<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="6279ffa4297b30182dc5202b001cb1dfc83a3bb5" translate="yes" xml:space="preserve">
          <source>Strategy: Find the block with the lowest address satisfying the requested block size.</source>
          <target state="translated">策略。找到地址最低的区块,满足要求的区块大小。</target>
        </trans-unit>
        <trans-unit id="fd04785e47c956a9f5fba602264a5dd14a34605a" translate="yes" xml:space="preserve">
          <source>Strategy: Find the smallest block satisfying the requested block size.</source>
          <target state="translated">策略。找出满足所要求的最小的块。</target>
        </trans-unit>
        <trans-unit id="44a887b6549779200c93196b47117dc9e9fd22f9" translate="yes" xml:space="preserve">
          <source>Strategy: Find the smallest block satisfying the requested block size. If multiple blocks are found, choose the one with the lowest address.</source>
          <target state="translated">策略。找出满足要求的最小的块。如果找到多个区块,则选择地址最小的一个。</target>
        </trans-unit>
        <trans-unit id="657b8318e9423de7a8d3e2e9ef2f190f7d6a01fe" translate="yes" xml:space="preserve">
          <source>Strategy: Try to find the best fit, but settle for the best fit found during a limited search.</source>
          <target state="translated">战略:试图找到最合适的人选,但要在有限的搜索中找到最合适的人选。尽量找到最合适的,但要在有限的搜索中找到最合适的。</target>
        </trans-unit>
        <trans-unit id="5fcdff9196474123b66108d821dc8c835b72a528" translate="yes" xml:space="preserve">
          <source>Stream number (0-base) within the association to send the messages through;</source>
          <target state="translated">协会内发送消息的流号(0-base)。</target>
        </trans-unit>
        <trans-unit id="032322e337daa5362eff97379f0768caa1c4a70b" translate="yes" xml:space="preserve">
          <source>Stream,</source>
          <target state="translated">Stream,</target>
        </trans-unit>
        <trans-unit id="14c7fe8eb4bedf847bae92f16bee1373dae3ee7d" translate="yes" xml:space="preserve">
          <source>Streams the body of a 200 or 206 response to the calling process or to a file. When streaming to the calling process using option &lt;code&gt;self&lt;/code&gt;, the following stream messages are sent to that process: &lt;code&gt;{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}}&lt;/code&gt;.</source>
          <target state="translated">将200或206响应的主体流式传输到调用过程或文件。当使用选项 &lt;code&gt;self&lt;/code&gt; 将数据流传输到调用流程时，以下流消息将发送到该流程： &lt;code&gt;{http, {RequestId, stream_start, Headers}}, {http, {RequestId, stream, BinBodyPart}}, and {http, {RequestId, stream_end, Headers}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a376bfef88f4a5837ec22e75ca9bb2ad71a85ca" translate="yes" xml:space="preserve">
          <source>Strict version control, i.e. when a message is received, verify that the version is that which was negotiated.</source>
          <target state="translated">严格的版本控制,即当收到消息时,验证版本是否是协商好的版本。</target>
        </trans-unit>
        <trans-unit id="48c954c05304b9e81c5d975679386755a836c64c" translate="yes" xml:space="preserve">
          <source>Strictly as it appears in the &lt;code&gt;boot script&lt;/code&gt;, or</source>
          <target state="translated">严格按照 &lt;code&gt;boot script&lt;/code&gt; 显示进行操作，或者</target>
        </trans-unit>
        <trans-unit id="9c8e1fe6c3b86d4950a4f14e9e1b7a58807d6feb" translate="yes" xml:space="preserve">
          <source>Strictly monotonically increasing values are inherently quite expensive to generate and scales poorly. This is because the values need to be synchronized between CPU cores. That is, do not pass the &lt;code&gt;monotonic&lt;/code&gt; modifier unless you really need strictly monotonically increasing values.</source>
          <target state="translated">严格单调增加的值在本质上非常昂贵，无法生成和缩放。这是因为值需要在CPU内核之间同步。也就是说，除非确实需要严格单调增加的值，否则不要通过 &lt;code&gt;monotonic&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="34e63cef9636b51db449734a3cb5f4c085f07fd5" translate="yes" xml:space="preserve">
          <source>String (is the same as a list of integers)</source>
          <target state="translated">字符串(与整数列表相同)</target>
        </trans-unit>
        <trans-unit id="d118085e29d4750504557a8145b47af2cb2659cf" translate="yes" xml:space="preserve">
          <source>String containing the user's password. Only used if the private keyfile is password-protected.</source>
          <target state="translated">包含用户密码的字符串。仅当私钥文件有密码保护时使用。</target>
        </trans-unit>
        <trans-unit id="59ef56804edeb88e3ae1bcc6b7e688b7402b030a" translate="yes" xml:space="preserve">
          <source>String does &lt;strong&gt;not&lt;/strong&gt; have a corresponding Erlang representation, but is an optimization for sending lists of bytes (integer in the range 0-255) more efficiently over the distribution. As field &lt;code&gt;Length&lt;/code&gt; is an unsigned 2 byte integer (big-endian), implementations must ensure that lists longer than 65535 elements are encoded as &lt;code&gt;&lt;a href=&quot;#LIST_EXT&quot;&gt;LIST_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">串并&lt;strong&gt;不&lt;/strong&gt;具有相应的Erlang表示，但对于在分布更有效地（在0-255范围内的整数）发送的字节列出的优化。由于字段 &lt;code&gt;Length&lt;/code&gt; 是一个无符号的2字节整数（big-endian），因此实现必须确保将长度超过65535个元素的列表编码为 &lt;code&gt;&lt;a href=&quot;#LIST_EXT&quot;&gt;LIST_EXT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="059d063f4edd2896cbea701659c169723f6c691b" translate="yes" xml:space="preserve">
          <source>String handling can be slow if done improperly. In Erlang, you need to think a little more about how the strings are used and choose an appropriate representation. If you use regular expressions, use the &lt;code&gt;re&lt;/code&gt; module in STDLIB instead of the obsolete &lt;code&gt;regexp&lt;/code&gt; module.</source>
          <target state="translated">如果处理不当，字符串处理会很慢。在Erlang中，您需要更多地考虑如何使用字符串并选择适当的表示形式。如果使用正则表达式，请使用STDLIB中的 &lt;code&gt;re&lt;/code&gt; 模块而不是过时的 &lt;code&gt;regexp&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="ab7791e7c77db49941bf49b683f3c9df1fec0bac" translate="yes" xml:space="preserve">
          <source>String processing functions.</source>
          <target state="translated">字符串处理功能。</target>
        </trans-unit>
        <trans-unit id="7073c72847419cc61b613d7b0ddbaa7534b00711" translate="yes" xml:space="preserve">
          <source>String | Binary (configurable)</source>
          <target state="translated">字符串 | 二进制(可配置</target>
        </trans-unit>
        <trans-unit id="74d55dbdca8b484ae2bf6a9ace6819676c736d3c" translate="yes" xml:space="preserve">
          <source>Strings are enclosed in double quotes (&quot;), but is not a data type in Erlang. Instead, a string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; is shorthand for the list &lt;code&gt;[$h,$e,$l,$l,$o]&lt;/code&gt;, that is, &lt;code&gt;[104,101,108,108,111]&lt;/code&gt;.</source>
          <target state="translated">字符串用双引号（&amp;ldquo;），但不是在二郎一个数据类型，而是一个字符串 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 是列表速记 &lt;code&gt;[$h,$e,$l,$l,$o]&lt;/code&gt; ，即， &lt;code&gt;[104,101,108,108,111]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38229828f5ce707e9c637d7e4f9c75370c8f2483" translate="yes" xml:space="preserve">
          <source>Strings in the template are printed literally.</source>
          <target state="translated">模板中的字符串是按字面意思打印的。</target>
        </trans-unit>
        <trans-unit id="f9dab1696115bedd1587cdcd962fbaa87eb8dd52" translate="yes" xml:space="preserve">
          <source>Strings starting with &lt;code&gt;&quot;'@&lt;/code&gt;, for example &lt;code&gt;&quot;'@File&quot;&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;&quot;'@&lt;/code&gt; 开头的字符串，例如 &lt;code&gt;&quot;'@File&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57df87fb39970ecfe64667610e08517b0f8ba060" translate="yes" xml:space="preserve">
          <source>Strings, other than &lt;code&gt;&quot;Z&quot;&lt;/code&gt;, &lt;code&gt;&quot;z&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt;, must be on the form &lt;code&gt;&amp;plusmn;[hh]:[mm]&lt;/code&gt;, for example &lt;code&gt;&quot;-02:00&quot;&lt;/code&gt; or &lt;code&gt;&quot;+00:00&quot;&lt;/code&gt;.</source>
          <target state="translated">除 &lt;code&gt;&quot;Z&quot;&lt;/code&gt; ， &lt;code&gt;&quot;z&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 之外的其他字符串必须采用 &lt;code&gt;&amp;plusmn;[hh]:[mm]&lt;/code&gt; 的形式，例如 &lt;code&gt;&quot;-02:00&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;+00:00&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5570cbce59d54b3e8e89f954758052e0ea23cd1" translate="yes" xml:space="preserve">
          <source>Stub module files are created for those modules that are to be exported by the target module (see options &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;stubs&lt;/code&gt; and &lt;code&gt;stub_dir&lt;/code&gt;).</source>
          <target state="translated">将为目标模块要导出的那些模块创建存根模块文件（请参阅选项 &lt;code&gt;export&lt;/code&gt; ， &lt;code&gt;stubs&lt;/code&gt; 和 &lt;code&gt;stub_dir&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="db2cf9d107c5a79e75ca3fa12c082098b033a749" translate="yes" xml:space="preserve">
          <source>Stub modules will automatically be created (see the &lt;code&gt;stubs&lt;/code&gt; and &lt;code&gt;stub_dir&lt;/code&gt; options below) for each module that is renamed. These can be used to redirect any calls still using the old module names. The stub files are created in the same directory as the source file (typically overwriting the original file).</source>
          <target state="translated">将为每个已重命名的模块自动创建存根模块（请参见下面的 &lt;code&gt;stubs&lt;/code&gt; 和 &lt;code&gt;stub_dir&lt;/code&gt; 选项）。这些可用于重定向仍使用旧模块名称的所有调用。存根文件与源文件位于同一目录中（通常会覆盖原始文件）。</target>
        </trans-unit>
        <trans-unit id="4ca257e1525674f4f984164e97623ebf24612def" translate="yes" xml:space="preserve">
          <source>Style sheets can also be installed on a per suite and per test case basis.</source>
          <target state="translated">样式表也可以在每个套件和每个测试用例的基础上安装。</target>
        </trans-unit>
        <trans-unit id="0e3cd3b3663e36b6010fa328e4878eaf1bb09c78" translate="yes" xml:space="preserve">
          <source>Sub-agents and dependencies</source>
          <target state="translated">次级代理和附属机构</target>
        </trans-unit>
        <trans-unit id="90d7d767804a80af239bef8ee766d71a4944c07e" translate="yes" xml:space="preserve">
          <source>Sub-agents are only needed if your application requires special support for distribution from the SNMP toolkit. A sub-agent can also be used if the application requires a more complex set transaction scheme than is found in the master agent.</source>
          <target state="translated">只有当您的应用程序需要从SNMP工具包中分发特殊支持时,才需要使用子代理。如果应用程序需要比主代理中更复杂的集合事务方案,也可以使用子代理。</target>
        </trans-unit>
        <trans-unit id="5055cc4d96f14720694a56d07a68ee7980c81af5" translate="yes" xml:space="preserve">
          <source>Sub-agents are used for the following reasons:</source>
          <target state="translated">使用副剂的原因如下:</target>
        </trans-unit>
        <trans-unit id="9b6045ebe7d947335fe83f7f64672894d696d0bd" translate="yes" xml:space="preserve">
          <source>Sub-agents can also have sub-agents. Each sub-agent can have an arbitrary number of child sub-agents registered, forming a hierarchy.</source>
          <target state="translated">子代理也可以有子代理。每个子代理可以有任意数量的子代理注册,形成一个层次结构。</target>
        </trans-unit>
        <trans-unit id="8ac63ce8e1d74adcfdfbe2ca29ab772206b57ae0" translate="yes" xml:space="preserve">
          <source>Subpatterns are delimited by parentheses (round brackets), which can be nested. Turning part of a pattern into a subpattern does two things:</source>
          <target state="translated">子模式以圆括号(圆括号)为界,可以进行嵌套。将一个模式的一部分变成子模式有两件事。</target>
        </trans-unit>
        <trans-unit id="a820e243668b15a93364d75cb27a52bf2716a1a1" translate="yes" xml:space="preserve">
          <source>Subscribe to &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; messages from a service.</source>
          <target state="translated">从服务订阅 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="49f060764145c09021e9ae846a9e90442c5fb5e4" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for both visible and hidden nodes. The tuple &lt;code&gt;{node_type, visible | hidden}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">订阅可见和隐藏节点的节点状态更改消息。元组 &lt;code&gt;{node_type, visible | hidden}&lt;/code&gt; 已包含在 &lt;code&gt;InfoList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="928a7f14face133bf1a5d5c5ab3ba7234d171192" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for hidden nodes only. The tuple &lt;code&gt;{node_type, hidden}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">订阅仅针对隐藏节点的节点状态更改消息。元组 &lt;code&gt;{node_type, hidden}&lt;/code&gt; 已包含在 &lt;code&gt;InfoList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8e29b065f6418ba8f113a030561ebffc2353317d" translate="yes" xml:space="preserve">
          <source>Subscribe to node status change messages for visible nodes only. The tuple &lt;code&gt;{node_type, visible}&lt;/code&gt; is included in &lt;code&gt;InfoList&lt;/code&gt;.</source>
          <target state="translated">订阅仅针对可见节点的节点状态更改消息。元组 &lt;code&gt;{node_type, visible}&lt;/code&gt; 包含在 &lt;code&gt;InfoList&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7eeb3cfb3316bcf069c616fd3d9feb459ed3e566" translate="yes" xml:space="preserve">
          <source>Subscriptions are not triggered and no checkpoints are updated, but this operation is blindingly fast. Disc resident tables are not to be updated with the &lt;code&gt;ets&lt;/code&gt; function, as the disc is not updated.</source>
          <target state="translated">不会触发订阅，也不会更新检查点，但是此操作非常快。光盘驻留表不使用 &lt;code&gt;ets&lt;/code&gt; 功能进行更新，因为未更新光盘。</target>
        </trans-unit>
        <trans-unit id="433c536aabeab0d4376379abd1511ea5ccc8273f" translate="yes" xml:space="preserve">
          <source>Subsequent calls to &lt;code&gt;allow/1&lt;/code&gt; will add the specified nodes to the list of allowed nodes. It is not possible to remove nodes from the list.</source>
          <target state="translated">随后对 &lt;code&gt;allow/1&lt;/code&gt; 的调用会将指定的节点添加到允许的节点列表中。无法从列表中删除节点。</target>
        </trans-unit>
        <trans-unit id="4b5948f4a8c2efd083dca1a5d8f87dd377c41053" translate="yes" xml:space="preserve">
          <source>Subsequent calls to this function overwrites previous data set. To update existing data instead of overwriting it, see &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">随后对该函数的调用将覆盖先前的数据集。要更新现有数据而不是覆盖现有数据，请参见 &lt;code&gt;&lt;a href=&quot;#update_process_metadata-1&quot;&gt;update_process_metadata/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b62f60ecebed480c0f7cf1234a4d74b31ff5ce6" translate="yes" xml:space="preserve">
          <source>Subsequently, these types can be used to specify types of record fields and also the argument and return types of functions.</source>
          <target state="translated">随后,这些类型可以用来指定记录字段的类型以及函数的参数和返回类型。</target>
        </trans-unit>
        <trans-unit id="cb7698f2ce2f777969263d3a8ba0cef76e027f42" translate="yes" xml:space="preserve">
          <source>Subsets of test cases, called test case groups, can also be defined. A test case group can have execution properties associated with it. Execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is to be repeated. Test case groups can also be nested (that is, a group can, besides test cases, contain subgroups).</source>
          <target state="translated">测试用例的子集,称为测试用例组,也可以被定义。一个测试用例组可以有与之相关的执行属性。执行属性指定了测试用例组中的测试用例是按随机顺序、并行还是顺序执行,以及测试用例组的执行是否会被重复。测试用例组也可以嵌套(也就是说,一个组除了测试用例之外,还可以包含子组)。</target>
        </trans-unit>
        <trans-unit id="2a8724dcdb51c1cfe957da926417b908e509eba3" translate="yes" xml:space="preserve">
          <source>Substitute metavariables in a pattern or list of patterns, yielding a syntax tree or list of trees as result. Both for normal metavariables and glob metavariables, the substituted value may be a single element or a list of elements. For example, if a list representing &lt;code&gt;1, 2, 3&lt;/code&gt; is substituted for &lt;code&gt;var&lt;/code&gt; in either of &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; or &lt;code&gt;[foo, _@var, bar]&lt;/code&gt;, the result represents &lt;code&gt;[foo, 1, 2, 3, bar]&lt;/code&gt;.</source>
          <target state="translated">将metavariables替换为模式或模式列表，从而产生语法树或树列表。对于普通的元变量和全局元变量，替换值都可以是单个元素或元素列表。例如，如果用 &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; 或 &lt;code&gt;[foo, _@var, bar]&lt;/code&gt; 中的任意一个表示 &lt;code&gt;1, 2, 3&lt;/code&gt; 的列表替换 &lt;code&gt;var&lt;/code&gt; ，则结果表示 &lt;code&gt;[foo, 1, 2, 3, bar]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05ffcb976452c5c75ac29c7a75347990e68c424b" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;%FINAL_ROOTDIR%&lt;/code&gt; and &lt;code&gt;%EMU%&lt;/code&gt; for &lt;code&gt;/usr/local/erl-target&lt;/code&gt; and &lt;code&gt;beam&lt;/code&gt;, respectively, in the files &lt;code&gt;erl.src&lt;/code&gt;, &lt;code&gt;start.src&lt;/code&gt;, and &lt;code&gt;start_erl.src&lt;/code&gt; of the target &lt;code&gt;erts-5.10.4/bin&lt;/code&gt; directory, and puts the resulting files &lt;code&gt;erl&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;run_erl&lt;/code&gt; in the target &lt;code&gt;bin&lt;/code&gt; directory.</source>
          <target state="translated">在目标 &lt;code&gt;erts-5.10.4/bin&lt;/code&gt; 目录的 &lt;code&gt;erl.src&lt;/code&gt; ， &lt;code&gt;start.src&lt;/code&gt; 和 &lt;code&gt;start_erl.src&lt;/code&gt; 文件中分别将 &lt;code&gt;%FINAL_ROOTDIR%&lt;/code&gt; 和 &lt;code&gt;%EMU%&lt;/code&gt; 分别替换为 &lt;code&gt;/usr/local/erl-target&lt;/code&gt; 和 &lt;code&gt;beam&lt;/code&gt; 。将生成的文件 &lt;code&gt;erl&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;run_erl&lt;/code&gt; 放入目标 &lt;code&gt;bin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="bc3669ecd23d63b80d0c44dfa313091853f8eced" translate="yes" xml:space="preserve">
          <source>Substitutes keys of boolean-valued properties and simultaneously negates their values. For each entry in &lt;code&gt;ListIn&lt;/code&gt;, if it is associated with some key &lt;code&gt;K1&lt;/code&gt; such that &lt;code&gt;{K1, K2}&lt;/code&gt; occurs in &lt;code&gt;Negations&lt;/code&gt;: if the entry was &lt;code&gt;{K1, true}&lt;/code&gt;, it is replaced with &lt;code&gt;{K2, false}&lt;/code&gt;, otherwise with &lt;code&gt;{K2, true}&lt;/code&gt;, thus changing the name of the option and simultaneously negating the value specified by &lt;code&gt;&lt;a href=&quot;#get_bool-2&quot;&gt;get_bool(Key,ListIn)&lt;/a&gt;&lt;/code&gt;. If the same &lt;code&gt;K1&lt;/code&gt; occurs more than once in &lt;code&gt;Negations&lt;/code&gt;, only the first occurrence is used.</source>
          <target state="translated">替换布尔值属性的键，同时取反它们的值。对于 &lt;code&gt;ListIn&lt;/code&gt; 中的每个条目，如果它与某个键 &lt;code&gt;K1&lt;/code&gt; 关联，使得 &lt;code&gt;{K1, K2}&lt;/code&gt; 出现在 &lt;code&gt;Negations&lt;/code&gt; 中：如果该条目为 &lt;code&gt;{K1, true}&lt;/code&gt; ，则将其替换为 &lt;code&gt;{K2, false}&lt;/code&gt; ，否则将其替换为 &lt;code&gt;{K2, true}&lt;/code&gt; ，从而更改选项的名称，同时取反 &lt;code&gt;&lt;a href=&quot;#get_bool-2&quot;&gt;get_bool(Key,ListIn)&lt;/a&gt;&lt;/code&gt; 指定的值。如果在 &lt;code&gt;Negations&lt;/code&gt; 同一 &lt;code&gt;K1&lt;/code&gt; 出现多次，则仅使用第一次出现。</target>
        </trans-unit>
        <trans-unit id="1e27236324c145734276c060f10c3123a295b532" translate="yes" xml:space="preserve">
          <source>Substitutes keys of properties. For each entry in &lt;code&gt;ListIn&lt;/code&gt;, if it is associated with some key &lt;code&gt;K1&lt;/code&gt; such that &lt;code&gt;{K1, K2}&lt;/code&gt; occurs in &lt;code&gt;Aliases&lt;/code&gt;, the key of the entry is changed to &lt;code&gt;K2&lt;/code&gt;. If the same &lt;code&gt;K1&lt;/code&gt; occurs more than once in &lt;code&gt;Aliases&lt;/code&gt;, only the first occurrence is used.</source>
          <target state="translated">替换属性的键。对于 &lt;code&gt;ListIn&lt;/code&gt; 中的每个条目，如果它与某个键 &lt;code&gt;K1&lt;/code&gt; 关联，从而在 &lt;code&gt;Aliases&lt;/code&gt; 出现 &lt;code&gt;{K1, K2}&lt;/code&gt; ，则该条目的键将更改为 &lt;code&gt;K2&lt;/code&gt; 。如果相同的 &lt;code&gt;K1&lt;/code&gt; 在 &lt;code&gt;Aliases&lt;/code&gt; 中多次出现，则仅使用第一次出现。</target>
        </trans-unit>
        <trans-unit id="42a8f651d79fd005eeac0612df6442b983a01184" translate="yes" xml:space="preserve">
          <source>Success</source>
          <target state="translated">Success</target>
        </trans-unit>
        <trans-unit id="80c7261dc13f63e8ac3c5ef932b61d4d0f95604d" translate="yes" xml:space="preserve">
          <source>Success | {error, term()}</source>
          <target state="translated">成功|{error,term()}。</target>
        </trans-unit>
        <trans-unit id="8a0a4ea66889be40114ddfe9594dd7d12e174b44" translate="yes" xml:space="preserve">
          <source>Successful evaluations of the timer functions give return values containing a timer reference, denoted &lt;code&gt;TRef&lt;/code&gt;. By using &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;, the returned reference can be used to cancel any requested action. A &lt;code&gt;TRef&lt;/code&gt; is an Erlang term, which contents must not be changed.</source>
          <target state="translated">计时器功能的成功评估会给出包含计时器参考的返回值，表示为 &lt;code&gt;TRef&lt;/code&gt; 。通过使用 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; ，返回的引用可以用于取消任何请求的操作。一个 &lt;code&gt;TRef&lt;/code&gt; 是Erlang项，其内容不得更改。</target>
        </trans-unit>
        <trans-unit id="06863fc24f520b1140c18c4fa8cbe27b0b51428c" translate="yes" xml:space="preserve">
          <source>Such an application is called a &lt;strong&gt;distributed application&lt;/strong&gt;. Notice that it is the control of the application that is distributed. All applications can be distributed in the sense that they, for example, use services on other nodes.</source>
          <target state="translated">这样的应用程序称为&lt;strong&gt;分布式应用程序&lt;/strong&gt;。注意，分发的是应用程序的控件。可以在某种意义上分配所有应用程序，例如，它们使用其他节点上的服务。</target>
        </trans-unit>
        <trans-unit id="c3074117af859e520c7cb63eb135640878edd509" translate="yes" xml:space="preserve">
          <source>Such an argument line must start with &lt;code&gt;%%!&lt;/code&gt; and the remaining line is interpreted as arguments to the emulator.</source>
          <target state="translated">这样的参数行必须以 &lt;code&gt;%%!&lt;/code&gt; 开头！其余的行将解释为仿真器的参数。</target>
        </trans-unit>
        <trans-unit id="0798de14385866f626c39da2456b2b12c915aee8" translate="yes" xml:space="preserve">
          <source>Such code is difficult to read and understand, and errors occur if the numbering of the elements in the tuple is wrong. If the data representation of the fields is changed, by re-ordering, adding, or removing fields, all references to the person tuple must be checked and possibly modified.</source>
          <target state="translated">这样的代码很难阅读和理解,如果元组中元素的编号错误,就会出现错误。如果通过重新排序、增加或删除字段来改变字段的数据表示方式,则必须检查并可能修改对人元组的所有引用。</target>
        </trans-unit>
        <trans-unit id="f433654caeb1dadceed6f988cc45cba92d4659f9" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for dirty CPU scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 40 kilowords.</source>
          <target state="translated">建议的堆栈大小,以千字为单位,用于肮脏的CPU调度线程。有效范围是20-8192千字。默认的建议堆栈大小是40千字。</target>
        </trans-unit>
        <trans-unit id="af6be2dcf5716a0725659c157d5e2c536263c156" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for dirty IO scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 40 kilowords.</source>
          <target state="translated">建议的堆栈大小,以千字为单位,用于脏IO调度线程。有效范围是20-8192千字。默认的建议堆栈大小是40千字。</target>
        </trans-unit>
        <trans-unit id="bcf432451d4daca2de4246fc100508b99bcd1023" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for scheduler threads. Valid range is 20-8192 kilowords. The default suggested stack size is 128 kilowords.</source>
          <target state="translated">调度器线程的建议堆栈大小,以千字数为单位,有效范围是20-8192千字。有效范围是20-8192千字。默认的建议堆栈大小是128千字。</target>
        </trans-unit>
        <trans-unit id="b8bd14d1892c2129895ed57dfa2db4ceb46d0dc7" translate="yes" xml:space="preserve">
          <source>Suggested stack size, in kilowords, for threads in the async thread pool. Valid range is 16-8192 kilowords. The default suggested stack size is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the number of async threads can be large. The default size is enough for drivers delivered with Erlang/OTP, but might not be large enough for other dynamically linked-in drivers that use the &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;driver_async()&lt;/a&gt;&lt;/code&gt; functionality. Notice that the value passed is only a suggestion, and it can even be ignored on some platforms.</source>
          <target state="translated">异步线程池中线程的建议堆栈大小（以千字为单位）。有效范围是16-8192千字。建议的默认堆栈大小为16 KB，在32位体系结构上为64 KB。由于异步线程的数量可能很大，因此选择了此较小的默认大小。对于与Erlang / OTP一起提供的驱动程序，默认大小已足够，但对于使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;driver_async()&lt;/a&gt;&lt;/code&gt; 功能的其他动态链接的驱动程序，默认大小可能不够大。请注意，传递的值仅是一个建议，在某些平台上甚至可以忽略。</target>
        </trans-unit>
        <trans-unit id="da7ae3ce7097a50ecd686c674729f1c7303f10ff" translate="yes" xml:space="preserve">
          <source>Suite level configuration function, executed after the last test case. (Optional)</source>
          <target state="translated">套件级配置功能,在最后一个测试用例后执行。(可选)</target>
        </trans-unit>
        <trans-unit id="2b05185a141699c8f8fb351934189959847a1edf" translate="yes" xml:space="preserve">
          <source>Suite level configuration function, executed before the first test case. (Optional)</source>
          <target state="translated">套件级配置功能,在第一个测试用例之前执行。(可选)</target>
        </trans-unit>
        <trans-unit id="04518d1a0192d1131132db139b0e5008f6d17e70" translate="yes" xml:space="preserve">
          <source>Suite-related information is sent to the major log file.</source>
          <target state="translated">与套装相关的信息被发送到主要的日志文件中。</target>
        </trans-unit>
        <trans-unit id="a5a27f3edcde9ae36844a365f84f2f1240d62f6e" translate="yes" xml:space="preserve">
          <source>Suites (&lt;code&gt;*_SUITE.erl&lt;/code&gt;) files must be stored in &lt;code&gt;TestDir&lt;/code&gt; or &lt;code&gt;TestDir/test&lt;/code&gt;. All suites are compiled when the test is run.</source>
          <target state="translated">套件（ &lt;code&gt;*_SUITE.erl&lt;/code&gt; ）文件必须存储在 &lt;code&gt;TestDir&lt;/code&gt; 或 &lt;code&gt;TestDir/test&lt;/code&gt; 中。运行测试时，将编译所有套件。</target>
        </trans-unit>
        <trans-unit id="378fda76844d25f760b8a3232570c6811c1f60f2" translate="yes" xml:space="preserve">
          <source>Summary of options not previously described for function &lt;code&gt;run/3&lt;/code&gt;:</source>
          <target state="translated">功能 &lt;code&gt;run/3&lt;/code&gt; 先前未描述的选项摘要：</target>
        </trans-unit>
        <trans-unit id="2270dca3d5a482193570efd95b8b721376d2e899" translate="yes" xml:space="preserve">
          <source>Summary of options:</source>
          <target state="translated">备选方案摘要:</target>
        </trans-unit>
        <trans-unit id="f1ea23086ee2ae5acc3750e0b83a8ad5e05aec73" translate="yes" xml:space="preserve">
          <source>Summary of the options:</source>
          <target state="translated">备选方案摘要:</target>
        </trans-unit>
        <trans-unit id="68214c5d6d790a263205249ceaedff42f792b42f" translate="yes" xml:space="preserve">
          <source>Summing the elements in a list and double them at the same time:</source>
          <target state="translated">对列表中的元素进行求和,并同时将其翻倍。</target>
        </trans-unit>
        <trans-unit id="03121a488934e060630fcbde75ce3dedf8aac8f2" translate="yes" xml:space="preserve">
          <source>Sun's Java JDK 1.6.0 or later. Our Java code (jinterface, ic) is written for JDK 1.6.0. Get it for Windows and install it, the JRE is not enough. If you don't care about Java, you can skip this step. The result will be that jinterface is not built.</source>
          <target state="translated">Sun公司的Java JDK 1.6.0或更高版本。我们的Java代码(jinterface,ic)是为JDK 1.6.0编写的。买来Windows版的,然后安装它,JRE是不够的。如果你不关心Java,可以跳过这一步。结果会导致jinterface无法构建。</target>
        </trans-unit>
        <trans-unit id="14bb55d7d7430a4e707657bbba24d20d9e03a1c8" translate="yes" xml:space="preserve">
          <source>Sundanese</source>
          <target state="translated">Sundanese</target>
        </trans-unit>
        <trans-unit id="80226badb4fe578fcd3821c9a1fd88e31eb75b5b" translate="yes" xml:space="preserve">
          <source>Supervision of Erlang/OTP</source>
          <target state="translated">对Erlang/OTP的监督</target>
        </trans-unit>
        <trans-unit id="829f8d39f75c9bc9f969226bb510126e3c23e139" translate="yes" xml:space="preserve">
          <source>Supervision of a node being started using internal callback functions. Used to prevent hanging nodes. (Configurable.)</source>
          <target state="translated">使用内部回调函数对正在启动的节点进行监督。用于防止挂起节点。(可配置。)</target>
        </trans-unit>
        <trans-unit id="924f7769a101580d991ad9414eee8efcbffebbdb" translate="yes" xml:space="preserve">
          <source>Supervisor - skeleton for the OTP supervisor behavior</source>
          <target state="translated">监理--OTP监理行为的骨架</target>
        </trans-unit>
        <trans-unit id="323811135ee8c95f4855f00e4ef8542d2be8796b" translate="yes" xml:space="preserve">
          <source>Supervisor Bridge - skeleton for the OTP supervisor bridge behavior</source>
          <target state="translated">监理桥--OTP监理桥行为的骨架。</target>
        </trans-unit>
        <trans-unit id="da3aea84a47845aadb4debb823b5071baf475b58" translate="yes" xml:space="preserve">
          <source>Supervisor report</source>
          <target state="translated">监事报告</target>
        </trans-unit>
        <trans-unit id="87df9f02b7ab7494841fbdf4d8bc6ea62d2782fd" translate="yes" xml:space="preserve">
          <source>Supervisor reports and crash reports are issued as &lt;code&gt;error&lt;/code&gt; level log events, and are logged through the default handler started by Kernel.</source>
          <target state="translated">主管报告和崩溃报告以 &lt;code&gt;error&lt;/code&gt; 级别日志事件的形式发布，并通过内核启动的默认处理程序进行记录。</target>
        </trans-unit>
        <trans-unit id="8134165a77d04e2d6551122c49e5bdd280bc54b0" translate="yes" xml:space="preserve">
          <source>Supervisor reports, crash reports, and progress reports are no longer connected to the SASL application.</source>
          <target state="translated">主管报告、崩溃报告和进度报告不再与SASL应用连接。</target>
        </trans-unit>
        <trans-unit id="9969a639fd5f6ed1ac8b07340d0c05f6c0b8953c" translate="yes" xml:space="preserve">
          <source>Supervisors are processes that monitor the behaviour of workers. A supervisor can restart a worker if something goes wrong.</source>
          <target state="translated">监督员是监督工人行为的过程。如果出现问题,监督员可以重新启动工人。</target>
        </trans-unit>
        <trans-unit id="1b867b17045f3842a273db8cba0550b3d1ac6614" translate="yes" xml:space="preserve">
          <source>Support all platforms that implement DTrace: OS X, Solaris, and (I hope) FreeBSD and NetBSD.</source>
          <target state="translated">支持所有实现 DTrace 的平台。OS X,Solaris,以及(我希望)FreeBSD和NetBSD。</target>
        </trans-unit>
        <trans-unit id="69fe8cf7ba05f1cc818c0855d845cf60eed872f5" translate="yes" xml:space="preserve">
          <source>Support for CGI-1.1 is implemented in accordance with &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;RFC 3875&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对CGI-1.1的支持是根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3875.txt&quot;&gt;RFC 3875&lt;/a&gt;&lt;/code&gt; 实现的。</target>
        </trans-unit>
        <trans-unit id="cab27f867ed7b84d1da4274c9b4c8a517efc3269" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 encoded atoms in the external format has been available since ERTS 5.10 (OTP R16). This abillity allows such old nodes to decode, store and encode any Unicode atoms received from a new OTP 20 node.</source>
          <target state="translated">自ERTS 5.10(OTP R16)以来,外部格式中对UTF-8编码原子的支持一直存在。这种能力允许这些旧节点对从新的OTP 20节点接收到的任何Unicode原子进行解码、存储和编码。</target>
        </trans-unit>
        <trans-unit id="193baef9a2c52722bfd0c24ca1ca0d35adeafcf4" translate="yes" xml:space="preserve">
          <source>Support for Unicode is increasing throughout the world of computing, as the benefits of one common character set are overwhelming when programs are used in a global environment. Along with the base of the standard, the code points for all the scripts, some &lt;strong&gt;encoding standards&lt;/strong&gt; are available.</source>
          <target state="translated">随着在全球环境中使用程序时，一个通用字符集的好处不堪重负，在整个计算世界中，对Unicode的支持正在增加。除了标准的基础，所有脚本的代码点之外，还提供了一些&lt;strong&gt;编码标准&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8f1a1f5f1f39e75130f9a4b8fb8862e77cf4de40" translate="yes" xml:space="preserve">
          <source>Support for alternative service discovery mechanisms was added in Erlang/OTP 21.</source>
          <target state="translated">在Erlang/OTP 21中增加了对替代服务发现机制的支持。</target>
        </trans-unit>
        <trans-unit id="1d962630c5d6ce765c1eae0f7d5dc468e364cb4b" translate="yes" xml:space="preserve">
          <source>Support for the following encoding rules:</source>
          <target state="translated">支持以下编码规则:</target>
        </trans-unit>
        <trans-unit id="cf1c782df2c96e8282de7b476d79cc67e49828fb" translate="yes" xml:space="preserve">
          <source>Support for time measurement in NIF libraries:</source>
          <target state="translated">支持NIF库中的时间测量。</target>
        </trans-unit>
        <trans-unit id="4c3f03f63be41e2febacf4326efd1546b9941350" translate="yes" xml:space="preserve">
          <source>Support for time measurement in drivers:</source>
          <target state="translated">支持驱动程序中的时间测量。</target>
        </trans-unit>
        <trans-unit id="dc296a0486ec5f87002aad7f28ba0562ca867666" translate="yes" xml:space="preserve">
          <source>Support functions for property lists.</source>
          <target state="translated">支持财产清单的功能。</target>
        </trans-unit>
        <trans-unit id="93baf438b0613f3c74f0fdc2ba5aba73338aaf24" translate="yes" xml:space="preserve">
          <source>Support functions for test suite authors</source>
          <target state="translated">对测试套件作者的支持功能</target>
        </trans-unit>
        <trans-unit id="76ec5026dd3939812f4e93c176c2a0f384d8c0e6" translate="yes" xml:space="preserve">
          <source>Support libraries contain functions that are useful for all test suites, or for test suites in a specific functional area or subsystem. In addition to the general support libraries provided by the &lt;code&gt;Common Test&lt;/code&gt; framework, and the various libraries and applications provided by Erlang/OTP, there can also be a need for customized (user specific) support libraries.</source>
          <target state="translated">支持库包含对所有测试套件或特定功能区域或子系统中的测试套件有用的功能。除了 &lt;code&gt;Common Test&lt;/code&gt; 框架提供的常规支持库以及Erlang / OTP提供的各种库和应用程序之外，还需要定制的（用户特定的）支持库。</target>
        </trans-unit>
        <trans-unit id="0362ec0d097a5a157104529b450e00204f9cbbb5" translate="yes" xml:space="preserve">
          <source>Support library for abstract Erlang syntax trees.</source>
          <target state="translated">支持抽象的 Erlang 语法树的库。</target>
        </trans-unit>
        <trans-unit id="e9eea1dd92def1101125de3b37a7409d58a3f281" translate="yes" xml:space="preserve">
          <source>Support the &lt;code&gt;sys&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#debug&quot;&gt;debug facilities&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">支持 &lt;code&gt;sys&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#debug&quot;&gt;debug facilities&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95c22864cfced2306503ecdcaa13a389468c1121" translate="yes" xml:space="preserve">
          <source>Support was added for normalizations forms in &lt;code&gt;unicode&lt;/code&gt; and the &lt;code&gt;string&lt;/code&gt; module now handles utf8-encoded binaries.</source>
          <target state="translated">在 &lt;code&gt;unicode&lt;/code&gt; 中添加了对规范化表单的支持， &lt;code&gt;string&lt;/code&gt; 模块现在可以处理utf8编码的二进制文件。</target>
        </trans-unit>
        <trans-unit id="8c3d6e2b0c4b55646256fe3e98da277b50ee5de3" translate="yes" xml:space="preserve">
          <source>Supported cipher suites. The function &lt;code&gt;cipher_suites/0&lt;/code&gt; can be used to find all ciphers that are supported by default. &lt;code&gt;cipher_suites(all)&lt;/code&gt; can be called to find all available cipher suites. Pre-Shared Key (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4279.txt&quot;&gt;RFC 4279&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5487.txt&quot;&gt;RFC 5487&lt;/a&gt;&lt;/code&gt;), Secure Remote Password (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5054.txt&quot;&gt;RFC 5054&lt;/a&gt;&lt;/code&gt;), RC4 cipher suites, and anonymous cipher suites only work if explicitly enabled by this option; they are supported/enabled by the peer also. Anonymous cipher suites are supported for testing purposes only and are not be used when security matters.</source>
          <target state="translated">支持的密码套件。函数 &lt;code&gt;cipher_suites/0&lt;/code&gt; 可用于查找默认情况下支持的所有密码。可以调用 &lt;code&gt;cipher_suites(all)&lt;/code&gt; 来查找所有可用的密码套件。仅当此选项明确启用时，预共享密钥（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4279.txt&quot;&gt;RFC 4279&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5487.txt&quot;&gt;RFC 5487&lt;/a&gt;&lt;/code&gt; ），安全远程密码（ &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5054.txt&quot;&gt;RFC 5054&lt;/a&gt;&lt;/code&gt; ），RC4密码套件和匿名密码套件才有效。对方也支持/启用它们。支持仅用于测试目的的匿名密码套件，在安全性很重要的情况下不使用匿名密码套件。</target>
        </trans-unit>
        <trans-unit id="6ace0dceed0dc79156d544bb1e740bd6e2e4245f" translate="yes" xml:space="preserve">
          <source>Supported option: &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8862943cc8300abfb1bde27326d75dc9a30f07d9" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-D&lt;/code&gt; ， &lt;code&gt;-v&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; ， &lt;code&gt;-b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b18222290f4691ea2e1803f27d33f984dc4fed35" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="611e3fc6659a77f464d1ef09b1a3f966abeee562" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13af750ddec082e015f88004babe3e1a9cbf2249" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee8aa3fc6cd2da1cc08dd61046fb6b0ad0efa14b" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-v&lt;/code&gt; ， &lt;code&gt;-I&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9956c47dfedf732cac76d6c7cf8152d9c9559ea6" translate="yes" xml:space="preserve">
          <source>Supported options: &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-v&lt;/code&gt;.</source>
          <target state="translated">支持的选项： &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6162eeb9b9f8ad636a290938543b85a83786b99" translate="yes" xml:space="preserve">
          <source>Supported options: same as for &lt;code&gt;.erl&lt;/code&gt;.</source>
          <target state="translated">支持的选项：与 &lt;code&gt;.erl&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="002fcc7d4fbae71f711cdd87becc1cce73be8aaf" translate="yes" xml:space="preserve">
          <source>Supported time unit representations:</source>
          <target state="translated">支持的时间单位表示法。</target>
        </trans-unit>
        <trans-unit id="ae00ef55d1dcfbb028df51241440b188a57ac58d" translate="yes" xml:space="preserve">
          <source>Supported-Vendor-Id AVP</source>
          <target state="translated">支持-供应商-ID AVP</target>
        </trans-unit>
        <trans-unit id="e769daffee112f18015a5281f7f10cc6e2232070" translate="yes" xml:space="preserve">
          <source>Supports automatic repair of log files that are not properly closed and enables efficient reading of logged items in &lt;strong&gt;chunks&lt;/strong&gt; using a set of functions defined in this module. This is the only way to read internally formatted logs. An item logged to an internally formatted log must not occupy more than 4 GB of disk space (the size must fit in 4 bytes).</source>
          <target state="translated">支持自动修复未正确关闭的日志文件，并可以使用此模块中定义的一组功能来高效地读取&lt;strong&gt;块中&lt;/strong&gt;的已记录项目。这是读取内部格式化日志的唯一方法。记录到内部格式化日志中的项目不得占用超过4 GB的磁盘空间（大小必须适合4个字节）。</target>
        </trans-unit>
        <trans-unit id="cbbfa591a4b290b4ae62ef1ecc1698736ec6299b" translate="yes" xml:space="preserve">
          <source>Supports calling Erlang functions on remote nodes. &lt;code&gt;ei_rpc_to()&lt;/code&gt; sends an RPC request to a remote node and &lt;code&gt;ei_rpc_from()&lt;/code&gt; receives the results of such a call. &lt;code&gt;ei_rpc()&lt;/code&gt; combines the functionality of these two functions by sending an RPC request and waiting for the results. See also &lt;code&gt;rpc:call/4&lt;/code&gt; in Kernel.</source>
          <target state="translated">支持在远程节点上调用Erlang函数。 &lt;code&gt;ei_rpc_to()&lt;/code&gt; 向远程节点发送RPC请求，而 &lt;code&gt;ei_rpc_from()&lt;/code&gt; 接收此调用的结果。 &lt;code&gt;ei_rpc()&lt;/code&gt; 通过发送RPC请求并等待结果来结合这两个功能的功能。另请参见内核中的 &lt;code&gt;rpc:call/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa8c650384582fade821d1435197dd4d799e10f6" translate="yes" xml:space="preserve">
          <source>Supports calling Erlang functions on remote nodes. &lt;code&gt;erl_rpc_to()&lt;/code&gt; sends an RPC request to a remote node and &lt;code&gt;erl_rpc_from()&lt;/code&gt; receives the results of such a call. &lt;code&gt;erl_rpc()&lt;/code&gt; combines the functionality of these two functions by sending an RPC request and waiting for the results. See also &lt;code&gt;rpc:call/4&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">支持在远程节点上调用Erlang函数。 &lt;code&gt;erl_rpc_to()&lt;/code&gt; 向远程节点发送RPC请求，而 &lt;code&gt;erl_rpc_from()&lt;/code&gt; 接收此调用的结果。 &lt;code&gt;erl_rpc()&lt;/code&gt; 通过发送RPC请求并等待结果来结合这两个功能的功能。另见 &lt;code&gt;rpc:call/4&lt;/code&gt; 的 &lt;code&gt;Kernel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3811292723c6d7a387a20acab2375d3a48075ff" translate="yes" xml:space="preserve">
          <source>Suppose now that &lt;code&gt;cp2&lt;/code&gt; goes also down and does not restart within 5 seconds. &lt;code&gt;myapp&lt;/code&gt; is now restarted on &lt;code&gt;cp3&lt;/code&gt;.</source>
          <target state="translated">现在假设 &lt;code&gt;cp2&lt;/code&gt; 也关闭并且在5秒内没有重新启动。 &lt;code&gt;myapp&lt;/code&gt; 现在在 &lt;code&gt;cp3&lt;/code&gt; 上重新启动。</target>
        </trans-unit>
        <trans-unit id="c2a35d6565243a0a37ae621d98c111036eb6b54a" translate="yes" xml:space="preserve">
          <source>Suppose now that we call &lt;code&gt;set_lock_button&lt;/code&gt; while the door is open, and we have already postponed a button event that was the new lock button:</source>
          <target state="translated">现在假设我们在门打开时调用 &lt;code&gt;set_lock_button&lt;/code&gt; ，并且我们已经推迟了一个按钮事件，即新的锁定按钮：</target>
        </trans-unit>
        <trans-unit id="4f259e320457b94f7101d49c931d3f7e53c48f31" translate="yes" xml:space="preserve">
          <source>Suppose our client expects to connect to the web server https://www.example.net. This URI is therefore the Reference IDs of the client. The call will be:</source>
          <target state="translated">假设我们的客户端期望连接到Web服务器https://www.example.net。因此,这个URI就是客户端的Reference IDs。调用将是。</target>
        </trans-unit>
        <trans-unit id="f86d7a4fa0c16e05b4083974f68f3f6c6ca32ef5" translate="yes" xml:space="preserve">
          <source>Suppose you have the following private key and a corresponding public key:</source>
          <target state="translated">假设你有以下私钥和对应的公钥。</target>
        </trans-unit>
        <trans-unit id="161e2a3301f56050bd72a9a234717ac0bdcee365" translate="yes" xml:space="preserve">
          <source>Suppress erl and hrl generation, respectively.</source>
          <target state="translated">分别抑制erl和rl的产生。</target>
        </trans-unit>
        <trans-unit id="fd85d4a3e5b009ade7267fa909dd246107f8cd7a" translate="yes" xml:space="preserve">
          <source>Suppress warnings about behavior callbacks that drift from the published recommended interfaces.</source>
          <target state="translated">抑制对偏离已发布的推荐接口的行为回调的警告。</target>
        </trans-unit>
        <trans-unit id="658d4e7b1b098b27aa4e9901e6a6a91fde3e7e4d" translate="yes" xml:space="preserve">
          <source>Suppress warnings about behaviors that have no &lt;code&gt;-callback&lt;/code&gt; attributes for their callbacks.</source>
          <target state="translated">禁止显示有关其回调没有 &lt;code&gt;-callback&lt;/code&gt; 属性的行为的警告。</target>
        </trans-unit>
        <trans-unit id="99d8fcbfb989e4e7fda7c9452d49bb803228dd19" translate="yes" xml:space="preserve">
          <source>Suppress warnings about calls to missing functions.</source>
          <target state="translated">抑制对缺失函数调用的警告。</target>
        </trans-unit>
        <trans-unit id="f5f104449e97fb4d3d9fd5d369f54de49da0d189" translate="yes" xml:space="preserve">
          <source>Suppress warnings about invalid contracts.</source>
          <target state="translated">抑制对无效合同的警告。</target>
        </trans-unit>
        <trans-unit id="896f6537b177bdb199d5aeaf1e91ac70a0c3690d" translate="yes" xml:space="preserve">
          <source>Suppress warnings for construction of improper lists.</source>
          <target state="translated">制止对构建不当清单的警告。</target>
        </trans-unit>
        <trans-unit id="9e5a8003fe113325954491747d862630cd7a5e51" translate="yes" xml:space="preserve">
          <source>Suppress warnings for failing calls.</source>
          <target state="translated">抑制失败呼叫的警告。</target>
        </trans-unit>
        <trans-unit id="03070bddd1c1713fe09504f3e04390b0f76857ef" translate="yes" xml:space="preserve">
          <source>Suppress warnings for fun applications that will fail.</source>
          <target state="translated">抑制会失败的趣味应用的警告。</target>
        </trans-unit>
        <trans-unit id="e363bcef03fbcf4ab0a513ebe34c444e24468b1f" translate="yes" xml:space="preserve">
          <source>Suppress warnings for functions that will never return a value.</source>
          <target state="translated">抑制那些永远不会返回值的函数的警告。</target>
        </trans-unit>
        <trans-unit id="9e7a409dd7e022c1a6f54bf31cd4e3da6ea87e20" translate="yes" xml:space="preserve">
          <source>Suppress warnings for patterns that are unused or cannot match.</source>
          <target state="translated">对未使用或无法匹配的模式进行抑制警告。</target>
        </trans-unit>
        <trans-unit id="38c67ecef5210cce75595b7c59b94ce46cbf5939" translate="yes" xml:space="preserve">
          <source>Suppress warnings for unused functions.</source>
          <target state="translated">抑制未使用功能的警告。</target>
        </trans-unit>
        <trans-unit id="0e23a74a695d05be9cf7ca7b4cd92c59cd8c658c" translate="yes" xml:space="preserve">
          <source>Suppress warnings for violations of opacity of data types.</source>
          <target state="translated">抑制对违反数据类型不透明度的警告。</target>
        </trans-unit>
        <trans-unit id="00dba67736694228fe581698490416aec0e4a248" translate="yes" xml:space="preserve">
          <source>Suppresses the call statistics for each process from the analysis.</source>
          <target state="translated">抑制分析中每个进程的调用统计。</target>
        </trans-unit>
        <trans-unit id="5fe98e618f2833867a376cb98a815ac9ec990dd1" translate="yes" xml:space="preserve">
          <source>Suppresses the printing of callers and called information in the analysis.</source>
          <target state="translated">在分析中禁止打印来电和被叫信息。</target>
        </trans-unit>
        <trans-unit id="df8a60c08e48d602804f88560585bc9fbb66d14d" translate="yes" xml:space="preserve">
          <source>Suppresses the writing of a crash dump file entirely, thus rebooting the runtime system immediately. This is the same as not setting the environment variable.</source>
          <target state="translated">完全禁止写入崩溃转储文件,从而立即重启运行时系统。这和不设置环境变量是一样的。</target>
        </trans-unit>
        <trans-unit id="a988c8ef2b296fc0ea2e2d3047e7e09c23301de2" translate="yes" xml:space="preserve">
          <source>Supresses the totals section in the analysis, which is the default.</source>
          <target state="translated">隐藏分析中的总计部分,这是默认的。</target>
        </trans-unit>
        <trans-unit id="0ef25d72e538682415b03c36a263df0107df3d7d" translate="yes" xml:space="preserve">
          <source>Surefire XML can, for example, be used by Jenkins to display test results.</source>
          <target state="translated">例如,Surefire XML可以被Jenkins用来显示测试结果。</target>
        </trans-unit>
        <trans-unit id="b793def872c04362cbd57644640b08e1bf84da10" translate="yes" xml:space="preserve">
          <source>Surefire reports for EUnit (Format used by Maven and Atlassian Bamboo for example to integrate test results).</source>
          <target state="translated">EUnit的Surefire报告(例如Maven和Atlassian Bamboo用于整合测试结果的格式)。</target>
        </trans-unit>
        <trans-unit id="7631dc723852ac4b0bb4fd7d3058478eb65f5073" translate="yes" xml:space="preserve">
          <source>Surefire reports for EUnit (Format used by Maven and Atlassian Bamboo for example to integrate test results). Based on initial code from Paul Guyot.</source>
          <target state="translated">EUnit的Surefire报告(例如Maven和Atlassian Bamboo用于整合测试结果的格式)。基于Paul Guyot的初始代码。</target>
        </trans-unit>
        <trans-unit id="c948ea0246807256cf48a7cfaaf94b78e7b2095a" translate="yes" xml:space="preserve">
          <source>Surrogate</source>
          <target state="translated">Surrogate</target>
        </trans-unit>
        <trans-unit id="e9bce0f224084ad788d49010d7d7d29a8ae63144" translate="yes" xml:space="preserve">
          <source>Suspend the processes using the module (to avoid that they try to handle any requests before the code replacement is completed).</source>
          <target state="translated">暂停使用该模块的进程(以避免它们在代码替换完成之前尝试处理任何请求)。</target>
        </trans-unit>
        <trans-unit id="d39141a48920c1be93a6f36d09eebe0906941a82" translate="yes" xml:space="preserve">
          <source>Suspends the process calling this function for &lt;code&gt;Time&lt;/code&gt; milliseconds and then returns &lt;code&gt;ok&lt;/code&gt;, or suspends the process forever if &lt;code&gt;Time&lt;/code&gt; is the atom &lt;code&gt;infinity&lt;/code&gt;. Naturally, this function does &lt;strong&gt;not&lt;/strong&gt; return immediately.</source>
          <target state="translated">将调用此函数的过程暂停一段 &lt;code&gt;Time&lt;/code&gt; 毫秒为单位），然后返回 &lt;code&gt;ok&lt;/code&gt; ；如果 &lt;code&gt;Time&lt;/code&gt; 是atom &lt;code&gt;infinity&lt;/code&gt; ,则永远暂停该过程。当然，这个功能并&lt;strong&gt;没有&lt;/strong&gt;立即返回。</target>
        </trans-unit>
        <trans-unit id="a2e824b6e4f75be4a07d7079e9c06b0752d0649c" translate="yes" xml:space="preserve">
          <source>Suspends the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. The same as calling &lt;code&gt;&lt;a href=&quot;#suspend_process-2&quot;&gt;erlang:suspend_process(Suspendee, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">暂停被 &lt;code&gt;Suspendee&lt;/code&gt; 确定的过程。与调用 &lt;code&gt;&lt;a href=&quot;#suspend_process-2&quot;&gt;erlang:suspend_process(Suspendee, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d982fb65e6d52487c1ff358f3e710016d64e310b" translate="yes" xml:space="preserve">
          <source>Suspends the process. When the process is suspended, it only responds to other system messages, but not other messages.</source>
          <target state="translated">暂停进程。当进程被暂停时,它只响应其他系统消息,而不响应其他消息。</target>
        </trans-unit>
        <trans-unit id="4868e2fd51bda36328ddd3547e74c2e3f69d3c0e" translate="yes" xml:space="preserve">
          <source>Swaps places on &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space for ports and processes.</source>
          <target state="translated">交换将 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Id&lt;/code&gt; 空间放在端口和进程的位置。</target>
        </trans-unit>
        <trans-unit id="85a66af5fe9577ba36cb5dc160b5ab726c351f25" translate="yes" xml:space="preserve">
          <source>Switches off HTML enhancements that can be incompatible with older browsers.</source>
          <target state="translated">关闭可能与旧浏览器不兼容的HTML增强功能。</target>
        </trans-unit>
        <trans-unit id="f73cc71db4a1a943c0921fa8a5b8bb091227bf54" translate="yes" xml:space="preserve">
          <source>Syloti_Nagri</source>
          <target state="translated">Syloti_Nagri</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ff671c52be278a122290e8362f747edf95308739" translate="yes" xml:space="preserve">
          <source>Symbolic Links in --bindir</source>
          <target state="translated">--bindir中的符号链接</target>
        </trans-unit>
        <trans-unit id="38614ef7ffaabdccf540bb23f1bf4109a9456e2e" translate="yes" xml:space="preserve">
          <source>Symbolic links are not supported on this platform.</source>
          <target state="translated">本平台不支持符号链接。</target>
        </trans-unit>
        <trans-unit id="b2db0c5c047d755597fe723f5b3906e0e790e5fa" translate="yes" xml:space="preserve">
          <source>Symbolic names must be unique within a MIB and within a system.</source>
          <target state="translated">符号名称在MIB内和系统内必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="bc20e08aa6ee36e007fb8be42c9963c3987432d6" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the native time unit used by the Erlang runtime system.</source>
          <target state="translated">Erlang运行时系统使用的本地时间单位的符号表示。</target>
        </trans-unit>
        <trans-unit id="9c3de4c1d499b9c4d2940a999036876a992d4f1a" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the performance counter time unit used by the Erlang runtime system.</source>
          <target state="translated">Erlang运行时系统使用的性能计数器时间单位的符号表示。</target>
        </trans-unit>
        <trans-unit id="07800dda6fdaf0f476886edeef6a9aeb0d872f21" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000000000&lt;/code&gt;.</source>
          <target state="translated">时间单位的符号表示形式，由整数 &lt;code&gt;1000000000&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="2649cc9e01c228ec0f5a481c6b1745e523dc1efc" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000000&lt;/code&gt;.</source>
          <target state="translated">时间单位的符号表示形式，由整数 &lt;code&gt;1000000&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="b93ca2c4c24c9b54782ff7202cd91a428f51d3f7" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1000&lt;/code&gt;.</source>
          <target state="translated">时间单位的符号表示形式，由整数 &lt;code&gt;1000&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="9196744d900f2593e47a8bb8e5453768b4547c96" translate="yes" xml:space="preserve">
          <source>Symbolic representation of the time unit represented by the integer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">时间单位的符号表示形式，由整数 &lt;code&gt;1&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="fde31cc35fbdb6242bd81a4ff154a0d240c0fc6b" translate="yes" xml:space="preserve">
          <source>Symbols such as &lt;code&gt;'{'&lt;/code&gt;, &lt;code&gt;'.'&lt;/code&gt;, etc., have to be enclosed in single quotes when used as terminal or non-terminal symbols in grammar rules. The use of the symbols &lt;code&gt;'$empty'&lt;/code&gt;, &lt;code&gt;'$end'&lt;/code&gt;, and &lt;code&gt;'$undefined'&lt;/code&gt; should be avoided.</source>
          <target state="translated">诸如 &lt;code&gt;'{'&lt;/code&gt; ， &lt;code&gt;'.'&lt;/code&gt; 符号 等在语法规则中用作终端或非终端符号时，必须用单引号引起来。应避免使用符号 &lt;code&gt;'$empty'&lt;/code&gt; ， &lt;code&gt;'$end'&lt;/code&gt; 和 &lt;code&gt;'$undefined'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6c13be05542d397298f393613981e3279a425af" translate="yes" xml:space="preserve">
          <source>Symetric cipher algorithm used for the payload encryption. This algorithm will use the key calculated in the kex phase (together with other info) to genereate the actual key used. Examples are tripple-DES &lt;code&gt;'3des-cbc'&lt;/code&gt; and one of many AES variants &lt;code&gt;'aes192-ctr'&lt;/code&gt;.</source>
          <target state="translated">用于有效负载加密的对称密码算法。该算法将使用在kex阶段计算的密钥（以及其他信息）生成实际使用的密钥。例如三重DES'3des- &lt;code&gt;'3des-cbc'&lt;/code&gt; 和许多AES变体 &lt;code&gt;'aes192-ctr'&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="87f15c5c25b82750fdbe6837aad13a797f701d1e" translate="yes" xml:space="preserve">
          <source>Synchronization error during chunk sending according to one of the following:</source>
          <target state="translated">在分块发送过程中出现同步错误,符合以下情况之一。</target>
        </trans-unit>
        <trans-unit id="32b88210af732b7fa6f0597cd05eb328619f14e7" translate="yes" xml:space="preserve">
          <source>Synchronize (write to disc, if possible) the mib-server data. This depends on the &lt;code&gt;mib_storage&lt;/code&gt; option, and will only have an effect if the mib-storage option has an actual disc component (such as dets, or ets with a file).</source>
          <target state="translated">同步（如果可能，写入光盘）mib服务器数据。这取决于 &lt;code&gt;mib_storage&lt;/code&gt; 选项，并且仅当mib-storage选项具有实际的光盘组件（例如dets或带有文件的ets）时才会生效。</target>
        </trans-unit>
        <trans-unit id="312c1653b8bc7388af6f57b8ea1d1432ae577b59" translate="yes" xml:space="preserve">
          <source>Synchronize the mib-storage table.</source>
          <target state="translated">同步mib存储表。</target>
        </trans-unit>
        <trans-unit id="e07fb72859a7d37936b725af7a1d5239adfbbe40" translate="yes" xml:space="preserve">
          <source>Synchronized code replacement of processes using module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Mod&lt;/code&gt; 模块对进程进行同步代码替换。</target>
        </trans-unit>
        <trans-unit id="01a1092f1791521fc50b0a1a453d3d4948b7f226" translate="yes" xml:space="preserve">
          <source>Synchronizes the global name server with all nodes known to this node. These are the nodes that are returned from &lt;code&gt;erlang:nodes()&lt;/code&gt;. When this function returns, the global name server receives global information from all nodes. This function can be called when new nodes are added to the network.</source>
          <target state="translated">将全局名称服务器与该节点已知的所有节点同步。这些是从 &lt;code&gt;erlang:nodes()&lt;/code&gt; 返回的节点。当该函数返回时，全局名称服务器从所有节点接收全局信息。将新节点添加到网络时，可以调用此函数。</target>
        </trans-unit>
        <trans-unit id="89fe354cd7884bf36eefa9b3c8217acccc91948e" translate="yes" xml:space="preserve">
          <source>Synchronizes the group nodes, that is, the global name servers on the group nodes. Also checks the names globally registered in the current global group and unregisters them on any known node not part of the group.</source>
          <target state="translated">同步组节点,也就是组节点上的全局名称服务器。同时检查当前全局组中全局注册的名称,并在不属于组的任何已知节点上解除注册。</target>
        </trans-unit>
        <trans-unit id="07710d25b770f253a75d0aab226aa1ae135666c1" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">同步 &lt;code&gt;get-bulk-request&lt;/code&gt; （请参阅RFC1905）。</target>
        </trans-unit>
        <trans-unit id="f448ebbd4129a3291d4535aeab92c4cc47e4ddab" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">同步 &lt;code&gt;get-next-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b2b2fa27dbb4052bd3748ef0458bfd012b62beb" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">同步 &lt;code&gt;get-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e513e56abe4ab6731c1a205d51fc5b5980806174" translate="yes" xml:space="preserve">
          <source>Synchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">同步 &lt;code&gt;set-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33a68e25327ecc51a99120fe1d23ee0e50bf0b8b" translate="yes" xml:space="preserve">
          <source>Synchronously appends a list of items to the log. It is more efficient to use these functions instead of functions &lt;code&gt;log/2&lt;/code&gt; and &lt;code&gt;blog/2&lt;/code&gt;. The specified list is split into as large sublists as possible (limited by the size of wrap log files), and each sublist is logged as one single item, which reduces the overhead.</source>
          <target state="translated">同步将项目列表追加到日志。使用这些函数代替函数 &lt;code&gt;log/2&lt;/code&gt; 和 &lt;code&gt;blog/2&lt;/code&gt; 效率更高。将指定列表分成尽可能大的子列表（受包装日志文件的大小限制），并且每个子列表都记录为一个项目，从而减少了开销。</target>
        </trans-unit>
        <trans-unit id="089dc8c699a717858006211347bb6b82478e752b" translate="yes" xml:space="preserve">
          <source>Synchronously appends a term to a disk log. Returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, Reason}&lt;/code&gt; when the term is written to disk. If the log is distributed, &lt;code&gt;ok&lt;/code&gt; is returned, unless all nodes are down. Terms are written by the ordinary &lt;code&gt;write()&lt;/code&gt; function of the operating system. Hence, it is not guaranteed that the term is written to disk, it can linger in the operating system kernel for a while. To ensure that the item is written to disk, function &lt;code&gt;&lt;a href=&quot;#sync-1&quot;&gt;sync/1&lt;/a&gt;&lt;/code&gt; must be called.</source>
          <target state="translated">同步将术语附加到磁盘日志。当将该术语写入磁盘时 &lt;code&gt;{error, Reason}&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; 或{error，Reason}。如果分发了日志，则除非所有节点都关闭，否则返回 &lt;code&gt;ok&lt;/code&gt; 。术语由操作系统的普通 &lt;code&gt;write()&lt;/code&gt; 函数编写。因此，不能保证该术语已写入磁盘，它可能会在操作系统内核中徘徊一段时间。为了确保将项目写入磁盘，必须调用函数 &lt;code&gt;&lt;a href=&quot;#sync-1&quot;&gt;sync/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f5f72fe0e623ff3475c94b03480e1803098c61" translate="yes" xml:space="preserve">
          <source>Syntactic tests are used in the code associated with some rules, and an error is thrown (and caught by the generated parser to produce an error message) when a test fails. The same effect can be achieved with a call to &lt;code&gt;return_error(Error_line, Message_string)&lt;/code&gt;, which is defined in the &lt;code&gt;yeccpre.hrl&lt;/code&gt; default header file.</source>
          <target state="translated">语法测试在与某些规则关联的代码中使用，并且在测试失败时引发错误（并由生成的解析器捕获以产生错误消息）。调用 &lt;code&gt;yeccpre.hrl&lt;/code&gt; 默认头文件中定义的 &lt;code&gt;return_error(Error_line, Message_string)&lt;/code&gt; 可以达到相同的效果。</target>
        </trans-unit>
        <trans-unit id="8ebec072eed621a03687383916a65b1244e3a80a" translate="yes" xml:space="preserve">
          <source>Syntactically QLCs have the same parts as ordinary list comprehensions:</source>
          <target state="translated">从句法上看,QLC与普通列表理解的部分相同。</target>
        </trans-unit>
        <trans-unit id="f8f94a7abd535bc567b210e7feb24b95dcc145dd" translate="yes" xml:space="preserve">
          <source>Syntax according to the URI definition in RFC 3986, for example, &quot;http://www.erlang.org/&quot;</source>
          <target state="translated">语法根据RFC 3986中的URI定义,例如,&quot;http://www.erlang.org/&quot;</target>
        </trans-unit>
        <trans-unit id="3aef52650439fcc381066161b6a33ff26aa88627" translate="yes" xml:space="preserve">
          <source>Syntax errors are detected locally on this side of the protocol and may have many causes, e.g. a malfunctioning transport layer, wrong encoder/decoder selected, bad configuration of the selected encoder/decoder etc.</source>
          <target state="translated">语法错误是在协议本端检测到的,可能有很多原因,如传输层故障、选择的编码器/解码器错误、选择的编码器/解码器配置不良等。</target>
        </trans-unit>
        <trans-unit id="c3b09d06cdfdc92cef412c5e43702c1e9bf45027" translate="yes" xml:space="preserve">
          <source>Syntax errors in these files are discovered and reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module at start-up.</source>
          <target state="translated">这些文件中的语法错误会在启动时通过错误报告模块的功能 &lt;code&gt;config_err/2&lt;/code&gt; 进行发现并报告。</target>
        </trans-unit>
        <trans-unit id="9bc253a36e8ace3c94e28555bf56cc77650f265b" translate="yes" xml:space="preserve">
          <source>Syriac</source>
          <target state="translated">Syriac</target>
        </trans-unit>
        <trans-unit id="5131fe5695bc3ce3887d236a54747934336afaf8" translate="yes" xml:space="preserve">
          <source>System Information</source>
          <target state="translated">系统信息</target>
        </trans-unit>
        <trans-unit id="b35b204150b6742e0c35cf28de6a47c6519eee30" translate="yes" xml:space="preserve">
          <source>System events and table events are the two event categories that &lt;code&gt;Mnesia&lt;/code&gt; generates in various situations.</source>
          <target state="translated">系统事件和表事件是 &lt;code&gt;Mnesia&lt;/code&gt; 在各种情况下生成的两个事件类别。</target>
        </trans-unit>
        <trans-unit id="7ca52b12819dad012ad5eb499f8d3b89db539ac8" translate="yes" xml:space="preserve">
          <source>System flags effecting specific allocators have an uppercase letter as &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;. The following letters are used for the allocators:</source>
          <target state="translated">影响特定分配器的系统标志的大写字母为 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 。以下字母用于分配器：</target>
        </trans-unit>
        <trans-unit id="906ee68749a5a73a7e6af2237eb2dee1edbbf171" translate="yes" xml:space="preserve">
          <source>System info - System wide information. Read only.</source>
          <target state="translated">系统信息-系统范围内的信息。只读。</target>
        </trans-unit>
        <trans-unit id="5474f690d82670c5da64f04996c609d92047ddb8" translate="yes" xml:space="preserve">
          <source>System messages are messages with a special meaning, used in the supervision tree. Typical system messages are requests for trace output, and requests to suspend or resume process execution (used during release handling). Processes implemented using standard behaviours automatically understand these messages.</source>
          <target state="translated">系统消息是具有特殊含义的消息,在监督树中使用。典型的系统消息是跟踪输出请求,以及暂停或恢复进程执行的请求(在释放处理中使用)。使用标准行为实现的进程会自动理解这些消息。</target>
        </trans-unit>
        <trans-unit id="1b4c8fad84bf9ee2ed69c28438abdf60dfd04975" translate="yes" xml:space="preserve">
          <source>System settings</source>
          <target state="translated">系统设置</target>
        </trans-unit>
        <trans-unit id="97a5f85605eef008a7bb7f2a0d512d9d724526bc" translate="yes" xml:space="preserve">
          <source>SystemTap &amp;gt; 1.6</source>
          <target state="translated">SystemTap&amp;gt; 1.6</target>
        </trans-unit>
        <trans-unit id="5bf881dc1f558738602aecd490c360ffa2d35d9f" translate="yes" xml:space="preserve">
          <source>SystemTap is DTrace for Linux. In fact Erlang's SystemTap support is build using SystemTap's DTrace compatibility's layer. For an introduction to Erlang DTrace support read &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;$ERL_TOP/HOWTO/DTRACE.md&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SystemTap是DTrace for Linux。实际上，Erlang的SystemTap支持是使用SystemTap的DTrace兼容性的层构建的。有关Erlang DTrace支持的介绍，请阅读 &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;$ERL_TOP/HOWTO/DTRACE.md&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a67e86af30e598c1b8dd4410e063b04f3f531fa" translate="yes" xml:space="preserve">
          <source>SystemTap, unlike DTrace, needs to know what binary it is tracing and has to be able to read that binary before it starts tracing. Your probe script therefor has to reference the correct beam emulator and stap needs to be able to find that binary. The examples are written for &quot;beam&quot;, but other versions such as &quot;beam.smp&quot; or &quot;beam.debug.smp&quot; might exist (depending on your configuration). Make sure you either specify the full the path of the binary in the probe or your &quot;beam&quot; binary is in the search path.</source>
          <target state="translated">SystemTap与DTrace不同,它需要知道它正在追踪的二进制,并且在开始追踪之前必须能够读取该二进制。因此,你的探针脚本必须引用正确的光束仿真器,而stap需要能够找到该二进制。这些例子是为 &quot;beam &quot;而写的,但其他版本如 &quot;beam.smp &quot;或 &quot;beam.debug.smp &quot;也可能存在(取决于你的配置)。确保你在探针中指定了二进制的完整路径,或者你的 &quot;beam &quot;二进制在搜索路径中。</target>
        </trans-unit>
        <trans-unit id="3890f6e1eeb7c8b9e6d4cda8af3654adab1e5a34" translate="yes" xml:space="preserve">
          <source>TCP over IPv4 (the default)</source>
          <target state="translated">TCP over IPv4 (默认)</target>
        </trans-unit>
        <trans-unit id="dd63ca133c7c9505341195d3fb66a2e4d3b97381" translate="yes" xml:space="preserve">
          <source>TCP over IPv6</source>
          <target state="translated">TCP over IPv6</target>
        </trans-unit>
        <trans-unit id="04ee2e323dc35fc805718ec013670729358e3a49" translate="yes" xml:space="preserve">
          <source>TLS protocol versions supported by started clients and servers. This option overrides the application environment option &lt;code&gt;protocol_version&lt;/code&gt; and &lt;code&gt;dtls_protocol_version&lt;/code&gt;. If the environment option is not set, it defaults to all versions, except SSL-3.0, supported by the SSL application. See also &lt;code&gt;ssl(6).&lt;/code&gt;</source>
          <target state="translated">启动的客户端和服务器支持的TLS协议版本。此选项将覆盖应用程序环境选项 &lt;code&gt;protocol_version&lt;/code&gt; 和 &lt;code&gt;dtls_protocol_version&lt;/code&gt; 。如果未设置环境选项，则默认为SSL应用程序支持的所有版本，但SSL-3.0除外。另请参见 &lt;code&gt;ssl(6).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="981d4d11fc961a401155c4cc0aa1d985387ff5d6" translate="yes" xml:space="preserve">
          <source>TLS session cache API</source>
          <target state="translated">TLS会话缓存API</target>
        </trans-unit>
        <trans-unit id="e297ce43abfa4341900c35352befe7e5a48a3921" translate="yes" xml:space="preserve">
          <source>TLS/TCP and DTLS/SCTP Usage</source>
          <target state="translated">TLS/TCP和DTLS/SCTP使用方法</target>
        </trans-unit>
        <trans-unit id="fe06eb6459c87f0e497ce1805f076f104bfecf78" translate="yes" xml:space="preserve">
          <source>Tab</source>
          <target state="translated">Tab</target>
        </trans-unit>
        <trans-unit id="d7f5ee722fd0ae504f8d3c4d7a205b2fef8a3d7f" translate="yes" xml:space="preserve">
          <source>Tab (hex 09)</source>
          <target state="translated">标签(十六进制09)</target>
        </trans-unit>
        <trans-unit id="ac4a8afcda713e36d6e9d6a34b43dbf38fa7e2cb" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Applications&lt;/strong&gt; presents application information. Select an application in the left list to display its supervisor tree. The right-click options in the tree are as follows:</source>
          <target state="translated">选项卡&lt;strong&gt;应用程序&lt;/strong&gt;显示应用程序信息。在左侧列表中选择一个应用程序以显示其主管树。树中的右键单击选项如下：</target>
        </trans-unit>
        <trans-unit id="a99c25e3c4704f469b96b031da459e53abfe6fa8" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Atoms&lt;/strong&gt; lists all atoms found in the dump. By default the atoms are sorted in creation order from first to last. This is opposite of the raw crashdump where atoms are listed from last to first, meaning that if the dump was truncated in the middle of the atom list, only the last created atoms are visible in the &lt;strong&gt;Atoms&lt;/strong&gt; tab.</source>
          <target state="translated">Tab &lt;strong&gt;Atoms&lt;/strong&gt;列出了在转储中找到的所有原子。默认情况下，原子按创建顺序从头到尾排序。这与原始崩溃转储相反，在原始崩溃转储中，原子从最后到第一个列出，这意味着如果转储在原子列表的中间被截断，则在&lt;strong&gt;原子&lt;/strong&gt;选项卡中只有最后创建的原子可见。</target>
        </trans-unit>
        <trans-unit id="33be1b6f25987c84258604714f597ef47abe12d6" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;ETS Tables&lt;/strong&gt; shows all ETS table information found in the dump. &lt;strong&gt;Id&lt;/strong&gt; is the same as the 'Table' field in the raw crashdump. &lt;strong&gt;Memory&lt;/strong&gt; is the 'Words' field from the raw crashdump translated into bytes. For tree tables, there is no value in the 'Objects' field.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;ETS表&amp;rdquo;&lt;/strong&gt;选项卡显示转储中找到的所有ETS表信息。&lt;strong&gt;ID&lt;/strong&gt;与原始崩溃转储中的&amp;ldquo;表格&amp;rdquo;字段相同。&lt;strong&gt;内存&lt;/strong&gt;是原始崩溃转储中的&amp;ldquo;字&amp;rdquo;字段，被转换为字节。对于树表，&amp;ldquo;对象&amp;rdquo;字段中没有值。</target>
        </trans-unit>
        <trans-unit id="d086aaa9e2e638560ca52f2f78e7b03c35094870" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Funs&lt;/strong&gt; shows all fun information found in the dump.</source>
          <target state="translated">Tab &lt;strong&gt;Funs&lt;/strong&gt;显示转储中找到的所有有趣信息。</target>
        </trans-unit>
        <trans-unit id="25121d69819c8efb4b19c73b31c386b78a1fdbb2" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;General&lt;/strong&gt; shows a short overview of the dump.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;常规&amp;rdquo;&lt;/strong&gt;选项卡显示转储的简短概述。</target>
        </trans-unit>
        <trans-unit id="07e01288b5805bf1432af8b394a9b45442c593c3" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Load Charts&lt;/strong&gt; displays graphs of the current resource use on the active Erlang node.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;负载图表&amp;rdquo;&lt;/strong&gt;显示活动的Erlang节点上当前资源使用情况的图表。</target>
        </trans-unit>
        <trans-unit id="853f32a45947eb4c6d161de3626c9eaa0a83a4aa" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Memory Allocators&lt;/strong&gt; displays detailed information of the carrier size and current memory carriers. For details about memory carriers, see module &lt;code&gt;erts_alloc&lt;/code&gt; in application ERTS.</source>
          <target state="translated">选项卡&lt;strong&gt;内存分配器&lt;/strong&gt;显示托架大小和当前内存托架的详细信息。有关内存载体的详细信息，请参见应用程序ERTS中的模块 &lt;code&gt;erts_alloc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc3b4b0a4502f9b7b7c51416e31fdfd021b9067e" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Memory&lt;/strong&gt; shows memory and allocator information. From the left-hand menu you can select the following:</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;内存&amp;rdquo;&lt;/strong&gt;显示内存和分配器信息。从左侧菜单中，您可以选择以下选项：</target>
        </trans-unit>
        <trans-unit id="27ba8745969c8d5f12e6c931fd214d70f5efac15" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Modules&lt;/strong&gt; lists all modules loaded on the originating node, and the current code size. If old code exists, the old size is also shown.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;模块&amp;rdquo;&lt;/strong&gt;列出了在原始节点上加载的所有模块，以及当前代码大小。如果存在旧代码，则还会显示旧大小。</target>
        </trans-unit>
        <trans-unit id="eaf448913218cac98b494d3245a11c82d5371831" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Nodes&lt;/strong&gt; shows a list of all external Erlang nodes that are referenced from the crashdump.</source>
          <target state="translated">标签&lt;strong&gt;节点&lt;/strong&gt;显示了崩溃转储中引用的所有外部Erlang节点的列表。</target>
        </trans-unit>
        <trans-unit id="80764d8faf4781bc8ce3e0b8874a18d7e0699dd0" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Ports&lt;/strong&gt; is similar to the &lt;strong&gt;Processes&lt;/strong&gt; tab, except it lists all ports found in the crashdump.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;端口&amp;rdquo;&lt;/strong&gt;与&amp;ldquo; &lt;strong&gt;进程&amp;rdquo;&lt;/strong&gt;选项卡相似，不同之处在于它列出了崩溃转储中找到的所有端口。</target>
        </trans-unit>
        <trans-unit id="76b66410e4f2402b3acc96cda65eec1371b79f1b" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Ports&lt;/strong&gt; lists port information in columns. For each port the following information is displayed:</source>
          <target state="translated">选项卡&lt;strong&gt;端口&lt;/strong&gt;在列中列出端口信息。对于每个端口，将显示以下信息：</target>
        </trans-unit>
        <trans-unit id="5f5391882f31ea5c33386e235a2386ab3a7ce9b1" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Processes&lt;/strong&gt; lists process information in columns. For each process the following information is displayed:</source>
          <target state="translated">&amp;ldquo; Tab &lt;strong&gt;进程&amp;rdquo;&lt;/strong&gt;选项卡在列中列出了进程信息。对于每个过程，将显示以下信息：</target>
        </trans-unit>
        <trans-unit id="81e00bdbb07b70180cc90e9aaa68bf4d038cb024" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Processes&lt;/strong&gt; shows a list of all processes found in the crashdump, including brief information about each process. By default, the processes are sorted by their pids. To sort by another topic, click the desired column heading.</source>
          <target state="translated">&amp;ldquo; Tab &lt;strong&gt;进程&amp;rdquo;&lt;/strong&gt;选项卡显示了崩溃转储中找到的所有进程的列表，包括有关每个进程的简要信息。默认情况下，进程按其pid排序。要按另一个主题排序，请单击所需的列标题。</target>
        </trans-unit>
        <trans-unit id="37ee8ff7801abf11d7bda8a37bc6cfc86f955eeb" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Schedulers&lt;/strong&gt; shows all scheduler information found in the dump.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;计划程序&amp;rdquo;&lt;/strong&gt;显示在转储中找到的所有计划程序信息。</target>
        </trans-unit>
        <trans-unit id="ae16dafe965fd6bba4b8e61efd1280d8b73f7cdd" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;System&lt;/strong&gt; displays general information about the active Erlang node and its runtime system, such as build configuration, system capabilities, and overall use statistics.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;系统&amp;rdquo;&lt;/strong&gt;显示有关活动的Erlang节点及其运行时系统的常规信息，例如构建配置，系统功能和总体使用情况统计信息。</target>
        </trans-unit>
        <trans-unit id="2dc8b2d71fceee93b7ee5110352b556240629d35" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Table Viewer&lt;/strong&gt; lists tables. By default, ETS tables are displayed whereas unreadable private ETS tables and tables created by OTP applications are not diplayed. Use menu &lt;strong&gt;View&lt;/strong&gt; to view &quot;system&quot; ETS tables, unreadable ETS tables, or Mnesia tables.</source>
          <target state="translated">选项卡&lt;strong&gt;表查看器&lt;/strong&gt;列出表。默认情况下，显示ETS表，而不显示不可读的私人ETS表和由OTP应用程序创建的表。使用菜单&lt;strong&gt;视图&lt;/strong&gt;查看&amp;ldquo;系统&amp;rdquo; ETS表，不可读的ETS表或Mnesia表。</target>
        </trans-unit>
        <trans-unit id="c749a9404534acc9874c4dddfbf96e28d745b82f" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Timers&lt;/strong&gt; shows all timer information found in the dump.</source>
          <target state="translated">&amp;ldquo;选项卡&lt;strong&gt;计时器&amp;rdquo;&lt;/strong&gt;显示在转储中找到的所有计时器信息。</target>
        </trans-unit>
        <trans-unit id="532adb7424e374188bddb153f94b5dffdd01a32b" translate="yes" xml:space="preserve">
          <source>Tab &lt;strong&gt;Trace Overview&lt;/strong&gt; handles tracing. Trace by selecting the processes or ports to be traced and how to trace them. For processes, you can trace messages, function calls, scheduling, garbage collections, and process-related events such as &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and many others. For ports, you can trace messages, scheduling and port-related events.</source>
          <target state="translated">选项卡&lt;strong&gt;跟踪概述&lt;/strong&gt;处理跟踪。通过选择要跟踪的进程或端口以及如何跟踪它们来进行跟踪。对于流程，您可以跟踪消息，函数调用，调度，垃圾回收以及与流程相关的事件，例如 &lt;code&gt;spawn&lt;/code&gt; ， &lt;code&gt;exit&lt;/code&gt; 和许多其他事件。对于端口，您可以跟踪消息，调度和与端口相关的事件。</target>
        </trans-unit>
        <trans-unit id="c3b24916106c05d16fc45b26f326aea8327897c3" translate="yes" xml:space="preserve">
          <source>Tab.</source>
          <target state="translated">Tab.</target>
        </trans-unit>
        <trans-unit id="78e563ed4498b45afa55a612a7d50d8010f51d47" translate="yes" xml:space="preserve">
          <source>Table 1.1:</source>
          <target state="translated">表1.1:</target>
        </trans-unit>
        <trans-unit id="2ba8d01b5f4587ab25a8cf9806410e2f7f1f467f" translate="yes" xml:space="preserve">
          <source>Table 1.1: Configuration Parameters</source>
          <target state="translated">表1.1:表1.1:配置参数</target>
        </trans-unit>
        <trans-unit id="458a619e647863b2edbd583f53f1c4f27cc2c7fd" translate="yes" xml:space="preserve">
          <source>Table 1.1: File Types</source>
          <target state="translated">表1.1:文件类型</target>
        </trans-unit>
        <trans-unit id="d257f726296380c878ec40caabc8bee011031308" translate="yes" xml:space="preserve">
          <source>Table 10.1: Memory Size of Different Data Types</source>
          <target state="translated">表10.1.不同数据类型的内存大小 不同数据类型的内存大小</target>
        </trans-unit>
        <trans-unit id="1177d151257b31d9c29f7aa373dc11ffece292c4" translate="yes" xml:space="preserve">
          <source>Table 10.2: System Limits</source>
          <target state="translated">表10.2:系统限制</target>
        </trans-unit>
        <trans-unit id="fd59220c9b680aec464f9d24199fa3a8abdb16d2" translate="yes" xml:space="preserve">
          <source>Table 11.1: Exception Classes.</source>
          <target state="translated">表11.1:例外类:</target>
        </trans-unit>
        <trans-unit id="d6b64accf1c2234e132511d0019f44d13d7aeb9f" translate="yes" xml:space="preserve">
          <source>Table 11.1: Tool Summary</source>
          <target state="translated">表11.1:工具摘要</target>
        </trans-unit>
        <trans-unit id="f6169b398a7ff5ef27d299293d71cfddab2f0858" translate="yes" xml:space="preserve">
          <source>Table 11.2: Exit Reasons</source>
          <target state="translated">表11.2:离职原因</target>
        </trans-unit>
        <trans-unit id="b30a60a6dd809b8b57e40c37cb359be1d19a90fa" translate="yes" xml:space="preserve">
          <source>Table 12.10: SMALL_INTEGER_EXT</source>
          <target state="translated">表12.10:SMALL_INTEGER_EXT</target>
        </trans-unit>
        <trans-unit id="9866b94803a8e807cf22a1060604d66f72a8ea46" translate="yes" xml:space="preserve">
          <source>Table 12.11: INTEGER_EXT</source>
          <target state="translated">表12.11:INTEGER_EXT</target>
        </trans-unit>
        <trans-unit id="58ca896888c5b6bdb23917ab9d4badd52b5d9e0c" translate="yes" xml:space="preserve">
          <source>Table 12.12: FLOAT_EXT</source>
          <target state="translated">表12.12:FLOAT_EXT</target>
        </trans-unit>
        <trans-unit id="2fd6bbf622d7c5bf5fb9063eb1831d2717f4dd60" translate="yes" xml:space="preserve">
          <source>Table 12.13: REFERENCE_EXT</source>
          <target state="translated">表12.13:REFERENCE_EXT(参考文献)</target>
        </trans-unit>
        <trans-unit id="0578060eac8303938de8c878ec3873fcb4318376" translate="yes" xml:space="preserve">
          <source>Table 12.14: PORT_EXT</source>
          <target state="translated">表12.14:PORT_EXT</target>
        </trans-unit>
        <trans-unit id="96819e46fe9160b7684601591232299db1b36df4" translate="yes" xml:space="preserve">
          <source>Table 12.15: PID_EXT</source>
          <target state="translated">表12.15:PID_EXT</target>
        </trans-unit>
        <trans-unit id="929ef647be6942415e3f171358774bf82ec22c90" translate="yes" xml:space="preserve">
          <source>Table 12.16: SMALL_TUPLE_EXT</source>
          <target state="translated">表12.16:SMALL_TUPLE_EXT</target>
        </trans-unit>
        <trans-unit id="2bc9e7a9f0cdd26ab796e08ac173c9214cf33bb2" translate="yes" xml:space="preserve">
          <source>Table 12.17: LARGE_TUPLE_EXT</source>
          <target state="translated">表12.17:LARGE_TUPLE_EXT</target>
        </trans-unit>
        <trans-unit id="adb693dcc7fb1fd77fe8a58008cf68aa105437ec" translate="yes" xml:space="preserve">
          <source>Table 12.18: MAP_EXT</source>
          <target state="translated">表12.18:MAP_EXT</target>
        </trans-unit>
        <trans-unit id="0058992413b1a2072f46a8bef8849c819a9bd27c" translate="yes" xml:space="preserve">
          <source>Table 12.19: NIL_EXT</source>
          <target state="translated">表12.19:NIL_EXT</target>
        </trans-unit>
        <trans-unit id="8c7f1e0a03ffe076870e398ec25b8453d8eadb76" translate="yes" xml:space="preserve">
          <source>Table 12.1: Name Registration BIFs</source>
          <target state="translated">表12.1:名称登记的基本信息框架</target>
        </trans-unit>
        <trans-unit id="ad64574492eb17bfd807110b90dea335f1c7aae2" translate="yes" xml:space="preserve">
          <source>Table 12.1: Term Format</source>
          <target state="translated">表12.1.术语格式 表12.1:术语格式</target>
        </trans-unit>
        <trans-unit id="0df8d7a0af860ca015d80e7243b43bef49703f4d" translate="yes" xml:space="preserve">
          <source>Table 12.20: STRING_EXT</source>
          <target state="translated">表12.20:STRING_EXT</target>
        </trans-unit>
        <trans-unit id="7c0155dab34e626428cf77c18f392f114ec8b923" translate="yes" xml:space="preserve">
          <source>Table 12.21: LIST_EXT</source>
          <target state="translated">表12.21:LIST_EXT</target>
        </trans-unit>
        <trans-unit id="aa41c1d8936052f161d20f526c915bdfa140ba72" translate="yes" xml:space="preserve">
          <source>Table 12.22: BINARY_EXT</source>
          <target state="translated">表12.22:BINARY_EXT</target>
        </trans-unit>
        <trans-unit id="36cf93a4b7064da1028c95fc5d153f969a05f23b" translate="yes" xml:space="preserve">
          <source>Table 12.23: SMALL_BIG_EXT</source>
          <target state="translated">表12.23:SMALL_BIG_EXT</target>
        </trans-unit>
        <trans-unit id="8b7dc77f03315b79ffa7b47922ecb22f0aa5f2e7" translate="yes" xml:space="preserve">
          <source>Table 12.24: LARGE_BIG_EXT</source>
          <target state="translated">表12.24:LARGE_BIG_EXT</target>
        </trans-unit>
        <trans-unit id="0bcc99ccfd58c2a94d4cf75fd172c14957bee41a" translate="yes" xml:space="preserve">
          <source>Table 12.25: NEW_REFERENCE_EXT</source>
          <target state="translated">表12.25:NEW_REFERENCE_EXT</target>
        </trans-unit>
        <trans-unit id="1b3e3a9c2a02cf90a00369084f14b0b26a667ff3" translate="yes" xml:space="preserve">
          <source>Table 12.26: FUN_EXT</source>
          <target state="translated">表12.26:FUN_EXT</target>
        </trans-unit>
        <trans-unit id="29a4858c0789b86f5465f8cb5db1421d2810276a" translate="yes" xml:space="preserve">
          <source>Table 12.27: NEW_FUN_EXT</source>
          <target state="translated">表12.27:NEW_FUN_EXT</target>
        </trans-unit>
        <trans-unit id="f399cbd0c09e84ad8dba436d6454ceb339fc9356" translate="yes" xml:space="preserve">
          <source>Table 12.28: EXPORT_EXT</source>
          <target state="translated">表12.28:EXPORT_EXT</target>
        </trans-unit>
        <trans-unit id="c4f8c6d2a98bb834eb44bbc5c62a5c56f9612215" translate="yes" xml:space="preserve">
          <source>Table 12.29: BIT_BINARY_EXT</source>
          <target state="translated">表 12.29:BIT_BINARY_EXT</target>
        </trans-unit>
        <trans-unit id="9a7845dbd38fceef2f98e2021ad2db0a951f1f90" translate="yes" xml:space="preserve">
          <source>Table 12.2: Compressed Term Format</source>
          <target state="translated">表12.2:压缩术语格式</target>
        </trans-unit>
        <trans-unit id="69dd6d35b4f19964994f900ee8e129693a9ce6e5" translate="yes" xml:space="preserve">
          <source>Table 12.30: NEW_FLOAT_EXT</source>
          <target state="translated">表12.30:NEW_FLOAT_EXT</target>
        </trans-unit>
        <trans-unit id="39ba0ff930d671e34c458d513192e51e5782463c" translate="yes" xml:space="preserve">
          <source>Table 12.31: ATOM_UTF8_EXT</source>
          <target state="translated">表12.31:ATOM_UTF8_EXT</target>
        </trans-unit>
        <trans-unit id="71ae7d46f883a6cf5ca44c387bf96b8bf0304071" translate="yes" xml:space="preserve">
          <source>Table 12.32: SMALL_ATOM_UTF8_EXT</source>
          <target state="translated">表12.32:SMALL_ATOM_UTF8_EXT</target>
        </trans-unit>
        <trans-unit id="4f3e60db57ebf4f9ad1c8702519818c61269fd7b" translate="yes" xml:space="preserve">
          <source>Table 12.33: ATOM_EXT</source>
          <target state="translated">表12.33:ATOM_EXT</target>
        </trans-unit>
        <trans-unit id="d9763dcc196c99566fefe285bf27864c20b2a376" translate="yes" xml:space="preserve">
          <source>Table 12.34: SMALL_ATOM_EXT</source>
          <target state="translated">表12.34:SMALL_ATOM_EXT</target>
        </trans-unit>
        <trans-unit id="7f4f07bb52b5e0ac65f5c4b09be7c563c9af2a2a" translate="yes" xml:space="preserve">
          <source>Table 12.3: Compressed Data Format when Expanded</source>
          <target state="translated">表12.3:扩展时的压缩数据格式</target>
        </trans-unit>
        <trans-unit id="a1b25601d5798e4ada95d734eebfad09c3438475" translate="yes" xml:space="preserve">
          <source>Table 12.4: Distribution Header Format</source>
          <target state="translated">表12.4:发送头格式</target>
        </trans-unit>
        <trans-unit id="7ae3242d88a1907427a116698d6e7daa006dee20" translate="yes" xml:space="preserve">
          <source>Table 12.5:</source>
          <target state="translated">表12.5.1.1</target>
        </trans-unit>
        <trans-unit id="5a71917f82a2759e5a495c12c44a7eb3c885d967" translate="yes" xml:space="preserve">
          <source>Table 12.6:</source>
          <target state="translated">表12.6.2.1:</target>
        </trans-unit>
        <trans-unit id="7a6b6888acaa7d0157552bfe1d147e5f2ffc5c2a" translate="yes" xml:space="preserve">
          <source>Table 12.7:</source>
          <target state="translated">表12.7.1.1.2</target>
        </trans-unit>
        <trans-unit id="d455469fa598129902ab217f6b876f8e08b0c329" translate="yes" xml:space="preserve">
          <source>Table 12.8:</source>
          <target state="translated">表12.8.2.1:</target>
        </trans-unit>
        <trans-unit id="7e4fc9ad71d6c65901eeebf5f25e8c4321f8fd5d" translate="yes" xml:space="preserve">
          <source>Table 12.9: ATOM_CACHE_REF</source>
          <target state="translated">表12.9:ATOM_CACHE_REF</target>
        </trans-unit>
        <trans-unit id="2b3c51ca48ed62a11f8f6b268d0cfb454be00ab2" translate="yes" xml:space="preserve">
          <source>Table 13.10: DUMP_RESP</source>
          <target state="translated">表13.10:DUMP_RESP:</target>
        </trans-unit>
        <trans-unit id="a1268f8a739adc2dd0b6cf61f8bcf9b2c1a25af3" translate="yes" xml:space="preserve">
          <source>Table 13.11: KILL_REQ</source>
          <target state="translated">表13.11:KILL_REQ</target>
        </trans-unit>
        <trans-unit id="9924291901a5a0b8fe67cb8613a69112ee2d49ab" translate="yes" xml:space="preserve">
          <source>Table 13.12: KILL_RESP</source>
          <target state="translated">表13.12:杀人事件_RESP</target>
        </trans-unit>
        <trans-unit id="521337e4c6544841a20f88ecfc0c1ea60912a86c" translate="yes" xml:space="preserve">
          <source>Table 13.13: STOP_REQ</source>
          <target state="translated">表 13.13:STOP_REQ</target>
        </trans-unit>
        <trans-unit id="0ff58a2b54089117b1d4d95d994b2ed678f3c4cf" translate="yes" xml:space="preserve">
          <source>Table 13.14: STOP_RESP</source>
          <target state="translated">表 13.14:STOP_RESP</target>
        </trans-unit>
        <trans-unit id="a5cdc90bbaefb168ea142b2790c03070e154af9b" translate="yes" xml:space="preserve">
          <source>Table 13.15: STOP_NOTOK_RESP</source>
          <target state="translated">表13.15:STOP_NOTOK_RESP</target>
        </trans-unit>
        <trans-unit id="7b97daf857d1cf5519b64b59f2c01112e80fd279" translate="yes" xml:space="preserve">
          <source>Table 13.16: Format of Messages Passed between Nodes (as from ERTS 5.7.2)</source>
          <target state="translated">表13.16:节点间传递的信息格式(根据ERTS 5.7.2)</target>
        </trans-unit>
        <trans-unit id="0235810478165bd4a5414161e73679ab6e077e20" translate="yes" xml:space="preserve">
          <source>Table 13.17: Format of Messages Passed between Nodes (before ERTS 5.7.2)</source>
          <target state="translated">表13.17:节点间传递的信息格式(ERTS 5.7.2之前)</target>
        </trans-unit>
        <trans-unit id="03bda7e932b3f1c5bed1e5d6d2070739f08eaf1c" translate="yes" xml:space="preserve">
          <source>Table 13.1: Distribution BIFs</source>
          <target state="translated">表13.1:BIF分布情况</target>
        </trans-unit>
        <trans-unit id="61638ac22a7cbdb6b5559917090de7497beade99" translate="yes" xml:space="preserve">
          <source>Table 13.1: Request Format</source>
          <target state="translated">表13.1:请求格式</target>
        </trans-unit>
        <trans-unit id="42e15dae13f3c331c9200d0729d1ddc9e0e50071" translate="yes" xml:space="preserve">
          <source>Table 13.2: ALIVE2_REQ (120)</source>
          <target state="translated">表13.2:ALIVE2_REQ (120)</target>
        </trans-unit>
        <trans-unit id="c6a77d421f864fb58dddfaf3e3633bdb241cbfda" translate="yes" xml:space="preserve">
          <source>Table 13.2: Distribution Command-Line Flags</source>
          <target state="translated">表13.2:分发命令行标志</target>
        </trans-unit>
        <trans-unit id="9aea119540385e38157e1b773684ae3d6cbe0ba8" translate="yes" xml:space="preserve">
          <source>Table 13.3: ALIVE2_RESP (121)</source>
          <target state="translated">表13.3.ALIVE2_RESP (121)ALIVE2_RESP(121)</target>
        </trans-unit>
        <trans-unit id="94bfc83da20e2a496446d2150cfc714838620ceb" translate="yes" xml:space="preserve">
          <source>Table 13.3: Kernel Modules Useful For Distribution.</source>
          <target state="translated">表13.3:用于分发的内核模块。</target>
        </trans-unit>
        <trans-unit id="4aac3932070e2c73da7f9a23bb587d59bdb5f802" translate="yes" xml:space="preserve">
          <source>Table 13.4: PORT_PLEASE2_REQ (122)</source>
          <target state="translated">表13.4:PORT_PLEASE2_REQ (122)</target>
        </trans-unit>
        <trans-unit id="719629eb907013d0ec53e4c81e41dc5f23ae20a4" translate="yes" xml:space="preserve">
          <source>Table 13.4: STDLIB Modules Useful For Distribution.</source>
          <target state="translated">表13.4:用于分发的STDLIB模块。</target>
        </trans-unit>
        <trans-unit id="0f35a1a83b6107724dd65d19a2ced52d720d62b9" translate="yes" xml:space="preserve">
          <source>Table 13.5: PORT2_RESP (119) Response Indicating Error, Result &amp;gt; 0</source>
          <target state="translated">表13.5：PORT2_RESP（119）响应指示错误，结果&amp;gt; 0</target>
        </trans-unit>
        <trans-unit id="d7346d09d095d6d89b7bb97b2f6f60397d92b506" translate="yes" xml:space="preserve">
          <source>Table 13.6: PORT2_RESP, Result = 0</source>
          <target state="translated">表 13.6:PORT2_RESP,结果=0</target>
        </trans-unit>
        <trans-unit id="7651664c52537de188b4793cbd87741bdb99dbbe" translate="yes" xml:space="preserve">
          <source>Table 13.7: NAMES_REQ (110)</source>
          <target state="translated">表13.7:NAMES_REQ(110)</target>
        </trans-unit>
        <trans-unit id="b2f285bf0e8f76155a1b2ba2e26572814a0b098a" translate="yes" xml:space="preserve">
          <source>Table 13.8: NAMES_RESP</source>
          <target state="translated">表13.8:NAMES_RESP</target>
        </trans-unit>
        <trans-unit id="4db4ef3f34f7a95b11e9b62f8eb6359c7f0c035b" translate="yes" xml:space="preserve">
          <source>Table 13.9: DUMP_REQ</source>
          <target state="translated">表13.9:DUMP_REQ</target>
        </trans-unit>
        <trans-unit id="a28dfe55e369b981e9989ca655f8070823b288d4" translate="yes" xml:space="preserve">
          <source>Table 14.1: Scope of a CTH</source>
          <target state="translated">表14.1.CTH的范围 CTH的范围</target>
        </trans-unit>
        <trans-unit id="6f346618d895fae04b070f63801d27512e0a114e" translate="yes" xml:space="preserve">
          <source>Table 15.1: Port Creation BIF</source>
          <target state="translated">表15.1:港口创建BIF</target>
        </trans-unit>
        <trans-unit id="5702cda3079894261cf21470de9842cbf06107d1" translate="yes" xml:space="preserve">
          <source>Table 15.2: Messages Sent To a Port</source>
          <target state="translated">表 15.2:发送至端口的信息</target>
        </trans-unit>
        <trans-unit id="d888dee5eb271a175c076f3da8428908d38f7a20" translate="yes" xml:space="preserve">
          <source>Table 15.3: Messages Received From a Port</source>
          <target state="translated">表 15.3:从端口接收的信息</target>
        </trans-unit>
        <trans-unit id="728ee03beb77f2dd0af6fd6ba498d0eba5ed22d9" translate="yes" xml:space="preserve">
          <source>Table 15.4: Port BIFs</source>
          <target state="translated">表15.4:港口双边投资框架</target>
        </trans-unit>
        <trans-unit id="b27132ceaa20acb15aedc85775feadc97cf98c9c" translate="yes" xml:space="preserve">
          <source>Table 16.1: Error Messages</source>
          <target state="translated">表16.1:错误信息</target>
        </trans-unit>
        <trans-unit id="5f4934e67a618cf41c7091ca6f0fc3ad49ab6cce" translate="yes" xml:space="preserve">
          <source>Table 2.1: Character Classes</source>
          <target state="translated">表2.1:角色类别</target>
        </trans-unit>
        <trans-unit id="6eaaaa238c86c88e40d4df41a53e15cc0448911e" translate="yes" xml:space="preserve">
          <source>Table 2.1: Log Levels</source>
          <target state="translated">表2.1:对数水平</target>
        </trans-unit>
        <trans-unit id="4fc595026f67776148a8c9da2e83cff6c4e748e1" translate="yes" xml:space="preserve">
          <source>Table 2.1: Signature Algorithm OIDs</source>
          <target state="translated">表2.1:签名算法OIDs</target>
        </trans-unit>
        <trans-unit id="b559a4c56db17477d2000244623dc69a859d8ced" translate="yes" xml:space="preserve">
          <source>Table 2.2: Attribute OIDs</source>
          <target state="translated">表2.2:属性OID 属性代号</target>
        </trans-unit>
        <trans-unit id="61329aaff17f9cdc353879f67a1b6c2c2ced1057" translate="yes" xml:space="preserve">
          <source>Table 2.3: Public-Key Algorithm OIDs</source>
          <target state="translated">表2.3:公钥算法OIDs</target>
        </trans-unit>
        <trans-unit id="63c67e425d843f44c3ad3944ba2ea398bf3390ac" translate="yes" xml:space="preserve">
          <source>Table 2.4: Standard Certificate Extensions</source>
          <target state="translated">表2.4:标准证书扩展部分</target>
        </trans-unit>
        <trans-unit id="1d07377a9b4d3d0fdc53c19f9b80541a838d71a0" translate="yes" xml:space="preserve">
          <source>Table 2.5: Key Purpose OIDs</source>
          <target state="translated">表2.5:主要用途标识码</target>
        </trans-unit>
        <trans-unit id="c9a0d1dbd63f25fa4cab07cb6e81975a5434e58c" translate="yes" xml:space="preserve">
          <source>Table 2.6: Private Internet Extensions</source>
          <target state="translated">表2.6:私人互联网扩展</target>
        </trans-unit>
        <trans-unit id="3c4523326210a6e49a84a168a517493f6b494085" translate="yes" xml:space="preserve">
          <source>Table 2.7: CRL Extensions</source>
          <target state="translated">表2.7:CRL扩展部分</target>
        </trans-unit>
        <trans-unit id="e599a4ff0cd3050fdc6bb940882734dade0ed796" translate="yes" xml:space="preserve">
          <source>Table 2.8: CRL Entry Extensions</source>
          <target state="translated">表2.8:CRL条目扩展部分</target>
        </trans-unit>
        <trans-unit id="69a5a550952ff1d1582f1327251b38f6f3925307" translate="yes" xml:space="preserve">
          <source>Table 3.1: Mapping of ODBC data types to the Erlang data types returned to the Erlang application.</source>
          <target state="translated">表3.1.ODBC数据类型与返回给Erlang应用程序的Erlang数据类型的映射。ODBC数据类型与返回给Erlang应用程序的Erlang数据类型的映射。</target>
        </trans-unit>
        <trans-unit id="f8612a65d1f97ebf0034cd75baf0addcfe1c0893" translate="yes" xml:space="preserve">
          <source>Table 3.1: Recognized Escape Sequences</source>
          <target state="translated">表3.1:识别的逃逸序列</target>
        </trans-unit>
        <trans-unit id="9809e96d44e0af0600d936e259f842538f07e64b" translate="yes" xml:space="preserve">
          <source>Table 3.1: Supported ASN.1 Types</source>
          <target state="translated">表3.1:支持的ASN.1类型</target>
        </trans-unit>
        <trans-unit id="02b78e9c5cb42c3363db65995522a67a8422f0e9" translate="yes" xml:space="preserve">
          <source>Table 3.1: employee Database Record</source>
          <target state="translated">表3.1:员工数据库记录</target>
        </trans-unit>
        <trans-unit id="e2e04ae1720c523c09ad885d4bba619975d91dfd" translate="yes" xml:space="preserve">
          <source>Table 3.2: Mapping of extended ODBC data types to the Erlang data types returned to the Erlang application.</source>
          <target state="translated">表3.2:扩展的ODBC数据类型与返回给Erlang应用程序的Erlang数据类型的映射。</target>
        </trans-unit>
        <trans-unit id="c8fbe8731442bcc46734767ff421f607aa0f0b93" translate="yes" xml:space="preserve">
          <source>Table 3.2: at_dep Database Record</source>
          <target state="translated">表 3.2:at_dep 数据库记录</target>
        </trans-unit>
        <trans-unit id="472618ae5b8faf29f64e6182f23e94d8e8d2b3ff" translate="yes" xml:space="preserve">
          <source>Table 3.3: in_proj Database Record</source>
          <target state="translated">表 3.3:in_proj 数据库记录</target>
        </trans-unit>
        <trans-unit id="bd55e55c0bac662bbb91c2dab6fadd4546456110" translate="yes" xml:space="preserve">
          <source>Table 4.1: Match target depending on context</source>
          <target state="translated">表4.1:根据上下文匹配目标</target>
        </trans-unit>
        <trans-unit id="2d25688454b2bb5450c1309279e78263e6dbd7f4" translate="yes" xml:space="preserve">
          <source>Table 4.1: RFC 6733 Compliance</source>
          <target state="translated">表4.1:RFC 6733的合规性。</target>
        </trans-unit>
        <trans-unit id="732bc539aa9e2aceaab8c419c46c7186220b8351" translate="yes" xml:space="preserve">
          <source>Table 4.1: Results of Complete, Exclusive, and Selective Decode</source>
          <target state="translated">表4.1:完全解码、独占解码和选择性解码的结果</target>
        </trans-unit>
        <trans-unit id="2f6119a0a2c06c96a45bed121e21994c92602dec" translate="yes" xml:space="preserve">
          <source>Table 4.2: Literals in MatchCondition/MatchBody Parts of a Match Specification</source>
          <target state="translated">表4.2:匹配规格的MatchCondition/MatchBody部分中的字元。</target>
        </trans-unit>
        <trans-unit id="03c941b5ad0f9163428dd761c1aa72825546017a" translate="yes" xml:space="preserve">
          <source>Table 4.2: Results of Complete, Exclusive + decode_part, and Selective + complete decodes</source>
          <target state="translated">表4.2:完全、独家+解码部分和选择性+完全解码的结果。</target>
        </trans-unit>
        <trans-unit id="998575c4a113a89d67de8200527ab2f0671412a3" translate="yes" xml:space="preserve">
          <source>Table 7.1: Built-in types, predefined aliases</source>
          <target state="translated">表7.1.内置类型、预定义别名 内置类型,预定义别名</target>
        </trans-unit>
        <trans-unit id="7a46d02c216b62f4c7966fc627277fbbd5dca1db" translate="yes" xml:space="preserve">
          <source>Table 7.2: Additional built-in types</source>
          <target state="translated">表7.2:其他固有类型</target>
        </trans-unit>
        <trans-unit id="f425729931f6d1bdbaed18495dcda8f6c61e9665" translate="yes" xml:space="preserve">
          <source>Table 8.1: Codec performance</source>
          <target state="translated">表8.1:编解码器性能</target>
        </trans-unit>
        <trans-unit id="f02b919abba6c2f9f7cea19a79d8563e91342705" translate="yes" xml:space="preserve">
          <source>Table 8.1: Term Comparison Operators.</source>
          <target state="translated">表8.1:术语比较运算符。</target>
        </trans-unit>
        <trans-unit id="44dbfccf55391a47eda37e5337bceb5e6751ff98" translate="yes" xml:space="preserve">
          <source>Table 8.2: Arithmetic Operators.</source>
          <target state="translated">表8.2:算术运算符。</target>
        </trans-unit>
        <trans-unit id="80ab66478c80211ef28ea87ebf180af9badfa505" translate="yes" xml:space="preserve">
          <source>Table 8.3: Logical Operators.</source>
          <target state="translated">表8.3:逻辑运算符。</target>
        </trans-unit>
        <trans-unit id="d1b590658d7f606934706fe12855a35158b7b9ae" translate="yes" xml:space="preserve">
          <source>Table 8.4: Type Test BIFs</source>
          <target state="translated">表8.4:BIF类型试验</target>
        </trans-unit>
        <trans-unit id="e2253a5b23eb77ff9aec768859a9f84ff6371656" translate="yes" xml:space="preserve">
          <source>Table 8.5: Other BIFs Allowed in Guard Expressions</source>
          <target state="translated">表8.5:警卫表达式中允许的其他BIF。</target>
        </trans-unit>
        <trans-unit id="0053f71504d170421443aa2340e9bdc8a8bc2b06" translate="yes" xml:space="preserve">
          <source>Table 8.6: Operator Precedence</source>
          <target state="translated">表8.6:经营者优先</target>
        </trans-unit>
        <trans-unit id="a654ccdbe37f52ad3e2371abec18594740d9d987" translate="yes" xml:space="preserve">
          <source>Table 9.1: tty Text Editing</source>
          <target state="translated">表9.1:tty文本编辑</target>
        </trans-unit>
        <trans-unit id="785160c54069d8c0488a6885b676c3ed7ac94f33" translate="yes" xml:space="preserve">
          <source>Table attributes are specified when the table is created. For example, the following function creates a table with two RAM replicas:</source>
          <target state="translated">表的属性是在创建表时指定的。例如,以下函数创建了一个有两个RAM副本的表。</target>
        </trans-unit>
        <trans-unit id="920197fc8c7d9a17f9bba1e891a31f5e6bab2db5" translate="yes" xml:space="preserve">
          <source>Table events are events related to table updates. There are two types of table events, simple and detailed.</source>
          <target state="translated">表事件是与表更新有关的事件。表事件有两种类型,简单和详细。</target>
        </trans-unit>
        <trans-unit id="1f2cbbd1fe71c50be54063ec6ec279f2e5068eec" translate="yes" xml:space="preserve">
          <source>Table fragmentation</source>
          <target state="translated">碎裂表</target>
        </trans-unit>
        <trans-unit id="b321d78d8188930584227fd683d25947228f5912" translate="yes" xml:space="preserve">
          <source>Table indexes can be used whenever the user wants to use frequently some other field than the key field to look up records. If this other field has an associated index, these lookups can occur in constant time and space. For example, if your application wishes to use field &lt;code&gt;age&lt;/code&gt; to find efficiently all persons with a specific age, it can be a good idea to have an index on field &lt;code&gt;age&lt;/code&gt;. This can be done with the following call:</source>
          <target state="translated">只要用户希望经常使用键字段以外的其他字段来查找记录，就可以使用表索引。如果此其他字段具有关联的索引，则这些查找可以在恒定的时间和空间中进行。例如，如果您的应用程序希望使用字段 &lt;code&gt;age&lt;/code&gt; 有效地查找具有特定年龄的所有人员，则最好对字段 &lt;code&gt;age&lt;/code&gt; 进行索引。可以通过以下调用完成：</target>
        </trans-unit>
        <trans-unit id="c88fa77c87adc2265ab448874618640494fc6308" translate="yes" xml:space="preserve">
          <source>Table initialization is asynchronous. The function call &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the atom &lt;code&gt;ok&lt;/code&gt; and then starts to initialize the different tables. Depending on the size of the database, this can take some time, and the application programmer must wait for the tables that the application needs before they can be used. This is achieved by using the function &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt;, which suspends the caller until all tables specified in &lt;code&gt;TabList&lt;/code&gt; are properly initiated.</source>
          <target state="translated">表初始化是异步的。函数调用 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 返回原子 &lt;code&gt;ok&lt;/code&gt; ，然后开始初始化不同的表。根据数据库的大小，这可能需要一些时间，并且应用程序程序员必须等待应用程序需要的表才能使用。这可以通过使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; 来实现，该函数将挂起调用者，直到正确启动 &lt;code&gt;TabList&lt;/code&gt; 中指定的所有表为止。</target>
        </trans-unit>
        <trans-unit id="3d3b49fdca0320ed3b3453c5ed3280cae1c7efa5" translate="yes" xml:space="preserve">
          <source>Table locations are transparent to the programmer. Programs address table names and the system itself keeps track of table locations.</source>
          <target state="translated">表的位置对程序员是透明的。程序对表名进行寻址,系统本身也会跟踪表的位置。</target>
        </trans-unit>
        <trans-unit id="866e46fb585eb175d52c33c7d9ae3c6b97b99178" translate="yes" xml:space="preserve">
          <source>Table replicas of type &lt;code&gt;ram_copies&lt;/code&gt; can be dumped to disc with the function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型的表的副本 &lt;code&gt;ram_copies&lt;/code&gt; 可转储到盘与功能 &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af955ef17e57c071c4e89fa1503d4f412aa17a54" translate="yes" xml:space="preserve">
          <source>Table type &lt;code&gt;ordered_set&lt;/code&gt; is not affected by this option. Also, the memory consumption inflicted by both &lt;code&gt;write_concurrency&lt;/code&gt; and &lt;code&gt;read_concurrency&lt;/code&gt; is a constant overhead per table. This overhead can be especially large when both options are combined.</source>
          <target state="translated">表类型 &lt;code&gt;ordered_set&lt;/code&gt; 不受此选项影响。而且， &lt;code&gt;write_concurrency&lt;/code&gt; 和 &lt;code&gt;read_concurrency&lt;/code&gt; 两者造成的内存消耗是每个表的恒定开销。当两个选项组合在一起时，此开销可能会特别大。</target>
        </trans-unit>
        <trans-unit id="8ae7173fc695a7e90d392ed4e8e9a097c6a14f85" translate="yes" xml:space="preserve">
          <source>Tables are divided into four different types, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt;. A &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; table can only have one object associated with each key. A &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt; table can have many objects associated with each key.</source>
          <target state="translated">表分为四种不同的类型， &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;ordered_set&lt;/code&gt; ， &lt;code&gt;bag&lt;/code&gt; 和 &lt;code&gt;duplicate_bag&lt;/code&gt; 。甲 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 表只能有与每个键相关联的一个对象。一个 &lt;code&gt;bag&lt;/code&gt; 或 &lt;code&gt;duplicate_bag&lt;/code&gt; 表可以与每个键相关的许多对象。</target>
        </trans-unit>
        <trans-unit id="34d69fb54ae6920c0beb5343651ca15f5e6afaac" translate="yes" xml:space="preserve">
          <source>Tables can also have the following properties, where each attribute has a list of Erlang nodes as its value:</source>
          <target state="translated">表还可以有以下属性,其中每个属性都有一个Erlang节点的列表作为其值。</target>
        </trans-unit>
        <trans-unit id="de93908f0780db239ff5e538fea7ea2e43c2dd38" translate="yes" xml:space="preserve">
          <source>Tables can be created and new replicas can be added without starting all the disc-full nodes.</source>
          <target state="translated">可以在不启动所有盘满节点的情况下创建表和添加新的副本。</target>
        </trans-unit>
        <trans-unit id="d07956b5358d935c57f6803cf4b6ad1ef2830cb4" translate="yes" xml:space="preserve">
          <source>Tables can be declared to have properties such as location, replication, and persistence.</source>
          <target state="translated">表可以被声明为具有位置、复制和持久性等属性。</target>
        </trans-unit>
        <trans-unit id="f511e28cba4a01c743772e67af1ac7ec40828dab" translate="yes" xml:space="preserve">
          <source>Tables can be moved or deleted, and the layout of a table can be reconfigured in various ways. An important aspect of the implementation of these functions is that user programs can continue to use a table while it is being reconfigured. For example, it is possible to move a table and perform write operations to the table at the same time. This is important for many applications that require continuously available services. For more information, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#trans_prop&quot;&gt;Transactions and Other Access Contexts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以移动或删除表，并且可以以各种方式重新配置表的布局。这些功能实现的一个重要方面是，用户程序可以在重新配置表时继续使用该表。例如，可以移动表并同时对表执行写操作。这对于需要持续可用服务的许多应用程序很重要。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#trans_prop&quot;&gt;Transactions and Other Access Contexts&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d7bc03ffa55eb50ff02b4db69153553fd45996c" translate="yes" xml:space="preserve">
          <source>Tables can be moved or replicated to several nodes to improve fault tolerance. The rest of the system can still access the tables to read, write, and delete records.</source>
          <target state="translated">表可以被移动或复制到几个节点上,以提高容错能力。系统的其他部分仍然可以访问表来读、写、删记录。</target>
        </trans-unit>
        <trans-unit id="a0e957eb66e13f1765798b7a25ea084ce54f8043" translate="yes" xml:space="preserve">
          <source>Tables can be restored online from a backup without restarting &lt;code&gt;Mnesia&lt;/code&gt;. A restore is performed with the function &lt;code&gt;&lt;a href=&quot;mnesia#restore-2&quot;&gt;mnesia:restore(Opaque, Args)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; can contain the following tuples:</source>
          <target state="translated">可以从备份在线还原表，而无需重新启动 &lt;code&gt;Mnesia&lt;/code&gt; 。使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#restore-2&quot;&gt;mnesia:restore(Opaque, Args)&lt;/a&gt;&lt;/code&gt; 执行还原，其中 &lt;code&gt;Args&lt;/code&gt; 可以包含以下元组：</target>
        </trans-unit>
        <trans-unit id="d57d67e1acfe0bf746b51a2068d14140f7e2255b" translate="yes" xml:space="preserve">
          <source>Tables must be written in the following order: &lt;code&gt;tableObject&lt;/code&gt;, &lt;code&gt;entryObject&lt;/code&gt;, &lt;code&gt;column1&lt;/code&gt;, ..., &lt;code&gt;columnN&lt;/code&gt; (in order).</source>
          <target state="translated">表必须按以下顺序编写： &lt;code&gt;tableObject&lt;/code&gt; ， &lt;code&gt;entryObject&lt;/code&gt; ， &lt;code&gt;column1&lt;/code&gt; ，...， &lt;code&gt;columnN&lt;/code&gt; （按顺序）。</target>
        </trans-unit>
        <trans-unit id="0c69aeb6234da315154088828f3897ee8809919c" translate="yes" xml:space="preserve">
          <source>Tables of type &lt;code&gt;ram_copies&lt;/code&gt; are by definition stored in memory only. However, these tables can be dumped to disc, either at regular intervals or before the system is shut down. The function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; dumps all replicas of a set of RAM tables to disc. The tables can be accessed while being dumped to disc. To dump the tables to disc, all replicas must have the storage type &lt;code&gt;ram_copies&lt;/code&gt;.</source>
          <target state="translated">根据定义， &lt;code&gt;ram_copies&lt;/code&gt; 类型的表仅存储在内存中。但是，可以定期或在关闭系统之前将这些表转储到磁盘上。函数 &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables(TabList)&lt;/a&gt;&lt;/code&gt; 将一组RAM表的所有副本转储到光盘上。在将表转储到磁盘时可以对其进行访问。要将表转储到磁盘，所有副本都必须具有存储类型 &lt;code&gt;ram_copies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5f87c90bac9b358ab772324758ec3588f0e6d15" translate="yes" xml:space="preserve">
          <source>Tables that are created with these functions can be administered as all other Mnesia tables. They can be included in backups, replicas can be added, and so on. The tables are normal Mnesia tables owned by the user of the corresponding &lt;code&gt;erl_interface&lt;/code&gt; registries.</source>
          <target state="translated">使用这些功能创建的表可以像所有其他Mnesia表一样进行管理。它们可以包含在备份中，也可以添加副本，等等。这些表是相应的 &lt;code&gt;erl_interface&lt;/code&gt; 注册表用户所拥有的普通Mnesia表。</target>
        </trans-unit>
        <trans-unit id="743d28560816377de1f1a84b0e5ab1bcad9a2851" translate="yes" xml:space="preserve">
          <source>Tables that are only stored locally are initialized from the local &lt;code&gt;Mnesia&lt;/code&gt; directory.</source>
          <target state="translated">仅本地存储的表从本地 &lt;code&gt;Mnesia&lt;/code&gt; 目录初始化。</target>
        </trans-unit>
        <trans-unit id="15e17f79ab456ddb783d4d81329edb91056f584b" translate="yes" xml:space="preserve">
          <source>Tables that reside on remote nodes are available to other nodes as soon as they are loaded.</source>
          <target state="translated">驻留在远程节点上的表,一旦被加载,其他节点就可以使用。</target>
        </trans-unit>
        <trans-unit id="982963c1c41cbed8cab073724749592fe35c532b" translate="yes" xml:space="preserve">
          <source>Tag</source>
          <target state="translated">Tag</target>
        </trans-unit>
        <trans-unit id="ecc1e9ce18cc1f51b207c2bdf13311e34431c5b1" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;ct_hooks&lt;/code&gt; specifies the &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; to be run with this suite.</source>
          <target state="translated">标记 &lt;code&gt;ct_hooks&lt;/code&gt; 指定要与此套件一起运行的 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15ecb35628e9ad80298a11e2caca7262306b1658" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables required by test cases (or configuration functions) in the suite. If the required configuration variables are not found in any of the configuration files, all test cases are skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see funtion &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标记 &lt;code&gt;require&lt;/code&gt; 指定套件中测试用例（或配置功能）所需的配置变量。如果在任何配置文件中都找不到所需的配置变量，那么将跳过所有测试用例。有关 &lt;code&gt;require&lt;/code&gt; 功能的详细信息，请参见功能 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2131aee1075ebd4d5a669ce0e3a2b0c83464a600" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables required by test cases (or configuration functions) in the suite. If the required configuration variables are not found in any of the configuration files, all test cases in this group are skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标记 &lt;code&gt;require&lt;/code&gt; 指定套件中测试用例（或配置功能）所需的配置变量。如果在任何配置文件中都找不到所需的配置变量，那么将跳过该组中的所有测试用例。有关 &lt;code&gt;require&lt;/code&gt; 功能的详细信息，请参见功能 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f43fa665fa7746b66b55e1550ce1441ca788c63" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;require&lt;/code&gt; specifies configuration variables that are required by the test case (or &lt;code&gt;init_per_testcase/2&lt;/code&gt; or &lt;code&gt;end_per_testcase/2&lt;/code&gt;). If the required configuration variables are not found in any of the configuration files, the test case is skipped. For details about the &lt;code&gt;require&lt;/code&gt; functionality, see function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标记 &lt;code&gt;require&lt;/code&gt; 指定测试用例所需的配置变量（或 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 或 &lt;code&gt;end_per_testcase/2&lt;/code&gt; ）。如果在任何配置文件中都找不到所需的配置变量，那么将跳过测试用例。有关 &lt;code&gt;require&lt;/code&gt; 功能的详细信息，请参见功能 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb7858b354350ab4f0327568ec7e4c4a738e1efd" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;timetrap&lt;/code&gt; sets the maximum time that each test case is allowed to execute (including &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt;). If the timetrap time is exceeded, the test case fails with reason &lt;code&gt;timetrap_timeout&lt;/code&gt;. A &lt;code&gt;TimeFunc&lt;/code&gt; function can be used to set a new timetrap by returning a &lt;code&gt;TimeVal&lt;/code&gt;. It can also be used to trigger a timetrap time-out by, at some point, returning a value other than a &lt;code&gt;TimeVal&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Tag &lt;code&gt;timetrap&lt;/code&gt; 设置允许每个测试用例执行的最长时间（包括 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; ）。如果超过了超时时间，则测试用例将失败，原因为 &lt;code&gt;timetrap_timeout&lt;/code&gt; 。一个 &lt;code&gt;TimeFunc&lt;/code&gt; 功能可用于通过返回设置新的timetrap &lt;code&gt;TimeVal&lt;/code&gt; 。还可以通过在某个时候返回 &lt;code&gt;TimeVal&lt;/code&gt; 以外的值来触发超时。有关详细信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="22c64cb3bbc94cdf7758855dd0abf0e6e66c2d5d" translate="yes" xml:space="preserve">
          <source>Tag &lt;code&gt;timetrap&lt;/code&gt; sets the maximum time that the test case is allowed to execute. If the timetrap time is exceeded, the test case fails with reason &lt;code&gt;timetrap_timeout&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; are included in the timetrap time. A &lt;code&gt;TimeFunc&lt;/code&gt; function can be used to set a new timetrap by returning a &lt;code&gt;TimeVal&lt;/code&gt;. It can also be used to trigger a timetrap time-out by, at some point, returning a value other than a &lt;code&gt;TimeVal&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Tag &lt;code&gt;timetrap&lt;/code&gt; 设置允许测试用例执行的最长时间。如果超过了超时时间，则测试用例将失败，原因为 &lt;code&gt;timetrap_timeout&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 时间中包含init_per_testcase / 2和 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 。一个 &lt;code&gt;TimeFunc&lt;/code&gt; 功能可用于通过返回设置新的timetrap &lt;code&gt;TimeVal&lt;/code&gt; 。还可以通过在某个时候返回 &lt;code&gt;TimeVal&lt;/code&gt; 以外的值来触发超时。有关详细信息，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;Timetrap Time-Outs&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="89a60b10c6d51637e3c074271431727f5e04acf4" translate="yes" xml:space="preserve">
          <source>Tag = atom()</source>
          <target state="translated">Tag=atom()</target>
        </trans-unit>
        <trans-unit id="68ddd91d0b9671a791224a07e7c4440e749e446a" translate="yes" xml:space="preserve">
          <source>Tagalog</source>
          <target state="translated">Tagalog</target>
        </trans-unit>
        <trans-unit id="d97ec9a0d0dd8012061bd1e25a018f7d246bc720" translate="yes" xml:space="preserve">
          <source>Tagbanwa</source>
          <target state="translated">Tagbanwa</target>
        </trans-unit>
        <trans-unit id="0ea98ee2966f1a8d2f98d0a5da489f41da74714d" translate="yes" xml:space="preserve">
          <source>Tags aprops (&lt;code&gt;tags-apropos&lt;/code&gt;) - Display list of all tags in tags table REGEXP matches.</source>
          <target state="translated">标签aprops（ &lt;code&gt;tags-apropos&lt;/code&gt; ） -在标签表REGEXP匹配的所有标签的显示列表。</target>
        </trans-unit>
        <trans-unit id="d4f0c99b831a4946575130ded67ce565cb0d708d" translate="yes" xml:space="preserve">
          <source>Tags are not mentioned any more in this User's Guide.</source>
          <target state="translated">标签在本用户指南中不再提及。</target>
        </trans-unit>
        <trans-unit id="0f82a46a5e411e593e3fc9e2da286865bcb2e4ed" translate="yes" xml:space="preserve">
          <source>Tags is a standard Emacs package used to record information about source files in large development projects. In addition to listing the files of a project, a tags file normally contains information about all functions and variables that are defined. By far, the most useful command of the tags system is its ability to find the definition of functions in any file in the project. However the Tags system is not limited to this feature, for example, it is possible to do a text search in all files in a project, or to perform a project-wide search and replace.</source>
          <target state="translated">标签是一个标准的Emacs包,用于记录大型开发项目中源文件的信息。除了列出一个项目的文件外,tags文件通常还包含所有定义的函数和变量的信息。到目前为止,tags系统最有用的命令是它能够找到项目中任何文件中的函数定义。然而tags系统并不局限于这个功能,例如,可以在一个项目中的所有文件中进行文本搜索,也可以在整个项目中进行搜索和替换。</target>
        </trans-unit>
        <trans-unit id="4e5cc17a9625b1ef996d5f041d154602dfcaa438" translate="yes" xml:space="preserve">
          <source>Tags other than the earlier mentioned are ignored by the test server.</source>
          <target state="translated">除前面提到的标签外,其他标签都被测试服务器忽略。</target>
        </trans-unit>
        <trans-unit id="f4446936a2326a1b426b4bb095f8f0bc39469810" translate="yes" xml:space="preserve">
          <source>Tags used to be important for all users of ASN.1, because it was necessary to add tags manually to certain constructs in order for the ASN.1 specification to be valid. Example of an old-style specification:</source>
          <target state="translated">标签曾经对ASN.1的所有用户都很重要,因为为了使ASN.1规范有效,有必要对某些构造手动添加标签。旧式规范的例子。</target>
        </trans-unit>
        <trans-unit id="7ce68ff3f210c997cf191cc3047dad75cfbe97db" translate="yes" xml:space="preserve">
          <source>Tai_Le</source>
          <target state="translated">Tai_Le</target>
        </trans-unit>
        <trans-unit id="30754c9b404b9f791325a342fd0c615c1607ad6a" translate="yes" xml:space="preserve">
          <source>Tai_Tham</source>
          <target state="translated">Tai_Tham</target>
        </trans-unit>
        <trans-unit id="d56a5ea60a6f1aee9d29df15fa3ff172f1ecef8f" translate="yes" xml:space="preserve">
          <source>Tai_Viet</source>
          <target state="translated">Tai_Viet</target>
        </trans-unit>
        <trans-unit id="712d7b0229a9c9b792d9ee5e5f566583688440d1" translate="yes" xml:space="preserve">
          <source>Take a look at the DTD and observe that the structure of an XML document that is conformant to this DTD must have one motorcycles element (the root element). The motorcycles element must have at least one bike element. After each bike element it may be a date element. The content of the date element is #PCDATA (Parsed Character DATA), i.e. raw text. Observe that if #PCDATA must have a &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; or a &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; character it must be written as &lt;code&gt;&quot;&amp;amp;lt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;amp;amp;&quot;&lt;/code&gt; respectively. Also other character entities exists similar to the ones in HTML and SGML.</source>
          <target state="translated">看一下DTD并观察到符合该DTD的XML文档的结构必须具有一个单车元素（根元素）。摩托车元素必须至少具有一个自行车元素。在每个自行车元素之后，它可能是日期元素。date元素的内容为#PCDATA（已解析字符DATA），即原始文本。请注意，如果#PCDATA必须具有 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 字符，则必须将其写为 &lt;code&gt;&quot;&amp;amp;lt;&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;&amp;amp;amp;&quot;&lt;/code&gt; 分别。还有其他字符实体，类似于HTML和SGML中的字符实体。</target>
        </trans-unit>
        <trans-unit id="f1944ad3e238ccbfad283666266458fed59a2c12" translate="yes" xml:space="preserve">
          <source>Take care of &lt;code&gt;&lt;a href=&quot;#msg&quot;&gt;system messages&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">照顾 &lt;code&gt;&lt;a href=&quot;#msg&quot;&gt;system messages&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5cb213c0c3fbc91fd264762706d8f4c2755430c" translate="yes" xml:space="preserve">
          <source>Take time stamps with &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time/0&lt;/a&gt;&lt;/code&gt; and calculate the time difference using ordinary subtraction. The result is in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt;. If you want to convert the result to another time unit, you can use &lt;code&gt;&lt;a href=&quot;erlang#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time/0&lt;/a&gt;&lt;/code&gt; 获取时间戳，并使用普通减法计算时间差。结果以 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 。如果要将结果转换为另一个时间单位，可以使用 &lt;code&gt;&lt;a href=&quot;erlang#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9ada3a67eabb29a57989f4f801f3c2a4ec53a23" translate="yes" xml:space="preserve">
          <source>Take time stamps with &lt;code&gt;erlang:now/0&lt;/code&gt; and calculate the difference in time with &lt;code&gt;timer:now_diff/2&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;erlang:now/0&lt;/code&gt; 获取时间戳，并使用 &lt;code&gt;timer:now_diff/2&lt;/code&gt; 计算时间差。</target>
        </trans-unit>
        <trans-unit id="aad56d0b07d8624ffdf8f3dd6234bf0a87980ba7" translate="yes" xml:space="preserve">
          <source>Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is &lt;code&gt;namelist&lt;/code&gt;, which returns the tuple &lt;code&gt;{namelist, [binary()]}&lt;/code&gt;, containing the names of all (unique) named subpatterns in the regular expression. For example:</source>
          <target state="translated">接受已编译的正则表达式和一个项目，然后从正则表达式返回相关数据。唯一受支持的项是 &lt;code&gt;namelist&lt;/code&gt; ，它返回元组 &lt;code&gt;{namelist, [binary()]}&lt;/code&gt; ，其中包含正则表达式中所有（唯一）命名子模式的名称。例如：</target>
        </trans-unit>
        <trans-unit id="19bfeb3244c87dc7345b2a90b3a504725b9fc5d5" translate="yes" xml:space="preserve">
          <source>Takes a function from &lt;code&gt;A&lt;/code&gt;s to &lt;code&gt;B&lt;/code&gt;s, and a list of &lt;code&gt;A&lt;/code&gt;s and produces a list of &lt;code&gt;B&lt;/code&gt;s by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order depends on the implementation.</source>
          <target state="translated">接受从 &lt;code&gt;A&lt;/code&gt; s到 &lt;code&gt;B&lt;/code&gt; s 的函数，以及 &lt;code&gt;A&lt;/code&gt; 的列表，并通过将函数应用于列表中的每个元素来生成 &lt;code&gt;B&lt;/code&gt; 的列表。此函数用于获取返回值。评估顺序取决于实施方式。</target>
        </trans-unit>
        <trans-unit id="55656bdc88d1b3d6dee5f6b3418d04f6d2a52efe" translate="yes" xml:space="preserve">
          <source>Takes a function from &lt;code&gt;A&lt;/code&gt;s to lists of &lt;code&gt;B&lt;/code&gt;s, and a list of &lt;code&gt;A&lt;/code&gt;s (&lt;code&gt;List1&lt;/code&gt;) and produces a list of &lt;code&gt;B&lt;/code&gt;s by applying the function to every element in &lt;code&gt;List1&lt;/code&gt; and appending the resulting lists.</source>
          <target state="translated">将函数从 &lt;code&gt;A&lt;/code&gt; s到 &lt;code&gt;B&lt;/code&gt; s的列表，以及 &lt;code&gt;A&lt;/code&gt; s 的列表（ &lt;code&gt;List1&lt;/code&gt; ），并通过将函数应用于 &lt;code&gt;List1&lt;/code&gt; 中的每个元素并附加结果列表来生成 &lt;code&gt;B&lt;/code&gt; s的列表。</target>
        </trans-unit>
        <trans-unit id="52fae012e5e055efc934f9ec9bd9253885a38340" translate="yes" xml:space="preserve">
          <source>Takes a list of child specification as argument and returns &lt;code&gt;ok&lt;/code&gt; if all of them are syntactically correct, otherwise &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">将子规范的列表作为参数，如果所有语法都正确，则返回 &lt;code&gt;ok&lt;/code&gt; ，否则返回 &lt;code&gt;{error,Error}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="506646efe2a13a3aaee03a7ed507effbc3b857f9" translate="yes" xml:space="preserve">
          <source>Takes a list of key-value tuples elements and builds a map. The associations can be in any order, and both keys and values in the association can be of any term. If the same key appears more than once, the latter (right-most) value is used and the previous values are ignored.</source>
          <target state="translated">取一个键值元组元素的列表,并建立一个地图。关联可以是任何顺序,关联中的键和值可以是任何项。如果同一个键出现一次以上,则使用后一个(最右边)的值,忽略前面的值。</target>
        </trans-unit>
        <trans-unit id="8b5587ad9b89a81a22b94093c25712098169010e" translate="yes" xml:space="preserve">
          <source>Takes a pattern with &quot;don't care&quot; variables denoted as a &lt;code&gt;'_'&lt;/code&gt; parameter. This function returns a list of records that matched the pattern. Since the second element of a record in a table is considered to be the key for the record, the performance of this function depends on whether this key is bound or not.</source>
          <target state="translated">采用带有&amp;ldquo;无关&amp;rdquo;变量的模式，该变量表示为 &lt;code&gt;'_'&lt;/code&gt; 参数。此函数返回与模式匹配的记录列表。由于表中记录的第二个元素被视为该记录的键，因此此功能的性能取决于此键是否绑定。</target>
        </trans-unit>
        <trans-unit id="6aa0f10b3c4d20cfef7ffd9aac9c02c7e099a09b" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ErrorDesc&lt;/code&gt; returned by load, unload, or reload functions and returns a string that describes the error or warning.</source>
          <target state="translated">获取由加载，卸载或重新加载函数返回的 &lt;code&gt;ErrorDesc&lt;/code&gt; ，并返回描述错误或警告的字符串。</target>
        </trans-unit>
        <trans-unit id="57cbfc69dd180e338745075476b0f2367b010aeb" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when processing an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">采用 &lt;code&gt;ErrorDescriptor&lt;/code&gt; 并返回描述错误或警告的字符串。在处理 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构时，通常会隐式调用此函数（请参见 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 一节）。</target>
        </trans-unit>
        <trans-unit id="93bf5f96e7a486360d69cd80e7309017ce816941" translate="yes" xml:space="preserve">
          <source>Takes an additional parameter, which &lt;strong&gt;must&lt;/strong&gt; be the result of &lt;code&gt;record_info(size, &amp;lt;record_type&amp;gt;)&lt;/code&gt;, like in &lt;code&gt;{is_record, '$1', rectype, record_info(size, rectype)}&lt;/code&gt;.</source>
          <target state="translated">接受一个附加参数，该参数&lt;strong&gt;必须&lt;/strong&gt;是 &lt;code&gt;record_info(size, &amp;lt;record_type&amp;gt;)&lt;/code&gt; ，如 &lt;code&gt;{is_record, '$1', rectype, record_info(size, rectype)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c1469847249171e76b7f608e5d60058ff04bd25" translate="yes" xml:space="preserve">
          <source>Takes an error code returned by one of the other functions in the module and creates a textual description of the error.</source>
          <target state="translated">获取模块中其他函数返回的错误代码,并创建错误的文字描述。</target>
        </trans-unit>
        <trans-unit id="a79e919b8abfed5dd81802687c1118f9e75fc341" translate="yes" xml:space="preserve">
          <source>Takes care of any work that is not specifically assigned to a scheduler.</source>
          <target state="translated">处理任何没有专门分配给调度员的工作。</target>
        </trans-unit>
        <trans-unit id="b31c0f53fdbe49aa50563e165f4e3a62fb484ea0" translate="yes" xml:space="preserve">
          <source>Takes care of possible cleanup that is needed when the cache handling process terminates.</source>
          <target state="translated">照顾到缓存处理过程终止时可能需要的清理工作。</target>
        </trans-unit>
        <trans-unit id="46509e2dee350637229abb5245a0cb50da574d1e" translate="yes" xml:space="preserve">
          <source>Takes characters from &lt;code&gt;String&lt;/code&gt; as long as the characters are members of set &lt;code&gt;Characters&lt;/code&gt; or the complement of set &lt;code&gt;Characters&lt;/code&gt;. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt; or &lt;code&gt;trailing&lt;/code&gt;, indicates from which direction characters are to be taken.</source>
          <target state="translated">从取字符 &lt;code&gt;String&lt;/code&gt; ，只要字符集的成员 &lt;code&gt;Characters&lt;/code&gt; 或集合的补 &lt;code&gt;Characters&lt;/code&gt; 。 &lt;code&gt;Dir&lt;/code&gt; 可以是 &lt;code&gt;leading&lt;/code&gt; 或 &lt;code&gt;trailing&lt;/code&gt; ，指示要从哪个方向获取字符。</target>
        </trans-unit>
        <trans-unit id="e93b486ac5971a63d69d4eadcbdf142bace13b4a" translate="yes" xml:space="preserve">
          <source>Takes elements &lt;code&gt;Elem&lt;/code&gt; from &lt;code&gt;List1&lt;/code&gt; while &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate.</source>
          <target state="translated">注意到元素 &lt;code&gt;Elem&lt;/code&gt; 从 &lt;code&gt;List1&lt;/code&gt; ，而 &lt;code&gt;Pred(Elem)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，也就是函数返回其所有元素满足谓词列表的最长前缀。</target>
        </trans-unit>
        <trans-unit id="fbb4f090d8ca065719386cdc9464916982f88f35" translate="yes" xml:space="preserve">
          <source>Takes no argument and returns the value of the node's trace control word. The same is done by &lt;code&gt;erlang:system_info(trace_control_word)&lt;/code&gt;.</source>
          <target state="translated">不带参数，并返回节点的跟踪控制字的值。同样是所做 &lt;code&gt;erlang:system_info(trace_control_word)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de7cf647d0f18821ebb79f5e2e860bbb7ec66c82" translate="yes" xml:space="preserve">
          <source>Takes one argument. If the argument is &lt;code&gt;true&lt;/code&gt;, the call trace message mode for the current process is set to silent for this call and all later calls, that is, call trace messages are inhibited even if &lt;code&gt;{message, true}&lt;/code&gt; is called in the &lt;code&gt;MatchBody&lt;/code&gt; part for a traced function.</source>
          <target state="translated">有一个论点。如果参数为 &lt;code&gt;true&lt;/code&gt; ，则当前进程的呼叫跟踪消息模式将对此呼叫设置为静默，并且所有以后的呼叫，即即使在 &lt;code&gt;MatchBody&lt;/code&gt; 部分中为 &lt;code&gt;{message, true}&lt;/code&gt; 调用了呼叫跟踪消息，也会禁止呼叫跟踪消息跟踪功能。</target>
        </trans-unit>
        <trans-unit id="fd489e11a7379f3da46a8f5de6664950f616c21a" translate="yes" xml:space="preserve">
          <source>Takes one argument: the message. Returns &lt;code&gt;true&lt;/code&gt; and can only be used in the &lt;code&gt;MatchBody&lt;/code&gt; part and when tracing.</source>
          <target state="translated">有一个参数：消息。返回 &lt;code&gt;true&lt;/code&gt; ，并且只能在 &lt;code&gt;MatchBody&lt;/code&gt; 部分和跟踪中使用。</target>
        </trans-unit>
        <trans-unit id="30493b8e01e1c19322e9bf0b28ad578877d961a6" translate="yes" xml:space="preserve">
          <source>Takes one unsigned integer argument, sets the value of the node's trace control word to the value of the argument, and returns the previous value. The same is done by &lt;code&gt;erlang:system_flag(trace_control_word, Value)&lt;/code&gt;. It is only allowed to use &lt;code&gt;set_tcw&lt;/code&gt; in the &lt;code&gt;MatchBody&lt;/code&gt; part when tracing.</source>
          <target state="translated">接受一个无符号整数参数，将节点的跟踪控制字的值设置为该参数的值，并返回前一个值。同样是所做 &lt;code&gt;erlang:system_flag(trace_control_word, Value)&lt;/code&gt; 。跟踪时，仅允许在 &lt;code&gt;MatchBody&lt;/code&gt; 部分中使用 &lt;code&gt;set_tcw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09da2fcd1e2efe51ebf24c738e905ab46e139be1" translate="yes" xml:space="preserve">
          <source>Takes over the distributed application &lt;code&gt;Application&lt;/code&gt;, which executes at another node &lt;code&gt;Node&lt;/code&gt;. At the current node, the application is restarted by calling &lt;code&gt;Module:start({takeover,Node},StartArgs)&lt;/code&gt;. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;StartArgs&lt;/code&gt; are retrieved from the loaded application specification. The application at the other node is not stopped until the startup is completed, that is, when &lt;code&gt;Module:start/2&lt;/code&gt; and any calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; have returned.</source>
          <target state="translated">接管分布式应用程序 &lt;code&gt;Application&lt;/code&gt; ，该应用程序在另一个节点 &lt;code&gt;Node&lt;/code&gt; 上执行。在当前节点，通过调用 &lt;code&gt;Module:start({takeover,Node},StartArgs)&lt;/code&gt; 重新启动应用程序。从加载的应用程序规范中检索 &lt;code&gt;Module&lt;/code&gt; 和 &lt;code&gt;StartArgs&lt;/code&gt; 。直到启动完成，即返回 &lt;code&gt;Module:start/2&lt;/code&gt; 和对 &lt;code&gt;Module:start_phase/3&lt;/code&gt; 的所有调用后，其他节点上的应用程序才会停止。</target>
        </trans-unit>
        <trans-unit id="0a647ce123db14489ad591cd488d47d856711e8f" translate="yes" xml:space="preserve">
          <source>Takes the list of characters &lt;code&gt;String&lt;/code&gt; and tries to scan (tokenize) them. Returns one of the following:</source>
          <target state="translated">获取 &lt;code&gt;String&lt;/code&gt; 的列表，然后尝试扫描（标记）它们。返回以下之一：</target>
        </trans-unit>
        <trans-unit id="3d44d06fda277fec8865be5e542736e38ae54f97" translate="yes" xml:space="preserve">
          <source>Takri</source>
          <target state="translated">Takri</target>
        </trans-unit>
        <trans-unit id="86c2b6275f076b31c4be9812e835dab2a6f07ccf" translate="yes" xml:space="preserve">
          <source>Tamil</source>
          <target state="translated">Tamil</target>
        </trans-unit>
        <trans-unit id="efa2b1a6ae1600d5f4d3d0746df43e1f2e23a7fa" translate="yes" xml:space="preserve">
          <source>Tar files can be created in one operation using function &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#create-3&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用功能 &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#create-3&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt; 在一个操作中创建Tar文件。</target>
        </trans-unit>
        <trans-unit id="25d3b39619df66bdd0c7bc6d8ee96ee14afa2c24" translate="yes" xml:space="preserve">
          <source>Tear down a &quot;virtual&quot; connection</source>
          <target state="translated">拆掉 &quot;虚拟 &quot;连接</target>
        </trans-unit>
        <trans-unit id="82bd3966ddc98061bf824297ca3d00cb4214a988" translate="yes" xml:space="preserve">
          <source>Tell &lt;code&gt;dbg&lt;/code&gt; to trace function Calls</source>
          <target state="translated">告诉 &lt;code&gt;dbg&lt;/code&gt; 跟踪函数调用</target>
        </trans-unit>
        <trans-unit id="835e2ece47c360b333f1a47931eef30669499f1b" translate="yes" xml:space="preserve">
          <source>Tell Erlang to use another primitive TCP module than &lt;code&gt;inet_tcp&lt;/code&gt;.</source>
          <target state="translated">告诉Erlang使用不同于 &lt;code&gt;inet_tcp&lt;/code&gt; 的另一个原始TCP模块。</target>
        </trans-unit>
        <trans-unit id="6cb70b65ff1780e8afb327f1a87fff375570f8ad" translate="yes" xml:space="preserve">
          <source>Tell Erlang to use another primitive UDP module than &lt;code&gt;inet_udp&lt;/code&gt;.</source>
          <target state="translated">告诉Erlang使用不同于 &lt;code&gt;inet_udp&lt;/code&gt; 的另一个原始UDP模块。</target>
        </trans-unit>
        <trans-unit id="9b7ea6ec990e7644aa1c8797918e78fc5d49e152" translate="yes" xml:space="preserve">
          <source>Tell it specifically to trace the &lt;code&gt;et:trace_me/5&lt;/code&gt; function</source>
          <target state="translated">专门告诉它跟踪 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="57dd041bbdd098628d1f020b85579436c5820b6e" translate="yes" xml:space="preserve">
          <source>Tell the release handler to use the &lt;code&gt;releases&lt;/code&gt; directory in our target structure instead of &lt;code&gt;$OTP_ROOT/releases&lt;/code&gt;. This is done by setting the SASL environment variable &lt;code&gt;releases_dir&lt;/code&gt;, either from the command line (&lt;code&gt;-sasl releases_dir &amp;lt;target-dir&amp;gt;/releases&lt;/code&gt;) or in &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">告诉发布处理程序使用目标结构中的 &lt;code&gt;releases&lt;/code&gt; 目录而不是 &lt;code&gt;$OTP_ROOT/releases&lt;/code&gt; 。这可以通过在命令行（ &lt;code&gt;-sasl releases_dir &amp;lt;target-dir&amp;gt;/releases&lt;/code&gt; ）或 &lt;code&gt;sys.config&lt;/code&gt; 中设置SASL环境变量 &lt;code&gt;releases_dir&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="572e18ff0add697584fb4ac9dc773051bb0e16f3" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests &lt;code&gt;n&lt;/code&gt; times (described later).</source>
          <target state="translated">告诉 &lt;code&gt;Common Test&lt;/code&gt; 重复 &lt;code&gt;n&lt;/code&gt; 次测试（稍后描述）。</target>
        </trans-unit>
        <trans-unit id="e4b8cb1936cb9df69d4554104909777bb2678271" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests for duration of time (described later).</source>
          <target state="translated">告诉 &lt;code&gt;Common Test&lt;/code&gt; 在一段时间内重复测试（稍后描述）。</target>
        </trans-unit>
        <trans-unit id="2898ea99fa920352a923e39692a4049acc36eb31" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;Common Test&lt;/code&gt; to repeat the tests until &lt;code&gt;stop_time&lt;/code&gt; (described later).</source>
          <target state="translated">告诉 &lt;code&gt;Common Test&lt;/code&gt; 重复测试直到 &lt;code&gt;stop_time&lt;/code&gt; （稍后描述）。</target>
        </trans-unit>
        <trans-unit id="e085c8fd09860d3c0a7a2525ced06370c6aa9e09" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;erlsrv&lt;/code&gt; how to stop the Erlang emulator. Default is to kill it (Win32 TerminateProcess), but this action can specify any Erlang shell command that will be executed in the emulator to make it stop. The emulator is expected to stop within 30 seconds after the command is issued in the shell. If the emulator is not stopped, it reports a running state to the service manager.</source>
          <target state="translated">告诉 &lt;code&gt;erlsrv&lt;/code&gt; 如何停止Erlang仿真器。默认是杀死它（Win32 TerminateProcess），但是此操作可以指定将在模拟器中执行的任何Erlang shell命令以使其停止。在外壳中发出命令后，仿真器有望在30秒内停止。如果仿真器没有停止，它将向服务管理器报告运行状态。</target>
        </trans-unit>
        <trans-unit id="c0b8c2f094ce49a65d1ca33bf7b4040a376bc6cf" translate="yes" xml:space="preserve">
          <source>Tells explicitly which XML Schema documents to use to validate the XML document. Used together with the &lt;code&gt;{validation,schema}&lt;/code&gt; option.</source>
          <target state="translated">明确告知要使用哪些XML Schema文档来验证XML文档。与 &lt;code&gt;{validation,schema}&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="0492b5903796ca58eb4f908e0044cfd75d4cdeda" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to delete the child specification identified by &lt;code&gt;Id&lt;/code&gt;. The corresponding child process must not be running. Use &lt;code&gt;&lt;a href=&quot;#terminate_child-2&quot;&gt;terminate_child/2&lt;/a&gt;&lt;/code&gt; to terminate it.</source>
          <target state="translated">告诉主管 &lt;code&gt;SupRef&lt;/code&gt; 删除 &lt;code&gt;Id&lt;/code&gt; 标识的子规范。相应的子进程一定不能运行。使用 &lt;code&gt;&lt;a href=&quot;#terminate_child-2&quot;&gt;terminate_child/2&lt;/a&gt;&lt;/code&gt; 终止它。</target>
        </trans-unit>
        <trans-unit id="854d6e6ea1b17fd3503e1214e269e4327574ba1f" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to restart a child process corresponding to the child specification identified by &lt;code&gt;Id&lt;/code&gt;. The child specification must exist, and the corresponding child process must not be running.</source>
          <target state="translated">告诉主管 &lt;code&gt;SupRef&lt;/code&gt; 重新启动与 &lt;code&gt;Id&lt;/code&gt; 标识的子级规范相对应的子级进程。子规范必须存在，并且相应的子进程一定不能运行。</target>
        </trans-unit>
        <trans-unit id="83cd5f49c19723bcbd4b9d8efb377bc645bf4fe0" translate="yes" xml:space="preserve">
          <source>Tells supervisor &lt;code&gt;SupRef&lt;/code&gt; to terminate the specified child.</source>
          <target state="translated">告诉主管 &lt;code&gt;SupRef&lt;/code&gt; 终止指定的孩子。</target>
        </trans-unit>
        <trans-unit id="caff595a530bcc59815e7fe18f59345b5ce49ff6" translate="yes" xml:space="preserve">
          <source>Tells the DNS client &lt;code&gt;inet_res(3)&lt;/code&gt; to look up IPv6 addresses. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">告诉DNS客户端 &lt;code&gt;inet_res(3)&lt;/code&gt; 查找IPv6地址。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fdb6ce16675d8c8dd66ce3986070e67a82e2171" translate="yes" xml:space="preserve">
          <source>Tells the DNS client &lt;code&gt;inet_res(3)&lt;/code&gt; to use TCP (Virtual Circuit) instead of UDP. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">告诉DNS客户端 &lt;code&gt;inet_res(3)&lt;/code&gt; 使用TCP（虚拟电路）代替UDP。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78c529a078634064f178098741caf31cb78a48a7" translate="yes" xml:space="preserve">
          <source>Tells the compiler to generate functions for conversion between names (as atoms) and numbers and conversely for the specified &lt;code&gt;EnumTypeName&lt;/code&gt;. There can be multiple occurrences of this option to specify several type names. The type names must be declared as &lt;code&gt;ENUMERATIONS&lt;/code&gt; in the ASN.1 specification.</source>
          <target state="translated">告诉编译器生成用于在名称（作为原子）和数字之间进行转换的函数，以及相反地为指定的 &lt;code&gt;EnumTypeName&lt;/code&gt; 进行转换的函数。可以多次出现此选项，以指定多个类型名称。类型名称必须在ASN.1规范中声明为 &lt;code&gt;ENUMERATIONS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a526775f5490371c812a9e90593190860b2feeb" translate="yes" xml:space="preserve">
          <source>Tells the process to change code. The process must be suspended to handle this message. Argument &lt;code&gt;Extra&lt;/code&gt; is reserved for each process to use as its own. Function &lt;code&gt;Module:system_code_change/4&lt;/code&gt; is called. &lt;code&gt;OldVsn&lt;/code&gt; is the old version of the &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">告诉过程更改代码。必须暂停该过程以处理此消息。Argument &lt;code&gt;Extra&lt;/code&gt; 保留供每个进程单独使用。功能 &lt;code&gt;Module:system_code_change/4&lt;/code&gt; 被调用。 &lt;code&gt;OldVsn&lt;/code&gt; 是 &lt;code&gt;Module&lt;/code&gt; 的旧版本。</target>
        </trans-unit>
        <trans-unit id="ea6c03461dc3a543514f149ca6bb793d0a9e158a" translate="yes" xml:space="preserve">
          <source>Telugu</source>
          <target state="translated">Telugu</target>
        </trans-unit>
        <trans-unit id="48a0458cda5329a0ce2df604a592dac2d33cdef2" translate="yes" xml:space="preserve">
          <source>Temporary error: Try again.</source>
          <target state="translated">暂时性错误。再试一次。</target>
        </trans-unit>
        <trans-unit id="c5c7003721dac5bbb05b8381d825683179e7de3e" translate="yes" xml:space="preserve">
          <source>Temporary files and the output file can be compressed. Defaults &lt;code&gt;false&lt;/code&gt;, which implies that written files are not compressed. Regardless of the value of option &lt;code&gt;compressed&lt;/code&gt;, compressed files can always be read. Notice that reading and writing compressed files are significantly slower than reading and writing uncompressed files.</source>
          <target state="translated">临时文件和输出文件可以压缩。默认 &lt;code&gt;false&lt;/code&gt; ，这意味着未压缩写入的文件。无论选项 &lt;code&gt;compressed&lt;/code&gt; 的值如何，始终可以读取压缩文件。请注意，读写压缩文件比读写未压缩文件要慢得多。</target>
        </trans-unit>
        <trans-unit id="1532f885d5197fe3f8b41aeb41de89534d082e50" translate="yes" xml:space="preserve">
          <source>Term comparison operators return the Boolean value of the expression, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">术语比较运算符返回表达式的布尔值 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30fd6857122636ec1a6eaf8d0167df27dbbc2068" translate="yes" xml:space="preserve">
          <source>Term comparisons</source>
          <target state="translated">术语比较</target>
        </trans-unit>
        <trans-unit id="36df6bde5c18fe5e5d93fd385843cb7b8a0873f6" translate="yes" xml:space="preserve">
          <source>Term constructions/literals are translated as much as is needed to get them into valid match specification. This way tuples are made into match specification tuple constructions (a one element tuple containing the tuple) and constant expressions are used when importing variables from the environment. Records are also translated into plain tuple constructions, calls to element, and so on. The guard test &lt;code&gt;is_record/2&lt;/code&gt; is translated into match specification code using the three parameter version that is built into match specification, so that &lt;code&gt;is_record(A,t)&lt;/code&gt; is translated into &lt;code&gt;{is_record,'$1',t,5}&lt;/code&gt; if the record size of record type &lt;code&gt;t&lt;/code&gt; is 5.</source>
          <target state="translated">术语结构/文字的翻译量足以使它们进入有效的匹配规范。这样，将元组制成匹配规范元组结构（包含元组的一个元素元组），并在从环境中导入变量时使用常量表达式。记录也将转换为简单的元组构造，对元素的调用等。使用匹配规范中内置的三个参数版本将保护测试 &lt;code&gt;is_record/2&lt;/code&gt; 转换为匹配规范代码，因此如果记录大小， &lt;code&gt;is_record(A,t)&lt;/code&gt; 转换为 &lt;code&gt;{is_record,'$1',t,5}&lt;/code&gt; 记录类型 &lt;code&gt;t&lt;/code&gt; 的值为5。</target>
        </trans-unit>
        <trans-unit id="908579f030e6ac5e6a39f29bf0038f9182d1fd66" translate="yes" xml:space="preserve">
          <source>Term is not a binary.</source>
          <target state="translated">术语不是二进制。</target>
        </trans-unit>
        <trans-unit id="0f9a73563feaeca50f714fb97a106cd148e6a35f" translate="yes" xml:space="preserve">
          <source>Term passed as the third argument to the &lt;code&gt;&lt;a href=&quot;diameter_transport#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; function of the relevant &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; in order to start a transport process. Defaults to the empty list.</source>
          <target state="translated">术语作为第三个参数传递给相关 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport module&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;diameter_transport#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 函数，以启动传输过程。默认为空列表。</target>
        </trans-unit>
        <trans-unit id="dfe25b408798a81c28611f4d808102f77953debd" translate="yes" xml:space="preserve">
          <source>Term to be sent to &lt;code&gt;&lt;a href=&quot;gen_event#add_handler-3&quot;&gt;gen_event:add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要发送到 &lt;code&gt;&lt;a href=&quot;gen_event#add_handler-3&quot;&gt;gen_event:add_handler/3&lt;/a&gt;&lt;/code&gt; 的术语。</target>
        </trans-unit>
        <trans-unit id="09f89796d08f4695c60595fc0a731d30d3e1ce2a" translate="yes" xml:space="preserve">
          <source>TermConstruct = {{}} | {{ ConditionExpression, ... }} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression, ...] | #{} | #{term() =&amp;gt; ConditionExpression, ...} | NonCompositeTerm | Constant</source>
          <target state="translated">TermConstruct = {{}} | {{ConditionExpression，...}} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression，...] | ＃{} | ＃{term（）=&amp;gt; ConditionExpression，...} | NonCompositeTerm | 不变</target>
        </trans-unit>
        <trans-unit id="301994d75fc00647fccf09f8223c73d02716a9f6" translate="yes" xml:space="preserve">
          <source>TermConstruct = {{}} | {{ ConditionExpression, ... }} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression, ...] | &lt;code&gt;#{}&lt;/code&gt; | #{term() =&amp;gt; ConditionExpression, ...} | NonCompositeTerm | Constant</source>
          <target state="translated">TermConstruct = {{}} | {{ConditionExpression，...}} | &lt;code&gt;[]&lt;/code&gt; | [ConditionExpression，...] | &lt;code&gt;#{}&lt;/code&gt; | ＃{term（）=&amp;gt; ConditionExpression，...} | NonCompositeTerm | 不变</target>
        </trans-unit>
        <trans-unit id="317c27ee519ee48f9c75d7b40776395c672e14f6" translate="yes" xml:space="preserve">
          <source>Terminal I/O is slightly easier than file I/O. The output is meant for human reading and is usually Erlang syntax (for example, in the shell). There exists syntactic representation of any Unicode character without displaying the glyph (instead written as &lt;code&gt;\x&lt;/code&gt;{&lt;code&gt;HHH&lt;/code&gt;}). Unicode data can therefore usually be displayed even if the terminal as such does not support the whole Unicode range.</source>
          <target state="translated">终端I / O比文件I / O稍微容易一些。输出是供人类阅读的，通常是Erlang语法（例如，在shell中）。存在任何Unicode字符的语法表示形式，但不显示该字形（而是写为 &lt;code&gt;\x&lt;/code&gt; { &lt;code&gt;HHH&lt;/code&gt; }）。因此，即使终端本身不支持整个Unicode范围，通常也可以显示Unicode数据。</target>
        </trans-unit>
        <trans-unit id="3782509534bdc8ecddfd675751de4bf801b681ec" translate="yes" xml:space="preserve">
          <source>Terminal categories may only appear in the right hand sides (= &lt;code&gt;rhs&lt;/code&gt;) of grammar rules.</source>
          <target state="translated">最终类别只能出现在语法规则的右侧（= &lt;code&gt;rhs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="157aa94e1d362822c48f2dff41e099927c9cb618" translate="yes" xml:space="preserve">
          <source>Terminate the transport process without Disconnect-Peer-Request being sent to the peer.</source>
          <target state="translated">在没有向对等体发送Disconnect-Peer-Request的情况下终止传输过程。</target>
        </trans-unit>
        <trans-unit id="86018e6ee1482838e5a0aeb6ac5e33225172df60" translate="yes" xml:space="preserve">
          <source>Terminate the traversal and return &lt;code&gt;[Value | Acc]&lt;/code&gt;.</source>
          <target state="translated">终止遍历并返回 &lt;code&gt;[Value | Acc]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef4447a97be9cdfc58e0bd40da8f22d111904fcd" translate="yes" xml:space="preserve">
          <source>Terminates &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">终止 &lt;code&gt;etop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baa4e4f2aee82c277b2987190bacf935eba00880" translate="yes" xml:space="preserve">
          <source>Terminates a test case with an error message specified by a format string and a list of values (used as arguments to &lt;code&gt;io_lib:format/2&lt;/code&gt;).</source>
          <target state="translated">使用格式字符串和值列表（用作 &lt;code&gt;io_lib:format/2&lt;/code&gt; 的参数）指定的错误消息终止测试用例。</target>
        </trans-unit>
        <trans-unit id="5a0abbf285140ae9fd7bfbb3aeee2d59660f0146" translate="yes" xml:space="preserve">
          <source>Terminates a test case with the specified error &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">终止具有指定错误 &lt;code&gt;Reason&lt;/code&gt; 的测试用例。</target>
        </trans-unit>
        <trans-unit id="2ab95c672b98796e32387d13d61b81abc40092fa" translate="yes" xml:space="preserve">
          <source>Terminates all processes listed in the window using &lt;code&gt;exit(Pid,kill)&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;exit(Pid,kill)&lt;/code&gt; 终止窗口中列出的所有进程。</target>
        </trans-unit>
        <trans-unit id="004c6a43d05b92bb17dce6f779b63e9a29b1b7f4" translate="yes" xml:space="preserve">
          <source>Terminates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Reason&lt;/code&gt; and &lt;code&gt;NewData&lt;/code&gt;, if specified.</source>
          <target state="translated">如果指定了 &lt;code&gt;Reason&lt;/code&gt; ，则通过使用Reason和 &lt;code&gt;NewData&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 终止 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f271847fb13d7634791602927e994ef860fda84e" translate="yes" xml:space="preserve">
          <source>Terminates the Crashdump Viewer and closes all GUI windows.</source>
          <target state="translated">终止Crashdump Viewer并关闭所有GUI窗口。</target>
        </trans-unit>
        <trans-unit id="519a117c3896c0663badf989d4b915309b17e65a" translate="yes" xml:space="preserve">
          <source>Terminates the calling thread with the exit value passed as argument. &lt;code&gt;exit_value&lt;/code&gt; is a pointer to an exit value or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">使用作为参数传递的退出值终止调用线程。 &lt;code&gt;exit_value&lt;/code&gt; 是指向退出值或 &lt;code&gt;NULL&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="f20f699b09860115b81d54774a7222feaffe4a96" translate="yes" xml:space="preserve">
          <source>Terminates the character class</source>
          <target state="translated">终止字符类</target>
        </trans-unit>
        <trans-unit id="bbd0750c043e7f8c526d39a2181c885faf307424" translate="yes" xml:space="preserve">
          <source>Terminates the process using &lt;code&gt;exit(Pid,kill)&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;exit(Pid,kill)&lt;/code&gt; 终止进程。</target>
        </trans-unit>
        <trans-unit id="332a0cca120165a32d4b04552488dcf492ca6ec7" translate="yes" xml:space="preserve">
          <source>Terminating closing square bracket</source>
          <target state="translated">终止关闭方括号</target>
        </trans-unit>
        <trans-unit id="0f64c2787dcc796a369590e14f97af233d6dfc3a" translate="yes" xml:space="preserve">
          <source>Termination of a process executing a dirty NIF can only be completed up to a certain point while it executes the dirty NIF. All Erlang resources, such as its registered name and its ETS tables, are released. All links and monitors are triggered. The execution of the NIF is, however, &lt;strong&gt;not&lt;/strong&gt; stopped. The NIF can safely continue execution, allocate heap memory, and so on, but it is of course better to stop executing as soon as possible. The NIF can check whether a current process is alive using &lt;code&gt;&lt;a href=&quot;#enif_is_current_process_alive&quot;&gt;enif_is_current_process_alive&lt;/a&gt;&lt;/code&gt;. Communication using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enif_port_command&quot;&gt;enif_port_command&lt;/a&gt;&lt;/code&gt; is also dropped when the sending process is not alive. Deallocation of certain internal resources, such as process heap and process control block, is delayed until the dirty NIF has completed.</source>
          <target state="translated">执行脏NIF的进程的终止只能在执行脏NIF的某个时刻完成。释放所有Erlang资源，例如其注册名称和其ETS表。所有链接和监视器均被触发。但是，NIF的执行&lt;strong&gt;不会&lt;/strong&gt;停止。NIF可以安全地继续执行，分配堆内存等等，但是当然最好尽快停止执行。NIF可以使用 &lt;code&gt;&lt;a href=&quot;#enif_is_current_process_alive&quot;&gt;enif_is_current_process_alive&lt;/a&gt;&lt;/code&gt; 检查当前进程是否处于活动状态。使用 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enif_port_command&quot;&gt;enif_port_command&lt;/a&gt;&lt;/code&gt; 进行通信发送过程不活跃时，也会丢弃。某些内部资源（例如进程堆和进程控制块）的重新分配将延迟到脏NIF完成之前。</target>
        </trans-unit>
        <trans-unit id="50961d0e1b820684d69e8aad3d9b1e96970dd946" translate="yes" xml:space="preserve">
          <source>Termination reason.</source>
          <target state="translated">终止原因:</target>
        </trans-unit>
        <trans-unit id="e19bcb1a4afdcf2396c1810bc351a007a00a0314" translate="yes" xml:space="preserve">
          <source>Termination-Cause AVP</source>
          <target state="translated">终止-原因AVP</target>
        </trans-unit>
        <trans-unit id="720015dea84e939f9657bdc05e78a8f484b53980" translate="yes" xml:space="preserve">
          <source>Termination-Cause AVP Values</source>
          <target state="translated">终止原因AVP值</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="146c4bd146babe3998863abfd062b2ff20015f96" translate="yes" xml:space="preserve">
          <source>Terms are read from the disk log running on &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">从运行在 &lt;code&gt;Node&lt;/code&gt; 上的磁盘日志中读取术语。</target>
        </trans-unit>
        <trans-unit id="f400db43c5a4bb9dcf24053b78382c5623a73df7" translate="yes" xml:space="preserve">
          <source>Terms in the current test specification (that is, the specification that has been used to configure and run the current test) can be looked up. The function &lt;code&gt;&lt;a href=&quot;ct#get_testspec_terms-0&quot;&gt;get_testspec_terms()&lt;/a&gt;&lt;/code&gt; returns a list of all test specification terms (both configuration terms and test terms), and &lt;code&gt;get_testspec_terms(Tags)&lt;/code&gt; returns the term (or a list of terms) matching the tag (or tags) in &lt;code&gt;Tags&lt;/code&gt;.</source>
          <target state="translated">可以查询当前测试规范（即，用于配置和运行当前测试的规范）中的术语。该功能 &lt;code&gt;&lt;a href=&quot;ct#get_testspec_terms-0&quot;&gt;get_testspec_terms()&lt;/a&gt;&lt;/code&gt; 返回所有测试规范条款（包括配置术语和测试条件）的列表，并 &lt;code&gt;get_testspec_terms(Tags)&lt;/code&gt; 返回匹配的标签（或标签）的术语（或术语列表） &lt;code&gt;Tags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2258114625478405b0794d20feae7776bb952f1d" translate="yes" xml:space="preserve">
          <source>Terms of type binary are accessed with the help of struct type &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt;, which contains a pointer (&lt;code&gt;data&lt;/code&gt;) to the raw binary data and the length (&lt;code&gt;size&lt;/code&gt;) of the data in bytes. Both &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; are read-only and are only to be written using calls to API functions. Instances of &lt;code&gt;ErlNifBinary&lt;/code&gt; are, however, always allocated by the user (usually as local variables).</source>
          <target state="translated">可以使用结构类型 &lt;code&gt;&lt;a href=&quot;#ErlNifBinary&quot;&gt;ErlNifBinary&lt;/a&gt;&lt;/code&gt; 访问二进制类型的术语，该结构类型包含指向原始二进制数据的指针（ &lt;code&gt;data&lt;/code&gt; ）和以字节为单位的数据长度（ &lt;code&gt;size&lt;/code&gt; ）。这两个 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 是只读的，并且只能使用到API函数的调用来编写。但是， &lt;code&gt;ErlNifBinary&lt;/code&gt; 的实例始终由用户分配（通常作为局部变量）。</target>
        </trans-unit>
        <trans-unit id="920e01199bada94afb9a7c210700367bebf552cd" translate="yes" xml:space="preserve">
          <source>Test case groups can be nested so sets of groups can be configured with the same &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; functions. Nested groups can be defined by including a group definition, or a group name reference, in the test case list of another group.</source>
          <target state="translated">测试用例组可以嵌套，因此可以使用相同的 &lt;code&gt;init_per_group/2&lt;/code&gt; 和 &lt;code&gt;end_per_group/2&lt;/code&gt; 函数配置组组。可以通过在另一个组的测试用例列表中包括一个组定义或一个组名引用来定义嵌套的组。</target>
        </trans-unit>
        <trans-unit id="5bdbfab66783753cdeb866267c3e01eab16087f3" translate="yes" xml:space="preserve">
          <source>Test cases</source>
          <target state="translated">测试案例</target>
        </trans-unit>
        <trans-unit id="6ee68d1c38276f67012fb2a67884c914e7df88a5" translate="yes" xml:space="preserve">
          <source>Test cases are to restore as much of the execution environment as possible, so that subsequent test cases do not crash because of their execution order. The function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; is suitable for this.</source>
          <target state="translated">测试用例将恢复尽可能多的执行环境，以使后续测试用例不会因执行顺序而崩溃。函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 适合于此。</target>
        </trans-unit>
        <trans-unit id="eb3ed6107b568f9909300a05e389ccf37148b03c" translate="yes" xml:space="preserve">
          <source>Test cases can be executed individually or in batches. &lt;code&gt;Common Test&lt;/code&gt; also features a distributed testing mode with central control and logging. With this feature, multiple systems can be tested independently in one common session. This is useful, for example, when running automated large-scale regression tests.</source>
          <target state="translated">测试用例可以单独执行，也可以分批执行。 &lt;code&gt;Common Test&lt;/code&gt; 还具有带有中央控制和记录功能的分布式测试模式。使用此功能，可以在一个公共会话中独立测试多个系统。例如，在运行自动化大规模回归测试时，这很有用。</target>
        </trans-unit>
        <trans-unit id="4b194be204295ad16e8f14aa0046caa585dd7fd0" translate="yes" xml:space="preserve">
          <source>Test cases can be skipped in the following ways:</source>
          <target state="translated">可以通过以下方式跳过测试用例。</target>
        </trans-unit>
        <trans-unit id="d965a3f15f28a4c03812e7925aaabc94f5d085e2" translate="yes" xml:space="preserve">
          <source>Test cases in a sequence are executed in order until all succeed or one fails. If one fails, all following cases in the sequence are skipped. The cases in the sequence that have succeeded up to that point are reported as successful in the log. Any number of sequences can be specified.</source>
          <target state="translated">一个序列中的测试用例按顺序执行,直到所有测试用例成功或一个测试用例失败。如果一个失败了,则跳过序列中的所有案例。序列中成功的案例在日志中被报告为成功。可以指定任意数量的序列。</target>
        </trans-unit>
        <trans-unit id="40d70b7f6a0f40937f01a2ea075f8ecd7645309e" translate="yes" xml:space="preserve">
          <source>Test install using &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;. The content of the &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; variable will prefix all installation paths when doing &lt;code&gt;make install&lt;/code&gt;. Note that &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; is similar to &lt;code&gt;DESTDIR&lt;/code&gt;, but it does &lt;strong&gt;not&lt;/strong&gt; have the same effect as &lt;code&gt;DESTDIR&lt;/code&gt;. The installation can and have to be run from the location specified by &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;. That is, it can be useful if you want to try the system out, running test suites, etc, before doing the real install without &lt;code&gt;EXTRA_PREFIX&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 进行测试安装。在进行 &lt;code&gt;make install&lt;/code&gt; 时， &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 变量的内容将为所有安装路径添加前缀。需要注意的是 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 类似于 &lt;code&gt;DESTDIR&lt;/code&gt; ，但它并&lt;strong&gt;没有&lt;/strong&gt;具有相同的效果 &lt;code&gt;DESTDIR&lt;/code&gt; 。安装可以并且必须从 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 指定的位置运行。也就是说，如果您想在不进行 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; 的情况下进行实际安装之前尝试使用系统，运行测试套件等，这将很有用。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09cd8634fdd2477138516ede0b407901933f6764" translate="yes" xml:space="preserve">
          <source>Test sets can be joined in the same way: if &lt;code&gt;S_1&lt;/code&gt;, ..., &lt;code&gt;S_K&lt;/code&gt; are test sets, then &lt;code&gt;[S_1, ..., S_K]&lt;/code&gt; is also a test set, where the tests of &lt;code&gt;S_i&lt;/code&gt; are ordered before those of &lt;code&gt;S_(i+1)&lt;/code&gt;, for each subset &lt;code&gt;S_i&lt;/code&gt;.</source>
          <target state="translated">可以用相同的方式连接测试集：如果 &lt;code&gt;S_1&lt;/code&gt; ，...， &lt;code&gt;S_K&lt;/code&gt; 是测试集，则 &lt;code&gt;[S_1, ..., S_K]&lt;/code&gt; 也是测试集，其中 &lt;code&gt;S_i&lt;/code&gt; 的测试先于 &lt;code&gt;S_(i+1)&lt;/code&gt; ，针对每个子集 &lt;code&gt;S_i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0476bc91790b91266bc97b686a581dbb9934797" translate="yes" xml:space="preserve">
          <source>Test specifications can be used to run tests both in a single test host environment and in a distributed &lt;code&gt;Common Test&lt;/code&gt; environment (Large Scale Testing). The node parameters in term &lt;code&gt;init&lt;/code&gt; are only relevant in the latter (see section &lt;code&gt;&lt;a href=&quot;ct_master_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in Large Scale Testing). For details about the various terms, see the corresponding sections in the User's Guide, for example, the following:</source>
          <target state="translated">测试规范可用于在单个测试主机环境和分布式 &lt;code&gt;Common Test&lt;/code&gt; 环境（大型测试）中运行测试。术语 &lt;code&gt;init&lt;/code&gt; 中的节点参数仅在后者中相关（请参阅大规模测试中的 &lt;code&gt;&lt;a href=&quot;ct_master_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 部分）。有关各种术语的详细信息，请参见《用户指南》中的相应部分，例如：</target>
        </trans-unit>
        <trans-unit id="30c41c15ebd68c9f73776e8a167fcaff4ee08b62" translate="yes" xml:space="preserve">
          <source>Test suites are organized in test directories and each test suite can have a separate data directory. Typically, these files and directories are version-controlled similar to other forms of source code (possibly by a version control system like GIT or Subversion). However, &lt;code&gt;Common Test&lt;/code&gt; does not itself put any requirements on (or has any awareness of) possible file and directory versions.</source>
          <target state="translated">测试套件组织在测试目录中，每个测试套件可以具有单独的数据目录。通常，这些文件和目录受版本控制，类似于其他形式的源代码（可能由诸如GIT或Subversion的版本控制系统）。但是， &lt;code&gt;Common Test&lt;/code&gt; 本身并没有对可能的文件和目录版本提出任何要求（或没有意识到）。</target>
        </trans-unit>
        <trans-unit id="703b1b5effc82cad270e49b3081c9a0476a73290" translate="yes" xml:space="preserve">
          <source>Test the boot script. To do this, start Erlang with the &lt;code&gt;-boot&lt;/code&gt; command-line parameter specifying this boot script (with its full path, but without the &lt;code&gt;.boot&lt;/code&gt; suffix). In UNIX it can look as follows:</source>
          <target state="translated">测试启动脚本。要做到这一点，在开始二郎 &lt;code&gt;-boot&lt;/code&gt; 命令行参数，指定此启动脚本（及其完整路径，但没有 &lt;code&gt;.boot&lt;/code&gt; 后缀）。在UNIX中，它可能如下所示：</target>
        </trans-unit>
        <trans-unit id="1079562f698ab46db96db811ee51262354e5cae9" translate="yes" xml:space="preserve">
          <source>Test the function:</source>
          <target state="translated">测试功能。</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="10e93232f5ee13cde5c73ae6c73ca6a57a250ad6" translate="yes" xml:space="preserve">
          <source>TestResult</source>
          <target state="translated">TestResult</target>
        </trans-unit>
        <trans-unit id="9ff287ce9b2c7f5d011b9dafc2c0e9b0834011d4" translate="yes" xml:space="preserve">
          <source>Testing can be turned off by defining the &lt;code&gt;NOTEST&lt;/code&gt; macro when compiling, for example as an option to &lt;code&gt;erlc&lt;/code&gt;, as in:</source>
          <target state="translated">可以通过在编译时定义 &lt;code&gt;NOTEST&lt;/code&gt; 宏来关闭测试，例如，作为 &lt;code&gt;erlc&lt;/code&gt; 的选项，例如：</target>
        </trans-unit>
        <trans-unit id="2585f55dae2dfcc3e47a81c069669b6106c8d569" translate="yes" xml:space="preserve">
          <source>Testing is performed by running test suites (sets of test cases) or individual test cases. A test suite is implemented as an Erlang module named &lt;code&gt;&amp;lt;suite_name&amp;gt;_SUITE.erl&lt;/code&gt; which contains a number of test cases. A test case is an Erlang function that tests one or more things. The test case is the smallest unit that the &lt;code&gt;Common Test&lt;/code&gt; test server deals with.</source>
          <target state="translated">通过运行测试套件（测试用例集）或单个测试用例来执行测试。测试套件作为名为 &lt;code&gt;&amp;lt;suite_name&amp;gt;_SUITE.erl&lt;/code&gt; 的Erlang模块实现，其中包含许多测试用例。测试用例是一种Erlang函数，用于测试一项或多项内容。测试用例是 &lt;code&gt;Common Test&lt;/code&gt; 测试服务器处理的最小单元。</target>
        </trans-unit>
        <trans-unit id="cc6f17d3447c6fc66e6aa450b14b5cd25f941708" translate="yes" xml:space="preserve">
          <source>Testing that a complete system behaves according to its specification. Specifically, system testing should not require knowing any details about the implementation. It typically involves testing many different aspects of the system behaviour apart from the basic functionality, such as performance, usability, and reliability.</source>
          <target state="translated">测试一个完整的系统是否按照它的规范表现。具体来说,系统测试不应要求了解任何有关实现的细节。它通常涉及测试系统行为的许多不同方面,除了基本功能外,如性能、可用性和可靠性。</target>
        </trans-unit>
        <trans-unit id="20415ba2297f8ab20d67c7323905cf5ac08c6d83" translate="yes" xml:space="preserve">
          <source>Testing that a number of individually developed program units (assumed to already have been separately unit tested) work together as expected. Depending on the system being developed, integration testing may be as simple as &quot;just another level of unit testing&quot;, but might also involve other kinds of tests (compare &lt;strong&gt;system testing&lt;/strong&gt;).</source>
          <target state="translated">测试多个单独开发的程序单元（假定已经进行了单独的单元测试）可以按预期进行。根据所开发的系统，集成测试可能像&amp;ldquo;只是另一级别的单元测试&amp;rdquo;一样简单，但也可能涉及其他类型的测试（比较&lt;strong&gt;系统测试&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="9f22e406cc557d808f91d5ca40281d6d87b69e3f" translate="yes" xml:space="preserve">
          <source>Testing that a program unit behaves as it is supposed to do (in itself), according to its specifications. Unit tests have an important function as regression tests, when the program later is modified for some reason, since they check that the program still behaves according to specification.</source>
          <target state="translated">测试一个程序单元的行为是否符合其规格要求(本身)。单元测试有一个重要的功能是作为回归测试,当程序后来由于某些原因被修改时,因为它们检查程序是否仍然按照规范运行。</target>
        </trans-unit>
        <trans-unit id="4edeec23b3417c02267c0c57b9ce61f0a5bdd89d" translate="yes" xml:space="preserve">
          <source>Testing the Application Configuration File</source>
          <target state="translated">测试应用程序配置文件</target>
        </trans-unit>
        <trans-unit id="d049bb261c78990b7f3a05cead76ac7f2ab8f8d3" translate="yes" xml:space="preserve">
          <source>Testing this program gives:</source>
          <target state="translated">测试这个程序给。</target>
        </trans-unit>
        <trans-unit id="1ebcdae36a9b05a6e1ab46518e4e58eef26626f1" translate="yes" xml:space="preserve">
          <source>Tests a match specification used in calls to &lt;code&gt;ets:select/2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;. The function tests both a match specification for &quot;syntactic&quot; correctness and runs the match specification against the object. If the match specification contains errors, the tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">测试在对 &lt;code&gt;ets:select/2&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 的调用中使用的匹配规范。该函数测试匹配规范的&amp;ldquo;语法&amp;rdquo;正确性并针对对象运行匹配规范。如果匹配规范包含错误，则返回元组 &lt;code&gt;{error, Errors}&lt;/code&gt; ，其中 &lt;code&gt;Errors&lt;/code&gt; 是匹配规范存在问题的自然语言描述的列表。</target>
        </trans-unit>
        <trans-unit id="20af8d3a638a732a9ca30d0034512653a2afc567" translate="yes" xml:space="preserve">
          <source>Tests are spawned on &lt;code&gt;Node&lt;/code&gt; according to &lt;code&gt;TestSpecs&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;TestSpecs&lt;/code&gt; 在 &lt;code&gt;Node&lt;/code&gt; 上生成测试。</target>
        </trans-unit>
        <trans-unit id="25a350c07b1dc4870d3e5fe60df517c27f4d00ae" translate="yes" xml:space="preserve">
          <source>Tests are spawned on &lt;code&gt;Node&lt;/code&gt; using &lt;code&gt;ct:run_test/1&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;ct:run_test/1&lt;/code&gt; 在 &lt;code&gt;Node&lt;/code&gt; 上生成测试</target>
        </trans-unit>
        <trans-unit id="f9a6986bdc799652b1ed63c152d9475dfa79837d" translate="yes" xml:space="preserve">
          <source>Tests are spawned on the nodes as specified in &lt;code&gt;TestSpecs&lt;/code&gt;. Each specification in &lt;code&gt;TestSpec&lt;/code&gt; is handled separately. However, it is also possible to specify a list of specifications to be merged into one specification before the tests are executed. Any test without a particular node specification is also executed on the nodes in &lt;code&gt;InclNodes&lt;/code&gt;. Nodes in the &lt;code&gt;ExclNodes&lt;/code&gt; list are excluded from the test.</source>
          <target state="translated">根据 &lt;code&gt;TestSpecs&lt;/code&gt; 中的指定在节点上生成测试。 &lt;code&gt;TestSpec&lt;/code&gt; 中的每个规范都是单独处理的。但是，也可以在执行测试之前指定要合并到一个规范中的一系列规范。没有特定节点规范的任何测试也会在 &lt;code&gt;InclNodes&lt;/code&gt; 中的节点上执行。 &lt;code&gt;ExclNodes&lt;/code&gt; 列表中的节点将从测试中排除。</target>
        </trans-unit>
        <trans-unit id="70b11f1992889a6b7c7c46cf1041e8db8225983d" translate="yes" xml:space="preserve">
          <source>Tests are started by calling &lt;code&gt;&lt;a href=&quot;ct_master#run-1&quot;&gt;ct_master:run(TestSpecs)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_master#run-3&quot;&gt;ct_master:run(TestSpecs, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;ct_master#run-1&quot;&gt;ct_master:run(TestSpecs)&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ct_master#run-3&quot;&gt;ct_master:run(TestSpecs, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef16c9679cb63420148768ec48ac04c5d63e936c" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Expr&lt;/code&gt; is a legal guard test. &lt;code&gt;Expr&lt;/code&gt; is an Erlang term representing the abstract form for the expression. &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs(Tokens)&lt;/a&gt;&lt;/code&gt; can be used to generate a list of &lt;code&gt;Expr&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;Expr&lt;/code&gt; 是否为合法警卫测试。 &lt;code&gt;Expr&lt;/code&gt; 是一个Erlang术语，表示该表达式的抽象形式。 &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs(Tokens)&lt;/a&gt;&lt;/code&gt; 可用于生成 &lt;code&gt;Expr&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="c8ad645a0fe48da2850f345d9fd12acf10e03596" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Key&lt;/code&gt; is contained in dictionary &lt;code&gt;Dict&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;Key&lt;/code&gt; 是否包含在字典 &lt;code&gt;Dict&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="6804c0c8402a7f1d95110388290468af5380b366" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Key&lt;/code&gt; is contained in dictionary &lt;code&gt;Orddict&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;Key&lt;/code&gt; 是否包含在字典 &lt;code&gt;Orddict&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="17470d32fe0b145b2fa6cac2598fec80f0fef633" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Q&lt;/code&gt; is empty and returns &lt;code&gt;true&lt;/code&gt; if so, otherwise otherwise.</source>
          <target state="translated">测试 &lt;code&gt;Q&lt;/code&gt; 是否为空，如果是，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回true。</target>
        </trans-unit>
        <trans-unit id="a356ab74ac86d19af634fb0738a567189848582f" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;Term&lt;/code&gt; is a queue and returns &lt;code&gt;true&lt;/code&gt; if so, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">测试 &lt;code&gt;Term&lt;/code&gt; 是否为队列，如果是，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c37996f5d93af87f0cd3d137cfbd78cf77e1b111" translate="yes" xml:space="preserve">
          <source>Tests if the Actions argument is correctly composed.</source>
          <target state="translated">测试Actions参数的组成是否正确。</target>
        </trans-unit>
        <trans-unit id="acacfb3b7cddace5d9eb1b40646553496edf16cd" translate="yes" xml:space="preserve">
          <source>Tests if the Reply argument is correctly composed.</source>
          <target state="translated">测试Reply参数的组成是否正确。</target>
        </trans-unit>
        <trans-unit id="05fe70637fd8ca288c9016c0d2d69bc952a899ac" translate="yes" xml:space="preserve">
          <source>Text to the operator console.</source>
          <target state="translated">文字到操作台。</target>
        </trans-unit>
        <trans-unit id="54d4e6a8bdb666ab45d5ae6f0905988c6b9bdfe3" translate="yes" xml:space="preserve">
          <source>Textbook basic form Box-Muller standard normal deviate</source>
          <target state="translated">教材基本形式Box-Muller标准正态偏差</target>
        </trans-unit>
        <trans-unit id="2f72bba0ea07edaf4c51d66fc5bb6bab86a6ccd2" translate="yes" xml:space="preserve">
          <source>Thaana</source>
          <target state="translated">Thaana</target>
        </trans-unit>
        <trans-unit id="c32767e0541fe7038ff8d87e7b8aed17f49474f8" translate="yes" xml:space="preserve">
          <source>Thai</source>
          <target state="translated">Thai</target>
        </trans-unit>
        <trans-unit id="7c54512782f0b8a8a8ee3e013c2e8e72a5dedaa8" translate="yes" xml:space="preserve">
          <source>That EPMD is running</source>
          <target state="translated">该EPDM正在运行</target>
        </trans-unit>
        <trans-unit id="6d5dd72a57184dddefa9dbd040521e6e6341703b" translate="yes" xml:space="preserve">
          <source>That environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; is set correctly</source>
          <target state="translated">正确设置了环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e3a97a56528bdf88e1b2051f20678cae41f8ace" translate="yes" xml:space="preserve">
          <source>That is an optimization. Most applications do not send messages with shared subterms.</source>
          <target state="translated">这是一种优化。大多数应用程序不会发送带有共享子术语的消息。</target>
        </trans-unit>
        <trans-unit id="5c80baa8384a9b1de6a39a6f7088119999c1a237" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;Message&lt;/code&gt; (any Erlang term) is sent to the process with identity &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">即，将 &lt;code&gt;Message&lt;/code&gt; （任何Erlang术语）以标识 &lt;code&gt;Pid&lt;/code&gt; 发送到进程。</target>
        </trans-unit>
        <trans-unit id="45015129465c2268d074359ec5005e5d4d17b91b" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;filtermap&lt;/code&gt; behaves as if it had been defined as follows:</source>
          <target state="translated">也就是说， &lt;code&gt;filtermap&lt;/code&gt; 的行为就像已定义如下：</target>
        </trans-unit>
        <trans-unit id="535867dd76e5b138e05f832dc9af825cc91d8cc3" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;flatmap&lt;/code&gt; behaves as if it had been defined as follows:</source>
          <target state="translated">即， &lt;code&gt;flatmap&lt;/code&gt; 的行为就像已定义如下：</target>
        </trans-unit>
        <trans-unit id="aad791da5a9f2ebf28101f220528f9b8d026646d" translate="yes" xml:space="preserve">
          <source>That is, a leap year. The next two &lt;code&gt;trunc&lt;/code&gt;-tests evaluate if the year is divisible by 100 or 4 in the same way. The first &lt;code&gt;if&lt;/code&gt; returns &lt;code&gt;leap&lt;/code&gt; or &lt;code&gt;not_leap&lt;/code&gt;, which lands up in the variable &lt;code&gt;Leap&lt;/code&gt;. This variable is used in the guard for &lt;code&gt;feb&lt;/code&gt; in the following &lt;code&gt;case&lt;/code&gt; that tells us how long the month is.</source>
          <target state="translated">那就是a年。接下来的两个 &lt;code&gt;trunc&lt;/code&gt; -tests以相同的方式评估年份是否可以被100或4整除。第一 &lt;code&gt;if&lt;/code&gt; 返回 &lt;code&gt;leap&lt;/code&gt; 或 &lt;code&gt;not_leap&lt;/code&gt; ，这在可变土地了 &lt;code&gt;Leap&lt;/code&gt; 。在以下 &lt;code&gt;case&lt;/code&gt; ，此变量在 &lt;code&gt;feb&lt;/code&gt; 的防护中使用，它告诉我们该月有多长时间。</target>
        </trans-unit>
        <trans-unit id="61bd067e8a1df03751d1301ebc5a385097e1ecce" translate="yes" xml:space="preserve">
          <source>That is, a trace output, with both the function called and the resulting value.</source>
          <target state="translated">也就是跟踪输出,既有调用的函数,又有结果的值。</target>
        </trans-unit>
        <trans-unit id="b1bb322ca91a6283f723e39d12e1d20ae13c765c" translate="yes" xml:space="preserve">
          <source>That is, all the bound variables in the match head as a list. If tuples are to be constructed, one has to write a tuple of arity 1 where the single element in the tuple is the tuple one wants to construct (as an ordinary tuple can be mistaken for a &lt;code&gt;Guard&lt;/code&gt;).</source>
          <target state="translated">也就是说，匹配项中的所有绑定变量都以列表的形式出现。如果要构造元组，则必须编写一个Arity 1的元组，其中元组中的单个元素是您要构造的元组（因为普通元组可能会误认为 &lt;code&gt;Guard&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">那就是:</target>
        </trans-unit>
        <trans-unit id="7179c2c2c75b5324944355b82ad607b610b23c74" translate="yes" xml:space="preserve">
          <source>That should make it possible to rebuild any library without hassle...</source>
          <target state="translated">这应该使重建任何库成为可能,没有麻烦......。</target>
        </trans-unit>
        <trans-unit id="ff03a468de0d9ed380aa26940cb3d4ce174a3748" translate="yes" xml:space="preserve">
          <source>That the correct cookie was used</source>
          <target state="translated">使用了正确的cookie</target>
        </trans-unit>
        <trans-unit id="fbb73f156f2e40ae17a54d203d8b3537e9a4d680" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;ei&lt;/code&gt; library</source>
          <target state="translated">另一端的远程Erlang节点正在运行与 &lt;code&gt;ei&lt;/code&gt; 库相同版本的Erlang</target>
        </trans-unit>
        <trans-unit id="43093885e0893ad901ee4b46bda00f5dc1d9a9d7" translate="yes" xml:space="preserve">
          <source>That the remote Erlang node on the other side is running the same version of Erlang as the &lt;code&gt;erl_interface&lt;/code&gt; library</source>
          <target state="translated">另一端的远程Erlang节点正在运行与 &lt;code&gt;erl_interface&lt;/code&gt; 库相同版本的Erlang</target>
        </trans-unit>
        <trans-unit id="e3420600d759a760d25722c58727ef289f531b08" translate="yes" xml:space="preserve">
          <source>That was once true, but from R6B the BEAM compiler can see that a variable is not used.</source>
          <target state="translated">曾经是这样的,但是从R6B开始,BEAM编译器可以看到一个变量没有被使用。</target>
        </trans-unit>
        <trans-unit id="aefbfb778a6045a9feec711cee7f0b6bfe06745c" translate="yes" xml:space="preserve">
          <source>That was true to some extent before R12B. It was even more true before R7B. Today, not so much. A body-recursive function generally uses the same amount of memory as a tail-recursive function. It is generally not possible to predict whether the tail-recursive or the body-recursive version will be faster. Therefore, use the version that makes your code cleaner (hint: it is usually the body-recursive version).</source>
          <target state="translated">在R12B之前,在某种程度上是如此。在R7B之前更是如此。今天,情况就不一样了。一个主体递归函数通常与一个尾部递归函数使用相同数量的内存。一般来说,我们无法预测尾递归还是体递归的版本会更快。因此,使用能让你的代码更干净的版本(提示:通常是body-recursive版本)。</target>
        </trans-unit>
        <trans-unit id="8ef05f15aa52cadeef34686e592834e1d7565d8c" translate="yes" xml:space="preserve">
          <source>That will copy the emulator executables.</source>
          <target state="translated">这将复制仿真器的可执行文件。</target>
        </trans-unit>
        <trans-unit id="c1b9697cd4f3baa91fdf236c77e1a263c60d4132" translate="yes" xml:space="preserve">
          <source>That's basically all you need to get going.</source>
          <target state="translated">基本上就可以了。</target>
        </trans-unit>
        <trans-unit id="82c971d45846792b2b886cdbb85418dc5903f332" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator has a complexity proportional to the product of the length of its operands. This means that the operator is very slow if both of its operands are long lists:</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;运算符的复杂度与其操作数长度的乘积成正比。这意味着如果两个操作数均为长列表，则该运算符将非常慢：</target>
        </trans-unit>
        <trans-unit id="ff5589371f0dbe70e4139850cd24f1db48567113" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;strong&gt;state callback&lt;/strong&gt;&quot; for a specific &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;gen_statem&lt;/code&gt; is the callback function that is called for all events in this state. It is selected depending on which &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; that the callback module defines with the callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&amp;ldquo; &lt;strong&gt;状态回调&lt;/strong&gt; &amp;rdquo;针对特定 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;gen_statem&lt;/code&gt; 是呼吁在这种状态下的所有事件的回调函数。根据回调模块使用回调函数 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 选择。</target>
        </trans-unit>
        <trans-unit id="fd11f0de519165a84c1b8fcc83fbb4913df33819" translate="yes" xml:space="preserve">
          <source>The &quot;Definitions.&quot;, &quot;Rules.&quot; and &quot;Erlang code.&quot; headings are mandatory and must occur at the beginning of a source line. The &amp;lt;Header&amp;gt;, &amp;lt;Macro Definitions&amp;gt; and &amp;lt;Erlang code&amp;gt; sections may be empty but there must be at least one rule.</source>
          <target state="translated">&amp;ldquo;定义&amp;rdquo;，&amp;ldquo;规则&amp;rdquo;。和&amp;ldquo; Erlang代码&amp;rdquo;。标题是强制性的，必须出现在源代码行的开头。&amp;lt;Header&amp;gt;，&amp;lt;Macro Definitions&amp;gt;和&amp;lt;Erlang code&amp;gt;部分可能为空，但必须至少有一个规则。</target>
        </trans-unit>
        <trans-unit id="0a6c1c05be408f7e65aa7a987ce718ffc02949c2" translate="yes" xml:space="preserve">
          <source>The &quot;Okasaki API&quot; is inspired by &quot;Purely Functional Data Structures&quot; by Chris Okasaki. It regards queues as lists. This API is by many regarded as strange and avoidable. For example, many reverse operations have lexically reversed names, some with more readable but perhaps less understandable aliases.</source>
          <target state="translated">Okasaki API &quot;的灵感来自于Chris Okasaki的 &quot;纯功能数据结构&quot;。它将队列视为列表。这种API被很多人认为是奇怪的,是可以避免的。例如,许多逆向操作都有词法上的逆向名称,有的还有更易读但可能不太容易理解的别名。</target>
        </trans-unit>
        <trans-unit id="4fe7eac7bdedf25d0494e04217d2e3132e60e367" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; and the &quot;Extended API&quot; both use the mental picture of a waiting line of items. Both have reverse operations suffixed &quot;_r&quot;.</source>
          <target state="translated">&quot;原始API &quot;和 &quot;扩展API &quot;都使用了项目排队等候的心理图景。两者都有后缀为&quot;_r &quot;的反向操作。</target>
        </trans-unit>
        <trans-unit id="3887fa2b48cbded502d3da264fbe59b3f1883ab5" translate="yes" xml:space="preserve">
          <source>The &quot;Original API&quot; item removal functions return compound terms with both the removed item and the resulting queue. The &quot;Extended API&quot; contains alternative functions that build less garbage and functions for just inspecting the queue ends. Also the &quot;Okasaki API&quot; functions build less garbage.</source>
          <target state="translated">&quot;原始API &quot;项移除函数返回带有移除项和结果队列的复合项。扩展API &quot;包含了构建较少垃圾的替代函数和仅用于检查队列末端的函数。另外,&quot;Okasaki API &quot;的函数也是构建较少垃圾的。</target>
        </trans-unit>
        <trans-unit id="7a1a738b6242350a278b4cc4eaff19808c280faf" translate="yes" xml:space="preserve">
          <source>The &quot;Oxford Advanced Learners Dictionary of Current English&quot; says the following about the word &quot;indent&quot;:</source>
          <target state="translated">牛津现行英语高级学习者词典》中对 &quot;缩进 &quot;一词有如下说法。</target>
        </trans-unit>
        <trans-unit id="b71ca1b4095bae581a22c9bd4dc765543e310daa" translate="yes" xml:space="preserve">
          <source>The &quot;keep alive&quot; activity (that is, that &lt;code&gt;Common Test&lt;/code&gt; sends NOP to the server every 10 seconds if the connection is idle) can be enabled or disabled for one particular connection as described here. It can be disabled for all connections using &lt;code&gt;telnet_settings&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">可以为一个特定的连接启用或禁用&amp;ldquo;保持活动&amp;rdquo;活动（即，如果连接空闲，则 &lt;code&gt;Common Test&lt;/code&gt; 每10秒向服务器发送一次NOP），如此处所述。可以使用 &lt;code&gt;telnet_settings&lt;/code&gt; 对所有连接禁用此功能（请参阅 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4fe589f8c1fff89269afb0db8e6111d61dec7b78" translate="yes" xml:space="preserve">
          <source>The &quot;private&quot; message &lt;code&gt;{From, rewind}&lt;/code&gt; results in the current position in the pseudo-file to be reset to &lt;code&gt;0&lt;/code&gt; (the beginning of the &quot;file&quot;). This is a typical example of I/O device-specific messages not being part of the I/O protocol. It is usually a bad idea to embed such private messages in &lt;code&gt;io_request&lt;/code&gt; tuples, as that can confuse the reader.</source>
          <target state="translated">&amp;ldquo;私人&amp;rdquo;消息 &lt;code&gt;{From, rewind}&lt;/code&gt; 导致伪文件中的当前位置被重置为 &lt;code&gt;0&lt;/code&gt; （&amp;ldquo;文件&amp;rdquo;的开头）。这是不属于I / O协议的I / O设备特定消息的典型示例。将此类私有消息嵌入 &lt;code&gt;io_request&lt;/code&gt; 元组通常是一个坏主意，因为这会使读者感到困惑。</target>
        </trans-unit>
        <trans-unit id="e4a690e384b2d5a804cad58bd96420656c204892" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page includes a link to the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file in which information about imported configuration data and general test progress is written. This log file is useful to get snapshot information about the test run during execution. It can also be helpful when analyzing test results or debugging test suites.</source>
          <target state="translated">&amp;ldquo;测试运行索引&amp;rdquo;页面包括指向&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 框架日志&amp;rdquo;文件的链接，其中写入了有关导入的配置数据和常规测试进度的信息。该日志文件对于获取有关执行期间测试运行的快照信息很有用。在分析测试结果或调试测试套件时，它也很有帮助。</target>
        </trans-unit>
        <trans-unit id="8c3be9bfee853a4424aae3e9b08197fdb2f6acc7" translate="yes" xml:space="preserve">
          <source>The &quot;test run index&quot; page indicates if a test has missing suites (that is, suites that &lt;code&gt;Common Test&lt;/code&gt; failed to compile). Names of the missing suites can be found in the &lt;code&gt;Common Test&lt;/code&gt; Framework Log file.</source>
          <target state="translated">&amp;ldquo;测试运行索引&amp;rdquo;页面指示测试是否缺少套件（即， &lt;code&gt;Common Test&lt;/code&gt; 未能编译的套件）。可以在 &lt;code&gt;Common Test&lt;/code&gt; 框架日志文件中找到缺少的套件的名称。</target>
        </trans-unit>
        <trans-unit id="a60728f91de50a0cab75ed1bd09ee0c55638db56" translate="yes" xml:space="preserve">
          <source>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying &lt;code&gt;{parts,&lt;/code&gt;N&lt;code&gt;}&lt;/code&gt;:</source>
          <target state="translated">&amp;ldquo;修剪&amp;rdquo;选项说；&amp;ldquo;给我尽可能多的零件，空的零件除外&amp;rdquo;，有时这很有用。您还可以通过指定 &lt;code&gt;{parts,&lt;/code&gt; N &lt;code&gt;}&lt;/code&gt; 来指定所需的零件数：</target>
        </trans-unit>
        <trans-unit id="9d8edde0db65ff7f9e25c8ce9f9ce0286b2ab0b7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;Regexp&amp;gt; must occur at the start of a line and not include any blanks; use &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\s&lt;/code&gt; to include TAB and SPACE characters in the regular expression. If &amp;lt;Regexp&amp;gt; matches then the corresponding &amp;lt;Erlang code&amp;gt; is evaluated to generate a token. With the Erlang code the following predefined variables are available:</source>
          <target state="translated">&amp;lt;Regexp&amp;gt;必须出现在一行的开头，并且不能包含任何空格。使用 &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\s&lt;/code&gt; 在正则表达式中包含TAB和SPACE字符。如果&amp;lt;Regexp&amp;gt;匹配，则将评估相应的&amp;lt;Erlang代码&amp;gt;以生成令牌。使用Erlang代码，可以使用以下预定义变量：</target>
        </trans-unit>
        <trans-unit id="5fd6006060b360d3964e6301c70d62dfa6542605" translate="yes" xml:space="preserve">
          <source>The (*MARK) name is tagged with &quot;MK:&quot; in this output, and in this example it indicates which of the two alternatives matched. This is a more efficient way of obtaining this information than putting each alternative in its own capturing parentheses.</source>
          <target state="translated">在这个输出中,(*MARK)名称被标记为 &quot;MK:&quot;,在这个例子中,它表明了两个备选方案中哪一个匹配。与将每个备选方案放在自己的捕获括号中相比,这是一种更有效的获取该信息的方式。</target>
        </trans-unit>
        <trans-unit id="7626cd8d4a95d16adbb501a045b70ff730bc3449" translate="yes" xml:space="preserve">
          <source>The (*UTF8) and (*UCP) leading sequences can be used to set UTF and Unicode property modes. They are equivalent to setting options &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;ucp&lt;/code&gt;, respectively. The (*UTF) sequence is a generic version that can be used with any of the libraries. However, the application can set option &lt;code&gt;never_utf&lt;/code&gt;, which locks out the use of the (*UTF) sequences.</source>
          <target state="translated">（* UTF8）和（* UCP）前导序列可用于设置UTF和Unicode属性模式。它们分别等效于设置选项 &lt;code&gt;unicode&lt;/code&gt; 和 &lt;code&gt;ucp&lt;/code&gt; 。 （* UTF）序列是可与任何库一起使用的通用版本。但是，应用程序可以设置选项 &lt;code&gt;never_utf&lt;/code&gt; ，从而锁定（* UTF）序列的使用。</target>
        </trans-unit>
        <trans-unit id="0af8bbc7ab3d2447bd6a5d8520e9f3d0f277f0b4" translate="yes" xml:space="preserve">
          <source>The (built-in) &lt;code&gt;escript&lt;/code&gt; program first determines which Erlang runtime system to use and then starts it to execute your script. Usually the runtime system is located in the same Erlang installation as the &lt;code&gt;escript&lt;/code&gt; program itself. But for standalone systems with one or more escripts it may be the case that the &lt;code&gt;escript&lt;/code&gt; program in your path actually starts the runtime system bundled with the escript. This is intentional, and typically happens when the standalone system &lt;code&gt;bin&lt;/code&gt; directory is not in the execution path (as it may cause its &lt;code&gt;erl&lt;/code&gt; program to override the desired one) and the &lt;code&gt;escript&lt;/code&gt;(s) are referred to via symbolic links from a &lt;code&gt;bin&lt;/code&gt; directory in the path.</source>
          <target state="translated">（内置的） &lt;code&gt;escript&lt;/code&gt; 程序首先确定要使用的Erlang运行时系统，然后启动它来执行脚本。通常，运行时系统与 &lt;code&gt;escript&lt;/code&gt; 程序本身位于同一Erlang安装中。但是对于具有一个或多个脚本的独立系统，路径中的 &lt;code&gt;escript&lt;/code&gt; 程序实际上可能会启动与该脚本捆绑在一起的运行时系统。这是有意的，并且通常在独立系统 &lt;code&gt;bin&lt;/code&gt; 目录不在执行路径中时发生（因为它可能导致其 &lt;code&gt;erl&lt;/code&gt; 程序覆盖所需的erl程序），并且 &lt;code&gt;escript&lt;/code&gt; 通过来自 &lt;code&gt;bin&lt;/code&gt; 目录中的bin目录的符号链接进行引用路径。</target>
        </trans-unit>
        <trans-unit id="dfd9ff6975abbc395a9f98a9f0cbda02a2c72d28" translate="yes" xml:space="preserve">
          <source>The (compressed) tape archive file is to be extracted in the installation directory defined above.</source>
          <target state="translated">(压缩的)磁带存档文件将被解压到上面定义的安装目录中。</target>
        </trans-unit>
        <trans-unit id="bdcfaa6a575093f30922fde0b326af66b1dc8369" translate="yes" xml:space="preserve">
          <source>The (hidden) node implements atom cache (obsolete).</source>
          <target state="translated">(隐藏)节点实现了原子缓存(过时)。</target>
        </trans-unit>
        <trans-unit id="148d899ab108f6515349d4b01878d74abd02d0c9" translate="yes" xml:space="preserve">
          <source>The (host operating system) environment variable &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; can be used to give default compiler options. Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not a list, it is put into a list.</source>
          <target state="translated">（主机操作系统）环境变量 &lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; 可用于提供默认的编译器选项。其值必须是有效的Erlang术语。如果值为列表，则按原样使用。如果不是列表，则将其放入列表中。</target>
        </trans-unit>
        <trans-unit id="f06fadd0b84d13f99d85c50cfc349e4a25addef3" translate="yes" xml:space="preserve">
          <source>The (possibly flattened) &lt;code&gt;Path&lt;/code&gt; parameter must be consistent throughout the system. A driver is to, by all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, be loaded using the same &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt;. The exception is when &lt;strong&gt;reloading&lt;/strong&gt; is requested, in which case &lt;code&gt;Path&lt;/code&gt; can be specified differently. Notice that all &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; trying to load the driver later need to use the &lt;strong&gt;new&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; if &lt;code&gt;Path&lt;/code&gt; is changed using a &lt;code&gt;reload&lt;/code&gt; option. This is yet another reason to have &lt;strong&gt;only one loader&lt;/strong&gt; of a driver one wants to upgrade in a running system.</source>
          <target state="translated">（可能是平坦的） &lt;code&gt;Path&lt;/code&gt; 参数在整个系统中必须一致。所有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 必须使用相同的&lt;strong&gt;文字&lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 来加载驱动程序。例外是请求&lt;strong&gt;重新加载&lt;/strong&gt;时，在这种情况下，可以不同地指定 &lt;code&gt;Path&lt;/code&gt; 。请注意，所有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 试图加载驱动程序后需要使用&lt;strong&gt;新的&lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; ，如果 &lt;code&gt;Path&lt;/code&gt; 是利用改变 &lt;code&gt;reload&lt;/code&gt; 选项。这是在运行的系统中&lt;strong&gt;只有一个&lt;/strong&gt;驱动程序&lt;strong&gt;加载&lt;/strong&gt;程序要升级的另一个原因。</target>
        </trans-unit>
        <trans-unit id="7c443fb128bea98f3149bd2df5d12047cad839bc" translate="yes" xml:space="preserve">
          <source>The 16 bytes MD5 of the significant parts of the Beam file.</source>
          <target state="translated">Beam文件中重要部分的16个字节MD5。</target>
        </trans-unit>
        <trans-unit id="7d39efdef71579d11fb25cc52651c18fba9a7537" translate="yes" xml:space="preserve">
          <source>The 3-tuple form additionally specifies an interval, in milliseconds, after which a started transport process should be terminated if it has not yet established a connection. For example, the following options on a connecting transport request a connection with one peer over SCTP or another (typically the same) over TCP.</source>
          <target state="translated">3-tuple形式还指定了一个间隔,以毫秒为单位,如果启动的传输过程尚未建立连接,则应在此间隔后终止。例如,连接传输上的以下选项要求通过SCTP与一个对等体或通过TCP与另一个对等体(通常是相同的)建立连接。</target>
        </trans-unit>
        <trans-unit id="acebf1a57043cf38ebb17933963dec066b1efb07" translate="yes" xml:space="preserve">
          <source>The 4-byte header is limited to 2Gb.</source>
          <target state="translated">4字节的头部限制在2Gb。</target>
        </trans-unit>
        <trans-unit id="c54cda7cb6bfe2ffa1c818c4fe4b01c2c1e1b503" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; type consists of the following options:</source>
          <target state="translated">所述 &lt;code id=&quot;cert_opt&quot;&gt;cert_opt()&lt;/code&gt; 类型包括以下选项：</target>
        </trans-unit>
        <trans-unit id="865c911e774746bccfef22abcc84f0e0893f4e7b" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; driver API functions need a port handle that identifies the driver instance (and the port in the emulator). This is only passed to the &lt;code&gt;start&lt;/code&gt; function, but not to the other functions. The &lt;code&gt;start&lt;/code&gt; function returns a driver-defined handle that is passed to the other functions. A common practice is to have the &lt;code&gt;start&lt;/code&gt; function allocate some application-defined structure and stash the &lt;code&gt;port&lt;/code&gt; handle in it, to use it later with the driver API functions.</source>
          <target state="translated">该 &lt;code id=&quot;emulator&quot;&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 驱动API函数需要标识的驱动程序实例端口句柄（并在模拟器的端口）。这仅传递给 &lt;code&gt;start&lt;/code&gt; 函数，而不传递给其他函数。在 &lt;code&gt;start&lt;/code&gt; 函数返回传递给其他功能的驱动程序定义的手柄。一种常见的做法是让 &lt;code&gt;start&lt;/code&gt; 函数分配一些应用程序定义的结构并将其存储在 &lt;code&gt;port&lt;/code&gt; 句柄中，以便以后与驱动程序API函数一起使用。</target>
        </trans-unit>
        <trans-unit id="418f98e4e66687632d887b26d161001270432df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; file contains all available cross configuration variables and can be used as a template when creating a cross compilation configuration. All &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; are also listed at the end of this document. For examples of working cross configurations see the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; file and the &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; file. If the default behavior of a variable is satisfactory, the variable does not need to be set. However, the &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">在 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; 文件包含了所有可用的交叉配置变量，可以创建一个交叉编译配置时，可以作为一个模板。本文档末尾还列出了所有 &lt;code&gt;&lt;a href=&quot;#Currently-Used-Configuration-Variables&quot;&gt;cross configuration variables&lt;/a&gt;&lt;/code&gt; 。有关交叉配置的示例，请参见 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-TileraMDE2.0-tilepro.conf&lt;/code&gt; 文件和 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp-x86_64-saf-linux-gnu.conf&lt;/code&gt; 文件。如果变量的默认行为令人满意，则无需设置该变量。但是，当使用默认值时， &lt;code&gt;configure&lt;/code&gt; 脚本将发出警告。设置变量后，将不会发出警告。</target>
        </trans-unit>
        <trans-unit id="2e8c049d3991b699c878b126ce3c6bdb33cc7a3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; directory is where new release packets are installed, and where the release handler keeps information about releases. For more information, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">该 &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 目录是新版本的数据包的安装位置，并在发布处理器保留有关发布的信息。有关更多信息，请参见SASL中的 &lt;code&gt;release_handler(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="927497bac1e3aacb4e090f1231bc5491dae42268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;++&lt;/code&gt; operator has, somewhat undeservedly, got a bad reputation. It probably has something to do with code like the following, which is the most inefficient way there is to reverse a list:</source>
          <target state="translated">该 &lt;code&gt;++&lt;/code&gt; 运营商，有些不应有的，有一个不好的名声。它可能与以下代码有关，这是反转列表的最无效的方法：</target>
        </trans-unit>
        <trans-unit id="42130a038f0aadad4f70fd60034fb79e9e360ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;#&lt;/code&gt; operators are defined for line number expressions, provided the operands are compatible. The LineOp operators are also defined for modules, applications, and releases; the operand is implicitly converted to functions. Similarly, the cast operator is defined for the interpretation of the LineOp operators.</source>
          <target state="translated">如果操作数兼容，则为行号表达式定义 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;#&lt;/code&gt; 运算符。还为模块，应用程序和发行版定义了LineOp运算符；操作数被隐式转换为函数。同样，为解释LineOp运算符而定义了强制转换运算符。</target>
        </trans-unit>
        <trans-unit id="7d867665c4e36dd9997bf46a9f78b7c231955da1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fna&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt;. This has effect if the locale settings cause the behavior of &lt;code&gt;+fnu&lt;/code&gt; to be selected; see the description of &lt;code&gt;+fnu&lt;/code&gt; above. If the locale settings cause the behavior of &lt;code&gt;+fnl&lt;/code&gt; to be selected, then &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; have no effect.</source>
          <target state="translated">的 &lt;code&gt;+fna&lt;/code&gt; 开关可以跟随 &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ，或 &lt;code&gt;e&lt;/code&gt; 。如果语言环境设置导致选择了 &lt;code&gt;+fnu&lt;/code&gt; 的行为，则此方法有效。请参阅上面 &lt;code&gt;+fnu&lt;/code&gt; 的说明。如果语言环境设置导致选择了 &lt;code&gt;+fnl&lt;/code&gt; 的行为，则 &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; 或 &lt;code&gt;e&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="9e6133996f9262b8d90826837351bd3d8efee96b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+fnu&lt;/code&gt; switch can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported:</source>
          <target state="translated">的 &lt;code&gt;+fnu&lt;/code&gt; 开关可以跟随 &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ，或 &lt;code&gt;e&lt;/code&gt; 控制编码错误的文件名是如何被报告：</target>
        </trans-unit>
        <trans-unit id="831e6d2347d95f44b19c16835a12096caa3382d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--enable-bootstrap-only&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt; isn't strictly necessary, but will speed things up. It will only run &lt;code&gt;configure&lt;/code&gt; in applications necessary for the bootstrap, and will disable a lot of things not needed by the bootstrap system. If you run &lt;code&gt;configure&lt;/code&gt; without &lt;code&gt;--enable-boostrap-only&lt;/code&gt; you also have to run make as &lt;code&gt;make bootstrap&lt;/code&gt;; otherwise, the whole system will be built.</source>
          <target state="translated">该 &lt;code&gt;--enable-bootstrap-only&lt;/code&gt; 参数 &lt;code&gt;configure&lt;/code&gt; 并非绝对必要，反而会加快速度。它只会在引导程序所需的应用程序中运行 &lt;code&gt;configure&lt;/code&gt; ，并且会禁用引导程序系统不需要的许多功能。如果您运行的 &lt;code&gt;configure&lt;/code&gt; 没有 &lt;code&gt;--enable-boostrap-only&lt;/code&gt; 你还必须运行make作为 &lt;code&gt;make bootstrap&lt;/code&gt; ; 否则，将构建整个系统。</target>
        </trans-unit>
        <trans-unit id="f9606e2fd218b40d91d81e57470942cf1aec71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-error()&lt;/code&gt; and &lt;code&gt;-warning()&lt;/code&gt; directives were added in OTP 19.</source>
          <target state="translated">所述 &lt;code&gt;-error()&lt;/code&gt; 和 &lt;code&gt;-warning()&lt;/code&gt; 指令在OTP 19加入。</target>
        </trans-unit>
        <trans-unit id="c265860ecc1894d7ef2df5fb5a19bf0d362bff43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-on_load()&lt;/code&gt; directive names a function that is to be run automatically when a module is loaded.</source>
          <target state="translated">所述 &lt;code&gt;-on_load()&lt;/code&gt; 指令名称的功能也就是当被加载的模块来自动运行。</target>
        </trans-unit>
        <trans-unit id="aa13e09e4d341c2108d3357512871ca10a0cc6bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; file for release may reside in the &lt;code&gt;ebin&lt;/code&gt;-directory in a development environment but it is encouraged that this is an artifact of the build step. By convention a &lt;code&gt;.app.src&lt;/code&gt; file is used, which resides in the &lt;code&gt;src&lt;/code&gt; directory. This file is nearly identical as the &lt;code&gt;.app&lt;/code&gt; file but certain fields may be replaced during the build step, such as the application version.</source>
          <target state="translated">的 &lt;code&gt;.app&lt;/code&gt; 发布文件可能驻留在 &lt;code&gt;ebin&lt;/code&gt; 在开发环境中-directory但鼓励，这是构建步骤的神器。按照约定，使用 &lt;code&gt;.app.src&lt;/code&gt; 文件，该文件位于 &lt;code&gt;src&lt;/code&gt; 目录中。该文件与 &lt;code&gt;.app&lt;/code&gt; 文件几乎相同，但是在构建步骤中可能会替换某些字段，例如应用程序版本。</target>
        </trans-unit>
        <trans-unit id="817bfba9b560dd19b99757cc44790bf08dd077b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.app&lt;/code&gt; files</source>
          <target state="translated">该 &lt;code&gt;.app&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="e7a9a94b1b27ccedaac07d12dcc8d76dbbdc8458" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">该 &lt;code&gt;.appup&lt;/code&gt; 文件可以如下所示：</target>
        </trans-unit>
        <trans-unit id="0f9944b699387d7c11ea7cd1be3bab23ba4afdef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.appup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</source>
          <target state="translated">所述 &lt;code&gt;.appup&lt;/code&gt; 文件包含一个单一的Erlang术语，它定义了用于升级或降级的应用的指令。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="0a4e2f387f9c84aa65d3380a5a44029b602ea3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.erlang.cookie&lt;/code&gt; file is to contain a line with the same atom. For example, on Linux or UNIX, in the OS shell:</source>
          <target state="translated">该 &lt;code&gt;.erlang.cookie&lt;/code&gt; 文件是包含具有相同原子的线。例如，在Linux或UNIX上，在OS Shell中：</target>
        </trans-unit>
        <trans-unit id="0032fcf48e0da685e59294f0a4f697a2db8dcacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcs&lt;/code&gt; file would look like:</source>
          <target state="translated">该 &lt;code&gt;.funcs&lt;/code&gt; 文件将如下所示：</target>
        </trans-unit>
        <trans-unit id="14e7547174b37977afa693aeffb001d289cd5a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hrl&lt;/code&gt; files are generated with &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt;. Include these files in your code as in the following example:</source>
          <target state="translated">的 &lt;code&gt;.hrl&lt;/code&gt; 文件与生成 &lt;code&gt;snmpc:mib_to_hrl/1&lt;/code&gt; 。如下例所示，将这些文件包括在您的代码中：</target>
        </trans-unit>
        <trans-unit id="3f3c52adfe9451ed557d5cb72636a16ce9b8cff5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="f61412bcc5809a8e7db35485d4bc2ee4c582bd3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains information about the release: its name, version, and which ERTS and application versions it uses.</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件包含有关发布的信息：它的名称，版本，以及ERTS和应用程序版本，它使用。</target>
        </trans-unit>
        <trans-unit id="fba0dc5cd4e50a75950facea5ebefcde4b2c40d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file contains one single Erlang term, which is called a &lt;strong&gt;release specification&lt;/strong&gt;. The file has the following syntax:</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件包含一个单一的Erlang项，其中被称为&lt;strong&gt;放行标准&lt;/strong&gt;。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="9be75095f9fcc28e6742d9c5c6b665ebdc21fd1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.rel&lt;/code&gt; file must also contain &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;sasl&lt;/code&gt;, as these applications are required by &lt;code&gt;ch_app&lt;/code&gt;. The file is called &lt;code&gt;ch_rel-1.rel&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;.rel&lt;/code&gt; 文件还必须包含 &lt;code&gt;kernel&lt;/code&gt; ， &lt;code&gt;stdlib&lt;/code&gt; 和 &lt;code&gt;sasl&lt;/code&gt; ，因为这些应用程序是由需要 &lt;code&gt;ch_app&lt;/code&gt; 。该文件称为 &lt;code&gt;ch_rel-1.rel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="13be72d295c9d3a74b0ba266a8b6d753044e4f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.script&lt;/code&gt; file is generated by &lt;code&gt;systools&lt;/code&gt; from a &lt;code&gt;.rel&lt;/code&gt; file and from &lt;code&gt;.app&lt;/code&gt; files.</source>
          <target state="translated">该 &lt;code&gt;.script&lt;/code&gt; 文件由产生 &lt;code&gt;systools&lt;/code&gt; 从 &lt;code&gt;.rel&lt;/code&gt; 文件，并从 &lt;code&gt;.app&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="8952d3b159688281512664b4559315ca46a6b2ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; in which the resolved process id is stored.</source>
          <target state="translated">存储了解析的进程ID 的 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f0ba8ce42f3241f6f1e8ce8e3ec88bd285be952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; in which the resolved port id is stored.</source>
          <target state="translated">存储解析的端口ID 的 &lt;code&gt;&lt;a href=&quot;#ErlNifPort&quot;&gt;ErlNifPort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9be61e44d94622615ce4101938ee713afd7cdab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; has the same behavior as before, and the old API still works. Thus, you are not required to change anything unless you want to. However, &lt;strong&gt;you are strongly encouraged to use the new API&lt;/strong&gt; instead of the old API based on &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;erlang:now/0&lt;/code&gt; is deprecated, as it is and will be a scalability bottleneck.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;default time warp mode&lt;/a&gt;&lt;/code&gt; 具有相同的行为和以前一样，和旧的API仍然有效。因此，除非您愿意，否则无需更改任何内容。但是，&lt;strong&gt;强烈建议您使用新的API&lt;/strong&gt;而不是基于 &lt;code&gt;&lt;a href=&quot;erlang#now-0&quot;&gt;erlang:now/0&lt;/a&gt;&lt;/code&gt; 的旧API 。 &lt;code&gt;erlang:now/0&lt;/code&gt; 仍被弃用，它将成为可伸缩性瓶颈。</target>
        </trans-unit>
        <trans-unit id="18bf0f08971899dc4f16a1b00f5aad47c098d502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt; is designed to model selective receives. A selective receive implicitly postpones any not received events, but the &lt;code&gt;postpone&lt;/code&gt; state transition action explicitly postpones one received event.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 的设计模型选择性接收。选择性接收会隐式延迟任何未接收的事件，但是 &lt;code&gt;postpone&lt;/code&gt; 状态转换操作会显式延迟一个已接收的事件。</target>
        </trans-unit>
        <trans-unit id="2e521122544eb6fa9ab0cd68ed9751d9d365e33f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of Erlang monotonic time heavily depends on the following:</source>
          <target state="translated">Erlang单调时间的 &lt;code&gt;&lt;a href=&quot;#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 在很大程度上取决于以下各项：</target>
        </trans-unit>
        <trans-unit id="6f631a391a9754e49e6ee1bde4ff6f90ac52a87f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; function can be used to inform the runtime system about the length of the NIF call. It is typically always to be used unless the NIF executes very fast.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#enif_consume_timeslice&quot;&gt;enif_consume_timeslice()&lt;/a&gt;&lt;/code&gt; 函数可以被用来通知运行时系统对NIF呼叫的长度。除非NIF执行得非常快，否则通常总是使用它。</target>
        </trans-unit>
        <trans-unit id="42203200dce5d30a841bfbad273ab03cca628668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; records below are defined in diameter.hrl, which can be included as follows.</source>
          <target state="translated">下面的 &lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#packet&quot;&gt;packet()&lt;/a&gt;&lt;/code&gt; 记录在直径.hrl中定义，可以包括以下内容。</target>
        </trans-unit>
        <trans-unit id="5443a5673cfdeb62b70cfaa66a1a4d05ea2c10ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; is displayed.</source>
          <target state="translated">显示&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64917e182873d825bb4118b082544cb5020d55ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; test is not completely foolproof. For a few special node types (e.g. &lt;code&gt;arity_qualifier&lt;/code&gt;), if such a node occurs in a context where it is not expected, it will be left unchanged as a non-reverted subtree of the result. This can only happen if &lt;code&gt;Tree&lt;/code&gt; does not actually represent legal Erlang code.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 测试是不完全万无一失。对于一些特殊的节点类型（例如 &lt;code&gt;arity_qualifier&lt;/code&gt; ），如果这样的节点出现在不期望出现的上下文中，则将其保留为结果的未还原子树。仅当 &lt;code&gt;Tree&lt;/code&gt; 实际上不表示合法的Erlang代码时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="8bdddf2d9e89b5afec27570549313f0a00dfb66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; is displayed with information about all debugged processes, interpreted modules, and selected options. Initially there are normally no debugged processes. First, it must be specified which modules that are to be &lt;strong&gt;debugged&lt;/strong&gt; (also called &lt;strong&gt;interpreted&lt;/strong&gt;). Proceed as follows:</source>
          <target state="translated">将显示&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor window&lt;/a&gt;&lt;/code&gt; ，其中包含有关所有调试的进程，解释的模块和所选选项的信息。最初通常没有调试过的进程。首先，必须指定要&lt;strong&gt;调试的&lt;/strong&gt;模块（也称为&lt;strong&gt;解释的&lt;/strong&gt;）。进行如下：</target>
        </trans-unit>
        <trans-unit id="d1371003c4109f45bb7c590d9e6bfcf741d3783e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;native&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; at the time when current Erlang runtime system instance started.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;native&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 的时候，目前的Erlang运行时系统实例启动。</target>
        </trans-unit>
        <trans-unit id="c54a199fd4640b0c1f2d1a7d7f234a5d11ebf160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; syntax and semantics resemble that of Perl.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#regexp_syntax&quot;&gt;regular expression&lt;/a&gt;&lt;/code&gt; 的语法和语义相似是Perl的。</target>
        </trans-unit>
        <trans-unit id="7246167f3c09c6525874f60b11ba89db7e2744c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; can insert events using the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;next_event&lt;/code&gt; and such an event is inserted as the next to present to the state callback. That is, as if it is the oldest incoming event. A dedicated &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;internal&lt;/code&gt; can be used for such events making them impossible to mistake for external events.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 可以插入使用的事件 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;next_event&lt;/code&gt; 和这样的事件被插入作为下一存在到状态回调。也就是说，好像它是最早的传入事件。可以将专用的 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event_type()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;internal&lt;/code&gt; 事件用于此类事件，从而使它们无法误认为外部事件。</target>
        </trans-unit>
        <trans-unit id="d79b4de0faec73ea8a56c3d33b4728d0d0f13117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; are executed when entering the first &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; just as for a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, except that the action &lt;code&gt;postpone&lt;/code&gt; is forced to &lt;code&gt;false&lt;/code&gt; since there is no event to postpone.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 进入第一次当执行 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 只是作为一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，只不过操作 &lt;code&gt;postpone&lt;/code&gt; 被迫 &lt;code&gt;false&lt;/code&gt; ，因为没有活动推迟。</target>
        </trans-unit>
        <trans-unit id="04249803fd25f8d18a129af7ec7559589758bac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; are associated with this list of keys.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#type-host_accepting_client_options&quot;&gt;host_accepting_client_options()&lt;/a&gt;&lt;/code&gt; 与键此列表关联。</target>
        </trans-unit>
        <trans-unit id="0e395a27eee95c6082f8cf61222aaf962540cea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; or an associated &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; must then be used in calls to &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#type-server_id&quot;&gt;server_id()&lt;/a&gt;&lt;/code&gt; 或相关联的 &lt;code&gt;&lt;a href=&quot;ct#type-target_name&quot;&gt;ct:target_name()&lt;/a&gt;&lt;/code&gt; 必须随后在调用用于 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3dc033ce6bd037856bac83ebd4f39855340ec51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; type also consist of the following &lt;strong&gt;deprecated&lt;/strong&gt; symbolic time units:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;#type_time_unit&quot;&gt;time_unit()&lt;/a&gt;&lt;/code&gt; 类型还包括以下的&lt;strong&gt;弃用&lt;/strong&gt;符号时间单元：</target>
        </trans-unit>
        <trans-unit id="88d76a69dffe86852b03f6f2771d64a235602ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; is expected to know if reloading is demanded before creating a monitor for loading.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 预计将知道，如果重新装入加载创建显示器前要求。</target>
        </trans-unit>
        <trans-unit id="4ef4e16c6d6043c0d934f6a3edee0c7cc5aa2fe6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; module provides the main interface for writing test cases. This includes for example, the following:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 模块提供了编写测试用例的主界面。例如，这包括以下内容：</target>
        </trans-unit>
        <trans-unit id="24d2428c5253a289420ac3c56a797aad5738f051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; function prints a string to the test case log file. The &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the string to screen. The &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; function prints the same string both to file and screen. The functions are described in module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct#log-1&quot;&gt;log/1,2,3,4,5&lt;/a&gt;&lt;/code&gt; 函数打印字符串测试用例的日志文件。在 &lt;code&gt;&lt;a href=&quot;ct#print-1&quot;&gt;print/1,2,3,4&lt;/a&gt;&lt;/code&gt; 函数打印字符串到屏幕。在 &lt;code&gt;&lt;a href=&quot;ct#pal-1&quot;&gt;pal/1,2,3,4&lt;/a&gt;&lt;/code&gt; 函数打印相同的字符串既文件和屏幕。功能在模块 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 中描述。</target>
        </trans-unit>
        <trans-unit id="2225a95d59e4a2a00a916261ffc2ac6e972545a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program can be used for running tests from the OS command line, for example, as follows:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 程序可用于从OS命令行运行试验，例如，如下所示：</target>
        </trans-unit>
        <trans-unit id="45351661ad4006c4669c2ebdd26490749b02b241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable &lt;code&gt;Age&lt;/code&gt;, which is included at two positions in the tuple. The pattern match is performed as follows:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;erl_format#erl_match&quot;&gt;erl_format:erl_match&lt;/a&gt;&lt;/code&gt; 功能执行模式匹配。它需要一个模式和一个术语，并试图匹配它们。副作用是，模式中任何未绑定的变量都将被绑定。在以下示例中，使用变量 &lt;code&gt;Age&lt;/code&gt; 创建一个模式，该模式包含在元组的两个位置。模式匹配执行如下：</target>
        </trans-unit>
        <trans-unit id="5d913aee0ec20f5c99548c0d67120c8b7390405c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; callback, which is used a lot in this implementation.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 回调，这是在这个实现中使用了很多。</target>
        </trans-unit>
        <trans-unit id="e04d20c0a21a342accdbeea00bdc89554c9bbc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; is used by clients and servers, that is, SSH channels, to communicate over the SSH connection. The API functions in this module send SSH Connection Protocol events, which are received as messages by the remote channel. If the receiving channel is an Erlang process, the messages have the format &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; 由客户机和服务器，即，SSH通道使用的，超过所述SSH连接进行通信。此模块中的API函数发送SSH连接协议事件，该事件作为消息由远程通道接收。如果接收通道是Erlang进程，则消息的格式为 &lt;code&gt;{ssh_cm, connection_ref(), ssh_event_msg()}&lt;/code&gt; 。如果使用 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为来实现通道过程，则由 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 处理这些消息。</target>
        </trans-unit>
        <trans-unit id="29f892246d7df69546254cbfcc798654f3646997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; defines</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125&quot;&gt;RFC 6125&lt;/a&gt;&lt;/code&gt; 定义</target>
        </trans-unit>
        <trans-unit id="7dcb6a1e5d8b3f03deff03d3241d42eac28f4c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module makes it possible to map different parts of the host file system into the document tree, that is, creates aliases and redirections.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;mod_alias&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 模块，可以将主机文件系统的不同部分映射到文档树中，即创建别名和重定向。</target>
        </trans-unit>
        <trans-unit id="fcc4b78316a4143698c35ef4043e086c3252f889" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; module provides for basic user authentication using textual files, Dets databases as well as Mnesia databases.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 模块使用的文本文件，dets的数据库以及数据库的Mnesia提供了基本的用户认证。</target>
        </trans-unit>
        <trans-unit id="461a1eaddbc542451f83c2ca184fe0b61bd2923e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; module implements the Erlang Server Interface (ESI) providing a tight and efficient interface to the execution of Erlang functions.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; 模块实现Erlang的服务器接口（ESI）提供紧密和有效的接口的二郎功能的执行。</target>
        </trans-unit>
        <trans-unit id="451822a0390939c5b7aa871766fbf59707a840eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; module serves as a filter for authenticated requests handled in &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt;. It provides a possibility to restrict users from access for a specified amount of time if they fail to authenticate several times. It logs failed authentication as well as blocking of users, and it calls a configurable callback module when the events occur.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;mod_security&quot;&gt;mod_security&lt;/a&gt;&lt;/code&gt; 模块用作认证请求的过滤器中处理 &lt;code&gt;&lt;a href=&quot;mod_auth&quot;&gt;mod_auth(3)&lt;/a&gt;&lt;/code&gt; 。如果用户多次验证失败，则可以在指定的时间内限制用户访问。它记录失败的身份验证以及对用户的阻止，并在事件发生时调用可配置的回调模块。</target>
        </trans-unit>
        <trans-unit id="41608b3a764923c262561e0c2d97e667f71e82d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; for an overview of available start flags (as most flags have a corresponding configuration term)</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_runprogram&lt;/a&gt;&lt;/code&gt; 可用开始标志的概述（大多数标志具有相应配置的术语）</target>
        </trans-unit>
        <trans-unit id="8c2bdaafc19f8eda6fa7e095397c6b638b7731c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; module can be used for debugging a supervisor bridge.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 模块，可用于调试主管桥。</target>
        </trans-unit>
        <trans-unit id="1915b4761876d96adb7cfdaf20279417ba58c6b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;tftp#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 功能启动一个守护进程监听端口的UDP数据包。收到读取或写入请求后，它将生成一个临时服务器进程来处理传输。</target>
        </trans-unit>
        <trans-unit id="8e817126baaf83dd2177ff4d3961b1bf92117ec3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac6d07dd79fabf515998a51c2c8ccd52cb9e6e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11b934f9948e4845a2b33851b5932f94d59f1d45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="842d1fd61ccfd8c7f0a3b2ea51238f75d1a39f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; has examples and a &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">《 &lt;code&gt;&lt;a href=&quot;users_guide&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 包含示例和&amp;ldquo; &lt;code&gt;&lt;a href=&quot;using_ssh&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="7213ba1d558f14b69b4e8a3edef214d04ef9e98a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?Q&lt;/code&gt; macros turn the quoted code fragments into ASTs, and lifts metavariables such as &lt;code&gt;_@Tuple&lt;/code&gt; and &lt;code&gt;_@Number&lt;/code&gt; to the level of your Erlang code, so you can use the corresponding Erlang variables &lt;code&gt;Tuple&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; directly. This is the most straightforward way to use Merl, and in many cases it's all you need.</source>
          <target state="translated">该 &lt;code&gt;?Q&lt;/code&gt; 宏打开引用的代码片段到AST的，和升降机元变量诸如 &lt;code&gt;_@Tuple&lt;/code&gt; 和 &lt;code&gt;_@Number&lt;/code&gt; 到您的二郎山代码的水平，这样你就可以使用相应的二郎神变量 &lt;code&gt;Tuple&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 直接。这是使用Merl的最直接的方法，在很多情况下，这就是您所需要的。</target>
        </trans-unit>
        <trans-unit id="15c579f9adfb6704c3bcff309334cae348b5e5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?assert(Expression)&lt;/code&gt; macro will evaluate &lt;code&gt;Expression&lt;/code&gt;, and if that does not evaluate to &lt;code&gt;true&lt;/code&gt;, it will throw an exception; otherwise it just returns &lt;code&gt;ok&lt;/code&gt;. In the above example, the test will thus fail if the call to &lt;code&gt;length&lt;/code&gt; does not return 3.</source>
          <target state="translated">本 &lt;code&gt;?assert(Expression)&lt;/code&gt; 宏将评估 &lt;code&gt;Expression&lt;/code&gt; ，如果不计算结果为 &lt;code&gt;true&lt;/code&gt; ，就会抛出一个异常; 否则，它将返回 &lt;code&gt;ok&lt;/code&gt; 。在上面的示例中，如果调用 &lt;code&gt;length&lt;/code&gt; 不返回3 ，则测试将因此失败。</target>
        </trans-unit>
        <trans-unit id="824fe9ddd06f6c4a1a05c0b0fcb9265f7a7b2017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASN.1&lt;/code&gt; application provides the following two separate user interfaces:</source>
          <target state="translated">在 &lt;code&gt;ASN.1&lt;/code&gt; 申请提供了以下两个独立的用户界面：</target>
        </trans-unit>
        <trans-unit id="ad1896e2fd3770f39ede02112fb63bbac81b7df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Address&lt;/code&gt; field is the second element.</source>
          <target state="translated">的 &lt;code&gt;Address&lt;/code&gt; 字段是第二元件。</target>
        </trans-unit>
        <trans-unit id="e284c989131372b49e03051b62849870dd521425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to &quot;compact notation&quot;. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;BIT STRING&lt;/code&gt; 类型被解码为&amp;ldquo;紧凑符号&amp;rdquo;。&lt;strong&gt;不建议在新代码中使用此选项。&lt;/strong&gt;此选项不能与选项 &lt;code&gt;maps&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="d727373c971108a708085cfa309ebdb4fa5bc28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BIT STRING&lt;/code&gt; type is decoded to the legacy format, that is, a list of zeroes and ones. &lt;strong&gt;This option is not recommended for new code.&lt;/strong&gt; This option cannot be combined with the option &lt;code&gt;maps&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;BIT STRING&lt;/code&gt; 类型被解码到传统格式，也就是0和1的列表。&lt;strong&gt;不建议在新代码中使用此选项。&lt;/strong&gt;此选项不能与选项 &lt;code&gt;maps&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="3c84e077a6dbf3c771cfd255a8a9895e6702d3a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bitstring&lt;/code&gt; variable can consist of any number of bits, for example, 0, 1, 8, 11, 17, 42, and so on. This is because the default &lt;code&gt;unit&lt;/code&gt; for bitstrings is 1.</source>
          <target state="translated">的 &lt;code&gt;Bitstring&lt;/code&gt; 变量可以由任意数目的位，例如，0，1，8，11，17，42，等等。这是因为位串的默认 &lt;code&gt;unit&lt;/code&gt; 是1。</target>
        </trans-unit>
        <trans-unit id="94a1488efe62c17d8ba98c01afd1b232f7321a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; argument indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Block&lt;/code&gt; 参数指示如果日志应转换期间不被阻止。这在转换大型日志时可能很有用（否则，在转换过程中日志可能会换行）。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ab5f211e8f18fd1c4ca859d11a5d3fcd218d631" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Block&lt;/code&gt; option indicates if the log should be blocked during conversion. This could be usefull when converting large logs (when otherwise the log could wrap during conversion). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Block&lt;/code&gt; 选项指示在转换过程中是否应阻止日志。这在转换大型日志时可能很有用（否则，在转换过程中日志可能会自动换行）。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2acfbefe2ee37310ba387213e5e15aa6901a988c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Callback&lt;/code&gt; module should contain hook functions for all tags present in the data structure. A hook function must have the following format:</source>
          <target state="translated">所述 &lt;code&gt;Callback&lt;/code&gt; 模块应包含钩子函数所有标签存在于所述数据结构中。挂钩函数必须具有以下格式：</target>
        </trans-unit>
        <trans-unit id="883390db9451e13b3d5a5f85d744ec9ca06a2b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallbackMode&lt;/code&gt; is either just &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; or a list containing &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; and possibly the atom &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;CallbackMode&lt;/code&gt; 是要么只是 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 或含列表 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback_mode()&lt;/a&gt;&lt;/code&gt; 以及可能的原子 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a580d51d45e0183e4b31ffec1224002d11cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CharSpec&lt;/code&gt;&lt;code&gt;eof&lt;/code&gt; signals end of file. &lt;code&gt;LeftOverChars&lt;/code&gt; then takes the value &lt;code&gt;eof&lt;/code&gt; as well.</source>
          <target state="translated">所述 &lt;code&gt;CharSpec&lt;/code&gt; &lt;code&gt;eof&lt;/code&gt; 信号结束的文件。然后， &lt;code&gt;LeftOverChars&lt;/code&gt; 也将取值 &lt;code&gt;eof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64d980b4c7c9584d2e8b4e055ab6694f99c89599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChildSpecs&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; is a list of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; 返回值中的 &lt;code&gt;ChildSpecs&lt;/code&gt; 变量是 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;child specifications&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="e5232c85e790e4f73652dc642ce50e6888594555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ChunkSize&lt;/code&gt; defines the size of the &lt;code&gt;PlainBin&lt;/code&gt;s that &lt;code&gt;EncodeFun&lt;/code&gt; is applied to. If the &lt;code&gt;ChunkSize&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;ChunkSize&lt;/code&gt; is intended for block crypto. &lt;code&gt;ChunkSize&lt;/code&gt;s can be changed in the return from the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;ChunkSize&lt;/code&gt; 定义了的尺寸 &lt;code&gt;PlainBin&lt;/code&gt; s表示 &lt;code&gt;EncodeFun&lt;/code&gt; 施加到。如果 &lt;code&gt;ChunkSize&lt;/code&gt; 是 &lt;code&gt;undefined&lt;/code&gt; ，所述的尺寸 &lt;code&gt;PlainBin&lt;/code&gt; 小号而变化，因为这是用于流密码，而一个固定的 &lt;code&gt;ChunkSize&lt;/code&gt; 是用于块密码。 &lt;code&gt;ChunkSize&lt;/code&gt; S能够从返回改变 &lt;code&gt;EncryptFun&lt;/code&gt; 或 &lt;code&gt;DecryptFun&lt;/code&gt; 。可以在 &lt;code&gt;pos_integer()&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 之间更改该值。</target>
        </trans-unit>
        <trans-unit id="e8a7a9966f0b85d64cc4feece108959a21b830fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; API does also allow you to save the collected &lt;code&gt;Events&lt;/code&gt; to file and later load them in a later session.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; API确实也让您保存收集 &lt;code&gt;Events&lt;/code&gt; ，以文件，后来在以后的会议上加载它们。</target>
        </trans-unit>
        <trans-unit id="fceb8c2c1f65a97284385a3f23405d68267725fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; automatically registers itself to listen for trace &lt;code&gt;Events&lt;/code&gt;, so all you have to do is enable them.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; 会自动将自身注册为监听跟踪 &lt;code&gt;Events&lt;/code&gt; ，因此，所有你需要做的就是让他们。</target>
        </trans-unit>
        <trans-unit id="ec20677889045987c82a0d9f6c4d053fcf85822c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Collector&lt;/code&gt; manages a key/value based dictionary, where the filters are stored. Updates of the dictionary is propagated to all subscribing processes. When a &lt;code&gt;Viewer&lt;/code&gt; is started it is registered as a subscriber of dictionary updates.</source>
          <target state="translated">该 &lt;code&gt;Collector&lt;/code&gt; 管理基于键/值字典，当过滤器存储。字典的更新将传播到所有订阅过程。当 &lt;code&gt;Viewer&lt;/code&gt; 启动已被注册为词典更新的订户。</target>
        </trans-unit>
        <trans-unit id="e368c10bff22300d3fab811f6f50a4674a69667b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Framework Log page includes links to the Pre- and Post Test I/O Log. In this log, &lt;code&gt;Common Test&lt;/code&gt; saves printouts made with &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; and &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt;, as well as captured system error- and progress reports, which take place before, and after, the test run. Examples of this are printouts from a CT hook init- or terminate function, or progress reports generated when an OTP application is started from a CT hook init function. Another example is an error report generated because of a failure when an external application is stopped from a CT hook terminate function. All information in these examples ends up in the Pre- and Post Test I/O Log. For more information on how to synchronize test runs with external user applications, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; in section Common Test Hooks.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 框架日志&amp;rdquo;页面包含指向&amp;ldquo;测试前和测试后I / O日志&amp;rdquo;的链接。在此日志中， &lt;code&gt;Common Test&lt;/code&gt; 保存使用 &lt;code&gt;ct:log/1,2,3,4,5&lt;/code&gt; 和 &lt;code&gt;ct:pal/1,2,3,4,5&lt;/code&gt; 进行的打印输出，以及捕获的系统错误和进度报告，这些报告分别在测试运行之前和之后进行。例如，CT挂钩初始化或终止功能的打印输出，或从CT挂钩初始化功能启动OTP应用程序时生成的进度报告。另一个示例是由于从CT挂钩终止功能停止外部应用程序时失败导致的错误报告。这些示例中的所有信息最终显示在&amp;ldquo;测试前/测试后I / O日志&amp;rdquo;中。有关如何将测试运行与外部用户应用程序同步的更多信息，请参见&amp;ldquo; 通用测试挂钩&amp;rdquo; 部分中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#synchronizing&quot;&gt;Synchronizing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="2b15f94344ef9977a91750baa9dddf1dbad0746d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master API is exported by module &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 大师API由模块输出 &lt;code&gt;&lt;a href=&quot;ct_master&quot;&gt;ct_master&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1eb6fe3660c4d65491500f6426215f629639619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server runs on one dedicated Erlang node and uses distributed Erlang to communicate with any number of &lt;code&gt;Common Test&lt;/code&gt; test nodes, each hosting a regular &lt;code&gt;Common Test&lt;/code&gt; server. Test specifications are used as input to specify what to test on which test nodes, using what configuration.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 一个专门的Erlang节点上的主服务器运行，并使用分布式二郎神与任意数量的沟通 &lt;code&gt;Common Test&lt;/code&gt; 测试节点，每个节点托管一个普通 &lt;code&gt;Common Test&lt;/code&gt; 服务器。测试规范用作输入，以指定使用什么配置在哪些测试节点上进行测试。</target>
        </trans-unit>
        <trans-unit id="d910e14beb83938480f0c5db0900211c5bc5ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; Master server writes progress information to HTML log files similarly to the regular &lt;code&gt;Common Test&lt;/code&gt; server. The logs contain test statistics and links to the log files written by each independent &lt;code&gt;Common Test&lt;/code&gt; server.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 主服务器到HTML日志文件类似于定期将进展信息 &lt;code&gt;Common Test&lt;/code&gt; 服务器。日志包含测试统计信息，并链接到每个独立的 &lt;code&gt;Common Test&lt;/code&gt; 服务器编写的日志文件。</target>
        </trans-unit>
        <trans-unit id="4e124139583e4b5d8918f07bb2c0c03bd8d6c703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application also includes other modules named &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt;, which provide various support, mainly simplified use of communication protocols such as RPC, SNMP, FTP, Telnet, and others.</source>
          <target state="translated">的 &lt;code&gt;Common Test&lt;/code&gt; 程序还包括其他名为模块 &lt;code&gt;ct_&amp;lt;component&amp;gt;&lt;/code&gt; ，它们提供各种支持，主要简化使用的通信协议，例如RPC，SNMP，FTP，Telnet和其他。</target>
        </trans-unit>
        <trans-unit id="03a84fce685f88578ce41de6a729049cb8fac0fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; application is installed with the Erlang/OTP system. No extra installation step is required to start using &lt;code&gt;Common Test&lt;/code&gt; through the &lt;code&gt;ct_run&lt;/code&gt; executable program, and/or the interface functions in the &lt;code&gt;ct&lt;/code&gt; module.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 应用程序安装与二郎/ OTP系统。通过 &lt;code&gt;ct_run&lt;/code&gt; 可执行程序和/或 &lt;code&gt;ct&lt;/code&gt; 模块中的接口功能开始使用 &lt;code&gt;Common Test&lt;/code&gt; ,不需要任何额外的安装步骤。</target>
        </trans-unit>
        <trans-unit id="78a22725d0c7f0f676d4ba2a90661e795ebb56c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is a tool that supports implementation and automated execution of test cases to any types of target systems. &lt;code&gt;Common Test&lt;/code&gt; is the main tool being used in all testing- and verification activities that are part of Erlang/OTP system development and maintenance.</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 框架是支持实施和测试用例自动执行任何类型的目标系统的工具。 &lt;code&gt;Common Test&lt;/code&gt; 是Erlang / OTP系统开发和维护中所有测试和验证活动中使用的主要工具。</target>
        </trans-unit>
        <trans-unit id="18e9917f7eb0c975fe2d0bf461322b555cc56962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework is an environment for implementing and performing automatic and semi-automatic execution of test cases.</source>
          <target state="translated">的 &lt;code&gt;Common Test&lt;/code&gt; 框架是用于实现和执行的测试用例自动和半自动执行的环境。</target>
        </trans-unit>
        <trans-unit id="c32a30ee7b6005326d0a472ffa1a54f5ce95df96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; framework provides a high-level operator interface for testing, providing the following features:</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 框架提供了测试，并提供以下功能的高级操作界面：</target>
        </trans-unit>
        <trans-unit id="ad9b65cad13beffef2e82d575de6699dcf88a08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Common Test&lt;/code&gt; test server requires that the test suite defines and exports the following mandatory or optional callback functions:</source>
          <target state="translated">在 &lt;code&gt;Common Test&lt;/code&gt; 测试服务器要求的测试套件定义和导出以下强制或可选的回调函数：</target>
        </trans-unit>
        <trans-unit id="b3f5974325a1f6adb2e7a53fd6b80b396429c849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database is now initialized and contains data.</source>
          <target state="translated">该 &lt;code&gt;Company&lt;/code&gt; 数据库现在已经初始化并包含数据。</target>
        </trans-unit>
        <trans-unit id="84399fbfc3c32ddc0958865c1bc7e66e07f291b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Company&lt;/code&gt; database, introduced in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, has three tables that store records (&lt;code&gt;employee&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, &lt;code&gt;project&lt;/code&gt;), and three tables that store relationships (&lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, &lt;code&gt;in_proj&lt;/code&gt;). This is a normalized data model, which has some advantages over a non-normalized data model.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 引入的 &lt;code&gt;Company&lt;/code&gt; 数据库具有三个存储记录的表（ &lt;code&gt;employee&lt;/code&gt; ， &lt;code&gt;dept&lt;/code&gt; ， &lt;code&gt;project&lt;/code&gt; ）和三个存储关系的表（ &lt;code&gt;manager&lt;/code&gt; ， &lt;code&gt;at_dep&lt;/code&gt; ， &lt;code&gt;in_proj&lt;/code&gt; ）。这是规范化的数据模型，与非规范化的数据模型相比，它具有一些优点。</target>
        </trans-unit>
        <trans-unit id="5b4167561d4c9786e75acf722fa5255d76e1f375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ControlMessage&lt;/code&gt; is a tuple, where the first element indicates which distributed operation it encodes:</source>
          <target state="translated">所述 &lt;code&gt;ControlMessage&lt;/code&gt; 是一个元组，其中第一元素指示它编码一种分布式操作：</target>
        </trans-unit>
        <trans-unit id="b53e02a747463b517e8ec15e14ceddfb049c6d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DAT&lt;/code&gt; files must always be opened with option &lt;code&gt;{repair, false}&lt;/code&gt;. This ensures that these files are not automatically repaired. Without this option, the database can become inconsistent, because &lt;code&gt;Mnesia&lt;/code&gt; can believe that the files were properly closed. For information about configuration parameter &lt;code&gt;auto_repair&lt;/code&gt;, see the Reference Manual.</source>
          <target state="translated">的 &lt;code&gt;DAT&lt;/code&gt; 文件必须始终选项打开 &lt;code&gt;{repair, false}&lt;/code&gt; 。这样可以确保不会自动修复这些文件。没有此选项，数据库可能会变得不一致，因为 &lt;code&gt;Mnesia&lt;/code&gt; 可以认为文件已正确关闭。有关配置参数 &lt;code&gt;auto_repair&lt;/code&gt; 的信息，请参见《参考手册》。</target>
        </trans-unit>
        <trans-unit id="5873af1928aed9c59ec2db4bf69bcbdd1c33d63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Data&lt;/code&gt; received can be a &lt;code&gt;binary()&lt;/code&gt; or a &lt;code&gt;list()&lt;/code&gt; of bytes (integers in the range 0 through 255) depending on the socket mode, or an SCTP event.</source>
          <target state="translated">根据套接字模式或SCTP事件，接收到的 &lt;code&gt;Data&lt;/code&gt; 可以是 &lt;code&gt;binary()&lt;/code&gt; 或字节的 &lt;code&gt;list()&lt;/code&gt; （0到255之间的整数）。</target>
        </trans-unit>
        <trans-unit id="69f5b6911daa714868434e1a90189319187674c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DbgExtra&lt;/code&gt; options are described in section &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;DbgExtra&lt;/code&gt; 选项在节中描述 &lt;code&gt;&lt;a href=&quot;#debug_flags&quot;&gt;DbgExtra Options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16f5677b6ef24617d1e07a7aa94edc055731eaee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DiscoHandler&lt;/code&gt; module is used during the discovery process. See &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">所述 &lt;code&gt;DiscoHandler&lt;/code&gt; 模块在发现过程中使用。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_discovery_handler&quot;&gt;discovery handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="510046e751218ed5f95a1059673c4d8fbf2a7fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dst&lt;/code&gt; map is updated with new channel values. The syntax for updating an existing key with a new value is with the &lt;code&gt;:=&lt;/code&gt; operator.</source>
          <target state="translated">所述 &lt;code&gt;Dst&lt;/code&gt; 的图与新的信道值来更新。用新值更新现有键的语法是使用 &lt;code&gt;:=&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d0e5af70acd62ed71f0140803a094eed25236db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term type is used for passing a term encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, that is, a term that has been encoded by &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;, and so on. For example, if &lt;code&gt;binp&lt;/code&gt; is a pointer to an &lt;code&gt;ErlDrvBinary&lt;/code&gt; that contains term &lt;code&gt;{17, 4711}&lt;/code&gt; encoded with the &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt;, and you want to wrap it in a two-tuple with the tag &lt;code&gt;my_tag&lt;/code&gt;, that is, &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt;, you can do as follows:</source>
          <target state="translated">所述 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 术语类型用于通过与所述编码的术语 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; ，即，已经由编码的术语 &lt;code&gt;&lt;a href=&quot;erlang#term_to_binary-2&quot;&gt;erlang:term_to_binary&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; ，等等。例如，如果 &lt;code&gt;binp&lt;/code&gt; 是指向ErlDrvBinary的指针，该指针包含用 &lt;code&gt;&lt;a href=&quot;erl_ext_dist&quot;&gt;external format&lt;/a&gt;&lt;/code&gt; 编码的术语 &lt;code&gt;{17, 4711}&lt;/code&gt; &lt;code&gt;ErlDrvBinary&lt;/code&gt; }，并且您想将其包装成带有标签 &lt;code&gt;my_tag&lt;/code&gt; 的两个元组，即 &lt;code&gt;{my_tag, {17, 4711}}&lt;/code&gt; ，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="8c0ac01302ce56a5538e783afbe86c0e3ca92aac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; term is a way to construct strings. It works differently from how &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; works. &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; builds a string list in reverse order (as opposed to how &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; works), concatenating the strings added to a list. The tail must be specified before &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 项是构建字符串的方法。它的工作方式与 &lt;code&gt;ERL_DRV_STRING&lt;/code&gt; 的工作方式不同。 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 以相反的顺序构建字符串列表（与 &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 的工作方式相反），将添加到列表中的字符串连接起来。必须在 &lt;code&gt;ERL_DRV_STRING_CONS&lt;/code&gt; 之前指定尾部。</target>
        </trans-unit>
        <trans-unit id="7fe5603a0b688982ee095c5b6eb8b3abf301f57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_DRV_UINT&lt;/code&gt;, &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt;, and &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; term types were introduced in ERTS 5.6.</source>
          <target state="translated">该 &lt;code&gt;ERL_DRV_UINT&lt;/code&gt; ， &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 和 &lt;code&gt;ERL_DRV_EXT2TERM&lt;/code&gt; 项类型ERTS 5.6进行了介绍。</target>
        </trans-unit>
        <trans-unit id="78c7a39595ca5fe9252d32999a603c6e910dd570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable can be used to store the complicated parameters in:</source>
          <target state="translated">所述 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 环境变量可以用于存储复杂参数中：</target>
        </trans-unit>
        <trans-unit id="0a3584a359b0427b176ceaff9674304e574ffce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Emakefile&lt;/code&gt; (if it exists) in the current directory is searched for compiler options for each module. If a given module does not exist in &lt;code&gt;Emakefile&lt;/code&gt; or if &lt;code&gt;Emakefile&lt;/code&gt; does not exist, the module is still compiled.</source>
          <target state="translated">在当前目录中的 &lt;code&gt;Emakefile&lt;/code&gt; （如果存在）中搜索每个模块的编译器选项。如果给定的模块不存在中 &lt;code&gt;Emakefile&lt;/code&gt; 或者 &lt;code&gt;Emakefile&lt;/code&gt; 不存在，该模块还在编制。</target>
        </trans-unit>
        <trans-unit id="da28c7ffe618c58fd36df47a840c22abe8ebdbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encoding&lt;/code&gt; says how the characters in the request are represented. We want to store the characters as lists in the ETS table, so we convert them to lists using function &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt;. The conversion function conveniently accepts the encoding types &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;latin1&lt;/code&gt;, so we can use &lt;code&gt;Encoding&lt;/code&gt; directly.</source>
          <target state="translated">该 &lt;code&gt;Encoding&lt;/code&gt; 表示，如何在请求中的字符表示。我们要将字符存储为ETS表中的列表，因此我们使用 &lt;code&gt;unicode:characters_to_list/2&lt;/code&gt; 函数将它们转换为列表。转换函数方便地接受 &lt;code&gt;unicode&lt;/code&gt; 和 &lt;code&gt;latin1&lt;/code&gt; 编码类型，因此我们可以直接使用 &lt;code&gt;Encoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3c694d3baa325d31ca5ef434295459f7fd84d35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvBinary&lt;/code&gt; structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when &lt;code&gt;driver_binary_free&lt;/code&gt; is called, the reference count is decremented, when it reaches zero, the binary is deallocated. &lt;code&gt;orig_size&lt;/code&gt; is the binary size and &lt;code&gt;orig_bytes&lt;/code&gt; is the buffer. &lt;code&gt;ErlDrvBinary&lt;/code&gt; has not a fixed size, its size is &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 结构是二进制，因为仿真器和驱动器之间发送。所有二进制文件都以引用计数；调用 &lt;code&gt;driver_binary_free&lt;/code&gt; 时，引用计数递减，当引用计数达到零时，将释放二进制文件。 &lt;code&gt;orig_size&lt;/code&gt; 是二进制大小，而 &lt;code&gt;orig_bytes&lt;/code&gt; 是缓冲区。 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 没有固定大小，其大小为 &lt;code&gt;orig_size + 2 * sizeof(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c86b87f3b0b95eba095182c55f0fcc45cc6647fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvNowData&lt;/code&gt; structure holds a time stamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</source>
          <target state="translated">该 &lt;code&gt;ErlDrvNowData&lt;/code&gt; 结构包含由选自在过去的某个任意点处测量的三个值的时间戳。这三个结构成员是：</target>
        </trans-unit>
        <trans-unit id="89f846aa2a9d3bbb835eaa5c58e3ac257c0f2247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure is used for storage of information about the Erlang runtime system. &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; writes the system information when passed a reference to a &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; structure. The fields in the structure are as follows:</source>
          <target state="translated">该 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构用于关于Erlang运行时系统信息的存储。当传递对 &lt;code&gt;ErlDrvSysInfo&lt;/code&gt; 结构的引用时， &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 会写入系统信息。结构中的字段如下：</target>
        </trans-unit>
        <trans-unit id="a097b8521d625c64b18dfa0ef6d0bb28ad84fb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library contains functions that help you integrate programs written in C and Erlang. The functions in &lt;code&gt;Erl_Interface&lt;/code&gt; support the following:</source>
          <target state="translated">该 &lt;code&gt;Erl_Interface&lt;/code&gt; 库包含了帮助您将C语言编写，Erlang程序的功能。 &lt;code&gt;Erl_Interface&lt;/code&gt; 中的函数支持以下功能：</target>
        </trans-unit>
        <trans-unit id="c0bb8f936d4589865a80fe604ad9b594bedb70df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Erl_Interface&lt;/code&gt; library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple &lt;code&gt;{tobbe,3928}&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;Erl_Interface&lt;/code&gt; 库支持这项活动。它具有创建和操作Erlang数据结构的多个C函数。该库还包含编码和解码功能。下面的示例演示如何创建和编码Erlang元组 &lt;code&gt;{tobbe,3928}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57a4e297c09c6f1e5049ba6a6a04c4f9715c1746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorDesc&lt;/code&gt; returned is an opaque value to be passed further on to function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;. For more control over the operation, use the &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">返回的 &lt;code&gt;ErrorDesc&lt;/code&gt; 是一个不透明的值，将进一步传递给函数 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。要对操作进行更多控制，请使用 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="0a7a560a95e6aefba3bb607f84b70fa45da9fcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned earlier is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure, which is returned from all I/O modules. It has the following format:</source>
          <target state="translated">前面提到的 &lt;code&gt;ErrorInfo&lt;/code&gt; 是标准的 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构，该结构从所有I / O模块返回。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="46cd6a74f6ad42247387aa8b77c1e43606850bb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorInfo&lt;/code&gt; mentioned in this module is the standard &lt;code&gt;ErrorInfo&lt;/code&gt; structure that is returned from all I/O modules. It has the following format:</source>
          <target state="translated">所述 &lt;code&gt;ErrorInfo&lt;/code&gt; 该模块中提到的是标准 &lt;code&gt;ErrorInfo&lt;/code&gt; 即从所有的I / O模块返回的结构。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="93b9c6c6a8848b5cb82997ba3624a2f0fabf1b76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Records&lt;/code&gt; in the Ets table are ordered by their timestamp. Which timestamp that should be used is controlled via the &lt;code&gt;event_order&lt;/code&gt; parameter. Default is &lt;code&gt;trace_ts&lt;/code&gt; which means the time when the trace data was generated. &lt;code&gt;event_ts&lt;/code&gt; means the time when the trace data was parsed (transformed into an &lt;code&gt;Event Record&lt;/code&gt;).</source>
          <target state="translated">Ets表中的 &lt;code&gt;Event Records&lt;/code&gt; 按其时间戳排序。通过 &lt;code&gt;event_order&lt;/code&gt; 参数控制应使用的时间戳。默认值为 &lt;code&gt;trace_ts&lt;/code&gt; ，这表示生成跟踪数据的时间。 &lt;code&gt;event_ts&lt;/code&gt; 表示解析跟踪数据（转换为 &lt;code&gt;Event Record&lt;/code&gt; ）的时间。</target>
        </trans-unit>
        <trans-unit id="78b79ae16c44e1321dea0365d3ec779b8f949891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses named filters in various contexts. An Event Trace filter is an &lt;code&gt;Erlang fun&lt;/code&gt; that takes some trace data as input and returns a possibly modified version of it:</source>
          <target state="translated">该 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 使用命名在各种情况下的过滤器。事件跟踪过滤器是 &lt;code&gt;Erlang fun&lt;/code&gt; 一个有趣功能，它将一些跟踪数据作为输入并返回其可能的修改版本：</target>
        </trans-unit>
        <trans-unit id="272a43aecd37d28c1a13622b7271bed26dc65387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Event Tracer (ET)&lt;/code&gt; uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</source>
          <target state="translated">该 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 用来收集和跟踪数据的图形查看内置在二郎山跟踪机制，并提供工具。</target>
        </trans-unit>
        <trans-unit id="7b3f5424185756e71f4988bcc6cd871d1c3dd01e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expire&lt;/code&gt; time indicates for how long the request is valid (after which the manager is free to delete it).</source>
          <target state="translated">该 &lt;code&gt;Expire&lt;/code&gt; 时间表示请求的有效时间（在此之后，管理者可以自由地将其删除）。</target>
        </trans-unit>
        <trans-unit id="8e6c34cadce8690c6e2555787337ac8b727e225e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 通过添加过滤器时参数被指定 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="229acf43839cafb043149ab1533fb570fa7aafb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Extra&lt;/code&gt; parameter to the &lt;code&gt;domain/2&lt;/code&gt; function is specified when adding the filter via &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Extra&lt;/code&gt; 的参数 &lt;code&gt;domain/2&lt;/code&gt; 通过添加过滤器时指定的函数 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52e94c11f02389a5bccbbedf86c2e899b3c665d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraArgument&lt;/code&gt; parameter is the empty list. For example, when the agent receives a get-request for the &lt;code&gt;ipAdr&lt;/code&gt; variable, a call will be made to &lt;code&gt;ip_access(get)&lt;/code&gt;. The value returned by this function is the answer to the get-request.</source>
          <target state="translated">该 &lt;code&gt;ExtraArgument&lt;/code&gt; 参数为空表。例如，当代理收到对 &lt;code&gt;ipAdr&lt;/code&gt; 变量的get-request时，将调用 &lt;code&gt;ip_access(get)&lt;/code&gt; 。此函数返回的值是get-request的答案。</target>
        </trans-unit>
        <trans-unit id="fb7a37656b5be6c6e17b2389894ea550dae8ed86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on from the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;ExtraInfo&lt;/code&gt; 参数从传递 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="f30e53e02c0d2cd4e451fab992fbc868cf17c42e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraInfo&lt;/code&gt; argument is passed on to the callback functions of the &lt;code&gt;DiscoHandler&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ExtraInfo&lt;/code&gt; 参数传递到的回调函数 &lt;code&gt;DiscoHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="289abc6fff4535554475e47566270dcbf6237037" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Freeze&lt;/code&gt; button starts/stops the redrawing of the graph. &lt;code&gt;Reset&lt;/code&gt; moves the graph to the middle of the window and resets all graph settings to default, with the exception of deleted nodes.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Freeze&lt;/code&gt; 按钮开始/停止图形的重绘。 &lt;code&gt;Reset&lt;/code&gt; 将图形移至窗口的中间，并将所有图形设置重置为默认值，但删除的节点除外。</target>
        </trans-unit>
        <trans-unit id="bb27036c1560c4a25ff7bd106092a75ea724c349" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is called when the tar function wants to do a low-level operation, like writing a block to a file. The &lt;code&gt;Fun&lt;/code&gt; is called as &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is the operation name, &lt;code&gt;UserPrivate&lt;/code&gt; is the term passed as the first argument to &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;Parameters...&lt;/code&gt; are the data added by the tar function to be passed down to the storage handling function.</source>
          <target state="translated">该 &lt;code&gt;Fun&lt;/code&gt; 被称为当焦油功能想要做一个低级别的操作，就像写一个块到一个文件中。的 &lt;code&gt;Fun&lt;/code&gt; 称为 &lt;code&gt;Fun(Op, {UserPrivate,Parameters...})&lt;/code&gt; ，其中， &lt;code&gt;Op&lt;/code&gt; 是操作名称， &lt;code&gt;UserPrivate&lt;/code&gt; 是作为第一个参数，以传递的术语 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;Parameters...&lt;/code&gt; 在数据通过所添加的tar函数将传递给存储处理函数。</target>
        </trans-unit>
        <trans-unit id="5d186993003ed1ccd81976e2681cc3264ce79a2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; is the definition of what to do when the different storage operations functions are to be called from the higher tar handling functions (such as &lt;code&gt;add/3&lt;/code&gt;, &lt;code&gt;add/4&lt;/code&gt;, and &lt;code&gt;close/1&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;Fun&lt;/code&gt; 是当不同的存储操作功能是从更高的焦油处理函数调用做什么的定义（如 &lt;code&gt;add/3&lt;/code&gt; ， &lt;code&gt;add/4&lt;/code&gt; ，和 &lt;code&gt;close/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ca0ec970a34ee33c7f128926a1e15f48a39b7957" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;foldl/3&lt;/code&gt; returns the final accumulator value. &lt;code&gt;Acc0&lt;/code&gt; is returned if the archive is empty. It is not necessary to iterate over all files in the archive. The iteration can be ended prematurely in a controlled manner by throwing an exception.</source>
          <target state="translated">该 &lt;code&gt;Fun&lt;/code&gt; 必须返回一个新的累加器，这是传递给下一个电话。 &lt;code&gt;foldl/3&lt;/code&gt; 返回最终的累加器值。如果存档为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。不必遍历存档中的所有文件。可以通过引发异常以受控的方式提前结束迭代。</target>
        </trans-unit>
        <trans-unit id="387a945d1ef3c3c3d8058c83966af63af2d4d8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt; section can also contain logic and arithmetic operations, which are written with the same syntax as the guard tests (prefix notation), so that the following guard test written in Erlang:</source>
          <target state="translated">该 &lt;code&gt;Guard&lt;/code&gt; 部还可以包含逻辑和算术运算，其被写入与相同的语法作为保护测试（前缀符号），所以下面的后卫测试Erlang编写：</target>
        </trans-unit>
        <trans-unit id="0ed2562e6fd2d312da06422aef22e77ebef5ba9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Guard&lt;/code&gt;s are constructed as tuples, where the first element is the test name and the remaining elements are the test parameters. To check for a specific type (say a list) of the element bound to the match variable &lt;code&gt;'$1'&lt;/code&gt;, one would write the test as &lt;code&gt;{is_list, '$1'}&lt;/code&gt;. If the test fails, the object in the table does not match and the next &lt;code&gt;MatchFunction&lt;/code&gt; (if any) is tried. Most guard tests present in Erlang can be used, but only the new versions prefixed &lt;code&gt;is_&lt;/code&gt; are allowed (&lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_atom&lt;/code&gt;, and so on).</source>
          <target state="translated">的 &lt;code&gt;Guard&lt;/code&gt; s的构造为元组，其中所述第一元件是所述测试名称和其余元件的测试参数。要检查绑定到匹配变量 &lt;code&gt;'$1'&lt;/code&gt; 的元素的特定类型（例如列表），可以将测试写为 &lt;code&gt;{is_list, '$1'}&lt;/code&gt; 。如果测试失败，则表中的对象不匹配，并尝试下一个 &lt;code&gt;MatchFunction&lt;/code&gt; （如果有）。目前在二郎大多数后卫的测试可以使用，但只有新版本的前缀 &lt;code&gt;is_&lt;/code&gt; 允许（ &lt;code&gt;is_float&lt;/code&gt; ， &lt;code&gt;is_atom&lt;/code&gt; ，等等）。</target>
        </trans-unit>
        <trans-unit id="3de2a50d3651924af28c65d29b6c75e407eb8165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HTTP&lt;/code&gt; version of the request, that is, &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot;, or &quot;HTTP/1.1&quot;.</source>
          <target state="translated">请求的 &lt;code&gt;HTTP&lt;/code&gt; 版本，即&amp;ldquo; HTTP / 0.9&amp;rdquo;，&amp;ldquo; HTTP / 1.0&amp;rdquo;或&amp;ldquo; HTTP / 1.1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="462a5eb6a4e1b7237b73c6e94eed8c647d921612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HostName&lt;/code&gt; will also be used in the hostname verification of the peer certificate using &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;HostName&lt;/code&gt; 也将在对等证书的主机名验证使用与用于 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fe5414d8d8a859939f8d4935fe18c2a11ba8b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Id&lt;/code&gt; identifies a CTH instance uniquely. If two CTHs return the same &lt;code&gt;Id&lt;/code&gt;, the second CTH is ignored and subsequent calls to the CTH are only made to the first instance. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">该 &lt;code&gt;Id&lt;/code&gt; 唯一标识一个CTH实例。如果两个CTH返回相同的 &lt;code&gt;Id&lt;/code&gt; ，则将忽略第二个CTH，并且仅对第一个实例进行对CTH的后续调用。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Installing a CTH&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="c260809e9afd9c349ba39adc0e706099bd4227f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InclNodes&lt;/code&gt; argument to &lt;code&gt;run/3&lt;/code&gt; is a list of node names. Function &lt;code&gt;run/3&lt;/code&gt; runs the tests in &lt;code&gt;TestSpecs&lt;/code&gt; just like &lt;code&gt;run/1&lt;/code&gt;, but also takes any test in &lt;code&gt;TestSpecs&lt;/code&gt;, which is not explicitly tagged with a particular node name, and execute it on the nodes listed in &lt;code&gt;InclNodes&lt;/code&gt;. By using &lt;code&gt;run/3&lt;/code&gt; this way, any test specification can be used, with or without node information, in a large-scale test environment.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 的 &lt;code&gt;InclNodes&lt;/code&gt; 参数是节点名称的列表。函数 &lt;code&gt;run/3&lt;/code&gt; 与 &lt;code&gt;run/1&lt;/code&gt; 一样在 &lt;code&gt;TestSpecs&lt;/code&gt; 中运行测试，但也可以在 &lt;code&gt;TestSpecs&lt;/code&gt; 中进行任何未显式标记有特定节点名称的测试，并在 &lt;code&gt;InclNodes&lt;/code&gt; 中列出的节点上执行该测试。通过以这种方式使用 &lt;code&gt;run/3&lt;/code&gt; ，可以在大规模测试环境中使用任何测试规范，无论有无节点信息。</target>
        </trans-unit>
        <trans-unit id="728f2fde5e1be51dec6dbadf7fd8bb23ae8a8436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InfoTuple&lt;/code&gt;s with the following items are part of the result:</source>
          <target state="translated">具有以下各项的 &lt;code&gt;InfoTuple&lt;/code&gt; 属于结果的一部分：</target>
        </trans-unit>
        <trans-unit id="18a616360c14e89869b3ee8a191e8982efcb7c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InitFun&lt;/code&gt; is applied once prior to any other &lt;code&gt;crypto&lt;/code&gt; operation. The returned &lt;code&gt;CryptoState&lt;/code&gt; is then folded into repeated applications of the &lt;code&gt;EncryptFun&lt;/code&gt; or &lt;code&gt;DecryptFun&lt;/code&gt;. The binary returned from those funs are sent further to the remote SFTP server. Finally, if doing encryption, the &lt;code&gt;CloseFun&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;CloseFun&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">所述 &lt;code&gt;InitFun&lt;/code&gt; 被任何其他施加一次现有 &lt;code&gt;crypto&lt;/code&gt; 操作。然后将返回的 &lt;code&gt;CryptoState&lt;/code&gt; 折叠到 &lt;code&gt;EncryptFun&lt;/code&gt; 或 &lt;code&gt;DecryptFun&lt;/code&gt; 的重复应用程序中。这些功能返回的二进制文件将进一步发送到远程SFTP服务器。最后，如果进行加密，则将 &lt;code&gt;CloseFun&lt;/code&gt; 应用于最后一块数据。所述 &lt;code&gt;CloseFun&lt;/code&gt; 负责填充（如果需要）并加密该最后一块。</target>
        </trans-unit>
        <trans-unit id="f831068a66059cf58bd10807a62c5026adc8c387" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">该 &lt;code&gt;Install&lt;/code&gt; 脚本应该当前被调用为它驻留（顶层目录）的目录如下：</target>
        </trans-unit>
        <trans-unit id="151c25d0c87229840b1a357c4265bc6b194406ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Install&lt;/code&gt; script used when installing Erlang/OTP requires common Unix tools such as &lt;code&gt;sed&lt;/code&gt; to be present in your &lt;code&gt;$PATH&lt;/code&gt;. If your target system does not have such tools, you need to run the &lt;code&gt;Install&lt;/code&gt; script on your build machine before packaging Erlang/OTP. The &lt;code&gt;Install&lt;/code&gt; script should currently be invoked as follows in the directory where it resides (the top directory):</source>
          <target state="translated">安装Erlang / OTP时使用的 &lt;code&gt;Install&lt;/code&gt; 脚本需要 &lt;code&gt;$PATH&lt;/code&gt; Unix 中存在的通用Unix工具，例如 &lt;code&gt;sed&lt;/code&gt; 。如果目标系统没有这样的工具，则在打包Erlang / OTP之前，需要在构建计算机上运行 &lt;code&gt;Install&lt;/code&gt; 脚本。该 &lt;code&gt;Install&lt;/code&gt; 脚本应该当前被调用为它驻留（顶层目录）的目录如下：</target>
        </trans-unit>
        <trans-unit id="63ceadf10aefd8db61da0846c16f50dd4c57bf68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Issuer&lt;/code&gt; argument contains the issuer name of the certificate to be checked. Normally the returned CRL should be issued by this issuer, except if the &lt;code&gt;cRLIssuer&lt;/code&gt; field of &lt;code&gt;DistributionPoint&lt;/code&gt; has a value, in which case that value should be used instead.</source>
          <target state="translated">该 &lt;code&gt;Issuer&lt;/code&gt; 参数包含要检查的证书的颁发者的名字。通常，返回的CRL应该由此发行者发行，除非 &lt;code&gt;DistributionPoint&lt;/code&gt; 的 &lt;code&gt;cRLIssuer&lt;/code&gt; 字段具有值，在这种情况下，应使用该值代替。</target>
        </trans-unit>
        <trans-unit id="1df86fa6a13d4782f56f4b70368193619f74ccce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JCL&lt;/code&gt; commands have the following meaning:</source>
          <target state="translated">该 &lt;code&gt;JCL&lt;/code&gt; 命令的含义如下：</target>
        </trans-unit>
        <trans-unit id="eb0d6b265bbd8a2ede63c784c4e76e0b9b25a09c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANG&lt;/code&gt; or &lt;code&gt;LC_CTYPE&lt;/code&gt; setting are to be consistent with what the terminal is capable of. There is no portable way for Erlang to ask the terminal about its UTF-8 capacity, we have to rely on the language and character type settings.</source>
          <target state="translated">该 &lt;code&gt;LANG&lt;/code&gt; 或 &lt;code&gt;LC_CTYPE&lt;/code&gt; 设置要与什么终端能够保持一致。Erlang没有可移植的方式向终端询问其UTF-8容量，我们必须依靠语言和字符类型设置。</target>
        </trans-unit>
        <trans-unit id="6dcd5eb8b8d30040b44118c19bb40f40ac2fd675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lin&lt;/code&gt; (&lt;code&gt;LLin&lt;/code&gt;, &lt;code&gt;XLin&lt;/code&gt;) operator assigns the lines where calls (local calls, external calls) are made. The &lt;code&gt;ELin&lt;/code&gt; operator assigns to each call (From, To), for which it is defined, every line L such that there is a chain of calls from From to To beginning with a call on line L.</source>
          <target state="translated">该 &lt;code&gt;Lin&lt;/code&gt; （ &lt;code&gt;LLin&lt;/code&gt; ， &lt;code&gt;XLin&lt;/code&gt; ）运算符受让人，其中电话（拨打本地电话，外线电话）制成的线。所述 &lt;code&gt;ELin&lt;/code&gt; 操作者分配给每个呼叫（从，到），它被定义为其中，每个线L，使得在调用链从从到要与线L的呼叫开始</target>
        </trans-unit>
        <trans-unit id="ddd6ecd801eba0297210dd779a386d2f9b34f307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ListOfExtraArguments&lt;/code&gt; can be used to write generic functions. This list is appended to the standard arguments for each function. Consider two read-only variables for a device, &lt;code&gt;ipAdr&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; with object identifiers 1.1.23.4 and 1.1.7 respectively. To access these variables, one could implement the two Erlang functions &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt;, which will be in the MIB. The functions could be specified in a text file as follows:</source>
          <target state="translated">该 &lt;code&gt;ListOfExtraArguments&lt;/code&gt; 可用于编写通用的功能。该列表被附加到每个函数的标准参数中。考虑设备的两个只读变量 &lt;code&gt;ipAdr&lt;/code&gt; 和 &lt;code&gt;name&lt;/code&gt; ，分别具有对象标识符1.1.23.4和1.1.7。要访问这些变量，可以实现两个Erlang函数 &lt;code&gt;ip_access&lt;/code&gt; 和 &lt;code&gt;name_access&lt;/code&gt; ，它们将在MIB中。可以在文本文件中指定功能，如下所示：</target>
        </trans-unit>
        <trans-unit id="e1503197789ab51916ae2782b9a6115c1230e790" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; argument will be the same as the &lt;code&gt;Listen&lt;/code&gt; handle part of the return value of the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback above. &lt;code&gt;accept/1&lt;/code&gt; is called only once when the distribution protocol is started.</source>
          <target state="translated">在 &lt;code&gt;Listen&lt;/code&gt; 的说法将是一样的 &lt;code&gt;Listen&lt;/code&gt; 的返回值的手柄部分 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 回调以上。启动分发协议时， &lt;code&gt;accept/1&lt;/code&gt; 仅被调用一次。</target>
        </trans-unit>
        <trans-unit id="431a15a498450f82a9cfae588ffa70427314b380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LoadOrder&lt;/code&gt; priority is by default &lt;code&gt;0&lt;/code&gt; (zero) but can be set to any integer. The tables with the highest &lt;code&gt;LoadOrder&lt;/code&gt; priority are loaded first at startup.</source>
          <target state="translated">默认情况下， &lt;code&gt;LoadOrder&lt;/code&gt; 优先级为 &lt;code&gt;0&lt;/code&gt; （零），但可以设置为任何整数。具有最高 &lt;code&gt;LoadOrder&lt;/code&gt; 优先级的表将在启动时首先加载。</target>
        </trans-unit>
        <trans-unit id="6ca1036527f7b7c9ab7ab8a36cae20db5fe67ec0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; configuration was as follows:</source>
          <target state="translated">的 &lt;code&gt;MEDIA-GATEWAY-CONTROL&lt;/code&gt; 配置如下：</target>
        </trans-unit>
        <trans-unit id="d517f2a191b0a2929a426e74c5d9977a2a92791e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MIB.Object&lt;/code&gt; syntax is not implemented (since all objects must be unique anyway).</source>
          <target state="translated">该 &lt;code&gt;MIB.Object&lt;/code&gt; 语法未实现（因为所有的对象都必须是唯一反正）。</target>
        </trans-unit>
        <trans-unit id="636dca28dbd87863b36f206b257464a2e654c483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Max Carrier size&lt;/code&gt; column shows the maximum value seen by observer since the last node change or since the start of the application, i.e. switching nodes will reset the max column. Values are sampled so higher values may have existed than what is shown.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Max Carrier size&lt;/code&gt; 列显示观察者自上次节点更改或自应用程序启动以来看到的最大值，即交换节点将重置最大列。对值进行了采样，因此可能存在比所示更高的值。</target>
        </trans-unit>
        <trans-unit id="cc6e05d560929a4a9cfa001cecdf62f1726f815c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; programmer cannot prioritize one particular transaction to execute before other transactions that are waiting to execute. As a result, the &lt;code&gt;Mnesia&lt;/code&gt; DBMS transaction system is not suitable for hard real-time applications. However, &lt;code&gt;Mnesia&lt;/code&gt; contains other features that have real-time properties.</source>
          <target state="translated">该 &lt;code&gt;Mnesia&lt;/code&gt; 的程序员不能优先考虑一个特定的交易之前等待执行的其他交易中执行。结果， &lt;code&gt;Mnesia&lt;/code&gt; DBMS事务系统不适用于硬实时应用程序。但是， &lt;code&gt;Mnesia&lt;/code&gt; 包含其他具有实时属性的功能。</target>
        </trans-unit>
        <trans-unit id="2398df613eed0972c6702e33c30169f57db4a6c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; record identifiers (&lt;code&gt;{Tab, Key}&lt;/code&gt;) can also be used as references. In this case, attribute &lt;code&gt;dept&lt;/code&gt; would be set to value &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; instead of &lt;code&gt;'B/SFR'&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 的记录标识符（ &lt;code&gt;{Tab, Key}&lt;/code&gt; ）也可以用作参考。在这种情况下，属性 &lt;code&gt;dept&lt;/code&gt; 将设置为 &lt;code&gt;{dept, 'B/SFR'}&lt;/code&gt; 而不是 &lt;code&gt;'B/SFR'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90246ca10a3686ec4547ee9155bf07c76827f547" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transaction system facilitates the construction of reliable, distributed systems by providing the following important properties:</source>
          <target state="translated">该 &lt;code&gt;Mnesia&lt;/code&gt; 的交易系统提供以下重要特性来方便可靠，分布式系统的建设：</target>
        </trans-unit>
        <trans-unit id="05c05e9d6716d8728951521a8360d9cad3bf485c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Mnesia&lt;/code&gt; transactions have four important properties, called &lt;strong&gt;A&lt;/strong&gt;tomicity, &lt;strong&gt;C&lt;/strong&gt;onsistency, &lt;strong&gt;I&lt;/strong&gt;solation, and &lt;strong&gt;D&lt;/strong&gt;urability (ACID). These properties are described in the following sections.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 的事务有四大特性，被称为&lt;strong&gt;一个&lt;/strong&gt; tomicity，&lt;strong&gt;&amp;Ccedil;&lt;/strong&gt; onsistency，&lt;strong&gt;我&lt;/strong&gt;染料溶液，和&lt;strong&gt;d&lt;/strong&gt; urability（ACID）。这些属性在以下各节中描述。</target>
        </trans-unit>
        <trans-unit id="34969f65d94bd140bef4861a2be0633f1edd4059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Module:callback_mode()&lt;/code&gt; function may also return a list containing the callback mode and the atom &lt;code&gt;state_enter&lt;/code&gt; in which case &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; are activated for the callback mode.</source>
          <target state="translated">的 &lt;code&gt;Module:callback_mode()&lt;/code&gt; 函数也可以返回包含该回调模式和原子的列表 &lt;code&gt;state_enter&lt;/code&gt; 在这种情况下， &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;State Enter Calls&lt;/a&gt;&lt;/code&gt; 被回调模式激活。</target>
        </trans-unit>
        <trans-unit id="40a0e269f3ccc50144dceff290b7ec1e5d3d30c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">该 &lt;code&gt;Msg&lt;/code&gt; 或者是二进制的&amp;ldquo;明文&amp;rdquo;的数据，或者它是&amp;ldquo;纯文本&amp;rdquo;，的散列值即，消化。</target>
        </trans-unit>
        <trans-unit id="aa7575828f011f723e11b39b2169db4b9db4b1aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Msg&lt;/code&gt; is either the binary &quot;plain text&quot; data to be signed or it is the hashed value of &quot;plain text&quot;, that is, the digest.</source>
          <target state="translated">该 &lt;code&gt;Msg&lt;/code&gt; 或者是二进制的&amp;ldquo;明文&amp;rdquo;的数据进行签名，或者它是&amp;ldquo;纯文本&amp;rdquo;，的散列值即，消化。</target>
        </trans-unit>
        <trans-unit id="caed8c29d6ad9904a92815ee1e45441de9aec981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; parameters have exactly the same meaning as when calling the plain function &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 参数具有完全相同的含义调用纯函数时，作为同一 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27916491cb8658a94525ccdce76cf8ccb4103b9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; field is the first element of the tuple.</source>
          <target state="translated">该 &lt;code&gt;Name&lt;/code&gt; 字段是元组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="3ca819160319b409a2f4c421438e5784e6c81c13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Name&lt;/code&gt; specified is to correspond to the filename of the dynamically loadable object file residing in the directory specified as &lt;code&gt;Path&lt;/code&gt;, but &lt;strong&gt;without&lt;/strong&gt; the extension (that is, &lt;code&gt;.so&lt;/code&gt;). The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as Erlang module names correspond to the names of the &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">指定的 &lt;code&gt;Name&lt;/code&gt; 对应于驻留在指定为 &lt;code&gt;Path&lt;/code&gt; 的目录中的动态可加载目标文件的文件名，但&lt;strong&gt;没有&lt;/strong&gt;扩展名（即 &lt;code&gt;.so&lt;/code&gt; ）。驱动程序初始化例程中提供的驱动程序名称必须与文件名相对应，与Erlang模块名称与 &lt;code&gt;.beam&lt;/code&gt; 文件的名称相对应的方式几乎相同。</target>
        </trans-unit>
        <trans-unit id="a8577668ea7b4d3a7d25c6ddf13c9da38e01e030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegotiationTimeout&lt;/code&gt; is in milli-seconds. The default value is &lt;code&gt;infinity&lt;/code&gt;. For connection timeout, use the option &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;NegotiationTimeout&lt;/code&gt; 是毫秒。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。对于连接超时，请使用选项 &lt;code&gt;&lt;a href=&quot;#type-connect_timeout_client_option&quot;&gt;connect_timeout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25cf803e685b877b848b6e92d88b9c3e6c3210a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; is an important type and it is widely used within different standards to identify various objects uniquely. Dubuisson: ASN.1 - Communication Between Heterogeneous Systems includes an easy-to-understand description of the use of &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 是一个重要的类型和它被广泛不同的标准中用于唯一地标识各个对象。Dubuisson：ASN.1-异构系统之间的通信包括对目标 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 的使用的易于理解的描述。</target>
        </trans-unit>
        <trans-unit id="d89a49f90db529d1a87ec8ebe643fd609dd3d3b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; value is simply a tuple with the consecutive values, which must be integers.</source>
          <target state="translated">的 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 值是简单地与连续值，它必须是整数的元组。</target>
        </trans-unit>
        <trans-unit id="291813bf4581fd45b017cff8a605850835e5740d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Operation&lt;/code&gt; 可以是 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;undo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0de93bd973f344208a44803393d2336ed72a592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; can be &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Operation&lt;/code&gt; 可以是 &lt;code&gt;new&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;is_set_ok&lt;/code&gt; ， &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c435f50eeeff168b9ba4f24d7c44a547a62546d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Opts&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; when only the &lt;code&gt;Module&lt;/code&gt; is specified.</source>
          <target state="translated">所述 &lt;code&gt;Opts&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 当只有 &lt;code&gt;Module&lt;/code&gt; 中指定。</target>
        </trans-unit>
        <trans-unit id="fb29cec4d8746b25b30ed76f21784b67fd7d4bbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Phone&lt;/code&gt; field is the third element.</source>
          <target state="translated">在 &lt;code&gt;Phone&lt;/code&gt; 领域是第三个元素。</target>
        </trans-unit>
        <trans-unit id="9a36c74c23cadea74c3943787187639b86600b99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pid&lt;/code&gt; is the process handling the supervision of the SNMP manager start. When the manager has started a completion message will be sent to the client from this process: &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt;. If the SNMP manager was not started in time, a timeout message will be sent to the client: &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Pid&lt;/code&gt; 是搬运过程SNMP管理器启动的监督。经理启动后，将通过以下过程将完成消息发送给客户端： &lt;code&gt;{snmpm_started, Pid}&lt;/code&gt; 。如果SNMP管理器未及时启动，则会向客户端发送超时消息： &lt;code&gt;{snmpm_start_timeout, Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad1ec7b826ce17efed8a480d14fb2c2d7c83c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ProtocolVersion&lt;/code&gt; version is the version actually encoded in the reply message.</source>
          <target state="translated">该 &lt;code&gt;ProtocolVersion&lt;/code&gt; 版本是在回复消息实际编码的版本。</target>
        </trans-unit>
        <trans-unit id="cc15bf57b674de665a3aa4e09be58f12e93f6528" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RELATIVE-OID&lt;/code&gt; type for relative object identifiers is fully supported.</source>
          <target state="translated">完全支持相对对象标识符的 &lt;code&gt;RELATIVE-OID&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="500392beab058916677f3be61233265c489d27bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; parameter in the &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; user callback function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmpm_user#handle_error&quot;&gt;handle_error&lt;/a&gt;&lt;/code&gt; 用户回调函数中的 &lt;code&gt;Reason&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="6b9fce90dd7e0310098f64ad13d29f2262c2551d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reason&lt;/code&gt; returned value if any of the sync/async get/get-next/set/get-bulk functions returns &lt;code&gt;{error, Reason}&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;Reason&lt;/code&gt; 返回的值是否有任何同步/异步获取/ GET-下一个/组/取块函数返回 &lt;code&gt;{error, Reason}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1adaa6337c0136bccefb9d645f47ac7a3dea29f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReplyData&lt;/code&gt; defaults to &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt;, but may be explicitly overridden by a &lt;code&gt;megaco:cast/3&lt;/code&gt; option in order to forward info about the calling context of the originating process.</source>
          <target state="translated">该 &lt;code&gt;ReplyData&lt;/code&gt; 默认为 &lt;code&gt;megaco:lookup(ConnHandle, reply_data)&lt;/code&gt; ，但可以通过显式覆盖 &lt;code&gt;megaco:cast/3&lt;/code&gt; 选项以约始发过程的调用上下文向前信息。</target>
        </trans-unit>
        <trans-unit id="5dcd8c369c6500e932ff1e1629f6fafbdc39108e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-Line&lt;/code&gt; as defined in&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;Request-Line&lt;/code&gt; ，例如 &lt;code&gt;&quot;GET /cgi-bin/find.pl?person=jocke HTTP/1.0&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="560f996f8e0b32b35d673e574bfba7c7f5732599" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request-URI&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1945.txt&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;Request-URI&lt;/code&gt; ，例如 &lt;code&gt;&quot;/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cc862e08384f6496c068b1ef00d8543bcd2fea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Request&lt;/code&gt; element can in itself contain many &lt;code&gt;Request&lt;/code&gt;s by using the following format:</source>
          <target state="translated">通过使用以下格式， &lt;code&gt;Request&lt;/code&gt; 元素本身可以包含许多 &lt;code&gt;Request&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df3736ae6d527f6dc758c7bc44a6f372a5715a61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Root directory&lt;/code&gt; can be edited by selecting the line where the path of the root directory is displayed and clicking the right mouse button. Choose edit in the menu that pops up.</source>
          <target state="translated">的 &lt;code&gt;Root directory&lt;/code&gt; 可以通过选择在显示的根目录的路径的线并点击鼠标右键进行编辑。在弹出的菜单中选择&amp;ldquo;编辑&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="84770d839ef4e410e85af06b8af1e00bd08e41e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RowIndex&lt;/code&gt; argument may refer to an existing row or a non-existing row, or it may be unspecified. The &lt;code&gt;Cols&lt;/code&gt; list may refer to inaccessible columns or non-existing columns. For each column in the &lt;code&gt;Cols&lt;/code&gt; list, the corresponding next instance is determined, and the last part of its OBJECT IDENTIFIER and its value is returned.</source>
          <target state="translated">所述 &lt;code&gt;RowIndex&lt;/code&gt; 参数可以是指现有的行或不存在的行，或它可以是未指定的。该 &lt;code&gt;Cols&lt;/code&gt; 列表可参考不可访问的列或不存在的柱。对于 &lt;code&gt;Cols&lt;/code&gt; 列表中的每一列，都会确定相应的下一个实例，并返回其对象标识符的最后一部分及其值。</target>
        </trans-unit>
        <trans-unit id="b8d86bbb9ebe74c2dccf692588c950366f9986be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SecurityCallbackModule&lt;/code&gt; is a user-written module that can receive events from the &lt;code&gt;mod_security&lt;/code&gt; Erlang web server API module. This module only exports the functions event/[4,5] which are described here.</source>
          <target state="translated">该 &lt;code&gt;SecurityCallbackModule&lt;/code&gt; 是可以接收来自事件的用户编写的模块 &lt;code&gt;mod_security&lt;/code&gt; 的二郎山Web服务器API模块。该模块仅导出此处描述的功能event / [4,5]。</target>
        </trans-unit>
        <trans-unit id="6af65a9600faa054b3af4ac9bf04b32c2eda0702" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SeqCnt&lt;/code&gt; values in the filenames are all in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;WrapCnt&lt;/code&gt; with a gap in the circular sequence. The gap is needed to find the end of the trace.</source>
          <target state="translated">文件名中的 &lt;code&gt;SeqCnt&lt;/code&gt; 值都在 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;WrapCnt&lt;/code&gt; 的范围内，循环序列中有一个间隔。需要间隙来找到轨迹的末端。</target>
        </trans-unit>
        <trans-unit id="c2214d4ed634c1087714e34b7518b2efdc6127b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; or the &lt;code&gt;TypeSpecifier&lt;/code&gt;, or both, can be omitted. Thus, the following variants are allowed:</source>
          <target state="translated">在 &lt;code&gt;Size&lt;/code&gt; 或 &lt;code&gt;TypeSpecifier&lt;/code&gt; ，或两者，可以省略。因此，允许以下变体：</target>
        </trans-unit>
        <trans-unit id="4401af203194a6b8a2b7ece91e21c535b2bfb4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; part of the segment multiplied by the unit in &lt;code&gt;TypeSpecifierList&lt;/code&gt; (described later) gives the number of bits for the segment. In construction, &lt;code&gt;Size&lt;/code&gt; is any expression that evaluates to an integer. In matching, &lt;code&gt;Size&lt;/code&gt; must be a constant expression or a variable.</source>
          <target state="translated">段的 &lt;code&gt;Size&lt;/code&gt; 部分乘以 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 中的单位（稍后描述）可得出该段的位数。在构造中， &lt;code&gt;Size&lt;/code&gt; 是任何计算结果为整数的表达式。在匹配中， &lt;code&gt;Size&lt;/code&gt; 必须是常量表达式或变量。</target>
        </trans-unit>
        <trans-unit id="fa124ccd13ea8b5e4811fb40dda4e89bf8e0ab6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Socket&lt;/code&gt; shall be in passive mode ({active, false}) before calling this function or else the behavior of this function is undefined.</source>
          <target state="translated">该 &lt;code&gt;Socket&lt;/code&gt; 应在调用这个函数，否则这个函数的行为是未定义之前处于被动模式（{活跃，假}）。</target>
        </trans-unit>
        <trans-unit id="7eae7e5127eb1df08b89e0018b0917cb18f30c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SupFlags&lt;/code&gt; variable in the return value from &lt;code&gt;init/1&lt;/code&gt; represents the &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init/1&lt;/code&gt; 返回值中的 &lt;code&gt;SupFlags&lt;/code&gt; 变量表示 &lt;code&gt;&lt;a href=&quot;#flags&quot;&gt;supervisor flags&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b2315a984f49c0998e8d5af6001ef3acd45c41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TEST&lt;/code&gt; macro can also be used to override the &lt;code&gt;NOTEST&lt;/code&gt; macro. If &lt;code&gt;TEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included (even if &lt;code&gt;NOTEST&lt;/code&gt; is also defined), then the code will be compiled with EUnit enabled.</source>
          <target state="translated">该 &lt;code&gt;TEST&lt;/code&gt; 宏还可以用来覆盖 &lt;code&gt;NOTEST&lt;/code&gt; 宏。如果&lt;strong&gt;在&lt;/strong&gt;包含EUnit头文件&lt;strong&gt;之前&lt;/strong&gt;定义了 &lt;code&gt;TEST&lt;/code&gt; （即使还定义了 &lt;code&gt;NOTEST&lt;/code&gt; ），则将在启用EUnit的情况下编译代码。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="838665ed4c5367a2b5c2a4be4ad60949587a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module.</source>
          <target state="translated">该 &lt;code&gt;TarDescriptor&lt;/code&gt; 项不是文件描述符。建议您不要依赖此术语的具体内容，因为当向该模块添加更多功能时，它可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="465bc37c25caf4b34efb2c4086ab264294ebb922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TarDescriptor&lt;/code&gt; term is not a file descriptor. You are advised not to rely on the specific contents of this term, as it can change in future Erlang/OTP releases when more features are added to this module..</source>
          <target state="translated">该 &lt;code&gt;TarDescriptor&lt;/code&gt; 项不是文件描述符。建议您不要依赖此术语的具体内容，因为当向该模块添加更多功能时，它可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="0454f0125983aa193be8922f905a4526ad0af9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; is the time the request is valid. The value has to be greater then zero.</source>
          <target state="translated">该 &lt;code&gt;Timeout&lt;/code&gt; 是请求有效的时间。该值必须大于零。</target>
        </trans-unit>
        <trans-unit id="7d17ac7ee8e9756a5bbf3de834214c031df9a61a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Timeout&lt;/code&gt; parameter is for the actual tls upgrade (phase 2) while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for the initial negotiation about upgrade (phase 1).</source>
          <target state="translated">的 &lt;code&gt;Timeout&lt;/code&gt; 参数是实际的TLS升级而在超时（阶段2） &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 被用于有关升级（阶段1）在初始协商。</target>
        </trans-unit>
        <trans-unit id="7e76487200ab118ffd183bce3e76d073d0b42eca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Trace Pattern&lt;/code&gt; is basically a tuple of a &lt;code&gt;module&lt;/code&gt; and a &lt;code&gt;detail level&lt;/code&gt; (either an integer or the atom max for full detail). In most cases the &lt;code&gt;Trace Pattern&lt;/code&gt;&lt;code&gt;{et,max}&lt;/code&gt; does suffice. But if you do not want any runtime dependency of &lt;code&gt;et&lt;/code&gt; you can implement your own &lt;code&gt;trace_me/5&lt;/code&gt; function in some module and refer to that module in the &lt;code&gt;Trace Pattern&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Trace Pattern&lt;/code&gt; 基本上是一个元组 &lt;code&gt;module&lt;/code&gt; 和 &lt;code&gt;detail level&lt;/code&gt; （整数或原子最大为全部细节）。在大多数情况下， &lt;code&gt;Trace Pattern&lt;/code&gt; &lt;code&gt;{et,max}&lt;/code&gt; 就足够了。但是，如果您不希望 &lt;code&gt;et&lt;/code&gt; 的任何运行时依赖性，则可以在某个模块中实现自己的 &lt;code&gt;trace_me/5&lt;/code&gt; 函数，并在&amp;ldquo; &lt;code&gt;Trace Pattern&lt;/code&gt; 引用该模块。</target>
        </trans-unit>
        <trans-unit id="c7f49e5bd7c0b07a911f5147dffd68a5a99e4dbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceStartOption&lt;/code&gt; is any option allowed for &lt;code&gt;trace/1&lt;/code&gt;. The options &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; are given to &lt;code&gt;trace/1&lt;/code&gt;, where &lt;code&gt;OptList&lt;/code&gt; is &lt;code&gt;OptionList&lt;/code&gt; with &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;{procs, _}&lt;/code&gt; options removed.</source>
          <target state="translated">该 &lt;code&gt;TraceStartOption&lt;/code&gt; 是允许任何选项 &lt;code&gt;trace/1&lt;/code&gt; 。选项 &lt;code&gt;[start, {procs, [self() | PidList]} | OptList]&lt;/code&gt; 分配给 &lt;code&gt;trace/1&lt;/code&gt; ，其中 &lt;code&gt;OptList&lt;/code&gt; 是 &lt;code&gt;OptionList&lt;/code&gt; ，其中删除了 &lt;code&gt;continue&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;{procs, _}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d2aed641ea18d80129eeabfddfeb6dc4dea97713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TraceTag&lt;/code&gt;&lt;code&gt;seq_trace&lt;/code&gt; is handled slightly differently. There is no &lt;code&gt;Tracee&lt;/code&gt; for &lt;code&gt;seq_trace&lt;/code&gt;, instead the &lt;code&gt;Label&lt;/code&gt; associated with the &lt;code&gt;seq_trace&lt;/code&gt; event is specified.</source>
          <target state="translated">该 &lt;code&gt;TraceTag&lt;/code&gt; &lt;code&gt;seq_trace&lt;/code&gt; 略有不同的处理。没有 &lt;code&gt;Tracee&lt;/code&gt; 对 &lt;code&gt;seq_trace&lt;/code&gt; ，而不是 &lt;code&gt;Label&lt;/code&gt; 与相关 &lt;code&gt;seq_trace&lt;/code&gt; 指定事件。</target>
        </trans-unit>
        <trans-unit id="0e7aee8b9587689f8640e087123cb9269b76c67d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeSpecifierList&lt;/code&gt; is a list of type specifiers separated by hyphens.</source>
          <target state="translated">该 &lt;code&gt;TypeSpecifierList&lt;/code&gt; 是用连字符隔开类型说明符的列表。</target>
        </trans-unit>
        <trans-unit id="cf30b67e2b9d6eefe96e2a44b56b701c3a71843b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Value&lt;/code&gt; part is any expression, when used in binary construction. Used in binary matching, the &lt;code&gt;Value&lt;/code&gt; part must be a literal or a variable. For more information about the &lt;code&gt;Value&lt;/code&gt; part, see &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当用于二进制构造时， &lt;code&gt;Value&lt;/code&gt; 部分是任何表达式。在二进制匹配中使用，&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 部分必须是文字或变量。有关&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 部分的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#Constructing%20Binaries%20and%20Bitstrings&quot;&gt;Constructing Binaries and Bitstrings&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;#Matching%20Binaries&quot;&gt;Matching Binaries&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db41e1083994609150ba03a58467ce1564f93559" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will automatically pull events from the &lt;code&gt;Collector&lt;/code&gt; and display them on the screen.</source>
          <target state="translated">该 &lt;code&gt;Viewer&lt;/code&gt; 将自动从拉事件 &lt;code&gt;Collector&lt;/code&gt; ，并在屏幕上显示出来。</target>
        </trans-unit>
        <trans-unit id="8afb3e18be8e7e2fb56c7adc4a8999ad88a05635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Viewer&lt;/code&gt; will by default create a &lt;code&gt;Collector&lt;/code&gt; for you. With a few options and some configuration settings you can start collecting &lt;code&gt;Events&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;Viewer&lt;/code&gt; 将为您创建一个 &lt;code&gt;Collector&lt;/code&gt; 。使用一些选项和一些配置设置，您可以开始收集 &lt;code&gt;Events&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12a1a53435b86d328cae136152477d1bdb078001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;XXL&lt;/code&gt; operator is defined for the interpretation of any of the LineOp operators applied to a set of function calls. The result is that of replacing the function call with a line numbered function call, that is, each of the two functions of the call is replaced by a pair of the function and the line where the function is defined. The effect of the &lt;code&gt;XXL&lt;/code&gt; operator can be undone by the LineOp operators. For instance, &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; is equivalent to &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;XXL&lt;/code&gt; 操作者对任何应用到一组函数调用LineOp运营商的解释定义。结果是用行编号的函数调用替换了函数调用，也就是说，该调用的两个函数中的每一个都被一对函数和定义函数的那一行替换。该效果 &lt;code&gt;XXL&lt;/code&gt; 运营商可以通过LineOp运营商百废待兴。例如， &lt;code&gt;(Lin)&amp;nbsp;(XXL)&amp;nbsp;(Lin)&amp;nbsp;E&lt;/code&gt; 等效于 &lt;code&gt;(Lin)&amp;nbsp;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="773f8eacbf90d517d7610d94842c0bab01a3934c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ZipHandle&lt;/code&gt; is closed if the process that originally opened the archive dies.</source>
          <target state="translated">该 &lt;code&gt;ZipHandle&lt;/code&gt; 如果过程最初打开存档模具被关闭。</target>
        </trans-unit>
        <trans-unit id="6a10f4396b335e787b9182ce75a8ccae749ae857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_test&lt;/code&gt; macro takes any expression (the &quot;body&quot;) as argument, and places it within a fun-expression (along with some extra information). The body can be any kind of test expression, just like the body of a simple test function.</source>
          <target state="translated">该 &lt;code&gt;_test&lt;/code&gt; 宏接受任何表情（以下简称&amp;ldquo;机构&amp;rdquo;）作为参数，和一个有趣的表达式中放置它（有一些额外的信息一起）。主体可以是任何类型的测试表达式，就像简单的测试函数的主体一样。</target>
        </trans-unit>
        <trans-unit id="21e2f2fedc48b32638d6fb2b72fe74559f091a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call does &lt;strong&gt;not&lt;/strong&gt; have to be issued from the socket owner process. Using version 5.5.3 and higher of the emulator, multiple simultaneous accept calls can be issued from different processes, which allows for a pool of acceptor processes handling incoming connections.</source>
          <target state="translated">在 &lt;code&gt;accept&lt;/code&gt; 电话并&lt;strong&gt;没有&lt;/strong&gt;必须从插座所有者进程发出。使用5.5.3版和更高版本的仿真器，可以从不同的进程发出多个同时的接受调用，从而允许一组处理传入连接的接受器进程。</target>
        </trans-unit>
        <trans-unit id="b97c48085c09e86337df00a4b0a18e9e9f983484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apread/4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;apread/4&lt;/code&gt; 功能从指定的位置读出，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#aread-3&quot;&gt;aread/3&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="6e1ba830557bf0975fcfe18ee483f0f3bec5d278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apwrite/4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;apwrite/4&lt;/code&gt; 函数写入到指定的位置，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#awrite-3&quot;&gt;awrite/3&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="00d3c3634428cbc77b5aceea9f983ec649758967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert&lt;/code&gt; macro can be used anywhere in a program, not just in unit tests, to check pre/postconditions and invariants. For example:</source>
          <target state="translated">该 &lt;code&gt;assert&lt;/code&gt; 宏可以在程序中使用的任何地方，不只是在单元测试，以检查前/后置条件和不变量。例如：</target>
        </trans-unit>
        <trans-unit id="108ceadd98496de12d8902f0058bac96f4aa9204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is passed to the &lt;code&gt;do_perm&lt;/code&gt; function. We do not use a &lt;code&gt;async_free&lt;/code&gt; function (the last argument to &lt;code&gt;driver_async&lt;/code&gt;), it is only used if the task is cancelled programmatically.</source>
          <target state="translated">该 &lt;code&gt;async_data&lt;/code&gt; 传递给 &lt;code&gt;do_perm&lt;/code&gt; 功能。我们不使用 &lt;code&gt;async_free&lt;/code&gt; 功能（最后一个参数 &lt;code&gt;driver_async&lt;/code&gt; ），它只是用来当任务以编程方式取消。</target>
        </trans-unit>
        <trans-unit id="4cd04a38dd6fcdc2cd251ae665b899f10977e42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_data&lt;/code&gt; is the argument to the functions &lt;code&gt;async_invoke&lt;/code&gt; and &lt;code&gt;async_free&lt;/code&gt;. It is typically a pointer to a structure containing a pipe or event that can be used to signal that the async operation completed. The data is to be freed in &lt;code&gt;async_free&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;async_data&lt;/code&gt; 是参数的功能 &lt;code&gt;async_invoke&lt;/code&gt; 和 &lt;code&gt;async_free&lt;/code&gt; 。它通常是指向包含管道或事件的结构的指针，该管道或事件可用于指示异步操作已完成。数据将在 &lt;code&gt;async_free&lt;/code&gt; 中释放。</target>
        </trans-unit>
        <trans-unit id="61c5f2724e8a89f933cb80bf3b2eb6cc8b3b6977" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;avg1/0&lt;/code&gt;, &lt;code&gt;avg5/0&lt;/code&gt;, and &lt;code&gt;avg15/0&lt;/code&gt; functions can be used for retrieving system load values, and the &lt;code&gt;util/0&lt;/code&gt; and &lt;code&gt;util/1&lt;/code&gt; functions can be used for retrieving CPU utilization values.</source>
          <target state="translated">所述 &lt;code&gt;avg1/0&lt;/code&gt; ， &lt;code&gt;avg5/0&lt;/code&gt; ，和 &lt;code&gt;avg15/0&lt;/code&gt; 函数可以用于检索系统的负载值，并且 &lt;code&gt;util/0&lt;/code&gt; 和 &lt;code&gt;util/1&lt;/code&gt; 可用于检索CPU利用率值的函数。</target>
        </trans-unit>
        <trans-unit id="a43d2dcf5e0e967eda5efa53bd70665dc5d59efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blog()&lt;/code&gt; functions can also be used for internally formatted logs, but in this case they must be called with binaries constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;. There is no check to ensure this, it is entirely the responsibility of the caller. If these functions are called with binaries that do not correspond to Erlang terms, the &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; and automatic repair functions fail. The corresponding terms (not the binaries) are returned when &lt;code&gt;chunk/2,3&lt;/code&gt; is called.</source>
          <target state="translated">该 &lt;code&gt;blog()&lt;/code&gt; 函数也可以用于内部格式的日志，但在这种情况下，他们必须与调用构造二进制文件被称为 &lt;code&gt;term_to_binary/1&lt;/code&gt; 。没有检查可以确保这一点，这完全是呼叫者的责任。如果使用与Erlang项不对应的二进制文件来调用这些函数，则 &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; 和自动修复函数将失败。当调用 &lt;code&gt;chunk/2,3&lt;/code&gt; 时，将返回相应的项（不是二进制文件）。</target>
        </trans-unit>
        <trans-unit id="37d74f76daa8e51f123951ddaf373680517fc012" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel_callback&lt;/code&gt; is the module that implements the &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; (replaces ssh_daemon_channel) behaviour in the daemon. See the section &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information and an example.</source>
          <target state="translated">该 &lt;code&gt;channel_callback&lt;/code&gt; 是模块实现了 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 的守护进程（取代ssh_daemon_channel）行为。有关更多信息和示例，请参见《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;using_ssh#usersguide_creating_a_subsystem&quot;&gt;Creating a Subsystem&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b8493f2b264f76e709a289fe048f59895e05cdc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; above makes the &lt;code&gt;.erlang.cookie&lt;/code&gt; file accessible only by the owner of the file. This is a requirement.</source>
          <target state="translated">上面的 &lt;code&gt;chmod&lt;/code&gt; 使得 &lt;code&gt;.erlang.cookie&lt;/code&gt; 文件只能由文件所有者访问。这是一个要求。</target>
        </trans-unit>
        <trans-unit id="067ed8257f3ed48d1dd77d1c82e5f73c03791be2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;client_directory&lt;/code&gt; in the directory structure of the master nodes must be specified.</source>
          <target state="translated">该 &lt;code&gt;client_directory&lt;/code&gt; 在主节点的目录结构必须被指定。</target>
        </trans-unit>
        <trans-unit id="97ad2677bec8a2ec1b2eaf275491aa26823e6cdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clients&lt;/code&gt; directory is to have one subdirectory per supported client node. The name of each client directory is to be the name of the corresponding client node. As a minimum, each client directory is to contain the &lt;code&gt;bin&lt;/code&gt; and &lt;code&gt;releases&lt;/code&gt; subdirectories. These directories are used to store information about installed releases and to appoint the current release to the client. The &lt;code&gt;$ROOT&lt;/code&gt; directory thus contains the following:</source>
          <target state="translated">该 &lt;code&gt;clients&lt;/code&gt; 目录是让每个支持的客户端节点的一个子目录。每个客户端目录的名称将是相应客户端节点的名称。至少，每个客户端目录 &lt;code&gt;bin&lt;/code&gt; 包含bin并 &lt;code&gt;releases&lt;/code&gt; 子目录。这些目录用于存储有关已安装发行版的信息，并将当前发行版指定给客户端。在 &lt;code&gt;$ROOT&lt;/code&gt; 因此目录包含以下内容：</target>
        </trans-unit>
        <trans-unit id="fef0ac1b98cce64ffd1d82b4509565a3e18b84ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code_change&lt;/code&gt; method must also be implemented.</source>
          <target state="translated">该 &lt;code&gt;code_change&lt;/code&gt; 方法也必须执行。</target>
        </trans-unit>
        <trans-unit id="dfba9577e3cba70bb212c1548338d8d33c8f09a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combined&lt;/code&gt; format is one line looking like this: &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;combined&lt;/code&gt; 格式被一条线看起来像这样： &lt;code&gt;remotehost rfc931 authuser [date] &quot;request&quot; status bytes &quot;referer&quot; &quot;user_agent&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b60f349fe6a82d8f3ab2d525a727ef964290939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process does the following:</source>
          <target state="translated">在 &lt;code&gt;complex&lt;/code&gt; 过程执行以下操作：</target>
        </trans-unit>
        <trans-unit id="ceca332ed5fece3a22bbc2b65250bbdfb9575097" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complex&lt;/code&gt; process performs the following:</source>
          <target state="translated">的 &lt;code&gt;complex&lt;/code&gt; 过程执行以下：</target>
        </trans-unit>
        <trans-unit id="3748b6dda37726d1886cb8a28dacde2fa7798fe9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; macro is defined in &lt;code&gt;ct.hrl&lt;/code&gt;. This macro is to be used to retrieve information from the &lt;code&gt;Config&lt;/code&gt; variable sent to all test cases. It is used with two arguments; the first is the name of the configuration variable to retrieve, the second is the &lt;code&gt;Config&lt;/code&gt; variable supplied to the test case.</source>
          <target state="translated">的 &lt;code&gt;config&lt;/code&gt; 宏在定义 &lt;code&gt;ct.hrl&lt;/code&gt; 。该宏用于从发送给所有测试用例的 &lt;code&gt;Config&lt;/code&gt; 变量中检索信息。它与两个参数一起使用；第一个是要检索的配置变量的名称，第二个是提供给测试用例的 &lt;code&gt;Config&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="3402fd646c2b066512d58aeec8dd8cb2dfa256aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; script will issue a warning when a default value is used. When a variable has been set, no warning will be issued.</source>
          <target state="translated">使用默认值时， &lt;code&gt;configure&lt;/code&gt; 脚本将发出警告。设置变量后，将不会发出警告。</target>
        </trans-unit>
        <trans-unit id="6288c90b6c5e2f3d2b468cb02b51d6affc24bf92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; scripts are generated by invoking &lt;code&gt;./otp_build autoconf&lt;/code&gt; in the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory. The &lt;code&gt;configure&lt;/code&gt; scripts also have to be regenerated when a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file has been modified. Note that when checking out a branch a &lt;code&gt;configure.in&lt;/code&gt; or &lt;code&gt;aclocal.m4&lt;/code&gt; file may change content, and you may therefore have to regenerate the &lt;code&gt;configure&lt;/code&gt; scripts when checking out a branch. Regenerated &lt;code&gt;configure&lt;/code&gt; scripts imply that you have to run &lt;code&gt;configure&lt;/code&gt; and build again.</source>
          <target state="translated">该 &lt;code&gt;configure&lt;/code&gt; 脚本调用产生 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 在 &lt;code&gt;$ERL_TOP&lt;/code&gt; 目录。该 &lt;code&gt;configure&lt;/code&gt; 脚本还具有当要再生 &lt;code&gt;configure.in&lt;/code&gt; 或 &lt;code&gt;aclocal.m4&lt;/code&gt; 文件已被修改。请注意，签出分支时， &lt;code&gt;configure.in&lt;/code&gt; 或 &lt;code&gt;aclocal.m4&lt;/code&gt; 文件可能会更改内容，因此签出分支时可能必须重新生成 &lt;code&gt;configure&lt;/code&gt; 脚本。重新生成的 &lt;code&gt;configure&lt;/code&gt; 脚本意味着您必须再次运行 &lt;code&gt;configure&lt;/code&gt; 和build。</target>
        </trans-unit>
        <trans-unit id="208c163b5d9b18adfd658c53d3afa3ceb105c168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; function looks a bit different too. We connect using the asynchronous &lt;code&gt;PQconnectStart&lt;/code&gt; function. After the connection is started, we retrieve the socket for the connection with &lt;code&gt;PQsocket&lt;/code&gt;. This socket is used with the &lt;code&gt;driver_select&lt;/code&gt; function to wait for connection. When the socket is ready for input or for output, the &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">在 &lt;code&gt;connect&lt;/code&gt; 功能看起来有点不同了。我们使用异步 &lt;code&gt;PQconnectStart&lt;/code&gt; 函数进行连接。连接开始后，我们使用 &lt;code&gt;PQsocket&lt;/code&gt; 检索用于连接的套接字。该套接字与 &lt;code&gt;driver_select&lt;/code&gt; 函数一起使用，以等待连接。当套接字准备好用于输入或输出时，将 &lt;code&gt;ready_io&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="72241940e6969f3882cb2063d805e933d9f13162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; option is &lt;strong&gt;not&lt;/strong&gt; intended for production. It is &lt;strong&gt;only&lt;/strong&gt; a convenient way to debug Erlang services during development.</source>
          <target state="translated">该 &lt;code&gt;console&lt;/code&gt; 选项&lt;strong&gt;不&lt;/strong&gt;用于生产。这&lt;strong&gt;只是&lt;/strong&gt;在开发过程中调试Erlang服务的便捷方法。</target>
        </trans-unit>
        <trans-unit id="09d03cd7b2afda946d29b4dfa4871ca45c957a3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content&lt;/code&gt; field of the top element is a list of records that shows the structure and data of the document. If it is a simple document like:</source>
          <target state="translated">顶部元素的 &lt;code&gt;content&lt;/code&gt; 字段是记录列表，显示文档的结构和数据。如果它是一个简单的文档，例如：</target>
        </trans-unit>
        <trans-unit id="838c0fd05d2d1deb4094b06de0e616a5af7c6e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; option inhibits the call to &lt;code&gt;trace(stop)&lt;/code&gt; and leaves it up to the caller to stop tracing at a suitable time.</source>
          <target state="translated">该 &lt;code&gt;continue&lt;/code&gt; 选项禁止调用 &lt;code&gt;trace(stop)&lt;/code&gt; 和叶它给调用者停止在一个合适的时间跟踪。</target>
        </trans-unit>
        <trans-unit id="5e5e4cf83680d9fc0726d1fa4e444a1ac9be072e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;control&lt;/code&gt; entry is called from the emulator when the Erlang code calls &lt;code&gt;port_control/3&lt;/code&gt;, to do the actual work. We have defined a simple set of commands: &lt;code&gt;connect&lt;/code&gt; to log in to the database, &lt;code&gt;disconnect&lt;/code&gt; to log out, and &lt;code&gt;select&lt;/code&gt; to send a SQL-query and get the result. All results are returned through &lt;code&gt;rbuf&lt;/code&gt;. The library &lt;code&gt;ei&lt;/code&gt; in &lt;code&gt;erl_interface&lt;/code&gt; is used to encode data in binary term format. The result is returned to the emulator as binary terms, so &lt;code&gt;binary_to_term&lt;/code&gt; is called in Erlang to convert the result to term form.</source>
          <target state="translated">该 &lt;code&gt;control&lt;/code&gt; 在二郎山代码调用条目从模拟器称为 &lt;code&gt;port_control/3&lt;/code&gt; ，做实际工作。我们定义了一组简单的命令： &lt;code&gt;connect&lt;/code&gt; 以登录数据库， &lt;code&gt;disconnect&lt;/code&gt; 以注销，并 &lt;code&gt;select&lt;/code&gt; 发送SQL查询并获取结果。所有结果都通过 &lt;code&gt;rbuf&lt;/code&gt; 返回。该库 &lt;code&gt;ei&lt;/code&gt; 在 &lt;code&gt;erl_interface&lt;/code&gt; 用于以二进制格式术语编码数据。结果以二进制术语的形式返回给仿真器，因此在Erlang中调用 &lt;code&gt;binary_to_term&lt;/code&gt; 将结果转换为术语形式。</target>
        </trans-unit>
        <trans-unit id="26bab11093554a028ef86c3afb6f974cfc496b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert_to_c&lt;/code&gt; function is the same as before, but here it is used as a fun:</source>
          <target state="translated">该 &lt;code&gt;convert_to_c&lt;/code&gt; 功能是和以前一样，但在这里它作为一个有趣的：</target>
        </trans-unit>
        <trans-unit id="77c0725ecb5968616addeb9bf220dfefe059032f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cprof&lt;/code&gt; module is used to profile a program to find out how many times different functions are called. Breakpoints similar to local call trace, but containing a counter, are used to minimise runtime performance impact.</source>
          <target state="translated">该 &lt;code&gt;cprof&lt;/code&gt; 模块用于简报的程序，找出不同的功能调用多少次。类似于本地呼叫跟踪的断点，但包含一个计数器，用于最大程度地减少对运行时性能的影响。</target>
        </trans-unit>
        <trans-unit id="9716455d32bb78ba694b642a2f677996c5c94a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypto&lt;/code&gt; mode option is applied to the generated stream of bytes prior to sending them to the SFTP server. This is intended for encryption but can be used for other purposes.</source>
          <target state="translated">将 &lt;code&gt;crypto&lt;/code&gt; 模式选项应用于已生成的字节流，然后再将其发送到SFTP服务器。这旨在用于加密，但可以用于其他目的。</target>
        </trans-unit>
        <trans-unit id="f05085fc1befe3aa6ba53fe6204755e8c7f0ad8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_hooks&lt;/code&gt; statement must look as follows:</source>
          <target state="translated">该 &lt;code&gt;ct_hooks&lt;/code&gt; 声明必须如下所示：</target>
        </trans-unit>
        <trans-unit id="195e3e1b4f16da2ed99752167d29e762d1e2035f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program is automatically installed with Erlang/OTP and the &lt;code&gt;Common Test&lt;/code&gt; application (for more information, see section &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; in the User's Guide). The program accepts different start flags. Some flags trigger &lt;code&gt;ct_run&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt; and pass on data to it. Some flags start an Erlang node prepared for running &lt;code&gt;Common Test&lt;/code&gt; in a particular mode.</source>
          <target state="translated">该 &lt;code&gt;ct_run&lt;/code&gt; 程序使用Erlang / OTP和自动安装 &lt;code&gt;Common Test&lt;/code&gt; 应用程序（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;install_chapter&quot;&gt;Installation&lt;/a&gt;&lt;/code&gt; 的用户指南）。该程序接受不同的开始标志。一些标志触发 &lt;code&gt;ct_run&lt;/code&gt; 以启动 &lt;code&gt;Common Test&lt;/code&gt; 并将数据传递给它。一些标志会启动一个Erlang节点，准备在特定模式下运行 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bead0eeaff46c7e466e0712fc0054654e293c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ct_run&lt;/code&gt; program sets the exit status before shutting down. The following values are defined:</source>
          <target state="translated">该 &lt;code&gt;ct_run&lt;/code&gt; 程序关闭之前设置退出状态。定义了以下值：</target>
        </trans-unit>
        <trans-unit id="5e688bf44ef358ec92d20ce42ff6bf380d1fb9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cth_conn_log&lt;/code&gt; hook performs unformatted logging of Telnet data to a separate text file. All Telnet communication is captured and printed, including any data sent from the server. The link to this text file is located at the top of the test case HTML log.</source>
          <target state="translated">所述 &lt;code&gt;cth_conn_log&lt;/code&gt; 钩进行远程登录数据的无格式记录到一个单独的文本文件。捕获并打印所有Telnet通信，包括从服务器发送的所有数据。指向此文本文件的链接位于测试用例HTML日志的顶部。</target>
        </trans-unit>
        <trans-unit id="a68179b6708f261780e3204a93ccf67ebff3b412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; module is primarily targeted towards tracing through the &lt;code&gt;erlang:trace/3&lt;/code&gt; function. It is sometimes desired to trace messages in a more delicate way, which can be done with the help of the &lt;code&gt;seq_trace&lt;/code&gt; module.</source>
          <target state="translated">所述 &lt;code&gt;dbg&lt;/code&gt; 模块主要是针对向通过跟踪 &lt;code&gt;erlang:trace/3&lt;/code&gt; 的功能。有时希望以一种更精致的方式跟踪消息，这可以在 &lt;code&gt;seq_trace&lt;/code&gt; 模块的帮助下完成。</target>
        </trans-unit>
        <trans-unit id="4ec06ab24b2bef8a81af6b12d4353768a1844399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; server keeps a list of nodes where tracing should be performed. Whenever a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; call or a &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; call is made, it is executed for all nodes in this list including the local node (except for &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; with a specific &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; as first argument, in which case the command is executed only on the node where the designated process or port resides).</source>
          <target state="translated">该 &lt;code&gt;dbg&lt;/code&gt; 服务器保留在那里跟踪应执行的节点列表。每当进行 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 调用或 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 调用时，都会对列表中的所有节点（包括本地节点）执行该操作（除了以特殊 &lt;code&gt;pid()&lt;/code&gt; 或 &lt;code&gt;port()&lt;/code&gt; 作为第一个参数的 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 之外），其中如果命令仅在指定进程或端口所在的节点上执行）。</target>
        </trans-unit>
        <trans-unit id="c217008a9ef77e9f7c9c82997e3edae1e2b0a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg&lt;/code&gt; variants of match specifications have an imperative approach to the match specification body, the ETS dialect has not. The fun body for &lt;code&gt;ets:fun2ms/1&lt;/code&gt; returns the result without side effects. As matching (&lt;code&gt;=&lt;/code&gt;) in the body of the match specifications is not allowed (for performance reasons) the only thing left, more or less, is term construction.</source>
          <target state="translated">匹配规范的 &lt;code&gt;dbg&lt;/code&gt; 变体对匹配规范主体具有强制性的方法，而ETS方言则没有。 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 的fun主体返回的结果没有副作用。由于不允许匹配规范中的匹配（ &lt;code&gt;=&lt;/code&gt; ）（出于性能原因），剩下的或多或少是术语构造。</target>
        </trans-unit>
        <trans-unit id="8b1d45e514e2b4bb0f72c0e576b456b901110516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; option ensures that the BEAM file contains debug information, which makes it possible to find unused local functions.</source>
          <target state="translated">该 &lt;code&gt;debug_info&lt;/code&gt; 选项确保梁文件包含调试信息，这使得它可以找到未使用的本地功能。</target>
        </trans-unit>
        <trans-unit id="f272f87848e9520c4164ada69cea273706e63692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug_info&lt;/code&gt; parameter controls whether the debug information in the beam file should be kept (&lt;code&gt;keep&lt;/code&gt;) or stripped &lt;code&gt;strip&lt;/code&gt; when the file is copied to the target system.</source>
          <target state="translated">所述 &lt;code&gt;debug_info&lt;/code&gt; 参数控制在梁文件中的调试信息是否应保持（ &lt;code&gt;keep&lt;/code&gt; ）或剥离 &lt;code&gt;strip&lt;/code&gt; 时，文件被复制到目标系统。</target>
        </trans-unit>
        <trans-unit id="6fb823bf619fb63ef67310a79ad7a561ee4d0a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the table from the database since unloading an MIB does not necessarily mean that the table should be destroyed.</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 功能不会从数据库中，因为卸载的MIB并不一定意味着该表应销毁删除表。</target>
        </trans-unit>
        <trans-unit id="9bb6d436299249f5caa30b07b29030812a609536" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; function does not delete the variable from the database.</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 功能不会从数据库中删除该变量。</target>
        </trans-unit>
        <trans-unit id="7056e5309dbe8cb35a67254e724ea1561fd3590e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; operation is considered successful if the element was not present in the table. Hence all attempts to check that the element is present in the Ets/Mnesia table before deletion are unnecessary. Here follows an example for Ets tables:</source>
          <target state="translated">该 &lt;code&gt;delete&lt;/code&gt; 操作被认为是成功的，如果该元素是不存在的表。因此，无需在删除之前进行所有检查以检查该元素是否在Ets / Mnesia表中的尝试。以下是Ets表的示例：</target>
        </trans-unit>
        <trans-unit id="3ec29833516e95ca8c52bcd06ca0329b6a9912b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disc_copies&lt;/code&gt; tables are stored on disk with &lt;code&gt;.DCL&lt;/code&gt; and &lt;code&gt;.DCD&lt;/code&gt; files, which are standard &lt;code&gt;disk_log&lt;/code&gt; files.</source>
          <target state="translated">该 &lt;code&gt;disc_copies&lt;/code&gt; 表存储在磁盘 &lt;code&gt;.DCL&lt;/code&gt; 和 &lt;code&gt;.DCD&lt;/code&gt; 文件，这是标准的 &lt;code&gt;disk_log&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="0566aa9127b7a16298ed02e87fbca3df443437c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disk_log&lt;/code&gt; module does not report errors to the &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; module. It is up to the caller to decide whether to employ the error logger. Function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; can be used to produce readable messages from error replies. However, information events are sent to the error logger in two situations, namely when a log is repaired, or when a file is missing while reading chunks.</source>
          <target state="translated">该 &lt;code&gt;disk_log&lt;/code&gt; 模块不向报告错误 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 模块。由调用者决定是否使用错误记录器。函数 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 可用于从错误回复中产生可读的消息。但是，在两种情况下，信息事件会发送到错误记录器，即修复日志时或读取块时缺少文件时。</target>
        </trans-unit>
        <trans-unit id="cfcfef3897d14b434ad165428853c39b5f2890f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; and &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; functions takes a &lt;code&gt;#hs_data{}&lt;/code&gt; record as argument. There are quite a lot of fields in this record that you need to set. The record is defined in &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt;. Not documented fields should not be set, i.e., should be left as &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;dist_util:handshake_we_started/1&lt;/code&gt; 和 &lt;code&gt;dist_util:handshake_other_started/1&lt;/code&gt; 功能需要 &lt;code&gt;#hs_data{}&lt;/code&gt; 记录作为参数。您需要在此记录中设置很多字段。该记录在 &lt;code&gt;kernel/include/dist_util.hrl&lt;/code&gt; 中定义。未记录的字段不应设置，即应保留为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83c7e0ed34c372831d8c8f2866d0a4d8b8af47d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_select&lt;/code&gt; function initiates a select, and returns if there is no immediate error. The result is returned when &lt;code&gt;ready_io&lt;/code&gt; is called.</source>
          <target state="translated">该 &lt;code&gt;do_select&lt;/code&gt; 功能启动选择和回报，如果没有直接的错误。调用 &lt;code&gt;ready_io&lt;/code&gt; 时将返回结果。</target>
        </trans-unit>
        <trans-unit id="9e898d68f399dcaad71bedb473b4e1db27a86822" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;driver_entry&lt;/code&gt; structure is a C struct that all Erlang drivers define. It contains entry points for the Erlang driver, which are called by the Erlang emulator when Erlang code accesses the driver.</source>
          <target state="translated">该 &lt;code&gt;driver_entry&lt;/code&gt; 结构是一个C结构，所有二郎司机定义。它包含Erlang驱动程序的入口点，当Erlang代码访问驱动程序时，Erlang仿真器将调用这些入口点。</target>
        </trans-unit>
        <trans-unit id="e2f343471e0cd9e732eb94fa594ad01445d525d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entity-Body&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;, for example, data sent from a CGI script using the POST method.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 中定义的 &lt;code&gt;entity-Body&lt;/code&gt; ，例如，使用POST方法从CGI脚本发送的数据。</target>
        </trans-unit>
        <trans-unit id="8485e195c6ca973415a83d30d66c767c905bacbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epmd&lt;/code&gt; daemon accepts messages from both the local host and remote hosts. However, only the query commands are answered (and acted upon) if the query comes from a remote host. It is always an error to try to register a node name if the client is not a process on the same host as the &lt;code&gt;epmd&lt;/code&gt; instance is running on. Such requests are considered hostile and the connection is closed immediately.</source>
          <target state="translated">该 &lt;code&gt;epmd&lt;/code&gt; 守护进程接受来自本地主机和远程主机的消息。但是，如果查询来自远程主机，则仅查询（和执行）查询命令。如果客户端不是与 &lt;code&gt;epmd&lt;/code&gt; 实例运行在同一主机上的进程，则尝试注册节点名称始终是错误的。此类请求被视为具有敌意，并且连接将立即关闭。</target>
        </trans-unit>
        <trans-unit id="1a8cdcc41303bad80d1836231fd657575e8b7da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl&lt;/code&gt; program starts an Erlang runtime system. The exact details (for example, whether &lt;code&gt;erl&lt;/code&gt; is a script or a program and which other programs it calls) are system-dependent.</source>
          <target state="translated">该 &lt;code&gt;erl&lt;/code&gt; 程序启动一个Erlang运行时系统。确切的详细信息（例如， &lt;code&gt;erl&lt;/code&gt; 是脚本还是程序，以及它调用的其他程序）取决于系统。</target>
        </trans-unit>
        <trans-unit id="23033c746a70348dcd7ee413398f764a041fafc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_boot_server&lt;/code&gt; can read regular files and files in archives. See &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; in ERTS.</source>
          <target state="translated">该 &lt;code&gt;erl_boot_server&lt;/code&gt; 可以在档案读取普通文件和文件。请参阅ERTS中的 &lt;code&gt;&lt;a href=&quot;code&quot;&gt;code(3)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc1db4ac366acb55e5dbd23b870fee87dcf6984d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erl_prim_loader&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">所述 &lt;code&gt;erl_prim_loader&lt;/code&gt; 模块解释下面的命令行标志：</target>
        </trans-unit>
        <trans-unit id="9c8443a325361f346c54c5b5b79ecfd176dc3cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF is equivalent to:</source>
          <target state="translated">的 &lt;code&gt;erlang:timestamp()&lt;/code&gt; BIF等效于：</target>
        </trans-unit>
        <trans-unit id="674c071fef1bb6c50be069bf2fac5cfa5b02ddff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; commands can be used to compile SNMP MIBs. Example:</source>
          <target state="translated">所述 &lt;code&gt;erlc&lt;/code&gt; 命令可用于编译的SNMP MIB。例：</target>
        </trans-unit>
        <trans-unit id="62bad1fda35fe8631456e7f852e564c8e9c8e268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides a common way to run all compilers in the Erlang system. Depending on the extension of each input file, &lt;code&gt;erlc&lt;/code&gt; invokes the appropriate compiler. Regardless of which compiler is used, the same flags are used to provide parameters, such as include paths and output directory.</source>
          <target state="translated">该 &lt;code&gt;erlc&lt;/code&gt; 程序提供运行在Erlang的系统中所有的编译器的常用方法。根据每个输入文件的扩展名， &lt;code&gt;erlc&lt;/code&gt; 调用适当的编译器。无论使用哪种编译器，都使用相同的标志来提供参数，例如包含路径和输出目录。</target>
        </trans-unit>
        <trans-unit id="04a181b53380c41c65d2013dd7fbc831073b3697" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erlc&lt;/code&gt; program provides an even better way to compile modules from the shell, see the &lt;code&gt;erlc(1)&lt;/code&gt; manual page in ERTS. It understands a number of flags that can be used to define macros, add search paths for include files, and more.</source>
          <target state="translated">该 &lt;code&gt;erlc&lt;/code&gt; 方案提供了一个更好的方法，以从所述外壳编译模块，请参见 &lt;code&gt;erlc(1)&lt;/code&gt; 在ERTS手册页。它了解许多标志，这些标志可用于定义宏，添加包含文件的搜索路径等等。</target>
        </trans-unit>
        <trans-unit id="cd3c7d4f5dac617c7aad52a992257a0165d9e724" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger&lt;/code&gt; API still exists, but should only be used by legacy code. It will be removed in a later release.</source>
          <target state="translated">该 &lt;code&gt;error_logger&lt;/code&gt; API仍然存在，但只能由传统的代码中使用。它将在以后的版本中删除。</target>
        </trans-unit>
        <trans-unit id="d68556b2eb1fae2f09bd4af885781dca52da64d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_logger_format_depth&lt;/code&gt; variable is &lt;code&gt;deprecated&lt;/code&gt; since the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; was introduced in Erlang/OTP 21.0. The variable, and this function, are kept for backwards compatibility since they still might be used by legacy report handlers.</source>
          <target state="translated">所述 &lt;code&gt;error_logger_format_depth&lt;/code&gt; 变量 &lt;code&gt;deprecated&lt;/code&gt; 由于 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 在二郎/ OTP 21.0引入。保留变量和此函数是为了向后兼容，因为旧式报表处理程序仍可能使用它们。</target>
        </trans-unit>
        <trans-unit id="7c78dbc6e06eb7032ca1037abf4bb7cf984ec4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; tool can be used to aid creation of an &lt;code&gt;erts_alloc&lt;/code&gt; configuration that is suitable for a limited number of runtime scenarios.</source>
          <target state="translated">所述 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 工具，可以用来帮助一个的创建 &lt;code&gt;erts_alloc&lt;/code&gt; 配置适合于运行时的场景的数量有限。</target>
        </trans-unit>
        <trans-unit id="6d445f376d6f420d187f6eefce3f926292a91d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;et&lt;/code&gt; module is not like other modules. It contains a function called &lt;code&gt;et:trace_me/5&lt;/code&gt;. Which is a function that does not do any useful stuff at all. Its sole purpose is to be a function that is easy to trace. A call to it may be something like:</source>
          <target state="translated">所述 &lt;code&gt;et&lt;/code&gt; 模块不是像其它模块。它包含一个名为 &lt;code&gt;et:trace_me/5&lt;/code&gt; 的函数。该函数根本不做任何有用的事情。其唯一目的是成为易于跟踪的功能。对其进行的调用可能类似于：</target>
        </trans-unit>
        <trans-unit id="bed59c1de102975ce15ed3e675ac3119209f047d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; program of fairly modern versions of Emacs and XEmacs has native support for Erlang. To check if your version does include this support, issue the command &lt;code&gt;etags --help&lt;/code&gt; at a the command line prompt. At the end of the help text there is a list of supported languages. Unless Erlang is a member of this list I suggest that you should upgrade to a newer version of Emacs.</source>
          <target state="translated">相当现代的Emacs和XEmacs版本的 &lt;code&gt;etags&lt;/code&gt; 程序具有对Erlang的本地支持。要检查您的版本是否确实包含此支持，请在命令行提示符下发出命令 &lt;code&gt;etags --help&lt;/code&gt; 。帮助文本的末尾有支持的语言列表。除非Erlang是此列表的成员，否则我建议您升级到Emacs的较新版本。</target>
        </trans-unit>
        <trans-unit id="47e6f553b59c8cd440ae6bcf427e51798ed42721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;etags&lt;/code&gt; utility can also read a list of files from its standard input by supplying a single dash in place of the file names. This feature is useful when a project consists of a large number of files. The standard UNIX command &lt;code&gt;find&lt;/code&gt; can be used to generate the list of files, e.g:</source>
          <target state="translated">该 &lt;code&gt;etags&lt;/code&gt; 实用程序还可以通过替代文件名提供一个单一的破折号读取从标准输入文件的列表。当项目包含大量文件时，此功能很有用。标准UNIX命令 &lt;code&gt;find&lt;/code&gt; 可用于生成文件列表，例如：</target>
        </trans-unit>
        <trans-unit id="e41a30417c9eb9b7fd9125a0948a761a185309da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ets:select/2&lt;/code&gt; call conceptually looks like this in the resulting code:</source>
          <target state="translated">在结果代码中， &lt;code&gt;ets:select/2&lt;/code&gt; 调用在概念上看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c0a28f71fbf02463cf528426b0591cc67a7a02b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;example_drv_start&lt;/code&gt;, is the only function that is called with a handle to the port instance, so this must be saved. It is customary to use an allocated driver-defined structure for this one, and to pass a pointer back as a reference.</source>
          <target state="translated">该 &lt;code&gt;example_drv_start&lt;/code&gt; ，是调用句柄到端口实例的唯一功能，因此必须被保存。通常为此使用分配的驱动程序定义的结构，并将指针传回作为引用。</target>
        </trans-unit>
        <trans-unit id="d0356d1c5d4e8ef894f1ca0204010b1f0f916038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extended_errors&lt;/code&gt; option enables extended ODBC error information when an operation fails. Rather than returning &lt;code&gt;{error, Reason}&lt;/code&gt;, the failing function will reutrn &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt;. Note that this information is probably of little use when writing database-independent code, but can be of assistance in providing more sophisticated error handling when dealing with a known underlying database.</source>
          <target state="translated">当操作失败时， &lt;code&gt;extended_errors&lt;/code&gt; 选项启用扩展的ODBC错误信息。失败的函数将返回 &lt;code&gt;{error, {ODBCErrorCode, NativeErrorCode, Reason}}&lt;/code&gt; 而不是返回 &lt;code&gt;{error, Reason}&lt;/code&gt; }。请注意，在编写与数据库无关的代码时，此信息可能用处不大，但是在处理已知的基础数据库时，可以帮助提供更复杂的错误处理。</target>
        </trans-unit>
        <trans-unit id="c59051a0d238b0abf7c9e7050c91b5361d579937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra&lt;/code&gt; info is not normally interpreted by the agent, instead it is passed through to the &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; process. It is up to the implementor of that process to make use of this data.</source>
          <target state="translated">该 &lt;code&gt;extra&lt;/code&gt; 信息通常不被代理人的解释，而不是将其传递通过对 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;net-if&lt;/a&gt;&lt;/code&gt; 过程。使用该数据取决于该过程的实现者。</target>
        </trans-unit>
        <trans-unit id="9363097de66681822e14d18a16cae53b07a71b33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module accepts raw filenames as input. &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; also accepts them. As mentioned earlier, the arguments specified in the option list to &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; undergo the same conversion as the filenames, meaning that the executable is provided with arguments in UTF-8 as well. This translation is avoided consistently with how the filenames are treated, by giving the argument as a binary.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; 模块接受原始文件名作为输入。 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 也接受它们。如前所述，在选项列表中为 &lt;code&gt;open_port({spawn_executable, ...} ...)&lt;/code&gt; 指定的参数与文件名的转换相同，这意味着可执行文件在UTF-8中也提供了参数。通过将参数指定为二进制，可以避免与文件名的处理方式保持一致的转换。</target>
        </trans-unit>
        <trans-unit id="56811d8968fc7cff92a38ee6c1b86759f5455dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; module already spread's tags, so there is noo need to manually call these function to get user tags spread to the efile driver through that module.</source>
          <target state="translated">该 &lt;code&gt;file&lt;/code&gt; 模块已经蔓延的标签，所以野应需要手动调用这些函数来获取用户标签蔓延到通过该模块的电子文件的驱动程序。</target>
        </trans-unit>
        <trans-unit id="d1888f67852ce013eb515b48a1f7e3f5fb2b5677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foo&lt;/code&gt; table is replicated on the two nodes &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;foo&lt;/code&gt; 表被复制的两个节点 &lt;code&gt;N1&lt;/code&gt; 和 &lt;code&gt;N2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58cb0b27674de03ef7e6aa8a782a3f05022f6202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fprof&lt;/code&gt; module uses tracing to collect profiling data, hence there is no need for special compilation of any module to be profiled. When it starts tracing, &lt;code&gt;fprof&lt;/code&gt; will erase all previous tracing in the node and set the necessary trace flags on the profiling target processes as well as local call trace on all functions in all loaded modules and all modules to be loaded. &lt;code&gt;fprof&lt;/code&gt; erases all tracing in the node when it stops tracing.</source>
          <target state="translated">该 &lt;code&gt;fprof&lt;/code&gt; 模块使用跟踪，收集分析数据，因此没有必要对任何模块的特殊编制进行概要分析。当开始跟踪时， &lt;code&gt;fprof&lt;/code&gt; 将擦除节点中的所有先前跟踪，并在概要分析目标进程上设置必要的跟踪标志，以及在所有已加载模块和要加载的所有模块中的所有函数上设置本地调用跟踪。 &lt;code&gt;fprof&lt;/code&gt; 停止跟踪时，它将删除该节点中的所有跟踪。</target>
        </trans-unit>
        <trans-unit id="2499ac11d982c28fc125b257bd3bdd2fea444c7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fqdn_fun&lt;/code&gt; extracts hostnames (Fully Qualified Domain Names) from uri_id or other ReferenceIDs that are not pre-defined in the public_key function. Suppose you have some URI with a very special protocol-part: &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt;. Since this a non-standard URI there will be no hostname extracted for matching CN-names in the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;fqdn_fun&lt;/code&gt; 从uri_id或其他ReferenceIDs提取的主机名（完全限定域名），其未在PUBLIC_KEY函数预先定义。假设您有一些带有非常特殊协议部分的URI： &lt;code&gt;myspecial://example.com&quot;&lt;/code&gt; 。由于这是一个非标准URI，因此不会提取任何主机名来匹配 &lt;code&gt;Subject&lt;/code&gt; 中的CN名称。</target>
        </trans-unit>
        <trans-unit id="122806faca6d67fa7fa167376a0e47c2c49bcb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;message&lt;/code&gt; parameters are exactly what they sound like. &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are visualized in the &lt;code&gt;Viewer&lt;/code&gt; as &quot;lifelines&quot;, with the message passing from one to the other. If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same value, then it is displayed next to the lifeline as an &quot;action&quot;. The &lt;code&gt;extra_stuff&lt;/code&gt;value is simply data that you can attach that will be displayed when someone actually clicks on the action or message in the &lt;code&gt;Viewer&lt;/code&gt; window.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 参数是它们的声音究竟是什么样子。 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 在可视化 &lt;code&gt;Viewer&lt;/code&gt; 为&amp;ldquo;生命线&amp;rdquo;，用从一个到另一个的消息传递。如果 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 是相同的值，那么它将在生命线旁边显示为&amp;ldquo;操作&amp;rdquo;。该 &lt;code&gt;extra_stuff&lt;/code&gt; 值只是数据可以附加，当有人在操作或消息实际点击会显示 &lt;code&gt;Viewer&lt;/code&gt; 窗口。</target>
        </trans-unit>
        <trans-unit id="87548be67a9ff93c1ef1ff4d3cbb19180b6403f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ftp&lt;/code&gt; module normally accesses the tar file on disk using the &lt;code&gt;file&lt;/code&gt; module. When other needs arise, you can define your own low-level Erlang functions to perform the writing and reading on the storage media; use function &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ftp&lt;/code&gt; 模块访问正常使用的磁盘tar文件 &lt;code&gt;file&lt;/code&gt; 模块。当有其他需求时，您可以定义自己的低级Erlang函数，以在存储介质上执行写入和读取操作。使用函数 &lt;code&gt;&lt;a href=&quot;#init-3&quot;&gt;init/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="601051b0fdf8cf4c5f5015c05c1f7676f5366f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun()&lt;/code&gt; is very restricted, it can take only a single parameter (the parameter list to match), a sole variable or a list. It needs to use the &lt;code&gt;is_&lt;/code&gt;XXX guard tests and one cannot use language constructs that have no representation in a match_spec (like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; etc). The return value from the fun will be the return value of the resulting match_spec.</source>
          <target state="translated">的 &lt;code&gt;fun()&lt;/code&gt; 是非常有限的，它可以采取只有一个参数（参数列表匹配），唯一的变量或列表。它需要使用 &lt;code&gt;is_&lt;/code&gt; XXX保护测试，并且不能使用在match_spec中没有表示形式的语言构造（例如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; ， &lt;code&gt;receive&lt;/code&gt; 等）。Fun的返回值将是结果match_spec的返回值。</target>
        </trans-unit>
        <trans-unit id="000806ecedbeddab2e6bf12ee5fe07ca1e33c2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun/2&lt;/code&gt; in this option replaces the default host name matching rules. The fun should return a boolean to tell if the Reference ID and Presented ID matches or not. The fun can also return a third value, the atom &lt;code&gt;default&lt;/code&gt;, if the default matching rules shall apply. This makes it possible to augment the tests with a special case:</source>
          <target state="translated">此选项中的 &lt;code&gt;fun/2&lt;/code&gt; 替换默认的主机名匹配规则。乐趣应该返回一个布尔值，以告诉参考ID和呈现ID是否匹配。如果默认匹配规则适用，该fun还可以返回第三个值，原子 &lt;code&gt;default&lt;/code&gt; 。这样就可以通过特殊情况扩展测试：</target>
        </trans-unit>
        <trans-unit id="f52884fca2fcf6439eaac6506d404d211516c579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functions&lt;/code&gt; filter shows each function as a vertical line in the sequence diagram. A function calling itself is shown as an activity within a function, and all other function calls are shown as interactions between functions.</source>
          <target state="translated">所述 &lt;code&gt;functions&lt;/code&gt; 过滤器示出了每个功能如在序列图的垂直线。调用自身的函数显示为函数内的活动，所有其他函数调用均显示为函数之间的交互。</target>
        </trans-unit>
        <trans-unit id="3f981dcbf4ac48552e64e421603989d6797ca936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;garbage_collect&lt;/code&gt; pseudo function has not got an OWN time of zero like &lt;code&gt;suspend&lt;/code&gt;, instead it is equal to the ACC time.</source>
          <target state="translated">该 &lt;code&gt;garbage_collect&lt;/code&gt; 伪功能还没有得到零像自己的时间 &lt;code&gt;suspend&lt;/code&gt; ，相反，它是等于ACC时间。</target>
        </trans-unit>
        <trans-unit id="044322659b6e8af2be19d4c036e45080be4df433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_event&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function in a handler module specifies &lt;code&gt;hibernate&lt;/code&gt; in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</source>
          <target state="translated">该 &lt;code&gt;gen_event&lt;/code&gt; 过程可以进入休眠状态（见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ）如果在一个处理器模块指定回调函数 &lt;code&gt;hibernate&lt;/code&gt; 在其返回值。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾回收（休眠时和唤醒后不久），而不是您要在繁忙的事件管理器处理的每个事件之间执行的操作。</target>
        </trans-unit>
        <trans-unit id="26a989bcc28ed3e808b806405714b19049fd235b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned.</source>
          <target state="translated">的 &lt;code&gt;gen_server&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 进行初始化。为了确保同步启动过程，在返回 &lt;code&gt;Module:init/1&lt;/code&gt; 之前，不会返回 &lt;code&gt;start_link/3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa0125aacc8a9ef2d0db488477563acd091e114f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process can go into hibernation (see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;) if a callback function specifies &lt;code&gt;'hibernate'&lt;/code&gt; instead of a time-out value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each call to a busy server.</source>
          <target state="translated">如果回调函数指定 &lt;code&gt;'hibernate'&lt;/code&gt; 而不是超时值，则 &lt;code&gt;gen_server&lt;/code&gt; 进程可以进入休眠状态（请参阅 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; ）。如果服务器长时间处于空闲状态，则此功能很有用。但是，请谨慎使用此功能，因为休眠意味着至少有两个垃圾回收（休眠时和唤醒后不久），并且您不想在每次调用繁忙的服务器之间执行此操作。</target>
        </trans-unit>
        <trans-unit id="93b11bb8bc3cc58fae8df0b4cde4e2b1b7508719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process has been set to trap exit signals.</source>
          <target state="translated">该 &lt;code&gt;gen_server&lt;/code&gt; 过程已被设置为捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="1a0a8f650014835d8fac6303db526f6a6997059c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_server&lt;/code&gt; process terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;gen_server&lt;/code&gt; 进程异常终止和记录一个错误。 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a177f7b03da7ce677026ac74a7f1eaf2f38ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior can if this is enabled, regardless of callback mode, automatically &lt;code&gt;call the state callback&lt;/code&gt; with special arguments whenever the state changes so you can write state enter actions near the rest of the state transition rules. It typically looks like this:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为如果被启用，不管回调模式，自动 &lt;code&gt;call the state callback&lt;/code&gt; 有每当状态变化，所以你可以写状态进入附近的状态转换规则，其余的操作特殊的参数。通常看起来像这样：</target>
        </trans-unit>
        <trans-unit id="bed0fd34af6e417a5ed2971b378b4cefa2ed46b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; behavior supports two callback modes:</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 行为支持两种回调模式：</target>
        </trans-unit>
        <trans-unit id="17680806ff10db88faa8089ccb57cda1bbf46d1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;NextState&lt;/code&gt; (which can be the same as the current state), sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 确实的状态转变到 &lt;code&gt;NextState&lt;/code&gt; （其可以是相同的当前状态），设置 &lt;code&gt;NewData&lt;/code&gt; ，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b1ba800b2bd8eddab3c29205a82310973e51fec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; does a state transition to &lt;code&gt;State&lt;/code&gt;, which has to be the current state, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 做了状态过渡到 &lt;code&gt;State&lt;/code&gt; ，它必须是当前的状态，将 &lt;code&gt;NewData&lt;/code&gt; ，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ff91dbdb67dc0752a1cb136935a70afdac9c712" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; engine can automatically make a specialized call to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; whenever a new state is entered; see &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt;. This is for writing code common to all state entries. Another way to do it is to insert an event at the state transition, and/or to use a dedicated state transition function, but that is something you will have to remember at every state transition to the state(s) that need it.</source>
          <target state="translated">每当输入新状态时， &lt;code&gt;gen_statem&lt;/code&gt; 引擎就可以自动对 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 进行专门的调用。参见 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state_enter()&lt;/a&gt;&lt;/code&gt; 。这是用于编写所有状态条目通用的代码。做到这一点的另一种方法是在状态转换处插入事件，和/或使用专用的状态转换函数，但这是您在每次状态转换到需要状态的状态时都必须记住的事情。</target>
        </trans-unit>
        <trans-unit id="609a55f5722ed6b61803cc1734f944814dbce653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; enqueues incoming events in order of arrival and presents these to the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in that order. The state callback can postpone an event so it is not retried in the current state. After a state change the queue restarts with the postponed events.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 按到达顺序使进入的事件排队，并按该顺序将它们呈现给 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。状态回调可以推迟事件，因此不会在当前状态下重试该事件。状态更改后，队列将重新启动并推迟事件。</target>
        </trans-unit>
        <trans-unit id="63345530db17175adac9ec3a019543d210266d03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 事件队列模型是足够选择性接收以模拟正常过程消息队列。推迟事件对应于在接收语句中不匹配事件，而更改状态对应于输入新的接收语句。</target>
        </trans-unit>
        <trans-unit id="641237d979ff0a2d03c26c3ad66f07cb507fd0a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; has been set to trap exit signals.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 已被设置为捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="154bbf6641ffd5663c5aefea121dd325520717a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is globally registered in &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 在全球范围内注册的 &lt;code&gt;global&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67b6a4a7c1fd3b7590f8afba5f3bf9c9be4abb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered on another node.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 是本地注册的另一个节点上。</target>
        </trans-unit>
        <trans-unit id="85f1bfb26c1bebdbfe3ea8eee17c7ba7fcaa85f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is locally registered.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 是本地注册。</target>
        </trans-unit>
        <trans-unit id="dff17e2a1fe994c2de42244386fbbe29172ce5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; is registered in an alternative process registry. The registry callback module &lt;code&gt;RegMod&lt;/code&gt; is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is the same as &lt;code&gt;{global,GlobalName}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 注册在替代进程注册表。注册表回调模块 &lt;code&gt;RegMod&lt;/code&gt; 将导出函数 &lt;code&gt;register_name/2&lt;/code&gt; ， &lt;code&gt;unregister_name/1&lt;/code&gt; ， &lt;code&gt;whereis_name/1&lt;/code&gt; 和 &lt;code&gt;send/2&lt;/code&gt; ，它们的行为类似于 &lt;code&gt;global&lt;/code&gt; 中的相应函数。因此， &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; 与 &lt;code&gt;{global,GlobalName}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f744ffe4f5b7b57ef92ebf70203f5d38f475257a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state and data, or does a state transition to the current state if you like, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state_and_data&lt;/code&gt; is the same as &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 保持当前的状态和数据，或者做一个状态过渡到当前状态，如果你喜欢，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{repeat_state,CurrentData,Actions}&lt;/code&gt; 相同。如果 &lt;code&gt;gen_statem&lt;/code&gt; 运行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，则状态输入调用将重复，请参见type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，否则 &lt;code&gt;repeat_state_and_data&lt;/code&gt; 与 &lt;code&gt;keep_state_and_data&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d475ad84f6e39a68e71be16a98a5f4760d76809d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state or does a state transition to the current state if you like, keeps the current server data, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，保留当前服务器数据，并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{next_state,CurrentState,CurrentData,Actions}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6668d570fa47d65dc6496ac8a7e26666fa0a0e00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the state enter call is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，设置 &lt;code&gt;NewData&lt;/code&gt; 并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。如果 &lt;code&gt;gen_statem&lt;/code&gt; 运行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，则将重复状态输入调用，请参见type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，否则 &lt;code&gt;repeat_state&lt;/code&gt; 与 &lt;code&gt;keep_state&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d700edd0442a4b2cb750903fd91d19af04ce58f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; keeps the current state, or does a state transition to the current state if you like, sets &lt;code&gt;NewData&lt;/code&gt;, and executes all &lt;code&gt;Actions&lt;/code&gt;. This is the same as &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 保留当前状态，或者根据需要将状态转换为当前状态，设置 &lt;code&gt;NewData&lt;/code&gt; 并执行所有 &lt;code&gt;Actions&lt;/code&gt; 。这与 &lt;code&gt;{next_state,CurrentState,NewData,Actions}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8501d306024ff238059935aefd0de35838afe886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; to initialize the server. To ensure a synchronized startup procedure, &lt;code&gt;start_link/3,4&lt;/code&gt; does not return until &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; has returned.</source>
          <target state="translated">所述 &lt;code&gt;gen_statem&lt;/code&gt; 进程调用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 初始化服务器。为了确保同步启动过程，在返回 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 之前，不会返回 &lt;code&gt;start_link/3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3de78075e1ead85abb08c9961b0132a2121787" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; process can go into hibernation; see &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;. It is done when a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; specifies &lt;code&gt;hibernate&lt;/code&gt; in the returned &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 过程可以进入休眠状态; 参见 &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 在返回的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; 列表中指定 &lt;code&gt;hibernate&lt;/code&gt; ，便完成了此操作。在预期服务器长时间处于空闲状态时，此功能对于回收进程堆内存很有用。但是，请谨慎使用此功能，因为在每次事件后使用休眠方式的成本都很高。参见 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="881ead844dbebfad51980a814a9a4905aa6bf4c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_statem&lt;/code&gt; terminates abnormally and logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">该 &lt;code&gt;gen_statem&lt;/code&gt; 异常终止，记录一个错误。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;terminate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98d014159aa311c58e42eb49a30b95ce56872c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get-bulk&lt;/code&gt; operation for transferring large amounts of data.</source>
          <target state="translated">用于传输大量数据的 &lt;code&gt;get-bulk&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="ca7aa99a53f77bb03e023a14cb8a5dfa322719fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;realm&lt;/code&gt; filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, and assuming at most one of each AVP. If this is not the case then the &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; filters must be used to achieve the desired result. An empty &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; (which should not be typical) matches all hosts/realms for the purposes of filtering.</source>
          <target state="translated">在 &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;realm&lt;/code&gt; 滤波器原因目的主机和目标的境界的AVP从呼出请求被提取，假设它是一个record-或列表值 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; ，并且假定每个AVP的至多一个。如果不是这种情况，则必须使用 &lt;code&gt;{host|realm, &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;}&lt;/code&gt; 过滤器才能获得所需的结果。空 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;DiameterIdentity()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; （不应该是典型值）与所有主机/领域匹配，以进行过滤。</target>
        </trans-unit>
        <trans-unit id="6d366d9713f6b9c72596126187499371839fd52b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; module provides short forms for some of the functions used by the graphical Debugger and some of the functions in module &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, the Erlang interpreter.</source>
          <target state="translated">在 &lt;code&gt;i&lt;/code&gt; 模块提供了一些由图形调试器使用的功能和一些在模块的功能的简短形式 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ，Erlang的解释器。</target>
        </trans-unit>
        <trans-unit id="56dd7d3b9f60436a9a9021776dba220b9a35a843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; header represents the number of unique identifiers under a class when the option &lt;code&gt;{combine, true}&lt;/code&gt; is used (which is on by default). It will otherwise show the specific identifier. The &lt;code&gt;db_tab&lt;/code&gt; listing shows 722287 unique locks, it is one for each ets-table created and Mnesia creates one for each transaction.</source>
          <target state="translated">的 &lt;code&gt;id&lt;/code&gt; 标头表示的唯一标识符的一类下的数量，当选项 &lt;code&gt;{combine, true}&lt;/code&gt; 被使用（这是在默认情况下）。否则，它将显示特定的标识符。该 &lt;code&gt;db_tab&lt;/code&gt; 清单所示722287个独特的锁，它是一个用于创建的每个ETS-表的Mnesia创建一个为每个事务。</target>
        </trans-unit>
        <trans-unit id="0fc657f0d7c1adea0e37abaf50e5955d09748ddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; key is mandatory.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 关键是强制性的。</target>
        </trans-unit>
        <trans-unit id="543a86a9dbb014f2154dac485e637aa4987d5f47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; type denotes an snmp index structure.</source>
          <target state="translated">的 &lt;code&gt;index()&lt;/code&gt; 类型表示一个SNMP索引结构。</target>
        </trans-unit>
        <trans-unit id="9e43b2120ef1641713607a20d5663b50e4bfd154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; field of a &lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; record. Can have one of the following types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#service_event&quot;&gt;service_event()&lt;/a&gt;&lt;/code&gt; 记录的 &lt;code&gt;info&lt;/code&gt; 字段。可以具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="1a3e0c6a3b85d7da20be620618cd94e4069d8c32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; functions return information as a list of pairs {Tag, term()} in some order about the state and the &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;info&lt;/code&gt; 函数返回的信息，对{标签，期限（1）}在有关国家的一些订单和列表 &lt;code&gt;&lt;a href=&quot;#module_data&quot;&gt;module data&lt;/a&gt;&lt;/code&gt; 的的 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe1b7238dd78cc738fd7a6138cfed66a0946104d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init:get_arguments()&lt;/code&gt; call verifies that the correct arguments are supplied to the emulator.</source>
          <target state="translated">该 &lt;code&gt;init:get_arguments()&lt;/code&gt; 调用验证正确的参数被给仿真器。</target>
        </trans-unit>
        <trans-unit id="de26f216cc9cb8c745717da43fc15ae4239618cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; module interprets the following command-line flags:</source>
          <target state="translated">所述 &lt;code&gt;init&lt;/code&gt; 模块解释下面的命令行标志：</target>
        </trans-unit>
        <trans-unit id="9159e5b3d2da59b16c5905eba93189ce3aa15286" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; process itself interprets some of these flags, the &lt;strong&gt;init flags&lt;/strong&gt;. It also stores any remaining flags, the &lt;strong&gt;user flags&lt;/strong&gt;. The latter can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;init&lt;/code&gt; 过程本身的一些解释这些标志时，&lt;strong&gt;初始化标志&lt;/strong&gt;。它还存储所有剩余的标志，即&lt;strong&gt;用户标志&lt;/strong&gt;。可以通过调用 &lt;code&gt;init:get_argument/1&lt;/code&gt; 来检索后者。</target>
        </trans-unit>
        <trans-unit id="a00463fc2a7f182be0da0183c5213eee9fd19f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert_emp/3&lt;/code&gt; arguments are as follows:</source>
          <target state="translated">所述 &lt;code&gt;insert_emp/3&lt;/code&gt; 参数如下：</target>
        </trans-unit>
        <trans-unit id="35e63d83642fa80f496dd6056b90a430ea6b3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; module has been extended along with the actual I/O protocol to handle Unicode data. This means that many functions require binaries to be in UTF-8, and there are modifiers to format control sequences to allow for output of Unicode strings.</source>
          <target state="translated">在 &lt;code&gt;io&lt;/code&gt; 模块已经与所述实际I / O协议来处理Unicode数据扩展沿。这意味着许多函数要求二进制文件使用UTF-8，并且有一些修饰符可以格式化控制序列以允许输出Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="abc6624cbf5af8be037d2670ec76b72f4b7f1113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip&lt;/code&gt; Reference ID takes an &lt;code&gt;inet:ip_address()&lt;/code&gt; or an ip address in string format (E.g &quot;10.0.1.1&quot; or &quot;1234::5678:9012&quot;) as second element.</source>
          <target state="translated">的 &lt;code&gt;ip&lt;/code&gt; 参考ID接受一个 &lt;code&gt;inet:ip_address()&lt;/code&gt; 或字符串格式（例如，&amp;ldquo;10.0.1.1&amp;rdquo;或&amp;ldquo;1234 :: 5678：9012&amp;rdquo;）的IP地址作为第二元件。</target>
        </trans-unit>
        <trans-unit id="a7ee8c582d46917ec81790ab0ac53e2589a28393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is_set_ok&lt;/code&gt; function checks that a row which is to be modified or deleted exists, and that a row which is to be created does not exist.</source>
          <target state="translated">所述 &lt;code&gt;is_set_ok&lt;/code&gt; 函数检查该行要被修改或删除是否存在，以及一个行要被创建的不存在。</target>
        </trans-unit>
        <trans-unit id="ff7f1bbdc59c16a06c62efdccc8b7854b7407424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key()&lt;/code&gt; type correlates to the &lt;code&gt;key_types()&lt;/code&gt; type. If the &lt;code&gt;key_types()&lt;/code&gt; is a single atom, the corresponding &lt;code&gt;key()&lt;/code&gt; is a single type as well, but if the &lt;code&gt;key_types()&lt;/code&gt; is a tuple, &lt;code&gt;key&lt;/code&gt; must be a tuple of the same size.</source>
          <target state="translated">的 &lt;code&gt;key()&lt;/code&gt; 类型相关于 &lt;code&gt;key_types()&lt;/code&gt; 的类型。如果 &lt;code&gt;key_types()&lt;/code&gt; 是单个原子，则相应的 &lt;code&gt;key()&lt;/code&gt; 也是单个类型，但是如果 &lt;code&gt;key_types()&lt;/code&gt; 是一个元组，则 &lt;code&gt;key&lt;/code&gt; 必须是相同大小的元组。</target>
        </trans-unit>
        <trans-unit id="5cac72dd809c7185a7dcb83183f4f89c08277c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type defines the types of the SNMP INDEX columns for the table. If the table has one single INDEX column, this type should be a single atom, but if the table has multiple INDEX columns, it should be a tuple with atoms.</source>
          <target state="translated">所述 &lt;code&gt;key_types()&lt;/code&gt; 类型定义了类型SNMP INDEX列表中的。如果表具有单个INDEX列，则此类型应为单个原子，但如果表具有多个INDEX列，则应为具有原子的元组。</target>
        </trans-unit>
        <trans-unit id="a81df154de4b4c4f859872829034600f9ab7e463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key_types()&lt;/code&gt; type is used when creating the index structure, and the &lt;code&gt;key()&lt;/code&gt; type is used when inserting and deleting items from the structure.</source>
          <target state="translated">所述 &lt;code&gt;key_types()&lt;/code&gt; 创建索引结构时类型被使用，并且 &lt;code&gt;key()&lt;/code&gt; 插入和删除从该结构项目时类型被使用。</target>
        </trans-unit>
        <trans-unit id="555d2dccfadbf0b7e5219e84813fd3bd45eaaf5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypos&lt;/code&gt; of the table dumped to file, which is used when loading the table again.</source>
          <target state="translated">表的 &lt;code&gt;keypos&lt;/code&gt; 转储到文件中，在再次加载表时使用。</target>
        </trans-unit>
        <trans-unit id="f7afe180cd162bc0e597b4a20726157b5ac4e0bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;killproc&lt;/code&gt; procedure is not to be removed. The purpose is here to move from run level 3 (multi-user mode with networking resources) to run level 2 (multi-user mode without such resources), in which Erlang is not to run.</source>
          <target state="translated">该 &lt;code&gt;killproc&lt;/code&gt; 程序不被删除。目的是从运行级别3（具有网络资源的多用户模式）移至运行级别2（没有此类资源的多用户模式），在该级别中，将不运行Erlang。</target>
        </trans-unit>
        <trans-unit id="03c484e3840400c5a5e9dd6a195fc19b5d1faa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; component is a term which identifies all events belonging to the same sequential trace. If several sequential traces can be active simultaneously, &lt;code&gt;label&lt;/code&gt; is used to identify the separate traces. Default is 0.</source>
          <target state="translated">该 &lt;code&gt;label&lt;/code&gt; 组件是标识属于同一顺序跟踪的所有事件的术语。如果几个连续的迹线可以同时处于活动状态，则使用 &lt;code&gt;label&lt;/code&gt; 标识单独的迹线。默认值为0。</target>
        </trans-unit>
        <trans-unit id="8ada4b47638c77da9291a9bd47140e9b15fe504a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_free&lt;/code&gt; and &lt;code&gt;number_of_free&lt;/code&gt; tags are currently only returned on a VxWorks system.</source>
          <target state="translated">该 &lt;code&gt;largest_free&lt;/code&gt; 和 &lt;code&gt;number_of_free&lt;/code&gt; 标签目前只能返回VxWorks系统上。</target>
        </trans-unit>
        <trans-unit id="47c985889700e94be33eba8b924bf9a3dfed0540" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lcnt&lt;/code&gt; module is used to profile the internal ethread locks in the Erlang Runtime System. With &lt;code&gt;lcnt&lt;/code&gt; enabled, internal counters in the runtime system are updated each time a lock is taken. The counters stores information about the number of acquisition tries and the number of collisions that has occurred during the acquisition tries. The counters also record the waiting time a lock has caused for a blocked thread when a collision has occurred.</source>
          <target state="translated">在 &lt;code&gt;lcnt&lt;/code&gt; 模块用于轮廓在Erlang运行时系统中的内部ETHREAD锁。与 &lt;code&gt;lcnt&lt;/code&gt; 启用，在运行时系统的内部计数器的每一个的锁被取时进行更新。计数器存储有关获取尝试次数和获取尝试期间发生的冲突次数的信息。计数器还记录发生冲突时锁导致线程阻塞的等待时间。</target>
        </trans-unit>
        <trans-unit id="b187fc5e5c5e9c948af3fd95dc59f5d10e6fe566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;list_in&lt;/code&gt; 项必须属于环境 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2831975c1bbe04314d3d0e20134569769f4c8e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log_mf_h&lt;/code&gt; handler writes all reports to a report logging directory, which is specified when configuring the SASL application.</source>
          <target state="translated">该 &lt;code&gt;log_mf_h&lt;/code&gt; 处理程序会将所有报告的报告日志目录，这是配置SASL应用程序时指定。</target>
        </trans-unit>
        <trans-unit id="c42c9a83ba0cfd927135745afcf8a51d16e0e657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map_in&lt;/code&gt; term must belong to environment &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;map_in&lt;/code&gt; 项必须属于环境 &lt;code&gt;env&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4596e3e12adaafb27a37675223c89e5e8290b48e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match_fun&lt;/code&gt; takes two arguments and returns either &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;. The value &lt;code&gt;default&lt;/code&gt; will invoke the default match function.</source>
          <target state="translated">该 &lt;code&gt;match_fun&lt;/code&gt; 有两个参数，并返回要么 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 。该值 &lt;code&gt;default&lt;/code&gt; 将调用默认的匹配功能。</target>
        </trans-unit>
        <trans-unit id="8b940d5eaace9d3d7a8384b7f450246290a324ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_path_length&lt;/code&gt; is the maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if &lt;code&gt;max_path_length&lt;/code&gt; is 0, the PEER must be signed by the trusted ROOT-CA directly, if it is 1, the path can be PEER, CA, ROOT-CA, if it is 2, the path can be PEER, CA, CA, ROOT-CA, and so on.</source>
          <target state="translated">该 &lt;code&gt;max_path_length&lt;/code&gt; 是可以遵循的有效证书路径对证书的非自发放的中间证书的最大数量。因此，如果 &lt;code&gt;max_path_length&lt;/code&gt; 为0，则PEER必须直接由受信任的ROOT-CA签名，如果为1，则路径可以为PEER，CA，ROOT-CA，如果为2，则路径可以为PEER，CA， CA，ROOT-CA等。</target>
        </trans-unit>
        <trans-unit id="38b7f85ec648548ce222a27921a129e6b78760bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mib_to_hrl&lt;/code&gt; generator can be invoked from the OS command line by using the command &lt;code&gt;erlc&lt;/code&gt;. &lt;code&gt;erlc&lt;/code&gt; recognizes the extension &lt;code&gt;.bin&lt;/code&gt;, and invokes this function for files with that extension.</source>
          <target state="translated">所述 &lt;code&gt;mib_to_hrl&lt;/code&gt; 发生器可以从OS的命令行通过使用命令调用 &lt;code&gt;erlc&lt;/code&gt; 。 &lt;code&gt;erlc&lt;/code&gt; 识别扩展名 &lt;code&gt;.bin&lt;/code&gt; ，并对具有该扩展名的文件调用此函数。</target>
        </trans-unit>
        <trans-unit id="8c1d578ccfe04ced0a4858e6e98da0fd19d29b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mods_and_procs&lt;/code&gt; and &lt;code&gt;funcs_and_procs&lt;/code&gt; filters are equivalent to the &lt;code&gt;modules&lt;/code&gt; and &lt;code&gt;functions&lt;/code&gt; filters respectively, except that each module or function can have many vertical lines, one for each process it resides on.</source>
          <target state="translated">的 &lt;code&gt;mods_and_procs&lt;/code&gt; 和 &lt;code&gt;funcs_and_procs&lt;/code&gt; 滤波器等同于 &lt;code&gt;modules&lt;/code&gt; 和 &lt;code&gt;functions&lt;/code&gt; 分别过滤器，不同之处在于每个模块或功能可以有许多垂直的线，一个用于每个它驻留在进程。</target>
        </trans-unit>
        <trans-unit id="629670db402f7cde732ec01282578c7159f3daad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; functions of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">该 &lt;code&gt;module&lt;/code&gt; 选件能够为用户提供他们自己的回调模块。当接收到新消息时，将调用此模块的 &lt;code&gt;receive_message/4&lt;/code&gt; 或 &lt;code&gt;process_received_message/4&lt;/code&gt; 函数（取决于消息的大小；小-receive_message，大-process_received_message）。默认值为&lt;strong&gt;megaco&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4039dc8c38a872b706a72298a0693bdeed53b2b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; option makes it possible for the user to provide their own callback module. The functions &lt;code&gt;receive_message/4&lt;/code&gt; or &lt;code&gt;process_received_message/4&lt;/code&gt; of this module is called when a new message is received (which one depends on the size of the message; small - receive_message, large - process_received_message). Default value is &lt;strong&gt;megaco&lt;/strong&gt;.</source>
          <target state="translated">该 &lt;code&gt;module&lt;/code&gt; 选件能够为用户提供他们自己的回调模块。当接收到新消息时，将调用此模块的函数 &lt;code&gt;receive_message/4&lt;/code&gt; 或 &lt;code&gt;process_received_message/4&lt;/code&gt; （取决于消息的大小；其中小-receive_message，大-process_received_message）。默认值为&lt;strong&gt;megaco&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1fa747bd68db4bc817397fca349049b0c0c2bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_info/0&lt;/code&gt; function in each module, returns a list of &lt;code&gt;{Key,Value}&lt;/code&gt; tuples with information about the module. Currently, the list contain tuples with the following &lt;code&gt;Key&lt;/code&gt;s: &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt;, &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;md5&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;. The order and number of tuples may change without prior notice.</source>
          <target state="translated">每个模块中的 &lt;code&gt;module_info/0&lt;/code&gt; 函数返回 &lt;code&gt;{Key,Value}&lt;/code&gt; 元组的列表，其中包含有关该模块的信息。当前，列表包含具有以下 &lt;code&gt;Key&lt;/code&gt; 的元组： &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;attributes&lt;/code&gt; ， &lt;code&gt;compile&lt;/code&gt; ， &lt;code&gt;exports&lt;/code&gt; ， &lt;code&gt;md5&lt;/code&gt; 和 &lt;code&gt;native&lt;/code&gt; 。元组的顺序和数量如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="13c3af4d94c692779fc270d51ec8836243a76c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; filter shows each module as a vertical line in the sequence diagram. External function calls/returns are shown as interactions between modules, and internal function calls/returns are shown as activities within a module.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 过滤器示出了每个模块作为序列图的垂直线。外部函数调用/返回显示为模块之间的交互，内部函数调用/返回显示为模块内的活动。</target>
        </trans-unit>
        <trans-unit id="220a661131b4c202e09615fa7794089d54019aa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not given, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 关键是可选的。如果未给出，则默认为 &lt;code&gt;[M]&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 来自孩子的开头 &lt;code&gt;{M,F,A}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3890e0d50c45d6e12a18dbc1aec19b335349f526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modules&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;[M]&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; comes from the child's start &lt;code&gt;{M,F,A}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;modules&lt;/code&gt; 关键是可选的。如果未指定，则默认为 &lt;code&gt;[M]&lt;/code&gt; ，其中 &lt;code&gt;M&lt;/code&gt; 来自孩子的开头 &lt;code&gt;{M,F,A}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b73b08f6879f5bf7ade5d9880f8cf1f512709fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;native&lt;/code&gt; time unit is determined at runtime system start, and remains the same until the runtime system terminates. If a runtime system is stopped and then started again (even on the same machine), the &lt;code&gt;native&lt;/code&gt; time unit of the new runtime system instance can differ from the &lt;code&gt;native&lt;/code&gt; time unit of the old runtime system instance.</source>
          <target state="translated">所述 &lt;code&gt;native&lt;/code&gt; 时间单元在运行时系统开始确定，并且保持相同，直到运行时系统终止。如果运行时系统会停止，然后再次启动（即使是在同一台机器上），在 &lt;code&gt;native&lt;/code&gt; 的新的运行时系统实例的时间单位可以从不同的 &lt;code&gt;native&lt;/code&gt; 老运行系统实例的时间单位。</target>
        </trans-unit>
        <trans-unit id="e77d232e74f552cf373975f9713b96716de00e8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_kernel&lt;/code&gt; process terminated.</source>
          <target state="translated">所述 &lt;code&gt;net_kernel&lt;/code&gt; 过程终止。</target>
        </trans-unit>
        <trans-unit id="33c94a1185ccb7943d79b55ac568ef3bf3963cc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;net_ticktime&lt;/code&gt; changes must be initiated on all nodes in the network (with the same &lt;code&gt;NetTicktime&lt;/code&gt;) before the end of any transition period on any node; otherwise connections can erroneously be disconnected.</source>
          <target state="translated">所述 &lt;code&gt;net_ticktime&lt;/code&gt; 变化必须在网络中的所有节点（具有相同的上启动 &lt;code&gt;NetTicktime&lt;/code&gt; 任何节点上的任何过渡期结束前）; 否则可能会错误地断开连接。</target>
        </trans-unit>
        <trans-unit id="88d35276b805d419b7b2b451eec9f43dfbe3fb9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;reuse&lt;/code&gt; options might seem convenient in a production system, but consider that the logs grow indefinitely during the system lifetime and cannot be truncated, except if the service is restarted.</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;reuse&lt;/code&gt; 的选项似乎在生产系统中方便，但考虑到该日志的系统生命周期内无限增长，不能被截断，除非重新启动该服务。</target>
        </trans-unit>
        <trans-unit id="ffcaa93ee15ba09c39cb246f4b83efb0388fde54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates a new variable in the database with a default value as defined in the MIB, or a zero value (depending on the type).</source>
          <target state="translated">的 &lt;code&gt;new&lt;/code&gt; 函数创建与在MIB中定义的默认值，或零值（取决于类型）数据库中的一个新的变量。</target>
        </trans-unit>
        <trans-unit id="2000d16d511f7d3865cad4dec402c68d50d75e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; function creates the table if it does not exist, but only if the database is the SNMP internal db.</source>
          <target state="translated">该 &lt;code&gt;new&lt;/code&gt; 功能创建表，如果它不存在，但只有当数据库是SNMP内部分贝。</target>
        </trans-unit>
        <trans-unit id="fe241cbaac0cb96b60c93ae96dc9889cf2b5f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nteventlog&lt;/code&gt; module is used to implement &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt;. Note that the start functions of &lt;code&gt;nteventlog&lt;/code&gt; does not need to be used, in this case the process is started automatically as part of the OS_Mon supervision tree.</source>
          <target state="translated">该 &lt;code&gt;nteventlog&lt;/code&gt; 模块用于实现 &lt;code&gt;os_sup&lt;/code&gt; 。参见 &lt;code&gt;&lt;a href=&quot;nteventlog&quot;&gt;nteventlog(3)&lt;/a&gt;&lt;/code&gt; 。请注意，不需要使用 &lt;code&gt;nteventlog&lt;/code&gt; 的启动功能，在这种情况下，该过程将作为OS_Mon监视树的一部分自动启动。</target>
        </trans-unit>
        <trans-unit id="e2bfdbeebfa5a9fe7cf75fe729c76e05070db8fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is a pointer to the resource. The only allowed use for the resource in the destructor is to access its user data one final time. The destructor is guaranteed to be the last callback before the resource is deallocated.</source>
          <target state="translated">该 &lt;code&gt;obj&lt;/code&gt; 参数是指向该资源。析构函数中对资源的唯一允许使用是最后一次访问其用户数据。保证析构函数是释放资源之前的最后一个回调。</target>
        </trans-unit>
        <trans-unit id="7ceb6922f1bc2b55a11a196aefd83fd27d2d6cd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; if no chain of calls between the given constants can be found.</source>
          <target state="translated">的 &lt;code&gt;of&lt;/code&gt; 操作符返回 &lt;code&gt;false&lt;/code&gt; ，如果没有给定的常数之间的调用链都可以找到。</target>
        </trans-unit>
        <trans-unit id="edc8f1a9759344cda2be6a01281eb7cf8541e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;after&lt;/code&gt; sections are all optional, as long as there is at least a &lt;code&gt;catch&lt;/code&gt; or an &lt;code&gt;after&lt;/code&gt; section. So the following are valid &lt;code&gt;try&lt;/code&gt; expressions:</source>
          <target state="translated">所述 &lt;code&gt;of&lt;/code&gt; ， &lt;code&gt;catch&lt;/code&gt; ，和 &lt;code&gt;after&lt;/code&gt; 段都是可选的，只要有至少一个 &lt;code&gt;catch&lt;/code&gt; 或 &lt;code&gt;after&lt;/code&gt; 部。因此，以下是有效的 &lt;code&gt;try&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="ebc057ad457a36d0493c7c4827deec0d89f9db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;oid()&lt;/code&gt; type is used to represent an ASN.1 OBJECT IDENTIFIER.</source>
          <target state="translated">的 &lt;code&gt;oid()&lt;/code&gt; 类型用于代表一个ASN.1对象标识符。</target>
        </trans-unit>
        <trans-unit id="c317ddfbc946c81f789ac77305cd9d495bd67257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ordered_set&lt;/code&gt; works on the &lt;strong&gt;Erlang term order&lt;/strong&gt; and no defined order exists between an &lt;code&gt;integer()&lt;/code&gt; and a &lt;code&gt;float()&lt;/code&gt; that extends to the same value. Hence the key &lt;code&gt;1&lt;/code&gt; and the key &lt;code&gt;1.0&lt;/code&gt; are regarded as equal in an &lt;code&gt;ordered_set&lt;/code&gt; table.</source>
          <target state="translated">的 &lt;code&gt;ordered_set&lt;/code&gt; 的运作上&lt;strong&gt;Erlang项顺序&lt;/strong&gt;和一个之间不存在定义的顺序 &lt;code&gt;integer()&lt;/code&gt; 和 &lt;code&gt;float()&lt;/code&gt; 延伸到相同的值。因此，键 &lt;code&gt;1&lt;/code&gt; 和键 &lt;code&gt;1.0&lt;/code&gt; 在 &lt;code&gt;ordered_set&lt;/code&gt; 表中被视为相等。</target>
        </trans-unit>
        <trans-unit id="23f84a949184c1de5bc030233161e9c4c0b92121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;originating&lt;/code&gt; options effects discovery initiated by this agent.</source>
          <target state="translated">在 &lt;code&gt;originating&lt;/code&gt; 此代理启动选项效应的发现。</target>
        </trans-unit>
        <trans-unit id="ccd973135b90cc097810c0c2b724141ea8487e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; syntax:</source>
          <target state="translated">该 &lt;code&gt;otp_patch_apply&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="8bdd7004ea407fa82763663af39ba15a0e1f25f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;otp_patch_apply&lt;/code&gt; tool utilizes the &lt;code&gt;runtime_dependencies&lt;/code&gt; tag in the &lt;code&gt;application resource file&lt;/code&gt;. This information is used to determine if the patch can be installed in the given Erlang/OTP installation directory.</source>
          <target state="translated">该 &lt;code&gt;otp_patch_apply&lt;/code&gt; 工具利用 &lt;code&gt;runtime_dependencies&lt;/code&gt; 在标签 &lt;code&gt;application resource file&lt;/code&gt; 。此信息用于确定是否可以在给定的Erlang / OTP安装目录中安装补丁。</target>
        </trans-unit>
        <trans-unit id="8315d03358900e027c0447a981ac995840fffee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; function allocates the work area of the asynchronous function. As we use C++, we use a struct, and stuff the data in it. We must copy the original data, it is not valid after we have returned from the &lt;code&gt;output&lt;/code&gt; function, and the &lt;code&gt;do_perm&lt;/code&gt; function is called later, and from another thread. We return no data here, instead it is sent later from the &lt;code&gt;ready_async&lt;/code&gt; callback.</source>
          <target state="translated">该 &lt;code&gt;output&lt;/code&gt; 功能分配异步函数的工作区。在使用C ++时，我们使用一个结构，并将数据填充到其中。我们必须复制原始数据，从 &lt;code&gt;output&lt;/code&gt; 函数返回后，它无效，然后稍后再从另一个线程调用 &lt;code&gt;do_perm&lt;/code&gt; 函数。我们在这里不返回任何数据，而是稍后从 &lt;code&gt;ready_async&lt;/code&gt; 回调发送该数据。</target>
        </trans-unit>
        <trans-unit id="71aa4ffe227f9aa33da51854c389c54a822efeef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; format is an internal representation that can be passed to &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;forms&lt;/code&gt; format can be passed to &lt;code&gt;compile:forms/2&lt;/code&gt;. The &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;hrl&lt;/code&gt; formats are returned as iolists.</source>
          <target state="translated">的 &lt;code&gt;parse&lt;/code&gt; 格式是可以传递到内部表示 &lt;code&gt;&lt;a href=&quot;#flatten-1&quot;&gt;flatten/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;forms&lt;/code&gt; 格式可以传递给 &lt;code&gt;compile:forms/2&lt;/code&gt; 。该 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;hrl&lt;/code&gt; 格式返回iolists。</target>
        </trans-unit>
        <trans-unit id="9ac6e1b83188e6ba00253b80c4e4e283b31e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option is used for pointing out the old version of all applications. (The new versions are already in the code path - assuming of course that the Erlang node on which this is executed is running the correct version of Erlang/OTP.)</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 选项用于指明了旧版本的所有应用程序。（新版本已在代码路径中-当然，要假定执行此操作的Erlang节点正在运行正确版本的Erlang / OTP。）</target>
        </trans-unit>
        <trans-unit id="24e00a9507fa707a286aad7abe3e3cd07325080a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pending_driver&lt;/code&gt;&lt;code&gt;MonitorOption&lt;/code&gt; is by far the most useful. It must be used to ensure that the driver really is unloaded and the ports closed whenever option &lt;code&gt;kill_ports&lt;/code&gt; is used, or the driver can have been loaded with driver option &lt;code&gt;kill_ports&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;pending_driver&lt;/code&gt; &lt;code&gt;MonitorOption&lt;/code&gt; 是迄今为止最有用的。每当使用选项 &lt;code&gt;kill_ports&lt;/code&gt; 或可以使用驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 加载驱动程序时，必须使用它来确保确实卸载了驱动程序并关闭了端口。</target>
        </trans-unit>
        <trans-unit id="f36e06928220660615452de6fef2258f5362fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perf_counter&lt;/code&gt; time unit behaves much in the same way as the &lt;code&gt;native&lt;/code&gt; time unit. That is, it can differ between runtime restarts. To get values of this type, call &lt;code&gt;os:perf_counter/0&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;perf_counter&lt;/code&gt; 时间单位的行为多以同样的方式为 &lt;code&gt;native&lt;/code&gt; 时间单位。也就是说，运行时重新启动之间可能有所不同。要获取此类型的值，请调用 &lt;code&gt;os:perf_counter/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ff6f3b7d18bc68a03a8f098e3306bea8afa3388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pread/3,4&lt;/code&gt; function reads from a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;pread/3,4&lt;/code&gt; 函数从指定的位置读出，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#read-3&quot;&gt;read/3,4&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="8ade504b785b0942df35eaf3b82afa6476a54cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;priv&lt;/code&gt; directory holds assets that the application needs during runtime. Executables should reside in &lt;code&gt;priv/bin&lt;/code&gt; and dynamically-linked libraries should reside in &lt;code&gt;priv/lib&lt;/code&gt;. Other assets are free to reside within the &lt;code&gt;priv&lt;/code&gt; directory but it is recommended it does so in a structured manner.</source>
          <target state="translated">在 &lt;code&gt;priv&lt;/code&gt; 目录保存资产，应用程序运行时的需要。可执行文件应驻留在 &lt;code&gt;priv/bin&lt;/code&gt; 中,而动态链接的库应驻留在 &lt;code&gt;priv/lib&lt;/code&gt; 中。其他资产可以自由地驻留在 &lt;code&gt;priv&lt;/code&gt; 目录中，但是建议以结构化的方式这样做。</target>
        </trans-unit>
        <trans-unit id="a744587962b51e3c606263db57ff07f274e44a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processes&lt;/code&gt; filter is the only filter showing all trace messages from a trace log. Each vertical line in the sequence diagram represents a process. Erlang messages, spawn, and link/unlink are typical interactions between processes. Function calls, scheduling, and garbage collection, are typical activities within a process. &lt;code&gt;processes&lt;/code&gt; is the default filter.</source>
          <target state="translated">该 &lt;code&gt;processes&lt;/code&gt; 滤波器是表示从跟踪日志中的所有跟踪消息的唯一的过滤器。顺序图中的每条垂直线代表一个过程。Erlang消息，生成和链接/取消链接是进程之间的典型交互。函数调用，调度和垃圾回收是流程中的典型活动。 &lt;code&gt;processes&lt;/code&gt; 是默认过滤器。</target>
        </trans-unit>
        <trans-unit id="3861f99e16c84fe5707ca3129e815480d2eca579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwrite/3,4&lt;/code&gt; function writes to a specified position, combining the &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">所述 &lt;code&gt;pwrite/3,4&lt;/code&gt; 函数写入到一个指定的位置，结合 &lt;code&gt;&lt;a href=&quot;#position-3&quot;&gt;position/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#write-3&quot;&gt;write/3,4&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="a4939b64de1d53ed04f7d5997288438bc45d2be8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module evaluates this differently depending on the query handles &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;. If, for example, &lt;code&gt;X2&lt;/code&gt; is matched against the key of a QLC table, the lookup join method traverses the objects of &lt;code&gt;QH2&lt;/code&gt; while looking up key values in the table. However, if not &lt;code&gt;X2&lt;/code&gt; or &lt;code&gt;Y2&lt;/code&gt; is matched against the key or an indexed position of a QLC table, the merge join method ensures that &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; are both sorted on position 2 and next do the join by traversing the objects one by one.</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块评估此不同，这取决于查询处理 &lt;code&gt;QH1&lt;/code&gt; 和 &lt;code&gt;QH2&lt;/code&gt; 。例如，如果 &lt;code&gt;X2&lt;/code&gt; 与QLC表的键匹配，则查找联接方法将在查找表中的键值时遍历 &lt;code&gt;QH2&lt;/code&gt; 的对象。但是，如果 &lt;code&gt;X2&lt;/code&gt; 或 &lt;code&gt;Y2&lt;/code&gt; 没有与QLC表的键或索引位置匹配，则合并 &lt;code&gt;QH1&lt;/code&gt; 方法可确保QH1和 &lt;code&gt;QH2&lt;/code&gt; 都在位置2上排序，然后通过逐个遍历对象来进行联接。</target>
        </trans-unit>
        <trans-unit id="7bdc283a4e0d387d9b4fe3c9cce9b3813bddfd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module supports fast join of two query handles. Fast join is possible if some position &lt;code&gt;P1&lt;/code&gt; of one query handler and some position &lt;code&gt;P2&lt;/code&gt; of another query handler are tested for equality. Two fast join methods are provided:</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块支持快速连接两个查询句柄。快速连接是可能的，如果某些位置 &lt;code&gt;P1&lt;/code&gt; 一个查询处理程序和一些位置 &lt;code&gt;P2&lt;/code&gt; 另一个查询处理的都是平等的测试。提供了两种快速连接方法：</target>
        </trans-unit>
        <trans-unit id="4dc69ce9649099f1a16568929e4dca5a9ec4a8ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qlc&lt;/code&gt; module warns at compile time if a QLC combines query handles in such a way that more than one join is possible. That is, no query planner is provided that can select a good order between possible join operations. It is up to the user to order the joins by introducing query handles.</source>
          <target state="translated">该 &lt;code&gt;qlc&lt;/code&gt; 模块警告在编译时如果QLC联合查询以这样的方式来处理多个连接是可能的。也就是说，没有提供可以在可能的联接操作之间选择良好顺序的查询计划器。用户可以通过引入查询句柄来对联接进行排序。</target>
        </trans-unit>
        <trans-unit id="1ac4329d09995d8cc50dafbae48fcd60ee3ef172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re&lt;/code&gt; module allows for matching Unicode strings as a special option. As the library is centered on matching in binaries, the Unicode support is UTF-8-centered.</source>
          <target state="translated">在 &lt;code&gt;re&lt;/code&gt; 模块允许符合Unicode字符串作为一个特殊的选项。由于库的重点是二进制匹配，因此Unicode支持以UTF-8为中心。</target>
        </trans-unit>
        <trans-unit id="412cfcfb79171f8451db72dbfc6769aeeae48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_ahead&lt;/code&gt; buffer is also highly used by function &lt;code&gt;read_line/1&lt;/code&gt; in &lt;code&gt;raw&lt;/code&gt; mode, therefore this option is recommended (for performance reasons) when accessing raw files using that function.</source>
          <target state="translated">所述 &lt;code&gt;read_ahead&lt;/code&gt; 缓冲器也被高度使用功能 &lt;code&gt;read_line/1&lt;/code&gt; 中 &lt;code&gt;raw&lt;/code&gt; 使用该函数访问原始文件时模式，因此建议该选项（出于性能原因）。</target>
        </trans-unit>
        <trans-unit id="1d7e68fecfc79e8020cc09ac14cad9865216cb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_io&lt;/code&gt; function is called when the socket we got from postgres is ready for input or output. Here we first check if we are connecting to the database. In that case, we check connection status and return OK if the connection is successful, or error if it is not. If the connection is not yet established, we simply return; &lt;code&gt;ready_io&lt;/code&gt; is called again.</source>
          <target state="translated">该 &lt;code&gt;ready_io&lt;/code&gt; 当我们从Postgres的拿到插槽中可以输入或输出函数被调用。在这里，我们首先检查是否要连接到数据库。在这种情况下，我们将检查连接状态，如果连接成功则返回OK，否则返回错误。如果尚未建立连接，我们只返回即可； &lt;code&gt;ready_io&lt;/code&gt; 再次被调用。</target>
        </trans-unit>
        <trans-unit id="c5f336c46236fef6d33a9737fecfbc45848cc85a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; construct is used to allow processes to wait for messages from other processes. It has the following format:</source>
          <target state="translated">所述 &lt;code&gt;receive&lt;/code&gt; 结构用于允许进程等待来自其它进程的消息。它具有以下格式：</target>
        </trans-unit>
        <trans-unit id="37481113af1fc6bf67ec51a1b4573b5766d4940d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receive&lt;/code&gt; expression can be augmented with a timeout:</source>
          <target state="translated">所述 &lt;code&gt;receive&lt;/code&gt; 表达可以与一个超时来增强：</target>
        </trans-unit>
        <trans-unit id="42725fa1b02c7390bf310c7b5f650def33047bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;receiver&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">首先将向 &lt;code&gt;receiver&lt;/code&gt; 发送 &lt;code&gt;snmp_targets&lt;/code&gt; 消息，然后为&amp;ldquo; &lt;code&gt;Addresses&lt;/code&gt; 列表中的每个地址发送两个 &lt;code&gt;snmp_notification&lt;/code&gt; 消息之一。</target>
        </trans-unit>
        <trans-unit id="e35f7f5fad0e5d56316957219823696de6e6786c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refc&lt;/code&gt; field has been removed. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; is now stored elsewhere. The reference count of an &lt;code&gt;ErlDrvBinary&lt;/code&gt; can be accessed through &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;refc&lt;/code&gt; 场已被删除。 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 的引用计数现在存储在其他位置。一个的引用计数 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 可以通过被访问 &lt;code&gt;&lt;a href=&quot;#driver_binary_get_refc&quot;&gt;driver_binary_get_refc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#driver_binary_inc_refc&quot;&gt;driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;#driver_binary_dec_refc&quot;&gt;driver_binary_dec_refc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="660ed54d5ac1fcd2169600b38b40bd925d66cf86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_handler&lt;/code&gt; copies these files to the &lt;code&gt;bin&lt;/code&gt; directory in the client directory at the master nodes whenever a new release is made permanent.</source>
          <target state="translated">每当使新发行版成为永久发行版时， &lt;code&gt;release_handler&lt;/code&gt; 会将这些文件复制到主节点上客户端目录中的 &lt;code&gt;bin&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="56830d582041a2d058cd8b9ca80ec725e5c3e287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reload&lt;/code&gt; option can be either of the following:</source>
          <target state="translated">该 &lt;code&gt;reload&lt;/code&gt; 选项可以是以下几点：</target>
        </trans-unit>
        <trans-unit id="207c0a4a6dd7d54555e6c470a0c170ec46378f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains instructions for how to upgrade to, or downgrade from, this version of the release.</source>
          <target state="translated">该 &lt;code&gt;relup&lt;/code&gt; 文件包含如何升级到，或从该版本的发布的降级说明。</target>
        </trans-unit>
        <trans-unit id="eb051013f36a233ac41b404b8075c071558087a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relup&lt;/code&gt; file contains one single Erlang term, which defines the instructions used to upgrade the release. The file has the following syntax:</source>
          <target state="translated">该 &lt;code&gt;relup&lt;/code&gt; 文件包含一个单一的Erlang项，它定义了用于升级版本的说明。该文件具有以下语法：</target>
        </trans-unit>
        <trans-unit id="d56076bd8991e00d489d3da464bc1ef66915e244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply_timer&lt;/code&gt; eventually times out.</source>
          <target state="translated">最后， &lt;code&gt;reply_timer&lt;/code&gt; 超时。</target>
        </trans-unit>
        <trans-unit id="3918ee266b06587588695e693fc72ac650418ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;permanent&lt;/code&gt; will be used.</source>
          <target state="translated">该 &lt;code&gt;restart&lt;/code&gt; 键是可选的。如果未给出，将使用默认值 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa12db49496616557ec440b620daa191bf27cdc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;restart&lt;/code&gt; 键是可选的。如果未指定，则默认为 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6a92effc8d3efc4277861eec34f0f1caed07816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction must always be the first instruction in a relup. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">该 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令必须始终在relup的第一条指令。如果relup由 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成，则会自动确保。</target>
        </trans-unit>
        <trans-unit id="11d3f640ffec2cfdf0c8a6e928ab7cecff319eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_erl&lt;/code&gt; program is specific to Unix systems. This program redirects the standard input and standard output streams so that all output can be logged. It also lets the program &lt;code&gt;to_erl&lt;/code&gt; connect to the Erlang console, making it possible to monitor and debug an embedded system remotely.</source>
          <target state="translated">该 &lt;code&gt;run_erl&lt;/code&gt; 方案是专门针对Unix系统。该程序重定向标准输入和标准输出流，以便可以记录所有输出。它还使程序 &lt;code&gt;to_erl&lt;/code&gt; 连接到Erlang控制台，从而可以远程监视和调试嵌入式系统。</target>
        </trans-unit>
        <trans-unit id="750c30ae5ba824b2f2aab4a171c99b419364a053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runtime_dependencies&lt;/code&gt; key was introduced in OTP 17.0. The type of its value might be subject to changes during the OTP 17 release.</source>
          <target state="translated">该 &lt;code&gt;runtime_dependencies&lt;/code&gt; 关键是在OTP 17.0介绍。在OTP 17发行期间，其值的类型可能会发生更改。</target>
        </trans-unit>
        <trans-unit id="49d8491d2a1375817a9cf2b814c2646acf960284" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sasl&lt;/code&gt; application includes the example Erlang module &lt;code&gt;target_system.erl&lt;/code&gt;, which contains functions for creating and installing a target system. This module is used in the following examples. The source code of the module is listed in &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;sasl&lt;/code&gt; 应用程序包括例如二郎模块 &lt;code&gt;target_system.erl&lt;/code&gt; ，其中包含用于创建和安装目标系统的功能。在以下示例中使用此模块。该模块的源代码在 &lt;code&gt;&lt;a href=&quot;#listing%20of%20target%20system&quot;&gt;Listing of target_system.erl&lt;/a&gt;&lt;/code&gt; 列出。</target>
        </trans-unit>
        <trans-unit id="3906ed9fb14f8072e02da2d35e2b47f21b0a6292" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; expression matches all entries in table employee with the field &lt;code&gt;sex&lt;/code&gt; set to &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;select&lt;/code&gt; 表达式匹配与田间表员工所有条目 &lt;code&gt;sex&lt;/code&gt; 设定为 &lt;code&gt;female&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5c2c9e1f5cbdb80c6a7e6b52821b6b12fa676f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; flags enable tracing of all messages sent and received by the process/port. Trace patterns set with &lt;code&gt;tpe&lt;/code&gt; may limit traced messages based on the message content, the sender, and/or the receiver.</source>
          <target state="translated">的 &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 标志使所有消息的跟踪发送并且由处理/端口接收。使用 &lt;code&gt;tpe&lt;/code&gt; 设置的跟踪模式可能会根据消息内容，发送者和/或接收者来限制跟踪的消息。</target>
        </trans-unit>
        <trans-unit id="0233a943ab6f52106ec90bb0ab714ed2cd9deb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; call does not accept a time-out option because time-outs on send is handled through socket option &lt;code&gt;send_timeout&lt;/code&gt;. The behavior of a send operation with no receiver is mainly defined by the underlying TCP stack and the network infrastructure. To write code that handles a hanging receiver that can eventually cause the sender to hang on a &lt;code&gt;send&lt;/code&gt; do like the following.</source>
          <target state="translated">在 &lt;code&gt;send&lt;/code&gt; 因为发送超时通过套接字选项处理的呼叫不接受超时选项 &lt;code&gt;send_timeout&lt;/code&gt; 。没有接收者的发送操作的行为主要由基础TCP堆栈和网络基础结构定义。要编写处理挂起的接收方的代码，最终可能导致发送方挂起 &lt;code&gt;send&lt;/code&gt; 请执行以下操作。</target>
        </trans-unit>
        <trans-unit id="bdcf831f5f9a895f78c5ead8d39eb67c53d11a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_notification/6&lt;/code&gt; function is the most general version of the function. A &lt;code&gt;ContextName&lt;/code&gt; must be specified, from which the notification will be sent. If this parameter is not specified, the default context (&lt;code&gt;&quot;&quot;&lt;/code&gt;) is used.</source>
          <target state="translated">该 &lt;code&gt;send_notification/6&lt;/code&gt; 功能是函数的最普遍的版本。必须指定一个 &lt;code&gt;ContextName&lt;/code&gt; ，从中将发送通知。如果未指定此参数，则使用默认上下文（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e10004941e2f7c2be1fb735798912ba806d773f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_out_queue&lt;/code&gt; routine is as follows:</source>
          <target state="translated">该 &lt;code&gt;send_out_queue&lt;/code&gt; 程序如下：</target>
        </trans-unit>
        <trans-unit id="843b939f65952e899d6ea657ca1ebe102c72dbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; module corresponds, greatly simplified, to the Erlang/OTP behaviour &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;server&lt;/code&gt; 模块对应，极大地简化，所述的Erlang / OTP行为 &lt;code&gt;gen_server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eede287bf30328bbe010a8372b63b7607963a54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; commands modifies or adds an Erlang service, respectively. The simplest form of an &lt;code&gt;add&lt;/code&gt; command is without any options in which case all default values (described above) apply. The service name is mandatory.</source>
          <target state="translated">的 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;add&lt;/code&gt; 分别命令修改或添加一个Erlang服务。 &lt;code&gt;add&lt;/code&gt; 命令的最简单形式是不带任何选项，在这种情况下，所有默认值（如上所述）都适用。服务名称是必填项。</target>
        </trans-unit>
        <trans-unit id="7d5aec8c53556f4c4632141415f220fd68b8daa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function checks if it has enough information to make the row change its status from &lt;code&gt;notReady&lt;/code&gt; to &lt;code&gt;notInService&lt;/code&gt; (when a row has been been set to &lt;code&gt;createAndWait&lt;/code&gt;). If a row is set to &lt;code&gt;createAndWait&lt;/code&gt;, columns without a value are set to &lt;code&gt;noinit&lt;/code&gt;. If Mnesia is used, the set functionality is handled within a transaction.</source>
          <target state="translated">该 &lt;code&gt;set&lt;/code&gt; 功能检查是否有足够的信息，使该行改变其状态 &lt;code&gt;notReady&lt;/code&gt; ，以 &lt;code&gt;notInService&lt;/code&gt; （当行已被设置为 &lt;code&gt;createAndWait&lt;/code&gt; ）。如果将一行设置为 &lt;code&gt;createAndWait&lt;/code&gt; ，则将没有值的列设置为 &lt;code&gt;noinit&lt;/code&gt; 。如果使用Mnesia，则在交易中处理设置的功能。</target>
        </trans-unit>
        <trans-unit id="dffce6a86883fb98a441ee618f3e33a10bd8dd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_on_spawn&lt;/code&gt; option will active call time tracing for all processes spawned by processes in the rootset. This is the default behaviour.</source>
          <target state="translated">该 &lt;code&gt;set_on_spawn&lt;/code&gt; 选项将通过在rootset过程中产生的所有进程当前通话时间跟踪。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="d7ea8237fdbb6c1e6e9cad779100829368078340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not given, and the child is of type &lt;code&gt;worker&lt;/code&gt;, the default value &lt;code&gt;5000&lt;/code&gt; will be used; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;, the default value &lt;code&gt;infinity&lt;/code&gt; will be used.</source>
          <target state="translated">在 &lt;code&gt;shutdown&lt;/code&gt; 键是可选的。如果未给出，并且子 &lt;code&gt;worker&lt;/code&gt; 类型，则将使用默认值 &lt;code&gt;5000&lt;/code&gt; ；否则，将使用默认值。如果子项是 &lt;code&gt;supervisor&lt;/code&gt; 类型，则将使用默认值 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb49de51c4b23fb4081f3a3f48b32fd97395704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shutdown&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;5000&lt;/code&gt; if the child is of type &lt;code&gt;worker&lt;/code&gt; and it defaults to &lt;code&gt;infinity&lt;/code&gt; if the child is of type &lt;code&gt;supervisor&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;shutdown&lt;/code&gt; 键是可选的。如果未指定，则在子类型为 &lt;code&gt;worker&lt;/code&gt; 的情况下默认为 &lt;code&gt;5000&lt;/code&gt; ，在子类型为 &lt;code&gt;supervisor&lt;/code&gt; 的情况下默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38a6562eb72c50374e4148dda56f4f2798a51836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;silent&lt;/code&gt; trace flag facilitates setting up a trace on many or even all processes in the system. The trace can then be activated and deactivated using the match specification function &lt;code&gt;{silent,Bool}&lt;/code&gt;, giving a high degree of control of which functions with which arguments that trigger the trace.</source>
          <target state="translated">在 &lt;code&gt;silent&lt;/code&gt; 跟踪标志有利于建立许多甚至在系统中的所有进程痕迹。然后可以使用匹配规范函数 &lt;code&gt;{silent,Bool}&lt;/code&gt; 激活和停用跟踪，从而高度控制哪些函数使用哪些参数来触发跟踪。</target>
        </trans-unit>
        <trans-unit id="57bdb45fe915c31143be502180221ee741783591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field changed from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">在 &lt;code&gt;size&lt;/code&gt; 从变化领域签署无符号。如果仅在各处更改类型，则可能会导致例如循环终止条件或错误条件的问题。</target>
        </trans-unit>
        <trans-unit id="240a989a5bf707c990bcb78e115aed91f3f04714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; field in &lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; has been changed to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; from &lt;code&gt;int&lt;/code&gt;. Check all code that use that field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ErlIOVec&quot;&gt;ErlIOVec&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;size&lt;/code&gt; 字段已从 &lt;code&gt;int&lt;/code&gt; 更改为 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 。检查使用该字段的所有代码。</target>
        </trans-unit>
        <trans-unit id="a337f162f4c8e035168099f55089fef2894d81f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; directory could be useful to release for debugging purposes but is not required. The &lt;code&gt;include&lt;/code&gt; directory should only be released if the applications has public include files.</source>
          <target state="translated">在 &lt;code&gt;src&lt;/code&gt; 目录可能会释放用于调试的目的，但不是必需的有用。在 &lt;code&gt;include&lt;/code&gt; 如果应用程序具有公共包含文件的目录应该只被释放。</target>
        </trans-unit>
        <trans-unit id="fc13993adad718eae8701221afde4693b532449e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ssh&lt;/code&gt; application is an implementation of the SSH Transport, Connection and Authentication Layer Protocols in Erlang. It provides the following:</source>
          <target state="translated">在 &lt;code&gt;ssh&lt;/code&gt; 应用程序是SSH运输，在二郎山连接和认证层协议的实现。它提供以下内容：</target>
        </trans-unit>
        <trans-unit id="8f65d2a2ea4f4fd44a5c098586ac285ac95cdefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; commands communicates with the service manager for starting and stopping a service. The commands wait until the service is started or stopped. When disabling a service, it is not stopped, the disabled state does not take effect until the service is stopped. Enabling a service sets it in automatic mode, which is started at boot. This command cannot set the service to manual.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 的服务管理器的命令通信来启动和停止服务。命令等待，直到服务启动或停止。禁用服务时，它不会停止，禁用状态直到服务停止后才生效。启用服务会将其设置为自动模式，该模式在启动时启动。此命令无法将服务设置为手动。</target>
        </trans-unit>
        <trans-unit id="d1f3d732c30aec74a57c16dda04003bb1543c716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; entry is called when the driver is opened as a port with &lt;code&gt;open_port/2&lt;/code&gt;. Here we allocate memory for a user data structure. This user data is passed every time the emulator calls us. First we store the driver handle, as it is needed in later calls. We allocate memory for the connection handle that is used by LibPQ. We also set the port to return allocated driver binaries, by setting flag &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, calling &lt;code&gt;set_port_control_flags&lt;/code&gt;. (This is because we do not know if our data will fit in the result buffer of &lt;code&gt;control&lt;/code&gt;, which has a default size, 64 bytes, set up by the emulator.)</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 时，驾驶员被打开了端口条目被称为 &lt;code&gt;open_port/2&lt;/code&gt; 。在这里，我们为用户数据结构分配内存。每次模拟器调用我们时，都会传递此用户数据。首先，我们存储驱动程序句柄，这在以后的调用中是必需的。我们为LibPQ使用的连接句柄分配内存。我们还通过设置标志 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 并调用 &lt;code&gt;set_port_control_flags&lt;/code&gt; 来设置端口以返回分配的驱动程序二进制文件。（这是因为我们不知道数据是否适合 &lt;code&gt;control&lt;/code&gt; 的结果缓冲区，该缓冲区的默认大小为64字节，由模拟器设置。）</target>
        </trans-unit>
        <trans-unit id="f756fe51eb87c21305c2536fa74b5434575da4c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; key is mandatory.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 关键是强制性的。</target>
        </trans-unit>
        <trans-unit id="7a89df12694a55231dbe9df289731067f34bf0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; program is called when the machine is started.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 时，机器启动程序被调用。</target>
        </trans-unit>
        <trans-unit id="34d8bb2f8c095328e05b319382abf621840539e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is an example script on how to start up the Erlang system in embedded mode on Unix.</source>
          <target state="translated">该 &lt;code&gt;start&lt;/code&gt; 脚本是如何在Unix上嵌入模式下启动Erlang的系统的示例脚本。</target>
        </trans-unit>
        <trans-unit id="c9b5982012fe67cdfffd9b71b0eeb41c6d062f31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; script is to be edited accordingly.</source>
          <target state="translated">该 &lt;code&gt;start&lt;/code&gt; 脚本进行相应的修改。</target>
        </trans-unit>
        <trans-unit id="31e73008fe878f9797af9d091c4fba4b24889e97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_disabled&lt;/code&gt; command operates on a service regardless of if it is enabled/disabled or started/stopped. It does this by first enabling it (regardless of if it is enabled or not), then starting it (if not already started), and then disabling it. The result is a disabled but started service, regardless of its earlier state. This is useful for starting services temporarily during a release upgrade. The difference between using &lt;code&gt;start_disabled&lt;/code&gt; and the sequence &lt;code&gt;enable&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;disable&lt;/code&gt; is that all other &lt;code&gt;erlsrv&lt;/code&gt; commands are locked out during the sequence of operations in &lt;code&gt;start_disable&lt;/code&gt;, making the operation atomic from an &lt;code&gt;erlsrv&lt;/code&gt; user's point of view.</source>
          <target state="translated">该 &lt;code&gt;start_disabled&lt;/code&gt; 不管是启用/禁用或启动的一个服务命令操作/停止。为此，它首先启用它（无论是否启用），然后启动它（如果尚未启动），然后禁用它。结果是禁用的但已启动的服务，而不管其之前的状态如何。这对于在版本升级期间临时启动服务很有用。使用 &lt;code&gt;start_disabled&lt;/code&gt; 和序列 &lt;code&gt;enable&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;disable&lt;/code&gt; 之间的区别是，在 &lt;code&gt;start_disable&lt;/code&gt; 中的操作序列期间，所有其他 &lt;code&gt;erlsrv&lt;/code&gt; 命令均被锁定，从而使操作从 &lt;code&gt;erlsrv&lt;/code&gt; 变为原子 用户的观点。</target>
        </trans-unit>
        <trans-unit id="fc0272cbbd8f9392623927de4cb2fc5730b48880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program in its original form recognizes the following options:</source>
          <target state="translated">原始形式的 &lt;code&gt;start_erl&lt;/code&gt; 程序可识别以下选项：</target>
        </trans-unit>
        <trans-unit id="a046e5227b7bb73b869f5bee562322400ca78ede" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; program is specific to Windows NT/2000/XP (and later versions of Windows). Although there are programs with the same name on other platforms, their functionality is different.</source>
          <target state="translated">该 &lt;code&gt;start_erl&lt;/code&gt; 程序是特定于Windows NT / 2000 / XP（以及更高版本的Windows）。尽管在其他平台上存在具有相同名称的程序，但是它们的功能不同。</target>
        </trans-unit>
        <trans-unit id="dbb5a322b443d443c9f79ed8f50a8ce9c3dd4066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_erl&lt;/code&gt; shell script is normally not to be altered by the user.</source>
          <target state="translated">该 &lt;code&gt;start_erl&lt;/code&gt; shell脚本通常不是由用户来改变。</target>
        </trans-unit>
        <trans-unit id="f114d80543f043efa956ef10b8b8d871f223052b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stop&lt;/code&gt; entry is called when the port is closed.</source>
          <target state="translated">该 &lt;code&gt;stop&lt;/code&gt; 当端口关闭入口被调用。</target>
        </trans-unit>
        <trans-unit id="d04747a932902a65b42336d22f13d3d5bc78329f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strategy&lt;/code&gt; key is optional in this map. If it is not given, it defaults to &lt;code&gt;one_for_one&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;strategy&lt;/code&gt; 关键是在这个地图可选。如果未给出，则默认为 &lt;code&gt;one_for_one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac46c7648d961485339da72bde9519efe243649a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string&lt;/code&gt; module works perfectly for Unicode strings and ISO Latin-1 strings, except the language-dependent functions &lt;code&gt;string:uppercase/1&lt;/code&gt; and &lt;code&gt;string:lowercase/1&lt;/code&gt;. These two functions can never function correctly for Unicode characters in their current form, as there are language and locale issues to consider when converting text between cases. Converting case in an international environment is a large subject not yet addressed in OTP.</source>
          <target state="translated">该 &lt;code&gt;string&lt;/code&gt; 模块完全适用于Unicode字符串和ISO Latin-1的字符串，除了依赖于语言的函数 &lt;code&gt;string:uppercase/1&lt;/code&gt; 和 &lt;code&gt;string:lowercase/1&lt;/code&gt; 。这两种功能永远无法正确使用当前格式的Unicode字符，因为在大小写之间转换文本时要考虑语言和语言环境问题。在国际环境中进行案件转换是OTP中尚未解决的一个大问题。</target>
        </trans-unit>
        <trans-unit id="bbf0fa4cdfc9cb3b3a98e97fea86cc7766872258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subsystem_name&lt;/code&gt; is the name that a client requests to start with for example &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;subsystem_name&lt;/code&gt; 是名，一个客户端请求开始，例如 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09767c0926afa55480ccd26075dea864841952af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suspend&lt;/code&gt; pseudo function has got an OWN time of zero. This is to prevent the process total OWN time from including time in suspension. Whether suspend time is really ACC or OWN time is more of a philosophical question.</source>
          <target state="translated">在 &lt;code&gt;suspend&lt;/code&gt; 伪功能已经得到了零的自己的时间。这是为了防止进程总OWN时间包括暂停时间。暂停时间是真正的ACC时间还是OWN时间更是一个哲学问题。</target>
        </trans-unit>
        <trans-unit id="56fd6933946b063ca50f26b9fde4abf8abbc8167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. It also has functions that, together with functions in the &lt;code&gt;proc_lib&lt;/code&gt; module, can be used to implement a &lt;strong&gt;special process&lt;/strong&gt; that complies to the OTP design principles without using a standard behaviour. These functions can also be used to implement user-defined (non-standard) behaviours.</source>
          <target state="translated">该 &lt;code&gt;sys&lt;/code&gt; 模块具有的使用行为实施的过程简单的调试。它还具有与 &lt;code&gt;proc_lib&lt;/code&gt; 模块中的函数一起使用的函数，可用于实现符合OTP设计原则的&lt;strong&gt;特殊过程&lt;/strong&gt;，而无需使用标准行为。这些功能还可用于实现用户定义的（非标准）行为。</target>
        </trans-unit>
        <trans-unit id="a5f881a797bfc4fbe38f558b9ae2256b6de4f52c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sys&lt;/code&gt; module has functions for simple debugging of processes implemented using behaviours. The &lt;code&gt;code_lock&lt;/code&gt; example from &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; is used to illustrate this:</source>
          <target state="translated">该 &lt;code&gt;sys&lt;/code&gt; 模块具有的使用行为实施的过程简单的调试。 &lt;code&gt;&lt;a href=&quot;statem#Example&quot;&gt;gen_statem Behaviour&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;code_lock&lt;/code&gt; 示例用于说明这一点：</target>
        </trans-unit>
        <trans-unit id="d8d80e46d29a3b09620c79d01dfafc6546d08b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; value is not complete. Some allocated memory that is to be part of this value is not.</source>
          <target state="translated">该 &lt;code&gt;system&lt;/code&gt; 价值是不完整的。某些分配的内存不是该值的一部分。</target>
        </trans-unit>
        <trans-unit id="26e392c3cf2f0ef617cba237c6220075b3ea4b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system_dir&lt;/code&gt; option must be a directory containing a host key file and it defaults to &lt;code&gt;/etc/ssh&lt;/code&gt;. For details, see Section Configuration Files in &lt;code&gt;ssh(6)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;system_dir&lt;/code&gt; 选项必须是包含一个主机密钥文件的目录，并将其默认 &lt;code&gt;/etc/ssh&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 中的配置文件部分。</target>
        </trans-unit>
        <trans-unit id="8dc4b52b4a1a8766ffe6fbf819d4319fd568e3cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; function takes a &lt;code&gt;.rel&lt;/code&gt; file as input and creates a zipped tar file with the code for the specified applications, a &lt;strong&gt;release package&lt;/strong&gt;:</source>
          <target state="translated">的 &lt;code&gt;systools:make_tar/1,2&lt;/code&gt; 函数需要一个 &lt;code&gt;.rel&lt;/code&gt; 文件作为输入，并创建与所指定的应用程序，一个代码中的压缩的tar文件&lt;strong&gt;发布包&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="301c4b01094f4be3c122bd03d67de7a461179ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table_info/2&lt;/code&gt; function takes two arguments. The first is the name of a Mnesia table. The second is one of the following keys:</source>
          <target state="translated">该 &lt;code&gt;table_info/2&lt;/code&gt; 函数有两个参数。第一个是Mnesia表的名称。第二个是以下键之一：</target>
        </trans-unit>
        <trans-unit id="cc6490531af30f5ced0c442f4ca5f18223c8f2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag_receiver()&lt;/code&gt; will first be sent the &lt;code&gt;snmp_targets&lt;/code&gt; message, and then for each address in &lt;code&gt;Addresses&lt;/code&gt; list, one of the two &lt;code&gt;snmp_notification&lt;/code&gt; messages.</source>
          <target state="translated">所述 &lt;code&gt;tag_receiver()&lt;/code&gt; 将首先发送的 &lt;code&gt;snmp_targets&lt;/code&gt; 消息，然后在每个地址 &lt;code&gt;Addresses&lt;/code&gt; 列表中，这两个中的一个 &lt;code&gt;snmp_notification&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="05b2bd26a182333de1bd8075c792a7cf0885382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term&lt;/code&gt; structure contains the arity for a tuple or list, size for a binary, string, or atom. It contains a term if it is any of the following: integer, float, atom, pid, port, or ref.</source>
          <target state="translated">该 &lt;code&gt;term&lt;/code&gt; 结构包含用于为二进制，字符串或原子的元组或列表，大小的元数。它包含以下各项之一：整数，浮点数，原子，pid，端口或引用。</target>
        </trans-unit>
        <trans-unit id="414ded4046829ee348e2029f26b1f968edf7170d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminating&lt;/code&gt; options effects discovery initiated by a manager.</source>
          <target state="translated">该 &lt;code&gt;terminating&lt;/code&gt; 由经理启动选项的效果发现。</target>
        </trans-unit>
        <trans-unit id="7e88c128d4034b8d31e143d58083f1b627d669f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; functions use the &lt;code&gt;*.asn1db&lt;/code&gt; files for all included modules. If they are located in a different directory than the current working directory, use the &lt;code&gt;include&lt;/code&gt; option to add paths. This is only needed when automatically generating values. For static values using &lt;code&gt;Value&lt;/code&gt; no options are needed.</source>
          <target state="translated">该 &lt;code&gt;test&lt;/code&gt; 功能使用 &lt;code&gt;*.asn1db&lt;/code&gt; 文件所包含的全部模块。如果它们位于与当前工作目录不同的目录中，请使用 &lt;code&gt;include&lt;/code&gt; 选项添加路径。仅在自动生成值时才需要。对于使用&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 静态值，不需要任何选项。</target>
        </trans-unit>
        <trans-unit id="83b7e0837f597d64ddcc824925c5e1f6e2d7ce99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tftp&lt;/code&gt; application implements the following IETF standards:</source>
          <target state="translated">在 &lt;code&gt;tftp&lt;/code&gt; 应用程序实现以下IETF标准：</target>
        </trans-unit>
        <trans-unit id="4bd16215e29bac88188ec05db9e000d6b25c2a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time_unit/0&lt;/code&gt; type can be extended. To convert time values between time units, use &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;time_unit/0&lt;/code&gt; 类型可以延长。要在时间单位之间转换时间值，请使用 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d6b5da79accb971f070469104b62f5de13468c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; option in the &lt;code&gt;SearchOptions&lt;/code&gt; is for the ldap server, while the timeout in &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; is used for each individual request in the search operation.</source>
          <target state="translated">&lt;code&gt;SearchOptions&lt;/code&gt; 中的 &lt;code&gt;timeout&lt;/code&gt; 选项用于ldap服务器，而 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;eldap:open/2&lt;/a&gt;&lt;/code&gt; 中的超时用于搜索操作中的每个单独请求。</target>
        </trans-unit>
        <trans-unit id="3469f460bad51d15abfb716bef8439dd19f5713d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;total&lt;/code&gt; value is supposed to be the total amount of memory dynamically allocated by the emulator. Shared libraries, the code of the emulator itself, and the emulator stacks are not supposed to be included. That is, the &lt;code&gt;total&lt;/code&gt; value is &lt;strong&gt;not&lt;/strong&gt; supposed to be equal to the total size of all pages mapped to the emulator.</source>
          <target state="translated">该 &lt;code&gt;total&lt;/code&gt; 应该是仿真器动态分配的内存总量。不应包含共享库，仿真器本身的代码以及仿真器堆栈。也就是说， &lt;code&gt;total&lt;/code&gt; 价值&lt;strong&gt;不&lt;/strong&gt;应该等于映射到仿真器的所有页面的总大小。</target>
        </trans-unit>
        <trans-unit id="855a90cd384864cf599ca9011960a53bac88f853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trim&lt;/code&gt; behavior corresponds exactly to the Perl default. &lt;code&gt;{parts,N}&lt;/code&gt;, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of &lt;code&gt;split/3&lt;/code&gt; corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</source>
          <target state="translated">该 &lt;code&gt;trim&lt;/code&gt; 行为完全对应于Perl中的默认值。 &lt;code&gt;{parts,N}&lt;/code&gt; （其中N是一个正整数）与具有正数字第三参数的Perl行为完全对应。当将负整数指定为Perl例程的第三个参数时， &lt;code&gt;split/3&lt;/code&gt; 的默认行为与Perl行为相对应。</target>
        </trans-unit>
        <trans-unit id="503ae720e5d8f3760c374c5a7724a46be581ffb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can also be augmented with an &lt;code&gt;after&lt;/code&gt; section, intended to be used for cleanup with side effects:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 表达也可以与增强 &lt;code&gt;after&lt;/code&gt; 部分，意在被用于与副作用清理：</target>
        </trans-unit>
        <trans-unit id="9aa8fddb846b9b7abd8af53c04dc022f8bbdb56d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; expression can have an &lt;code&gt;of&lt;/code&gt; section:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 的表达可以有一个 &lt;code&gt;of&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="874e9960e26401a3b617a3b1e2c19da394373ec5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not given, the default value &lt;code&gt;worker&lt;/code&gt; will be used.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 关键是可选的。如果未提供，将使用默认值 &lt;code&gt;worker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce30d2f89579b051b36741023e812a759179d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; key is optional. If it is not specified, it defaults to &lt;code&gt;worker&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 关键是可选的。如果未指定，则默认为 &lt;code&gt;worker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8f1c69ed96b83a679b6a1461cadd4cb592d2117" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_command&lt;/code&gt; routine is the routine called when an Erlang process sends data to the port. This routine handles all asynchronous commands when the port is in &lt;code&gt;command&lt;/code&gt; mode and the sending of all data when the port is in &lt;code&gt;data&lt;/code&gt; mode:</source>
          <target state="translated">所述 &lt;code&gt;uds_command&lt;/code&gt; 例程是当一个Erlang过程将数据发送到的端口称为例程。当端口处于 &lt;code&gt;command&lt;/code&gt; 模式时，此例程处理所有异步命令；当端口处于 &lt;code&gt;data&lt;/code&gt; 模式时，此例程将发送所有数据：</target>
        </trans-unit>
        <trans-unit id="12d38078aadeb17f73f6143b46507ced220c8b0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine handles other input events (like non-blocking &lt;code&gt;accept&lt;/code&gt;), but most importantly handle data arriving at the socket by calling &lt;code&gt;do_recv&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;uds_input&lt;/code&gt; 程序处理其他输入事件（如无阻塞 &lt;code&gt;accept&lt;/code&gt; ），但通过调用最重要的处理到达套接字数据 &lt;code&gt;do_recv&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="202a772c2bbbb0c73373b15e1d87ffd28aa29133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_input&lt;/code&gt; routine is called when data is available on a file descriptor previously passed to the &lt;code&gt;driver_select&lt;/code&gt; routine. This occurs typically when a read command is issued and no data is available. The &lt;code&gt;do_recv&lt;/code&gt; routine is as follows:</source>
          <target state="translated">该 &lt;code&gt;uds_input&lt;/code&gt; 数据可用时先前传递给一个文件描述符程序被称为 &lt;code&gt;driver_select&lt;/code&gt; 程序。通常在发出读取命令并且没有可用数据时发生。该 &lt;code&gt;do_recv&lt;/code&gt; 程序如下：</target>
        </trans-unit>
        <trans-unit id="afe5ea4f80f83ad57ad0aad31e10486a4f2bf930" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uds_start&lt;/code&gt; routine is called when a port is opened from Erlang. In this case, we only allocate a structure and initialize it. Creating the actual socket is left to the &lt;code&gt;uds_command&lt;/code&gt; routine.</source>
          <target state="translated">该 &lt;code&gt;uds_start&lt;/code&gt; 当口，从二郎打开程序被调用。在这种情况下，我们仅分配一个结构并对其进行初始化。创建实际的套接字由 &lt;code&gt;uds_command&lt;/code&gt; 例程完成。</target>
        </trans-unit>
        <trans-unit id="8bfbb24810f0c5b15e0b6448d90f972fe31a6386" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undo&lt;/code&gt; function does nothing.</source>
          <target state="translated">该 &lt;code&gt;undo&lt;/code&gt; 函数什么都不做。</target>
        </trans-unit>
        <trans-unit id="7969bdd4f7e8e8283016abfb83b747e28e6525e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unicode&lt;/code&gt; module is clearly Unicode-aware. It contains functions for conversion between different Unicode formats and some utilities for identifying byte order marks. Few programs handling Unicode data survive without this module.</source>
          <target state="translated">在 &lt;code&gt;unicode&lt;/code&gt; 模块显然是支持Unicode的。它包含用于在不同Unicode格式之间进行转换的功能，以及一些用于标识字节顺序标记的实用程序。没有这个模块，很少有处理Unicode数据的程序可以生存。</target>
        </trans-unit>
        <trans-unit id="45fc4ab31edeed78de6dcc133ce43fa458252958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; function is an alternative for updating module data of recompiled modules.</source>
          <target state="translated">的 &lt;code&gt;update&lt;/code&gt; 功能是用于更新重新编译模块的模块数据的替代方案。</target>
        </trans-unit>
        <trans-unit id="e7a993cc2041a3a5e4126cbf7ea824172decdb48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; instruction must contain the tuple &lt;code&gt;{advanced,Extra}&lt;/code&gt;. The instruction makes the special process call the callback function &lt;code&gt;system_code_change/4&lt;/code&gt;, a function the user must implement. The term &lt;code&gt;Extra&lt;/code&gt;, in this case &lt;code&gt;[]&lt;/code&gt;, is passed as is to &lt;code&gt;system_code_change/4&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;update&lt;/code&gt; 指令必须包含元组 &lt;code&gt;{advanced,Extra}&lt;/code&gt; 。该指令使特殊过程调用回调函数 &lt;code&gt;system_code_change/4&lt;/code&gt; ，这是用户必须实现的功能。术语 &lt;code&gt;Extra&lt;/code&gt; （在这种情况下为 &lt;code&gt;[]&lt;/code&gt; ）按原样传递给 &lt;code&gt;system_code_change/4&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55a52d1bdeacd91af756556ef9395d795b7ce705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user_args&lt;/code&gt; configuration parameter which may be used to extend the argument list of the callback functions. For example, the handle_connect function takes by default two arguments:</source>
          <target state="translated">所述 &lt;code&gt;user_args&lt;/code&gt; 配置参数，其可以被用于扩展的回调函数的参数列表。例如，handle_connect函数默认采用两个参数：</target>
        </trans-unit>
        <trans-unit id="c15ed8631e7be541ad2f112cab6d63b078785dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmAccessTable&lt;/code&gt; maps the &lt;code&gt;groupName&lt;/code&gt; (found in &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;), &lt;code&gt;contextName&lt;/code&gt;, &lt;code&gt;securityModel&lt;/code&gt;, and &lt;code&gt;securityLevel&lt;/code&gt; to an MIB view for each type of operation (read, write, or notify). The MIB view is represented as a &lt;code&gt;viewName&lt;/code&gt;. The definition of the MIB view represented by the &lt;code&gt;viewName&lt;/code&gt; is found in the &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;vacmAccessTable&lt;/code&gt; 的映射 &lt;code&gt;groupName&lt;/code&gt; （在发现 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; ）， &lt;code&gt;contextName&lt;/code&gt; ， &lt;code&gt;securityModel&lt;/code&gt; 和 &lt;code&gt;securityLevel&lt;/code&gt; 进行为每个类型的操作（读，写，或通知）的MIB图。MIB视图表示为 &lt;code&gt;viewName&lt;/code&gt; 。在 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 中找到由 &lt;code&gt;viewName&lt;/code&gt; 表示的MIB视图的定义</target>
        </trans-unit>
        <trans-unit id="a70d16c49aee0ecab7697bd61b2b47a75fed9fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmContextTable&lt;/code&gt; is a read-only table that lists all available contexts.</source>
          <target state="translated">该 &lt;code&gt;vacmContextTable&lt;/code&gt; 是一个只读表，其中列出了可用的上下文。</target>
        </trans-unit>
        <trans-unit id="ef9aac3e2a8987ec6dd80992e0534a1b71403af1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; maps a &lt;code&gt;securityModel&lt;/code&gt; and a &lt;code&gt;securityName&lt;/code&gt; to a &lt;code&gt;groupName&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; 映射一个 &lt;code&gt;securityModel&lt;/code&gt; 和 &lt;code&gt;securityName&lt;/code&gt; 的 &lt;code&gt;groupName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28801f1623b234b9de96cc740a98bd5f85c06c85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; is indexed by the &lt;code&gt;viewName&lt;/code&gt;, and defines which objects are included in the MIB view.</source>
          <target state="translated">该 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 由索引 &lt;code&gt;viewName&lt;/code&gt; ，并且该对象包括在MIB视图定义。</target>
        </trans-unit>
        <trans-unit id="1870424a39adeddc9df6d1301607365bb578c850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vfs&lt;/code&gt; layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older versions did this by refusing to create non-UTF-8 conforming filenames, while newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the original character in hexadecimal notation. As Unicode translation is enabled by default on MacOS X, the only way to come up against this is to either start the VM with flag &lt;code&gt;+fnl&lt;/code&gt; or to use a raw filename in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding. If using a raw filename, with a bytewise encoding containing characters from 127 through 255, to create a file, the file cannot be opened using the same name as the one used to create it. There is no remedy for this behavior, except keeping the filenames in the correct encoding.</source>
          <target state="translated">MacOS X 的 &lt;code&gt;vfs&lt;/code&gt; 层以积极的方式强制执行UTF-8文件名。较旧的版本通过拒绝创建不符合UTF-8的文件名来做到这一点，而较新的版本则用序列&amp;ldquo;％HH&amp;rdquo;替换有问题的字节，其中HH是十六进制表示法中的原始字符。由于MacOS X上默认启用了Unicode转换，因此唯一的解决方法是使用标志 &lt;code&gt;+fnl&lt;/code&gt; 启动VM 或使用按字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码的原始文件名。如果使用原始文件名（按字节编码包含从127到255的字符）来创建文件，则无法使用与用于创建文件的文件名相同的名称来打开文件。除了将文件名保留为正确的编码外，没有针对此行为的补救措施。</target>
        </trans-unit>
        <trans-unit id="831df5545d1b1c7760cea7009d162230198cc0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;werl&lt;/code&gt; window is in many ways modeled after the &lt;code&gt;xterm&lt;/code&gt; window present on other platforms, as the &lt;code&gt;xterm&lt;/code&gt; model fits well with line-oriented command-based interaction. This means that selecting text is line-oriented rather than rectangle-oriented.</source>
          <target state="translated">由于 &lt;code&gt;xterm&lt;/code&gt; 模型非常适合基于行的基于命令的交互，因此在很多方面都以其他平台上存在的 &lt;code&gt;xterm&lt;/code&gt; 窗口为模型来模拟 &lt;code&gt;werl&lt;/code&gt; 窗口。这意味着选择文本是面向行的，而不是面向矩形的。</target>
        </trans-unit>
        <trans-unit id="cb0a24e0ba3c71a8aad37252c9a038696dacac35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;whereis&lt;/code&gt; function-call verifies that the SSL application is started.</source>
          <target state="translated">该 &lt;code&gt;whereis&lt;/code&gt; 函数调用验证的SSL应用程序已启动。</target>
        </trans-unit>
        <trans-unit id="a6d05af96ec0e7231d4e09ddd7a1fc622f5621cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; is defined by the user and is passed to the &lt;code&gt;match_fun&lt;/code&gt;, if defined. If the term in &lt;code&gt;OtherRefId&lt;/code&gt; is a binary, it will be converted to a string.</source>
          <target state="translated">的 &lt;code&gt;{OtherRefId,term()}&lt;/code&gt; 由用户定义，并且被传递到 &lt;code&gt;match_fun&lt;/code&gt; ，如果定义的话。如果 &lt;code&gt;OtherRefId&lt;/code&gt; 中的术语是二进制的，则它将转换为字符串。</target>
        </trans-unit>
        <trans-unit id="19e1b6293cd5c62e374c8457e4fbd9d95a253158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; option must be included. This option is used to find the callback module &lt;code&gt;Module&lt;/code&gt; of the application. &lt;code&gt;StartArgs&lt;/code&gt; is ignored, as &lt;code&gt;Module:start/2&lt;/code&gt; is called only for the primary application.</source>
          <target state="translated">的 &lt;code&gt;{mod, {Module,StartArgs}}&lt;/code&gt; 选项必须被包括在内。此选项用于查找应用程序的回调模块 &lt;code&gt;Module&lt;/code&gt; 。 &lt;code&gt;StartArgs&lt;/code&gt; 被忽略，因为 &lt;code&gt;Module:start/2&lt;/code&gt; 仅针对主应用程序被调用。</target>
        </trans-unit>
        <trans-unit id="4668f1fd645c2ffa2dba60de3db8016985e65bc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ok,tut}&lt;/code&gt; means that the compilation is OK. If it says &quot;error&quot; it means that there is some mistake in the text that you entered. Additional error messages gives an idea to what is wrong so you can modify the text and then try to compile the program again.</source>
          <target state="translated">该 &lt;code&gt;{ok,tut}&lt;/code&gt; 意味着编译正常。如果显示&amp;ldquo;错误&amp;rdquo;，则表示您输入的文本中存在错误。其他错误消息会提示您错误所在，因此您可以修改文本，然后尝试再次编译程序。</target>
        </trans-unit>
        <trans-unit id="37c82dec6529acb72fb125b0bac4fda347c61081" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{packet, N}&lt;/code&gt; and &lt;code&gt;{line, L}&lt;/code&gt; settings are mutually exclusive.</source>
          <target state="translated">的 &lt;code&gt;{packet, N}&lt;/code&gt; 和 &lt;code&gt;{line, L}&lt;/code&gt; 的设置是互相排斥的。</target>
        </trans-unit>
        <trans-unit id="971d55e17028d3606b6c283922622f2c0932a483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{port,PortNum}&lt;/code&gt; tuple is optional and if omitted, default Telnet port 23 is used. Also the &lt;code&gt;keep_alive&lt;/code&gt; tuple is optional, and the value defauls to &lt;code&gt;true&lt;/code&gt; (enabled).</source>
          <target state="translated">的 &lt;code&gt;{port,PortNum}&lt;/code&gt; 元组是可选的，并且如果省略，默认Telnet端口23被使用。另外， &lt;code&gt;keep_alive&lt;/code&gt; 元组是可选的，并且值默认为 &lt;code&gt;true&lt;/code&gt; （启用）。</target>
        </trans-unit>
        <trans-unit id="fa6ece2cc8b2e8dafa07d4e08292eb70bec23c2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; option must be included, and the set of specified phases must be a subset of the set of phases specified for the primary application.</source>
          <target state="translated">的 &lt;code&gt;{start_phases, [{Phase,PhaseArgs}]}&lt;/code&gt; 选项必须包括在内，和该组特定阶段必须设定的用于主应用程序指定的相位的一个子集。</target>
        </trans-unit>
        <trans-unit id="ff25bb9b46c77ee1bd1587510f1046fea71955a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt; &quot;such that&quot; and the arrow &lt;code&gt;&amp;lt;-&lt;/code&gt; is read as &quot;taken from&quot;.</source>
          <target state="translated">该 &lt;code&gt;||&lt;/code&gt; &amp;ldquo;诸如此类&amp;rdquo;和箭头 &lt;code&gt;&amp;lt;-&lt;/code&gt; 表示为&amp;ldquo;取自&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8950a73316b6b3766c9706406f02f3f2dda35162" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;Cartesian_product&quot;&gt;Cartesian product&lt;/strong&gt; of two sets X and Y, denoted X &amp;times; Y, is the set {a : a = (x, y) for some x in X and for some y in Y}.</source>
          <target state="translated">两个集合X和Y 的&lt;strong id=&quot;Cartesian_product&quot;&gt;笛卡尔积&lt;/strong&gt;，表示为X&amp;times;Y，是集合{a：a =（x，y），其中X中的一些x和Y中的一些y}。</target>
        </trans-unit>
        <trans-unit id="97f5043ae782de1e349c1f4e82a07bd359c0964c" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;converse&quot;&gt;converse&lt;/strong&gt; of R is the set {a : a = (y, x) for some (x, y) in R}.</source>
          <target state="translated">R 的&lt;strong id=&quot;converse&quot;&gt;逆&lt;/strong&gt;是集合{a：R中某些（x，y）的a = a（y，x）}。</target>
        </trans-unit>
        <trans-unit id="c74f91b2df651d6f1d918e8b3fa79c423cad5e1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;difference&quot;&gt;difference&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that do not belong to B.</source>
          <target state="translated">两个集合A和B 的&lt;strong id=&quot;difference&quot;&gt;区别&lt;/strong&gt;在于，该集合包含A的所有不属于B的元素。</target>
        </trans-unit>
        <trans-unit id="efd11e10dc9bffd3ce00966684d96fd8a122cb0d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;domain&quot;&gt;domain&lt;/strong&gt; of R is the set {x : x R y for some y in Y}.</source>
          <target state="translated">R 的&lt;strong id=&quot;domain&quot;&gt;域&lt;/strong&gt;是集合{x：x R y对于Y中的某些y}。</target>
        </trans-unit>
        <trans-unit id="377184fb47eff2618a884d3371438181861419a0" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;field&quot;&gt;field&lt;/strong&gt; of a relation R in X is the union of the domain of R and the range of R.</source>
          <target state="translated">X中的关系R 的&lt;strong id=&quot;field&quot;&gt;字段&lt;/strong&gt;是R的域和R的范围的并集。</target>
        </trans-unit>
        <trans-unit id="1a9617de87db1af0121da59eba19d31a6b757eff" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;in_degree&quot;&gt;in-degree&lt;/strong&gt; of a vertex is the number of edges incident on that vertex.</source>
          <target state="translated">所述&lt;strong id=&quot;in_degree&quot;&gt;入度&lt;/strong&gt;顶点的是边缘入射在该顶点的数目。</target>
        </trans-unit>
        <trans-unit id="4c0e00f79ce45926299ee2f3508020fdf2f45df9" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection&quot;&gt;intersection&lt;/strong&gt; of two sets A and B is the set that contains all elements of A that belong to B.</source>
          <target state="translated">两个集合A和B 的&lt;strong id=&quot;intersection&quot;&gt;交集&lt;/strong&gt;是包含所有属于B的A元素的集合。</target>
        </trans-unit>
        <trans-unit id="3f1d912f47b338c33084d89f0c15a5a316197ecb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;intersection_n&quot;&gt;intersection&lt;/strong&gt; of a non-empty collection of sets is the set that contains all elements that belong to every set of the collection.</source>
          <target state="translated">该&lt;strong id=&quot;intersection_n&quot;&gt;路口&lt;/strong&gt;的集合非空集是包含属于每一套集合中的所有元素的集合。</target>
        </trans-unit>
        <trans-unit id="429f2c89c9e807577354da0b8e15a8e248018d77" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;length&quot;&gt;length&lt;/strong&gt; of path P is k-1.</source>
          <target state="translated">路径P 的&lt;strong id=&quot;length&quot;&gt;长度&lt;/strong&gt;是k-1。</target>
        </trans-unit>
        <trans-unit id="abc21b67f672b304bee1db7701b820f9b24de3c6" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;natural_join&quot;&gt;natural join&lt;/strong&gt; of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ..., y[m]) for some (x[1], ..., x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.</source>
          <target state="translated">坐标i和j上的n元关系R和m元关系S 的&lt;strong id=&quot;natural_join&quot;&gt;自然连接&lt;/strong&gt;定义为集合{z：z =（x [1]，...，x [n]，y [ 1]，...，y [j-1]，y [j + 1]，...，y [m]）对于R中的某些（x [1]，...，x [n]）和对于S中的某些（y [1]，...，y [m]），使得x [i] = y [j]}。</target>
        </trans-unit>
        <trans-unit id="adf6489e3c93a13ca7fd19239f3939863c02f11d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;out_degree&quot;&gt;out-degree&lt;/strong&gt; of a vertex is the number of edges emanating from that vertex.</source>
          <target state="translated">顶点的&lt;strong id=&quot;out_degree&quot;&gt;出度&lt;/strong&gt;是从该顶点发出的边的数量。</target>
        </trans-unit>
        <trans-unit id="7c6a3c4f02bedbb63c4000218f9eaa4b3029b656" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;projection&quot;&gt;projection&lt;/strong&gt; of an n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ..., x[n]) in R for some x[j] in X[j], 1 &amp;lt;= j &amp;lt;= n and not i = j}. The projections of a binary relation R onto the first and second coordinates are the domain and the range of R, respectively.</source>
          <target state="translated">n元关系R在坐标i上的&lt;strong id=&quot;projection&quot;&gt;投影&lt;/strong&gt;是R在某些x上的集合{x [i]：（x [1]，...，x [i]，...，x [n]） X [j]中的[j]，1 &amp;lt;= j &amp;lt;= n，而不是i = j}。二进制关系R在第一和第二坐标上的投影分别是R的域和范围。</target>
        </trans-unit>
        <trans-unit id="928618861a3a7864fa16dc6571d48344039643c2" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;range&quot;&gt;range&lt;/strong&gt; of R is the set {y : x R y for some x in X}.</source>
          <target state="translated">R 的&lt;strong id=&quot;range&quot;&gt;范围&lt;/strong&gt;是集合{y：X中x的x y}。</target>
        </trans-unit>
        <trans-unit id="a0513ff69692a7179c5c24f4ad25a5aa23d84d71" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;restriction&quot;&gt;restriction&lt;/strong&gt; of R to A is the set S defined so that x S y if and only if there exists an element x in A such that x R y.</source>
          <target state="translated">R对A 的&lt;strong id=&quot;restriction&quot;&gt;限制&lt;/strong&gt;是定义的集合S，因此，当且仅当A中存在元素x使得x R y时，x S y。</target>
        </trans-unit>
        <trans-unit id="53dd8e97ddf5e81c0a22de5f228a88721f6ccc8d" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;symmetric_difference&quot;&gt;symmetric difference&lt;/strong&gt; of two sets is the set that contains those element that belong to either of the two sets, but not both.</source>
          <target state="translated">两组的&lt;strong id=&quot;symmetric_difference&quot;&gt;对称差异&lt;/strong&gt;是包含属于两个组中的一个但不是两个的元素的组。</target>
        </trans-unit>
        <trans-unit id="baf0cfcddb027f4d4f3dff2390047419348137ab" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union&quot;&gt;union&lt;/strong&gt; of two sets A and B is the smallest set that contains all elements of A and all elements of B.</source>
          <target state="translated">该&lt;strong id=&quot;union&quot;&gt;工会&lt;/strong&gt;两套A和B是包含和A的所有元素B的所有元素的最小集合</target>
        </trans-unit>
        <trans-unit id="81d4f87a2b598bff542bef7879776b07f0f811bb" translate="yes" xml:space="preserve">
          <source>The &lt;strong id=&quot;union_n&quot;&gt;union&lt;/strong&gt; of a collection of sets is the smallest set that contains all the elements that belong to at least one set of the collection.</source>
          <target state="translated">该&lt;strong id=&quot;union_n&quot;&gt;联盟&lt;/strong&gt;的集合的集合是包含所有属于至少一组的集合中的元素的最小集。</target>
        </trans-unit>
        <trans-unit id="5d51e506fb7ebd09e0439b577c3665c859bbc0bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Auto Attach&lt;/strong&gt; boxes, &lt;strong&gt;Stack Trace&lt;/strong&gt; label, &lt;strong&gt;Back Trace Size&lt;/strong&gt; label, and &lt;strong&gt;Strings&lt;/strong&gt; box display some options set. For details about these options, see section &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;自动附加&amp;rdquo;&lt;/strong&gt;框，&amp;ldquo; &lt;strong&gt;堆栈跟踪&amp;rdquo;&lt;/strong&gt;标签，&amp;ldquo; &lt;strong&gt;后跟踪大小&amp;rdquo;&lt;/strong&gt;标签和&amp;ldquo; &lt;strong&gt;字符串&amp;rdquo;&lt;/strong&gt;框显示一些选项集。有关这些选项的详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;Options Menu&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="abcaf1a971590700133b8016539b636c71ba876f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Break&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">该&lt;strong&gt;休息&lt;/strong&gt;，&lt;strong&gt;视窗&lt;/strong&gt;和&lt;strong&gt;帮助&lt;/strong&gt;菜单是一样的，在 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; ，除了&lt;strong&gt;休息&lt;/strong&gt;菜单只适用于本地断点。</target>
        </trans-unit>
        <trans-unit id="a10eb03f19350fbdf85025a9eab01c5153042f77" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Break&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt;, and &lt;strong&gt;Help&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt;, except that the &lt;strong&gt;Breaks&lt;/strong&gt; menu applies only to local breakpoints.</source>
          <target state="translated">该&lt;strong&gt;休息&lt;/strong&gt;，&lt;strong&gt;视窗&lt;/strong&gt;和&lt;strong&gt;帮助&lt;/strong&gt;菜单是一样的，在 &lt;code&gt;&lt;a href=&quot;#monitor&quot;&gt;Monitor Window&lt;/a&gt;&lt;/code&gt; ，除了&lt;strong&gt;休息&lt;/strong&gt;菜单只适用于本地断点。</target>
        </trans-unit>
        <trans-unit id="81208a589d29fcc1ae9246757bcbbd412aee1292" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; by callbacks before and after all test suite calls. It is intended for advanced users of &lt;code&gt;Common Test&lt;/code&gt; who want to abstract out behavior that is common to multiple test suites.</source>
          <target state="translated">在&lt;strong&gt;通用测试钩（星期三）&lt;/strong&gt;框架允许的默认行为扩展 &lt;code&gt;Common Test&lt;/code&gt; 通过回调之前，所有测试套件来电之后。它适用于希望抽象出多个测试套件共有行为的 &lt;code&gt;Common Test&lt;/code&gt; 高级用户。</target>
        </trans-unit>
        <trans-unit id="e6fc5c94241e7e52f12a5fd7bd3416eff9018efa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Common Test Hook (CTH)&lt;/strong&gt; framework allows extensions of the default behavior of &lt;code&gt;Common Test&lt;/code&gt; using hooks before and after all test suite calls. CTHs allow advanced &lt;code&gt;Common Test&lt;/code&gt; users to abstract out behavior that is common to multiple test suites without littering all test suites with library calls. This can be used for logging, starting, and monitoring external systems, building C files needed by the tests, and so on.</source>
          <target state="translated">在&lt;strong&gt;通用测试钩（星期三）&lt;/strong&gt;框架允许的默认行为扩展 &lt;code&gt;Common Test&lt;/code&gt; 使用挂钩之前，所有测试套件来电之后。CTH允许高级的 &lt;code&gt;Common Test&lt;/code&gt; 用户抽象出多个测试套件所共有的行为，而不会在所有测试套件中堆满库调用。这可用于记录，启动和监视外部系统，构建测试所需的C文件，等等。</target>
        </trans-unit>
        <trans-unit id="18cdc049609d4e15a26ab891a990c31ae80de460" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; and &lt;strong&gt;Edit&lt;/strong&gt; menus are the same as in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;和&amp;ldquo; &lt;strong&gt;编辑&amp;rdquo;&lt;/strong&gt;菜单与&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process Window&lt;/a&gt;&lt;/code&gt; 中的菜单相同。</target>
        </trans-unit>
        <trans-unit id="ff4e15bb4c0b2061b264590ff96d04af89b93805" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; menu includes options to save the contents of the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window. Simply choose the options and enter the file to save the contents in.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;菜单包含用于保存&amp;ldquo; &lt;strong&gt;日志&amp;rdquo;&lt;/strong&gt;窗口和&amp;ldquo; &lt;strong&gt;警告&amp;rdquo;&lt;/strong&gt;窗口的内容的选项。只需选择选项，然后输入文件以保存内容即可。</target>
        </trans-unit>
        <trans-unit id="370a6214852f8fdbb6373c8997912c0758173f20" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;File&lt;/strong&gt; window displays a listing of the current directory. Click your way to the directories/modules you want to add or type the correct path in the entry.</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;文件&amp;rdquo;&lt;/strong&gt;窗口显示当前目录的列表。单击您要添加的目录/模块的方式，或在条目中键入正确的路径。</target>
        </trans-unit>
        <trans-unit id="8e3940de2fcf0c6b61297d85ec453fc7187e592a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;OTP design principles&lt;/strong&gt; define how to structure Erlang code in terms of processes, modules, and directories.</source>
          <target state="translated">所述&lt;strong&gt;OTP设计原则&lt;/strong&gt;定义如何构建的Erlang代码中的过程，模块，和目录条款。</target>
        </trans-unit>
        <trans-unit id="ce6dbe8f8ec89aa3b4f8a5fbd8bce3df7dce0384" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;anonymous variable&lt;/strong&gt; is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</source>
          <target state="translated">所述&lt;strong&gt;匿名变量&lt;/strong&gt;由下划线表示（_），并且可以在需要的变量，但其值可以忽略使用。</target>
        </trans-unit>
        <trans-unit id="a6798179458a851b9ebec479cdde3c475bff4cbb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application resource file&lt;/strong&gt; specifies the resources an application uses, and how the application is started. There must always be one application resource file called &lt;code&gt;Application.app&lt;/code&gt; for each application &lt;code&gt;Application&lt;/code&gt; in the system.</source>
          <target state="translated">该&lt;strong&gt;应用程序资源文件&lt;/strong&gt;指定资源的应用程序的使用，以及应用程序的启动方式。系统中的每个应用程序 &lt;code&gt;Application&lt;/code&gt; 始终必须有一个名为 &lt;code&gt;Application.app&lt;/code&gt; 的应用程序资源文件。</target>
        </trans-unit>
        <trans-unit id="f6e14a23d7c2ef8d516ebeb71a889d63ab7e5e5f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;application upgrade file&lt;/strong&gt; defines how an application is upgraded or downgraded in a running system.</source>
          <target state="translated">该&lt;strong&gt;应用程序升级文件&lt;/strong&gt;定义了应用程序如何升级或正在运行的系统降级。</target>
        </trans-unit>
        <trans-unit id="2db57b7456855f2efbc5591cfd1f43a7d95e2566" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;boot script&lt;/strong&gt; describes how the Erlang runtime system is started. It contains instructions on which code to load and which processes and applications to start.</source>
          <target state="translated">该&lt;strong&gt;启动脚本&lt;/strong&gt;描述了Erlang运行时系统如何启动。它包含有关加载哪些代码以及启动哪些进程和应用程序的说明。</target>
        </trans-unit>
        <trans-unit id="5741097334e8b8597284eb3550244c5de695e977" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;callback mode&lt;/strong&gt; is selected when starting the &lt;code&gt;gen_statem&lt;/code&gt; and after code change using the return value from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;strong&gt;回调模式&lt;/strong&gt;开始时被选择 &lt;code&gt;gen_statem&lt;/code&gt; 并使用返回值从代码改变后 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010c2dfc5017e7774d251ec3e8505c4cdafc0e30" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;detailed table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;strong&gt;表&lt;/strong&gt;的&lt;strong&gt;详细事件&lt;/strong&gt;是元组，例如 &lt;code&gt;{Oper, Table, Data, [OldRecs], ActivityId}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="60cb531fb67c541100e62d6289d443a02cba5fa3" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty set&lt;/strong&gt; contains no elements.</source>
          <target state="translated">该&lt;strong&gt;空集&lt;/strong&gt;不包含任何元素。</target>
        </trans-unit>
        <trans-unit id="529d8e8336cfdf10118ffc9b093a47018a9c6171" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;mstone2&lt;/strong&gt; is similar to the &lt;strong&gt;mstone1&lt;/strong&gt; tool, but in this case, each created process makes only &lt;strong&gt;one&lt;/strong&gt; run through the messages and then exits. A soon as a process exits, a new process (with the same config and messages) is created to takes its place. The number of messages processed in total is the mstone2(1) value.</source>
          <target state="translated">所述&lt;strong&gt;mstone2&lt;/strong&gt;类似于&lt;strong&gt;mstone1&lt;/strong&gt;工具，但在这种情况下，每个所创建的过程使得仅&lt;strong&gt;一个&lt;/strong&gt;通过消息，然后退出运行。进程退出后，将立即创建一个具有相同配置和消息的新进程来代替它。总共处理的消息数为mstone2（1）值。</target>
        </trans-unit>
        <trans-unit id="b927187f56617f5aef02c9b312ff36f409a08649" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ordered pair&lt;/strong&gt; of a and b, with first &lt;strong&gt;coordinate&lt;/strong&gt; a and second coordinate b, is denoted (a, b). An ordered pair is an &lt;strong&gt;ordered set&lt;/strong&gt; of two elements. In this module, ordered sets can contain one, two, or more elements, and parentheses are used to enclose the elements.</source>
          <target state="translated">具有第一&lt;strong&gt;坐标&lt;/strong&gt; a和第二坐标b 的a和b 的&lt;strong&gt;有序对&lt;/strong&gt;表示为（a，b）。有序对是两个元素的&lt;strong&gt;有序集合&lt;/strong&gt;。在此模块中，有序集可以包含一个，两个或多个元素，并且括号用于将元素括起来。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c83c801cd635dbe318e9132115de7b55b1599720" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;receiver&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which expects a response (for example Get, GetNext, Get-Bulk, Set or Inform PDU).</source>
          <target state="translated">所述&lt;strong&gt;接收器&lt;/strong&gt;是&lt;strong&gt;权威&lt;/strong&gt;对于含有有效载荷，其期望的响应消息（例如GET，的GetNext，取块，设置或通知PDU）。</target>
        </trans-unit>
        <trans-unit id="ac92db4f0e00aaa89bb19e432441af806acad352" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release handler&lt;/strong&gt; process belongs to the SASL application, which is responsible for &lt;strong&gt;release handling&lt;/strong&gt;, that is, unpacking, installation, and removal of release packages.</source>
          <target state="translated">该&lt;strong&gt;发布处理器&lt;/strong&gt;进程属于SASL应用程序，这是负责&lt;strong&gt;发布处理&lt;/strong&gt;，即，启封，安装和拆卸版本的软件包。</target>
        </trans-unit>
        <trans-unit id="91dc52a591c8ca51fdb38124dea4daf9b7e6ea32" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release resource file&lt;/strong&gt; specifies which applications are included in a release (system) based on Erlang/OTP.</source>
          <target state="translated">在&lt;strong&gt;释放资源文件&lt;/strong&gt;基于二郎/ OTP哪些应用程序被包括在释放（系统）指定。</target>
        </trans-unit>
        <trans-unit id="ad1a94e9c3dc7a7604b7beecc0ad4192b022ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;release upgrade file&lt;/strong&gt; describes how a release is upgraded in a running system.</source>
          <target state="translated">该&lt;strong&gt;版本的升级文件&lt;/strong&gt;描述释放如何在正在运行的系统升级。</target>
        </trans-unit>
        <trans-unit id="df96a6a378319ab14151f9909dca99424881e367" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;sender&lt;/strong&gt; is &lt;strong&gt;authoritative&lt;/strong&gt; for messages containing payload which does &lt;strong&gt;not&lt;/strong&gt; expect a response (for example SNMPv2-Trap, Response or Report PDU).</source>
          <target state="translated">的&lt;strong&gt;发送者&lt;/strong&gt;是&lt;strong&gt;权威&lt;/strong&gt;对于含有有效载荷，其不消息&lt;strong&gt;不&lt;/strong&gt;期望（例如的SNMPv2-陷阱，响应或报告PDU）的响应。</target>
        </trans-unit>
        <trans-unit id="4ac925cddc8d38d70b14e09284795baa1f665f91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simple table events&lt;/strong&gt; are tuples like &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt;, where:</source>
          <target state="translated">在&lt;strong&gt;简单的表事件&lt;/strong&gt;都像元组 &lt;code&gt;{Oper, Record, ActivityId}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="2fcc34c431d064d6d4c4085640be13ac8df36a55" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;system tracer&lt;/strong&gt; for sequential tracing is automatically initiated by &lt;code&gt;ttb&lt;/code&gt; when a trace port is started with &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;ttb:tracer/0,1,2&lt;/code&gt; 启动跟踪端口时，由 &lt;code&gt;ttb&lt;/code&gt; 自动启动用于顺序跟踪的&lt;strong&gt;系统&lt;/strong&gt;跟踪程序。</target>
        </trans-unit>
        <trans-unit id="c33df7c3d6f3cf265ee046f5bbcec06d7fee2046" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;unordered set&lt;/strong&gt; containing the elements a, b, and c is denoted {a, b, c}. This notation is not to be confused with tuples.</source>
          <target state="translated">包含元素a，b和c 的&lt;strong&gt;无序集合&lt;/strong&gt;表示为{a，b，c}。该表示法不应与元组混淆。</target>
        </trans-unit>
        <trans-unit id="338f2ff3d932d37a0203031cf3c8ecd12e555100" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;xmerl&lt;/strong&gt; XML parser is able to parse XML documents according to the XML 1.0 standard. As default it performs well-formed parsing, (syntax checks and checks of well-formed constraints). Optionally one can also use xmerl as a validating parser, (validate according to referenced DTD and validating constraints). By means of for example the xmerl_xs module it is possible to transform the parsed result to other formats, e.g. text, HTML, XML etc.</source>
          <target state="translated">该&lt;strong&gt;xmerl&lt;/strong&gt; XML解析器能够解析XML文档根据XML 1.0标准。默认情况下，它执行格式正确的解析（语法检查和格式正确的约束检查）。也可以选择将xmerl用作验证解析器（根据引用的DTD和验证约束进行验证）。通过例如xmerl_xs模块，可以将解析的结果转换为其他格式，例如文本，HTML，XML等。</target>
        </trans-unit>
        <trans-unit id="639ddc138940995a6e19ca0db97584c255b5e3c9" translate="yes" xml:space="preserve">
          <source>The ACC time calculation is sometimes difficult to make correct, since it is difficult to define. This happens especially when a function occurs in several instances in the call stack, for example by calling itself perhaps through other functions and perhaps even non-tail recursively.</source>
          <target state="translated">ACC时间的计算有时很难做到正确,因为它很难定义。特别是当一个函数在调用堆栈中的几个实例中发生时,例如通过调用自己或许通过其他函数,甚至可能是非尾部递归地调用。</target>
        </trans-unit>
        <trans-unit id="57e2a8ffba28b7446bf70cbc1663f4839a28353c" translate="yes" xml:space="preserve">
          <source>The AND intersection of the list &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt; is also easily defined:</source>
          <target state="translated">列表 &lt;code&gt;L1&lt;/code&gt; 和 &lt;code&gt;L2&lt;/code&gt; 的AND相交也很容易定义：</target>
        </trans-unit>
        <trans-unit id="79ddb999f667f09a910e3689c6469b160527272a" translate="yes" xml:space="preserve">
          <source>The API for logging consists of a set of &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, and a set of functions on the form &lt;code&gt;logger:Level/1,2,3&lt;/code&gt;, which are all shortcuts for &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">记录的API由一组 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;logger:Level/1,2,3&lt;/code&gt; 表单上的一组函数组成，它们都是 &lt;code&gt;&lt;a href=&quot;logger#log-2&quot;&gt;logger:log(Level,Arg1[,Arg2[,Arg3]])&lt;/a&gt;&lt;/code&gt; 快捷方式。</target>
        </trans-unit>
        <trans-unit id="9d41ee39dfc3d3300eef2e7cc4120a5fd8d4f83d" translate="yes" xml:space="preserve">
          <source>The API is simple:</source>
          <target state="translated">API很简单。</target>
        </trans-unit>
        <trans-unit id="d4aca81b201537abe8dedf009dd68114d62d46d3" translate="yes" xml:space="preserve">
          <source>The API provided by Windows.</source>
          <target state="translated">Windows提供的API。</target>
        </trans-unit>
        <trans-unit id="ea6764678e9074dc87171f45bcd4511b8aa2d4d8" translate="yes" xml:space="preserve">
          <source>The ASN.1 application provides the following:</source>
          <target state="translated">ASN.1应用程序提供以下内容:</target>
        </trans-unit>
        <trans-unit id="9c1b6316b531e843db6912095bad2d7449901534" translate="yes" xml:space="preserve">
          <source>The ASN.1 code, the Erlang source code, and the generated &lt;code&gt;.hrl&lt;/code&gt; files for them are provided in the distribution and are placed in the directories &lt;code&gt;mibs&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt;, and &lt;code&gt;include&lt;/code&gt;, respectively, in the &lt;code&gt;snmp&lt;/code&gt; application.</source>
          <target state="translated">在发行版中提供了ASN.1代码，Erlang源代码以及为它们生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件，并将它们分别放在 &lt;code&gt;snmp&lt;/code&gt; 应用程序的目录 &lt;code&gt;mibs&lt;/code&gt; ， &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;include&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c4c076a03aaf6d1e948523fb216ccde0cc05b7f7" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler can be started directly from the command line by the &lt;code&gt;erlc&lt;/code&gt; program. This is convenient when compiling many ASN.1 files from the command line or when using Makefiles. Some examples of how the &lt;code&gt;erlc&lt;/code&gt; command can be used to start the ASN.1 compiler:</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 程序可以直接从命令行启动ASN.1编译器。从命令行编译许多ASN.1文件或使用Makefile时，这很方便。有关如何使用 &lt;code&gt;erlc&lt;/code&gt; 命令来启动ASN.1编译器的一些示例：</target>
        </trans-unit>
        <trans-unit id="fb22058cd698b91ccb24c3e367daf392b4a590e1" translate="yes" xml:space="preserve">
          <source>The ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can encode and decode the specified data types. Alternatively, the compiler takes a specification module specifying all input modules, and generates a module with encode/decode functions. In addition, some generic functions can be used during development of applications that handles ASN.1 data (encoded as &lt;code&gt;BER&lt;/code&gt; or &lt;code&gt;PER&lt;/code&gt;).</source>
          <target state="translated">ASN.1编译器将ASN.1模块作为输入，并生成相应的Erlang模块，该模块可以对指定的数据类型进行编码和解码。或者，编译器采用指定所有输入模块的规范模块，并生成具有编码/解码功能的模块。此外，在处理ASN.1数据（编码为 &lt;code&gt;BER&lt;/code&gt; 或 &lt;code&gt;PER&lt;/code&gt; ）的应用程序的开发过程中，可以使用一些通用功能。</target>
        </trans-unit>
        <trans-unit id="c60d4a11ddc52b500d299eda7e6852a95f2bae35" translate="yes" xml:space="preserve">
          <source>The ASN.1 specifications in the test were compiled with options &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; and &lt;code&gt;asn1config&lt;/code&gt;. Omitting option &lt;code&gt;driver&lt;/code&gt; gives higher values for &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;decode_part&lt;/code&gt;. These tests have not been rerun using NIFs, but are expected to perform about 5% better than the linked-in driver.</source>
          <target state="translated">测试中的ASN.1规范使用 &lt;code&gt;ber_bin, optimize, driver&lt;/code&gt; 和 &lt;code&gt;asn1config&lt;/code&gt; 选项进行编译。省略选项 &lt;code&gt;driver&lt;/code&gt; 可为 &lt;code&gt;decode&lt;/code&gt; 和 &lt;code&gt;decode_part&lt;/code&gt; 提供更高的值。尚未使用NIF重新运行这些测试，但预期这些测试的性能比链接驱动程序高约5％。</target>
        </trans-unit>
        <trans-unit id="2f22980605315f568d967ab23f6f0f04c10f0db4" translate="yes" xml:space="preserve">
          <source>The ASN.1 to Erlang compiler does not determine the correct interpretation of each BER string octet value with different character strings. The application is responsible for interpretation of octets. Therefore, from the BER string point of view, octets are very similar to character strings and are compiled in the same way.</source>
          <target state="translated">ASN.1到Erlang编译器并不能确定每个BER字符串八位数值与不同字符串的正确解释。应用程序负责解释八位组。因此,从BER串的角度来看,八位数与字符串非常相似,编译方式也相同。</target>
        </trans-unit>
        <trans-unit id="e882c6bd57a43305a3640939f477df3d4ead459d" translate="yes" xml:space="preserve">
          <source>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</source>
          <target state="translated">ASN.1类型可以是 &quot;证书&quot;、&quot;OTPC证书 &quot;或两者的子类型。</target>
        </trans-unit>
        <trans-unit id="a7a7f7547a93bea8b589e07f519f153c18f157b7" translate="yes" xml:space="preserve">
          <source>The AVPs of the message. Ignored for an outgoing message if the &lt;code&gt;msg&lt;/code&gt; field is set to a value other than &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">消息的AVP。如果 &lt;code&gt;msg&lt;/code&gt; 字段设置为 &lt;code&gt;undefined&lt;/code&gt; 以外的值，则忽略传出消息。</target>
        </trans-unit>
        <trans-unit id="bbe283419a75e9a012fbd1970d31d2b4f451187c" translate="yes" xml:space="preserve">
          <source>The Adler checksum of the dictionary is returned.</source>
          <target state="translated">返回字典的阿德勒校验和。</target>
        </trans-unit>
        <trans-unit id="c87eb8ebe47038b4ccdd22aaa97c4f88f2c5c087" translate="yes" xml:space="preserve">
          <source>The Application Id is set in the Diameter Header of outgoing messages of the application, and the value in the header of an incoming message is used to identify the relevant dictionary module.</source>
          <target state="translated">应用程序ID设置在应用程序的外发报文的Diameter Header中,传入报文的报头中的值用于识别相关的字典模块。</target>
        </trans-unit>
        <trans-unit id="f5de0091f6607fa5ed052b8880c8cef363f44808" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to do the actual changing of the type.</source>
          <target state="translated">审计跟踪日志是由网络接口流程管理的。所以,就是这个流程要进行实际的改型。</target>
        </trans-unit>
        <trans-unit id="4ffaae1f3e0b8fd90d36e73237642154e3434485" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to retrieve the actual log-type.</source>
          <target state="translated">审计跟踪日志是由网络接口进程管理的。所以,就是这个进程要检索实际的日志类型。</target>
        </trans-unit>
        <trans-unit id="56bc2b11b64e2a80365e104579b5470c818d8f1f" translate="yes" xml:space="preserve">
          <source>The Audit Trail Log is managed by the network interface process. So, it is this process that has to return the actual log-type.</source>
          <target state="translated">审计跟踪日志是由网络接口进程管理的。所以,就是这个进程要返回实际的日志类型。</target>
        </trans-unit>
        <trans-unit id="fb9967052a764c3afae20ad96d6a28a3fa28a91f" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; can also add match specifications to a function. A match specification comprises a pattern that the function arguments must match, a guard expression that must evaluate to &lt;code&gt;true&lt;/code&gt;, and an action to be performed. The default action is to send a trace message. If the pattern does not match or the guard fails, the action is not executed.</source>
          <target state="translated">BIF &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 也可以将匹配规范添加到函数中。匹配规范包括函数参数必须匹配的模式，必须评估为 &lt;code&gt;true&lt;/code&gt; 的保护表达式以及要执行的操作。默认操作是发送跟踪消息。如果模式不匹配或防护失败，则不执行操作。</target>
        </trans-unit>
        <trans-unit id="0e87dd32697c643963810be073120b237d9b1c65" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;open_port/2&lt;/code&gt; is documented in the &lt;code&gt;erlang&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">BIF &lt;code&gt;open_port/2&lt;/code&gt; 记录在ERTS 的 &lt;code&gt;erlang&lt;/code&gt; 手册页中。</target>
        </trans-unit>
        <trans-unit id="102d447ee7d66bcdc64a15b95caa727b7d5ec384" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; is used for estimating future loads. It returns the length of the queue of ready to run processes in the Erlang runtime system.</source>
          <target state="translated">BIF &lt;code&gt;statistics(run_queue)&lt;/code&gt; 用于估计将来的负载。它返回Erlang运行时系统中准备运行的进程的队列长度。</target>
        </trans-unit>
        <trans-unit id="a6a407c55efe87e4b70f70a1f8c95515dc9b4791" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;throw(Any)&lt;/code&gt; can be used for non-local return from a function. It must be evaluated within a &lt;code&gt;catch&lt;/code&gt;, which returns the value &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;throw(Any)&lt;/code&gt; 可用于函数的非本地返回。必须在 &lt;code&gt;catch&lt;/code&gt; 中对其求值，该catch返回值 &lt;code&gt;Any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ca995f69db34040dadf8f4fb8f2daa8f294d98" translate="yes" xml:space="preserve">
          <source>The BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; checks if a registered process of name &lt;code&gt;RegisteredName&lt;/code&gt; exists. If it exists, the pid of that process is returned. If it does not exist, the atom &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">BIF &lt;code&gt;whereis(RegisteredName)&lt;/code&gt; 检查是否存在名称为 &lt;code&gt;RegisteredName&lt;/code&gt; 的注册进程。如果存在，则返回该进程的pid。如果它不存在，则返回 &lt;code&gt;undefined&lt;/code&gt; 的原子。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
