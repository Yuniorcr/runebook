<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">请注意，RFC 6733要求端到端标识符在至少4分钟的时间内保持唯一，并且此速率和呼叫速率将 &lt;code&gt;N&lt;/code&gt; 的适当值设置为下限：以每秒 &lt;code&gt;R&lt;/code&gt; 个请求的速率（即 &lt;code&gt;N&lt;/code&gt; 位计数器在 &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; 分钟内遍历其所有值，因此界限为 &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab161900c8191797fce6b824ca72c3fe1be8d39b" translate="yes" xml:space="preserve">
          <source>Note that TLS-1.3 and TLS-1.2 cipher suites are not overlapping sets of cipher suites so to support both these versions cipher suites from both versions need to be included. If supporting TLS-1.3 versions prior to TLS-1.2 can not be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">请注意,\0dd总是一个八进制代码,\8和\9是字面意义上的 &quot;8 &quot;和 &quot;9&quot;。</target>
        </trans-unit>
        <trans-unit id="fa00a5e7155faa8238baf7626fd63ae2adafb209" translate="yes" xml:space="preserve">
          <source>Note that a &lt;strong&gt;state enter call&lt;/strong&gt;&lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this actually is not a &lt;strong&gt;state change&lt;/strong&gt;. In this case &lt;code&gt;OldState =:= State&lt;/code&gt;, which cannot happen for a subsequent state change, but will happen when repeating the &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">需要注意的是,字典模块应该有一个唯一的名字,这样才不会与系统中现有的模块相冲突。</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">请注意，当未指定 &lt;code&gt;return&lt;/code&gt; 选项时，字典的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 和 &lt;code&gt;outdir&lt;/code&gt; 选项一起确定输出路径。文字输入字典的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 默认为 &lt;code&gt;dictionary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">注意,如果epmd没有运行,分布式节点将无法启动。</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">请注意，给定对等方的单个 &lt;code&gt;up&lt;/code&gt; 或 &lt;code&gt;down&lt;/code&gt; 事件对应于多个 &lt;code&gt;peer_up/3&lt;/code&gt; 或 &lt;code&gt;peer_down/3&lt;/code&gt; 回调，其中一个针对在能力交换期间协商的每个Diameter应用程序。也就是说，事件在整体上与对等方通信，而回调在各个Diameter应用程序之间通信。</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">注意，状态输入调用&lt;strong&gt;将&lt;/strong&gt;在进入初始状态之前立即完成，即使这正式不是状态更改。在这种情况下， &lt;code&gt;OldState&lt;/code&gt; 将与 &lt;code&gt;State&lt;/code&gt; 相同，这在后续的状态更改中不会发生，但在重复状态enter调用时会发生。</target>
        </trans-unit>
        <trans-unit id="1a1ae5ee8fe086b1e864731f91a5db626649b898" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb520f2054c75e0b1b39831bcf49afdb1c0b3e3f" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case). So either immediately call the function or &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">注意，所有处理都在调用过程的上下文中完成。传输模块可以通过其中一个 &lt;code&gt;spawn&lt;/code&gt; 函数（例如 &lt;code&gt;spawn_opt&lt;/code&gt; ）调用此函数。另请参见 &lt;code&gt;receive_message/4,5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3db41f10bff721f3ee02192c83ee3f08a54b12b" translate="yes" xml:space="preserve">
          <source>Note that although guard expressions should only yield boolean values, this function does not guarantee that &lt;code&gt;Term&lt;/code&gt; is either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">请注意,一个SMIv2 MIB可以导入一个SMIv1 MIB,反之亦然。</target>
        </trans-unit>
        <trans-unit id="9b685cbc242545fbad15153c417da3182cac4fef" translate="yes" xml:space="preserve">
          <source>Note that an abstract atom may have several literal representations, and that the representation yielded by this function is not fixed; e.g., &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; could yield the string &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">请注意,一个别名只有在mib中才是唯一的,所以当把多个mib加载到一个管理器中时,可能会有几个相同的别名实例。</target>
        </trans-unit>
        <trans-unit id="ffe0be9b4d38daeed36a33562bc4da5606bc0b2f" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well when you have for example a status call as in section &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">请注意，事件超时不适用于例如状态为 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 或处理未知事件的状态调用，因为所有类型的事件都会取消事件超时。</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">请注意，一个继承的AVP，其设定所述V标志采取它的厂商ID从任 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 在继承字典或 &lt;code&gt;@vendor&lt;/code&gt; 在继承字典。特别是，继承的字典中的 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 将被忽略。从指定所需 &lt;code&gt;@vendor&lt;/code&gt; 的字典继承等效于将 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 与字典定义的副本一起使用，但是前者可以简化重用。</target>
        </trans-unit>
        <trans-unit id="6d33800347145579293148a2f5b8e31e3a2764de" translate="yes" xml:space="preserve">
          <source>Note that arguments for macros cannot be complex expressions, because the arguments are split on &lt;code&gt;,&lt;/code&gt;. For example, the following would not work because &lt;strong&gt;beam_makeops&lt;/strong&gt; would split the expression into two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">请注意， &lt;code&gt;cipher&lt;/code&gt; 中的两个列表都已更改为提供的值（ &lt;code&gt;'aes128-ctr'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a24670d7b6d01336c8695b5d4d57a391c44adcb2" translate="yes" xml:space="preserve">
          <source>Note that capabilities for an outgoing hello can be passed directly to &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">请注意,默认操作后的子句将被忽略。</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">请注意,client_random、server_random和master_secret是影响连接安全性的值。上面没有指定的有意义的原子是ssl选项名。</target>
        </trans-unit>
        <trans-unit id="f5dd2f74718152ce40902beac42e0c7a6f30ccfb" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random, master_secret and keylog are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bf6b7b0630a07fa672109442d6b02fb72a8793" translate="yes" xml:space="preserve">
          <source>Note that doing the primary log level filtering through a filter and not through the level is quite a lot more expensive, so make sure to test that your system can handle the extra load before you enable it on a production node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意，例如 &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; 代表`x \ ny'，`x \ 12y'，`x \ 012y'和`x \ ^ Jy \''中的任何一个和所有；参见 &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">请注意,每个元组传递一个或多个AVP值。指定重复的元组是错误的。</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">请注意,ec_gf2m并不是严格意义上的公钥算法,而是对ecdsa和ecdh支持哪些曲线的限制。</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请注意，即使此函数返回的 &lt;code&gt;Tail&lt;/code&gt; 值不是 &lt;code&gt;none&lt;/code&gt; ，如果显式指定了tail且列表框架尚未压缩（请参见 &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;Tail&lt;/code&gt; 的类型也可以为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="192c5999ce9ab89a2a2dbe3ec7c900d7ee1db0a4" translate="yes" xml:space="preserve">
          <source>Note that file and line have to be added in the metadata by the caller of &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; as otherwise Logger will not know from where it was called. The file and line number are automatically added if you use the &lt;code&gt;?LOG_ERROR&lt;/code&gt; macros in &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c389355e70f459658e087541ff06cacc40c70758" translate="yes" xml:space="preserve">
          <source>Note that for e.g. &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt;, most implementations doing a close does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">请注意，如果 &lt;code&gt;EngineId&lt;/code&gt; 具有 &lt;code&gt;discovery&lt;/code&gt; 值，则代理无法向该管理器发送 &lt;code&gt;inform&lt;/code&gt; 消息，直到它与该管理器执行了&lt;strong&gt;发现&lt;/strong&gt;过程。</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">请注意，如果使用 &lt;code&gt;udp&lt;/code&gt; ，则相同的传输过程可以用于多个连接。这样可能无法升级。</target>
        </trans-unit>
        <trans-unit id="18ab9ea99f0d2ed9aaa93df42d7129d992c9c108" translate="yes" xml:space="preserve">
          <source>Note that if a length (&lt;code&gt;&amp;gt; 0&lt;/code&gt;) is specified, and only part of that amount of data is available, the function will return with that data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait for the remaining data, it must immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">请注意，如果未提供 &lt;code&gt;port&lt;/code&gt; ，并且 &lt;code&gt;taddress&lt;/code&gt; 不包含端口号，则使用默认值。</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">请注意，如果未给出 &lt;code&gt;tdomain&lt;/code&gt; ，则使用默认值 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de8909d667626be185465024dfa8ebbd745359a8" translate="yes" xml:space="preserve">
          <source>Note that if not all the data was sent, the function will return with the remaining data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait to be able to send the rest, it should immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">请注意，如果 &lt;code&gt;gen_statem&lt;/code&gt; 是通过 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; 启动的，则永远不会调用此回调。由于此回调不是可选的，因此在这种情况下可以实现为：</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">请注意，如果Version参数是 &lt;code&gt;dynamic&lt;/code&gt; ，则解码器应尝试从消息本身中找出实际版本，然后使用适当的解码器，例如version 1。</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">请注意，如果主体较小，则所有数据只能以一个块的形式传递，然后将使用{last，Data :: binary（），undefined}调用回调，而不会使用 &lt;code&gt;{first, Data::binary()}&lt;/code&gt; 调用回调。</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">注意，如果对于标记为关键的扩展名，fun返回 &lt;code&gt;unknown&lt;/code&gt; ，则验证将失败。</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">请注意，如果选项 &lt;code&gt;warnings&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，而选项 &lt;code&gt;verbosity&lt;/code&gt; 为 &lt;code&gt;silence&lt;/code&gt; ，则仍将显示警告消息。</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将答复分段（分成几个较小的消息；分段），则 &lt;code&gt;UserReply&lt;/code&gt; 中还将包含一些额外的信息，分段编号以及是否已接收到答复的所有分段的指示。</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">请注意,在Erlang中,如果没有指定超时部分,receive-expression必须至少有一个子句。</target>
        </trans-unit>
        <trans-unit id="08a96fc716918fe5871d98094662c927e7804b46" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629d6084a6f0543f14df18dbc3535aef38711dc0" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">请注意，在大多数TCP实现中，执行 &lt;code&gt;close&lt;/code&gt; 并不能保证在远程端检测到关闭之前，已发送的任何数据都已传递给接收方。如果要保证将数据传递给收件人，可以通过两种常用方法来实现。</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">请注意，为了让reltool进行排序版本的应用程序，从而能够选择最新，要求该版本ID为唯一整数点的应用consits，例如 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2.0&lt;/code&gt; 或 &lt;code&gt;3.17.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">请注意，无论传递的 &lt;code&gt;InEncoding&lt;/code&gt; 如何，列表中的整数始终表示代码点。如果传递了 &lt;code&gt;InEncoding latin1&lt;/code&gt; ，则仅允许&amp;lt;256个代码点；否则，将允许所有有效的unicode代码点。</target>
        </trans-unit>
        <trans-unit id="6b71fac57eccdc841417bdc84d942c5ed4df483a" translate="yes" xml:space="preserve">
          <source>Note that it also blocks other operations than just &lt;code&gt;rpc:block_call()&lt;/code&gt; operations, so use it with care.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">请注意，最简单的方法是使用帮助函数（例如上面的 &lt;code&gt;lazy_gen/1&lt;/code&gt; 函数）编写这种递归生成器。如果您不想使您的函数名称空间混乱并且对编写这种代码感到满意，也可以使用递归的乐趣来编写它。</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">注意,不可能也不需要取消这个超时,因为它会被任何其他事件自动取消。</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">请注意，此函数可以通过返回更新的 &lt;code&gt;Targets&lt;/code&gt; 列表（ &lt;code&gt;NewTargets&lt;/code&gt; ）来过滤掉目标（但&lt;strong&gt;不能&lt;/strong&gt;添加自己的目标）。</target>
        </trans-unit>
        <trans-unit id="e68901639556f6e842921bc4c6aab5754c944701" translate="yes" xml:space="preserve">
          <source>Note that it is up to the user to ensure that correct code to execute via &lt;code&gt;erpc&lt;/code&gt; is available on the involved nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">请注意,它很少需要被显式启动,因为它是由需要运行服务器的函数自动启动的。</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">需要注意的是,它的实现取决于(也取决于是否使用了mib-存储)是否可以进行备份。</target>
        </trans-unit>
        <trans-unit id="1fddaac0c2eba362c90fcf63bcdd71ddcd1d0713" translate="yes" xml:space="preserve">
          <source>Note that just because we have a documented and described option, it does &lt;strong&gt;not&lt;/strong&gt; mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec78a15c5217c92c95a49b94462adac13df7646" translate="yes" xml:space="preserve">
          <source>Note that new types may be added in the future, so the caller must be prepared to handle unknown types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">请注意，不会检查 &lt;code&gt;Name&lt;/code&gt; 是否是保留的属性名称（例如 &lt;code&gt;module&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; )：假定属性为&amp;ldquo; wild&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">请注意,此函数不会影响全局跟踪模式。</target>
        </trans-unit>
        <trans-unit id="c9dbd761e7b3ccf030e5d2634d121608a5fc566a" translate="yes" xml:space="preserve">
          <source>Note that not all individual &lt;code&gt;Option&lt;/code&gt;s are checked when the spawn request is sent. Some &lt;code&gt;Option&lt;/code&gt;s can only be checked on reception of the request. Therefore an invalid option does &lt;strong&gt;not&lt;/strong&gt; cause a &lt;code&gt;badarg&lt;/code&gt; exception, but will cause the spawn operation to fail with an error reason of &lt;code&gt;badopt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1046cde1e5db61beca0efc3f9616a4641ffd20" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7f42298d81e647ec75e32ec8f0a6e4e85efbf7" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb7d234e889fecf34a0a8cc44508f7dd715d1f4" translate="yes" xml:space="preserve">
          <source>Note that only one transport per kind for each transport domain can be configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef85014f2633aed4a8852aa3b53ebbaf3622c48" translate="yes" xml:space="preserve">
          <source>Note that only the exec channel is closed after the one-time execution. The connection is still up and can handle previously opened channels. It is also possible to open a new channel:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">请注意，执行配置功能或测试用例的过程永远不会包含在 &lt;code&gt;TestProcs&lt;/code&gt; 中。因此，可以安全地使用后配置挂钩函数（例如post_end_per_suite，post_end_per_group，post_end_per_testcase）终止 &lt;code&gt;TestProcs&lt;/code&gt; 中所有以当前组长进程作为其组长的进程。</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">需要注意的是原始文件名&lt;strong&gt;没有&lt;/strong&gt;一定的编码方式为在操作系统级别相同。</target>
        </trans-unit>
        <trans-unit id="82914e4f408f26df4d5bb211a9e507c3fd9f2819" translate="yes" xml:space="preserve">
          <source>Note that some curves are disabled if FIPS is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb3e885aec0adb2e32b31326d16ceb9409b7c9f" translate="yes" xml:space="preserve">
          <source>Note that spaces are preserved and that no point (.) is needed at the end - that was required by the default evaluator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">请注意，在文本（&amp;lt;，&amp;gt;和＆）中的特殊字符将被打印到日志文件之前，Common Test将对其进行转义。</target>
        </trans-unit>
        <trans-unit id="863f3323e07ccde5b57c1b225a8cb6abcf3f22bb" translate="yes" xml:space="preserve">
          <source>Note that the &quot;super&quot; in super alignment and the &quot;super&quot; in super carrier has nothing to do with each other. We could have choosen another naming to avoid confusion, such as &quot;meta&quot; carrier or &quot;giant&quot; aligment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27bd01e0ed18a111b98018e635bbdb5be686872" translate="yes" xml:space="preserve">
          <source>Note that the (new) extended transport entries (including &lt;code&gt;Kind&lt;/code&gt; and &lt;code&gt;Opts&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; specify port-info as they ignore any value specified by &lt;code&gt;intAgentUDPPort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">请注意，并非在所有实现中都使用 &lt;code&gt;RecordName&lt;/code&gt; 和 &lt;code&gt;Fields&lt;/code&gt; 参数（实际上，仅基于mnesia的实现才需要它们）。</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">注意， &lt;code&gt;erl_parse&lt;/code&gt; 表示对于&amp;ldquo; &lt;code&gt;FunctionType&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;fun(FunctionType)&lt;/code&gt; &amp;rdquo; 是相同的。</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">需要注意的是该&lt;strong&gt;教派&lt;/strong&gt;曲线GF2m（特征二）曲线，并且只支持如果底层OpenSSL无法对他们的支持。另见 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">请注意,有关的AVP可以在继承的字典中定义,以便为另一个字典中定义的枚举引入额外的值。</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">请注意,该AVP的CCF与RFC 3588中的CCF是不一样的。</target>
        </trans-unit>
        <trans-unit id="3839e34d035de6fcffb30bf27e41d5c5ddbeeb10" translate="yes" xml:space="preserve">
          <source>Note that the actual definition of (some of) these records depend on the megaco protocol version used. For instance, the &lt;code&gt;'TransactionReply'&lt;/code&gt; record has two more fields in version 3, so a simple erlang type definition cannot be made here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">请注意，实际支持的dss_digest_type取决于基础加密库。在OpenSSL版本&amp;gt; = 1.0.1中，支持列出的摘要，而在1.0.0中仅支持sha，sha224和sha256。在0.9.8版中，仅支持sha。</target>
        </trans-unit>
        <trans-unit id="3b70bc0ac9ae266a36a7ccaa90cb46529ab3a596" translate="yes" xml:space="preserve">
          <source>Note that the algorithms in the file &lt;code&gt;ex2.config&lt;/code&gt; is not yet applied. They will be when we start ssh:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7c24f4a4a2d3cbb7e5f46db8ca5bbd93271e2c" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdefbbcdb7a6e85db537e1b6266c9775e69d082" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">需要注意的是,追加的算法从原来的地方去掉,然后追加到同一个列表中。</target>
        </trans-unit>
        <trans-unit id="3ccb116cfa36059b115c940833292db4f44f844b" translate="yes" xml:space="preserve">
          <source>Note that the buffer pointed to by the &lt;code&gt;outbuf&lt;/code&gt; argument must be large enough if a non &lt;code&gt;NULL&lt;/code&gt; value is passed as &lt;code&gt;outbuf&lt;/code&gt;. You typically want to call &lt;code&gt;ei_decode_iodata()&lt;/code&gt; twice. First with a non &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; argument and a &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;outbuf&lt;/code&gt; argument in order to determine the size of the buffer needed, and then once again in order to do the actual decoding. Note that the integer pointed to by &lt;code&gt;index&lt;/code&gt; will be updated by the call determining the size as well, so you need to reset it before the second call doing the actual decoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">请注意,如果只指定打印输出的重要性,则不需要类别参数。例如:</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">请注意,客户可以自由使用任何命令和排除方法。</target>
        </trans-unit>
        <trans-unit id="468edd7f0dc67514b910bd2116ac92cf52f20c09" translate="yes" xml:space="preserve">
          <source>Note that the command specified with the &lt;code&gt;-rsh&lt;/code&gt; flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt;, so the &lt;code&gt;erl&lt;/code&gt; command must be found in the path on the remote host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">请注意，编译器可能会优化掉原子。例如，编译器会将 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 重写为 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 。如果该表达式是包含模块中唯一提及原子 &lt;code&gt;some_atom&lt;/code&gt; 的元素，则在加载模块时将不会创建该原子，并且随后对 &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">请注意，编译器可能会优化掉原子。例如，编译器会将 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 重写为 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 。如果该表达式是包含模块中唯一提及原子 &lt;code&gt;some_atom&lt;/code&gt; 的元素，则在加载模块时将不会创建该原子，并且随后对 &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; 调用将失败。</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">请注意，从导入（加载）的mib中提取的数据部分由mib服务器存储，部分由符号存储服务器存储。有关详细信息，请参见默认的mib服务器数据模块 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">请注意，事件 &lt;code&gt;$s | $S&lt;/code&gt; ， &lt;code&gt;l | $L&lt;/code&gt; 和 &lt;code&gt;$z | $Z&lt;/code&gt; 与使用相同字符的计时器无关。</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">请注意，现有的 &lt;code&gt;.beam&lt;/code&gt; 文件必须包含&lt;strong&gt;抽象代码&lt;/strong&gt;，即它必须已使用 &lt;code&gt;debug_info&lt;/code&gt; 选项进行编译。如果不是，则返回错误原因 &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; 。如果抽象代码已加密，并且没有可用的密钥对其进行解密 &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; 返回错误原因{encrypted_abstract_code，BeamFile}。</target>
        </trans-unit>
        <trans-unit id="efa3ec631430748847eae6fa5201d4a2accae7a7" translate="yes" xml:space="preserve">
          <source>Note that the first two instruction have three fragments, while the other two only have two fragments. Here are the fragments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">请注意,以下内容将始终被加载。</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">请注意,该函数不会检查该条目是否已经存在。</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">请注意,生成的证书和密钥并不能提供一个正式正确的PKIX-信任链,它们不能用来实现真正的安全。此功能仅用于测试目的。</target>
        </trans-unit>
        <trans-unit id="078ffae6e673ee69ef0d8a166daaaedfa933f1dd" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they cannot be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6ba71f76cfedfe0e85aa82b7676692388cd2df" translate="yes" xml:space="preserve">
          <source>Note that the internal data that the &lt;code&gt;StateEnc&lt;/code&gt; and &lt;code&gt;StateDec&lt;/code&gt; references are destructivly updated by the calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt;. This is to gain time in the calls of the nifs interfacing the cryptolib. In a loop where the state is saved in the loop's state, it also saves one update of the loop state per crypto operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">请注意,在编译过程中,内部数据库是(重新)启动的,这意味着任何以前收集的模块的覆盖数据将丢失。</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">请注意，网络接口过滤器是应用程序（ &lt;code&gt;snmpa_net_if&lt;/code&gt; ）提供的网络接口实现所使用的东西。默认过滤器接受所有消息。</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">请注意，网络接口过滤器是应用程序提供的网络接口实现（ &lt;code&gt;snmpm_net_if&lt;/code&gt; 和 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ）使用的东西。默认过滤器接受所有消息。</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">请注意，以这种方式实际启动代理的唯一方法是在启动应用程序之后添加与代理相关的配置（例如，它不能成为常规应用程序配置的一部分sys.config）。可以通过调用以下命令完成： &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">请注意，以这种方式实际启动管理器的唯一方法是在启动应用程序后添加与管理器相关的配置（例如，它不能是常规应用程序配置sys.config的一部分）。可以通过调用以下命令完成： &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe1baccf1828d7692350ac5f909a060eecbece59" translate="yes" xml:space="preserve">
          <source>Note that the order of the tuples in the resulting list is undefined and may change at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb3c0cb2baba7b63c67e88c6cd13cca1a7e679" translate="yes" xml:space="preserve">
          <source>Note that the order that things are printed have changed, and also I added a reverse-dns lookup of the IP address. This will not print as nicely when using a single line formatter, however you can also use a report_cb fun with 2 arguments where the second argument is the formatting options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">注意,列表中元组的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">请注意，调用此函数的过程&lt;strong&gt;必须&lt;/strong&gt;是永久的。如果它死了，端口将退出并且驱动程序卸载。</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">请注意，如果使用此功能，则检测功能无法访问特定于请求的参数（例如 &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">请注意，如果使用此功能，则检测功能无法访问特定于请求的参数（例如 &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">请注意，取决于使用哪个功能来发出原始请求，这些段以不同的方式交付给用户。当使用 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; 函数发出请求时，这些段在到达时通过 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 回调函数一次传递给用户。但这显然不适用于 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 函数。在这种情况下，段会被累积，然后在函数返回时立即全部交付。</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">需要注意的是,TSL需要ssl应用,并且必须在直径传输上配置TLS功能之前启动。</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">请注意，未提及的列表（ &lt;code&gt;public_key&lt;/code&gt; ， &lt;code&gt;cipher&lt;/code&gt; ， &lt;code&gt;mac&lt;/code&gt; 和 &lt;code&gt;compression&lt;/code&gt; ）未更改。</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">请注意，如果代理要&amp;ldquo;模拟&amp;rdquo;多个EngineID，则仅在特殊情况下才使用LocalEngineID参数！默认情况下，代理使用 &lt;code&gt;SnmpEngineID&lt;/code&gt; 的值（请参阅SNMP-FRAMEWORK-MIB）。</target>
        </trans-unit>
        <trans-unit id="f2ec007dbfec9a50f3790ddfb78b2d7470067938" translate="yes" xml:space="preserve">
          <source>Note that the very first thing done is to fetch the address to the next instruction. The reason is that it usually improves performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56e76ea1af9a17fd56fb02b811e895206d51eb5" translate="yes" xml:space="preserve">
          <source>Note that there is a special case when the value of &lt;code&gt;ReqId&lt;/code&gt; has the value of the atom &lt;code&gt;netif&lt;/code&gt;. This means that the NetIF process has suffered a &quot;fatal&quot; error and been restarted. With possible loss of traffic!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">请注意，与 &lt;code&gt;transport&lt;/code&gt; 信息相反，可能有多个具有相同 &lt;code&gt;ref&lt;/code&gt; 的条目。</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">请注意,每个连接必须有一个分配控制器。一个进程或端口只能成为一个连接的分配控制器。不能撤销作为分配控制器的注册。它将保持不变,直到分配控制器终止。分布控制器不应忽略退出信号。允许它捕捉退出信号,但当收到退出信号时,它应该主动终止。</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">请注意，&lt;strong&gt;仅&lt;/strong&gt;当在代理进程的上下文中执行这些功能时，才会由检测功能调用这些功能（例如，如果从生成的进程中调用，则这些功能将不起作用）。</target>
        </trans-unit>
        <trans-unit id="05534c73155b84674fad449b2de6066e6ecf290c" translate="yes" xml:space="preserve">
          <source>Note that this can cause the message queue to overflow causing for example the virtual machine to run out of memory and crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">请注意，此检查使用已加载或将在使用时加载的应用程序版本。您的应用程序版本可能满足系统中安装的所有依赖关系，但是如果未加载所有依赖关系，此检查将失败。当这样使用时，系统当然也会失败。当您在系统中安装了同一应用程序的多个 &lt;code&gt;branched versions&lt;/code&gt; ，但是没有使用 &lt;code&gt;boot script&lt;/code&gt; 标识正确的应用程序版本时，可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">请注意,这不会影响堆栈自主发送的消息。它们使用的是连接信息的protocol_version。</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">请注意,这个函数是在主代理进程的上下文中执行的。</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">请注意，仅当用户将 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config选项设置为 &lt;code&gt;true&lt;/code&gt; &lt;strong&gt;且&lt;/strong&gt;实际上是消息重新发送时，才会调用此函数。如果&lt;strong&gt;这两个&lt;/strong&gt;条件都不&lt;strong&gt;同时&lt;/strong&gt;满足，将调用 &lt;code&gt;send_message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">请注意,这对待处理事务的实际发送没有影响。这要么是隐含的(例如当收到一个正在处理的请求的重新发送的事务请求时),要么由pending_timer控制,见上文。</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">请注意,这对配置文件所定义的应用程序配置没有影响,所以节点重启会将配置恢复到这些文件中的任何内容。</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">请注意,这个标识符有时也被称为 &quot;名称&quot;。现在尽可能地使用 &quot;标识符 &quot;或 &quot;id&quot;,但为了保持向后的兼容性,仍然可以找到 &quot;name &quot;的出现,例如在错误信息中。</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">请注意,这也是一次recv调用可以接收的最大数据量。如果你使用的MTU比正常的高,可以考虑将缓冲区设置得更高。</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">请注意，这只是一个实用程序函数，它完成将给定字符串拆分为由空格分隔的单词并设置带有适当缩进的 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; （包含 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 元素列表）的所有工作。</target>
        </trans-unit>
        <trans-unit id="3e4569ecffb57e143102668b7a6dd11b0264d4d3" translate="yes" xml:space="preserve">
          <source>Note that this list might be reduced if the underlying libcrypto does not support all of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">请注意,这可能是一个不完整的需要更新的文件列表。</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">请注意，只有在 &lt;code&gt;sent_pending_limit&lt;/code&gt; 配置选项已设置为整数值的情况下，此选项才能按指定方式工作。</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">请注意,这整个模块是实验性的,所使用的表示方法以及功能在未来可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">请注意,这将永远是被调用的默认用户。</target>
        </trans-unit>
        <trans-unit id="2e15a72745c4b2259c54938521a47a61a3e00dfd" translate="yes" xml:space="preserve">
          <source>Note that to enable FIPS mode succesfully, OTP must be built with the configure option &lt;code&gt;--enable-fips&lt;/code&gt;, and the underlying libcrypto must also support FIPS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">请注意,事务ID是(目前)以每个用户为基础进行维护的,所以无法确定返回的值是否真的会被用于在这个连接上发送的事务(如果一个用户有多个连接,这并不是不可能的)。</target>
        </trans-unit>
        <trans-unit id="bfaf8929b2a813d73b67b54b1a840c42370aef06" translate="yes" xml:space="preserve">
          <source>Note that up until here it is not allowed to fragments the message. The entire atom cache and control message has to be part of the starting fragment. After the control message the payload of the message is sent using 128 bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c2bdc163cd56fda0bc897570388a7d7819f96a" translate="yes" xml:space="preserve">
          <source>Note that user defined custom &lt;code&gt;verify_fun&lt;/code&gt; may alter original path validation error (e.g &lt;code&gt;selfsigned_peer&lt;/code&gt;). Use with caution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfc282f9f5a7f60dc04c61e35f9a1919be96f74" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">请注意，使用 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 中的此操作在巫术的边界上会很奇怪，因为在此服务器中没有更早地调用 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">请注意，在编译模块时，将&lt;strong&gt;删除所有现有的coverage数据&lt;/strong&gt;，包括导入的数据。如果在导入数据时已经编译了模块，则导入的数据将&lt;strong&gt;添加&lt;/strong&gt;到现有coverage数据中。</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">请注意，当要输入的数据值是字符串时，必须用 &lt;code&gt;'&lt;/code&gt; 引起来。例：</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">请注意，只要&amp;ldquo;文档&amp;rdquo;中的 &lt;code&gt;Docs&lt;/code&gt; 包含换行符，它将被放置在单独的行上。因此，无论是</target>
        </trans-unit>
        <trans-unit id="f445dc35aa8bfa91f3e834a45f7fca092ded7275" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;TCP_NOPUSH&lt;/code&gt; socket option is available on OSX, its semantics is very different (e.g., unsetting it does not cause immediate send of accumulated data). Hence, &lt;code&gt;nopush&lt;/code&gt; option is intentionally ignored on OSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">请注意，在脏的I / O调度程序上执行的工作应主要等待I / O。也就是说，当您在脏的I / O调度程序上获得较高的调度程序利用率时，由于这项工作，预计CPU利用率&lt;strong&gt;不会&lt;/strong&gt;很高。</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">请注意，您不能在交叉编译配置文件中定义任意变量。在所有 &lt;code&gt;configure&lt;/code&gt; 脚本的整个执行过程中，仅保证以下列出的内容可见。需要将其他变量定义为在环境中 &lt;code&gt;configure&lt;/code&gt; 或导出的参数。</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">请注意，在Windows上构建任何东西之前，需要在特定的shell中运行 &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; 。完成make opt后，您可以通过运行 &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; 来测试结果。如果要将结果复制到发布目录（例如 &lt;code&gt;/tmp/erl_release&lt;/code&gt; ），请执行此操作（仍在 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">请注意，在执行此操作时，您应该在路径中有一个新鲜的Erlang，最好是在先前步骤中构建的普通21。您还可以在重建特定库之前将 &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; 添加到 &lt;code&gt;PATH&lt;/code&gt; 中。那将为您提供足够好的Erlang系统来编译任何OTP erlang代码。正确设置路径有些棘手。在路径中的实际仿真器&lt;strong&gt;之前&lt;/strong&gt;，您仍然需要具有 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 。使用引导程序编译器的路径的典型设置为：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0eb0b5bede55df32486ffb5e68143aaf83b271f3" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 23 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">请注意，作为指示最新文件的一种方式， &lt;code&gt;run_erl&lt;/code&gt; 将删除最旧的日志文件以在文件序列中保留&amp;ldquo;空洞&amp;rdquo;。例如，如果日志文件＃1，＃2，＃4和＃5存在，则意味着＃2是最新的，而＃4是最早的。因此，您获得的日志文件最多比 &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; 设置的值少一个。</target>
        </trans-unit>
        <trans-unit id="cc609e818cd60886eb0217d87244da60ff760651" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;move c xy&lt;/code&gt; and &lt;code&gt;move c d&lt;/code&gt;. Note that &lt;code&gt;move c xy&lt;/code&gt; is equivalent to the following two definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">请注意，您可以使用 &lt;code&gt;throw&lt;/code&gt; 返回结果，这很有用。例如，在无法返回 &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 的复杂代码中深入使用 &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; 进行纾困，因为 &lt;code&gt;State&lt;/code&gt; 或 &lt;code&gt;Data&lt;/code&gt; 不在范围内。</target>
        </trans-unit>
        <trans-unit id="7f3c2db9a65e908102a67487ed12c89a758f057f" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that cannot return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">注意这个选项在正常的TLS使用中是不需要的,也不应该用来实现新的客户端。但是,传统的客户端会以以下方式重试连接。</target>
        </trans-unit>
        <trans-unit id="3157e5999d26e98c016dbd63bda9ac9a0dfb9593" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Clause&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">注意：识别 &lt;code&gt;arity_qualifier&lt;/code&gt; 节点。这是遵循Erlang Parser的狂野属性：{F，A}和F / A都可以识别的，这使得可以将狂野属性转换为公认的属性，而同时又无法使用旧版本的Erlang编译器提供了新语法。</target>
        </trans-unit>
        <trans-unit id="d81e2383b82cc4e91e2f04de6cf454f9653c7f46" translate="yes" xml:space="preserve">
          <source>Note: All instances of free variables will be given distinct labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b61204a294edc11d57ba05c5e469df9123163d6" translate="yes" xml:space="preserve">
          <source>Note: Because &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf9d511dcfa9aaf58ab7283975eec8497bcb0e4" translate="yes" xml:space="preserve">
          <source>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">注意：当前，具有具体表示形式的语法树的集合大于可以使用函数 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 构建的树的集合。抽象字符将具体化为整数，而 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 目前不会为任何输入产生抽象字符。（使用 &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; 函数显式创建一个抽象字符。）</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">注意：如果文档中的某些 &lt;code&gt;Docs&lt;/code&gt; 包含换行符，则将始终选择垂直布局。</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">注意：如果在尝试合并文件时收到&amp;ldquo;语法错误&amp;rdquo;消息（并且您知道这些文件是正确的），请尝试&amp;ldquo; &lt;code&gt;preprocess&lt;/code&gt; 选项。通常，这意味着您的代码包含太多奇怪的宏，无法在不实际执行预处理器扩展的情况下进行处理。</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">注意：由于 &lt;code&gt;Node&lt;/code&gt; 是语法树，因此与其子树相对应的实际运行时值通常可能是部分或完全未知的。因此，如果 &lt;code&gt;Node&lt;/code&gt; 表示例如&amp;ldquo; &lt;code&gt;[... | Ns]&lt;/code&gt; &amp;rdquo;（其中 &lt;code&gt;Ns&lt;/code&gt; 是变量），则该函数将返回 &lt;code&gt;false&lt;/code&gt; ，因为尚不清楚 &lt;code&gt;Ns&lt;/code&gt; 是否在运行时绑定到列表。如果 &lt;code&gt;Node&lt;/code&gt; 相反表示&amp;ldquo; &lt;code&gt;[1, 2, 3]&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;[A | []]&lt;/code&gt; &amp;rdquo;，则该函数将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">注意：Erlang语言具有不同的1元组，即 &lt;code&gt;{X}&lt;/code&gt; 始终与 &lt;code&gt;X&lt;/code&gt; 本身不同。</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">注意：为了避免破坏动态代码替换的语义，必须区分&amp;ldquo;静态&amp;rdquo;模块和&amp;ldquo;安全&amp;rdquo;模块。除非目标模块也将被替换，否则&amp;ldquo;静态&amp;rdquo;源模块将不会被替换。现在想象一下一个状态机，该状态机是通过将每个状态的代码放在单独的模块中来实现的，并假设我们要将其合并到单个目标模块中，并将所有源模块标记为静态。在原始代码中从模块之一调用到另一个模块的每个点（即状态转换），都期望检测到代码替换。然后，如果我们在合并的代码中不检查这些点上的&lt;strong&gt;目标&lt;/strong&gt;模块（合并的结果）已被替换，我们通常无法确定我们将能够对合并的状态机进行代码替换-它可以永久运行而不会检测到代码更改。因此，所有此类调用都必须保留为远程调用（检测代码更改），但可以直接调用目标模块。</target>
        </trans-unit>
        <trans-unit id="8daa2d5e45d509f284f5f3a9bb9a8c05ad568947" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we cannot be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9850cccf6fb6ccf68d12503d679738d939b63a6a" translate="yes" xml:space="preserve">
          <source>Note: The name of the primary constructor function for a node type is always the name of the type itself, prefixed by &quot;&lt;code&gt;c_&lt;/code&gt;&quot;; recognizer predicates are correspondingly prefixed by &quot;&lt;code&gt;is_c_&lt;/code&gt;&quot;. Furthermore, to simplify preservation of annotations (cf. &lt;code&gt;get_ann/1&lt;/code&gt;), there are analogous constructor functions prefixed by &quot;&lt;code&gt;ann_c_&lt;/code&gt;&quot; and &quot;&lt;code&gt;update_c_&lt;/code&gt;&quot;, for setting the annotation list of the new node to either a specific value or to the annotations of an existing node, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">注意：预处理程序宏定义指令&amp;ldquo; &lt;code&gt;-define(Name, Body).&lt;/code&gt; &amp;rdquo;对 &lt;code&gt;Body&lt;/code&gt; 的语法形式的要求相对较少（视为标记序列）。该 &lt;code&gt;text&lt;/code&gt; 节点类型可以被用于 &lt;code&gt;Body&lt;/code&gt; 这不是一个正常的Erlang构建体。</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">注意:节点类型的主构造函数应该总是与节点类型本身具有相同的名称。</target>
        </trans-unit>
        <trans-unit id="8ca2fedd6ed2548e302789ae2e0c23407f15fd76" translate="yes" xml:space="preserve">
          <source>Note: This is a constant time operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="961e68d5ec80ea10407155400f5248fb08c77ba7" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;length(values_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="1c349a183f568e3a4f03fe936ebb15f7b0b8d9c0" translate="yes" xml:space="preserve">
          <source>Note: all literals (cf. &lt;code&gt;is_literal/1&lt;/code&gt;) are leaf nodes, even if they represent structured (constant) values such as &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt;. Also note that variables are leaf nodes but not literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ca5b0925ea2a2251f51d1eef2e90cac1124164" translate="yes" xml:space="preserve">
          <source>Note: catch-expressions can be rewritten as try-expressions, and will eventually be removed from Core Erlang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">注意:改变这个值(并将产生的上下文传递给一个延续函数)不会影响正常的格式化,但可能会影响钩子函数中用户定义的行为。</target>
        </trans-unit>
        <trans-unit id="1e66a58313670e508e4d5829246111554fd79c2d" translate="yes" xml:space="preserve">
          <source>Note: each node in &lt;code&gt;Clauses&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">注意：如果 &lt;code&gt;Node&lt;/code&gt; 表示&amp;ldquo; &lt;code&gt;M:F(...)&lt;/code&gt; &amp;rdquo;，则结果是表示&amp;ldquo; &lt;code&gt;M:F&lt;/code&gt; &amp;rdquo; 的子树。</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">注意：如果 &lt;code&gt;Node&lt;/code&gt; 表示&amp;ldquo; &lt;code&gt;fun N/A&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;fun M:N/A&lt;/code&gt; &amp;rdquo;，则结果是分别表示&amp;ldquo; &lt;code&gt;N/A&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;M:N/A&lt;/code&gt; &amp;rdquo; 的子树。</target>
        </trans-unit>
        <trans-unit id="a650514ba11566a0849a47048d45d0a0ca77843f" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;cons&lt;/code&gt;, the number of subtrees is exactly two. If &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;{atomic, Value}&lt;/code&gt;, the number of subtrees is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">注意：在 &lt;code&gt;list(Elements, none)&lt;/code&gt; ，&amp;ldquo; nil&amp;rdquo;列表终止符是隐式的并且没有关联信息（请参阅 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; ），而在看似等效的 &lt;code&gt;list(Elements, Tail)&lt;/code&gt; 当 &lt;code&gt;Tail&lt;/code&gt; 的类型为 &lt;code&gt;nil&lt;/code&gt; 时，列表终止符子树 &lt;code&gt;Tail&lt;/code&gt; 可能具有附加的属性，例如位置，注释和注释，这些属性将保留在结果中。</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">注意:没有检查字符序列是否代表一个正确的变量名,即它的第一个字符是否是大写的Erlang字符,或者它是否不包含控制字符、空格等。</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">注意:并不是所有的符都是叶子节点,反之亦然。例如,非零数的元组和非空列表可能是字元,但不是叶子节点。另一方面,变量是叶子结点,但不是字元。</target>
        </trans-unit>
        <trans-unit id="3393ba242996126bd79b8530e4ba8690724e5617" translate="yes" xml:space="preserve">
          <source>Note: passing a string as argument to this function causes a corresponding atom to be created for the internal representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">注意：与特定字符值相对应的文字不是唯一定义的。例如，字符&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;可以写为&amp;ldquo; &lt;code&gt;$a&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;$\141&lt;/code&gt; &amp;rdquo;，Tab字符可以写为&amp;ldquo; &lt;code&gt;$\11&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;$\011&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;$\t&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">注意：对于相同的 &lt;code&gt;ShortName&lt;/code&gt; ，结果列表可以包含多个元组 &lt;code&gt;{ShortName, Name}&lt;/code&gt; ，根据给定的列表， &lt;code&gt;Name&lt;/code&gt; 的值可能不同。</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">注意：与该模块中的其他函数不同，返回值是 &lt;code&gt;ok&lt;/code&gt; 而不是 &lt;code&gt;success&lt;/code&gt; 。这是很久以前就引入的错误，任何更改都会破坏大量现有软件。</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">注意:格式化函数返回的文本将在每个换行处自动分割成独立的注释行。不需要额外的工作。</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">注意:如果编译时启用了测试功能,这些宏会引入对EUnit库代码的运行时依赖。</target>
        </trans-unit>
        <trans-unit id="bd0d2709ddf8a0638d0aff92ed2e6f15b3be5f7b" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(apply_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1209b617e8d5cc3c5cfc6c1377fd43e5ce41cd" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(call_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e53230502f03bb4733db74bc560eb0d865cde8" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(clause_pats(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd282e7fb8db35030f176c6215fe03b5567042d" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(fun_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca941f0b40db2f3695ecc15ccff4c8a24695250" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(let_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;length(list_elements(Node))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="ebcca9b6d7e57fd06c7e8bed4e5fd7e93be99484" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(primop_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="ec59e73e9bc821017665db80dbf6cf98689682f7" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea075dee9256e89d461acd90fcf6f51117060f2" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; ，但可能会更有效。</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:这只是为了向后兼容现有的解析器和工具而保留的。</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">注意:这只是一种将源代码形式分组为单一语法树的方式,通常是为了形成一个Erlang模块定义。</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:这只支持与现有的解析器和工具向后兼容。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c32e67b1c4c65b813f5c5d3ba41235581ee4036f" translate="yes" xml:space="preserve">
          <source>Notes About MacOS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d325fef3978cce9c3fe25199318432f2a2956f8" translate="yes" xml:space="preserve">
          <source>Notes and Implementation Details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b98b21a7184296ef346762bd6728f411d329337" translate="yes" xml:space="preserve">
          <source>Notes concerning the Log Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">注。浮动文件似乎很好用,但目前的通用性不如你所希望的那么强,当嵌入到某些环境中时,就会失去效果。可以嵌套浮动操作符(即使优先级不同),但效果可能难以预测。在任何情况下,请注意,算法重新排序浮动文档的方式相当于 &quot;bubblesort&quot;,所以不要指望它能够快速排序大序列的浮动文档。</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">注释。如果一个文件中包含的宏定义或使用过于异国情调,那么在没有预处理的情况下将无法读取该文件。此外,Igor 目前并不尝试整理同一文件的多个包含物,或同一宏名的重新定义。因此,当预处理被关闭时,可能需要编辑生成的源代码,删除这些重新包含和重新定义的内容。</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">注意：如果&amp;ldquo; &lt;code&gt;Arguments&lt;/code&gt; 为空列表，则结果将表示&amp;ldquo; &lt;code&gt;?Name()&lt;/code&gt; &amp;rdquo;，其中包括一对匹配的括号。</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不会从队列中删除任何内容，而必须使用 &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; 完成。</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不会从队列中删除任何内容，而必须使用 &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还请注意，&amp;ldquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;被解释为&amp;ldquo; &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;，这是一种语法错误。正确的方法是在'='之后写一个空格：&amp;ldquo; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">还请注意,面向字节的数据使用ISO Latin-1编码发送最为简单。</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">还要注意，瞬态类型几乎没有实际用途，因为当监视树终止时，原因被设置为 &lt;code&gt;shutdown&lt;/code&gt; ，不是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">还请注意,当从shell测试程序时,由于行太长,输入的内容被分散在两行中。</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">还要注意，在 &lt;code&gt;io:format&lt;/code&gt; 中使用〜p代替〜w。引用该手册：&amp;ldquo;〜p以与〜w相同的方式使用标准语法写入数据，但是将打印表示形式长于一行的术语分成多行，并在每行缩进。还尝试检测可打印列表。字符并将其输出为字符串&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">请注意&quot;!&quot;这个操作符是如何用来发送消息的。&quot;!&quot;的语法是:</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">注意如何编写 &lt;code&gt;server&lt;/code&gt; 函数，以便它通过 &lt;code&gt;server(User_List)&lt;/code&gt; 调用自身，从而创建一个循环。 Erlang编译器是&amp;ldquo;聪明的&amp;rdquo;并且优化代码，因此这实际上是一种循环，而不是正确的函数调用。但这仅在调用后没有代码的情况下有效。否则，编译器希望该调用返回并进行适当的函数调用。这将导致每个循环的过程越来越大。</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">注意，在第二个示例中，重复名称在返回的列表中仅出现一次，并且该列表按字母顺序排列，无论名称在正则表达式中的位置如何。如果将 &lt;code&gt;{capture, all_names}&lt;/code&gt; 指定为 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的选项，则名称的顺序与捕获的子表达式的顺序相同。因此，您可以像这样从 &lt;code&gt;run/3&lt;/code&gt; 的结果创建名称到值的映射：</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">请注意，在第16行，将5英寸转换为厘米，然后再次返回并放心地恢复到原始值。也就是说，一个函数的参数可以是另一个函数的结果。考虑第16行（以上）的工作方式。给函数 &lt;code&gt;{inch,5}&lt;/code&gt; 的参数首先与 &lt;code&gt;convert_length&lt;/code&gt; 的第一个head子句匹配，即 &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; 。可以看出 &lt;code&gt;{centimeter,X}&lt;/code&gt; 与 &lt;code&gt;{inch,5}&lt;/code&gt; 不匹配（头部是&amp;ldquo;-&amp;gt;&amp;rdquo;之前的位）。失败了，让我们尝试下一个子句的头，即 &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; 。这匹配，并且 &lt;code&gt;Y&lt;/code&gt; 获得值5。</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，&amp;ldquo; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;将被解释为&amp;ldquo; &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &amp;rdquo;，这是一种语法错误。编写表达式的正确方法是： &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">请注意,模式开始时的(*COMMIT)和锚是不一样的,除非PCRE的匹配开始优化被关闭,如下例所示。</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">请注意,(*SKIP:NAME)只搜索由(*MARK:NAME)设置的名称,它忽略了由(*PRUNE:NAME)或(*THEN:NAME)设置的名称。它忽略(*PRUNE:NAME)或(*THEN:NAME)设置的名称。</target>
        </trans-unit>
        <trans-unit id="ac772e9232c60fd05e436000b3d65e5ba73ff0bb" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt; file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">请注意，在启动守护程序时指定了 &lt;code&gt;-relaxed_command_check&lt;/code&gt; ，该守护程序在注册了活动节点时接受终止。交互式运行 &lt;code&gt;epmd&lt;/code&gt; 时， &lt;code&gt;-relaxed_command_check&lt;/code&gt; 不起作用。如果启动了没有轻松进行命令检查的守护程序，则必须使用信号或其他特定于OS的方法（如果已注册活动客户端）将其终止。</target>
        </trans-unit>
        <trans-unit id="70bfe90d5c883bf60d9637a901f3b97c4d3f704b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ActiveSuspendCount&lt;/code&gt; 和 &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; 并不是 &lt;code&gt;Suspendee&lt;/code&gt; 的总暂停数，而是 &lt;code&gt;Pid&lt;/code&gt; 贡献的部分。</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ErlNifBinary&lt;/code&gt; 是半透明类型，只允许您读取字段 &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">请注意， &lt;code&gt;Filename&lt;/code&gt; 可以是列表或二进制文件。</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">请注意， &lt;code&gt;Tracee&lt;/code&gt; 必须引用与 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 的调用者所在的节点相同或当前存在的进程。特殊的 &lt;code&gt;Tracee&lt;/code&gt; 原子 &lt;code&gt;all&lt;/code&gt; 表示当前在节点中跟踪的所有进程。</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">请注意，根据Unicode标准， &lt;code&gt;[$\r,$\n]&lt;/code&gt; 是一个字素簇。</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">请注意， &lt;code&gt;[$\r,$\n]&lt;/code&gt; 是一个字素簇。</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;bind_address&lt;/code&gt; 必须是函数 &lt;code&gt;info&lt;/code&gt; 报告的IP地址，并且不能是放入 &lt;code&gt;bind_address&lt;/code&gt; 时允许的主机名。</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">请注意， &lt;code&gt;catch&lt;/code&gt; 的优先级较低，并且catch子表达式通常需要用块表达式或括号括起来：</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意，只允许在两个回调 &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; 中调用 &lt;code&gt;enif_open_resource_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">请注意， &lt;code&gt;erlsrv&lt;/code&gt; 不是Windows的常规服务实用程序，而是为嵌入式Erlang系统设计的。</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">请注意，如果链接指向无效的文件名，则 &lt;code&gt;file:read_link/1&lt;/code&gt; 总是返回错误。</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">请注意，在将日志事件转发到每个处理程序之前，Logger本身会遵守 &lt;code&gt;level&lt;/code&gt; 和 &lt;code&gt;filters&lt;/code&gt; ，而 &lt;code&gt;formatter&lt;/code&gt; 和所有处理程序特定的选项则留给处理程序实现。</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">请注意， &lt;code&gt;n3&lt;/code&gt; 和 &lt;code&gt;creation&lt;/code&gt; 的精度受到限制，因此仅使用这些数字的低18位和2位。</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">请注意， &lt;code&gt;number&lt;/code&gt; 和 &lt;code&gt;creation&lt;/code&gt; 的精度受到限制，因此仅使用这些数字的低18位和2位。</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">请注意， &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; 与 &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; ；一个元素的列表未与该元素本身一起标识。</target>
        </trans-unit>
        <trans-unit id="d6bd7c1e7434d1dad6aeb762e0751cad3313447c" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary for table type &lt;code&gt;ordered_set&lt;/code&gt; and for traversals done by a single ETS function call, like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">请注意， &lt;code&gt;stdin&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 用于缓冲的输入/输出，&lt;strong&gt;不能&lt;/strong&gt;用于与Erlang的通信。</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">请注意， &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; 不会导致任何条件成功。这会导致运行时错误 &lt;code&gt;if_clause&lt;/code&gt; ，在此由shell很好地格式化。有关许多可用保护测试的详细信息，请参见 &lt;code&gt;Guard Sequences&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">请注意， &lt;code&gt;{active, true}&lt;/code&gt; 模式不提供流量控制。快速的发送者可以轻松地使接收者的接收消息溢出。对于 &lt;code&gt;{active, N}&lt;/code&gt; 模式，消息数大于零时也是如此。</target>
        </trans-unit>
        <trans-unit id="3d5d39b6d9eb6afa53058c47c7cffc48273fdd29" translate="yes" xml:space="preserve">
          <source>Notice that Logger automatically inserts a timestamp in the meta data unless it already exists. This function is exported for the rare case when the timestamp must be taken at a different point in time than when the log event is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">注意，Mnesia可以连接到除 &lt;code&gt;ReturnValue&lt;/code&gt; 中返回的节点以外的其他节点。</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">注意,SNMPv3配置时需要USM用户,不要与用户混淆。</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">注意，对于从128到255的代码点，UTF-8 与字节表示形式&lt;strong&gt;不&lt;/strong&gt;兼容，因此ISO Latin-1字节表示形式通常与UTF-8不兼容。</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">请注意，\ g {...}（Perl语法）和\ g &amp;lt;...&amp;gt;（Oniguruma语法）&lt;strong&gt;不是&lt;/strong&gt;同义词。前者是回溯参考；后者是子例程调用。</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">请注意， &lt;code&gt;gen_server&lt;/code&gt; 进程不会自动捕获退出信号，必须在回调模块中显式启动该退出信号。</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;gen_statem&lt;/code&gt; 不会自动捕获退出信号，必须在回调模块中显式启动（通过调用 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">请注意,一个条件子模式并不被认为有两个选择,因为只有一个被使用。也就是说,条件子模式中的|字符有不同的含义。忽略空格,考虑一下。</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">请注意，驱动程序二进制文件具有内部参考计数器。这意味着调用 &lt;code&gt;driver_free_binary&lt;/code&gt; ，实际上可能不会处理它。如果将其发送到仿真器，则可以在其中引用它。</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">注意,一个伪造的CPU拓扑结构如果不能反映真实CPU拓扑结构的样子,很可能会降低运行时系统的性能。</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">注意,占有式定语可以和整个群体一起使用,例如。</target>
        </trans-unit>
        <trans-unit id="1bc519a5e1193bcfddf9bfba3de07bc1233b4abf" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using decentralized counter groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the groups are distributed better between schedulers with this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">注意，使用共享读取器组的运行时系统受益于 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; ，因为读取器组在调度程序之间的分配更好。</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">请注意,即使操作系统已经排定了调度线程,调度器也可能是繁忙的。</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">注意,所有使用标准OTP行为模块实现的子进程都会自动遵守关闭协议。</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">请注意，所有八个等级同时出现在标题中，不仅 &lt;code&gt;ERROR&lt;/code&gt; ， &lt;code&gt;WARNING&lt;/code&gt; 或 &lt;code&gt;INFO&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 产生。并且在时间戳记末尾添加了微秒。</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">请注意,最后一个片段中的所有记录都必须移动到另一个片段中,因为整个片段都被删除了。</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">请注意,所有的输出都是在gollum上接收的。这是因为I/O系统发现了进程从哪里产生,并将所有的输出发送到那里。</target>
        </trans-unit>
        <trans-unit id="b1caf8d4d97365e6e7817ea835b055cfc59c2108" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，尽管用户已请求绑定调度程序，但他们可以默默地失败绑定。要检查调度程序绑定，请调用 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">请注意，虽然关键字 &lt;code&gt;catch&lt;/code&gt; 在使用 &lt;code&gt;try&lt;/code&gt; 表达，没有一个 &lt;code&gt;catch&lt;/code&gt; 的范围内表达 &lt;code&gt;try&lt;/code&gt; 表达。</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">请注意，始终可以通过调用 &lt;code&gt;stop/1&lt;/code&gt; 显式停止应用程序。无论应用程序的类型如何，都不会影响其他应用程序。</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">请注意，事件管理器&lt;strong&gt;会&lt;/strong&gt;自动捕获退出信号。</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">请注意,有一个出口端口存在,但没有打开。</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">请注意，存在一个正在退出的进程，但该进程没有生命。也就是说， &lt;code&gt;is_process_alive/1&lt;/code&gt; 对于退出的进程返回 &lt;code&gt;false&lt;/code&gt; ，但是其进程标识符是从processs &lt;code&gt;processes/0&lt;/code&gt; 返回的结果的一部分。</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">请注意，在 &lt;code&gt;mnesia:select/4&lt;/code&gt; 和 &lt;code&gt;mnesia:select/1&lt;/code&gt; 调用之间完成的任何修改操作，即 &lt;code&gt;mnesia:write&lt;/code&gt; 或 &lt;code&gt;mnesia:delete&lt;/code&gt; ，在结果中都不可见。</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">请注意，任何进程都可以使用 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 关闭端口！{PortOwner，close}好像它本身是端口所有者一样，但是答复总是转到端口所有者。</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">请注意，任何进程都可以使用 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 发送到端口！{PortOwner，{command，Data}}，就好像它本身是端口所有者一样。</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">注意，任何过程都可以使用 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 设置端口所有者！{PortOwner，{connect，Pid}}就像它本身是端口所有者一样，但是答复总是转到端口所有者。</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">请注意，存储在表中的任何元组必须至少具有 &lt;code&gt;Pos&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">请注意,作为驱动程序二进制是由驱动程序和仿真器共享的。从仿真器接收到的二进制文件或发送到仿真器的二进制文件不能被驱动程序改变。</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">请注意，由于这是 &lt;code&gt;server_transfer/5&lt;/code&gt; ，所以它与先前的功能 &lt;code&gt;server_transfer/4&lt;/code&gt; 不同。在 &lt;code&gt;keysearch&lt;/code&gt; 上完成另一个关键字 &lt;code&gt;User_List&lt;/code&gt; 以查找与fred对应的客户端的pid：</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">注意,位串模式不能嵌套。</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">请注意，通过传递 &lt;code&gt;positive&lt;/code&gt; 修饰符，您将更快地为堆分配整数（bignums）。</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">注意，在事务上下文中调用（嵌套） &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; 会继承事务语义。</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">注意，在事务上下文中调用（嵌套） &lt;code&gt;mnesia:ets&lt;/code&gt; 会继承事务语义。</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">注意，调用 &lt;code&gt;complex2:foo/1&lt;/code&gt; 和 &lt;code&gt;complex2:bar/1&lt;/code&gt; 会导致元组 &lt;code&gt;{foo,X}&lt;/code&gt; 或 &lt;code&gt;{bar,Y}&lt;/code&gt; 被发送到 &lt;code&gt;complex&lt;/code&gt; 进程，该进程将它们编码为二进制文件并将其发送到端口。这意味着C程序必须能够处理这两个元组。</target>
        </trans-unit>
        <trans-unit id="76111f96a154ca2aa3dcd82c9fbe77397be7146e" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many children under low memory conditions can cause an out of memory exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">请注意,在低内存条件下监督很多孩子时,调用此函数会导致内存不足异常。</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">请注意，分块编码可以添加标头，以便 &lt;code&gt;stream_end&lt;/code&gt; 消息中的标头比 &lt;code&gt;stream_start&lt;/code&gt; 中的标头多。当流传输到文件并且请求是异步的时，将发送消息 &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">请注意， &lt;code&gt;disc_only_copies&lt;/code&gt; 表当前不支持 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;disc_only_copies&lt;/code&gt; 不支持当前 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">请注意，由于内部原因，无法更改默认选项 &lt;code&gt;{active, true}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61f3baddeb0657db3f04655dfe751683be5006f5" translate="yes" xml:space="preserve">
          <source>Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">请注意，分发套接字禁用了 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 和 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 的使用。相反，他们使用 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; ，这是一个类似的功能。</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">请注意，分发套接字禁用了 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 和 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 的使用。而是使用 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; ，这是类似的功能。</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">注意，每个断言都独立地应用于主题字符串中的同一点。首先检查前三个字符是否都是数字，然后检查相同的三个字符是否不是&amp;ldquo; 999&amp;rdquo;。此模式与以六个字符开头的&amp;ldquo; foo&amp;rdquo; &lt;strong&gt;不&lt;/strong&gt;匹配，前六个字符是数字，后三个字符不是&amp;ldquo; 999&amp;rdquo;。例如，它与&amp;ldquo; 123abcfoo&amp;rdquo;不匹配。一种实现方式如下：</target>
        </trans-unit>
        <trans-unit id="5779934da069d89a75c4be1d8cdff80ec5c00bf4" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">请注意，清空调用堆栈意味着删除所有周围的 &lt;code&gt;catch&lt;/code&gt; ，并且在休眠后必须重新插入。这样的效果是，使用 &lt;code&gt;proc_lib&lt;/code&gt; 启动的进程（也间接地，例如 &lt;code&gt;gen_server&lt;/code&gt; 进程）将使用 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 来确保异常处理程序在唤醒时继续工作。</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">注意,代码中省略了错误处理。</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">请注意,每一个守备测试都有与某个表达式相同的源形式,并以与对应表达式相同的方式表示。</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">请注意,每个模式的源形式都与某个表达式相同,并与相应的表达式以相同的方式表示。</target>
        </trans-unit>
        <trans-unit id="1dafff17410c30a74873fbb0f049fd6b36e0dd69" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_all/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d439f14c665f39e855a7716b502d1b790e81b7b" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_groups/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">请注意，对于SCTP套接字，此函数仅返回套接字地址之一。函数 &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; 返回全部。</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">请注意，对于SCTP套接字，此函数仅返回套接字的对等地址之一。函数 &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; 返回全部。</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">请注意，由于任何其它原因比 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或者 &lt;code&gt;{shutdown,Term}&lt;/code&gt; ，则 &lt;code&gt;gen_server&lt;/code&gt; 假定进程终止，因为一个错误和错误报告使用发出 &lt;code&gt;logger(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">请注意，由于任何其它原因比 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或者 &lt;code&gt;{shutdown,Term}&lt;/code&gt; ，所述 &lt;code&gt;gen_statem&lt;/code&gt; 假定终止，因为一个错误和错误报告使用发出 &lt;code&gt;logger(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">请注意，为了获得最佳性能，在同一事务中对该表执行任何修改操作之前，将使用 &lt;code&gt;select&lt;/code&gt; 。也就是说，不要在 &lt;code&gt;mnesia:select&lt;/code&gt; 之前使用 &lt;code&gt;mnesia:write&lt;/code&gt; 或 &lt;code&gt;mnesia:delete&lt;/code&gt; 。为了提高效率， &lt;code&gt;NObjects&lt;/code&gt; 仅作为建议，结果可以包含从空列表到所有可用结果的任何内容。</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">请注意，为了获得最佳性能，在同一事务中对该表执行任何修改操作之前，将使用 &lt;code&gt;select&lt;/code&gt; 。也就是说，在 &lt;code&gt;select&lt;/code&gt; 之前不要使用 &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">请注意，对于表类型 &lt;code&gt;ordered_set&lt;/code&gt; 来说，不需要 &lt;code&gt;safe_fixtable/2&lt;/code&gt; ，因为对 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 的调用始终会成功。</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">注意,对于临时子代,当子代终止时,子代规范会被自动删除;因此,无法重新启动此类子代。</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">请注意，在转换要测试相等性的字符串时，应使用函数 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 可以用作帮助，如下所示：</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">注意，函数 &lt;code&gt;chunk/2,3&lt;/code&gt; ， &lt;code&gt;bchunk/2,3&lt;/code&gt; 和 &lt;code&gt;chunk_step/3&lt;/code&gt; 不会影响 &lt;code&gt;info/1&lt;/code&gt; 返回的任何值。</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果 &lt;code&gt;init_per_suite&lt;/code&gt; 不存在init_per_suite和 &lt;code&gt;end_per_suite&lt;/code&gt; ，则 &lt;code&gt;Common Test&lt;/code&gt; 会调用伪函数（具有相同的名称），以便将钩子函数生成的输出保存到这些虚拟变量的日志文件中。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">请注意，如果 &lt;code&gt;parallel_login&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，一次只能有一个客户端处于身份验证阶段。</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">请注意，如果跟踪到&amp;ldquo;技术上内置的函数&amp;rdquo;（即，不是用Erlang编写的函数），则 &lt;code&gt;caller&lt;/code&gt; 函数有时会返回原子 &lt;code&gt;undefined&lt;/code&gt; 。在此类调用期间，调用Erlang函数不可用。</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">请注意，如果在运行时更改处理程序的配置，则不得修改 &lt;code&gt;type&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="ce90066e3aad3459d75c1fb55cecaec28fe2794d" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, or &lt;code&gt;modes&lt;/code&gt; parameters must not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果在打开文件时使用了选项 &lt;code&gt;delayed_write&lt;/code&gt; ，则 &lt;code&gt;close/1&lt;/code&gt; 会返回旧的写入错误，甚至不会尝试关闭文件。参见 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">请注意，如果文件 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 和 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 不在目录 &lt;code&gt;/etc&lt;/code&gt; 中，则必须修改第二个和第三个命令中的文件路径。</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">请注意，如果原始属性项在扩展时要保留在结果中，则必须将其包括在扩展列表中。插入的术语不会递归扩展。如果 &lt;code&gt;Expansions&lt;/code&gt; 包含多个具有相同键的属性，则仅使用第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">请注意，如果还原到非空注册表，则表中的对象将使用相同的键覆盖注册表中的对象。此外，还原后，注册表的&lt;strong&gt;全部&lt;/strong&gt;内容都标记为未修改，包括还原操作未覆盖的所有已修改对象。这可能不是您的意图。</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">请注意，如果您存储依赖于上下文的二进制对象（例如，包含指针或打开的文件描述符），则将它们备份到 &lt;code&gt;Mnesia&lt;/code&gt; 表并随后在其他上下文中还原时，它们将失去含义。</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">注意，忽略此函数的返回值将导致&lt;strong&gt;不可靠的&lt;/strong&gt;消息传递，这与Erlang编程模型相矛盾。如果此函数返回 &lt;code&gt;false&lt;/code&gt; ,&lt;strong&gt;则不&lt;/strong&gt;发送该消息。</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">注意，在 &lt;code&gt;ordered_set&lt;/code&gt; 表中，记录按片段排序，并且在 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;match_object&lt;/code&gt; 以及 &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;prev&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 返回的结果中未定义顺序。</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">请注意，在某些情况下，与从OS命令外壳直接调用时的命令标准输出相比，从另一个程序调用时命令的标准输出（例如， &lt;code&gt;os:cmd/1&lt;/code&gt; ）可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">请注意,在这个未锚定的例子中,标记从主题中的字母 &quot;X &quot;开始的匹配尝试中被保留。随后的匹配尝试从 &quot;P &quot;开始,然后是一个空字符串,并没有到达(*MARK)项,但不会重置它。</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">请注意，它没有写过3次&amp;ldquo; hello&amp;rdquo;，然后写了3次&amp;ldquo;再见&amp;rdquo;。相反，第一个过程写了一个&amp;ldquo;你好&amp;rdquo;，第二个过程写了&amp;ldquo;再见&amp;rdquo;，第一个过程写了一个&amp;ldquo;你好&amp;rdquo;，依此类推。但是&amp;lt;0.63.0&amp;gt;从何而来？函数的返回值是函数中最后一个&amp;ldquo;事物&amp;rdquo;的返回值。函数 &lt;code&gt;start&lt;/code&gt; 的最后一件事是</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">请注意，它也需要扩大 &lt;code&gt;-export&lt;/code&gt; 用，还有另一种功能信息线路 &lt;code&gt;mult&lt;/code&gt; 用两个参数。</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">请注意，与其他规范结合使用时，始终是源规范中的 &lt;code&gt;merge_tests&lt;/code&gt; 设置。例如，假设具有测试TA1和TA2的源规范A 设置了 &lt;code&gt;{merge_tests,false}&lt;/code&gt; ，并且它包括了另一个具有测试TB1和TB2的规范B，其中设置了 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 。结果是执行了测试序列 &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; 。相反的 &lt;code&gt;merge_tests&lt;/code&gt; 设置将导致测试系列 &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">注意,脏读记录的效率是事务内的十倍以上。</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">请注意,在谈论 &quot;BIF &quot;时,通常指的是一组自动导入的BIF。</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">注意，由运行时系统确定是否以及如何使用此信息。在某些平台上的实现可以使用其他方式来确定消耗的CPU时间。无论如何，冗长的 &lt;code&gt;enif_consume_timeslice&lt;/code&gt; 都应经常调用enif_consume_timeslice以确定是否允许其继续执行。</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">注意,是否使用和如何使用这些信息由运行时系统决定。一些平台上的实现可以使用其他方式来确定时间片的消耗分数。冗长的驱动回调应该不管这些,经常调用这个函数来确定是否允许继续执行。</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">请注意，如果列表完全由0..255范围内的整数组成，则将它们编码为字符串。此函数不会解码此类字符串，请改用 &lt;code&gt;ei_decode_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">请注意，消息 &lt;code&gt;trace_delivered&lt;/code&gt; 并&lt;strong&gt;没有&lt;/strong&gt;暗示跟踪消息已经交付。相反，它意味着所有&lt;strong&gt;要传递的&lt;/strong&gt;跟踪消息均已传递。如果没有 &lt;code&gt;Tracee&lt;/code&gt; ，也没有被任何人跟踪，这不是错误，但是，在这种情况下，当 &lt;code&gt;trace_delivered&lt;/code&gt; 消息到达时，&lt;strong&gt;没有任何&lt;/strong&gt;跟踪消息已经传递。</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">请注意，大多数类型测试BIF具有较旧的等效项，而没有 &lt;code&gt;is_&lt;/code&gt; 前缀。保留这些旧的BIF只是为了向后兼容，不能在新代码中使用。也只允许在最高级别使用它们。例如，在警卫队的布尔表达式中不允许使用它们。</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">请注意,允许使用多个 &quot;*&quot;字符(如Unix通配符,但与Windows/DOS通配符不同)。</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">请注意,负整数和浮点数不会出现这样的情况;它们被解析为单子否定运算符的应用。</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">注意，缓冲区上没有边界检查。调用者有责任确保缓冲区足够大以容纳编码的术语。您可以使用足够大的静态缓冲区来容纳程序中期望的术语，也可以使用 &lt;code&gt;erl_term_len()&lt;/code&gt; 确定给定术语的确切要求。</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">注意,在固定表被释放之前,不会从固定表中删除对象。如果一个进程固定了一个表,但从未释放它,那么被删除对象所使用的内存就永远不会被释放。对表的操作性能也会大大降低。</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">请注意,当程序执行对这些副本的写操作时,不会执行磁盘操作。但是,如果需要永久的RAM副本,则可采用以下替代方案。</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">请注意，并非所有实现都支持所有这些 &lt;code&gt;Item&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">请注意，使用此语法指定的八进制值&amp;gt; = 100不能由前导零引入，因为最多只能读取三个八进制数字。</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">请注意，偏移量以字节为单位，而不是以字符为单位。如果使用 &lt;code&gt;latin1&lt;/code&gt; 以外的其他 &lt;code&gt;encoding&lt;/code&gt; 打开文件，则一个字节不对应一个字符。在此类文件中的定位只能在已知字符边界进行。也就是说，要通过获取当前位置来更早地获取位置，到文件的开头/结尾或通过其他某种方式（通常超出文件中的字节顺序标记）到&lt;strong&gt;已知&lt;/strong&gt;在正确字符边界上的某个其他位置，具有已知的字节大小）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">请注意，在Windows上，此标志仅适用于 &lt;code&gt;werl&lt;/code&gt; ，而不适用于 &lt;code&gt;erl&lt;/code&gt; （ &lt;code&gt;oldshell&lt;/code&gt; ）。还要注意，在Windows上使用 &lt;code&gt;Ctrl-Break&lt;/code&gt; 代替 &lt;code&gt;Ctrl-C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b312389a960b6c4523a134c6d69a5e6dbd847cda" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must close the port explicitly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">请注意，在某些系统（例如VxWorks）上，此机制未检测到故障节点，因为操作系统不会自动关闭当节点故障时保持打开状态的描述符。如果节点以这种方式发生故障，则 &lt;code&gt;epmd&lt;/code&gt; 会阻止您使用旧名称注册新节点，因为它认为旧名称仍在使用中。在这种情况下，必须显式注销该名称：</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">请注意，一旦 &lt;code&gt;enif_make_resource&lt;/code&gt; 创建了返回Erlang的术语，代码就可以选择保留其自身的本机指针，以指向所分配的结构并在以后释放它，或者立即释放它，并且仅依赖于垃圾收集器最终在以下情况下释放资源对象：它收集术语。</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">请注意， &lt;code&gt;DiscNodes&lt;/code&gt; 中仅包含具有disc的节点。无盘节点，即包括模式的所有表仅驻留在RAM中的节点，不得包含在内。</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">请注意,每个驱动程序实例上只存在一个定时器;设置一个新的定时器会替换一个旧的定时器。</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">注意,只有在线的调度器才能绑定到逻辑处理器。</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">请注意，只能还原某些格式的表，即已创建并通过 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 备份的表。如果在操作之前注册表不为空，则将表的内容添加到注册表的内容中。如果表包含的对象具有与注册表中已经存在的键相同的键，则注册表对象将被新值覆盖。如果注册表包含表中未包含的对象，则此操作将使它们保持不变。</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">注意,只有通道被关闭。连接还在,可以处理其他通道。</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">注意,Mnesia中只实现了词法SNMP排序,而不是实际的SNMP监控。</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">请注意，参数 &lt;code&gt;Assoc&lt;/code&gt; 是由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义的，对于一对一样式的套接字将被忽略。对于一对多样式的套接字，将特殊值 &lt;code&gt;0&lt;/code&gt; 定义为意味着返回的地址必须没有任何特定的关联。不同的SCTP实现方式对此的解释有些不同。</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">请注意，参数 &lt;code&gt;Assoc&lt;/code&gt; 是由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义的，对于一对一样式的套接字将被忽略。不幸的是，特殊值 &lt;code&gt;0&lt;/code&gt; 表示什么，因此它对于一对多样式套接字的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">请注意，将按钮从 &lt;code&gt;open&lt;/code&gt; 状态推迟到 &lt;code&gt;locked&lt;/code&gt; 状态对于代码锁定来说感觉很奇怪，但这至少说明了事件推迟。</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">请注意，清除代码意味着保留在模块旧代码中的所有进程都会被杀死，而不会发出警告。有关更多信息，请参见 &lt;code&gt;code/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">请注意，必须为联系的 &lt;code&gt;epmd&lt;/code&gt; 守护程序启用宽松的命令检查。交互式运行 &lt;code&gt;epmd&lt;/code&gt; 时， &lt;code&gt;-relaxed_command_check&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">注意,请求一个文件的多个部分向日志文件报告的大小为零。</target>
        </trans-unit>
        <trans-unit id="e599e5f12a452819b319876058461d934b52f083" translate="yes" xml:space="preserve">
          <source>Notice that setting this value to &lt;code&gt;0&lt;/code&gt; does not turn of rotation. It only specifies that no archives are kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">注意,Erlang/OTP R16B01或更高版本保存的设置不能被Erlang/OTP R16B或更早版本读取。</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">请注意,由于以下划线开头的变量不是匿名的,所以这符合。</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">注意，一些系统内部事件也可以被接收。因此，必须在事件处理程序回调函数 &lt;code&gt;Module:handle_event/2&lt;/code&gt; 的定义中使用一个包罗万象的子句。这也适用于 &lt;code&gt;Module:handle_info/2&lt;/code&gt; ，因为事件处理程序还必须处理一些系统内部消息。</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">注意， &lt;code&gt;bin_opt_info&lt;/code&gt; 并不是要添加到 &lt;code&gt;Makefile&lt;/code&gt; 的永久选项，因为它生成的所有消息都无法消除。因此，在大多数情况下，将选项传递给环境是最实用的方法。</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;get_until&lt;/code&gt; 请求允许一个函数，其中指定的数据始终为列表。同样，来自该函数的返回值数据可以是任何类型（确实是 &lt;code&gt;io:fread/2,3&lt;/code&gt; 请求发送到I / O服务器时的情况）。客户端必须准备好以各种形式接收作为对这些请求的答复的数据。但是，I / O服务器将在可能的情况下（即，提供给 &lt;code&gt;get_until&lt;/code&gt; 的函数返回列表时）将结果转换为二进制文件。这在&amp;ldquo;带 &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; 部分的示例中完成。</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">请注意，元组 &lt;code&gt;io_reply&lt;/code&gt; 中未明确存在I / O服务器的 &lt;code&gt;pid()&lt;/code&gt; 。可以从任何进程发送答复，而不必是实际的I / O服务器。</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">请注意，不同行为模块的 &lt;code&gt;start_link&lt;/code&gt; 函数满足上述要求。</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">请注意， &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 消息可以是链接的结果，但也可以是 &lt;code&gt;Id&lt;/code&gt; 调用 &lt;code&gt;exit/2&lt;/code&gt; 的结果。因此，它&lt;strong&gt;可以&lt;/strong&gt;是适当的调用后捕获退出时清理消息队列 &lt;code&gt;unlink(Id)&lt;/code&gt; ，如下：</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">请注意，很少使用UTF-8的BOM，它实际上不是&lt;strong&gt;字节顺序&lt;/strong&gt;标记。UTF-8显然没有字节顺序问题，因此BOM仅用于区分UTF-8编码和其他UTF格式。</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">请注意，C程序处于 &lt;code&gt;while&lt;/code&gt; 循环中，正在检查 &lt;code&gt;read_cmd/1&lt;/code&gt; 的返回值。这是因为C程序必须检测端口何时关闭和终止。</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">请注意，内核变量 &lt;code&gt;inetrc&lt;/code&gt; 会覆盖此环境变量。</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">请注意,上述处理程序没有任何过载保护,所有的日志事件都是直接从客户端进程中打印出来的。</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">请注意,上述规范并没有以任何方式限制输入和输出类型。这些类型可以通过类似卫士的子类型约束,并提供有界量化。</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">请注意,明显相似的模式</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">请注意,应用程序版本指定了一个源代码版本。还有一个间接的要求是,所安装的指定版本的二进制应用程序要与系统的其他部分兼容。</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">请注意，该参数是一个仅包含一个，两个或三个参数的列表。 &lt;code&gt;NameType&lt;/code&gt; 默认为 &lt;code&gt;longnames&lt;/code&gt; 和 &lt;code&gt;Ticktime&lt;/code&gt; 至 &lt;code&gt;15000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，SCTP一对多样式套接字的此功能的行为未由 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">请注意，编译器不会为参数化类型生成编码/解码函数，仅为参数化类型的实例生成。因此，如果文件如前面的示例中包含类型 &lt;code&gt;General{}&lt;/code&gt; ， &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; ，则仅为 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 生成编码/解码功能。</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">请注意,当前的密钥存储在驱动程序中,并且可能是无效的(例如,如果密钥已被删除)。</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">请注意,TCP/IP套接字的默认选项可以通过本手册页面开头提到的内核配置参数来改变。</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">请注意，类型 &lt;code&gt;SET OF&lt;/code&gt; 的定义意味着未定义组件的顺序，但实际上 &lt;code&gt;SET OF&lt;/code&gt; 和 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 之间没有区别。用于Erlang的ASN.1编译器在编码之前不会随机化 &lt;code&gt;SET OF&lt;/code&gt; 组件的顺序。</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">注意，这种类型的注释的结尾是模式中的文字换行符序列；碰巧代表换行符的转义序列不计算在内。例如，在设置 &lt;code&gt;extended&lt;/code&gt; 时考虑以下模式，并且默认的换行约定生效：</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">请注意，打开文件时指定的文件编码选项与文件名编码约定无关。您可以很好地打开包含以UTF-8编码的数据，但文件名以字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码或相反的文件。</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">注意，包含虚拟机可执行文件（文件系统 &lt;code&gt;beam.smp&lt;/code&gt; 中的例子）必须是本地的，安装而不标志 &lt;code&gt;nosetuid&lt;/code&gt; 的，支持扩展属性和内核必须支持文件的能力。至少在Ubuntu 12.04 LTS上，所有这些都是开箱即用的，除了SCTP套接字似乎不支持网络名称空间。</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">注意，作为表创建过程的一部分，对于其他每个片段（编号1除外），函数 &lt;code&gt;add_frag/2&lt;/code&gt; 都会启动一次。</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">注意，对于模块实际上标记为粘性的或驻留在标记为粘性的目录中的模块而言，该函数可以返回 &lt;code&gt;true&lt;/code&gt; 。原因是直到解释程序尝试加载模块后才发现此问题。</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">请注意,下面的函数使用调用者提供的打开的文件描述符来执行RPC。在全局操作过程中,这个文件描述符不能用于其他流量,因为这样的话,函数可能会收到意外的数据而失败。</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">请注意，最后跟踪的历史记录始终在文件 &lt;code&gt;ttb_last_config&lt;/code&gt; 中可用。</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">请注意,返回的信息是高度依赖于实现的,可以在任何时候改变或删除,而无需事先通知。它最初的目的是作为开发新分配器的工具,但由于它可能会引起其他人的兴趣,因此简要地记录了它。</target>
        </trans-unit>
        <trans-unit id="ed442d55f4c83cba3d99e636fc5b3b8fb144e267" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，整数值仅在Logger中内部使用。在API中，您必须始终使用原子。要比较两个日志级别的严重性，请使用 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">请注意,最后创建的原子是先显示的。</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">请注意，调用该函数时， &lt;code&gt;Request&lt;/code&gt; 元组（ &lt;code&gt;[$\n]&lt;/code&gt; ）中的最后一个元素会附加到参数列表中。该功能将由I / O服务器像 &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">请注意，最后一部分是&amp;ldquo; ang&amp;rdquo;，而不是&amp;ldquo; an&amp;rdquo;，因为将分割指定为两部分，并且在给出足够的部分时分割停止，这就是为什么结果与 &lt;code&gt;trim&lt;/code&gt; 的结果不同的原因。</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">请注意，遍历整个二进制文件后，将放弃 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 中的match上下文。如果迭代在到达二进制末尾之前停止，会发生什么情况？优化是否仍然有效？</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">请注意,返回的对象的顺序是不明确的。特别是,对象插入的顺序没有反映出来。</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">请注意，该程序位于仿真器的 &lt;code&gt;bin&lt;/code&gt; 目录中，而不是直接位于Erlang根目录下的 &lt;code&gt;bin&lt;/code&gt; 目录中。这样做的原因是在运行中的系统上升级仿真器的细微问题，在该系统上，新版本的运行时系统不需要覆盖现有的（并且可能使用过的）可执行文件。</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">注意,如果数据位于远程节点上,程序的运行速度会比较慢。</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">请注意，范围 &lt;code&gt;0..Range-1&lt;/code&gt; 与 &lt;code&gt;phash/2&lt;/code&gt; 的范围不同，后者是 &lt;code&gt;1..Range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">请注意，即使 &lt;code&gt;record_name&lt;/code&gt; 具有其他设置，记录名称也是表名称。</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">请注意，正则表达式必须与完整的版本字符串匹配，因此此示例适用于例如 &lt;code&gt;2.1.1&lt;/code&gt; ，但不适用于 &lt;code&gt;2.1.1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88bf6f27cbb64880bfd54716d99abab3e050207e" translate="yes" xml:space="preserve">
          <source>Notice that the risk of loosing log events grows when the &lt;code&gt;file_check&lt;/code&gt; value grows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b783e1e390dc485584c1f74b3ed69a29fd778c4" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，同样的警告适用于 &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">请注意，序列\ A，\ Z和\ z可用于在两种模式下匹配对象的开始和结束。如果模式的所有分支均以\ A开头，则无论是否设置了 &lt;code&gt;multiline&lt;/code&gt; ，它总是固定的。</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">请注意， &lt;code&gt;list()&lt;/code&gt; 的简写形式，即未知类型的元素列表，是 &lt;code&gt;[_]&lt;/code&gt; （或 &lt;code&gt;[any()]&lt;/code&gt; ），而不是 &lt;code&gt;[]&lt;/code&gt; 。符号 &lt;code&gt;[]&lt;/code&gt; 指定空列表的单例类型。</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">注意,保存在RAM中的空间管理数据结构,好友系统,也会被写入磁盘。如果表是碎片化的,这可能需要一些时间。</target>
        </trans-unit>
        <trans-unit id="2158fd0c30567923e783ca815a320fc6fd564c3e" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这些值的总和&lt;strong&gt;不是&lt;/strong&gt;模拟器分配的内存总量。一些值是其他值的一部分，而某些存储区不是结果的一部分。有关模拟器分配的内存总量的信息，请参见 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">请注意， &lt;code&gt;map()&lt;/code&gt; 的语法表示形式是 &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; （或 &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; ），而不是 &lt;code&gt;#{}&lt;/code&gt; 。标记 &lt;code&gt;#{}&lt;/code&gt; 指定空映射的单例类型。</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">请注意，此处的模板与 &lt;code&gt;single_line=false&lt;/code&gt; 的模板相同，但是生成的日志条目的不同之处在于标题之后仅一行：</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">请注意,对象插入的时间顺序是保留的;以指定键插入的第一个对象是结果列表中的第一个,以此类推。</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">注意，早期的Erlang / OTP版本支持 &lt;code&gt;.inetrc&lt;/code&gt; 文件的使用，现在已过时。</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">注意,输入到选择解码函数中的值必须是二进制。</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">注意没有&amp;ldquo;;&amp;rdquo; 在 &lt;code&gt;end&lt;/code&gt; 之前。条件与保护措施相同，即测试成功或失败。Erlang从顶部开始进行测试，直到找到成功的条件。然后，它评估（执行）条件之后的动作，并忽略 &lt;code&gt;end&lt;/code&gt; 之前的所有其他条件和动作。如果没有条件匹配，则会发生运行时故障。永远成功的条件是原子 &lt;code&gt;true&lt;/code&gt; 。如果所有其他条件均失败，则通常在 &lt;code&gt;if&lt;/code&gt; 的最后使用它，意思是按照 &lt;code&gt;true&lt;/code&gt; 执行操作。</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">请注意，Erlang驱动程序线程API中没有&amp;ldquo;条件变量等待超时&amp;rdquo;。这是由于 &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; 的问题。当系统时钟突然更改时，不能总是保证您会按预期从呼叫中唤醒。 Erlang运行时系统必须能够应对系统时钟的突然更改。因此，我们从Erlang驱动程序线程API中省略了它。在Erlang驱动程序的情况下，可以并且应该通过Erlang驱动程序API的计时器功能来处理超时。</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，没有针对表的自动垃圾收集。即使没有任何进程对表的引用，除非所有者进程终止，否则不会自动销毁该表。要显式销毁表，请使用函数 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; 。默认所有者是创建表的过程。要在进程终止时转移表所有权，请使用选项 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 或调用 &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">请注意,这些结果是高度特定于实现的,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">请注意,这些值并不能保证是在每个状态下花费的准确时间。这是因为为了保持尽可能小的开销而做的各种优化。</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">注意,这可能会导致消息队列溢出,因为在这种情况下没有办法节制发送者(没有流量控制)。</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">请注意，此代码从不使用 &lt;code&gt;ets:match/2&lt;/code&gt; ，而是使用 &lt;code&gt;ets:lookup/2&lt;/code&gt; 调用。的 &lt;code&gt;lists:map/2&lt;/code&gt; 呼叫仅用于遍历 &lt;code&gt;idno&lt;/code&gt; S IN表匹配名称&amp;ldquo;布赖恩&amp;rdquo;; 因此，主表中的查找次数得以最小化。</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">请注意，这丝毫没有说明如何将字符放置在I / O设备上或由I / O服务器处理。不同的I / O服务器可以根据需要处理字符，这只能告诉I / O服务器期望数据采用哪种格式。在&amp;ldquo; &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; 情况下，&amp;ldquo; &lt;code&gt;Encoding&lt;/code&gt; 告诉指定函数生成哪种格式。</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">请注意，此功能也可以作为代码升级过程的一部分来调用。因此，该功能不应有任何副作用。有关管理程序代码升级的更多信息，请参见《OTP设计原则》中的&amp;ldquo; &lt;code&gt;Changing a Supervisor&lt;/code&gt; 管理程序&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">请注意，此功能不会影响表的选项 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 。例如，表所有者可以将 &lt;code&gt;heir&lt;/code&gt; 设置为自己，将表赠与他人，然后在接收方终止时将其取回。</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">请注意,这个函数并不直接操作日志记录器配置,这意味着如果默认的日志记录器处理程序已经记录到一个文件,这个函数可能会导致记录到第二个文件。</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">请注意，即使使用支持SMP的仿真器，此功能&lt;strong&gt;也不&lt;/strong&gt;是线程安全的。</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">请注意，此函数位于 &lt;code&gt;Erl_Interface&lt;/code&gt; 库中。</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">请注意,该函数只能用于连接到新启动的RAM节点(N.D.R.S.N.),且模式为空。例如,如果在网络被分区后使用这个函数,可能会导致表不一致。</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">请注意,这个标识符有时被称为 &quot;name&quot;。现在尽可能地使用 &quot;标识符 &quot;或 &quot;id&quot;,但为了保持向后的兼容性,仍然可以找到 &quot;name &quot;的出现,例如在错误信息中。</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">请注意，这&lt;strong&gt;不&lt;/strong&gt;等同于反转 &lt;code&gt;select/3&lt;/code&gt; 调用的结果列表，因为结果列表不仅被反转，而且还包含表中的最后一个 &lt;code&gt;Limit&lt;/code&gt; 匹配对象，而不是第一个。</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">请注意，对于2.11.4之前的内核版本，&lt;strong&gt;无法&lt;/strong&gt;保证。</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">请注意，对于2.13之前的内核版本，&lt;strong&gt;不能&lt;/strong&gt;保证这样做。</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">请注意，这是开始生成故障转储时条目的确切快照。因此，它们很可能与&lt;strong&gt;= proc&lt;/strong&gt;部分中相同进程的条目不同（并且更具说服力）。如果当前没有正在运行的进程，则仅显示&amp;ldquo; &lt;strong&gt;当前进程&amp;rdquo;&lt;/strong&gt;条目。</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">请注意,这个列表太长了,以至于在一行上放不下。这并不重要,Erlang允许在所有 &quot;合理的地方 &quot;进行换行,但不允许在原子、整数等中间换行。</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">请注意，这仅影响输出中列表和二进制文件的&lt;strong&gt;启发式&lt;/strong&gt;解释。例如， &lt;code&gt;~ts&lt;/code&gt; 格式序列始终输出有效的字符列表，而不管 &lt;code&gt;+pc&lt;/code&gt; 设置如何，因为程序员已明确请求输出字符串。</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">请注意，此选项不会更改有关 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; 任何保证。对许多对象做出此类承诺的函数（例如 &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; ）从此选项中获得的收益较少（或没有收益）。</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">请注意,这部分以&quot;.&quot;结尾,表示这个函数没有其他部分了。</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">注意，该部分以分号&amp;ldquo;;&amp;rdquo;结尾。表示还有更多功能 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 即将到来。</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">注意，此状态图未指定在 &lt;code&gt;open&lt;/code&gt; 状态下如何处理按钮事件。因此，您需要在此处阅读一些附注，即：未指定的事件将被推迟（在以后的状态中处理）。同样，状态图并未显示必须在每种状态下都必须处理 &lt;code&gt;code_length/0&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">请注意， &lt;code&gt;ordered_set&lt;/code&gt; 尚未提供Ets中的ordered_set类型，也没有对并发更新的有限支持，这使得可以在固定ETS表上安全地使用一系列 &lt;code&gt;first&lt;/code&gt; 调用和 &lt;code&gt;next&lt;/code&gt; 调用。Dets可能会在Erlang / OTP的将来版本中提供这两个功能。在此之前，必须使用Mnesia应用程序（或某些用户实现的锁定方法）来实现安全并发​​。当前，没有Erlang / OTP库支持基于磁盘的有序术语存储。</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">请注意，如果此处出现错误，我们仅返回数据（使用 &lt;code&gt;driver_output&lt;/code&gt; ），否则我们将等待连接完成，在这种情况下，将调用 &lt;code&gt;ready_io&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ecb8672fadbd7174fe3603f747f5dd084a5c8a1f" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在调用局部函数时，使用隐式或完全限定的函数名是有区别的。后者总是指模块的最新版本。请参见 &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">请注意，在运行时中更改处理程序的配置时，不得修改disk_log选项（ &lt;code&gt;file&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;max_no_files&lt;/code&gt; ， &lt;code&gt;max_no_bytes&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">请注意，在操作PLT时，不会发出警告。要在（重新）分析PLT期间打开警告，请使用 &lt;code&gt;--get_warnings&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">注意，当调用多个事件处理程序时，一个事件处理程序返回一个 &lt;code&gt;hibernate&lt;/code&gt; 请求就足以使整个事件管理器进入休眠状态。</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，当重新启动策略为 &lt;code&gt;simple_one_for_one&lt;/code&gt; 时，子规范的列表必须是仅包含一个子规范的列表。（忽略子规范标识符。）然后在初始化阶段不启动任何子进程，但是假定所有子进程都使用 &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; 动态启动。</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">请注意，您不必担心在创建记录时为记录的各个部分分配值的顺序。使用记录的好处是，通过将其定义放在头文件中，您可以方便地定义易于更改的接口。例如，如果要向记录添加新字段，则只需更改使用新字段的代码，而不必在引用记录的每个位置都进行更改。如果在创建记录时遗漏了某个字段，那么它将获得原子 &lt;code&gt;undefined&lt;/code&gt; 的值。（*手册*）</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">请注意，如本例所示， &lt;code&gt;String&lt;/code&gt; 中两个或多个相邻的分隔符被视为一个。也就是说，结果标记列表中没有空字符串。</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">请注意，如本示例所示， &lt;code&gt;String&lt;/code&gt; 中两个或多个相邻的分隔符字素簇被视为一个。即，结果词素列表中没有空字符串。另请参见 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; ，它返回空字符串。</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">注意，例如，在 &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; 使用字符串文字是&amp;lt;&amp;lt; $ a，$ b，$ c &amp;gt;&amp;gt;的语法糖。</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">注意，使用Erlang中的二进制语法，驱动程序可以直接从二进制文件中匹配标头，因此可以将标头放入二进制文件中，并将 &lt;code&gt;hlen&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">注意第二种情况中的 &lt;code&gt;--&lt;/code&gt; 分隔符。</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">注意到小数(浮点数)的引入,没有任何解释。希望你能应付一下。</target>
        </trans-unit>
        <trans-unit id="b434bf92c1158275f129698bacaf4280054d4c1a" translate="yes" xml:space="preserve">
          <source>Notice the order, the &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; that we used many times in this user guide is a shortcut in the normalization process returning the intermediate datastructure, and allowing us to inspect and apply further decoding on the remaining percent-encoded triplets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">请注意，&lt;strong&gt;匹配&lt;/strong&gt;和&lt;strong&gt;比较equal&lt;/strong&gt;之间有细微的差别，表类型 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;ordered_set&lt;/code&gt; 证明了这一点：</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">请注意标签 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; ，它们在封面规格文件和 &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; 的调用中使用。这些的目的仅是将Cover规范中指定的模块映射到对analytics函数的调用中指定的日志目录。标记名称没有其他含义。</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">请注意，与普通算术一样，请使用方括号，乘法运算符&amp;ldquo; *&amp;rdquo;和除法运算符&amp;ldquo; /&amp;rdquo;（请参见 &lt;code&gt;Expressions&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">注意没有&amp;ldquo;;&amp;rdquo; 在 &lt;code&gt;end&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">然而,请注意,PCRE对\G的解释是当前匹配的开始,与Perl的解释有细微的不同,Perl将其定义为前一次匹配的结束。在Perl中,当之前匹配的字符串是空的时候,这两者可能是不同的。由于PCRE一次只进行一次匹配,所以它不能重现这种行为。</target>
        </trans-unit>
        <trans-unit id="741d95219191f3fd87708b3b502f3129d86f5b91" translate="yes" xml:space="preserve">
          <source>Notification Filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc912e028896fb2120e68a26a7e2cec85b39064" translate="yes" xml:space="preserve">
          <source>Notification Sending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">在SMIv1中,通知的定义是在MIB的定义中使用TRAP-TYPE宏(见RFC1215)。SMIv2中对应的宏是NOTIFICATION-TYPE。当应用程序决定发送通知时,它调用以下函数之一。</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">代理商的通知/陷阱会传递给进行注册的用户。</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">通知何时重新加载驱动程序（如果正在加载，则加载驱动程序）。仅监视正在加载或重新加载过程中的驱动程序才有意义。无法监视将来用于加载的驱动程序名称。这只会导致立即发送 &lt;code&gt;DOWN&lt;/code&gt; 消息。因此，在由 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 函数触发时，监视加载是最有用的，&lt;strong&gt;因为&lt;/strong&gt;驱动程序处于挂起状态，因此创建了监视器。</target>
        </trans-unit>
        <trans-unit id="bb6282907337e9abaf6ab3833a675724d09d4658" translate="yes" xml:space="preserve">
          <source>Now &quot;Stack needed&quot; and &quot;Heap needed&quot; are in the same word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">现在， &lt;code&gt;A&lt;/code&gt; 产生了摘要和它自己的挑战。这些一起打包发送到 &lt;code&gt;B&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">现在可以实现 &lt;code&gt;complex1:foo/1&lt;/code&gt; 和 &lt;code&gt;complex1:bar/1&lt;/code&gt; 。两者都向 &lt;code&gt;complex&lt;/code&gt; 过程发送一条消息，并收到以下答复：</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">现在可以实现 &lt;code&gt;complex5:foo/1&lt;/code&gt; 和 &lt;code&gt;complex5:bar/1&lt;/code&gt; 。两者都向 &lt;code&gt;complex&lt;/code&gt; 过程发送消息并收到以下答复：</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">现在，将使用列表的其余部分作为参数调用 &lt;code&gt;format_temps(Rest)&lt;/code&gt; 。这种处理方式类似于其他语言中的循环构造。 （是的，这是递归，但是不要让您担心。）因此，再次调用了相同的 &lt;code&gt;format_temps&lt;/code&gt; 函数，这次 &lt;code&gt;City&lt;/code&gt; 获得了值 &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; ,并且重复了相同的过程。完成此操作，直到列表变为空，即[]，从而使第一子句 &lt;code&gt;format_temps([])&lt;/code&gt; 匹配。这只是返回（导致）原子 &lt;code&gt;ok&lt;/code&gt; ，因此程序结束。</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">现在彼得用c1@bilbo登录。</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">现在彼得给弗雷德发了一条信息。</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">现在必须添加一个函数来寻找最高和最低温度的城市。下面的程序不是最有效的方法,因为你要把城市列表走四遍。但还是先追求清晰和正确,只有在需要的情况下,才会让程序高效。</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">现在一个 &lt;code&gt;ETERM&lt;/code&gt; 可以使用函数来构造表示所述整数结果结构 &lt;code&gt;erl_mk_int()&lt;/code&gt; 从 &lt;code&gt;erl_eterm&lt;/code&gt; 。也可以使用模块 &lt;code&gt;erl_format&lt;/code&gt; 中的函数 &lt;code&gt;erl_format()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">现在以乒乓为例,用链接来终止 &quot;乒乓&quot;。</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">现在举个例子,在处理列表时--颠倒列表的顺序。</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">现在假设对 &lt;code&gt;Expression&lt;/code&gt; 的解释是一组调用。如果命名类型比表达式类型更通用（分别说 &lt;code&gt;Mod&lt;/code&gt; 和 &lt;code&gt;Fun&lt;/code&gt; )，则强制转换表达式的解释是调用集（M1，M2），这样表达式的解释包含来自M1某些函数的调用M2的某些功能。如果命名类型比表达式类型更特殊，例如 &lt;code&gt;Fun&lt;/code&gt; 和 &lt;code&gt;Mod&lt;/code&gt; ，则解释是所有函数调用（F1，F2）的集合，这样表达式的解释包含一个调用（M1，M2），而F1是M1和F2的功能是M2的功能（在 &lt;code&gt;modules&lt;/code&gt; 模式下，没有函数调用，因此强制转换为 &lt;code&gt;Fun&lt;/code&gt; 总是产生一个空集）。同样，与应用程序和发行版之间的转换也是如此。</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">现在回到乒乓球的例子。</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">现在将目录更改为基本目录，并设置 &lt;code&gt;$ERL_TOP&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">现在举一个较大的例子来巩固到目前为止所学的知识。假设你有一份来自世界上许多城市的温度读数列表,其中有些是摄氏度,有些是华氏度(如前面的列表)。其中有些是以摄氏度为单位,有些是以华氏度为单位(如前面的列表)。首先让我们把它们全部转换为摄氏度,然后让我们整齐地打印数据。</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">现在举个大一点的例子,用一个简单的 &quot;信使&quot;。这个 &quot;信使 &quot;是一个允许用户在不同的节点上登录并互相发送简单消息的程序。</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">现在举个更复杂的例子,一个数字的阶乘。例如,4的阶乘是4*3*2*1,等于24。</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">现在让我们回到城市和温度的问题上,但这次要采取更有条理的方法。首先,让我们将整个列表转换为摄氏度,如下所示。</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">现在让我们回到代码的前两行。Erlang程序以文件形式编写。每个文件都包含一个Erlang &lt;strong&gt;模块&lt;/strong&gt;。模块中的第一行代码是模块名称（请参阅 &lt;code&gt;Modules&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">现在让我们看看 &quot;ping &quot;这个过程。回顾一下,它是通过执行以下命令启动的。</target>
        </trans-unit>
        <trans-unit id="6eddc3d3ff799bf232cc855fb7b548b211ee7ca5" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of &lt;code&gt;move_xx&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a7fa9dfcc333d467dd81b0a30c1df103da8ee8" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of the &lt;code&gt;move&lt;/code&gt; instruction. There are multiple files containing implementations of instructions in the &lt;code&gt;erts/emulator/beam&lt;/code&gt; directory. The &lt;code&gt;move&lt;/code&gt; instruction is defined in &lt;code&gt;instrs.tab&lt;/code&gt;. It looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">现在运行程序。</target>
        </trans-unit>
        <trans-unit id="7e848956566e548f1d9ae0d0b8013c74e6d83d3a" translate="yes" xml:space="preserve">
          <source>Now that we have defined the fragments, we need to inform &lt;strong&gt;beam_makeops&lt;/strong&gt; how they should be connected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">现在开始对咕噜进行 &quot;庞 &quot;的处理。</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">现在可以生成 &lt;code&gt;relup&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">现在， &lt;code&gt;tut2&lt;/code&gt; 程序几乎不是好的编程风格。考虑：</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">现在可以启动C节点。如果使用短节点名，则通过调用 &lt;code&gt;erl_connect_init()&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">现在C节点服务器可以接受来自Erlang节点的连接。</target>
        </trans-unit>
        <trans-unit id="f57b2ed1c1f99cc47795c85e2110f62964631a09" translate="yes" xml:space="preserve">
          <source>Now we can publish the structure in the table by writing the the pointer to the process structure in the slot previously reserved in 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">现在我们来谈谈更有趣的事情。</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">现在，我们有了可以以各种方式启动的目标系统。我们通过调用以下命令将其作为&lt;strong&gt;基本目标系统&lt;/strong&gt;启动：</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">现在，我们来看另一个有趣的伪函数， &lt;code&gt;garbage_collect&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">现在我们要从表中读取数据。函数 &lt;code&gt;get_until/5&lt;/code&gt; 读取数据并应用该函数，直到它说完成为止。结果发送回客户端：</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">现在当列表转换后,增加了一个打印的功能。</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">现在你已经为一些Unicode输入和输出做好了准备。最简单的做法是在shell中输入一个字符串。</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">现在，您可以通过在外壳中编写 &lt;code&gt;type erlc&lt;/code&gt; 来检查您拥有哪个erlc 。它应位于 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 或 &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bd9b4b08ad2850cc0852933844bf5bbc09109e4" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">现在，在 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; 中将有一个名为 &lt;code&gt;otp_win32_21.exe&lt;/code&gt; 或 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 的文件，即 &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf27925b0551dd76b6d0908cbb333e95a400dac2" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_23.exe&lt;/code&gt; or &lt;code&gt;otp_win64_23.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">现在， &lt;code&gt;fact(0)&lt;/code&gt; 被调用，并且函数子句再次被顺序扫描。首先，将模式 &lt;code&gt;N&lt;/code&gt; 与0匹配。匹配成功，但是防护（ &lt;code&gt;N&amp;gt;0&lt;/code&gt; ）为false。其次，将模式0与0进行匹配。匹配成功并且对主体进行了评估：</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">现在,回到例子中,我们想让输出更有安排。有了模板。</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">现在，假设 &lt;code&gt;m1&lt;/code&gt; 是一个库模块，那么系统 &lt;code&gt;s2&lt;/code&gt; 也经常使用它。测试运行 &lt;code&gt;s2&lt;/code&gt; 并没有专门测试 &lt;code&gt;m1&lt;/code&gt; ，但是查看 &lt;code&gt;s2&lt;/code&gt; 测试涵盖了 &lt;code&gt;m1&lt;/code&gt; 的哪些部分仍然很有趣。为此， &lt;code&gt;m1&lt;/code&gt; 也可以包含在 &lt;code&gt;s2&lt;/code&gt; 的封面规范中，如下所示：</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">现在，这样的 &lt;code&gt;monitor&lt;/code&gt; 调用将成功，并创建一个监视器。但是监控器只会监督连接。也就是说， &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; 是唯一可以接收的消息，因为原始节点无法报告所监视进程的状态。</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">现在,折叠和地图可以同时进行。</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">现在的编译器把列表理解改写成普通的递归函数。使用尾部有反转的递归函数还是会更快。或者说会吗?这就导致了尾递归函数比体递归函数快的神话。</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">上次读取表后，将一次调用 &lt;code&gt;PostFun&lt;/code&gt; 回调函数PostFun。捕获的返回值将被忽略。如果 &lt;code&gt;PreFun&lt;/code&gt; 已经呼吁建立一个表， &lt;code&gt;PostFun&lt;/code&gt; 可以保证被称为该表，即使查询的评估由于某种原因失败。</target>
        </trans-unit>
        <trans-unit id="e386a6937b577f217d46833120530e874cdb7e8a" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system (optional) You need this to build the self installing package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Nullsoft NSIS安装系统。你需要这个来构建自安装包。这是一个免费的开源安装程序,比商业的Wise和Install shield安装程序好用得多。这也是我们用于商业版本的安装程序。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">Number ::=-与非负的 Erlang 整数相同--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</target>
        </trans-unit>
        <trans-unit id="b120174b0ca1d364c35e309340c2699137e93cf3" translate="yes" xml:space="preserve">
          <source>Number of Atoms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">这把锁的收购数量。</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">一个函数或函数的参数数</target>
        </trans-unit>
        <trans-unit id="5f360155f999f4bc86536b7ac3f8776370a01909" translate="yes" xml:space="preserve">
          <source>Number of bits may be divisible by 8, which means a binary decodable by &lt;code&gt;ei_decode_binary&lt;/code&gt; is also decodable by &lt;code&gt;ei_decode_bitstring&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">套接字收到的字节数。</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">从套接字发送的字节数。</target>
        </trans-unit>
        <trans-unit id="2f05c7528a7c09c8ca7b40c3010abfa2c48aee95" translate="yes" xml:space="preserve">
          <source>Number of bytes waiting to be sent by the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">从导出的函数中调用的次数。</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">当一个线程试图获取这个锁时的碰撞次数。这时,trylock是ebusy,读持有rw_lock时的写尝试,写持有rw_lock时的读尝试,线程尝试锁定一个已经锁定的锁。内部状态监督)。</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">待收到的数据块数量</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">入站流的数量</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">要显示的行数(进程)。</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">文件的链接数(对于没有链接概念的文件系统,这个数字总是1)。</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">如果对等体不关闭连接,在传入DPR后终止传输连接的毫秒数。</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">如果没有收到DPA,在发出DPR后终止传输连接的毫秒数。</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">如果未从对等方接收到预期的功能交换消息（CER或CEA），则具有建立的传输连接的传输过程将终止的毫秒数。对于连接传输，连接尝试的时间由 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 到期时间控制。对于侦听传输，对等方确定时间。</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">请求超时的毫秒数。默认值为5000。</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果尚未收到DPA，则终止传输过程的毫秒数。默认为 &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">距离信息发出的时间还剩多少毫秒。</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">出境流的数量</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">套接字收到的数据包数量。</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">从套接字发送的数据包数量。</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">要启动的传输过程数。对于侦听传输，确定接受传输过程的池的大小，其中较大的数目对于处理多个并发的对等连接尝试是理想的。用于连接传输，确定将试图被establshed所讨论的连接的对等体的数量：所述 &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;restrict_connections&lt;/code&gt; 也应该对有问题的服务被配置成允许到同一对等体的多个连接。</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">未acked数据块的数量</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs/2+1 | 0</target>
        </trans-unit>
        <trans-unit id="8e1b0dd3b8942a6f418c72794efaf599fa638602" translate="yes" xml:space="preserve">
          <source>Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBC数据类型</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="7025579510c04aa01d4607a0e0aca5cbec9f5502" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6aa8960d1405b5237c6590a23f7510a292a61f98" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="178a184607add52e5bb5d680a1449c26c616fc56" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01588880c00f5e2abc030e7f6d3e755195174bd7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7438774d77f88e98fd2822354fa0458e5289e97d" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0552e661b2ea6fc224f8f95384fb27a6c1bfc0f7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">可选的; 如果定义了此函数，则还必须定义 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00ff70d59339a0ed84894894c61d1c1f2ef4d4e9" translate="yes" xml:space="preserve">
          <source>OS Monotonic Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6942daa3866fbe3e050507e50fbe84fe8347bcc" translate="yes" xml:space="preserve">
          <source>OS System Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">OS X(达尔文)</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x/Snow Leopard、OS X 10.7.x/Lion 以及可能的更新版本。</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X/Darwin。32位模式下的Darwin 9.8.0应该可以使用。</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">操作系统消息格式为元组 &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a67749980ef635fc8a670abb9e6fe74b4789978f" translate="yes" xml:space="preserve">
          <source>OS standard client and Erlang daemon (server)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">操作系统系统时间也可以通过 &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; 恢复。</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">当用户最终确定时间偏移时,操作系统系统时间必须正确。</target>
        </trans-unit>
        <trans-unit id="6a1aec662bcb7daef4aac0bdc11df31e66bf2d12" translate="yes" xml:space="preserve">
          <source>OTP 17.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de82a1d6e138a112b2ca58f2dba4eb38c8d2b810" translate="yes" xml:space="preserve">
          <source>OTP 17.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37bb2cd4f43310f6b07a381a40baa26e515175a" translate="yes" xml:space="preserve">
          <source>OTP 17.1.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e91f185f69a2ee4d0fbc84adbe27a2af2afdba2" translate="yes" xml:space="preserve">
          <source>OTP 17.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349cafd1d20ce8426e0b816e9c62b481bf800e1" translate="yes" xml:space="preserve">
          <source>OTP 17.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7470cc6ea6636b34aed5c1b324e72d549188877" translate="yes" xml:space="preserve">
          <source>OTP 17.5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303ea13a1fd386fe9f485b047ad9fbdd6c02040e" translate="yes" xml:space="preserve">
          <source>OTP 17.5.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fb89bd5f06bbf79eb565ca69b6861d91f7db23" translate="yes" xml:space="preserve">
          <source>OTP 17.5.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80c6f60adc5b870c25fb7c1013052f9d969c1e6" translate="yes" xml:space="preserve">
          <source>OTP 18.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb7af0c267d730fc45b68514cdc898b04ecd498" translate="yes" xml:space="preserve">
          <source>OTP 18.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bc05cb3765c17f769bcb5b7fb96b731b1c3725" translate="yes" xml:space="preserve">
          <source>OTP 18.1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd3b841b2d92c0b1abf38595d7acccf3845a2fa" translate="yes" xml:space="preserve">
          <source>OTP 18.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc6e46df551f13559fc03eedfe953522eb1359b" translate="yes" xml:space="preserve">
          <source>OTP 18.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c51896e23a1d1a678491db0ebaac921c06655" translate="yes" xml:space="preserve">
          <source>OTP 18.3.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda7846ff22cbff28cabbc39495e00ce1b7a18c2" translate="yes" xml:space="preserve">
          <source>OTP 19.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d95768670e0cd5fdbc1095ed0d1b993a8b2d9" translate="yes" xml:space="preserve">
          <source>OTP 19.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05083dc18d014647306ef002a92e31b47deb28fc" translate="yes" xml:space="preserve">
          <source>OTP 19.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae471f5364f5af28f7619f0b3d347819f821f34c" translate="yes" xml:space="preserve">
          <source>OTP 19.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfa396d52da21e038d97a4ee414f99969525781" translate="yes" xml:space="preserve">
          <source>OTP 20.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c37e3f1567db3d2ab061a53dad37370ec3d4a22" translate="yes" xml:space="preserve">
          <source>OTP 20.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f3a32e48ff7a1dda6db9c262b2f8cbf4924dab" translate="yes" xml:space="preserve">
          <source>OTP 20.1.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1ec79e85f251b1426541568df1755b478c8f13" translate="yes" xml:space="preserve">
          <source>OTP 20.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571eb6245a94eb851a6d7f90f3a8e74e0ae0d599" translate="yes" xml:space="preserve">
          <source>OTP 20.2.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e47bfe8e3a87617385f6f0d76f42d53dc879d6" translate="yes" xml:space="preserve">
          <source>OTP 20.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00961db21191f2944a9b797a6cdbf961bf46d33" translate="yes" xml:space="preserve">
          <source>OTP 21.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5be130ed3c502555d8f25e673de0b9efaa0941" translate="yes" xml:space="preserve">
          <source>OTP 21.0.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6021644865848073f992bae8b9c943c4afc7f8d3" translate="yes" xml:space="preserve">
          <source>OTP 21.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bbe1165ae35f17f43e710bfcffbe55c6ef69a2" translate="yes" xml:space="preserve">
          <source>OTP 21.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e689e6310bfe6136b48d902e26821ce9f123a9" translate="yes" xml:space="preserve">
          <source>OTP 21.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028e9221844cfd633f1eb008eaabcd781d51f96" translate="yes" xml:space="preserve">
          <source>OTP 21.3.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c232413f3213891452a5c261023c072ccd809791" translate="yes" xml:space="preserve">
          <source>OTP 22.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48773e8bb6bc4865bc681e3589d114b4e76b24a" translate="yes" xml:space="preserve">
          <source>OTP 22.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91df35b0c49a83fd12aa5367b8122925620295d9" translate="yes" xml:space="preserve">
          <source>OTP 22.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e767c5320fed5f340e4813fb7b81851515b9db" translate="yes" xml:space="preserve">
          <source>OTP 23.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645ad46075735cc44ee0b79de93dee14343f8e64" translate="yes" xml:space="preserve">
          <source>OTP 23.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7aca3e13ec5787bed988186babbcbbb08e4d83" translate="yes" xml:space="preserve">
          <source>OTP 23.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5cb3c43764b6e3642d0cc6e9870ab0a059e023" translate="yes" xml:space="preserve">
          <source>OTP R13B04</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c6138485cd68240ee15c2a9a5be15cfec50775" translate="yes" xml:space="preserve">
          <source>OTP R14B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1b5b8bc61568f039950359e0853f2bf506f077" translate="yes" xml:space="preserve">
          <source>OTP R14B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2068218ce2ddac80161a50fcee5791fada3771a" translate="yes" xml:space="preserve">
          <source>OTP R14B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9beac3fef36e94cdbe62f62d9631b02ce56c0c" translate="yes" xml:space="preserve">
          <source>OTP R14B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2cafa05f322e10fce6e2a71d88c24e3384148b" translate="yes" xml:space="preserve">
          <source>OTP R14B04</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c661581e56206ae5fffaf6b280a8cebf6df8545" translate="yes" xml:space="preserve">
          <source>OTP R15B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de524763778e0a0702eb821d76e1813ba58749a" translate="yes" xml:space="preserve">
          <source>OTP R15B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af10a49ebba90d9d20eaf701836dad0d8942390f" translate="yes" xml:space="preserve">
          <source>OTP R15B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927bd5757ada2536880868ac83237b0ba7d7267a" translate="yes" xml:space="preserve">
          <source>OTP R15B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d49d7f1b267727894067d4e17bd61989d7f900" translate="yes" xml:space="preserve">
          <source>OTP R16B</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf5721a7a707f5795c8ede7966ac925475590f0" translate="yes" xml:space="preserve">
          <source>OTP R16B01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a6f83de13304461ed514ae1410a25c30bef92f" translate="yes" xml:space="preserve">
          <source>OTP R16B02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72498ce41f5658d95091b6ea2350ae21b5605581" translate="yes" xml:space="preserve">
          <source>OTP R16B03</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d85f4d55d00adcbdf0c015b765c1dbf0415d274" translate="yes" xml:space="preserve">
          <source>OTP Versions Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP还支持更改行为流程的内部状态，请参阅 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">检察官办公室和(因此)Mnesia数据库。</target>
        </trans-unit>
        <trans-unit id="a850f204ff4cd54ef41e013bea894026258c1347" translate="yes" xml:space="preserve">
          <source>OTP application Config</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">特定版本的OTP是特定版本的一组应用程序。OTP版本标识的应用程序版本对应于爱立信AB的Erlang / OTP团队一起测试过的应用程序版本。但是，可以将OTP系统与来自不同OTP版本的应用程序放在一起。应用程序版本的这种组合未经Erlang / OTP团队的测试。因此，&lt;strong&gt;始终首选使用来自单个OTP版本的OTP应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">Unix的OTP启动脚本示例。</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTP支持在创建 &lt;code&gt;.appup&lt;/code&gt; 文件时使用的一组&lt;strong&gt;发行处理说明&lt;/strong&gt;。发布处理程序了解这些&lt;strong&gt;低级&lt;/strong&gt;指令的子集。为了使用户更容易使用，还有许多&lt;strong&gt;高级&lt;/strong&gt;指令，这些指令由 &lt;code&gt;systools:make_relup&lt;/code&gt; 转换为低级指令。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">因此，除 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; 外，OTP不支持更改居住模块。</target>
        </trans-unit>
        <trans-unit id="ad15f1b38f41249c946792c972d910fa729db9d3" translate="yes" xml:space="preserve">
          <source>OTP-22 introduces support for TLS 1.3. The current implementation supports a selective set of cryptographic algorithms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96fc983a2c3eaec3d8d2f2620f536bca0494a75" translate="yes" xml:space="preserve">
          <source>OTP-22.0</source>
          <target state="translated">OTP-22.0</target>
        </trans-unit>
        <trans-unit id="e91f35ba89b72bce378114917c30a606df1775f6" translate="yes" xml:space="preserve">
          <source>OTP-23</source>
          <target state="translated">OTP-23</target>
        </trans-unit>
        <trans-unit id="7a931e0d87dd0cc978b0822251977a0aacd4fc45" translate="yes" xml:space="preserve">
          <source>OTP-SNMPEA-MIB</source>
          <target state="translated">OTP-SNMPEA-MIB</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP /加密要求用户提供有关密钥的两三项信息。用户使用的应用程序通常处于较高级别，例如 &lt;code&gt;SSL&lt;/code&gt; 。如果直接使用加密应用程序，则要求：</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">对象标识符，由 &lt;code&gt;ASN.1&lt;/code&gt; 编译器生成的整数元组。</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 的基于对象的编程</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">对象通过set和get函数进行存储和检索。下面的例子展示了如何存储整数、浮点数、字符串和任意二进制对象。</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">可以从注册表中删除对象。</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">观察E2可以给E不同，举例来说如果有中定义的默认值 &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">请注意 &quot;TerminationId &quot;记录在内部表格中没有使用。它已经被一个megaco_term_id记录取代了(定义在 &quot;megaco/include/megaco.rl &quot;中)。</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">观察白色空间:标记之间的每个空格、制表符或换行都会导致xmlText记录。</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">观察者是一个观察Erlang系统特性的图形化工具,它可以显示系统信息、应用监督树、进程信息、ETS表、Mnesia表,并包含了Erlang追踪的前端。观察者可以显示系统信息、应用监督树、进程信息、ETS表、Mnesia表,并包含Erlang追踪的前端。</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Observer是用于观察Erlang系统特征的图形工具。Observer工具显示系统信息，应用程序主管树，过程信息，ETS表，Mnesia表，并包含用于模块 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 的 Erlang跟踪的前端。</target>
        </trans-unit>
        <trans-unit id="8160323258aa98f01ffae3a9b4dd4732b06a4950" translate="yes" xml:space="preserve">
          <source>Obsolete API functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">没有任何影响的过时标志，并且 &lt;code&gt;-setcookie&lt;/code&gt; 常见拼写错误。请改用 &lt;code&gt;-setcookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">显然,PCRE不能支持Perl代码的插值。相反,它支持整个模式的递归,以及单个子模式的递归的特殊语法。这种递归在PCRE和Python中引入后,后来在5.10版本中被引入Perl中。</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">很明显,如果列表的原始顺序很重要的话,这段代码就不起作用了。如果必须保留清单的顺序,请按以下方式操作。</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">在ECDSA密钥中,通常只有RSA、DSA或ECDSA公钥,但可以添加其他公钥的处理。</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">关:正常的黑白显示。</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">离线支持- 用于生成脚本和构建发行包的 &lt;code&gt;systools&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">与当前位置的偏移。</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">从文件末尾开始偏移。</target>
        </trans-unit>
        <trans-unit id="74f0c027755f3a641da0ac7fb4fdc91ca752be19" translate="yes" xml:space="preserve">
          <source>Offset to the next byte to write which also equals the amount of bytes currently written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">奥汉姆空间标记</target>
        </trans-unit>
        <trans-unit id="80a20b8493b41152418b7eebcae86cbcce091a38" translate="yes" xml:space="preserve">
          <source>Okasaki API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="5d9e0077e7780f989a1ceec9b3ec38c49f01d731" translate="yes" xml:space="preserve">
          <source>Old API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e62dbf3fb5370db410bc5b62d0381b5e3d16213" translate="yes" xml:space="preserve">
          <source>Old Crypto API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ffd367297aa558fd23448e1c93eab612c4b2b7" translate="yes" xml:space="preserve">
          <source>Old URI utility module, use uri_string instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b178b6946982a11f1126a949ec15c4d708664fde" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">必须更新旧驱动程序（与ERTS 5.9之前的 &lt;code&gt;erl_driver.h&lt;/code&gt; 一起编译），并且必须使用扩展接口（带有 &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13302e0d3a7dec730ee4bc597d731b5ec3f28913" translate="yes" xml:space="preserve">
          <source>Old-style exec specification that are kept for compatibility, but should not be used in new programs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="d3e43fe6cc5ed7e93ad3fb3737bbd4c693602579" translate="yes" xml:space="preserve">
          <source>OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="47ef70f9915b940884f76385b871fac7afb63176" translate="yes" xml:space="preserve">
          <source>OldValue</source>
          <target state="translated">OldValue</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="ba2f4398b4a78c8c3781b266ce8f8b6790397950" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;, and reduce the paths in stack traces to the module name alone. This option will make it easier to achieve reproducible builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">省略 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 返回的列表中的 &lt;code&gt;options&lt;/code&gt; 和 &lt;code&gt;source&lt;/code&gt; 元组。此选项将使实现可复制的构建更加容易。</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">省略行号信息,以产生一个稍小的输出文件。</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">然后，省略的字段将获得评估 &lt;code&gt;ExprL&lt;/code&gt; 的值，而不是其默认值。此功能主要用于为ETS和Mnesia匹配功能创建模式。</target>
        </trans-unit>
        <trans-unit id="2b4336bcea263f419ca09551f44528b242f15a01" translate="yes" xml:space="preserve">
          <source>On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">在32位架构上：-134217729 &amp;lt;i &amp;lt;134217728（28位）。</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">在32位架构上。4个字:</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">在32位架构上。从当前本地节点引用5个字+从另一个节点引用7个字。</target>
        </trans-unit>
        <trans-unit id="d729d6c56ff45c63b971639d2a3f12703da39867" translate="yes" xml:space="preserve">
          <source>On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt;. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee722acfea1218e0e9779b8fb79277f2b70e2b3" translate="yes" xml:space="preserve">
          <source>On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; within the Erlang term object is used to determine if something &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt;. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">在64位体系结构上：-576460752303423489 &amp;lt;i &amp;lt;576460752303423488（60位）。</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">在64位架构上。3个字:</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">在64位架构上。当前本地节点的引用为4个字+另一节点的引用为6个字。</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">在C节点上， &lt;code&gt;erl_interface&lt;/code&gt; 支持注册表表。这些表位于C节点的RAM中，但也可以转储到Mnesia表中。默认情况下，通过 &lt;code&gt;erl_interface&lt;/code&gt; 转储注册表表会导致在必要时使用 &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; 创建相应的Mnesia表。</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">关于达尔文。</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">在Linux或UNIX上，您可以放心地忽略它，只需在执行命令 &lt;code&gt;cd&lt;/code&gt; 之后不带任何参数的情况下， &lt;code&gt;.erlang.cookie&lt;/code&gt; 在目录中创建一个名为.erlang.cookie的文件。</target>
        </trans-unit>
        <trans-unit id="1abae7c719ffd5227ee01660d1ddd20cb3841aa3" translate="yes" xml:space="preserve">
          <source>On Linux systems the following changes will be made:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ddff816a143447a28cf2b2f9c5227d387e78f6" translate="yes" xml:space="preserve">
          <source>On Linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; os环境变量XDG_CACHE_HOME。</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">在Linux上：遵守os环境变量 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上：遵守os环境变量 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; os环境变量XDG_DATA_DIRS。</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">在Linux上： &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; os环境变量XDG_DATA_HOME。</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">在UNIX上，发布处理程序告诉 &lt;code&gt;heart&lt;/code&gt; 程序使用哪个命令来重新引导系统。在这种情况下， &lt;code&gt;heart&lt;/code&gt; 程序通常使用的环境变量 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 被忽略。该命令默认改为 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 。可以使用SASL配置参数 &lt;code&gt;start_prg&lt;/code&gt; 设置另一个命令，请参见 &lt;code&gt;sasl(6)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">在Ubuntu上，可以通过 &lt;code&gt;aptitude&lt;/code&gt; 安装：</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">在Unix平台上,可以设置上述以外的其他位。</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">在Unix平台上,如果Unicode文件名翻译生效,环境设置使用UTF-8编码。在Windows平台上,环境的设置使用宽字符接口。</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">在Unix系统上,Erlang运行时将解释两种类型的信号。</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">在Unix上， &lt;code&gt;event&lt;/code&gt; 是管道或套接字句柄（或 &lt;code&gt;select&lt;/code&gt; 系统调用可以理解的事件）。</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">在Unix上， &lt;code&gt;Osname&lt;/code&gt; 具有与 &lt;code&gt;uname -s&lt;/code&gt; 返回相同的值，但小写。例如，在Solaris 1和2上，它是 &lt;code&gt;sunos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">在Unix上,为这个字段指定的任何值都会被忽略(文件的 &quot;ctime &quot;被设置为当前时间)。在Windows上,该字段是为文件设置的新创建时间。</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">在类似Unix的操作系统上,如果启用了Unicode文件名,参数应该是UTF-8,不需要翻译。</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">在类似Unix的操作系统上，终端应能够处理输入和输出的UTF-8（例如，通过现代版本的XTerm，KDE Konsole和Gnome终端来完成），并且您的语言环境设置必须为正确。例如，可以如下设置 &lt;code&gt;LANG&lt;/code&gt; 环境变量：</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">在Windows XP中，选择&lt;strong&gt;控制面板&lt;/strong&gt; &amp;gt; &lt;strong&gt;区域和语言选项&lt;/strong&gt;，选择标签&lt;strong&gt;语言&lt;/strong&gt;，并单击按钮&lt;strong&gt;详细...&lt;/strong&gt;在广场命名为&lt;strong&gt;文字服务和输入语言&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">在Windows平台上,当以长名分布式模式启动时,Erlang会搜索系统注册表而不是寻找配置文件。</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">在Windows系统中,主目录是由环境变量$HOME指出的目录--你可能需要设置它。</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">在Windows上， &lt;code&gt;event&lt;/code&gt; 是 &lt;code&gt;Event&lt;/code&gt; 或 &lt;code&gt;Semaphore&lt;/code&gt; （或 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API函数可以理解的事件）。（仿真器中的一些欺骗手段允许使用超过64个 &lt;code&gt;Events&lt;/code&gt; 的内置限制。）</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">在Windows上，默认值设置为 &lt;code&gt;8196&lt;/code&gt; ,因为将正常的操作系统限制设置为高于大多数计算机可以处理的范围。</target>
        </trans-unit>
        <trans-unit id="d4b05412a62bc9a89fb50987de22114d258a3cec" translate="yes" xml:space="preserve">
          <source>On Windows the maximum number of nodes allowed in one epmd instance is 60. This is because of limitations in the current implementation. If you need more nodes, you should look into using and erlang based epmd implementation such as &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">在Windows上， &lt;code&gt;Osname&lt;/code&gt; 是 &lt;code&gt;nt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">在Windows上，正确的操作要求安装并选择适当的字体供Erlang应用程序使用。如果系统上没有合适的字体，请尝试安装免费的 &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; ，然后在Erlang Shell应用程序中选择该字体。</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">在Windows上，数据是从不同的OS API函数获取的，因此可以像一些 &lt;code&gt;Flag&lt;/code&gt; 值一样计算 &lt;code&gt;Netmask&lt;/code&gt; 和 &lt;code&gt;Broadaddr&lt;/code&gt; 值。报告恶意错误。</target>
        </trans-unit>
        <trans-unit id="47575c57c43d9b6b182dce9d049d1942967994c2" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values may be calculated, just as some &lt;code&gt;Flags&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">在Windows上,启动Erlang系统进行交互使用的首选方法如下。</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">在Windows上,使用分号作为分隔符。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">在Windows上。</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">在Unix系统中,你可以通过命令行查看手册页面,使用的是</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">在类似Unix的系统上，可以将 &lt;code&gt;ERL_LIBS&lt;/code&gt; 设置为以下内容</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">从概念上讲，使用Erlang ODBC API启动数据库连接是一个基本的客户端服务器应用程序。客户端进程使用API​​来启动管理连接的服务器进程并与之通信。 Erlang ODBC应用程序的策略是，应用程序本身的编程错误将导致连接过程异常终止。（当过程异常终止时，其主管将记录相关的错误报告。）在连接终止期间或之后调用API函数进程，将返回 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 。另一方面，上下文错误不会终止连接，只会将 &lt;code&gt;{error, Reason}&lt;/code&gt; 返回给客户端，其中 &lt;code&gt;Reason&lt;/code&gt; 可能是任何erlang术语。</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">在一个文件中,术语由一个头和一个二进制表示。两个选项定义了文件中术语的格式。</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">在一个单核系统上,或者如果它是一个非重入式扫描器,则会创建一个端口。在多核系统中,如果是重入式扫描器,则会创建多个端口(每个调度器一个)。</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">在使用释放处理的系统上，始终将其设置为 &lt;code&gt;ignore&lt;/code&gt; 。如果失败，请使用 &lt;code&gt;heart&lt;/code&gt; 重新启动服务。</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">在一个没有操作系统单调时间的系统上,Erlang单调时间保证了单调性,但不能给出其他保证。对Erlang单调时间的频率调整取决于所使用的时间扭曲模式。</target>
        </trans-unit>
        <trans-unit id="78bd91cdbb8d95fdca3d6cb73e168bf34bd8e3ca" translate="yes" xml:space="preserve">
          <source>On all platforms that we provide atomic memory operations, this is just a &lt;code&gt;volatile&lt;/code&gt; read, preventing the compiler to use values in registers, forcing the a read from memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">在嵌入式系统上，系统关闭时通常没有电源，甚至没有电池。当系统启动时，此类系统上的系统时钟通常会偏离。如果 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; ，并且在更正OS系统时间之前启动了Erlang运行时系统，则Erlang系统时间可能会长时间，数百年甚至更长的时间是错误的。</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">在嵌入式系统上， &lt;code&gt;erlsrv&lt;/code&gt; 模块将用于将Erlang进程作为Windows系统服务安装。Windows NT启动后，可以启动此服务。</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在应用程序（ &lt;code&gt;app&lt;/code&gt; ）级别，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在应用程序（ &lt;code&gt;escript&lt;/code&gt; ）级别，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">在没有 &lt;code&gt;crypto&lt;/code&gt; ， &lt;code&gt;ssl&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; 的构建中，未定义函数的测试用例失败。验证失败的测试用例日志仅显示对跳过的应用程序的调用。</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">在每个Erlang节点上，可以将一个进程设置为&lt;strong&gt;系统跟踪器&lt;/strong&gt;。每当发送或接收带有跟踪令牌的消息时（如果设置了跟踪令牌标志 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; ），此过程将接收跟踪消息。然后，系统跟踪程序可以打印每个跟踪事件，将其写入文件或任何合适的文件。</target>
        </trans-unit>
        <trans-unit id="91f3ac52e30283e286d347e915ad6557b2459808" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time information with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">在编码时,OctetString()IPv4地址以通常的x.x.x.x格式进行解析,而IPv6地址则以RFC 2373的2.2节 &quot;地址的文本表示 &quot;指定的任何格式进行解析。一个IPv4元组()的长度为4,包含的值类型为0...255。一个IPv6元组()的长度为8,包含类型为0...65535的值。在解码时使用元组表示法。</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">在编码时，可以将OctetString（）指定为iolist（），过大的浮点数（绝对值）等效于 &lt;code&gt;infinity&lt;/code&gt; 或 &lt;code&gt;'-infinity'&lt;/code&gt; 并且过大的整数会导致编码失败。分组的AVP记录如上一节所述。</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">在编码时,端口、传输和协议字段分别默认为3868、sctp和diameter。OctetString值的DiameterURI()的语法是RFC 6733的4.3节中规定的。解码时使用记录表示。</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">在编码时,可以使用 dictionary 的 hrl 文件中定义的宏来指定值。</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">遇到字符＃时， &lt;code&gt;pcre_compile()&lt;/code&gt; 会跳过，在模式中寻找换行符。在此阶段，序列\ n仍为原义，因此不会终止注释。只有代码值为0x0a的字符（默认换行符）才这样做。</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">失败时，即找不到此类环境变量，则返回值&amp;lt; &lt;code&gt;0&lt;/code&gt; 。如果 &lt;code&gt;value&lt;/code&gt; 缓冲区的大小太小，则返回值&amp;gt; &lt;code&gt;0&lt;/code&gt; ，并且已将 &lt;code&gt;*value_size&lt;/code&gt; 设置为所需的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">On gollum:</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">在kosken(Linux/UNIX系统上)。</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">在1-10行中，包含了驱动程序所需的OS标头。由于此驱动程序是为Solaris编写的，因此我们知道头文件 &lt;code&gt;uio.h&lt;/code&gt; 存在。因此，预处理器变量 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 可以之前定义 &lt;code&gt;erl_driver.h&lt;/code&gt; 被包括在线路12的定义 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 将使Erlang的驱动程序队列用于对应于操作系统同上，这是很方便的I / O的载体。</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">在第16-23行声明了不同的回调函数(&quot;正向声明&quot;)。</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">在第4-8行处理端口处于 &lt;code&gt;data&lt;/code&gt; 模式或 &lt;code&gt;intermediate&lt;/code&gt; 模式且其余例程处理不同命令的情况。该例程使用 &lt;code&gt;driver_failure_posix()&lt;/code&gt; 例程报告错误（例如，参见第15行）。请注意，故障例程对 &lt;code&gt;uds_stop&lt;/code&gt; 例程进行了调用，该例程将删除内部端口数据。因此，在 &lt;code&gt;driver_failure&lt;/code&gt; 调用之后，该句柄（以及强制转换的句柄 &lt;code&gt;ud&lt;/code&gt; ）是&lt;strong&gt;无效的指针&lt;/strong&gt;，我们应该&lt;strong&gt;立即返回&lt;/strong&gt;。运行时系统将向所有链接的进程发送退出信号。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">在Linux上，除了 &lt;code&gt;free_memory&lt;/code&gt; 之外，模拟器可用的内存是 &lt;code&gt;cached_memory&lt;/code&gt; 和 &lt;code&gt;buffered_memory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">在许多平台上,操作系统只支持状态码0-255。过大的状态码会通过清除高位截断。</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">在模块（ &lt;code&gt;mod&lt;/code&gt; ）级别上，支持以下选项：</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">在大多数平台上，必须先在套接字上设置此选项，然后才能将其与地址关联。因此，仅在创建套接字时指定它，而在调用包含此描述的函数（ &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; ）时不使用它是合理的。</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">在两个节点中的一个。</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">在具有强制性Unicode文件名的操作系统上，这意味着您可以更轻松地遵循其他（非Erlang）应用程序的文件名。您还可以处理至少在Windows上无法访问的文件名（因为具有无法在ISO Latin-1中表示的名称）。另外，避免在MacOS X上创建难以理解的文件名，因为操作系统的 &lt;code&gt;vfs&lt;/code&gt; 层会接受所有文件名，因为UTF-8不会重写它们。</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">在具有透明命名的操作系统（例如，除MacOS X之外的所有Unix系统）上，如果终端支持UTF-8，则默认值为 &lt;code&gt;utf8&lt;/code&gt; ，否则为 &lt;code&gt;latin1&lt;/code&gt; 。启动 &lt;code&gt;erl&lt;/code&gt; 时，可以使用 &lt;code&gt;+fnl&lt;/code&gt; （强制为 &lt;code&gt;latin1&lt;/code&gt; 模式）或 &lt;code&gt;+fnu&lt;/code&gt; （强制为 &lt;code&gt;utf8&lt;/code&gt; 模式）覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">在具有透明命名的操作系统上，文件的名称可能不一致，例如，某些文件以UTF-8编码，而其他文件则以ISO Latin-1编码。引入了&lt;strong&gt;原始文件名&lt;/strong&gt;的概念，以处理在 &lt;code&gt;utf8&lt;/code&gt; 模式下运行时名称不一致的文件系统。</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">在其他受支持的系统上，请参阅 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; 以了解如何启用HiPE。</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">在支持它的平台上，启用POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 同步I / O标志或它的依赖于平台的等效标志（例如Windows上的 &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; ），以便写入文件块，直到将数据物理写入磁盘为止。但是，请注意，该标志的确切语义因平台而异。例如，Linux或Windows都不保证在调用返回之前也写入所有文件元数据。有关精确的语义，请检查平台文档的详细信息。在不支持POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 或等效版本的平台上，使用 &lt;code&gt;sync&lt;/code&gt; 标志会导致 &lt;code&gt;open&lt;/code&gt; 返回 &lt;code&gt;{error, enotsup}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">在某些操作系统上，当 &lt;code&gt;epmd&lt;/code&gt; 作为守护程序运行时，将使用&lt;strong&gt;syslog&lt;/strong&gt;进行错误报告。要启用错误日志记录，必须编辑/etc/syslog.conf文件并添加一个条目：</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">在某些平台上,如果设置了特定的locales,Perl可能会有奇怪的表现。如果你在编译时出现错误,请尝试设置LANG变量。</target>
        </trans-unit>
        <trans-unit id="c557f429b8f8be575f4e9231e0c0e909cbf4d560" translate="yes" xml:space="preserve">
          <source>On some platforms its &lt;strong&gt;necessary&lt;/strong&gt; to provide the &lt;code&gt;protocol&lt;/code&gt; as its impossible to retrieve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">在某些平台上，此选项唯一允许的值为 &lt;code&gt;true&lt;/code&gt; ，例如OpenBSD和Windows。在这种情况下，尝试在创建套接字时将此选项设置为 &lt;code&gt;false&lt;/code&gt; 会失败。</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">在某些平台上,这个功能可能没有效果。</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">在某些系统上，可能有必要链接更多的库（例如，在Solaris上为 &lt;code&gt;libnsl.a&lt;/code&gt; 和 &lt;code&gt;libsocket.a&lt;/code&gt; ，在Windows上为 &lt;code&gt;wsock32.lib&lt;/code&gt; ）以使用 &lt;code&gt;Erl_Interface&lt;/code&gt; 的通信功能。</target>
        </trans-unit>
        <trans-unit id="d0471b1a417f337e7d9ebce0c70ef9a7679a721c" translate="yes" xml:space="preserve">
          <source>On success a pointer to the process identifier is returned. On failure &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd76559ef60de76711ee9a78bc983a284264cd1" translate="yes" xml:space="preserve">
          <source>On success it should set &lt;code&gt;*ctx&lt;/code&gt; to point to a context for the created socket. This context will be passed to all other socket callbacks. This function will be passed the same &lt;code&gt;setup_context&lt;/code&gt; as passed to the preceeding &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd81851a39ee097fec934afda86c40e9cc8f6b19" translate="yes" xml:space="preserve">
          <source>On success zero is returned. On failure a posix error code is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e61d475574f0ccdd55488d9e0d991962394b15" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*sz&lt;/code&gt; should be set to the handshake packet header size to use. Valid values are &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;. Erlang TCP distribution use a handshake packet size of &lt;code&gt;2&lt;/code&gt; and Erlang TLS distribution use a handshake packet size of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功时，将返回 &lt;code&gt;0&lt;/code&gt; ，并初始化 &lt;code&gt;obuf&lt;/code&gt; 以包含表统计信息，否则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">上的成功， &lt;code&gt;0&lt;/code&gt; 则返回，环境变量的值已经被写入到 &lt;code&gt;value&lt;/code&gt; 缓冲器，和 &lt;code&gt;*value_size&lt;/code&gt; 包含字符串的长度（不包括终止 &lt;code&gt;NULL&lt;/code&gt; 写入的值的字符） &lt;code&gt;value&lt;/code&gt; 缓冲液中。</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功后，用连接客户端的地址和节点名称填充 &lt;code&gt;conp&lt;/code&gt; ，并返回文件描述符。如果失败， &lt;code&gt;ERL_ERROR&lt;/code&gt; 返回和 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">成功时， &lt;code&gt;v&lt;/code&gt; （和 &lt;code&gt;size&lt;/code&gt; 如果对象是二进制）被初始化与相关联的值 &lt;code&gt;key&lt;/code&gt; ，并且该函数返回 &lt;code&gt;EI_INT&lt;/code&gt; ， &lt;code&gt;EI_FLT&lt;/code&gt; ， &lt;code&gt;EI_STR&lt;/code&gt; ，或 &lt;code&gt;EI_BIN&lt;/code&gt; ，指示对象的类型。失败时，返回 &lt;code&gt;-1&lt;/code&gt; ，并且不更新参数。</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">成功后，返回将调用过程连接到EPMD的描述符。失败时，将返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为：</target>
        </trans-unit>
        <trans-unit id="c0dc3f3e2f8d8457d666d03550d6d2ac2fec8095" translate="yes" xml:space="preserve">
          <source>On success, a file descriptor is returned which can be used in a call to &lt;code&gt;ei_accept()&lt;/code&gt;. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">成功时，设置 &lt;code&gt;*key&lt;/code&gt; 和 &lt;code&gt;*value&lt;/code&gt; 并返回 &lt;code&gt;true&lt;/code&gt; 。如果迭代器位于头（在第一个条目之前）或尾（在最后一个条目之后），则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功时，将 &lt;code&gt;*pid&lt;/code&gt; 设置为使用 &lt;code&gt;name&lt;/code&gt; 注册的本地进程，并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 不是注册过程或不是原子，则返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;*pid&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功后，将 &lt;code&gt;*port&lt;/code&gt; 设置为使用 &lt;code&gt;name&lt;/code&gt; 注册的端口，并返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 不是注册的端口或不是原子，则返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;*port&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">成功后，将结果项存储在 &lt;code&gt;*term&lt;/code&gt; 并返回读取的字节数。如果解码失败或 &lt;code&gt;opts&lt;/code&gt; 无效，则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e2b683cb27a455b0e37378b692f0fae65bff5e5" translate="yes" xml:space="preserve">
          <source>On success, the function returns 0, updates the &lt;code&gt;erlang_pid&lt;/code&gt; pointed to by the pid parameter, and the &lt;code&gt;node&lt;/code&gt; parameter is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, a negative number is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功后，该函数将返回 &lt;code&gt;ERL_MSG&lt;/code&gt; ,并且如上所述将 &lt;code&gt;Emsg&lt;/code&gt; 结构或 &lt;code&gt;ERL_TICK&lt;/code&gt; 初始化，在这种情况下，不会返回任何消息。如果失败，该函数返回 &lt;code&gt;ERL_ERROR&lt;/code&gt; 和套 &lt;code&gt;erl_errno&lt;/code&gt; 到之一：</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功时，函数返回 &lt;code&gt;ok&lt;/code&gt; 。失败时，该函数将返回一个不透明的错误，但前面所述的 &lt;code&gt;pending_process&lt;/code&gt; 错误除外。不透明错误将通过 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 函数转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功时，函数返回 &lt;code&gt;ok&lt;/code&gt; 。失败时，返回值为 &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; ，其中 &lt;code&gt;ErrorDesc&lt;/code&gt; 是一个不透明的术语，可以通过 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 函数转换为人类可读的形式。</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功后，函数将返回一个描述符，该描述符将调用过程连接到EPMD。失败时，返回 &lt;code&gt;-1&lt;/code&gt; 并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为 &lt;code&gt;EIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">成功后，该函数将返回一个指向资源类型的指针，并将 &lt;code&gt;*tried&lt;/code&gt; 设置为 &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; 或 &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; 来指示已完成操作。失败时，返回 &lt;code&gt;NULL&lt;/code&gt; 并将 &lt;code&gt;*tried&lt;/code&gt; 设置为 &lt;code&gt;flags&lt;/code&gt; 。它允许设置 &lt;code&gt;tried&lt;/code&gt; 以 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">成功后，该函数将返回一个包含指定名称地址的Erlang pid，并将该节点初始化为找到 &lt;code&gt;name&lt;/code&gt; 的节点名称。失败时，将返回 &lt;code&gt;NULL&lt;/code&gt; ，并且不会修改 &lt;code&gt;node&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">成功后，该函数将返回一个字符串数组，每个字符串包含一个注册的名称，并将 &lt;code&gt;count&lt;/code&gt; 设置为找到的名称数。该数组由单个 &lt;code&gt;NULL&lt;/code&gt; 指针终止。失败时，该函数返回 &lt;code&gt;NULL&lt;/code&gt; ,并且 &lt;code&gt;count&lt;/code&gt; 未修改。</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值，并以 &lt;code&gt;size&lt;/code&gt; 指示其长度。如果找不到该对象或它不是二进制对象，则返回 &lt;code&gt;NULL&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;NULL&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象，或者它不是浮点对象，则返回 &lt;code&gt;-1.0&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;-1.0&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象或它不是字符串，则返回 &lt;code&gt;NULL&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;NULL&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功后，函数将返回与 &lt;code&gt;key&lt;/code&gt; 关联的值。如果找不到该对象或它不是整数对象，则返回 &lt;code&gt;-1&lt;/code&gt; 。为避免带内错误报告出现问题（即，如果您无法区分 &lt;code&gt;-1&lt;/code&gt; 和有效结果），请改用更通用的函数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1519b2c5db86ccdb596ec05a28c63cbcfef77f9b" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; struct is initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">成功后，函数将返回 &lt;code&gt;ERL_MSG&lt;/code&gt; 并初始化 &lt;code&gt;msg&lt;/code&gt; 结构。 &lt;code&gt;erlang_msg&lt;/code&gt; 的定义如下：</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">成功后，将消息放置在指定的缓冲区中，该函数返回实际读取的字节数。如果失败，该函数返回 &lt;code&gt;ERL_ERROR&lt;/code&gt; 并设置 &lt;code&gt;erl_errno&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功后，将消息放置在指定的缓冲区中，该函数返回实际读取的字节数。失败时，该函数将返回负值，并将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为以下值之一：</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功后，将调整注册表大小，重新整理所有内容，并返回 &lt;code&gt;0&lt;/code&gt; 。失败时，注册表保持不变，并返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">在支持OS信号的系统上，也可以通过发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 信号来停止运行时系统并生成故障转储。</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">在&lt;strong&gt;内部表&lt;/strong&gt;标签上，您可以从左侧菜单中选择&lt;strong&gt;哈希表&lt;/strong&gt;，&lt;strong&gt;索引表&lt;/strong&gt;或&lt;strong&gt;内部ETS表&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;Code&lt;/code&gt; 页面上，将显示Erlang源代码。可以向前和向后搜索模块中的文本。在&amp;ldquo; &lt;code&gt;Find&lt;/code&gt; 字段中输入正则表达式，然后按Enter。也可以转到模块中的特定行。&amp;ldquo; &lt;code&gt;Back&lt;/code&gt; 按钮可用于返回到上一个位置。</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">在 &lt;code&gt;erl&lt;/code&gt; 命令行上，您可以指定创建套接字时SSL / TLS分发添加的选项。</target>
        </trans-unit>
        <trans-unit id="6a9c767404e4bacdf3f831aff6d5d541c2d1a85f" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the TLS distribution adds when creating a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">在C端，有必要编写函数，用于从/到Erlang接收和发送带有2个字节长的指示器的数据。默认情况下，C程序将从标准输入（文件描述符0）读取并写入标准输出（文件描述符1）。以下是 &lt;code&gt;read_cmd/1&lt;/code&gt; 和 &lt;code&gt;write_cmd/2&lt;/code&gt; 这样的函数的示例：</target>
        </trans-unit>
        <trans-unit id="b1adca5c0bfea4b4b3f2870a27e174b7d50075f9" translate="yes" xml:space="preserve">
          <source>On the client side the ssl application will save session data to try to automate session reuse on behalf of the client processes on the Erlang node. Note that only verified sessions will be saved for security reasons, that is session resumption relies on the certificate validation to have been run in the original handshake. To minimize memory consumption only unique sessions will be saved unless the special &lt;code&gt;save&lt;/code&gt; value is specified for the following option &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; in which case a full handhake will be performed and that specific session will have been saved before the handshake returns. The session id and even an opaque binary containing the session data can be retrieved using &lt;code&gt;ssl:connection_information/1&lt;/code&gt; function. A saved session (guaranteed by the save option) can be explicitly reused using &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt;. Also it is possible for the client to reuse a session that is not saved by the ssl application using &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">在客户端，函数 &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; 产生一个临时客户端进程，该进程与TFTP守护程序建立联系并执行文件传输。</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">在客户端，回调交互是相同的，但是它的开始和结束有所不同。它从对 &lt;code&gt;prepare/5&lt;/code&gt; 的调用开始，并使用与 &lt;code&gt;open/5&lt;/code&gt; 相同的参数。 &lt;code&gt;prepare/5&lt;/code&gt; 有望验证用户建议的TFTP选项并返回其接受的子集。然后将选项发送到服务器，服务器执行相同的TFTP选项协商过程。服务器接受的选项将转发给客户端的功能 &lt;code&gt;open/5&lt;/code&gt; 。在客户端，函数 &lt;code&gt;open/5&lt;/code&gt; 必须按原样接受所有选项或拒绝传输。然后，回调交互遵循与服务器端相同的模式。当遇到最后一个块时 &lt;code&gt;read/1&lt;/code&gt; 或 &lt;code&gt;write/2&lt;/code&gt; ，将返回的状态转发给用户，并从 &lt;code&gt;read_file&lt;/code&gt; / 3或 &lt;code&gt;write_file/3&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">在客户端，在 &lt;code&gt;open/5&lt;/code&gt; 调用之前要调用 &lt;code&gt;prepare/5&lt;/code&gt; ，所有选项都必须接受或拒绝。</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">在目的端,传输服务等待消息。每条信息通过megaco:receive_message/4回调函数转发给Megaco应用程序。传输服务可以提供或不提供阻断和解除阻断接收传入信息的方法。</target>
        </trans-unit>
        <trans-unit id="8a6a0caacfe77936a01171aa4a2af7bcafb1d066" translate="yes" xml:space="preserve">
          <source>On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; is a list of cons cells and thus requires 24 words. The atom &lt;code&gt;tag&lt;/code&gt; and the integer &lt;code&gt;42&lt;/code&gt; do not require any additional heap memory since it is an &lt;strong&gt;immediate&lt;/strong&gt;. Adding all the terms together, the heap space required in this example should be 33 words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">在库页面上,可以控制工具将使用哪些资源。该页面被组织成一棵树,可以通过点击可扩展/可折叠行开头的小符号进行扩展和折叠。</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">在节点 &lt;code&gt;a@gin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">在节点 &lt;code&gt;b@skeppet&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">在节点 &lt;code&gt;stack&lt;/code&gt; 有一个Erlang节点 &lt;code&gt;ant@stack&lt;/code&gt; ，在外壳中，键入以下内容：</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">在应用程序启动的节点上,有一个事务协调者进程。如果事务是分布式的,那么在需要进行提交工作的所有其他节点上,也有一个事务参与者进程。</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">另一方面值得一提的是,至少所有依赖于非验证算法的密码套件在FIPS模式下会被自动禁用。</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">另一方面:</target>
        </trans-unit>
        <trans-unit id="048ff061e68af3024276eb158992cafe58ebd7ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;move c d&lt;/code&gt; is a single instruction. At runtime, the &lt;code&gt;d&lt;/code&gt; operand will be tested to see whether it refers to an X register or a Y register, and a pointer to the register will be set up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">在接收端,传输模块接收消息并将其转发给协议引擎,协议引擎对消息进行解码,并为每个事务调用用户回调函数。当用户处理完其动作请求后,只需返回一个动作回复列表(或消息错误),协议引擎使用编码模块和传输模块组成消息并转发给发起用户。</target>
        </trans-unit>
        <trans-unit id="823b2c02cd0160bf197b81f01b9301ddf6d5a739" translate="yes" xml:space="preserve">
          <source>On the server side the the &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; option determines if the server will save session data and allow session reuse or not. This can be further customized by the option &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; that may introduce a local policy for session reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">在服务器端，回调交互以具有已注册初始回调状态的 &lt;code&gt;open/5&lt;/code&gt; 调用开始。 &lt;code&gt;open/5&lt;/code&gt; 有望打开（虚拟）文件。然后，每个 &lt;code&gt;read/1&lt;/code&gt; 块重复调用一次read / 1或 &lt;code&gt;write/2&lt;/code&gt; 函数。在每次函数调用时，都将从上一次调用返回的状态获得。遇到最后一个块时，应该使用函数 &lt;code&gt;read/1&lt;/code&gt; 或 &lt;code&gt;write/2&lt;/code&gt; 关闭（虚拟）文件并返回其最后状态。功能 &lt;code&gt;abort/3&lt;/code&gt; 仅在错误情况下使用。在服务器端未使用功能 &lt;code&gt;prepare/5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">在服务器端，没有之前的 &lt;code&gt;prepare/5&lt;/code&gt; 调用，不能添加任何新选项，但是， &lt;code&gt;SuggestedOptions&lt;/code&gt; 中存在的那些选项可以省略，也可以用 &lt;code&gt;AcceptedOptions&lt;/code&gt; 中的新值替换。</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">在系统设置页面上，可以控制一些全局设置，这些设置用作所有应用程序的默认设置。设置 &lt;code&gt;Application inclusion policy&lt;/code&gt; 以 &lt;code&gt;include&lt;/code&gt; 所有未明确排除的应用程序。见 &lt;code&gt;incl_cond&lt;/code&gt; （应用包含）和 &lt;code&gt;mod_cond&lt;/code&gt; （模块包含）在该模块的参考手册 &lt;code&gt;reltool&lt;/code&gt; 获取更多信息。</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">在第三行(或第二行,取决于Emacs指令的存在),可以向仿真器指定参数,例如。</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">超时后，当前测试作业完成后，测试运行将中止。如果提供了 &lt;code&gt;skip_rest&lt;/code&gt; ，则将跳过当前测试作业中的其余测试用例（稍后描述）。</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">在unix上,你可以在emacs中查看手册页面。为了找到手册页面,变量 &quot;erlang-root-dir &quot;应该与包含Erlang安装的目录名绑定。这个名字不应该包括最后的斜杠。实际上,你应该在你的 ~/.emacs 文件中添加一行如下的内容。</target>
        </trans-unit>
        <trans-unit id="f23caa93086babb9143d00576ee2b68575ed59f9" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">一旦返回了 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; ，就可以确保以后不会由于监视程序而将 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 消息放置在呼叫者消息队列中。但是，可以在呼叫之前将 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 消息放置在呼叫者消息队列中。因此，通常建议在停止监视之后从消息队列中删除此类 &lt;code&gt;'DOWN'&lt;/code&gt; 消息。 &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; 可以使用demonitor（MonitorRef，[flush]）代替 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">一旦 &lt;code&gt;unlink(Id)&lt;/code&gt; 返回，就可以确保调用者与 &lt;code&gt;Id&lt;/code&gt; 引用的实体之间的链接将来不会对调用者产生任何影响（除非再次设置链接）。如果呼叫者正在捕获出口，则可以在呼叫之前将链接中的 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 消息放置在呼叫者的消息队列中。</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">创建端口数据锁后，必须在对 &lt;code&gt;port&lt;/code&gt; 的驱动程序队列进行所有操作期间将其锁定。</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">NIF库一旦加载,就会持久存在。它不会被卸载,直到它所属的模块代码版本被清除。</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">读取后,这个文件会产生与下面文本文件相同的配置变量。</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">一旦将CTH安装到某个测试运行中，它将一直保留在那里，直到其作用范围到期为止。CTH的范围取决于安装时间，请参阅下表。功能 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 被称为在范围和函数的开始 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; 被称为范围结束时。</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">解释了适当的模块后，可以在源代码中的相关位置设置断点。断点是基于行指定的。当进程到达断点时，它将停止并等待用户的命令（&lt;strong&gt;Step&lt;/strong&gt;，&lt;strong&gt;Skip&lt;/strong&gt;，&lt;strong&gt;Continue&lt;/strong&gt; ...）。</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">一旦数据被收集到服务器上,它就可以以许多不同的方式进行过滤、分类和打印。</target>
        </trans-unit>
        <trans-unit id="55fa9be76565d3bf8388ee77c4576ca0c50c0cab" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">一旦创建了端口数据锁，就必须在锁定端口数据锁的同时进行对与端口数据锁关联的数据的每次访问。端口数据锁分别由 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; 锁定和解锁。</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">构建系统后，您可能需要更改它。在一个不错的目录中进行测试发布可能会很有用，但您也可以从源代码树中运行Erlang。目标 &lt;code&gt;local_setup&lt;/code&gt; 使得程序 &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; 可用，并且还使用源树中的所有OTP库。</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">一旦启用了锁计数功能的VM，就可以使用模块 &lt;code&gt;lcnt&lt;/code&gt; 。该模块旨在从当前运行的节点外壳中使用。要访问远程节点，请使用 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 和 &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">选择要分析的模块或目录后，单击&amp;ldquo; &lt;strong&gt;运行&amp;rdquo;&lt;/strong&gt;按钮以开始分析。如果出于某种原因要在运行分析时停止分析，请单击&amp;ldquo; &lt;strong&gt;停止&amp;rdquo;&lt;/strong&gt;按钮。</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">一个MIB可以和很多应用进行通信。</target>
        </trans-unit>
        <trans-unit id="ae6ac6f5e1f4c553d516e35fd92ef8609ef86d4a" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">可以通过调用 &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; 来获得 &lt;code&gt;native&lt;/code&gt; 时间单位的近似值。结果等于每秒的完整 &lt;code&gt;native&lt;/code&gt; 时间单位数。如果每秒的 &lt;code&gt;native&lt;/code&gt; 时间单位总数不等于整数，则结果将向下舍入。</target>
        </trans-unit>
        <trans-unit id="ef10c93f15b1c52938ec7e181160a865ba85041c" translate="yes" xml:space="preserve">
          <source>One critical issue to note here is that any term on the young heap can reference terms on the old heap but &lt;strong&gt;no&lt;/strong&gt; term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">每个分配器一个条目。请参阅ERTS中&amp;ldquo;如何解释Erlang故障转储&amp;rdquo;部分中的 &lt;code&gt;Allocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">这方面的一个例子是对传入的数据进行预处理,例如解密分块或收集字符直至换行。</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">一种例外是二进制文件的模式匹配。编译器不会重新排列与二进制文件匹配的子句。将匹配空子句的子句放在&lt;strong&gt;最后&lt;/strong&gt;通常比将其放在&lt;strong&gt;最前面&lt;/strong&gt;要快一些。</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">一个用于有限状态机（类似于 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; ），它要求状态是一个原子，并使用该状态作为当前回调函数的名称</target>
        </trans-unit>
        <trans-unit id="3f8d27506d8e90d0a22e543f80e99c7ae08237b4" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 忽略的一组直接传递给仿真器（ &lt;code&gt;-erl_args&lt;/code&gt; 的仿真器）。</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 将要处理的一组（ &lt;code&gt;-erl_args&lt;/code&gt; 之前的一组）。</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">从文件中返回一行,包括尾部的LF,但用一个LF代替CRLF序列(见上文)。</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">一个日志文件 &lt;code&gt;run_erl.log&lt;/code&gt; ，它记录来自 &lt;code&gt;run_erl&lt;/code&gt; 程序本身的进度和警告。</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">也可以将任意数据转换为XML。所以,比如说它很容易让人读懂。在这种情况下,你首先从你的数据中创建xmerl数据结构,然后将其转换为XML。</target>
        </trans-unit>
        <trans-unit id="ed6a90e414ee1584a7c5f1f7c5472363c8f0e272" translate="yes" xml:space="preserve">
          <source>One must be careful not to create infinite loops. For example, if we for some reason would want to reverse the operand order for the &lt;code&gt;move&lt;/code&gt; instruction, we must not do like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">一个网络RPC(两个消息)来获取写入锁。</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_pattern&lt;/code&gt; 的一个好处是，它允许您显式控制跟踪的详细程度，从而提供了一种非常简单的方法来最大程度地减少生成的跟踪数据。如您所见， &lt;code&gt;et_viewer&lt;/code&gt; 有一个名为 &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; 的滑块，它使您可以控制 &lt;code&gt;Viewer&lt;/code&gt; 中显示的跟踪 &lt;code&gt;Events&lt;/code&gt; 的细节级别。另一方面，如果在 &lt;code&gt;trace_pattern&lt;/code&gt; 中设置较低的详细信息级别，则将永远不会生成许多跟踪数据，因此不会通过套接字将其发送到跟踪客户端，也不会存储在 &lt;code&gt;Collector&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">其中一个 &lt;code&gt;&quot;Error&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; ，或者在一个目前尚不清楚Windows NT版本的情况下 &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8715b5dac001f8acd8e786d5f72ce95270b48d8" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ea7befab7a1376dc38a902be4e17f510f6d524" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_event&lt;/code&gt; 状态。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为 &lt;code&gt;normal&lt;/code&gt; 原子。</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_server&lt;/code&gt; 状态。 &lt;code&gt;Opt&lt;/code&gt; 设置为原子 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 被调用，以获得 &lt;code&gt;gen_statem&lt;/code&gt; 状态。在这种情况下，将 &lt;code&gt;Opt&lt;/code&gt; 设置为 &lt;code&gt;normal&lt;/code&gt; 原子。</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">其中的 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4929df166f7d8de83e743d85b22e80a274c8fcf4" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt; may be &lt;code&gt;undefined&lt;/code&gt; but &lt;strong&gt;not&lt;/strong&gt; both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">UTF编码之一，指定为参数 &lt;code&gt;InEncoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2585f7fa5d9239f75ea13c3267959aa775292560" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of security in SSH is cryptography. The development in crypto analysis is fast, and yesterday's secure algorithms are unsafe today. Therefore some algorithms are no longer enabled by default and that group grows with time. See the &lt;code&gt;SSH (App)&lt;/code&gt; for a list of supported and of disabled algorithms. In the User's Guide the chapter &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; describes the options for enabling or disabling algorithms - &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">内核进程之一无法启动。这可能是由于错误的参数（例如 &lt;code&gt;-config&lt;/code&gt; 参数中的错误）或错误的配置文件。检查所有文件都在正确的位置，并且配置文件（如果有）是否损坏。通常，消息还会被写入控制终端和/或错误日志，以说明错误所在。</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">使用Erlang代替其他功能语言的主要原因之一是Erlang能够处理并发和分布式编程。并发是指可以同时处理多个执行线程的程序。例如，现代操作系统允许您使用同时运行的文字处理器，电子表格，邮件客户端和打印作业。系统中的每个处理器（CPU）可能一次只能处理一个线程（或作业），但是它在作业之间进行交换的速度给人一种使它们同时运行的幻觉。在Erlang程序中创建并行执行线程很容易，并允许这些线程相互通信。在Erlang中，每个执行线程都称为一个&lt;strong&gt;process&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3a03a73b3fd84a50282a6c958644d8dd3d3c26" translate="yes" xml:space="preserve">
          <source>One of the possible &lt;strong&gt;transition actions&lt;/strong&gt; is to postpone the current event. Then it is not retried in the current state. The &lt;code&gt;gen_statem&lt;/code&gt; engine keeps a queue of events divided into the postponed events and the events still to process. After a &lt;strong&gt;state change&lt;/strong&gt; the queue restarts with the postponed events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">您可以指定的一件事是应该在哪里安装Erlang / OTP。默认情况下，Erlang / OTP将安装在 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 中。要保持相同的结构但将其安装在不同的位置，请使用 &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; 这样的 &lt;code&gt;--prefix&lt;/code&gt; 参数： &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">元组之一是 &lt;code&gt;{timeout, GcTime}&lt;/code&gt; ，其中 &lt;code&gt;GcTime&lt;/code&gt; 是垃圾收集的时间，以毫秒为单位。其他元组被标记为 &lt;code&gt;heap_size&lt;/code&gt; ， &lt;code&gt;heap_block_size&lt;/code&gt; ， &lt;code&gt;stack_size&lt;/code&gt; ， &lt;code&gt;mbuf_size&lt;/code&gt; ， &lt;code&gt;old_heap_size&lt;/code&gt; 和 &lt;code&gt;old_heap_block_size&lt;/code&gt; 。在跟踪消息 &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; 的描述中解释了这些元组（请参阅 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; ）。可以添加新的元组，并且&amp;ldquo; &lt;code&gt;Info&lt;/code&gt; 列表中的元组的顺序可以随时更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">这些MIB中总有一个被加载。如果只使用SNMPv1,则加载STANDARD-MIB,否则加载SNMPv2-MIB。</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">有一种选择。</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">一个或多个记录可能已被删除。表 &lt;code&gt;Tab&lt;/code&gt; 具有键&amp;ldquo; &lt;code&gt;Key&lt;/code&gt; 所有记录均已删除。</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">可以在配置文件中描述一个或多个选择性解码功能。使用以下符号。</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">这个函数的一个可能的用途是计算一个文档的固定布局,然后可以将其作为一个更大的文档的一部分。例如:</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">一个进程可以多次阻塞多调度和普通多调度。如果一个进程已经阻塞了多次,它必须在它阻塞的次数完全相同的情况下才会解除对多调度的阻塞。如果一个已阻塞多调度或正常多调度的进程退出,它就会自动解除对多调度和正常多调度的阻塞。</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">使用此功能的一个原因是，当您拥有一个状态项时，该状态项在更改后应取消 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; ，或者与延迟事件结合使用而影响事件处理。我们将采用后者，并通过引入可配置的锁定按钮（这是所讨论的状态项）使前一个示例复杂化，该按钮在 &lt;code&gt;open&lt;/code&gt; 状态下会立即锁定门，并提供API函数 &lt;code&gt;set_lock_button/1&lt;/code&gt; 来设置锁定按钮。</target>
        </trans-unit>
        <trans-unit id="f23d4aa95b25f50a19f9b6b4374f1b88dac66685" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">一个微小的区别是，如果 &lt;code&gt;L&lt;/code&gt; 是不正确的列表，则 &lt;code&gt;length(L)&lt;/code&gt; 失败，而第二个代码片段中的模式接受不正确的列表。</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">解决此问题的一种方法是使snmp应用程序成为分布式Erlang应用程序，这意味着可以将代理配置为在多个节点之一上运行。如果运行该节点的节点出现故障，则另一个节点将重新启动代理。这称为&lt;strong&gt;故障转移&lt;/strong&gt;。当节点再次启动时，它可以&lt;strong&gt;接管&lt;/strong&gt;应用程序。该问题的解决方案增加了另一个问题。通常，新节点的IP地址不同于第一个IP地址，这可能会导致SNMP管理器与代理之间的通信出现问题。</target>
        </trans-unit>
        <trans-unit id="4512e5220c29e6a7833a429e6e4b986d799dd593" translate="yes" xml:space="preserve">
          <source>One such debug functionality is the &lt;strong&gt;lock checker&lt;/strong&gt;, which can detect locking order violations and thereby potential deadlock bugs. For the lock checker to work the &lt;code&gt;name&lt;/code&gt; should be on the format &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; or &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt;, where App is the name of the application, Type is the name of the lock type and Instance is optional information about each lock instance. &quot;App.Type&quot; should be a unique name for the lock checker to detect lock order violations between locks of different types. The Instance information is currently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de0b12460a91c3f5fd94e39bda2873b3f5b7b16" translate="yes" xml:space="preserve">
          <source>One that allows the state to be any term and that uses one callback function for all states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">这个函数的一个用途是返回紧凑的替代状态表示,以避免在日志文件中打印大的状态项。另一个用途是隐藏敏感数据,避免被写入错误日志。</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">这个函数的一个用途是返回紧凑的替代状态表示,以避免大的状态项被打印在日志文件中。</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">存在一个有效的事件 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1de3f4f0701ff8998dbe849ff16761b4287d4cb" translate="yes" xml:space="preserve">
          <source>One way to handle this is to use the &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; function (&lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt;) to signal that no more data is to be sent and then wait for the read side of the socket to be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dac560fa843dd6f0f972d52ed8040ce20cb74d" translate="yes" xml:space="preserve">
          <source>One way to reduce the risk of intrusion is to not convey which software and which version the intruder is connected to. This limits the risk of an intruder exploiting known faults or peculiarities learned by reading the public code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">一个不限制状态数据类型,对所有状态使用一个回调函数。</target>
        </trans-unit>
        <trans-unit id="125ef9e0e55df17c031033b5d420b053905b830e" translate="yes" xml:space="preserve">
          <source>Online Help</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">在线支持 &lt;code&gt;release_handler&lt;/code&gt; 用于解包和安装发行包</target>
        </trans-unit>
        <trans-unit id="ae87ac2b337c683a338363cdb6dd6e6e3a876d81" translate="yes" xml:space="preserve">
          <source>Only a subset is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">在运行时只能更改所有 &lt;code&gt;erts_alloc&lt;/code&gt; 标志的子集。该子集当前仅是标志 &lt;code&gt;sbct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">上面只展示了函数子句的一个子集。输入参数的全部有效组合如下。</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">只返回除默认值以外的实际参数,例如不返回为配置参数指定其他来源的指令,也不返回清除参数的指令。</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">仅在 &lt;code&gt;if&lt;/code&gt; 或另一个 &lt;code&gt;elif&lt;/code&gt; 指令之后才允许。如果前面的 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;elif&lt;/code&gt; 指令的求值不为true，而 &lt;code&gt;Condition&lt;/code&gt; 的求值为true，则代之以计算 &lt;code&gt;elif&lt;/code&gt; 之后的行。</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">仅在 &lt;code&gt;ifdef&lt;/code&gt; 或 &lt;code&gt;ifndef&lt;/code&gt; 指令之后才允许。如果该条件为假，则将评估 &lt;code&gt;else&lt;/code&gt; 后面的行。</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">只允许用于面向连接的插座。</target>
        </trans-unit>
        <trans-unit id="b872c6846f1badf545548103fe27329f7bb9d68b" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; emulator option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">默认情况下，仅标记由NIF和驱动程序生成的二进制文件和分配，但是可以使用 &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; 仿真器选项在每个分配器的基础上进行配置。</target>
        </trans-unit>
        <trans-unit id="3f8fcfa18b8b4298ae4d967d6d04b8aabbe6553a" translate="yes" xml:space="preserve">
          <source>Only exceptions occurring during the evaluation of &lt;code&gt;Exprs&lt;/code&gt; can be caught by the &lt;code&gt;catch&lt;/code&gt; section. Exceptions occurring in a &lt;code&gt;Body&lt;/code&gt; or due to a failed match are not caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">只使用明确的连接设置。</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">只有正好是这些扩展名的文件才会被压缩。</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">仅当执行Shell脚本或 &lt;code&gt;.bat&lt;/code&gt; 文件时，才隐式调用相应的命令解释器，但仍然没有命令参数扩展或隐式 &lt;code&gt;PATH&lt;/code&gt; 搜索。</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">仅当字符串的代码点&amp;lt;256以下时，才可以使用 &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; 将其直接转换为二进制，或者可以直接将其发送到端口。如果字符串包含大于255的Unicode字符，则必须确定编码，然后使用 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 将字符串转换为首选编码形式的二进制。字符串通常不是字节列表，就像在Erlang / OTP R13之前一样，它们是字符列表。字符通常不是字节，它们是Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">只有当服务器处于确认提交阶段时,才会将配置恢复到进入确认提交阶段前的状态。否则,不会进行配置回滚。</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">仅当类型为 &lt;code&gt;integer&lt;/code&gt; 时才匹配。默认值为 &lt;code&gt;unsigned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">只有使用选项 &lt;code&gt;debug_info&lt;/code&gt; 设置编译的模块才能解释。不可解释的模块显示在&amp;ldquo;解释模块&amp;rdquo;窗口的括号内。</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">仅在64位半字模拟器上。尽管系统可以拥有更多的内存，但在不足4 GB的低内存区域中分配的内存总量。</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">只能指定一个 &lt;code&gt;MonitorOption&lt;/code&gt; 。它是以下之一：</target>
        </trans-unit>
        <trans-unit id="16b381e1eb19d06546da0fffa061890639f875ed" translate="yes" xml:space="preserve">
          <source>Only one byte long and only two bits are significant, the rest must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1021bb495145f4a605a8bf15b6c7510ce41d42c" translate="yes" xml:space="preserve">
          <source>Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">这种类型的条目只允许一个。</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 只能加载一个表。由于已提交的事务可能导致多个表中的更新，因此，由于强制负载，这些表可能会变得不一致。</target>
        </trans-unit>
        <trans-unit id="203a271e69e1e6f8cf93e61cb78904664002dc4b" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">此处仅提供了一些默认值。有关当前使用的设置和分配器的当前状态的信息，请参见 &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; 和 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17e89dc2513b107dcc6a0275a1a3c98d68b4387b" translate="yes" xml:space="preserve">
          <source>Only support running Cover on the local node. This function must be called before any modules have been compiled or any nodes added. When running in this mode, modules will be Cover compiled in a more efficient way, but the resulting code will only work on the same node they were compiled on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">仅当ERTS使用zlib&amp;gt; = 1.2.8编译时才受支持。</target>
        </trans-unit>
        <trans-unit id="e0c3b6c96d4a056b1891213af8fe63652b6f147a" translate="yes" xml:space="preserve">
          <source>Only supported when the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; has been passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">只有DEFLATE(zlib压缩)和STORE(未压缩数据)zip方法被支持。</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">只有打开该文件的Erlang进程才能使用它。</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">只有当前连接的作业才能与shell &quot;对话&quot;。</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">只有第一个捕获的子模式,它总是主体的完整匹配部分。所有明确捕获的子模式都会被丢弃。</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">在字符类中只识别以下元字符。</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">只有所有者进程才能对表进行读写。</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">除非已使用 &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; 注册了备用输入处理程序进程，否则仅允许注册为 &lt;code&gt;DHandle&lt;/code&gt; 标识的分发通道的分发控制器的进程调用此函数。如果已经注册了备用输入处理程序，则仅允许已注册的输入处理程序进程调用此函数。</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">仅注册为 &lt;code&gt;DHandle&lt;/code&gt; 标识的分发通道的分发控制器的进程才能调用此函数。</target>
        </trans-unit>
        <trans-unit id="97a2d2b2787c40ce488cca6bc1ab1989c6ad75b7" translate="yes" xml:space="preserve">
          <source>Only the process that created the digraph is allowed to update it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">仅搜索指定的部分。返回值相对于 &lt;code&gt;Subject&lt;/code&gt; 的开始还有偏移量。如本手册的&amp;ldquo;数据类型&amp;rdquo;部分所述，允许为负的 &lt;code&gt;Length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">仅识别这些确切的字符序列。诸如[a [：&amp;lt;：] b]之类的序列会为无法识别的POSIX类名引发错误。此支持与Perl不兼容。提供它是为了帮助从其他环境迁移，最好不要在任何新模式中使用。请注意，\ b在单词的开头和结尾匹配（请参见上面的&amp;ldquo;简单断言&amp;rdquo;），并且在Perl样式的模式中，前一个或后一个字符通常会显示所需的字符，而无需使用所使用的断言为了准确给出POSIX行为。</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">只有总数</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">仅跟踪来自特定进程 &lt;code&gt;Pid&lt;/code&gt; 的消息：</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">只跟踪其他节点的消息。</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">仅跟踪与 &lt;code&gt;{reply, _}&lt;/code&gt; 相匹配的消息：</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">只跟踪发送到其他节点的消息。</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">只跟踪发送到发送者本身的消息。</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">仅将消息跟踪到特定进程 &lt;code&gt;Pid&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">只有两个参数，其中一个必须为 &lt;code&gt;true&lt;/code&gt; ，另一个为 &lt;code&gt;false&lt;/code&gt; 以返回 &lt;code&gt;true&lt;/code&gt; ；否则， &lt;code&gt;'xor'&lt;/code&gt; 返回false。</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">只有在确定自己在做什么的情况下才能使用这些标志。不合适的设置会导致严重的性能下降,甚至在操作过程中随时出现系统崩溃。</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">只在握手阶段使用。</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。它允许生成的（Unix）进程的标准输入和输出（文件描述符0和1）与Erlang通信。</target>
        </trans-unit>
        <trans-unit id="18c2212e127b0c910798dbbf1d59d9d69e12fd4b" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The external program starts using &lt;code&gt;Dir&lt;/code&gt; as its working directory. &lt;code&gt;Dir&lt;/code&gt; must be a string.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。外部程序开始使用 &lt;code&gt;Dir&lt;/code&gt; 作为其工作目录。 &lt;code&gt;Dir&lt;/code&gt; 必须是字符串。</target>
        </trans-unit>
        <trans-unit id="65484a01cf9bd6e1a83ae6b606310e1c69ff32cf" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The environment of the started process is extended using the environment specifications in &lt;code&gt;Env&lt;/code&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 。使用 &lt;code&gt;Env&lt;/code&gt; 中的环境规范扩展了启动过程的环境。</target>
        </trans-unit>
        <trans-unit id="bfc9b2e1dea6a04ba983a9e94d3b648b00ca026f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, where &lt;code&gt;Command&lt;/code&gt; refers to an external program, and for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn, Command}&lt;/code&gt; 和 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，在此 &lt;code&gt;Command&lt;/code&gt; 指的是外部程序。</target>
        </trans-unit>
        <trans-unit id="ec0538decd2a683ac3d4fc85b7551d506a0ba696" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，并在运行可执行文件时显式指定程序名称参数。在某些操作系统上，这在某些情况下可能是理想的。程序对此的响应方式高度依赖于系统，并且无法保证特定的效果。</target>
        </trans-unit>
        <trans-unit id="94d77dba770e4fddcd3e5b235704abc55a41a06f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</source>
          <target state="translated">仅对 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 有效，并指定可执行文件的参数。每个参数都指定为单独的字符串，并且（在Unix上）最终以参数向量中的每个元素结尾。在其他平台上，类似的行为被模仿。</target>
        </trans-unit>
        <trans-unit id="0a16a27763d86648c52acb4eb9a028a14f39f822" translate="yes" xml:space="preserve">
          <source>Only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">仅对Unix上的字符设备有效。在所有其他情况下,该字段为零。</target>
        </trans-unit>
        <trans-unit id="7fc2cb0a3d19c899c55c3af5cabac685a4c4024f" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt; bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb3f031c9ac0eb9d790e14595d3fd9dd2d8d7c2" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="44042d084e920dd3dc985ac504cefdc2ed892dbe" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt; match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a550d32afdec41a5ce24c62d98873272eb328a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="2e13e6d3aa42a811de64c1e467938899f3dce98a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296b6181394c8bc2ef4aa069b7cdea56b08954fb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="9a762205d0a7ee19acfd273d7e78b6398592b6bb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt; select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97c71bb917f1db11558c4c9a89e12c4b7ed4b54" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt; select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfa868a6d8928ac7bb58be05cada3f714825ced" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="403f4b382799774e589923264bc2680b24377bd7" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 使用的不透明延续。</target>
        </trans-unit>
        <trans-unit id="0fd3a4cc67ebb2e2dcfc37bc089269155adc35e9" translate="yes" xml:space="preserve">
          <source>Opaque data type containing a compiled regular expression. &lt;code&gt;mp()&lt;/code&gt; is guaranteed to be a tuple() having the atom &lt;code&gt;re_pattern&lt;/code&gt; as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.</source>
          <target state="translated">包含已编译正则表达式的不透明数据类型。保证 &lt;code&gt;mp()&lt;/code&gt; 是具有原子 &lt;code&gt;re_pattern&lt;/code&gt; 作为其第一个元素的tuple（），以允许在防护中进行匹配。元组的大小或其他字段的内容可能会在将来的Erlang / OTP版本中更改。</target>
        </trans-unit>
        <trans-unit id="3073e10d40e31139c377d2037ae18a50d90f1eba" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a C-node. A &lt;code&gt;ei_cnode&lt;/code&gt; structure is initialized by calling &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23206d19a217e18d8ba3621938088efa39a69154" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a channel inside a connection.</source>
          <target state="translated">代表连接内通道的不透明数据类型。</target>
        </trans-unit>
        <trans-unit id="10ef7cb1f64bbdc10f27d8dc1ce5e8006717e4e1" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a compiled search pattern. Guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">表示已编译搜索模式的不透明数据类型。保证是 &lt;code&gt;tuple()&lt;/code&gt; ,以使程序可以将其与非预编译的搜索模式区分开。</target>
        </trans-unit>
        <trans-unit id="11a89fac909edd47d58426bf26b171a05bcc5425" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a connection between a client and a server (daemon).</source>
          <target state="translated">不透明的数据类型,代表客户端和服务器(守护进程)之间的连接。</target>
        </trans-unit>
        <trans-unit id="620b0b7f87aa05da3ff0439d717021eb8fe8e602" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a daemon.</source>
          <target state="translated">代表守护进程的不透明数据类型。</target>
        </trans-unit>
        <trans-unit id="782b9c52a05275a07fdb0325126b76a41e598067" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4927f104d4050e4e82f5e9b926c4785a9a6cd617" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang port identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b351d1987076f1dc291eddcbafd24ab67c9d0ca9" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang process identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb071ca2ae242d99f495914ddf8221680ce181d" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e1f3ab4b5c65c16968a9846c8960065afe6262" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang sequential trace token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3857ec812333e693713ca05fedf452c8c2760e48" translate="yes" xml:space="preserve">
          <source>Opaque reference for a connection to a NETCONF server or a NETCONF session.</source>
          <target state="translated">连接到NETCONF服务器或NETCONF会话的不透明参考。</target>
        </trans-unit>
        <trans-unit id="1ad02c5216bfba2278b495045671c8cc585c4d19" translate="yes" xml:space="preserve">
          <source>Opaque send handle whose contents is internal for the send module. May be any term.</source>
          <target state="translated">不透明的发送句柄,其内容是发送模块的内部内容。可以是任何术语。</target>
        </trans-unit>
        <trans-unit id="107ba6e41ccc6092a0776c13b1c83f0f2e14171a" translate="yes" xml:space="preserve">
          <source>Opaque types that define experimental options that are not to be used in products.</source>
          <target state="translated">不透明类型,定义了不在产品中使用的实验选项。</target>
        </trans-unit>
        <trans-unit id="7587b20d7be0af5fefb7a8ee2c09b36a8bb78350" translate="yes" xml:space="preserve">
          <source>Opaque value returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3550457d3cea02f68e91830d6b92589beceb0ac2" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) is a Microsoft standard for accessing relational databases that has become widely used. The ODBC standard provides a c-level application programming interface (API) for database access. It uses Structured Query Language (SQL) as its database access language.</source>
          <target state="translated">开放式数据库连接(ODBC)是微软公司的一个访问关系型数据库的标准,已经被广泛使用。ODBC标准提供了一个用于数据库访问的c级应用程序接口(API),它使用结构化查询语言(SQL)作为数据库访问语言。它使用结构化查询语言(SQL)作为其数据库访问语言。</target>
        </trans-unit>
        <trans-unit id="8082c8186bf5acfdb929e31ffd3d59546e0c666b" translate="yes" xml:space="preserve">
          <source>Open an SSH connection to a named NETCONF server.</source>
          <target state="translated">打开一个与命名的NETCONF服务器的SSH连接。</target>
        </trans-unit>
        <trans-unit id="ee2771cae64f2d66b96c7d0fdeb3a995d3b00a84" translate="yes" xml:space="preserve">
          <source>Open files and sockets</source>
          <target state="translated">打开文件和插座</target>
        </trans-unit>
        <trans-unit id="c2f3ad251a3411a0d3096b7d62ceb15282d3c92b" translate="yes" xml:space="preserve">
          <source>Open ports</source>
          <target state="translated">开放端口</target>
        </trans-unit>
        <trans-unit id="d5d9049df9a69941f4ebda406f0f9058d7b67428" translate="yes" xml:space="preserve">
          <source>Open punctuation</source>
          <target state="translated">开放式标点符号</target>
        </trans-unit>
        <trans-unit id="01b42cf5dcb6fdd0a783f67c992975adaac86c1d" translate="yes" xml:space="preserve">
          <source>OpenSSH Public-Key Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f83435c5ff89a01a4392cfcdc0fce03d20e7bcf" translate="yes" xml:space="preserve">
          <source>OpenSSH public-key format looks as follows:</source>
          <target state="translated">OpenSSH公钥格式如下。</target>
        </trans-unit>
        <trans-unit id="3962fc8d7cfd8504f9f8a80c8b447972c82afbc5" translate="yes" xml:space="preserve">
          <source>OpenSSL (optional) You need this to build crypto, ssh and ssl libs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a8e32789179af6e9a1ec19eccc362f6f09476e" translate="yes" xml:space="preserve">
          <source>OpenSSL -- The opensource toolkit for Secure Socket Layer and Transport Layer Security. Required for building the application &lt;code&gt;crypto&lt;/code&gt;. Further, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; require a working crypto application and will also be skipped if OpenSSL is missing. The &lt;code&gt;public_key&lt;/code&gt; application is available without &lt;code&gt;crypto&lt;/code&gt;, but the functionality will be very limited.</source>
          <target state="translated">OpenSSL-用于安全套接字层和传输层安全性的开源工具包 构建应用程序 &lt;code&gt;crypto&lt;/code&gt; 需要。此外， &lt;code&gt;ssl&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; 需要有效的加密应用程序，如果缺少OpenSSL，也会被跳过。无需 &lt;code&gt;crypto&lt;/code&gt; 即可使用 &lt;code&gt;public_key&lt;/code&gt; 应用程序，但功能将非常有限。</target>
        </trans-unit>
        <trans-unit id="f9ba88f6151c1d4c39311034d5740f6813c1bb3d" translate="yes" xml:space="preserve">
          <source>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</source>
          <target state="translated">OpenSSL可以被构建为提供FIPS 140-2验证的加密服务。经过验证的不是OpenSSL应用程序,而是一个特殊的软件组件,称为OpenSSL FIPS对象模块。然而应用程序并不直接使用这个对象模块,而是通过OpenSSL库的常规API来使用。</target>
        </trans-unit>
        <trans-unit id="ec75c958bae528f688b7acd8013d185972516f61" translate="yes" xml:space="preserve">
          <source>OpenSSL exposes an Engine API, which makes it possible to plug in alternative implementations for some or all of the cryptographic operations implemented by OpenSSL. When configured appropriately, OpenSSL calls the engine's implementation of these operations instead of its own.</source>
          <target state="translated">OpenSSL公开了一个引擎API,这使得它可以为OpenSSL实现的部分或全部加密操作插入替代实现。当配置得当时,OpenSSL会调用引擎对这些操作的实现,而不是它自己的实现。</target>
        </trans-unit>
        <trans-unit id="23dcb6e17a0724721b52791ead27b1179856c026" translate="yes" xml:space="preserve">
          <source>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</source>
          <target state="translated">OpenSSL在FIPS模式下可以处理这些角落的情况,但是Erlang的加密和ssl应用并没有为这些情况做好准备,因此你只能在FIPS模式下使用TLS 1.2。</target>
        </trans-unit>
        <trans-unit id="3a24b8124364457504f3d77d3e37c9aa2f092c8b" translate="yes" xml:space="preserve">
          <source>OpenSSL. This is if you want the SSL and crypto applications to compile (and run). There are prebuilt binaries, which you can just download and install, available here:</source>
          <target state="translated">OpenSSL。如果你想让SSL和加密应用程序编译(和运行),就需要这样做。这里有预制的二进制文件,你可以直接下载并安装。</target>
        </trans-unit>
        <trans-unit id="fc37c058118702102358b15e5a9279ede7fb88f0" translate="yes" xml:space="preserve">
          <source>OpenSource users can ask questions and share experiences on the &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt; Erlang questions mailing list&lt;/a&gt;.</source>
          <target state="translated">OpenSource用户可以在&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;Erlang问题邮件列表中&lt;/a&gt;提出问题并分享经验。</target>
        </trans-unit>
        <trans-unit id="9f59aad599af06a50017bc066f13ce93de0675e4" translate="yes" xml:space="preserve">
          <source>Opening a connection to the SUT</source>
          <target state="translated">打开与SUT的连接</target>
        </trans-unit>
        <trans-unit id="16d19c8e7f51506cd01c5e4f542d05b716cdf852" translate="yes" xml:space="preserve">
          <source>Opening files with option &lt;code&gt;encoding&lt;/code&gt; is convenient when writing or reading text files in a known encoding.</source>
          <target state="translated">使用已知编码写入或读取文本文件时，使用选项 &lt;code&gt;encoding&lt;/code&gt; 打开文件很方便。</target>
        </trans-unit>
        <trans-unit id="67011158e86d9fe5da95333d965bcbbe99127074" translate="yes" xml:space="preserve">
          <source>Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</source>
          <target state="translated">开头的小括号从左到右(从1开始)数,得到捕捉子模式的编号。例如,如果将字符串 &quot;红王 &quot;与下面的模式进行匹配,则捕获的子串分别为 &quot;红王&quot;、&quot;红&quot;、&quot;王&quot;,并分别编号为1、2、3。</target>
        </trans-unit>
        <trans-unit id="75588bb57f0a2ad5ebe6ca42cc40d8c3b6d3dc26" translate="yes" xml:space="preserve">
          <source>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</source>
          <target state="translated">开头的方括号(只有当它可以被解释为引入一个Posix类名时,或者是为了一个特殊的兼容性功能,见下两节)</target>
        </trans-unit>
        <trans-unit id="0a4914a57f284d13929c087c4e60d213c9577e76" translate="yes" xml:space="preserve">
          <source>Opens (creates) a registry, which initially is empty. To close the registry later, use &lt;code&gt;ei_reg_close()&lt;/code&gt;.</source>
          <target state="translated">打开（创建）注册表，该注册表最初为空。要稍后关闭注册表，请使用 &lt;code&gt;ei_reg_close()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b46d26782974b469a2ae782f58aa207429f253c" translate="yes" xml:space="preserve">
          <source>Opens a &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;, displaying the contents of the selected module.</source>
          <target state="translated">打开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; ，显示所选模块的内容。</target>
        </trans-unit>
        <trans-unit id="22a4c7bdc761516d54977e6e3c2f08e31666a769" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">打开NETCONF会话并交换 &lt;code&gt;hello&lt;/code&gt; 消息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
