<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="f82ed6c2be9cde928b716896e0b7750e4269ef66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_server&lt;/code&gt; process handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">甲 &lt;code&gt;gen_server&lt;/code&gt; 如在描述的过程处理系统消息 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 。所述 &lt;code&gt;sys&lt;/code&gt; 模块可用于调试 &lt;code&gt;gen_server&lt;/code&gt; 过程。</target>
        </trans-unit>
        <trans-unit id="9183aff59e51eee9e3ac3b923db0e1df5aa748f5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</source>
          <target state="translated">甲 &lt;code&gt;gen_statem&lt;/code&gt; 假定所有特定部分以位于一个回调模块导出预定的一组功能英寸 行为函数和回调函数之间的关系如下：</target>
        </trans-unit>
        <trans-unit id="c088e6c3ad593b97e2719e3a7f2ef3d25643973c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gen_statem&lt;/code&gt; handles system messages as described in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;sys&lt;/code&gt; module can be used for debugging a &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;gen_statem&lt;/code&gt; 中所述处理系统消息 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;sys&lt;/code&gt; 模块可用于调试 &lt;code&gt;gen_statem&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb679bbc4a894da7c683af08fece335a0b2f7f3a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;host&lt;/code&gt; filter is not typically desirable when setting Destination-Host since it will remove peer agents from the candidates list.</source>
          <target state="translated">设置目标主机时，通常不希望使用 &lt;code&gt;host&lt;/code&gt; 过滤器，因为它将从候选列表中删除对等代理。</target>
        </trans-unit>
        <trans-unit id="3136f605b2f92ac3277fb1aa4fb5ac14a0ceaca5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;list&lt;/code&gt; ，默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="687a85ac1691431ae16424f09a8711efd93e00b8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt;, defaults to [].</source>
          <target state="translated">甲 &lt;code&gt;list&lt;/code&gt; ，默认为[]。</target>
        </trans-unit>
        <trans-unit id="8945c1936d6e5ae6093c7d0fe2fcd18eac87d001" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;message_error()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">甲 &lt;code&gt;message_error()&lt;/code&gt; ，指示远程用户已与显式transactionError回答。</target>
        </trans-unit>
        <trans-unit id="e9dc2723fde49808f2786f42dd59628134c7bdff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;nowarn_xxx&lt;/code&gt; form, to turn off the warning.</source>
          <target state="translated">一个 &lt;code&gt;nowarn_xxx&lt;/code&gt; 形式，关闭警告。</target>
        </trans-unit>
        <trans-unit id="c1871757dec2ac832830f5a635684899bd5b3db1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;permanent&lt;/code&gt; child process is always restarted.</source>
          <target state="translated">一个 &lt;code&gt;permanent&lt;/code&gt; 子进程总是会重启。</target>
        </trans-unit>
        <trans-unit id="adff669099f0ada70cada77f613b34ae862107ab" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor by name resolves the &lt;code&gt;RegisteredName&lt;/code&gt; to &lt;code&gt;pid()&lt;/code&gt; or &lt;code&gt;port()&lt;/code&gt; only once at the moment of monitor instantiation, later changes to the name registration will not affect the existing monitor.</source>
          <target state="translated">甲 &lt;code&gt;process&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 通过名称监视器解析 &lt;code&gt;RegisteredName&lt;/code&gt; 到 &lt;code&gt;pid()&lt;/code&gt; 或 &lt;code&gt;port()&lt;/code&gt; 只在显示器实例的时刻一次，以后改变为名称注册不会影响现有的显示器。</target>
        </trans-unit>
        <trans-unit id="b4a4e8cecf512f5c76654bdb793223d7fff4380d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered only once, after that it is removed from both monitoring process and the monitored entity. Monitors are fired when the monitored process or port terminates, does not exist at the moment of creation, or if the connection to it is lost. If the connection to it is lost, we do not know if it still exists. The monitoring is also turned off when &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">一个 &lt;code&gt;process&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 监视器被触发一次，它从两个监控过程和监控实体消除后。当受监视的进程或端口终止，在创建时不存在或与其失去连接时，将触发监视器。如果与它的连接丢失，我们不知道它是否仍然存在。调用 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 时，监视也会关闭。</target>
        </trans-unit>
        <trans-unit id="faabc209db7c57f4dac9a885c73eaefbaad312f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in a test case information function</source>
          <target state="translated">一个 &lt;code&gt;require&lt;/code&gt; 在测试情况信息功能的语句</target>
        </trans-unit>
        <trans-unit id="84c08b930b637efc74e4be68d8d836d66a78b1ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the suite information function (&lt;code&gt;suite/0&lt;/code&gt;)</source>
          <target state="translated">一个 &lt;code&gt;require&lt;/code&gt; 在浴室的信息函数语句（ &lt;code&gt;suite/0&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c43c43f9ed4d600c7d71b45d8ac9c7203e0f6da6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;require&lt;/code&gt; statement in the test suite information case or test case information-list is to look like &lt;code&gt;{require,CfgVarName}&lt;/code&gt; or &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt;. The arguments &lt;code&gt;AliasName&lt;/code&gt; and &lt;code&gt;CfgVarName&lt;/code&gt; are the same as the arguments to &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;AliasName&lt;/code&gt; becomes an alias for the configuration variable, and can be used as reference to the configuration data value. The configuration variable can be associated with any number of alias names, but each name must be unique within the same test suite. The two main uses for alias names follows:</source>
          <target state="translated">一个 &lt;code&gt;require&lt;/code&gt; 在测试套件告知情况或测试实例信息列表语句看起来像 &lt;code&gt;{require,CfgVarName}&lt;/code&gt; 或 &lt;code&gt;{require,AliasName,CfgVarName}&lt;/code&gt; 。的参数 &lt;code&gt;AliasName&lt;/code&gt; 和 &lt;code&gt;CfgVarName&lt;/code&gt; 是相同的参数 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;AliasName&lt;/code&gt; 成为配置变量的别名，并且可以用作对配置数据值的引用。该配置变量可以与任意数量的别名关联，但是每个名称在同一测试套件中必须唯一。别名的两个主要用途如下：</target>
        </trans-unit>
        <trans-unit id="5ff9958a6d15c210b3259bc6e40de68c3b9fa571" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;resend_indication()&lt;/code&gt;, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;resend_indication()&lt;/code&gt; ，默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0153a022671e7ff3f8f28950553457e8d9526f45" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;scanner&lt;/code&gt; to pre-process the text (program, etc.) to be parsed is not provided in the &lt;code&gt;yecc&lt;/code&gt; module. The scanner serves as a kind of lexicon look-up routine. It is possible to write a grammar that uses only character tokens as terminal symbols, thereby eliminating the need for a scanner, but this would make the parser larger and slower.</source>
          <target state="translated">&lt;code&gt;yecc&lt;/code&gt; 模块中未提供用于预处理要解析的文本（程序等）的 &lt;code&gt;scanner&lt;/code&gt; 。扫描仪用作一种词典查询例程。可以编写仅使用字符令牌作为终端符号的语法，从而消除了对扫描仪的需求，但这会使解析器更大，更慢。</target>
        </trans-unit>
        <trans-unit id="87ac317ef6fe7f30b73d95244c9d1336c4280f0e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;segment_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError for this segment. This is of course only possible if the reply was segmented.</source>
          <target state="translated">甲 &lt;code&gt;segment_reason()&lt;/code&gt; ，指示远程用户已与该段的显式transactionError回答。当然，这仅在答复被分段的情况下才可能。</target>
        </trans-unit>
        <trans-unit id="b6458c8e12fe0d6e7fcbb7cf092bd2f54ade6bdd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_error()&lt;/code&gt;, indicates that the send function of the megaco transport callback module failed to send the request. There are two separate cases: &lt;code&gt;send_cancelled_reason()&lt;/code&gt; and &lt;code&gt;send_failed_reason()&lt;/code&gt;. The first is the result of the send function returning &lt;code&gt;{cancel, Reason}&lt;/code&gt; and the second is some other kind of erroneous return value. See the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function for more info.</source>
          <target state="translated">甲 &lt;code&gt;send_error()&lt;/code&gt; ，表示该MEGACO传输回调模块的发送功能未能发送该请求。有两种不同的情况： &lt;code&gt;send_cancelled_reason()&lt;/code&gt; 和 &lt;code&gt;send_failed_reason()&lt;/code&gt; 。第一个是send函数返回 &lt;code&gt;{cancel, Reason}&lt;/code&gt; ，第二个是其他某种错误的返回值。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="2afcbf56605493e5cb096c43726f60e7b25a7e6c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;send_reason()&lt;/code&gt;, indicates that the transport module &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function did not send the message. The reason for this can be:</source>
          <target state="translated">甲 &lt;code&gt;send_reason()&lt;/code&gt; ，表示该传输模块 &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; 功能没有发送该消息。原因可能是：</target>
        </trans-unit>
        <trans-unit id="0c9e5cf1fc1ef1d9c81cf8a83bbb2c92cb7facff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_mib_storage&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">一个 &lt;code&gt;snmpa_mib_storage&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="be1b2110a34fe49a492c740fc6d2a1e353485a6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">一个 &lt;code&gt;snmpa_notification_delivery_info_receiver&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="da19f426ecc187ba7aec2fbddba35e35ebdc8cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;supervisor&lt;/code&gt; and a &lt;code&gt;supervisor_bridge&lt;/code&gt; are also &lt;code&gt;gen_server&lt;/code&gt; processes. To return information that this process is a supervisor and the name of the callback module, &lt;code&gt;Module&lt;/code&gt; is &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; is the name of the supervisor callback module. &lt;code&gt;Arity&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, as the &lt;code&gt;init/1&lt;/code&gt; function is called initially in the callback module.</source>
          <target state="translated">一个 &lt;code&gt;supervisor&lt;/code&gt; 和 &lt;code&gt;supervisor_bridge&lt;/code&gt; 也 &lt;code&gt;gen_server&lt;/code&gt; 进程。要返回此过程是主管和回调模块名称的信息， &lt;code&gt;Module&lt;/code&gt; 是 &lt;code&gt;supervisor&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 是主管回调模块的名称。 &lt;code&gt;Arity&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，因为 &lt;code&gt;init/1&lt;/code&gt; 函数最初是在回调模块中调用的。</target>
        </trans-unit>
        <trans-unit id="9e84ddb3d1abb6010ba95215374a2c3fda587dad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;temporary&lt;/code&gt; child process is never restarted (not even when the supervisor restart strategy is &lt;code&gt;rest_for_one&lt;/code&gt; or &lt;code&gt;one_for_all&lt;/code&gt; and a sibling death causes the temporary process to be terminated).</source>
          <target state="translated">一个 &lt;code&gt;temporary&lt;/code&gt; 子进程不会再重新启动（即使是在主管重启策略是 &lt;code&gt;rest_for_one&lt;/code&gt; 或 &lt;code&gt;one_for_all&lt;/code&gt; 和兄弟姐妹的死亡使得临时进程被终止）。</target>
        </trans-unit>
        <trans-unit id="1d2a39bc2849b9b4ae106fb8032df69b5cf6fefa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp&lt;/code&gt; behavior and export the functions listed in the following.</source>
          <target state="translated">甲 &lt;code&gt;tftp&lt;/code&gt; 回调模块是被实施为 &lt;code&gt;tftp&lt;/code&gt; 行为并导出在下面列出的功能。</target>
        </trans-unit>
        <trans-unit id="27cee850217202e8dabaf2537514f0583ea52228" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tftp_logger&lt;/code&gt; callback module is to be implemented as a &lt;code&gt;tftp_logger&lt;/code&gt; behavior and export the following functions:</source>
          <target state="translated">一个 &lt;code&gt;tftp_logger&lt;/code&gt; 回调模块被实现为 &lt;code&gt;tftp_logger&lt;/code&gt; 行为和出口以下功能：</target>
        </trans-unit>
        <trans-unit id="6a934fbaa0dfee55a432f14191eb1f24df633cfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tooBig&lt;/code&gt; error in an SNMPv1 packet will always use the &lt;code&gt;'NULL'&lt;/code&gt; value in all variable bindings.</source>
          <target state="translated">一个 &lt;code&gt;tooBig&lt;/code&gt; 在SNMPv1的数据包错误总是会使用 &lt;code&gt;'NULL'&lt;/code&gt; 中的所有变量绑定值。</target>
        </trans-unit>
        <trans-unit id="33cb62d5e14ba5b3198337c7ba3cd6fbbcb1589c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transaction_reason()&lt;/code&gt;, indicates that the remote user has replied with an explicit transactionError.</source>
          <target state="translated">甲 &lt;code&gt;transaction_reason()&lt;/code&gt; ，指示远程用户已与显式transactionError回答。</target>
        </trans-unit>
        <trans-unit id="e53d6f03dc678459ddffb4d98f7b557780e96fef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;transient&lt;/code&gt; child process is restarted only if it terminates abnormally, that is, with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;transient&lt;/code&gt; 子进程重新启动，只有当它异常终止，也就是比其他的退出原因 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; ，或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9eb9caf239b9bb7b398b87222c53f550da50ad9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_error()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">甲 &lt;code&gt;user_cancel_error()&lt;/code&gt; ，表示该请求已经由用户取消。 &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; 函数调用中给出的原因。</target>
        </trans-unit>
        <trans-unit id="caaac6e0eeba26f0e8f05cc72836874db9f304d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;user_cancel_reason()&lt;/code&gt;, indicates that the request has been canceled by the user. &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; is the reason given in the call to the &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">甲 &lt;code&gt;user_cancel_reason()&lt;/code&gt; ，表示该请求已经由用户取消。 &lt;code&gt;reason_for_user_cancel()&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;megaco#cancel&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; 函数调用中给出的原因。</target>
        </trans-unit>
        <trans-unit id="5c86492d0dd649ce209af387e79b667ae92d9b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;warn_xxx&lt;/code&gt; form, to turn on the warning.</source>
          <target state="translated">一个 &lt;code&gt;warn_xxx&lt;/code&gt; 形式，开启警告。</target>
        </trans-unit>
        <trans-unit id="d4775dc55315e4de3bfb697e86b747e1981e9aa0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;components&quot;&gt;connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices, considering all edges undirected.</source>
          <target state="translated">阿&lt;strong id=&quot;components&quot;&gt;连接成分&lt;/strong&gt;是最大子图，使得在每对顶点之间的路径，考虑到无向所有边缘。</target>
        </trans-unit>
        <trans-unit id="c5c8116d1626ee6ce9e1eb9f966086aa8cd78606" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;depth_first_traversal&quot;&gt;depth-first traversal&lt;/strong&gt; of a directed digraph can be viewed as a process that visits all vertices of the digraph. Initially, all vertices are marked as unvisited. The traversal starts with an arbitrarily chosen vertex, which is marked as visited, and follows an edge to an unmarked vertex, marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no edge leading to an unvisited vertex. At that point the process backtracks, and the traversal continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated.</source>
          <target state="translated">甲&lt;strong id=&quot;depth_first_traversal&quot;&gt;深度优先遍历&lt;/strong&gt;一个有向图的可以被看作是一个过程，访问有向图的所有顶点。最初，所有顶点都标记为未访问。遍历从任意选择的顶点开始，该顶点被标记为已访问，并沿着边缘到达未标记的顶点，从而标记该顶点。然后以相同方式从该顶点进行搜索，直到没有导致未访问顶点的边为止。在这一点上，过程回溯，并且只要有未检查的边缘，遍历就会继续。如果在检查了第一个顶点的所有边后仍保留未访问的顶点，则选择一些到目前为止未访问的顶点，然后重复该过程。</target>
        </trans-unit>
        <trans-unit id="1b2506dfb79fff8f12c8b8a1cad93d4f54d6d800" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;digraph&quot;&gt;directed graph&lt;/strong&gt; (or just &quot;digraph&quot;) is a pair (V, E) of a finite set V of &lt;strong id=&quot;vertex&quot;&gt;vertices&lt;/strong&gt; and a finite set E of &lt;strong id=&quot;edge&quot;&gt;directed edges&lt;/strong&gt; (or just &quot;edges&quot;). The set of edges E is a subset of V &amp;times; V (the Cartesian product of V with itself).</source>
          <target state="translated">有&lt;strong id=&quot;digraph&quot;&gt;向图&lt;/strong&gt;（或仅是&amp;ldquo;有向图&amp;rdquo;）是&lt;strong id=&quot;vertex&quot;&gt;顶点&lt;/strong&gt;的有限集V 和有&lt;strong id=&quot;edge&quot;&gt;向边&lt;/strong&gt;（或仅是&amp;ldquo;边&amp;rdquo;）的有限集E的对（V，E ）。边集E是V&amp;times;V（V与自身的笛卡尔积）的子集。</target>
        </trans-unit>
        <trans-unit id="d772fcf249486473885a86b1e0fb07e1b81cc558" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;function&quot;&gt;function&lt;/strong&gt; F is a relation, a subset of X &amp;times; Y, such that the domain of F is equal to X and such that for every x in X there is a unique element y in Y with (x, y) in F. The latter condition can be formulated as follows: if x F y and x F z, then y = z. In this module, it is not required that the domain of F is equal to X for a relation to be considered a function.</source>
          <target state="translated">甲&lt;strong id=&quot;function&quot;&gt;函数&lt;/strong&gt; F是关系，X&amp;times;Y的一个子集，使得F的域是等于X和使得对于每x在X有Y中一个独特的元素y与F的（X，Y）后一个条件可以表述为：如果x F y和x F z，则y = z。在此模块中，对于将关系视为函数而言，不需要F的域等于X。</target>
        </trans-unit>
        <trans-unit id="9e6750400d02e17360f35f2ed9e1616f594d887a" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;loop&quot;&gt;loop&lt;/strong&gt; is a cycle of length one.</source>
          <target state="translated">甲&lt;strong id=&quot;loop&quot;&gt;环&lt;/strong&gt;是长度为1的循环。</target>
        </trans-unit>
        <trans-unit id="7c11e23c2588408ff5e86ef238bc8fcbf38b7c2f" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partial_ordering&quot;&gt;partial ordering&lt;/strong&gt; of a set S is a transitive, antisymmetric, and reflexive relation between the objects of S.</source>
          <target state="translated">甲&lt;strong id=&quot;partial_ordering&quot;&gt;部分排序&lt;/strong&gt;的一组S的是一个传递，反对称，以及自反关系S的对象之间的</target>
        </trans-unit>
        <trans-unit id="ac7ee38ffc1b59180cff85a400c6326e6a6aab8c" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;partition&quot;&gt;partition&lt;/strong&gt; of a set X is a collection S of non-empty subsets of X whose union is X and whose elements are pairwise disjoint.</source>
          <target state="translated">集合X的一个&lt;strong id=&quot;partition&quot;&gt;分区&lt;/strong&gt;是X的非空子集的集合S，它们的并集是X并且其元素成对不相交。</target>
        </trans-unit>
        <trans-unit id="d7deee876d2b62ea04d66ac5c3791065935e84a9" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;path&quot;&gt;path&lt;/strong&gt; P from v[1] to v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &amp;lt;= i &amp;lt; k.</source>
          <target state="translated">有向图（V，E）中从v [1]到v [k] 的&lt;strong id=&quot;path&quot;&gt;路径&lt;/strong&gt; P是V中顶点的非空序列v [1]，v [2]，...，v [k]对于1 &amp;lt;= i &amp;lt;k，E中存在边（v [i]，v [i + 1]）。</target>
        </trans-unit>
        <trans-unit id="e8aedf35788745c62222f34810b580741df0e0a0" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;relation&quot;&gt;relation&lt;/strong&gt; is a subset of X &amp;times; Y. Let R be a relation. The fact that (x, y) belongs to R is written as x R y. As relations are sets, the definitions of the last item (subset, union, and so on) apply to relations as well.</source>
          <target state="translated">甲&lt;strong id=&quot;relation&quot;&gt;关系&lt;/strong&gt;是X&amp;times;Y.设R的一个子集是一个关系。（x，y）属于R的事实写为x R y。当关系被设置时，最后一项的定义（子集，并集等）也适用于关系。</target>
        </trans-unit>
        <trans-unit id="95446742f2edee92dac5319d85b31460c32015fe" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;simple_cycle&quot;&gt;simple cycle&lt;/strong&gt; is a path that is both a cycle and simple.</source>
          <target state="translated">一个&lt;strong id=&quot;simple_cycle&quot;&gt;简单的周期&lt;/strong&gt;是既是一个周期和简单的路径。</target>
        </trans-unit>
        <trans-unit id="39c00c45dee614b6888498650b2a3b294abd94c1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;strong_components&quot;&gt;strongly connected component&lt;/strong&gt; is a maximal subgraph such that there is a path between each pair of vertices.</source>
          <target state="translated">甲&lt;strong id=&quot;strong_components&quot;&gt;强连通分量&lt;/strong&gt;是最大子图，使得在每对顶点之间的路径。</target>
        </trans-unit>
        <trans-unit id="77ea1ecd6a8be92c17cbe1f20f7156f6526977e8" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;sub_binary&quot;&gt;sub binary&lt;/strong&gt; is created by &lt;code&gt;split_binary/2&lt;/code&gt; and when a binary is matched out in a binary pattern. A sub binary is a reference into a part of another binary (refc or heap binary, but never into another sub binary). Therefore, matching out a binary is relatively cheap because the actual binary data is never copied.</source>
          <target state="translated">甲&lt;strong id=&quot;sub_binary&quot;&gt;子二进制&lt;/strong&gt;通过创建 &lt;code&gt;split_binary/2&lt;/code&gt; ，并且当二进制的二进制模式匹配的。子二进制文件是对另一个二进制文件（refc或堆二进制文件）的一部分的引用，但从不引用另一个子二进制文件。因此，匹配二进制文件相对便宜，因为从未复制实际的二进制数据。</target>
        </trans-unit>
        <trans-unit id="0025b1cc50f1b9268b28c701eca602b36605c8b7" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;subgraph&quot;&gt;subgraph&lt;/strong&gt; G' of G is a digraph whose vertices and edges form subsets of the vertices and edges of G.</source>
          <target state="translated">甲&lt;strong id=&quot;subgraph&quot;&gt;子图&lt;/strong&gt;的G G&amp;rdquo;是有向图，其顶点和边形成的顶点的子集和G的边缘</target>
        </trans-unit>
        <trans-unit id="0039a610746b5b7e8cb57b8cba5ce780934ff7d1" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;tree&quot;&gt;tree&lt;/strong&gt; is an acyclic non-empty digraph such that there is a unique path between every pair of vertices, considering all edges undirected.</source>
          <target state="translated">一&lt;strong id=&quot;tree&quot;&gt;棵树&lt;/strong&gt;是一个非循环的非空有向图，因此考虑到所有无向边，每对顶点之间都有一条唯一的路径。</target>
        </trans-unit>
        <trans-unit id="b32ebe8bef0eb8997c83afb4f754eff3d04ebc28" translate="yes" xml:space="preserve">
          <source>A &lt;strong id=&quot;type&quot;&gt;type&lt;/strong&gt; is an element of the domain of Sets.</source>
          <target state="translated">甲&lt;strong id=&quot;type&quot;&gt;类型&lt;/strong&gt;是集合的域的元素。</target>
        </trans-unit>
        <trans-unit id="c01dd20588e862d2bb347c0df2cf5a5ed91552dc" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;C node&lt;/strong&gt; is a C program written to act as a hidden node in a distributed Erlang system. The library &lt;strong&gt;Erl_Interface&lt;/strong&gt; contains functions for this purpose. For more information about C nodes, see the &lt;code&gt;Erl_Interface&lt;/code&gt; application and &lt;code&gt;Interoperability Tutorial.&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;&amp;Ccedil;节点&lt;/strong&gt;是写入到充当分布式系统的Erlang一个隐藏节点的C程序。库&lt;strong&gt;Erl_Interface&lt;/strong&gt;包含用于此目的的函数。有关C节点的更多信息，请参见 &lt;code&gt;Erl_Interface&lt;/code&gt; 应用程序和 &lt;code&gt;Interoperability Tutorial.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66dcfd2061a6be3ffc5089c446867b8415893bb3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;basic target system&lt;/strong&gt; that can be started by calling the ordinary &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">一个&lt;strong&gt;基本的目标系统&lt;/strong&gt;，可以通过调用普通的启动 &lt;code&gt;erl&lt;/code&gt; 脚本。</target>
        </trans-unit>
        <trans-unit id="55d83db79d583006717a0aeac0080dc553b75d98" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bit string generator&lt;/strong&gt; is written as:</source>
          <target state="translated">一个&lt;strong&gt;位串发电机&lt;/strong&gt;被写为：</target>
        </trans-unit>
        <trans-unit id="afe2abf552bd26d880de2e2001d284ae41c0e744" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;bitstring&lt;/strong&gt; is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8. If the number of bits is divisible by 8, the bitstring is also a binary.</source>
          <target state="translated">位&lt;strong&gt;串&lt;/strong&gt;是零个或多个位的序列，其中位数不需要被8整除。如果位数可以被8整除，则位串也是二进制的。</target>
        </trans-unit>
        <trans-unit id="a2d735f3a5066ecc4d1454fc4b0afd8407d709de" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;configuration file&lt;/strong&gt; contains values for configuration parameters for the applications in the system. The &lt;code&gt;erl&lt;/code&gt; command-line argument &lt;code&gt;-config Name&lt;/code&gt; tells the system to use data in the system configuration file &lt;code&gt;Name.config&lt;/code&gt;.</source>
          <target state="translated">一个&lt;strong&gt;配置文件&lt;/strong&gt;包含了系统中的应用程序的配置参数值。该 &lt;code&gt;erl&lt;/code&gt; 命令行参数 &lt;code&gt;-config Name&lt;/code&gt; 告诉系统使用数据的系统配置文件中 &lt;code&gt;Name.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f0a033b07b19b645b9f720df2987e2a2450883" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;distributed Erlang system&lt;/strong&gt; consists of a number of Erlang runtime systems communicating with each other. Each such runtime system is called a &lt;strong&gt;node&lt;/strong&gt;. Message passing between processes at different nodes, as well as links and monitors, are transparent when pids are used. Registered names, however, are local to each node. This means that the node must be specified as well when sending messages, and so on, using registered names.</source>
          <target state="translated">甲&lt;strong&gt;分布式二郎系统&lt;/strong&gt;由若干相互通信的Erlang运行时系统中的。每个这样的运行时系统都称为一个&lt;strong&gt;节点&lt;/strong&gt;。使用pid时，在不同节点的进程之间以及链接和监视器之间传递的消息是透明的。但是，注册名称是每个节点本地的。这意味着在发送消息等时也必须使用注册名称指定该节点。</target>
        </trans-unit>
        <trans-unit id="35fc39aba9120eb638121a4fd00b0aff5c8df307" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression that evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;滤波器&lt;/strong&gt;是一个表达式计算结果为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af58fb7b10794b226c8b033e42961c724b6386f1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;filter&lt;/strong&gt; is an expression, which evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;滤波器&lt;/strong&gt;是一个表达式，计算结果为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7239a397a4de1f7e0f662d28e63db77e29a8a038" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function clause&lt;/strong&gt; consists of a clause head and a clause body, separated by &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;功能的语句&lt;/strong&gt;由一个子句头和一个条款体，通过分离的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="702433f39c9e775694cb8f7f07b7d2e088b91814" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;function declaration&lt;/strong&gt; is a sequence of function clauses separated by semicolons, and terminated by period (.).</source>
          <target state="translated">甲&lt;strong&gt;函数声明&lt;/strong&gt;是由分号分隔，并且通过周期终止功能的条款的序列（。）。</target>
        </trans-unit>
        <trans-unit id="e0718a97c18e8111eccdd99489900e93dcc235d2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is written as:</source>
          <target state="translated">一个&lt;strong&gt;发电机&lt;/strong&gt;被写为：</target>
        </trans-unit>
        <trans-unit id="49fb24f8d2c4665a71b9fb75a2c85a70a1e64874" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard sequence&lt;/strong&gt; is a sequence of guards, separated by semicolon (;). The guard sequence is true if at least one of the guards is true. (The remaining guards, if any, are not evaluated.)</source>
          <target state="translated">&lt;strong&gt;保护序列&lt;/strong&gt;是由分号（;）分隔的&lt;strong&gt;保护序列&lt;/strong&gt;。如果至少一个防护为真，则防护序列为真。（其余警卫（如果有的话）不会得到评估。）</target>
        </trans-unit>
        <trans-unit id="981eab14479daed48688de4a5ee56b2147f16eb8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;guard&lt;/strong&gt; is a sequence of guard expressions, separated by comma (,). The guard is true if all guard expressions evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;后卫&lt;/strong&gt;是保护表达式的序列，用逗号（，）隔开。如果所有防护表达式都计算为true，则防护为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a741610f94ddf021d50b6a4ce0ea1ba4c3d40351" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;list&lt;/strong&gt; is any number of items. For example, an argument list can consist of zero, one, or more arguments.</source>
          <target state="translated">一个&lt;strong&gt;列表&lt;/strong&gt;是任何数量的项目。例如，参数列表可以包含零个，一个或多个参数。</target>
        </trans-unit>
        <trans-unit id="4bc9678f26cf6461a8a6b9764f2f492dda8d420f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;log event&lt;/strong&gt; consists of a &lt;strong&gt;log level&lt;/strong&gt;, the &lt;strong&gt;message&lt;/strong&gt; to be logged, and &lt;strong&gt;metadata&lt;/strong&gt;.</source>
          <target state="translated">甲&lt;strong&gt;日志事件&lt;/strong&gt;由一个的&lt;strong&gt;日志级别&lt;/strong&gt;，该&lt;strong&gt;消息&lt;/strong&gt;被记录，和&lt;strong&gt;元数据&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d6bec719f540faf5ce29c281150ca7c1acd29a54" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;match context&lt;/strong&gt; is similar to a sub binary, but is optimized for binary matching. For example, it contains a direct pointer to the binary data. For each field that is matched out of a binary, the position in the match context is incremented.</source>
          <target state="translated">甲&lt;strong&gt;匹配上下文&lt;/strong&gt;类似于子二进制，但对于二进制匹配被优化。例如，它包含一个指向二进制数据的直接指针。对于从二进制中匹配的每个字段，匹配上下文中的位置会增加。</target>
        </trans-unit>
        <trans-unit id="1e9bc69d9c0a74c78cd0265b7c282de9ccd749ff" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;module attribute&lt;/strong&gt; defines a certain property of a module.</source>
          <target state="translated">甲&lt;strong&gt;模块属性&lt;/strong&gt;定义的模块的某些特性。</target>
        </trans-unit>
        <trans-unit id="e8190f1687ae12b86f4402d53955920f9bd416c8" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;node&lt;/strong&gt; is an executing Erlang runtime system that has been given a name, using the command-line flag &lt;code&gt;-name&lt;/code&gt; (long names) or &lt;code&gt;-sname&lt;/code&gt; (short names).</source>
          <target state="translated">甲&lt;strong&gt;节点&lt;/strong&gt;是已被赋予名称，并使用命令行标记的执行Erlang运行时系统 &lt;code&gt;-name&lt;/code&gt; （长名称）或 &lt;code&gt;-sname&lt;/code&gt; （短名称）。</target>
        </trans-unit>
        <trans-unit id="6e89fa647f29644ee120e6617c0ff85024742693" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;raw filename&lt;/strong&gt; is a filename specified as a binary. The Erlang VM does not translate a filename specified as a binary on systems with transparent naming.</source>
          <target state="translated">甲&lt;strong&gt;原始文件名&lt;/strong&gt;是指定为二进制文件名。在具有透明命名的系统上，Erlang VM不会转换指定为二进制文件名。</target>
        </trans-unit>
        <trans-unit id="a275977fa1312a664ffd71817618e729388e7ac1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release package&lt;/strong&gt; is a compressed tar file containing code for a certain version of a release, created by calling &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt;. The release package is to be located in the &lt;code&gt;$ROOT/releases&lt;/code&gt; directory of the previous version of the release, where &lt;code&gt;$ROOT&lt;/code&gt; is the installation root directory, &lt;code&gt;code:root_dir()&lt;/code&gt;. Another &lt;code&gt;releases&lt;/code&gt; directory can be specified using the SASL configuration parameter &lt;code&gt;releases_dir&lt;/code&gt; or the OS environment variable &lt;code&gt;RELDIR&lt;/code&gt;. The release handler must have write access to this directory to install the new release. The persistent state of the release handler is stored there in a file called &lt;code&gt;RELEASES&lt;/code&gt;.</source>
          <target state="translated">甲&lt;strong&gt;释放包&lt;/strong&gt;是包含代码用于一个特定版本的释放，通过调用创建的压缩tar文件 &lt;code&gt;&lt;a href=&quot;systools#make_tar-1&quot;&gt;systools:make_tar/1,2&lt;/a&gt;&lt;/code&gt; 。该发行包位于该 &lt;code&gt;$ROOT/releases&lt;/code&gt; 先前版本的$ ROOT / releases目录中，其中 &lt;code&gt;$ROOT&lt;/code&gt; 是安装根目录 &lt;code&gt;code:root_dir()&lt;/code&gt; 。可以使用SASL配置参数 &lt;code&gt;releases_dir&lt;/code&gt; 或OS环境变量 &lt;code&gt;RELDIR&lt;/code&gt; 来指定另一个 &lt;code&gt;releases&lt;/code&gt; 目录。版本处理程序必须对此目录具有写访问权才能安装新版本。释放处理程序的持久状态存储在一个名为 &lt;code&gt;RELEASES&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="b0e927f4d2edf71fc5d44ab43ed17efe8434b72b" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;release&lt;/strong&gt; is a complete system made out from a subset of Erlang/OTP applications and a set of user-specific applications.</source>
          <target state="translated">甲&lt;strong&gt;释放&lt;/strong&gt;是从二郎/ OTP应用程序的子集和一组用户特定的应用程序开出了完整的系统。</target>
        </trans-unit>
        <trans-unit id="976ea0cb3408e08f1ff1f8752455df14d099e36d" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;sequence&lt;/strong&gt; is one or more items. For example, a clause body consists of a sequence of expressions. This means that there must be at least one expression.</source>
          <target state="translated">一个&lt;strong&gt;序列&lt;/strong&gt;是一个或多个项目。例如，子句主体由一系列表达式组成。这意味着必须至少有一个表达式。</target>
        </trans-unit>
        <trans-unit id="17f419c4c64396cd3eddb7f3ce76e4edf856d5d9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple target system&lt;/strong&gt; where also code replacement in runtime can be performed.</source>
          <target state="translated">一个&lt;strong&gt;简单的目标系统&lt;/strong&gt;，可以在运行时执行代码替换。</target>
        </trans-unit>
        <trans-unit id="bd639259721f11093866111b359fef2a8236a3eb" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;simple test object&lt;/strong&gt; is one of the following:</source>
          <target state="translated">一个&lt;strong&gt;简单的测试对象&lt;/strong&gt;是以下之一：</target>
        </trans-unit>
        <trans-unit id="82a1fd7cbded9d1d8965325e8da4ad9119bb1b3f" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;start type&lt;/strong&gt; is defined when starting the application:</source>
          <target state="translated">甲&lt;strong&gt;启动型&lt;/strong&gt;启动应用程序时被定义：</target>
        </trans-unit>
        <trans-unit id="a0236d18c08e4a43e425435b87053806e35cfab2" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;symmetric key&lt;/strong&gt; algorithm has one key only. The key is used for both encryption and decryption. These algorithms are fast, compared to public key algorithms (using two keys, one public and one private) and are therefore typically used for encrypting bulk data.</source>
          <target state="translated">一个&lt;strong&gt;对称密钥&lt;/strong&gt;算法只有一个密钥。该密钥用于加密和解密。与公共密钥算法（使用两个密钥，一个公共和一个私有）相比，这些算法速度快，因此通常用于加密批量数据。</target>
        </trans-unit>
        <trans-unit id="90e12c45690a2d90b9b7c27b63616643b3b02e6c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;token&lt;/strong&gt; is a tuple containing information about syntactic category, the token annotations, and the terminal symbol. For punctuation characters (such as &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) and reserved words, the category and the symbol coincide, and the token is represented by a two-tuple. Three-tuples have one of the following forms:</source>
          <target state="translated">甲&lt;strong&gt;令牌&lt;/strong&gt;是含有约句法类，令牌注解，和终端符号信息的元组。对于标点符号字符（例如 &lt;code&gt;;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; ）和保留字，类别和符号重合，并且标记由二元组表示。三元组具有以下形式之一：</target>
        </trans-unit>
        <trans-unit id="c710c4620cfaa2e0ecb80d9dcbf14cd7cba3ca83" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;user&lt;/strong&gt; in this context is basically a module implementing the &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; behaviour. A &lt;strong&gt;user&lt;/strong&gt; can issue snmp requests and receive notification/traps.</source>
          <target state="translated">一个&lt;strong&gt;用户&lt;/strong&gt;在这方面基本上实现一个模块 &lt;code&gt;&lt;a href=&quot;snmpm_user&quot;&gt;snmpm_user&lt;/a&gt;&lt;/code&gt; 行为。一个&lt;strong&gt;用户&lt;/strong&gt;可以发出SNMP请求和接收通知/陷阱。</target>
        </trans-unit>
        <trans-unit id="9d2d133d1504025586739d14579afcf2a4b16f56" translate="yes" xml:space="preserve">
          <source>A Bin does not need to consist of a whole number of bytes.</source>
          <target state="translated">一个Bin不需要由一个整数的字节组成。</target>
        </trans-unit>
        <trans-unit id="446abf7d28572cb4c16319d9159e9f73428ea954" translate="yes" xml:space="preserve">
          <source>A Bin is a low-level sequence of bits or bytes. The purpose of a Bin is to enable construction of binaries:</source>
          <target state="translated">Bin是一个低级的比特或字节序列。Bin的目的是为了实现二进制文件的构建。</target>
        </trans-unit>
        <trans-unit id="e18b65283e058fbced7bffdbd923450b434dd1e6" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the abstract code is compiler-generated. The Erlang Compiler does not emit warnings for such code.</source>
          <target state="translated">一个布尔值,表示抽象代码是否是编译器生成的。Erlang编译器不会对这种代码发出警告。</target>
        </trans-unit>
        <trans-unit id="8fafe519eed7d47dd4061f1954b6119a2c8bfca3" translate="yes" xml:space="preserve">
          <source>A Boolean indicating if the origin of the abstract code is a record. Used by &lt;code&gt;Dialyzer&lt;/code&gt; to assign types to tuple elements.</source>
          <target state="translated">一个布尔值，指示抽象代码的来源是否是记录。 &lt;code&gt;Dialyzer&lt;/code&gt; 使用它为元组元素分配类型。</target>
        </trans-unit>
        <trans-unit id="6de41a093bc1801677e67b2a06074305f2cfcbb9" translate="yes" xml:space="preserve">
          <source>A Boolean specifying if the data has been transmitted over the wire.</source>
          <target state="translated">一个布尔值,用于指定数据是否已通过有线传输。</target>
        </trans-unit>
        <trans-unit id="0384327244e40e6c1e6266a9b063a6ad9f121c59" translate="yes" xml:space="preserve">
          <source>A C node has access to names registered through the &lt;code&gt;global&lt;/code&gt; module in Kernel. Names can be looked up, allowing the C node to send messages to named Erlang services. C nodes can also register global names, allowing them to provide named services to Erlang processes or other C nodes.</source>
          <target state="translated">AC节点可以访问通过内核中的 &lt;code&gt;global&lt;/code&gt; 模块注册的名称。可以查找名称，从而允许C节点将消息发送到命名的Erlang服务。C节点还可以注册全局名称，从而允许它们向Erlang进程或其他C节点提供命名服务。</target>
        </trans-unit>
        <trans-unit id="682f01848ff412b810853a147adc8683eb3445ca" translate="yes" xml:space="preserve">
          <source>A C node server using long node names:</source>
          <target state="translated">一个使用长节点名的C节点服务器。</target>
        </trans-unit>
        <trans-unit id="bb35db3d2e0c2f3a8f1ad0dde3a30bca6441edc6" translate="yes" xml:space="preserve">
          <source>A C program that uses the Erl_Interface functions for setting up a connection to, and communicating with, a distributed Erlang node is called a &lt;strong&gt;C node&lt;/strong&gt;, or a &lt;strong&gt;hidden node&lt;/strong&gt;. The main advantage with a C node is that the communication from the Erlang programmer's perspective is extremely easy, as the C program behaves as a distributed Erlang node.</source>
          <target state="translated">使用Erl_Interface函数建立与分布式Erlang节点的连接并与之通信的AC程序称为&lt;strong&gt;C节点&lt;/strong&gt;或&lt;strong&gt;隐藏节点&lt;/strong&gt;。C节点的主要优点是，从Erlang程序员的角度来看，通信非常容易，因为C程序的行为就像一个分布式Erlang节点。</target>
        </trans-unit>
        <trans-unit id="aa24a183415b610afc89cc8dcdc9ea0fca45c74b" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">当充当服务器的C节点调用 &lt;code&gt;ei_publish()&lt;/code&gt; 时，会分配一个创建编号。</target>
        </trans-unit>
        <trans-unit id="e6c7aba44f58b6222686f74dc17e0b3bd8f16425" translate="yes" xml:space="preserve">
          <source>A C-node acting as a server is assigned a creation number when it calls &lt;code&gt;erl_publish()&lt;/code&gt;.</source>
          <target state="translated">当充当服务器的C节点调用 &lt;code&gt;erl_publish()&lt;/code&gt; 时，将分配一个创建编号。</target>
        </trans-unit>
        <trans-unit id="4e5f9a2d3d932ac1d27aa18a6752ebffe6998981" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name does not appear in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">在Erlang中，C节点显示为&lt;strong&gt;隐藏节点&lt;/strong&gt;。也就是说，知道C节点名称的Erlang进程可以正常方式与其通信，但是节点名称不会出现在 &lt;code&gt;ERTS&lt;/code&gt; 的 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 提供的列表中。</target>
        </trans-unit>
        <trans-unit id="e583adab7ce74410cb0c7c1feef4181103360c0c" translate="yes" xml:space="preserve">
          <source>A C-node appears to Erlang as a &lt;strong&gt;hidden node&lt;/strong&gt;. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name is not shown in the listing provided by &lt;code&gt;erlang:nodes/0&lt;/code&gt; in &lt;code&gt;ERTS&lt;/code&gt;.</source>
          <target state="translated">在Erlang中，C节点显示为&lt;strong&gt;隐藏节点&lt;/strong&gt;。即，知道所述C-节点可以使用它以正常的方式进行通信的名称Erlang进程，但节点名没有在列表中提供所示 &lt;code&gt;erlang:nodes/0&lt;/code&gt; 在 &lt;code&gt;ERTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08059f968b0ad7c0b01718559289e25bd4f10ee5" translate="yes" xml:space="preserve">
          <source>A CPU Load and CPU Utilization Supervisor Process</source>
          <target state="translated">一个CPU负载和CPU利用率的督导过程。</target>
        </trans-unit>
        <trans-unit id="5d2433f698f9b491166c109983414e1ff91ef2ab" translate="yes" xml:space="preserve">
          <source>A CPU topology can consist of both processor external, and processor internal NUMA nodes as long as each logical processor belongs to only one NUMA node. If &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; is omitted, its default position is before &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt;. That is, the default is processor external NUMA nodes.</source>
          <target state="translated">一个CPU拓扑可以由处理器外部NUMA节点和处理器内部NUMA节点组成，只要每个逻辑处理器仅属于一个NUMA节点即可。如果省略 &lt;code&gt;&amp;lt;ProcessorIds&amp;gt;&lt;/code&gt; ，则其默认位置在 &lt;code&gt;&amp;lt;NodeIds&amp;gt;&lt;/code&gt; 之前。也就是说，默认值为处理器外部NUMA节点。</target>
        </trans-unit>
        <trans-unit id="8ed401286c11a4167b9153f2763d08ee22a748c5" translate="yes" xml:space="preserve">
          <source>A CTH can be installed in multiple ways in your test run. You can do it for all tests in a run, for specific test suites, and for specific groups within a test suite. If you want a CTH to be present in all test suites within your test run, there are three ways to accomplish that, as follows:</source>
          <target state="translated">CTH 可以以多种方式安装到测试运行中。您可以对运行中的所有测试、特定的测试套件以及测试套件中的特定组进行安装。如果您想让 CTH 出现在测试运行中的所有测试套件中,有以下三种方法可以实现。</target>
        </trans-unit>
        <trans-unit id="2484fb91ce1c0711415802f1c1e1b2f011ddea08" translate="yes" xml:space="preserve">
          <source>A Coverage Analysis Tool for Erlang</source>
          <target state="translated">Erlang的覆盖率分析工具</target>
        </trans-unit>
        <trans-unit id="462cfacaa4707242a4aec32251bf3187a68a4056" translate="yes" xml:space="preserve">
          <source>A Cross Reference Tool for analyzing dependencies between functions, modules, applications and releases.</source>
          <target state="translated">一个交叉参考工具,用于分析函数、模块、应用程序和版本之间的依赖关系。</target>
        </trans-unit>
        <trans-unit id="52283e056d3171a619c0cac0805fc7102c861750" translate="yes" xml:space="preserve">
          <source>A DBMS query language, Query List Comprehension (QLC) as an add-on library.</source>
          <target state="translated">一个DBMS查询语言,查询列表理解(QLC)作为附加库。</target>
        </trans-unit>
        <trans-unit id="bb6bc7a0a2c07a2fe54be2405da37b62f7c39bde" translate="yes" xml:space="preserve">
          <source>A DSA private key can look as follows:</source>
          <target state="translated">一个DSA私钥可以如下所示。</target>
        </trans-unit>
        <trans-unit id="a0b5e71146772a786dbb1661b191c55af9cb0b9a" translate="yes" xml:space="preserve">
          <source>A Diameter application supported by the service.</source>
          <target state="translated">服务支持的Diameter应用。</target>
        </trans-unit>
        <trans-unit id="d177fdf4f1cf327fbf5fecfc4fa72345624b5d5f" translate="yes" xml:space="preserve">
          <source>A Diameter message as passed over the transport interface.</source>
          <target state="translated">通过传输接口传递的Diameter信息。</target>
        </trans-unit>
        <trans-unit id="62bfb25c7e21e8b536daf6c9f716b0eb6fa490c9" translate="yes" xml:space="preserve">
          <source>A Diameter node is implemented by configuring a &lt;strong&gt;service&lt;/strong&gt; and one or more &lt;strong&gt;transports&lt;/strong&gt; using the interface module &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt;. The service configuration defines the Diameter applications to be supported by the node and, typically, the capabilities that it should send to remote peers at capabilities exchange upon the establishment of transport connections. A transport is configured on a service and provides protocol-specific send/receive functionality by way of a transport interface defined by diameter and implemented by a transport module. The diameter application provides two transport modules: &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; for transport over TCP (using &lt;code&gt;gen_tcp&lt;/code&gt;) and SCTP (using &lt;code&gt;gen_sctp&lt;/code&gt;) respectively. Other transports can be provided by any module that implements diameter's &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用接口模块 &lt;code&gt;&lt;a href=&quot;diameter&quot;&gt;diameter&lt;/a&gt;&lt;/code&gt; 配置&lt;strong&gt;服务&lt;/strong&gt;和一个或多个&lt;strong&gt;传输&lt;/strong&gt;来实现Diameter节点。服务配置定义了节点要支持的Diameter应用程序，并且通常定义了在建立传输连接时进行功能交换时应发送给远程对等方的功能。传输器在服务上配置，并通过直径定义并由传输模块实现的传输接口提供特定于协议的发送/接收功能。直径应用程序提供两个传输模块： &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp&lt;/a&gt;&lt;/code&gt; ,用于通过TCP（使用 &lt;code&gt;gen_tcp&lt;/code&gt; ）和SCTP（使用 &lt;code&gt;gen_sctp&lt;/code&gt; ）。任何实现直径 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;transport interface&lt;/a&gt;&lt;/code&gt; 模块都可以提供其他传输。</target>
        </trans-unit>
        <trans-unit id="f6f02eb64bbe780dfde9efd8754001ee09c7d316" translate="yes" xml:space="preserve">
          <source>A Disk Supervisor Process</source>
          <target state="translated">磁盘监控程序</target>
        </trans-unit>
        <trans-unit id="cfe5d3f52e1bab9a63a7df0c0c6f4e1c0567b94a" translate="yes" xml:space="preserve">
          <source>A File Transfer Protocol client.</source>
          <target state="translated">一个文件传输协议客户端。</target>
        </trans-unit>
        <trans-unit id="8d70bbe040a2f8306532e86a99c772dde2300f04" translate="yes" xml:space="preserve">
          <source>A GUI tool for observing an Erlang system.</source>
          <target state="translated">一个观察Erlang系统的GUI工具。</target>
        </trans-unit>
        <trans-unit id="412558260339ef39924a36cedb4746b92b39860e" translate="yes" xml:space="preserve">
          <source>A MIB compiler, which understands SMIv1 (RFC1155, 1212, and 1215) and SMIv2 (RFC1902, 1903, and 1904).</source>
          <target state="translated">一个MIB编译器,可以理解SMIv1(RFC1155、1212和1215)和SMIv2(RFC1902、1903和1904)。</target>
        </trans-unit>
        <trans-unit id="465e342200f443fe19bf77c7c55e103eb0525cf5" translate="yes" xml:space="preserve">
          <source>A Make Utility for Erlang</source>
          <target state="translated">一个用于Erlang的Make工具</target>
        </trans-unit>
        <trans-unit id="4dfa6d3d81a250e09767148c068c430d43e6542a" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to #megaco_incr_timer{}.</source>
          <target state="translated">一个Megaco定时器(见上文解释),默认为#megaco_incr_timer{}。</target>
        </trans-unit>
        <trans-unit id="b68589e1526f4c0bee999a382123018413ba14b2" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to 30000.</source>
          <target state="translated">一个Megaco定时器(见上面的解释),默认值为30000。</target>
        </trans-unit>
        <trans-unit id="cbd6f555dff6fd8042f699c901ba913734ef4278" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;.</source>
          <target state="translated">Megaco计时器（请参见上面的说明）默认为 &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dad93e1d5d1ceeacd635b8d583372b48511bbd3" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;10000&lt;/code&gt;.</source>
          <target state="translated">Megaco计时器（请参见上面的说明），默认为 &lt;code&gt;10000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c141bdf1ede3294bead601d72060262ea844d853" translate="yes" xml:space="preserve">
          <source>A Megaco Timer (see explanation above), defaults to &lt;code&gt;60 seconds&lt;/code&gt;.</source>
          <target state="translated">Megaco计时器（请参阅上面的说明），默认为 &lt;code&gt;60 seconds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b0881b9c745a291d82b3b71d65651beef69c53b" translate="yes" xml:space="preserve">
          <source>A Memory Supervisor Process</source>
          <target state="translated">一个内存监控程序</target>
        </trans-unit>
        <trans-unit id="ae5893b089e2986872b8d9a34ac398cb97910587" translate="yes" xml:space="preserve">
          <source>A NIF does not have to be exported, it can be local to the module. However, unused local stub functions will be optimized away by the compiler, causing loading of the NIF library to fail.</source>
          <target state="translated">NIF不一定要导出,它可以是模块的本地函数,但未使用的本地函数会被编译器优化掉,导致加载失败。但是,未使用的本地存根函数会被编译器优化掉,导致NIF库的加载失败。</target>
        </trans-unit>
        <trans-unit id="ae9dbde8e133cef08c1e749be3a70e95b4ade2c3" translate="yes" xml:space="preserve">
          <source>A NIF is a function that is implemented in C instead of Erlang. NIFs appear as any other functions to the callers. They belong to a module and are called like any other Erlang functions. The NIFs of a module are compiled and linked into a dynamic loadable, shared library (SO in UNIX, DLL in Windows). The NIF library must be loaded in runtime by the Erlang code of the module.</source>
          <target state="translated">NIF是一个用C语言而不是Erlang语言实现的函数。对调用者来说,NIF就像其他函数一样。它们属于一个模块,并像其他Erlang函数一样被调用。一个模块的NIF被编译并链接到一个动态可加载的共享库中(UNIX中为SO,Windows中为DLL)。NIF库必须在运行时被模块的Erlang代码加载。</target>
        </trans-unit>
        <trans-unit id="84d9be08ac04a1b8855fd49f7405173d0e59dc63" translate="yes" xml:space="preserve">
          <source>A NIF is thread-safe without any explicit synchronization as long as it acts as a pure function and only reads the supplied arguments. When you write to a shared state either through static variables or &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;, you need to supply your own explicit synchronization. This includes terms in process-independent environments that are shared between threads. Resource objects also require synchronization if you treat them as mutable.</source>
          <target state="translated">NIF是线程安全的，没有任何显式同步，只要它充当纯函数并且仅读取提供的参数即可。通过静态变量或 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 写入共享状态时，需要提供自己的显式同步。这包括线程之间共享的与进程无关的环境中的术语。如果将资源对象视为可变对象，它们也需要同步。</target>
        </trans-unit>
        <trans-unit id="8a60c02f399b39b76528cae89a210e7ba95c129a" translate="yes" xml:space="preserve">
          <source>A NIF library contains native implementation of some functions of an Erlang module. The native implemented functions (NIFs) are called like any other functions without any difference to the caller. Each NIF must have an implementation in Erlang that is invoked if the function is called before the NIF library is successfully loaded. A typical such stub implementation is to throw an exception. But it can also be used as a fallback implementation if the NIF library is not implemented for some architecture.</source>
          <target state="translated">NIF库包含了Erlang模块的一些函数的本地实现。本机实现的函数(NIFs)和其他函数一样被调用,对调用者没有任何区别。每个NIF必须有一个在Erlang中的实现,如果函数在NIF库成功加载之前被调用,这个实现就会被调用。一个典型的这种存根实现是抛出一个异常。但如果某些架构的NIF库没有实现,它也可以作为后备实现。</target>
        </trans-unit>
        <trans-unit id="16083aaa52c81a0267780218bf0e70427a08f38c" translate="yes" xml:space="preserve">
          <source>A NIF library is already loaded for this module instance. The previously deprecated &lt;code&gt;reload&lt;/code&gt; feature was removed in OTP 20.</source>
          <target state="translated">NIF库已为此模块实例加载。先前不推荐使用的 &lt;code&gt;reload&lt;/code&gt; 功能已在OTP 20中删除。</target>
        </trans-unit>
        <trans-unit id="3a1f48477831047343a1f8bf95917f0e713f592c" translate="yes" xml:space="preserve">
          <source>A NIF that cannot be split and cannot execute in a millisecond or less is called a &quot;dirty NIF&quot;, as it performs work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. This is handled by executing dirty jobs on a separate set of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the same duration restriction as a normal NIF.</source>
          <target state="translated">一个不能拆分、不能在一毫秒或更短的时间内执行的NIF被称为 &quot;dirty NIF&quot;,因为它执行的工作是Erlang运行时系统的普通调度器无法处理干净的。使用这类函数的应用程序必须向运行时表明这些函数是脏的,这样才能对它们进行特殊处理。处理的方法是在一组单独的调度器上执行脏作业,称为脏调度器。在 dirty 调度器上执行的 dirty NIF 与普通 NIF 的持续时间限制不同。</target>
        </trans-unit>
        <trans-unit id="af197bff7b3c7ea0c0e795a6e3fce23b4ca646b1" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP agent &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Net if进程必须实现SNMP代理 &lt;code&gt;&lt;a href=&quot;snmpa_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4682baf7bf989ecc09c30378539a80083913f72a" translate="yes" xml:space="preserve">
          <source>A Net if process must implement the SNMP manager &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Net if进程必须实现SNMP管理器 &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;network interface behaviour&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5ce5e0afdd417aa616eb37eb871e57129530691" translate="yes" xml:space="preserve">
          <source>A POSIX error value if something else goes wrong, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; for possible error values</source>
          <target state="translated">如果出现其他错误，则为POSIX错误值，有关可能的错误值，请参见 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66a3f3d7962a2ff38d3eb0fc27400ec7705ecedf" translate="yes" xml:space="preserve">
          <source>A POSIX thread like API for multi-threading is provided. The Erlang driver thread API only provides a subset of the functionality provided by the POSIX thread API. The subset provided is more or less the basic functionality needed for multi-threaded programming:</source>
          <target state="translated">提供了一个类似POSIX线程的多线程API。Erlang驱动线程API只提供了POSIX线程API所提供功能的一个子集。所提供的子集多少是多线程编程所需要的基本功能。</target>
        </trans-unit>
        <trans-unit id="0bd457a7ac87a208b16a149cb348e99367ad82ba" translate="yes" xml:space="preserve">
          <source>A PPID can be configured with a a gen_sctp sctp_default_send_param option.</source>
          <target state="translated">可以用gen_sctp sctp_default_send_param选项来配置PPID。</target>
        </trans-unit>
        <trans-unit id="6c511d3ccb60e7dc830ac553725bdc5da3a2e9fa" translate="yes" xml:space="preserve">
          <source>A Route-Record AVP is appended by diameter when the return value of a request callback asks that a request be forwarded. Appending the AVP in other cases is the responsibility of the user.</source>
          <target state="translated">当请求回调的返回值要求转发请求时,路由记录AVP会被直径附加。在其他情况下附加AVP是用户的责任。</target>
        </trans-unit>
        <trans-unit id="094734567e030c7a3c51ff51fd0000a24bb2ce28" translate="yes" xml:space="preserve">
          <source>A SAX parser for XML that sends the events through a callback interface. SAX is the &lt;strong&gt;Simple API for XML&lt;/strong&gt;, originally a Java-only API. SAX was the first widely adopted API for XML in Java, and is a &lt;strong&gt;de facto&lt;/strong&gt; standard where there are versions for several programming language environments other than Java.</source>
          <target state="translated">用于XML的SAX解析器，它通过回调接口发送事件。SAX是&lt;strong&gt;XML&lt;/strong&gt;的&lt;strong&gt;简单API&lt;/strong&gt;，最初是纯Java的API。SAX是Java中第一个被广泛采用的XML XML API，并且是&lt;strong&gt;事实上的&lt;/strong&gt;标准，其中存在用于Java以外的几种编程语言环境的版本。</target>
        </trans-unit>
        <trans-unit id="248ee08e6a02ab2fc5bc7400b653c53caa52bbda" translate="yes" xml:space="preserve">
          <source>A Set of Release Handling Tools</source>
          <target state="translated">一套释放处理工具</target>
        </trans-unit>
        <trans-unit id="60186d2f270382eb00ad49b3e5e34efc25a7eb30" translate="yes" xml:space="preserve">
          <source>A TAR program that understands the GNU TAR format for long filenames.</source>
          <target state="translated">一个能理解长文件名的GNU TAR格式的TAR程序。</target>
        </trans-unit>
        <trans-unit id="7a5eb9a2cf5198242ce83b7910f56bb7256b5a72" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool for Erlang</source>
          <target state="translated">Erlang的时间剖析工具</target>
        </trans-unit>
        <trans-unit id="02d15da22619453c9a967ff17ef23dbd1a99ec4f" translate="yes" xml:space="preserve">
          <source>A Time Profiling Tool using trace to file for minimal runtime performance impact.</source>
          <target state="translated">一个使用跟踪到文件的时间分析工具,以最小的运行时性能影响。</target>
        </trans-unit>
        <trans-unit id="b6a932a694249ceff9de8c32f16fd50b0a78a087" translate="yes" xml:space="preserve">
          <source>A URI is an identifier consisting of a sequence of characters matching the syntax rule named &lt;strong&gt;URI&lt;/strong&gt; in &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">URI是由匹配评为句法规则的字符序列的标识符&lt;strong&gt;URI&lt;/strong&gt;在 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e149e0b4c1a1c105b7f889d32cd56c5262fc2226" translate="yes" xml:space="preserve">
          <source>A Unicode extended grapheme cluster</source>
          <target state="translated">一个Unicode扩展字词群</target>
        </trans-unit>
        <trans-unit id="91c776c2572caac7dae19c58dc677fab9b2bc760" translate="yes" xml:space="preserve">
          <source>A Unix-specific example:</source>
          <target state="translated">一个Unix特有的例子。</target>
        </trans-unit>
        <trans-unit id="44f895c061c338a2c4f6db51cc29f383c116fdd5" translate="yes" xml:space="preserve">
          <source>A User is an entity identified by a MID, e.g. a MGC or a MG.</source>
          <target state="translated">用户是一个由MID识别的实体,如MGC或MG。</target>
        </trans-unit>
        <trans-unit id="32b6de1aa97b29f50e5912a12d7ac4a95b0cfea8" translate="yes" xml:space="preserve">
          <source>A WxWidgets based tool for browsing Erlang crashdumps.</source>
          <target state="translated">一个基于WxWidgets的工具,用于浏览Erlang crashdumps。</target>
        </trans-unit>
        <trans-unit id="e4bde50404582298e3cf270bb8ccc3daf0ea5444" translate="yes" xml:space="preserve">
          <source>A back reference (see the next section)</source>
          <target state="translated">后期参考(见下一节)</target>
        </trans-unit>
        <trans-unit id="53d6a047b6dd3ed0e849f25a2c3fb01b061ee975" translate="yes" xml:space="preserve">
          <source>A back reference matches whatever matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself (section &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; describes a way of doing that). So, the following pattern matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;:</source>
          <target state="translated">后向引用匹配当前主题字符串中与捕获子模式匹配的任何内容，而不匹配与子模式本身匹配的任何内容（ &lt;code&gt;&lt;a href=&quot;#sect21&quot;&gt;Subpattern as Subroutines&lt;/a&gt;&lt;/code&gt; 子例程的子模式部分描述了一种实现方式）。因此，以下模式匹配&amp;ldquo;理智与情感&amp;rdquo;和&amp;ldquo;响应与责任&amp;rdquo;，但不匹配&amp;ldquo;理智与责任&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="c7a2ff223aa7f1180c7a5c0c761648542d8226fb" translate="yes" xml:space="preserve">
          <source>A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a\1) never matches. However, such references can be useful inside repeated subpatterns. For example, the following pattern matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot;, and so on:</source>
          <target state="translated">当第一次使用子模式时,发生在括号内的反向引用会失败,所以,例如,(a/\1)永远不会匹配。然而,这种引用在重复的子模式中是有用的。例如,下面的模式可以匹配任何数量的 &quot;a&quot;,也可以匹配 &quot;aba&quot;、&quot;ababbaa &quot;等。</target>
        </trans-unit>
        <trans-unit id="ffc1ebbafbdaba3dd7477ee36631ba1276292a19" translate="yes" xml:space="preserve">
          <source>A back reference to a numbered subpattern uses the most recent value that is set for that number by any subpattern. The following pattern matches &quot;abcabc&quot; or &quot;defdef&quot;:</source>
          <target state="translated">对编号子模式的反向引用使用任何子模式为该编号设置的最新值。以下模式与 &quot;abcabc &quot;或 &quot;defdef &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="0d402fcdbef693771940455e9ef73fd921c03b39" translate="yes" xml:space="preserve">
          <source>A base for building trace tools for distributed systems.</source>
          <target state="translated">构建分布式系统跟踪工具的基础。</target>
        </trans-unit>
        <trans-unit id="c418f2ac7b109d9e422eb741c2ec0065dcef710c" translate="yes" xml:space="preserve">
          <source>A basic concept in Erlang/OTP is the &lt;strong&gt;supervision tree&lt;/strong&gt;. This is a process structuring model based on the idea of &lt;strong&gt;workers&lt;/strong&gt; and &lt;strong&gt;supervisors&lt;/strong&gt;:</source>
          <target state="translated">Erlang / OTP中的基本概念是&lt;strong&gt;监视树&lt;/strong&gt;。这是一个基于&lt;strong&gt;工人&lt;/strong&gt;和&lt;strong&gt;主管&lt;/strong&gt;的想法的流程构建模型：</target>
        </trans-unit>
        <trans-unit id="a7814d9e97780d5bb1e4072e8590cdbb3e3d0929" translate="yes" xml:space="preserve">
          <source>A better solution for a real module is to take advantage of the new directive &lt;code&gt;on_load&lt;/code&gt; (see section &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; in the Erlang Reference Manual) to load the NIF library automatically when the module is loaded.</source>
          <target state="translated">对于实际模块，更好的解决方案是利用新指令 &lt;code&gt;on_load&lt;/code&gt; （请参见《 Erlang参考手册》中的&amp;ldquo;在 &lt;code&gt;Running a Function When a Module is Loaded&lt;/code&gt; 节）来在加载模块时自动加载NIF库。</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">一个二进制总是包含一个完整的字节数。</target>
        </trans-unit>
        <trans-unit id="b3e748c424b491ef4e2b424caaa0193f66560cd4" translate="yes" xml:space="preserve">
          <source>A binary data object, structured according to the Erlang external term format.</source>
          <target state="translated">一个二进制数据对象,按照Erlang外部术语格式结构。</target>
        </trans-unit>
        <trans-unit id="298c689646b297768a8fb73aa045eb2812167789" translate="yes" xml:space="preserve">
          <source>A binding structure.</source>
          <target state="translated">一种结合结构;</target>
        </trans-unit>
        <trans-unit id="e77e3889fe8c014ea8612f275ae6ccbea02093b9" translate="yes" xml:space="preserve">
          <source>A bit string comprehension returns a bit string, which is created by concatenating the results of evaluating &lt;code&gt;BitString&lt;/code&gt; for each combination of bit string generator elements, for which all filters are true.</source>
          <target state="translated">位字符串理解将返回一个位字符串，该位字符串是通过将对所有字符串均为true的位字符串生成器元素的每种组合的 &lt;code&gt;BitString&lt;/code&gt; 求值结果进行级联而创建的。</target>
        </trans-unit>
        <trans-unit id="c30114629b8426a6ada7d40a7f0ce097c95413d5" translate="yes" xml:space="preserve">
          <source>A bit string is used to store an area of untyped memory.</source>
          <target state="translated">一个位串用于存储非类型内存的区域。</target>
        </trans-unit>
        <trans-unit id="36bc1be2e2bdda5bcfbb5daa59af1b7decd47b95" translate="yes" xml:space="preserve">
          <source>A bitstring. By default, a &lt;code&gt;BIT STRING&lt;/code&gt; with no symbolic names is decoded to an Erlang bitstring.</source>
          <target state="translated">一个位串。默认情况下，不带符号名的 &lt;code&gt;BIT STRING&lt;/code&gt; 解码为Erlang位串。</target>
        </trans-unit>
        <trans-unit id="c215287a4d613c8262ada2c7133754a941970ff4" translate="yes" xml:space="preserve">
          <source>A body B is a non-empty sequence of expressions &lt;code&gt;E_1, ..., E_k&lt;/code&gt;, and Rep(B) = &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt;.</source>
          <target state="translated">主体B是表达式 &lt;code&gt;E_1, ..., E_k&lt;/code&gt; 的非空序列，并且Rep（B）= &lt;code&gt;[Rep(E_1), ..., Rep(E_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d107afa764d6c26d14d3133c85da34202dfafd4f" translate="yes" xml:space="preserve">
          <source>A boot script (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;) can be used that automatically starts the application.</source>
          <target state="translated">可以使用启动脚本（请参见 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ）来自动启动应用程序。</target>
        </trans-unit>
        <trans-unit id="919bef16600e113be86a5b24871b84665ab0d813" translate="yes" xml:space="preserve">
          <source>A boot script can be written manually. However, it is recommended to create a boot script by generating it from a release resource file &lt;code&gt;Name.rel&lt;/code&gt;, using the function &lt;code&gt;systools:make_script/1,2&lt;/code&gt;. This requires that the source code is structured as applications according to the OTP design principles. (The program does not have to be started in terms of OTP applications, but can be plain Erlang).</source>
          <target state="translated">引导脚本可以手动编写。但是，建议使用功能 &lt;code&gt;systools:make_script/1,2&lt;/code&gt; 从发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt; 生成启动脚本来创建启动脚本。这就要求根据OTP设计原则将源代码构造为应用程序。（该程序不必根据OTP应用程序启动，而可以是普通的Erlang）。</target>
        </trans-unit>
        <trans-unit id="c5fdc6fd4567d3a558e76cbc7f894eaa5a1c1eee" translate="yes" xml:space="preserve">
          <source>A boot script file has the extension &lt;code&gt;.script&lt;/code&gt;. The runtime system uses a binary version of the script. This &lt;strong&gt;binary boot script&lt;/strong&gt; file has the extension &lt;code&gt;.boot&lt;/code&gt;.</source>
          <target state="translated">引导脚本文件的扩展名为 &lt;code&gt;.script&lt;/code&gt; 。运行时系统使用脚本的二进制版本。该&lt;strong&gt;二进制启动脚本&lt;/strong&gt;文件的扩展名为 &lt;code&gt;.boot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38a18422668a20d746ea102449e8109a669766e" translate="yes" xml:space="preserve">
          <source>A boot script generated using &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; is already transformed to the binary form.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script&lt;/a&gt;&lt;/code&gt; 生成的启动脚本已转换为二进制形式。</target>
        </trans-unit>
        <trans-unit id="4418a28f4bc85f1e896a145b5a8fb062a5cafe33" translate="yes" xml:space="preserve">
          <source>A boot script, &lt;code&gt;Name.boot&lt;/code&gt;</source>
          <target state="translated">引导脚本 &lt;code&gt;Name.boot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506ee8bd04d892c57686f10406bfc1fa492da78c" translate="yes" xml:space="preserve">
          <source>A breakpoint can be either &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. Inactive breakpoints are ignored.</source>
          <target state="translated">断点可以是&lt;strong&gt;活性&lt;/strong&gt;或&lt;strong&gt;无活性&lt;/strong&gt;。不活动的断点将被忽略。</target>
        </trans-unit>
        <trans-unit id="a1dbb3701c56d51053c806657654df88416bde25" translate="yes" xml:space="preserve">
          <source>A breakpoint has the following:</source>
          <target state="translated">断点具有以下特点:</target>
        </trans-unit>
        <trans-unit id="f64f15640358c275e2397b778cc1de26c7a69372" translate="yes" xml:space="preserve">
          <source>A brief example in C of how to set the console control handler:</source>
          <target state="translated">用C语言简单介绍一下如何设置控制台控制处理程序。</target>
        </trans-unit>
        <trans-unit id="f6e88d46ec95e4e6ad69aee75cf44a13d46cf46a" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message being decoded can also have trailing bytes. If those trailing bytes are important, they can be returned along with the decoded value by compiling the ASN.1 specification with option &lt;code&gt;+undec_rest&lt;/code&gt;. The return value from the decoder is &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; where &lt;code&gt;Rest&lt;/code&gt; is a binary containing the trailing bytes.</source>
          <target state="translated">包含正在解码的消息的缓冲区也可以具有尾随字节。如果这些尾随字节很重要，则可以通过使用选项 &lt;code&gt;+undec_rest&lt;/code&gt; 编译ASN.1规范来将它们与解码后的值一起返回。解码器的返回值为 &lt;code&gt;{ok,Value,Rest}&lt;/code&gt; ，其中 &lt;code&gt;Rest&lt;/code&gt; 是一个包含尾随字节的二进制文件。</target>
        </trans-unit>
        <trans-unit id="233c3de16098dc52e49751db996b0afab4a44df9" translate="yes" xml:space="preserve">
          <source>A buffer that holds a message, being decoded it can also have some following bytes. Those following bytes can now be returned together with the decoded value. If an ASN.1 specification is compiled with this option, a tuple &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; is returned. &lt;code&gt;Rest&lt;/code&gt; can be a list or a binary. Earlier versions of the compiler ignored those following bytes.</source>
          <target state="translated">包含消息的缓冲区（被解码）也可以具有以下一些字节。现在可以将这些后续字节与解码后的值一起返回。如果使用此选项编译了ASN.1规范 &lt;code&gt;{ok, Value, Rest}&lt;/code&gt; 则返回元组{ok，Value，Rest}。 &lt;code&gt;Rest&lt;/code&gt; 可以是列表或二进制文件。较早版本的编译器将忽略后面的那些字节。</target>
        </trans-unit>
        <trans-unit id="1919a9845de02d3849d0b2e74c7851b7ee8c5506" translate="yes" xml:space="preserve">
          <source>A built-in function is called.</source>
          <target state="translated">一个内置函数被调用。</target>
        </trans-unit>
        <trans-unit id="99e307ba4f985ee1b328ac24d026a83d768b7e31" translate="yes" xml:space="preserve">
          <source>A call has been made to another transfer function during chunk sending, that is, before a call to &lt;code&gt;send_chunk_end/1&lt;/code&gt;.</source>
          <target state="translated">在块发送期间，即在调用 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 之前，已对另一个传递函数进行了调用。</target>
        </trans-unit>
        <trans-unit id="c058e649153aa49de98647d3ad23a2d22b4f3cbb" translate="yes" xml:space="preserve">
          <source>A call is made to &lt;code&gt;send_chunk/2&lt;/code&gt; or &lt;code&gt;send_chunk_end/1&lt;/code&gt; before a call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">呼叫被制成 &lt;code&gt;send_chunk/2&lt;/code&gt; 或 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 到呼叫之前 &lt;code&gt;send_chunk_start/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74dd8fdb8624f61745c3d9662e7a1e10a90a4feb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;ei&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is &lt;code&gt;[7, current release]&lt;/code&gt;. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">调用 &lt;code&gt;ei_set_compat_rel(release_number)&lt;/code&gt; 会将 &lt;code&gt;ei&lt;/code&gt; 库设置为release &lt;code&gt;release_number&lt;/code&gt; 的兼容模式。 &lt;code&gt;release_number&lt;/code&gt; 的有效范围是 &lt;code&gt;[7, current release]&lt;/code&gt; 。这样就可以与早期版本的Erlang / OTP组件进行通信。</target>
        </trans-unit>
        <trans-unit id="e817aa48e70b9f9cfae211dd9da7a5a9ccf5b654" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; sets the &lt;code&gt;Erl_Interface&lt;/code&gt; library in compatibility mode of release &lt;code&gt;release_number&lt;/code&gt;. Valid range of &lt;code&gt;release_number&lt;/code&gt; is [7, current release]. This makes it possible to communicate with Erlang/OTP components from earlier releases.</source>
          <target state="translated">调用 &lt;code&gt;erl_set_compat_rel(release_number)&lt;/code&gt; &lt;code&gt;Erl_Interface&lt;/code&gt; 库设置为release &lt;code&gt;release_number&lt;/code&gt; 的兼容模式。 &lt;code&gt;release_number&lt;/code&gt; 的有效范围是[7，当前版本]。这样就可以与早期版本的Erlang / OTP组件进行通信。</target>
        </trans-unit>
        <trans-unit id="0712fa3986f50d28ad07c76a65c1ecbb80736c35" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;get_system_memory_data/0&lt;/code&gt; is more costly than a call to &lt;code&gt;get_memory_data/0&lt;/code&gt; as data is collected synchronously when this function is called.</source>
          <target state="translated">与调用 &lt;code&gt;get_system_memory_data/0&lt;/code&gt; 相比，对 &lt;code&gt;get_memory_data/0&lt;/code&gt; 的调用成本更高，因为在调用此函数时会同步收集数据。</target>
        </trans-unit>
        <trans-unit id="2f677dc037cd69c670e9e88e5bc616a216192d94" translate="yes" xml:space="preserve">
          <source>A call to the call-back function &lt;code&gt;F&lt;/code&gt; will be</source>
          <target state="translated">对回调函数 &lt;code&gt;F&lt;/code&gt; 的调用将是</target>
        </trans-unit>
        <trans-unit id="64cfccc0b7ce97122769d167098947b39055c31f" translate="yes" xml:space="preserve">
          <source>A call to validate/2 or validate/3 must provide a well formed parsed XML element &lt;code&gt;#xmlElement{}&lt;/code&gt; and a State, &lt;code&gt;global_state()&lt;/code&gt;, which holds necessary information from an already processed schema. Thus validate enables reuse of the schema information and therefore if one shall validate several times towards the same schema it reduces time consumption.</source>
          <target state="translated">对validate / 2或validate / 3的调用必须提供格式 &lt;code&gt;#xmlElement{}&lt;/code&gt; 已解析XML元素#xmlElement {}和一个State &lt;code&gt;global_state()&lt;/code&gt; ，该元素持有来自已处理模式的必要信息。因此，验证可以重用模式信息，因此，如果一个人必须对同一模式进行多次验证，则可以减少时间消耗。</target>
        </trans-unit>
        <trans-unit id="4d8d381879044ee596ec7ee05db7b89483e7064a" translate="yes" xml:space="preserve">
          <source>A call-back function for user-controlled formatting. See &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种用于用户控制格式的回调函数。参见 &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df69379f9325d6a9fdffa360b63f0ee0eab09db5" translate="yes" xml:space="preserve">
          <source>A callback function that is called when the scanner has found an unquoted atom. If the function returns &lt;code&gt;true&lt;/code&gt;, the unquoted atom itself becomes the category of the token. If the function returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;atom&lt;/code&gt; becomes the category of the unquoted atom.</source>
          <target state="translated">当扫描程序找到未引用的原子时调用的回调函数。如果函数返回 &lt;code&gt;true&lt;/code&gt; ，则未加引号的原子本身将成为令牌的类别。如果函数返回 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;atom&lt;/code&gt; 成为未引用原子的类别。</target>
        </trans-unit>
        <trans-unit id="d91fce55e4034ef8ef725ab8525f555ff39cf2b9" translate="yes" xml:space="preserve">
          <source>A callback interface on top of Common Test.</source>
          <target state="translated">在Common Test基础上的回调接口。</target>
        </trans-unit>
        <trans-unit id="5e9caf8f98e50d5cd26b8f05e66b990f8b3c6d79" translate="yes" xml:space="preserve">
          <source>A callback module can inherit definitions from other callback modules, through the required function &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt;.</source>
          <target state="translated">回调模块可以通过所需的功能 &lt;code&gt;'#xml-interitance#() -&amp;gt; [ModuleName::atom()]&lt;/code&gt; 继承其他回调模块的定义。</target>
        </trans-unit>
        <trans-unit id="fb141abb3a89c44d4c462fec76a604e27632ab05" translate="yes" xml:space="preserve">
          <source>A callback module is a functional module, and for code extensions simple code replacement is sufficient.</source>
          <target state="translated">回调模块是一个功能模块,对于代码扩展简单的代码替换即可。</target>
        </trans-unit>
        <trans-unit id="b46a19092f99a8ba307ae9376469c5315dc6fe6f" translate="yes" xml:space="preserve">
          <source>A callback module to customize the inets HTTP servers behaviour see &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">定制inets HTTP服务器行为的回调模块，请参见 &lt;code&gt;&lt;a href=&quot;httpd_custom_api&quot;&gt;httpd_custom_api&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dc7be0b141d438c4483859c6c7d158a83325e8d" translate="yes" xml:space="preserve">
          <source>A cancelled timetrap is not automatically reactivated after the break, but must be started exlicitly with &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">休息后不会自动重新激活已取消的时间陷阱，但必须使用 &lt;code&gt;&lt;a href=&quot;#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 明确启动。</target>
        </trans-unit>
        <trans-unit id="80902d7e7f7cef8831c2f630fc53d4cb3659cebe" translate="yes" xml:space="preserve">
          <source>A certificate is similar to a driver's license, or a passport. The holder of the certificate is called the &lt;strong&gt;subject&lt;/strong&gt;. The certificate is signed with the private key of the issuer of the certificate. A chain of trust is built by having the issuer in its turn being certified by another certificate, and so on, until you reach the so called root certificate, which is self-signed, that is, issued by itself.</source>
          <target state="translated">证书类似于驾照或护照。证书的持有者称为&lt;strong&gt;主体&lt;/strong&gt;。证书使用证书颁发者的私钥签名。信任链的建立是通过使发行者依次由另一证书进行认证，依此类推，直到您到达所谓的根证书为止，该根证书是自签名的，即由其本身发行。</target>
        </trans-unit>
        <trans-unit id="f2fd43ae2e93cd58a77e25d50c236c265a71aa31" translate="yes" xml:space="preserve">
          <source>A chain of calls is represented by a list of &lt;code&gt;constant()&lt;/code&gt;. The list contains the From vertex of every call and the To vertex of the last call.</source>
          <target state="translated">调用链由 &lt;code&gt;constant()&lt;/code&gt; 列表表示。该列表包含每个调用的&amp;ldquo;自&amp;rdquo;顶点和最后一个调用的&amp;ldquo;至&amp;rdquo;顶点。</target>
        </trans-unit>
        <trans-unit id="85a537a33d3a97006da5ac79a03e13d4e08816a8" translate="yes" xml:space="preserve">
          <source>A chain of module calls from &lt;code&gt;toolbar&lt;/code&gt; to &lt;code&gt;debugger&lt;/code&gt;, if there is such a chain, otherwise &lt;code&gt;false&lt;/code&gt;. The chain of calls is represented by a list of modules, &lt;code&gt;toolbar&lt;/code&gt; being the first element and &lt;code&gt;debugger&lt;/code&gt;the last element.</source>
          <target state="translated">从 &lt;code&gt;toolbar&lt;/code&gt; 到 &lt;code&gt;debugger&lt;/code&gt; 的模块调用链（如果有），否则为 &lt;code&gt;false&lt;/code&gt; 。调用链由模块列表表示， &lt;code&gt;toolbar&lt;/code&gt; 是第一个元素， &lt;code&gt;debugger&lt;/code&gt; 是最后一个元素。</target>
        </trans-unit>
        <trans-unit id="c963de72e2f1d6300c000423f7ebb85156dc2f81" translate="yes" xml:space="preserve">
          <source>A challenge is a 32-bit integer in big-endian order. Below the function &lt;code&gt;gen_challenge()&lt;/code&gt; returns a random 32-bit integer used as a challenge.</source>
          <target state="translated">挑战是大端顺序的32位整数。在函数 &lt;code&gt;gen_challenge()&lt;/code&gt; 下面，返回一个随机的32位整数，用作质询。</target>
        </trans-unit>
        <trans-unit id="39b14f10c5b55097c8101f85c3f9aa51d49c3b22" translate="yes" xml:space="preserve">
          <source>A change in time offset can be observed at slightly different points in time by different processes.</source>
          <target state="translated">时间偏移的变化可以通过不同的过程在稍有不同的时间点观察到。</target>
        </trans-unit>
        <trans-unit id="542fbe84d9ce4598795bc891dcdfd8b000e68f19" translate="yes" xml:space="preserve">
          <source>A character class</source>
          <target state="translated">一个字符类</target>
        </trans-unit>
        <trans-unit id="61e7e6e3a9874a828dada509dcc75ed9b8baa957" translate="yes" xml:space="preserve">
          <source>A character class matches a single character in the subject. In a UTF mode, the character can be more than one data unit long. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is required as a member of the class, ensure that it is not the first character, or escape it with a backslash.</source>
          <target state="translated">字符类匹配主题中的单个字符。在UTF模式下,该字符可以超过一个数据单位长。匹配的字符必须在类所定义的字符集中,除非类定义中的第一个字符是圆周体,在这种情况下,主体字符必须不在类所定义的字符集中。如果类的成员中需要有一个圆括号,确保它不是第一个字符,或者用反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="9c9c4d2679cf888b556f5d6ffced7246bbf40eb2" translate="yes" xml:space="preserve">
          <source>A character preceded by &lt;code&gt;\&lt;/code&gt; loses its special meaning. Note that &lt;code&gt;\&lt;/code&gt; must be written as &lt;code&gt;\\&lt;/code&gt; in a string literal. For example, &quot;\\?*&quot; will match any filename starting with &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;\&lt;/code&gt; 开头的字符失去其特殊含义。请注意， &lt;code&gt;\&lt;/code&gt; 必须在字符串文字中写为 &lt;code&gt;\\&lt;/code&gt; 。例如，&amp;ldquo; \\？*&amp;rdquo;将匹配以 &lt;code&gt;?&lt;/code&gt; 开头的任何文件名。。</target>
        </trans-unit>
        <trans-unit id="142cc4bd716c781df84ea694767d7514165b6796" translate="yes" xml:space="preserve">
          <source>A character with property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">具有属性&lt;strong&gt;xx&lt;/strong&gt;的角色&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf738d3d1defd49ac7c9b392cd81c1e47fcf59d0" translate="yes" xml:space="preserve">
          <source>A character without property &lt;strong&gt;xx&lt;/strong&gt;</source>
          <target state="translated">没有属性&lt;strong&gt;xx&lt;/strong&gt;的角色&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377286b10e032ac7b156b224cfe02d4aa3b5ac8" translate="yes" xml:space="preserve">
          <source>A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and presents a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</source>
          <target state="translated">检查点是系统的一致视图。可以在一组表格上激活一个检查点。然后可以遍历这个检查点,并呈现系统的视图,因为它在检查点被激活时是存在的,即使表格正在或已经被操纵。</target>
        </trans-unit>
        <trans-unit id="edd44bafd2855e97c83bfe1495556b1997dac899" translate="yes" xml:space="preserve">
          <source>A checkpoint is a transaction consistent state that spans over one or more tables. When a checkpoint is activated, the system remembers the current content of the set of tables. The checkpoint retains a transaction consistent state of the tables, allowing the tables to be read and updated while the checkpoint is active. A checkpoint is typically used to back up tables to external media, but they are also used internally in &lt;code&gt;Mnesia&lt;/code&gt; for other purposes. Each checkpoint is independent and a table can be involved in several checkpoints simultaneously.</source>
          <target state="translated">检查点是跨一个或多个表的事务一致状态。激活检查点后，系统会记住表集的当前内容。检查点保留表的事务一致状态，允许在检查点处于活动状态时读取和更新表。检查点通常用于将表备份到外部媒体，但在 &lt;code&gt;Mnesia&lt;/code&gt; 中也内部用于其他目的。每个检查点都是独立的，一个表可以同时包含在多个检查点中。</target>
        </trans-unit>
        <trans-unit id="7af90dbef0975afb7b45bd12517b2d0b310aad09" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is activated and the current node is involved in the checkpoint. Checkpoints can be activated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; or implicitly at backup, when adding table replicas, at internal transfer of data between nodes, and so on. By default this event is ignored.</source>
          <target state="translated">名称为 &lt;code&gt;Checkpoint&lt;/code&gt; 的检查点被激活，并且当前节点包含在该检查点中。可以使用 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint/1&lt;/a&gt;&lt;/code&gt; 函数显式激活检查点，或者在备份时，添加表副本时，在节点之间进行内部数据传输时隐式激活检查点。默认情况下，将忽略此事件。</target>
        </trans-unit>
        <trans-unit id="ce168e38a6f2a63614deb75483a5c4e60dab573e" translate="yes" xml:space="preserve">
          <source>A checkpoint with the name &lt;code&gt;Checkpoint&lt;/code&gt; is deactivated and the current node is involved in the checkpoint. Checkpoints can be deactivated explicitly with the function &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; or implicitly when the last replica of a table (involved in the checkpoint) becomes unavailable, for example, at node-down. By default this event is ignored.</source>
          <target state="translated">名称为 &lt;code&gt;Checkpoint&lt;/code&gt; 的检查点被停用，并且当前节点包含在该检查点中。可以使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate/1&lt;/a&gt;&lt;/code&gt; 显式停用检查点，或者在表的最后一个副本（涉及检查点）不可用时（例如，在node-down时）隐式停用。默认情况下，将忽略此事件。</target>
        </trans-unit>
        <trans-unit id="757093a3c3c4440d97791337c35337b6b5b5acf3" translate="yes" xml:space="preserve">
          <source>A child under a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can be terminated with the following:</source>
          <target state="translated">在 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管下的孩子可以通过以下方式终止：</target>
        </trans-unit>
        <trans-unit id="b0b7cb7b3462b17e43bbfe35864d2ca8d80d92e7" translate="yes" xml:space="preserve">
          <source>A circumflex can conveniently be used with the uppercase character types to specify a more restricted set of characters than the matching lowercase type. For example, class [^\W_] matches any letter or digit, but not underscore, while [\w] includes underscore. A positive character class is to be read as &quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT something AND NOT ...&quot;.</source>
          <target state="translated">绕口令可以方便地与大写字母类型一起使用,以指定比匹配的小写字母类型更受限制的字符集。例如,类[^/W_]匹配任何字母或数字,但不匹配下划线,而[/w]包括下划线。正的字符类应读作 &quot;某物或某物或......&quot;,负的字符类应读作 &quot;非某物和非某物和非......&quot;。</target>
        </trans-unit>
        <trans-unit id="0a95d789d7844b6626f4da863b5eea766e7744a0" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;body&lt;/strong&gt; consists of a sequence of expressions separated by comma (,):</source>
          <target state="translated">子句&lt;strong&gt;主体&lt;/strong&gt;由用逗号（，）分隔的一系列表达式组成：</target>
        </trans-unit>
        <trans-unit id="19e13c276c19b62374e61b0b7fc25118ed9d5cf8" translate="yes" xml:space="preserve">
          <source>A clause &lt;strong&gt;head&lt;/strong&gt; consists of the function name, an argument list, and an optional guard sequence beginning with the keyword &lt;code&gt;when&lt;/code&gt;:</source>
          <target state="translated">有一条&lt;strong&gt;头&lt;/strong&gt;由函数名，参数列表，以及一个可选的保护序列开始与关键字的 &lt;code&gt;when&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58a6114240a04a860a349454adf52142f50d9abd" translate="yes" xml:space="preserve">
          <source>A clause C is one of the following:</source>
          <target state="translated">C项属于下列条款之一。</target>
        </trans-unit>
        <trans-unit id="d1f7a0040d46c009ca43441ed2b3e8cecbe10566" translate="yes" xml:space="preserve">
          <source>A client application that is dependent on the SNMP manager will use this function in order to be notified of when the manager has started. There are two situations when this is useful:</source>
          <target state="translated">依赖于SNMP管理器的客户端应用程序将使用此功能,以便通知管理器何时启动。在两种情况下,这个功能是有用的。</target>
        </trans-unit>
        <trans-unit id="92b63c3639a0d3be7790653a4cf98a0c37efe2e2" translate="yes" xml:space="preserve">
          <source>A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit. If the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus, the following matches at least three successive vowels, but can match many more:</source>
          <target state="translated">收尾括号本身不是特殊字符。如果第二个数字被省略,但逗号存在,则没有上限。如果第二个数字和逗号都被省略,那么量化符就会指定所需匹配的确切数量。因此,下面至少要匹配三个连续的元音,但可以匹配更多。</target>
        </trans-unit>
        <trans-unit id="5df59142009d0a2f0174628ac8c696397e059c32" translate="yes" xml:space="preserve">
          <source>A collection of annotations.</source>
          <target state="translated">注释的集合。</target>
        </trans-unit>
        <trans-unit id="03e8d201bb4d1ea3a3e042cc7f432a7b21d3da31" translate="yes" xml:space="preserve">
          <source>A collection of list processing functions can be found in the &lt;code&gt;lists&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">列表处理功能的集合可以在STDLIB 的 &lt;code&gt;lists&lt;/code&gt; 手册页中找到。</target>
        </trans-unit>
        <trans-unit id="0cdd7d34c0f5f7115114bd571785b83e151e658b" translate="yes" xml:space="preserve">
          <source>A collection of maps processing functions can be found in &lt;code&gt;maps&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">可以在STDLIB的 &lt;code&gt;maps&lt;/code&gt; 手册页中找到地图处理功能的集合。</target>
        </trans-unit>
        <trans-unit id="c3e3cce83083c2f4eda9342971b0fd43678fa41c" translate="yes" xml:space="preserve">
          <source>A collection of mathematical functions that return floats. Arguments are numbers.</source>
          <target state="translated">返回浮点数的数学函数集合。参数是数字。</target>
        </trans-unit>
        <trans-unit id="605e87ed4414816e773ab8b3750564d7de25784e" translate="yes" xml:space="preserve">
          <source>A collection of open disk logs with the same name running on different nodes is said to be a &lt;strong&gt;distributed disk log&lt;/strong&gt; if requests made to any of the logs are automatically made to the other logs as well. The members of such a collection are called individual distributed disk logs, or just distributed disk logs if there is no risk of confusion. There is no order between the members of such a collection. For example, logged terms are not necessarily written to the node where the request was made before written to the other nodes. However, a few functions do not make requests to all members of distributed disk logs, namely &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果对任何一个&lt;strong&gt;日志的&lt;/strong&gt;请求也自动向其他日志发出，则在不同节点上运行的同名打开磁盘日志的集合被称为&lt;strong&gt;分布式磁盘日志&lt;/strong&gt;。这样的集合的成员称为单独的分布式磁盘日志，如果没有混淆的风险，则称为分布式磁盘日志。这样的集合的成员之间没有顺序。例如，记录的术语在写入其他节点之前不一定要写入发出请求的节点。但是，一些功能不会向分布式磁盘日志的所有成员发出请求，即 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#chunk-2&quot;&gt;chunk/2,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#chunk_step-3&quot;&gt;chunk_step/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#lclose-1&quot;&gt;lclose/1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c28e602c295299b55b61e9e0432393728a24bb97" translate="yes" xml:space="preserve">
          <source>A collection of test cases, generally with a specific, common target for testing, such as a single function, module, or subsystem. A test suite may also be recursively composed by smaller test suites.</source>
          <target state="translated">测试用例的集合,通常有一个特定的、共同的测试目标,如一个函数、模块或子系统。一个测试套件也可以由更小的测试套件递归组成。</target>
        </trans-unit>
        <trans-unit id="1465092184b8e8294117483f6254c408114fee45" translate="yes" xml:space="preserve">
          <source>A command file for restarting a service looks as follows:</source>
          <target state="translated">重新启动服务的命令文件如下。</target>
        </trans-unit>
        <trans-unit id="9252c2a7f2a4db9009910e3b44326441724181d8" translate="yes" xml:space="preserve">
          <source>A common interoperability situation is when you want to incorporate a piece of code, solving a complex problem, in your Erlang program. Suppose for example, that you have the following C functions that you would like to call from Erlang:</source>
          <target state="translated">一个常见的互操作性情况是,当你想在你的Erlang程序中加入一段代码,解决一个复杂的问题。例如,假设你有以下的C函数,你想从Erlang中调用。</target>
        </trans-unit>
        <trans-unit id="b06198c1c89c922d52dc5340ce3b2b05bb39280d" translate="yes" xml:space="preserve">
          <source>A common method of identifying encoding in text files is to put a Byte Order Mark (BOM) first in the file. The BOM is the code point 16#FEFF encoded in the same way as the remaining file. If such a file is to be read, the first few bytes (depending on encoding) are not part of the text. This code outlines how to open a file that is believed to have a BOM, and sets the files encoding and position for further sequential reading (preferably using the &lt;code&gt;io&lt;/code&gt; module).</source>
          <target state="translated">识别文本文件中编码的一种常用方法是在文件中首先放置一个字节顺序标记（BOM）。BOM是代码点16＃FEFF，其编码方式与其余文件相同。如果要读取这样的文件，则前几个字节（取决于编码）不是文本的一部分。此代码概述了如何打开被认为具有BOM的文件，并设置了文件编码和位置以进行进一步的顺序读取（最好使用 &lt;code&gt;io&lt;/code&gt; 模块）。</target>
        </trans-unit>
        <trans-unit id="5647ae6e936ad55169d59c790e8343814c809ae6" translate="yes" xml:space="preserve">
          <source>A common situation in more complex systems is that the data in a table is distributed. Different table rows are implemented in different places. Some SNMP tool-kits dedicate an SNMP sub-agent for each part of the table and load the corresponding MIB into all sub-agents. The Master Agent is responsible for presenting the distributed table as a single table to the manager. The toolkit supplied uses a different method.</source>
          <target state="translated">在比较复杂的系统中,常见的情况是表内的数据是分布式的。不同的表行在不同的地方实现。一些SNMP工具箱为表的每一部分专门设置一个SNMP子代理,并将相应的MIB加载到所有子代理中。主代理负责将分布式表作为一张表呈现给管理者。所提供的工具包使用的是不同的方法。</target>
        </trans-unit>
        <trans-unit id="c7eeae65f0479a03e33632169a4331231e0f176a" translate="yes" xml:space="preserve">
          <source>A common way to send a zero-terminated string to a port is the following:</source>
          <target state="translated">向 port 发送零结尾字符串的常见方法如下。</target>
        </trans-unit>
        <trans-unit id="a45a7f5aa5a20b6c21f0a78bd8f6845034a8417e" translate="yes" xml:space="preserve">
          <source>A compile-time error, for example a syntax error, does not cause much trouble as it is caught by the compiler.</source>
          <target state="translated">编译时的错误,例如语法错误,不会造成太多麻烦,因为它被编译器发现了。</target>
        </trans-unit>
        <trans-unit id="b4602d9b41e423bca7841f2df941cffa70742972" translate="yes" xml:space="preserve">
          <source>A compiled MIB for SNMP. It generates a &lt;code&gt;.hrl&lt;/code&gt; file.</source>
          <target state="translated">SNMP的已编译MIB。它生成一个 &lt;code&gt;.hrl&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f5f98caa0ae9cf0f1bdae4ba51cfa598afa6c9ca" translate="yes" xml:space="preserve">
          <source>A compiled match specification.</source>
          <target state="translated">编制的匹配规范。</target>
        </trans-unit>
        <trans-unit id="9d939a33ffd17f021de49031e6a1518334f87b64" translate="yes" xml:space="preserve">
          <source>A compiled regular expression</source>
          <target state="translated">编译的正则表达式</target>
        </trans-unit>
        <trans-unit id="f8e9759655ec875d9026034a3b0994a59f1ef864" translate="yes" xml:space="preserve">
          <source>A compiled regular expression and the options for running it</source>
          <target state="translated">编译后的正则表达式和运行它的选项。</target>
        </trans-unit>
        <trans-unit id="d4c9209a41f5a084f05f289c557f295094459659" translate="yes" xml:space="preserve">
          <source>A completly different storage could be interfaced by writing call-back modules using the behaviours &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt;. A callback module is installed with the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; to the client and/or the daemon.</source>
          <target state="translated">通过使用行为 &lt;code&gt;&lt;a href=&quot;ssh_client_key_api&quot;&gt;ssh_client_key_api&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;ssh_server_key_api&quot;&gt;ssh_server_key_api&lt;/a&gt;&lt;/code&gt; 编写回调模块，可以实现完全不同的存储接口。带有选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 的回调模块将安装到客户端和/或守护程序。</target>
        </trans-unit>
        <trans-unit id="952ff2aeda160eb34af5c137f617385ffdf99591" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 的组件不存在。</target>
        </trans-unit>
        <trans-unit id="246870fe4fc14eed479b16bbb7b62bf284297f4b" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 的组件不是目录。在某些平台上，返回 &lt;code&gt;enoent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="402962cd392724e5760c55baa6887c10aa95a217" translate="yes" xml:space="preserve">
          <source>A component of &lt;code&gt;Dir&lt;/code&gt; is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 的组件不是目录。在某些平台上，将返回 &lt;code&gt;enoent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60b48fcc9f23ddcda04bff0fa0292b7348897642" translate="yes" xml:space="preserve">
          <source>A component of the filename does not exist.</source>
          <target state="translated">文件名的一个组成部分不存在。</target>
        </trans-unit>
        <trans-unit id="135c8c2d97ee75d613c98cc3cf13f66a7bede390" translate="yes" xml:space="preserve">
          <source>A component of the filename is not a directory. On some platforms, &lt;code&gt;enoent&lt;/code&gt; is returned instead.</source>
          <target state="translated">文件名的组成部分不是目录。在某些平台上，将返回 &lt;code&gt;enoent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="821747f02cfeb9e5714e2b19ea3b50b461a99dfe" translate="yes" xml:space="preserve">
          <source>A compression level can be specified by giving option &lt;code&gt;{compressed, Level}&lt;/code&gt;. &lt;code&gt;Level&lt;/code&gt; is an integer with range 0..9, where:</source>
          <target state="translated">可以通过提供选项 &lt;code&gt;{compressed, Level}&lt;/code&gt; 来指定压缩级别。 &lt;code&gt;Level&lt;/code&gt; 是一个整数，范围为0..9，其中：</target>
        </trans-unit>
        <trans-unit id="d0e574bf3fa3da4f1323956974511982101a1711" translate="yes" xml:space="preserve">
          <source>A concept of table fragmentation has been introduced to cope with large tables. The idea is to split a table into several manageable fragments. Each fragment is implemented as a first class &lt;code&gt;Mnesia&lt;/code&gt; table and can be replicated, have indexes, and so on, as any other table. But the tables cannot have &lt;code&gt;local_content&lt;/code&gt; or have the &lt;code&gt;snmp&lt;/code&gt; connection activated.</source>
          <target state="translated">表碎片化的概念已被引入以应对大型表。这个想法是将一个表分成几个可管理的片段。每个片段都作为第一类 &lt;code&gt;Mnesia&lt;/code&gt; 表实现，并且可以像其他任何表一样被复制，具有索引等。但是表不能具有 &lt;code&gt;local_content&lt;/code&gt; 或没有激活 &lt;code&gt;snmp&lt;/code&gt; 连接。</target>
        </trans-unit>
        <trans-unit id="e49ca9c3184442cd50035d353e0e9f2682e7441b" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint calling &lt;code&gt;c_test:c_break/1&lt;/code&gt; is added at line 6 in module &lt;code&gt;fact&lt;/code&gt;. Each time the breakpoint is reached, the function is called. When &lt;code&gt;N&lt;/code&gt; is equal to 3, the function returns &lt;code&gt;true&lt;/code&gt; and the process stops.</source>
          <target state="translated">在模块 &lt;code&gt;fact&lt;/code&gt; 的第6行中添加了一个调用 &lt;code&gt;c_test:c_break/1&lt;/code&gt; 的条件断点。每次到达断点时，都会调用该函数。当 &lt;code&gt;N&lt;/code&gt; 等于3时，该函数返回 &lt;code&gt;true&lt;/code&gt; ，并且过程停止。</target>
        </trans-unit>
        <trans-unit id="420493b84dd5c17e043c6b4089d0760ab787da6f" translate="yes" xml:space="preserve">
          <source>A conditional breakpoint is created at a certain line in the module, but a process reaching the breakpoint stops only if a specified condition is true.</source>
          <target state="translated">在模块中的某一行创建了一个条件断点,但只有当指定的条件为真时,到达断点的进程才会停止。</target>
        </trans-unit>
        <trans-unit id="f2032c66ce1d764483fb75f184dda9191dfa8a90" translate="yes" xml:space="preserve">
          <source>A configuration example:</source>
          <target state="translated">一个配置实例。</target>
        </trans-unit>
        <trans-unit id="fca2493f0bfcfddaa7857841304efa4715628d65" translate="yes" xml:space="preserve">
          <source>A configuration file can contain any number of elements of the type:</source>
          <target state="translated">一个配置文件可以包含任意数量的类型元素。</target>
        </trans-unit>
        <trans-unit id="78ca415df4713a5dc750b7b27876e4c151d1fefd" translate="yes" xml:space="preserve">
          <source>A configuration file for using the FTP client to access files on a remote host can look as follows:</source>
          <target state="translated">使用FTP客户端访问远程主机上的文件的配置文件可以如下所示。</target>
        </trans-unit>
        <trans-unit id="1c3a7bd9523a05d54af1d3003cdb3950dec94457" translate="yes" xml:space="preserve">
          <source>A configuration file is created or extended with &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt;. Configuration files are binary files and can therefore only be read and written with functions provided by &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ttb#write_config-2&quot;&gt;ttb:write_config/2,3&lt;/a&gt;&lt;/code&gt; 创建或扩展配置文件。配置文件是二进制文件，因此只能使用 &lt;code&gt;ttb&lt;/code&gt; 提供的功能进行读写。</target>
        </trans-unit>
        <trans-unit id="671d2cc5723fde16b3b1db23f40f7f8a98edafae" translate="yes" xml:space="preserve">
          <source>A configuration is created in the following way:</source>
          <target state="translated">配置的创建方式如下。</target>
        </trans-unit>
        <trans-unit id="c8ccb5edfb531730a93bb64572c6648008c39609" translate="yes" xml:space="preserve">
          <source>A configuration key which exists in a configuration file</source>
          <target state="translated">存在于配置文件中的配置密钥</target>
        </trans-unit>
        <trans-unit id="390f275edabaf65d38db27499e0d752ebcf76daa" translate="yes" xml:space="preserve">
          <source>A confirmation that the test has started and information about how many test cases are executed in total.</source>
          <target state="translated">确认测试已经开始,以及关于总共有多少测试用例被执行的信息。</target>
        </trans-unit>
        <trans-unit id="16cfc1e11c18feed4f6e01ecf44d3ed97a53d652" translate="yes" xml:space="preserve">
          <source>A confirmation when the test run is complete.</source>
          <target state="translated">测试运行完成后的确认。</target>
        </trans-unit>
        <trans-unit id="a8db6e97290afb25f8da08685474a76274ab963c" translate="yes" xml:space="preserve">
          <source>A connected socket (or accepted socket) in &lt;code&gt;command&lt;/code&gt; mode mentioned earlier.</source>
          <target state="translated">前面提到的在 &lt;code&gt;command&lt;/code&gt; 模式下连接的套接字（或可接受的套接字）。</target>
        </trans-unit>
        <trans-unit id="b989a34ee0dda9766c669da2f15eb2969efbeba6" translate="yes" xml:space="preserve">
          <source>A connected socket returned from &lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; inherits the &lt;code&gt;show_econnreset&lt;/code&gt; setting from the listening socket.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;gen_tcp#accept-1&quot;&gt;gen_tcp:accept/1&lt;/a&gt;&lt;/code&gt; 返回的已连接套接字从侦听套接字继承了 &lt;code&gt;show_econnreset&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="16798b95a6178eace7c7e27d49d5ae81b52eea7c" translate="yes" xml:space="preserve">
          <source>A connecting transport is attempting to establish/reestablish a transport connection with a peer following &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 到期后，连接传输正在尝试与对等方建立 /重新建立传输连接。</target>
        </trans-unit>
        <trans-unit id="2de4335ce6ca183161a25e425035c54728e74d6f" translate="yes" xml:space="preserve">
          <source>A connection can be associated with a target name and/or a handle. If &lt;code&gt;Connection&lt;/code&gt; has no associated target name, it can only be closed with the handle value (see &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">连接可以与目标名称和/或句柄相关联。如果 &lt;code&gt;Connection&lt;/code&gt; 没有关联的目标名称，则只能使用句柄值将其关闭（请参阅 &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:open/4&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84ef649954a73cf1383ab5bc1d54652a8c9eadd0" translate="yes" xml:space="preserve">
          <source>A connection is closed by simply closing the socket. For information about how to close the socket gracefully (when there are outgoing packets before close), see the relevant system documentation.</source>
          <target state="translated">通过简单地关闭套接字来关闭连接。关于如何优雅地关闭套接字(当关闭前有外发数据包时),请参见相关系统文档。</target>
        </trans-unit>
        <trans-unit id="17e6c50bbb1f711f9fede53cf0df05d82936b396" translate="yes" xml:space="preserve">
          <source>A connection may be established in several ways:</source>
          <target state="translated">可以通过多种方式建立连接。</target>
        </trans-unit>
        <trans-unit id="a37d94bb6ad00988b64d647642ebc7cb8c0abb3c" translate="yes" xml:space="preserve">
          <source>A connection to the node is already active, which either means that node &lt;code&gt;A&lt;/code&gt; is confused or that the TCP connection breakdown of a previous node with this name has not yet reached node &lt;code&gt;B&lt;/code&gt;. See step 3B below.</source>
          <target state="translated">到节点A连接已经处于活动状态，其或者意味着节点 &lt;code&gt;A&lt;/code&gt; 混乱或具有该名称的前一节点的TCP连接击穿尚未达到节点 &lt;code&gt;B&lt;/code&gt; 。请参阅下面的步骤3B。</target>
        </trans-unit>
        <trans-unit id="c7ac923ae2612ff651e35e68a8cf52b6bfffc763" translate="yes" xml:space="preserve">
          <source>A consequence of the rules for importing variables into a list comprehensions is that certain pattern matching operations must be moved into the filters and cannot be written directly in the generators.</source>
          <target state="translated">将变量导入列表理解的规则带来的一个后果是,某些模式匹配操作必须移到过滤器中,而不能直接写入生成器中。</target>
        </trans-unit>
        <trans-unit id="13bd8527f949ed0966879c517d0b7fc761771b34" translate="yes" xml:space="preserve">
          <source>A constant value &lt;code&gt;H&lt;/code&gt; for the topmost &lt;code&gt;32-N&lt;/code&gt; bits of of 32-bit End-to-End and Hop-by-Hop Identifiers generated by the service, either explicitly or as a return value of a function to be evaluated at &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. In particular, an identifier &lt;code&gt;Id&lt;/code&gt; is mapped to a new identifier as follows.</source>
          <target state="translated">由服务生成的32位端到端标识符和逐跳标识符的最高 &lt;code&gt;32-N&lt;/code&gt; 位的常量 &lt;code&gt;H&lt;/code&gt; ，无论是显式的还是作为要在 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 上求值的函数的返回值。具体地，如下将标识符 &lt;code&gt;Id&lt;/code&gt; 映射到新标识符。</target>
        </trans-unit>
        <trans-unit id="18d886af02e0496aa48e2b5d6a6f92d0202ac37e" translate="yes" xml:space="preserve">
          <source>A container for incoming and outgoing Diameter messages. Fields have the following types.</source>
          <target state="translated">接收和发送Diameter消息的容器。字段有以下类型:</target>
        </trans-unit>
        <trans-unit id="b1dd9fe6f6d7543e1cad9aacae9f7f895fe2c259" translate="yes" xml:space="preserve">
          <source>A context is a collection of management information accessible by an SNMP entity. An instance of a management object may exist in more than one context. An SNMP entity potentially has access to many contexts.</source>
          <target state="translated">上下文是SNMP实体可访问的管理信息的集合。一个管理对象的实例可能存在于一个以上的上下文中。一个SNMP实体有可能访问许多上下文。</target>
        </trans-unit>
        <trans-unit id="734dc478d1f1465863bbde8232d6c6d77c880f57" translate="yes" xml:space="preserve">
          <source>A continuation as returned by &lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#fread-3&quot;&gt;fread/3&lt;/a&gt;&lt;/code&gt; 返回的继续。</target>
        </trans-unit>
        <trans-unit id="e6381830ad9a3607ffa3055f5bcf56d4da1d20cb" translate="yes" xml:space="preserve">
          <source>A convenient way to specify arguments to Erlang is to use environment variable &lt;code&gt;ERL_FLAGS&lt;/code&gt;. All the flags needed to use the SSL/TLS distribution can be specified in that variable and are then interpreted as command-line arguments for all subsequent invocations of Erlang.</source>
          <target state="translated">指定Erlang参数的简便方法是使用环境变量 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 。可以在该变量中指定使用SSL / TLS分发所需的所有标志，然后将其解释为所有后续Erlang调用的命令行参数。</target>
        </trans-unit>
        <trans-unit id="1ca49f6e451d0d84b06716dddb10383b5981e929" translate="yes" xml:space="preserve">
          <source>A correctly encoded map cannot have duplicate keys.</source>
          <target state="translated">一个正确编码的地图不能有重复的密钥。</target>
        </trans-unit>
        <trans-unit id="d121637a1d8220cf7197c40025c0f7398d773f8f" translate="yes" xml:space="preserve">
          <source>A cross configuration file can be passed to &lt;code&gt;otp_build configure&lt;/code&gt; using the &lt;code&gt;--xcomp-conf&lt;/code&gt; command line argument. Note that &lt;code&gt;configure&lt;/code&gt; does not accept this command line argument. When using the &lt;code&gt;configure&lt;/code&gt; script directly, pass the configuration variables as arguments to &lt;code&gt;configure&lt;/code&gt; using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax. Variables can also be passed as environment variables to &lt;code&gt;configure&lt;/code&gt;. However, if you pass the configuration in the environment, make sure to unset all of these environment variables before invoking &lt;code&gt;make&lt;/code&gt;; otherwise, the environment variables might set make variables in some applications, or parts of some applications, and you may end up with an erroneously configured build.</source>
          <target state="translated">可以使用 &lt;code&gt;--xcomp-conf&lt;/code&gt; 命令行参数将交叉配置文件传递给 &lt;code&gt;otp_build configure&lt;/code&gt; 。请注意， &lt;code&gt;configure&lt;/code&gt; 不接受此命令行参数。当使用 &lt;code&gt;configure&lt;/code&gt; 直接脚本，通过配置变量作为自变量，以 &lt;code&gt;configure&lt;/code&gt; 使用 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 语法。变量也可以作为环境变量进行传递以进行 &lt;code&gt;configure&lt;/code&gt; 。但是，如果您在环境中传递配置，请确保在调用 &lt;code&gt;make&lt;/code&gt; 之前取消设置所有这些环境变量。;否则，环境变量可能会在某些应用程序或某些应用程序的某些部分中设置make变量，并且最终可能会导致配置错误。</target>
        </trans-unit>
        <trans-unit id="d1583ce679c6d2d53d418e62301c75ea7be08c45" translate="yes" xml:space="preserve">
          <source>A current restriction, which currently results in a warning (not an error) by the compiler, is that the domains of the argument types cannot overlap. For example, the following specification results in a warning:</source>
          <target state="translated">当前的一个限制,目前导致编译器发出警告(而不是错误),就是参数类型的域不能重叠。例如,下面的规范会导致一个警告。</target>
        </trans-unit>
        <trans-unit id="88d09c4bad655176f525dc30f98c229dc5d52beb" translate="yes" xml:space="preserve">
          <source>A customized prompt function is stated as a tuple &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt;. The function is called as &lt;code&gt;Mod:Func(L)&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is a list of key-value pairs created by the shell. Currently there is only one pair: &lt;code&gt;{history, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the current command number. The function is to return a list of characters or an atom. This constraint is because of the Erlang I/O protocol. Unicode characters beyond code point 255 are allowed in the list and the atom. Notice that in restricted mode the call &lt;code&gt;Mod:Func(L)&lt;/code&gt; must be allowed or the default shell prompt function is called.</source>
          <target state="translated">自定义的提示功能表示为元组 &lt;code&gt;{Mod,&amp;nbsp;Func}&lt;/code&gt; 。该函数称为 &lt;code&gt;Mod:Func(L)&lt;/code&gt; ，其中 &lt;code&gt;L&lt;/code&gt; 是由外壳创建的键值对的列表。当前只有一对： &lt;code&gt;{history, N}&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是当前命令号。函数是返回字符或原子的列表。该约束是由于Erlang I / O协议引起的。列表和原子中允许使用超出代码点255的Unicode字符。请注意，在受限模式下，必须允许调用 &lt;code&gt;Mod:Func(L)&lt;/code&gt; 或调用默认的shell提示函数。</target>
        </trans-unit>
        <trans-unit id="8c9abdbda17aa95d8e0108392fe6c0db5b6c523d" translate="yes" xml:space="preserve">
          <source>A database schema must be initiated, using the function &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须使用功能 &lt;code&gt;&lt;a href=&quot;mnesia#create_schema-1&quot;&gt;mnesia:create_schema/1&lt;/a&gt;&lt;/code&gt; 启动数据库模式。</target>
        </trans-unit>
        <trans-unit id="49e3317b1ebd7518e2b7a6cb468c8efab693a0e3" translate="yes" xml:space="preserve">
          <source>A decimal integer is expected.</source>
          <target state="translated">希望有一个十进制的整数。</target>
        </trans-unit>
        <trans-unit id="c1c59bae41554e9820138c5a12e4fa4d04d13249" translate="yes" xml:space="preserve">
          <source>A default set of socket &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; is used. In particular, the socket is opened in &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode, with SockType &lt;code&gt;seqpacket&lt;/code&gt;, and with reasonably large &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; and driver &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用一组默认的套接字 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;options&lt;/a&gt;&lt;/code&gt; 。特别是，套接字使用SockType &lt;code&gt;seqpacket&lt;/code&gt; 以及相当大的 &lt;code&gt;&lt;a href=&quot;inet#option-sndbuf&quot;&gt;kernel&lt;/a&gt;&lt;/code&gt; 和驱动程序 &lt;code&gt;&lt;a href=&quot;inet#option-buffer&quot;&gt;buffers&lt;/a&gt;&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;#option-binary&quot;&gt;binary&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; 模式打开。</target>
        </trans-unit>
        <trans-unit id="0a0192ce6ab3cadd73202466e0233a173404e218" translate="yes" xml:space="preserve">
          <source>A definition has normally a status field. When the status field has the value deprecated, then the MIB-compiler will ignore this definition. With the MIB-compiler option &lt;code&gt;{deprecated,true}&lt;/code&gt; the MIB-compiler does not ignore the deprecated definitions.</source>
          <target state="translated">定义通常具有一个状态字段。当status字段的值已弃用时，MIB编译器将忽略此定义。使用MIB-compiler选项 &lt;code&gt;{deprecated,true}&lt;/code&gt; ，MIB-compiler不会忽略不推荐使用的定义。</target>
        </trans-unit>
        <trans-unit id="08538f938c9e3f97e154e5c1ebc56ab69364db2a" translate="yes" xml:space="preserve">
          <source>A department is managed by an employee, hence the &lt;code&gt;manager&lt;/code&gt; relationship.</source>
          <target state="translated">部门由员工管理，因此是 &lt;code&gt;manager&lt;/code&gt; 关系。</target>
        </trans-unit>
        <trans-unit id="534a5700b1818fc0d3d69084b7c41aaeecf9a10e" translate="yes" xml:space="preserve">
          <source>A destroyed key is very likely to be reused soon. Therefore, if you fail to clear the thread-specific data using this key in a thread before destroying the key, you will &lt;strong&gt;very likely&lt;/strong&gt; get unexpected errors in other parts of the system.</source>
          <target state="translated">销毁的密钥很可能很快会被重用。因此，如果您在销毁密钥之前未能使用该密钥在线程中清除特定于线程的数据，则&lt;strong&gt;很可能&lt;/strong&gt;在系统的其他部分收到意外错误。</target>
        </trans-unit>
        <trans-unit id="6c06f3920fbc20d8a33902857e2e1dbbe9185ab8" translate="yes" xml:space="preserve">
          <source>A diameter service, as configured with &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, specifies one or more supported Diameter applications. Each Diameter application specifies a dictionary module that knows how to encode and decode its messages and AVPs. The dictionary module is in turn generated from a file that defines these messages and AVPs. The format of such a file is defined in &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; below. Users add support for their specific applications by creating dictionary files, compiling them to Erlang modules using either &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; and configuring the resulting dictionaries modules on a service.</source>
          <target state="translated">直径服务（由 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 配置）指定一个或多个受支持的直径应用。每个Diameter应用程序都指定一个字典模块，该模块知道如何编码和解码其消息和AVP。字典模块又从定义这些消息和AVP的文件中生成。此类 &lt;code&gt;&lt;a href=&quot;#FILE_FORMAT&quot;&gt;FILE FORMAT&lt;/a&gt;&lt;/code&gt; 在下面的&amp;ldquo; 文件格式&amp;rdquo;中定义。用户可以通过创建字典文件，使用 &lt;code&gt;&lt;a href=&quot;diameter_make&quot;&gt;diameter_make(3)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc(1)&lt;/a&gt;&lt;/code&gt; 或直径_make（3）将它们编译到Erlang模块并在服务上配置结果字典模块来增加对特定应用程序的支持。</target>
        </trans-unit>
        <trans-unit id="7a9137875cffe6b05cd927e970323d3a0b3eea26" translate="yes" xml:space="preserve">
          <source>A dictionary file consists of distinct sections. Each section starts with a tag followed by zero or more arguments and ends at the the start of the next section or end of file. Tags consist of an ampersand character followed by a keyword and are separated from their arguments by whitespace. Whitespace separates individual tokens but is otherwise insignificant.</source>
          <target state="translated">一个字典文件由不同的部分组成。每一节以一个标签开始,后面跟着零个或多个参数,并在下一节的开始或文件的结束处结束。标签由一个安培字符和一个关键字组成,并与它们的参数用空格隔开。空格分隔单个标记,但在其他方面并不重要。</target>
        </trans-unit>
        <trans-unit id="5e33a8495150bb32e7f8b820523060366bf248c7" translate="yes" xml:space="preserve">
          <source>A difference is how messages are sent to a registered process on another node:</source>
          <target state="translated">不同的是如何将消息发送到另一个节点上的注册进程。</target>
        </trans-unit>
        <trans-unit id="94b01ef26ce08428a3ba5531da74cc6167159294" translate="yes" xml:space="preserve">
          <source>A digest is a (16 bytes) MD5 hash of the challenge (as text) concatenated with the cookie (as text). Below, the function &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; generates a digest as described above.</source>
          <target state="translated">摘要是质询（作为文本）与cookie（作为文本）连接的MD5哈希（16字节）。下面，函数 &lt;code&gt;gen_digest(Challenge, Cookie)&lt;/code&gt; 如上所述生成摘要。</target>
        </trans-unit>
        <trans-unit id="97a4d843c861dcb7b6c4243c19ad5c6f32cf1f75" translate="yes" xml:space="preserve">
          <source>A digraph as returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0,1&lt;/a&gt;&lt;/code&gt; 返回的有向图。</target>
        </trans-unit>
        <trans-unit id="92134ca8f685d563f60794a6f2cd96898218a3f1" translate="yes" xml:space="preserve">
          <source>A direct one-to-one mapping can be established between Mnesia tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between Mnesia and SNMP makes it simple and convenient to achieve this mapping.</source>
          <target state="translated">Mnesia表和SNMP表之间可以建立直接的一对一映射。许多电信应用都是通过SNMP协议来控制和监控的。Mnesia和SNMP之间的这种连接使得实现这种映射变得简单方便。</target>
        </trans-unit>
        <trans-unit id="5a14fb204056be345e895dd5aa7d44f25878907a" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; is created, where the &lt;code&gt;.rel&lt;/code&gt; file, the boot script &lt;code&gt;start.boot&lt;/code&gt;, the system configuration file &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt; are placed. For applications with new version numbers, the application directories are placed under &lt;code&gt;$ROOT/lib&lt;/code&gt;. Unchanged applications are not affected.</source>
          <target state="translated">将创建目录 &lt;code&gt;$ROOT/lib/releases/Vsn&lt;/code&gt; ，其中放置 &lt;code&gt;.rel&lt;/code&gt; 文件，引导脚本 &lt;code&gt;start.boot&lt;/code&gt; ，系统配置文件 &lt;code&gt;sys.config&lt;/code&gt; 和 &lt;code&gt;relup&lt;/code&gt; 。对于具有新版本号的应用程序，应用程序目录位于 &lt;code&gt;$ROOT/lib&lt;/code&gt; 。不变的应用程序不受影响。</target>
        </trans-unit>
        <trans-unit id="b6621117e99280c08a6a5c251265a94569f71ef2" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;releases&lt;/code&gt; is also included in the release package, containing &lt;code&gt;Name.rel&lt;/code&gt; and a subdirectory &lt;code&gt;RelVsn&lt;/code&gt;. &lt;code&gt;RelVsn&lt;/code&gt; is the release version as specified in &lt;code&gt;Name.rel&lt;/code&gt;.</source>
          <target state="translated">目录 &lt;code&gt;releases&lt;/code&gt; 也被包括在发布包，含有 &lt;code&gt;Name.rel&lt;/code&gt; 和子目录 &lt;code&gt;RelVsn&lt;/code&gt; 。 &lt;code&gt;RelVsn&lt;/code&gt; 是符合规定的发行版 &lt;code&gt;Name.rel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4500d0e224c17fb948b0cb9c7625fe0de15c6f3" translate="yes" xml:space="preserve">
          <source>A directory containing one or more test suite modules, that is, a group of test suites.</source>
          <target state="translated">一个包含一个或多个测试套件模块的目录,也就是一组测试套件。</target>
        </trans-unit>
        <trans-unit id="e1df29d5aaa8b080fbaa691c505a19d49ce3028b" translate="yes" xml:space="preserve">
          <source>A dirty CPU scheduler thread.</source>
          <target state="translated">一个肮脏的CPU调度线程。</target>
        </trans-unit>
        <trans-unit id="ac9d98b43f6ed325d229760f35e5424d98091c99" translate="yes" xml:space="preserve">
          <source>A dirty I/O scheduler thread.</source>
          <target state="translated">一个肮脏的I/O调度线程。</target>
        </trans-unit>
        <trans-unit id="bf9457e20d0f94d641c3b38efb00a54afdb0494c" translate="yes" xml:space="preserve">
          <source>A dirty operation ensures a certain level of consistency. For example, dirty operations cannot return garbled records. Hence, each individual read or write operation is performed in an atomic manner.</source>
          <target state="translated">dirty操作可以保证一定程度的一致性。例如,dirty操作不能返回乱码记录。因此,每个单独的读或写操作都是以原子方式进行的。</target>
        </trans-unit>
        <trans-unit id="7ebf083e79a4bab181933e594cee2d9370b9ab7c" translate="yes" xml:space="preserve">
          <source>A disk-based term logging facility.</source>
          <target state="translated">一个基于磁盘的术语记录设施。</target>
        </trans-unit>
        <trans-unit id="0d96f2972ef274a3b4c3377bf6357c2926605d52" translate="yes" xml:space="preserve">
          <source>A disk-based term storage.</source>
          <target state="translated">一种基于磁盘的术语存储。</target>
        </trans-unit>
        <trans-unit id="47c69df1e3667dcfedb432994923493351c17966" translate="yes" xml:space="preserve">
          <source>A disk_log based handler for Logger</source>
          <target state="translated">基于disk_log的Logger处理程序</target>
        </trans-unit>
        <trans-unit id="d5a1bc14ede3681f787b432535890d0cd273d420" translate="yes" xml:space="preserve">
          <source>A distributed telecommunications DBMS</source>
          <target state="translated">分布式电信数据库管理系统</target>
        </trans-unit>
        <trans-unit id="ce830ece0130879215c67d6a63d5c97d8a7c48e3" translate="yes" xml:space="preserve">
          <source>A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option &lt;code&gt;multiline&lt;/code&gt; is specified. There is no equivalent option in Perl, and it cannot be set within a pattern.</source>
          <target state="translated">模式中的美元元字符仅在主题字符串的末尾匹配。如果没有此选项，则美元也将在字符串末尾的换行符前紧紧匹配（但不匹配任何其他换行符）。如果指定了选项 &lt;code&gt;multiline&lt;/code&gt; 则忽略此选项。Perl中没有等效选项，因此无法在模式中进行设置。</target>
        </trans-unit>
        <trans-unit id="ade8b69a85608bc000b53cc0bb10d32bd6f4e1e4" translate="yes" xml:space="preserve">
          <source>A domain field must be a list of atoms, creating smaller and more specialized domains as the list grows longer. The greatest domain is &lt;code&gt;[]&lt;/code&gt;, which comprises all possible domains.</source>
          <target state="translated">域字段必须是原子列表，随着列表的增长，它会创建更小，更专业的域。最大的域是 &lt;code&gt;[]&lt;/code&gt; ，它包含所有可能的域。</target>
        </trans-unit>
        <trans-unit id="3633cdcde13dc5b95a07d9cdccf61ad19b7292b3" translate="yes" xml:space="preserve">
          <source>A door with a code lock can be seen as a state machine. Initially, the door is locked. When someone presses a button, an event is generated. The pressed buttons are collected, up to the number of buttons in the correct code. If correct, the door is unlocked for 10 seconds. If not correct, we wait for a new button to be pressed.</source>
          <target state="translated">一扇带密码锁的门可以看作是一个状态机。最初,门是锁着的。当有人按下按钮时,会产生一个事件。收集被按下的按钮,直到正确代码的按钮数量。如果正确,门将在10秒内被解锁。如果不正确,我们将等待一个新的按钮被按下。</target>
        </trans-unit>
        <trans-unit id="9d2a5945a95873dd7f235759b1053935e86a971f" translate="yes" xml:space="preserve">
          <source>A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option &lt;code&gt;/s&lt;/code&gt; and it can be changed within a pattern by a &lt;code&gt;(?s)&lt;/code&gt; option setting. A negative class, such as &lt;code&gt;[^a]&lt;/code&gt;, always matches newline characters, independent of the setting of this option.</source>
          <target state="translated">模式中的点与所有字符匹配，包括指示换行符的字符。没有它，当前位置在换行符时，点将不匹配。此选项等效于Perl选项 &lt;code&gt;/s&lt;/code&gt; ，并且可以通过 &lt;code&gt;(?s)&lt;/code&gt; 选项设置在模式内进行更改。否定类，例如 &lt;code&gt;[^a]&lt;/code&gt; ，总是与换行符匹配，而与该选项的设置无关。</target>
        </trans-unit>
        <trans-unit id="885bb765c3b45bdf4bc945235d9e2dd16052f6ab" translate="yes" xml:space="preserve">
          <source>A drawback of simple test functions is that you must write a separate function (with a separate name) for each test case. A more compact way of writing tests (and much more flexible, as we shall see), is to write functions that &lt;strong&gt;return&lt;/strong&gt; tests, instead of &lt;strong&gt;being&lt;/strong&gt; tests.</source>
          <target state="translated">简单测试功能的缺点在于，您必须为每个测试用例编写一个单独的函数（具有单独的名称）。编写测试（和更加灵活，我们将看到）的更紧凑的方式，是写函数&lt;strong&gt;返回&lt;/strong&gt;的测试来代替，&lt;strong&gt;正在&lt;/strong&gt;测试。</target>
        </trans-unit>
        <trans-unit id="b000c1146f0c1ed1dc5a3aabc97ba084c853c614" translate="yes" xml:space="preserve">
          <source>A drawback with implementing an SNMP table as a Mnesia table is that the internal resource is forced to use the table definition from the MIB, which means that the external data model must be used internally. Actually, this is only partially true. The Mnesia table may extend the SNMP table, which means that the Mnesia table may have columns which are use internally and are not seen by SNMP. Still, the data model from SNMP must be maintained. Although this is undesirable, it is a pragmatic compromise in many situations where simple and efficient implementation is preferable to abstraction.</source>
          <target state="translated">将SNMP表实现为Mnesia表的一个缺点是,内部资源被迫使用MIB中的表定义,这意味着内部必须使用外部数据模型。实际上,这只是部分正确。Mnesia表可以扩展SNMP表,也就是说Mnesia表可能有一些列是内部使用的,SNMP看不到。但是,来自SNMP的数据模型仍然必须被维护。虽然这并不可取,但在许多情况下,简单有效的实现比抽象化更可取,这是一种务实的妥协。</target>
        </trans-unit>
        <trans-unit id="dc70d1fd3885c3da6699390fff4e736e7393cca0" translate="yes" xml:space="preserve">
          <source>A driver binary allocated in the driver, with &lt;code&gt;driver_alloc_binary&lt;/code&gt;, is to be freed in the driver (unless otherwise stated) with &lt;code&gt;driver_free_binary&lt;/code&gt;. (Notice that this does not necessarily deallocate it, if the driver is still referred in the emulator, the ref-count will not go to zero.)</source>
          <target state="translated">在驱动程序中分配的带有 &lt;code&gt;driver_alloc_binary&lt;/code&gt; 的驱动程序二进制文件将通过 &lt;code&gt;driver_free_binary&lt;/code&gt; 在驱动程序中释放（除非另有说明）。（请注意，这不一定会取消分配它，如果驱动程序仍在模拟器中被引用，则引用计数将不会为零。）</target>
        </trans-unit>
        <trans-unit id="54bf6555831bbcbb33a1143a231274fb8310abec" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">驱动程序回调在返回之前进行 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 会降低VM的响应能力，并可能导致其他奇怪的行为。这种奇怪的行为包括但不限于极端的内存使用情况和调度程序之间的不良负载平衡。在Erlang / OTP发行版之间，由于冗长的工作而可能发生的奇怪行为也可能有所不同。</target>
        </trans-unit>
        <trans-unit id="8a40326bca24e22884109edb9057e64a36e9d19f" translate="yes" xml:space="preserve">
          <source>A driver callback doing &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">驱动程序回调在返回之前进行 &lt;code&gt;&lt;a href=&quot;erl_driver#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 会降低VM的响应能力，并可能导致其他奇怪的行为。这种奇怪的行为包括但不限于极端的内存使用情况以及调度程序之间的不良负载平衡。在Erlang / OTP发行版之间，由于冗长的工作而可能发生的奇怪行为也可能有所不同。</target>
        </trans-unit>
        <trans-unit id="0b5eb508da3e1d5ef4a4f999ab3b5ee6a71a758f" translate="yes" xml:space="preserve">
          <source>A driver callback is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the driver callback function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">驱动程序回调是对VM本机代码的直接扩展。执行不是在安全的环境中进行的。 VM &lt;strong&gt;无法&lt;/strong&gt;提供执行Erlang代码时提供的相同服务，例如抢先式调度或内存保护。如果驱动程序回调函数运行不正常，则整个VM都会出现异常。</target>
        </trans-unit>
        <trans-unit id="c5fe6680281eb2602c7b531134d6486d21c3966d" translate="yes" xml:space="preserve">
          <source>A driver callback that crash will crash the whole VM.</source>
          <target state="translated">崩溃的驱动程序回调将使整个虚拟机崩溃。</target>
        </trans-unit>
        <trans-unit id="35f6d76692e5c5a3a8bc9ae237376468c696b57c" translate="yes" xml:space="preserve">
          <source>A driver can add and later remove drivers.</source>
          <target state="translated">驱动程序可以添加和以后删除驱动程序。</target>
        </trans-unit>
        <trans-unit id="5db720ccab1ee2294dd6583e58238e6ff531fde9" translate="yes" xml:space="preserve">
          <source>A driver can be configured to have one lock for each port instead.</source>
          <target state="translated">驱动程序可以被配置为每个端口有一个锁。</target>
        </trans-unit>
        <trans-unit id="ea8de0f635aa82b9e3262bc25c0681bf5ef9e25f" translate="yes" xml:space="preserve">
          <source>A driver can be dynamically loaded, as a shared library (known as a DLL on Windows), or statically loaded, linked with the emulator when it is compiled and linked. Only dynamically loaded drivers are described here, statically linked drivers are beyond the scope of this section.</source>
          <target state="translated">驱动程序可以动态加载,作为共享库(在Windows中称为DLL),或静态加载,在编译和链接时与模拟器链接。这里只描述动态加载的驱动程序,静态链接的驱动程序不在本节范围内。</target>
        </trans-unit>
        <trans-unit id="e0a7bb769b863c9b98696f02891a10946d65061a" translate="yes" xml:space="preserve">
          <source>A driver can monitor a process that does not own a port.</source>
          <target state="translated">驱动程序可以监控一个不拥有端口的进程。</target>
        </trans-unit>
        <trans-unit id="c998e9cdc2a7831f2ce7666b5692240829ea93b5" translate="yes" xml:space="preserve">
          <source>A driver in Erlang is a library written in C, which is linked to the Erlang emulator and called from Erlang. Drivers can be used when C is more suitable than Erlang, to speed up things, or to provide access to OS resources not directly accessible from Erlang.</source>
          <target state="translated">Erlang中的驱动是一个用C语言编写的库,它与Erlang模拟器相连,并从Erlang中调用。当C语言比Erlang更适合的时候,可以使用驱动,以加快事情的速度,或者提供对Erlang不能直接访问的操作系统资源的访问。</target>
        </trans-unit>
        <trans-unit id="485795b556efcb079ba1f2cce0c02a2d6a8f0346" translate="yes" xml:space="preserve">
          <source>A driver monitor for unload eventually results in one of the following messages being sent:</source>
          <target state="translated">卸载的驱动程序监控最终会导致发送以下消息之一。</target>
        </trans-unit>
        <trans-unit id="776db06c979c20584411a6ff4cdf277b51cad201" translate="yes" xml:space="preserve">
          <source>A drop-down box in the toolbar contains the command history. Selecting a command in the drop-down box inserts the command at the prompt, as if you used the keyboard to retrieve the command.</source>
          <target state="translated">工具栏中的下拉框包含命令历史记录。在下拉框中选择一个命令,就会在提示音中插入该命令,就像使用键盘检索命令一样。</target>
        </trans-unit>
        <trans-unit id="6861853bee0f535fea0e16450c99ed3515493ce2" translate="yes" xml:space="preserve">
          <source>A failed user authentication.</source>
          <target state="translated">用户认证失败。</target>
        </trans-unit>
        <trans-unit id="9db63409ec19fe48d435b1817d57ade59ec9240c" translate="yes" xml:space="preserve">
          <source>A fallback is typically used when a system upgrade is performed. A system typically involves the installation of new software versions, and &lt;code&gt;Mnesia&lt;/code&gt; tables are often transformed into new layouts. If the system crashes during an upgrade, it is highly probable that reinstallation of the old applications is required, and restoration of the database to its previous state. This can be done if a backup is performed and installed as a fallback before the system upgrade begins.</source>
          <target state="translated">执行系统升级时通常使用回退。系统通常需要安装新的软件版本， &lt;code&gt;Mnesia&lt;/code&gt; 表通常会转换为新的布局。如果系统在升级过程中崩溃，则很有可能需要重新安装旧应用程序，并将数据库还原到以前的状态。如果在系统升级开始之前执行了备份并将其安装为备用，则可以执行此操作。</target>
        </trans-unit>
        <trans-unit id="318a05f034b1325fb1731c6625436c4ea96c2dba" translate="yes" xml:space="preserve">
          <source>A family of options that selectively turn on/off warnings. (For help on the names of warnings, use &lt;code&gt;dialyzer -Whelp&lt;/code&gt;.) Notice that the options can also be specified in the file with a &lt;code&gt;-dialyzer()&lt;/code&gt; attribute. For details, see section &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有选择地打开/关闭警告的选项系列。（要获得有关警告名称的帮助，请使用 &lt;code&gt;dialyzer -Whelp&lt;/code&gt; 。）请注意，也可以在文件中使用 &lt;code&gt;-dialyzer()&lt;/code&gt; 属性指定选项。有关详细信息，请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#suppression&quot;&gt;Requesting or Suppressing Warnings in Source Files&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f11118ca381dffc41f3188bffb0c43a4c650f1ba" translate="yes" xml:space="preserve">
          <source>A fast allocator used for some frequently used fixed size data types.</source>
          <target state="translated">一个快速分配器,用于一些常用的固定大小的数据类型。</target>
        </trans-unit>
        <trans-unit id="3744509be8dd70aa593f301a9795a7c56c7a0de4" translate="yes" xml:space="preserve">
          <source>A faulty linked-in driver causes the entire Erlang runtime system to leak memory, hang, or crash.</source>
          <target state="translated">一个有问题的link-in驱动会导致整个Erlang运行时系统泄漏内存、挂起或崩溃。</target>
        </trans-unit>
        <trans-unit id="89cefbb8feb5d084db82b500bebe6a7d1dfbb558" translate="yes" xml:space="preserve">
          <source>A few applications, such as HiPE, do not support upgrade. This is indicated by an application upgrade file containing only &lt;code&gt;{Vsn,[],[]}&lt;/code&gt;. Any attempt at creating a release upgrade file with such input fails. The only way to force an upgrade involving applications like this is to handwrite the file &lt;code&gt;relup&lt;/code&gt;, preferably as described above with only the &lt;code&gt;restart_emulator&lt;/code&gt; instruction.</source>
          <target state="translated">某些应用程序（例如HiPE）不支持升级。这由仅包含 &lt;code&gt;{Vsn,[],[]}&lt;/code&gt; 的应用程序升级文件指示。用这种输入创建发行升级文件的任何尝试都将失败。强制进行涉及此类应用程序升级的唯一方法是手写文件 &lt;code&gt;relup&lt;/code&gt; ，最好如上所述，仅使用 &lt;code&gt;restart_emulator&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="ff07fbc6aad7ee78f12be074f853b050b49851ab" translate="yes" xml:space="preserve">
          <source>A few basic match specifications are provided in the tool, and you can provide your own match specifications. The syntax of match specifications is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. To simplify the writing of a match specification, they can also be written as &lt;code&gt;fun/1&lt;/code&gt;. For details, see module &lt;code&gt;ms_transform&lt;/code&gt; in application STDLIB.</source>
          <target state="translated">该工具提供了一些基本的匹配规格，您可以提供自己的匹配规格。匹配规范的语法在《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 中进行了描述。为了简化匹配说明的编写，它们也可以编写为 &lt;code&gt;fun/1&lt;/code&gt; 。有关详细信息，请参见应用程序STDLIB中的模块 &lt;code&gt;ms_transform&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ac9a5c3fa6e165b6c50df51a6215981d75c01d" translate="yes" xml:space="preserve">
          <source>A few cases when it can be useful to change &lt;code&gt;fullsweep_after&lt;/code&gt;:</source>
          <target state="translated">在少数情况下，更改 &lt;code&gt;fullsweep_after&lt;/code&gt; 可能很有用：</target>
        </trans-unit>
        <trans-unit id="fd821a8e6f09efd8fb5370148d4ea4ec2ea95138" translate="yes" xml:space="preserve">
          <source>A few exceptions are documented for each property that behaves differently, and the special cases &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; and &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt;, are represented as:</source>
          <target state="translated">对于每个行为不同的属性，都记录了一些例外情况，特殊情况 &lt;code&gt;{directory, {path(), PropertyList}}&lt;/code&gt; 和 &lt;code&gt;{security_directory, {Dir, PropertyList}}&lt;/code&gt; 表示为：</target>
        </trans-unit>
        <trans-unit id="fce4084ca7f83d86aff3d0d9ecf63d0ad90bd23a" translate="yes" xml:space="preserve">
          <source>A few functions of this module (&lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt;) accept an Erlang function as a means to modify each element of a given unordered set. Such a function, called SetFun in the following, can be specified as a functional object (fun), a tuple &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt;, or an integer:</source>
          <target state="translated">这个模块的一些功能（ &lt;code&gt;&lt;a href=&quot;#drestriction-3&quot;&gt;drestriction/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#family_projection-2&quot;&gt;family_projection/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#partition_family-2&quot;&gt;partition_family/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#projection-2&quot;&gt;projection/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#restriction-3&quot;&gt;restriction/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#substitution-2&quot;&gt;substitution/2&lt;/a&gt;&lt;/code&gt; ）接受一个Erlang功能作为一种手段来修改给定的无序的每个元素组。这样的函数在下面称为SetFun，可以指定为函数对象（fun），元组 &lt;code id=&quot;set_fun&quot;&gt;{external,&amp;nbsp;Fun}&lt;/code&gt; 或整数：</target>
        </trans-unit>
        <trans-unit id="e2ace938c1e5c889a1c9155b08dfea0b539e2fd8" translate="yes" xml:space="preserve">
          <source>A few more ways of retrieving parts of the result set when the driver supports scrollable cursors. Note that next will work even without support for scrollable cursors.</source>
          <target state="translated">当驱动程序支持可滚动光标时,还有一些检索结果集部分内容的方法。请注意,即使不支持可滚动光标,next也可以工作。</target>
        </trans-unit>
        <trans-unit id="69178368f8f421dd7829a950db37217d05913e11" translate="yes" xml:space="preserve">
          <source>A file &lt;code&gt;test.config&lt;/code&gt; is created with the following contents:</source>
          <target state="translated">创建的文件 &lt;code&gt;test.config&lt;/code&gt; 具有以下内容：</target>
        </trans-unit>
        <trans-unit id="c8d336412b7f7b3198bf244f5e66fc7122fd82ab" translate="yes" xml:space="preserve">
          <source>A file can be included as follows:</source>
          <target state="translated">一个文件可以包含如下内容:</target>
        </trans-unit>
        <trans-unit id="cbeaf69644d74ca16d734d345aa0a129a3918826" translate="yes" xml:space="preserve">
          <source>A file can contain several &lt;code&gt;BEGIN/END&lt;/code&gt; blocks. Text lines between blocks are ignored. Attributes, if present, are ignored except for &lt;code&gt;Proc-Type&lt;/code&gt; and &lt;code&gt;DEK-Info&lt;/code&gt;, which are used when &lt;code&gt;DER&lt;/code&gt; data is encrypted.</source>
          <target state="translated">一个文件可以包含几个 &lt;code&gt;BEGIN/END&lt;/code&gt; 块。块之间的文本行将被忽略。属性，如果存在，除了忽略 &lt;code&gt;Proc-Type&lt;/code&gt; 和 &lt;code&gt;DEK-Info&lt;/code&gt; ，当其中使用 &lt;code&gt;DER&lt;/code&gt; 数据进行加密。</target>
        </trans-unit>
        <trans-unit id="9565a924f37de4be5c2226f5018cb7da0db985af" translate="yes" xml:space="preserve">
          <source>A file can have an encoding option that makes it generally usable by the &lt;code&gt;io&lt;/code&gt; module (for example &lt;code&gt;{encoding,utf8}&lt;/code&gt;), but is by default opened as a byte-oriented file. The &lt;code&gt;file&lt;/code&gt; module is byte-oriented, so only ISO Latin-1 characters can be written using that module. Use the &lt;code&gt;io&lt;/code&gt; module if Unicode data is to be output to a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding). It is slightly confusing that a file opened with, for example, &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; cannot be properly read using &lt;code&gt;file:read(File,N)&lt;/code&gt;, but using the &lt;code&gt;io&lt;/code&gt; module to retrieve the Unicode data from it. The reason is that &lt;code&gt;file:read&lt;/code&gt; and &lt;code&gt;file:write&lt;/code&gt; (and friends) are purely byte-oriented, and should be, as that is the way to access files other than text files, byte by byte. As with ports, you can write encoded data into a file by &quot;manually&quot; converting the data to the encoding of choice (using the &lt;code&gt;unicode&lt;/code&gt; module or the bit syntax) and then output it on a bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoded file.</source>
          <target state="translated">文件可以具有使其可以在 &lt;code&gt;io&lt;/code&gt; 模块中普遍使用的编码选项（例如 &lt;code&gt;{encoding,utf8}&lt;/code&gt; ），但是默认情况下是作为面向字节的文件打开的。该 &lt;code&gt;file&lt;/code&gt; 模块是面向字节，所以只有ISO Latin-1字符可以使用该模块被写入。如果要将Unicode数据以不同于 &lt;code&gt;latin1&lt;/code&gt; （按字节编码）的其他 &lt;code&gt;encoding&lt;/code&gt; 输出到文件，请使用 &lt;code&gt;io&lt;/code&gt; 模块。使用 &lt;code&gt;file:read(File,N)&lt;/code&gt; 无法正确读取以例如 &lt;code&gt;file:open(Name,[read,{encoding,utf8}])&lt;/code&gt; 打开的文件，但使用 &lt;code&gt;io&lt;/code&gt; 模块检索来自它的Unicode数据。原因是 &lt;code&gt;file:read&lt;/code&gt; 和 &lt;code&gt;file:write&lt;/code&gt; （以及朋友）完全是字节导向的，应该这样，因为这是访问文本文件以外的文件的逐字节方式。与端口一样，您可以通过&amp;ldquo;手动&amp;rdquo;将数据转换为选择的编码（使用 &lt;code&gt;unicode&lt;/code&gt; 模块或位语法），然后将其输出到按字节（ &lt;code&gt;latin1&lt;/code&gt; ）编码的文件中，从而将编码的数据写入文件。</target>
        </trans-unit>
        <trans-unit id="4d89c7591289fd3005e1bbfce5efe617ceee10df" translate="yes" xml:space="preserve">
          <source>A file containing data related to a test and/or an SUT, for example, protocol server addresses, client login details, and hardware interface addresses. That is, any data that is to be handled as variable in the suite and not be hard-coded.</source>
          <target state="translated">包含与测试和/或SUT有关的数据的文件,例如,协议服务器地址、客户端登录详情和硬件接口地址。也就是说,任何将作为套件中的变量而不是硬编码处理的数据。</target>
        </trans-unit>
        <trans-unit id="616a73250d7af5692f557f0fc3d8f0aefbf16ef9" translate="yes" xml:space="preserve">
          <source>A file descriptor representing a file opened in &lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">代表以 &lt;code&gt;&lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt;&lt;/code&gt; 模式打开的文件的文件描述符。</target>
        </trans-unit>
        <trans-unit id="2d71dcec01ab246a78607a17cbd7cd28847c46b5" translate="yes" xml:space="preserve">
          <source>A file or directory named &lt;code&gt;Dir&lt;/code&gt; exists already.</source>
          <target state="translated">命名文件或目录 &lt;code&gt;Dir&lt;/code&gt; 中已经存在。</target>
        </trans-unit>
        <trans-unit id="26be688763e641b3a9dfad11fde8db2842f3801c" translate="yes" xml:space="preserve">
          <source>A filename.</source>
          <target state="translated">一个文件名。</target>
        </trans-unit>
        <trans-unit id="7e18ad0e74d1cf4a7f98aab6228b1e84c7680443" translate="yes" xml:space="preserve">
          <source>A filter is defined as:</source>
          <target state="translated">过滤器的定义是:</target>
        </trans-unit>
        <trans-unit id="8e5fa771ebe9bef523c8171150923d10ee3e8517" translate="yes" xml:space="preserve">
          <source>A filter which can be installed as a handler filter, or as a primary filter in Logger.</source>
          <target state="translated">一个过滤器,它可以作为处理过滤器安装,也可以作为记录仪中的主过滤器安装。</target>
        </trans-unit>
        <trans-unit id="1e3cb0a88c21fc9cb93d8900a90dbffadc95b7ff" translate="yes" xml:space="preserve">
          <source>A filter_fun() takes an event record as sole argument and returns false | true | {true, NewEvent}.</source>
          <target state="translated">filter_fun()将一个事件记录作为唯一参数,并返回false | true | {true,NewEvent}。</target>
        </trans-unit>
        <trans-unit id="520861380e77fff7b333b5642ccc63edc6c4108c" translate="yes" xml:space="preserve">
          <source>A final massage of the environment is needed, and that is done by the script &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt;. Start bash and do the following, note the &quot;back-ticks&quot; (`), can be quite hard to get on some keyboards, but pressing the back-tick key followed by the space bar might do it...</source>
          <target state="translated">需要对环境进行最后的按摩，这是通过脚本 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 。启动bash并执行以下操作，请注意在某些键盘上很难获得&amp;ldquo;反勾号&amp;rdquo;（`），但是按反勾号键和空格键可能会完成此操作...</target>
        </trans-unit>
        <trans-unit id="90f744119c16fd9fb8932446ccb5476df4faf187" translate="yes" xml:space="preserve">
          <source>A fixed number of characters is requested using the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">使用以下 &lt;code&gt;Request&lt;/code&gt; 来请求固定数量的字符：</target>
        </trans-unit>
        <trans-unit id="0a7d5da9ebedb8e232edc49649003f18ee79c791" translate="yes" xml:space="preserve">
          <source>A fixed-size array does not grow automatically and does not allow accesses beyond the last set entry:</source>
          <target state="translated">一个固定大小的数组不会自动增长,也不允许访问超过最后一个设置的条目。</target>
        </trans-unit>
        <trans-unit id="3bad05ad914ca3ed5e8df973848616692506d53e" translate="yes" xml:space="preserve">
          <source>A flag starting with a plus (&lt;code&gt;+&lt;/code&gt;) rather than a hyphen is converted to an Erlang term and passed unchanged to the compiler. For example, option &lt;code&gt;export_all&lt;/code&gt; for the Erlang compiler can be specified as follows:</source>
          <target state="translated">以加号（ &lt;code&gt;+&lt;/code&gt; ）而不是连字符开头的标志将转换为Erlang术语，并原样传递给编译器。例如，可以如下指定用于Erlang编译器的选项 &lt;code&gt;export_all&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="10b632ad7a686b2d7a96c3959bf12e04c0566f52" translate="yes" xml:space="preserve">
          <source>A float is stored as 8 bytes in big-endian IEEE format.</source>
          <target state="translated">浮点数以IEEE大字段格式存储为8个字节。</target>
        </trans-unit>
        <trans-unit id="e9e5201aedcab16b3adecdda5a3e12ff8098d3d7" translate="yes" xml:space="preserve">
          <source>A float is stored in string format. The format used in sprintf to format the float is &quot;%.20e&quot; (there are more bytes allocated than necessary). To unpack the float, use sscanf with format &quot;%lf&quot;.</source>
          <target state="translated">浮点数是以字符串格式存储的。在sprintf中使用的格式是&quot;%.20e&quot;(分配的字节数超过了需要)。要解压浮点数,可以使用格式为&quot;%lf &quot;的sscanf。</target>
        </trans-unit>
        <trans-unit id="a6f6fcdac9b179d5523fd1d6e88e1a598a905d83" translate="yes" xml:space="preserve">
          <source>A floating point number is expected. It must follow the Erlang floating point number syntax.</source>
          <target state="translated">希望是一个浮点数,必须遵循Erlang浮点数语法。它必须遵循Erlang浮点数语法。</target>
        </trans-unit>
        <trans-unit id="b4d0580dc8d2afb0f4c6adffa439752a5472ac02" translate="yes" xml:space="preserve">
          <source>A format handler is a fun taking four arguments. This fun is called for each trace message in the binary log(s). A simple example that only prints each trace message can be as follows:</source>
          <target state="translated">格式化处理程序是一个包含四个参数的fun。这个fun对二进制日志中的每一条跟踪消息都会被调用。一个简单的例子是,只打印每条跟踪消息,如下所示。</target>
        </trans-unit>
        <trans-unit id="685c2f489be151735ae38f24a353d5faae37fc17" translate="yes" xml:space="preserve">
          <source>A formatter can be used by the handler implementation to do the final formatting of a log event, before printing to the handler's destination. The handler callback receives the formatter information as part of the handler configuration, which is passed as the second argument to &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理程序实现可以使用格式化程序在打印到处理程序的目标位置之前对日志事件进行最终格式化。处理程序回调将格式化程序信息作为处理程序配置的一部分接收，并将其作为第二个参数传递给 &lt;code&gt;&lt;a href=&quot;logger#HModule:log-2&quot;&gt;HModule:log/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ddabb55af8280ef44d4873b2fe6f87c2ff0d592" translate="yes" xml:space="preserve">
          <source>A framework for automated testing of any target nodes.</source>
          <target state="translated">一个对任何目标节点进行自动测试的框架。</target>
        </trans-unit>
        <trans-unit id="aee4c7374225cff97b384f5e8f0444105623df6f" translate="yes" xml:space="preserve">
          <source>A fun created by &lt;code&gt;fun M:F/A&lt;/code&gt; is called an &lt;strong&gt;external&lt;/strong&gt; fun. Calling it will always call the function &lt;code&gt;F&lt;/code&gt; with arity &lt;code&gt;A&lt;/code&gt; in the latest code for module &lt;code&gt;M&lt;/code&gt;. Notice that module &lt;code&gt;M&lt;/code&gt; does not even need to be loaded when the fun &lt;code&gt;fun M:F/A&lt;/code&gt; is created.</source>
          <target state="translated">由 &lt;code&gt;fun M:F/A&lt;/code&gt; 创建的乐趣称为&lt;strong&gt;外部&lt;/strong&gt;乐趣。调用它总是会调用该函数 &lt;code&gt;F&lt;/code&gt; 与元数 &lt;code&gt;A&lt;/code&gt; 在模块的最新代码 &lt;code&gt;M&lt;/code&gt; 。注意，创建 &lt;code&gt;fun M:F/A&lt;/code&gt; 时甚至不需要加载模块 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe82f35844a581a23e9acd45f2d705a836415f6f" translate="yes" xml:space="preserve">
          <source>A fun expression begins with the keyword &lt;code&gt;fun&lt;/code&gt; and ends with the keyword &lt;code&gt;end&lt;/code&gt;. Between them is to be a function declaration, similar to a &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt;, except that the function name is optional and is to be a variable, if any.</source>
          <target state="translated">fun表达式以关键字 &lt;code&gt;fun&lt;/code&gt; 开头，以关键字 &lt;code&gt;end&lt;/code&gt; 结尾。它们之间将是一个函数声明，类似于 &lt;code&gt;&lt;a href=&quot;functions#syntax&quot;&gt;regular function declaration&lt;/a&gt;&lt;/code&gt; ，不同之处在于函数名称是可选的，并且应是变量（如果有）。</target>
        </trans-unit>
        <trans-unit id="7ba69074df191132a5aee72b7de68af231ccb23b" translate="yes" xml:space="preserve">
          <source>A fun is a functional object. Funs make it possible to create an anonymous function and pass the function itself -- not its name -- as argument to other functions.</source>
          <target state="translated">fun是一个函数对象。通过fun可以创建一个匿名函数,并将函数本身--而不是它的名字--作为参数传递给其他函数。</target>
        </trans-unit>
        <trans-unit id="a83e179e2a0b967f058ad516cb4229a827e95fd9" translate="yes" xml:space="preserve">
          <source>A fun is applied to the wrong number of arguments. &lt;code&gt;F&lt;/code&gt; describes the fun and the arguments.</source>
          <target state="translated">错误的参数数量会带来乐趣。 &lt;code&gt;F&lt;/code&gt; 描述了乐趣和参数。</target>
        </trans-unit>
        <trans-unit id="331ce727ff0b82a2baa3eca467f7f047acb2688e" translate="yes" xml:space="preserve">
          <source>A fun refers into a fun table, which also consumes memory.</source>
          <target state="translated">趣指成趣表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="917f02c1a076a8a47ebb3722785173da993cb101" translate="yes" xml:space="preserve">
          <source>A fun with the following signature:</source>
          <target state="translated">有以下签名的趣味。</target>
        </trans-unit>
        <trans-unit id="9c0db4550739af00d32b0dfa12f09adabde22929" translate="yes" xml:space="preserve">
          <source>A function (&lt;code&gt;fun/0&lt;/code&gt; or &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; (MFA) tuple) can be specified as timetrap value in the suite-, group- and test case information function, and as argument to function &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以在套件，组和测试用例信息函数中将函数（ &lt;code&gt;fun/0&lt;/code&gt; 或 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; （MFA）元组）指定为时间陷阱值，并作为函数 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="07a3cf7ceca0e362fe2af257283edf78084fc160" translate="yes" xml:space="preserve">
          <source>A function breakpoint is a set of line breakpoints, one at the first line of each clause in the specified function.</source>
          <target state="translated">函数断点是一组行断点,在指定的函数中每个子句的第一行都有一个。</target>
        </trans-unit>
        <trans-unit id="5f0fd871bd70c7514030529afb1f484443906fd8" translate="yes" xml:space="preserve">
          <source>A function can have many arguments. Let us expand the module &lt;code&gt;tut1&lt;/code&gt; with the function to multiply two numbers:</source>
          <target state="translated">一个函数可以有很多参数。让我们使用将两个数字相乘的函数来扩展模块 &lt;code&gt;tut1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fede52edfc71f21c837f79f6a8e9fb78f0248b2b" translate="yes" xml:space="preserve">
          <source>A function compliant with these functions. For details, see the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page.</source>
          <target state="translated">符合这些功能的功能。有关详细信息，请参见 &lt;code&gt;supervisor(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="26f617733f33e20e330ebc8aa6d33e7c36f5c2a1" translate="yes" xml:space="preserve">
          <source>A function constraint Fc is a non-empty sequence of constraints &lt;code&gt;C_1, ..., C_k&lt;/code&gt;, and Rep(Fc) = &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt;.</source>
          <target state="translated">函数约束Fc是约束 &lt;code&gt;C_1, ..., C_k&lt;/code&gt; 的非空序列，并且Rep（Fc）= &lt;code&gt;[Rep(C_1), ..., Rep(C_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dfcd76722f3584d620315b3cb799ba807ca502f" translate="yes" xml:space="preserve">
          <source>A function for an exclusive decode, whose name the user decides in the configuration file</source>
          <target state="translated">独占解码的功能,用户在配置文件中决定其名称。</target>
        </trans-unit>
        <trans-unit id="be3487c9bce760681de79e5934bed4a4861cc982" translate="yes" xml:space="preserve">
          <source>A function in a test suite that is meant to be used for setting up, cleaning up, and/or verifying the state and environment on the System Under Test (SUT) and/or the &lt;code&gt;Common Test&lt;/code&gt; host node, so that a test case (or a set of test cases) can execute correctly.</source>
          <target state="translated">测试套件中的一项功能，旨在用于在被测系统（SUT）和/或 &lt;code&gt;Common Test&lt;/code&gt; 主机节点上设置，清理和/或验证状态和环境，以便测试用例（或一组测试用例）可以正确执行。</target>
        </trans-unit>
        <trans-unit id="8a453d0634dfbb426f81f44cc7d5fb202b518059" translate="yes" xml:space="preserve">
          <source>A function in a test suite that returns a list of properties (read by the &lt;code&gt;Common Test&lt;/code&gt; server) that describes the conditions for executing the test cases in the suite.</source>
          <target state="translated">测试套件中的一个函数，它返回属性列表（由 &lt;code&gt;Common Test&lt;/code&gt; 服务器读取），该属性列表描述了在套件中执行测试用例的条件。</target>
        </trans-unit>
        <trans-unit id="bee93e2fd141ac952df7640f626d3d10f1e92fbd" translate="yes" xml:space="preserve">
          <source>A function in the &lt;code&gt;proc_lib&lt;/code&gt; module is to be used to start the process. Several functions are available, for example, &lt;code&gt;spawn_link/3,4&lt;/code&gt; for asynchronous start and &lt;code&gt;start_link/3,4,5&lt;/code&gt; for synchronous start.</source>
          <target state="translated">&lt;code&gt;proc_lib&lt;/code&gt; 模块中的一个函数将用于启动该过程。有几个功能可用，例如， &lt;code&gt;spawn_link/3,4&lt;/code&gt; 用于异步启动， &lt;code&gt;start_link/3,4,5&lt;/code&gt; 用于同步启动。</target>
        </trans-unit>
        <trans-unit id="1ea8125453a1f5033d8778318612575164d3d3ce" translate="yes" xml:space="preserve">
          <source>A function is called using the &lt;code&gt;M:F&lt;/code&gt; syntax, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are atoms or expressions.</source>
          <target state="translated">使用 &lt;code&gt;M:F&lt;/code&gt; 语法调用函数，其中 &lt;code&gt;M&lt;/code&gt; 和 &lt;code&gt;F&lt;/code&gt; 是原子或表达式。</target>
        </trans-unit>
        <trans-unit id="f874e0a252012bc547a3211dd48e03d0c6554317" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;f&lt;/code&gt; in the module &lt;code&gt;m&lt;/code&gt; and with arity &lt;code&gt;N&lt;/code&gt; is often denoted as &lt;code&gt;m:f/N&lt;/code&gt;.</source>
          <target state="translated">命名为A功能 &lt;code&gt;f&lt;/code&gt; 在模块 &lt;code&gt;m&lt;/code&gt; ，并与元数 &lt;code&gt;N&lt;/code&gt; 经常表示为 &lt;code&gt;m:f/N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e2076ece482295f13f43d68037c1f2992b8f9a" translate="yes" xml:space="preserve">
          <source>A function not explicitly documented as thread-safe can, at some point in time, have a thread-safe implementation in the runtime system. Such an implementation can however change to a thread &lt;strong&gt;unsafe&lt;/strong&gt; implementation at any time &lt;strong&gt;without any notice&lt;/strong&gt;.</source>
          <target state="translated">在某个时间点，未明确记录为线程安全的函数可以在运行时系统中具有线程安全的实现。但是，此类实现可以随时更改为线程&lt;strong&gt;不安全的&lt;/strong&gt;实现，&lt;strong&gt;而无需任何通知&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ad55a8c4f2fdc2e2ad52ed3c0264567f558d6c9a" translate="yes" xml:space="preserve">
          <source>A function of one argument can be specified as output. The results of sorting or merging the input is collected in a non-empty sequence of variable length lists of binaries or terms depending on the format. The output function is called with one list at a time, and is assumed to return a new output function. Any other return value is immediately returned as value of the current call to the sort or merge function. Each output function is called exactly once. When some output function has been applied to all of the results or an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, and the reply is returned as value of the current call to the sort or merge function.</source>
          <target state="translated">可以将一个参数的函数指定为输出。排序或合并输入的结果将以非空的二进制或术语可变长度列表列表（取决于格式）收集。一次调用一个列表的输出函数，并假定它返回一个新的输出函数。任何其他返回值将立即作为当前调用的值返回到sort或merge函数。每个输出函数仅被调用一次。当某些输出函数应用于所有结果或发生错误时，将使用参数 &lt;code&gt;close&lt;/code&gt; 调用最后一个函数，并将回复作为当前调用的值返回到sort或merge函数。</target>
        </trans-unit>
        <trans-unit id="59fe57d80e3ef9db4ebd49c663824a7be50c8252" translate="yes" xml:space="preserve">
          <source>A function specification can be overloaded. That is, it can have several types, separated by a semicolon (&lt;code&gt;;&lt;/code&gt;):</source>
          <target state="translated">功能说明可以重载。也就是说，它可以有几种类型，以分号（ &lt;code&gt;;&lt;/code&gt; ）分隔：</target>
        </trans-unit>
        <trans-unit id="fa95908fabb759c7e5694e79bc74d7fa4cb9cab8" translate="yes" xml:space="preserve">
          <source>A function that adds a family to the database can be written as follows if there is a structure &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt;:</source>
          <target state="translated">如果有一个结构 &lt;code&gt;{family, Father, Mother, ChildrenList}&lt;/code&gt; 可以向数据库添加一个家庭的函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd3a3a3eaa7687c88a4600f70861728b853757b4" translate="yes" xml:space="preserve">
          <source>A function that is intended to be traced.</source>
          <target state="translated">一个打算被追踪的函数。</target>
        </trans-unit>
        <trans-unit id="84f14d74551f2c944f4c5fc40a31a1120c5642d9" translate="yes" xml:space="preserve">
          <source>A function type Ft is one of the following:</source>
          <target state="translated">函数类型Ft是以下之一:</target>
        </trans-unit>
        <trans-unit id="f2ed1d7e05b7d9f3e384891d361b5e9e23e3a041" translate="yes" xml:space="preserve">
          <source>A function which has been called with &lt;code&gt;is_set_ok&lt;/code&gt; will be called again, either with &lt;code&gt;set&lt;/code&gt; if there was no error, or with &lt;code&gt;undo&lt;/code&gt;, if an error occurred. In this way, resources can be reserved in the &lt;code&gt;is_set_ok&lt;/code&gt; operation, released in the &lt;code&gt;undo&lt;/code&gt; operation, or made permanent in the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">使用 &lt;code&gt;is_set_ok&lt;/code&gt; 调用的函数将再次调用，如果没有错误，则使用 &lt;code&gt;set&lt;/code&gt; ;如果发生错误，则使用 &lt;code&gt;undo&lt;/code&gt; 再次调用。这样，可以在 &lt;code&gt;is_set_ok&lt;/code&gt; 操作中保留资源，在 &lt;code&gt;undo&lt;/code&gt; 操作中释放资源，或在 &lt;code&gt;set&lt;/code&gt; 操作中使其成为永久资源。</target>
        </trans-unit>
        <trans-unit id="bd8be8e88421b65c5785dda3b74a299c4437c971" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test()&lt;/code&gt; is recognized by EUnit as a simple test function - it takes no arguments, and its execution either succeeds (returning some arbitrary value that EUnit will throw away), or fails by throwing an exception of some kind (or by not terminating, in which case it will be aborted after a while).</source>
          <target state="translated">名称以 &lt;code&gt;..._test()&lt;/code&gt; 结尾的函数被EUnit识别为简单的测试函数-它不带参数，并且执行成功（返回EUnit会丢弃的任意值），或者通过抛出某种例外（或不终止，在这种情况下将在一段时间后终止）。</target>
        </trans-unit>
        <trans-unit id="6cb5bb4750e96bdf1cb4a018b0ae8f0c42348f8c" translate="yes" xml:space="preserve">
          <source>A function with a name ending in &lt;code&gt;..._test_()&lt;/code&gt; (note the final underscore) is recognized by EUnit as a &lt;strong&gt;test generator&lt;/strong&gt; function. Test generators return a &lt;strong&gt;representation&lt;/strong&gt; of a &lt;strong&gt;set of tests&lt;/strong&gt; to be executed by EUnit.</source>
          <target state="translated">名称以 &lt;code&gt;..._test_()&lt;/code&gt; 结尾的函数（请注意最后的下划线）被EUnit识别为&lt;strong&gt;测试生成器&lt;/strong&gt;函数。测试生成器返回由EUnit执行的一&lt;strong&gt;组测试&lt;/strong&gt;的&lt;strong&gt;表示&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a48507b735622ceff0ef19da321ab8f330d7565" translate="yes" xml:space="preserve">
          <source>A functional interface to system messages.</source>
          <target state="translated">系统消息的功能接口。</target>
        </trans-unit>
        <trans-unit id="5718538818085276e24476684d081fe2c16ac1e8" translate="yes" xml:space="preserve">
          <source>A functional object (fun) is called.</source>
          <target state="translated">一个功能对象(fun)被称为。</target>
        </trans-unit>
        <trans-unit id="a77ae01d0047b90d93e3127e8ab05f3c2f271265" translate="yes" xml:space="preserve">
          <source>A functional, extendible array. The representation is not documented and is subject to change without notice. Notice that arrays cannot be directly compared for equality.</source>
          <target state="translated">一个功能性、可扩展的数组。其表示方法未见记载,如有变更,恕不另行通知。请注意,数组不能直接进行平等比较。</target>
        </trans-unit>
        <trans-unit id="54ada27e365cb4a22611cb6a9989b7fa6327cde2" translate="yes" xml:space="preserve">
          <source>A general balanced set iterator.</source>
          <target state="translated">一般平衡集迭代器。</target>
        </trans-unit>
        <trans-unit id="abd2d7ccb70af9192a88e9078363ed031f3357e6" translate="yes" xml:space="preserve">
          <source>A general balanced set.</source>
          <target state="translated">总的平衡集。</target>
        </trans-unit>
        <trans-unit id="8cf5f3092481aa2537de6a0b5a55a3c05a0431e5" translate="yes" xml:space="preserve">
          <source>A general balanced tree iterator.</source>
          <target state="translated">一般平衡树迭代器。</target>
        </trans-unit>
        <trans-unit id="9983fa582405ead1dae547bcbe84a7f86c9c2c6a" translate="yes" xml:space="preserve">
          <source>A general balanced tree.</source>
          <target state="translated">一般平衡的树。</target>
        </trans-unit>
        <trans-unit id="ef9ed8ddc12844f0870bb4f089487a9445710baf" translate="yes" xml:space="preserve">
          <source>A general function for creating Erlang terms using a format specifier and a corresponding set of arguments, much in the way &lt;code&gt;printf()&lt;/code&gt; works.</source>
          <target state="translated">一个通用的函数，用于使用格式说明符和一组对应的参数来创建Erlang术语，这与 &lt;code&gt;printf()&lt;/code&gt; 的工作方式非常相似。</target>
        </trans-unit>
        <trans-unit id="2e207a92b9beca5dbcb01f63b66742b4b78e66b3" translate="yes" xml:space="preserve">
          <source>A general function for retrieving any kind of object from the registry.</source>
          <target state="translated">用于从注册表中检索任何类型的对象的一般功能。</target>
        </trans-unit>
        <trans-unit id="59cb7a53195dd959efa385b2b1d8e6b04a5e665a" translate="yes" xml:space="preserve">
          <source>A generated error is when the code itself calls &lt;code&gt;exit/1&lt;/code&gt; or &lt;code&gt;throw/1&lt;/code&gt;. Notice that emulated run-time errors are not denoted as generated errors here.</source>
          <target state="translated">生成的错误是代码本身调用 &lt;code&gt;exit/1&lt;/code&gt; 或 &lt;code&gt;throw/1&lt;/code&gt; 时。请注意，此处未将模拟的运行时错误表示为生成的错误。</target>
        </trans-unit>
        <trans-unit id="8faf45d14b7e5fe4683d094888fbeeed4fc63af0" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library.</source>
          <target state="translated">一个通用的漂亮打印机库。</target>
        </trans-unit>
        <trans-unit id="96309c20b89273ad4e96e038b104fd007caed27f" translate="yes" xml:space="preserve">
          <source>A generic pretty printer library. This module uses a strict-style context passing implementation of John Hughes algorithm, described in &quot;The design of a Pretty-printing Library&quot;. The paragraph-style formatting, empty documents, floating documents, and null strings are my own additions to the algorithm.</source>
          <target state="translated">一个通用的漂亮打印机库。本模块使用了John Hughes算法的严格风格的上下文传递实现,在 &quot;The design of a Pretty-printing Library &quot;中描述。段落式格式化、空文档、浮动文档和空字符串是我自己在算法中添加的。</target>
        </trans-unit>
        <trans-unit id="ac6a4400b941cc8bdd539f01f5213eda72cb86dc" translate="yes" xml:space="preserve">
          <source>A generic single object compare-and-swap operation:</source>
          <target state="translated">一个通用的单对象比较和交换操作。</target>
        </trans-unit>
        <trans-unit id="3f766bd2ae406c1622999afa0312a1512bd99928" translate="yes" xml:space="preserve">
          <source>A generic state machine process (&lt;code&gt;gen_statem&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">使用此模块实现的通用状态机进程（ &lt;code&gt;gen_statem&lt;/code&gt; ）具有一组标准的接口功能，并包括用于跟踪和错误报告的功能。它也适合OTP监管树。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a97b266d23ce2fe3a69cfab0ece23a4c06694585" translate="yes" xml:space="preserve">
          <source>A global group defined with &lt;code&gt;PublishType&lt;/code&gt; equal to &lt;code&gt;hidden&lt;/code&gt; is said to be a hidden global group. All nodes in a hidden global group are hidden nodes, whether they are started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; or not.</source>
          <target state="translated">与定义的全局组 &lt;code&gt;PublishType&lt;/code&gt; 等于 &lt;code&gt;hidden&lt;/code&gt; 被说成是一个隐藏的全局组。隐藏全局组中的所有节点都是隐藏节点，无论它们是否以命令行标记 &lt;code&gt;-hidden&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="be16c14a618ebfab9ed6b6a24231e3d1ce85555b" translate="yes" xml:space="preserve">
          <source>A global name registration facility.</source>
          <target state="translated">一个全球性的名称注册设施。</target>
        </trans-unit>
        <trans-unit id="5ca996b1105de3e2c7c27a0f7cfb576400f98429" translate="yes" xml:space="preserve">
          <source>A global trace flag for the Erlang node that makes all trace time stamps using flag &lt;code&gt;timestamp&lt;/code&gt; to be in CPU time, not wall clock time. That is, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not be used if &lt;code&gt;monotonic_timestamp&lt;/code&gt; or &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; is enabled. Only allowed with &lt;code&gt;PidPortSpec==all&lt;/code&gt;. If the host machine OS does not support high-resolution CPU time measurements, &lt;code&gt;trace/3&lt;/code&gt; exits with &lt;code&gt;badarg&lt;/code&gt;. Notice that most OS do not synchronize this value across cores, so be prepared that time can seem to go backwards when using this option.</source>
          <target state="translated">Erlang节点的全局跟踪标志，使用标志 &lt;code&gt;timestamp&lt;/code&gt; 将所有跟踪时间戳记为CPU时间，而不是挂钟时间。也就是说，如果启用了 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 或 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; ， &lt;code&gt;cpu_timestamp&lt;/code&gt; 使用cpu_timestamp。仅允许使用 &lt;code&gt;PidPortSpec==all&lt;/code&gt; 。如果主机操作系统不支持高分辨率的CPU时间测量，则使用 &lt;code&gt;badarg&lt;/code&gt; 退出 &lt;code&gt;trace/3&lt;/code&gt; 。请注意，大多数操作系统不会跨内核同步此值，因此请做好准备，以使使用此选项时时间似乎倒退。</target>
        </trans-unit>
        <trans-unit id="a35f6209ff3e97a1fbff24a3ba0f5b7de01c5979" translate="yes" xml:space="preserve">
          <source>A good book explaining those reference texts is Dubuisson: ASN.1 - Communication Between Heterogeneous Systems, is free to download at &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解释这些参考文献的好书是Dubuisson：ASN.1-异构系统之间的通信，可从 &lt;code&gt;&lt;a href=&quot;http://www.oss.com/asn1/dubuisson.html&quot;&gt;http://www.oss.com/asn1/dubuisson.html&lt;/a&gt;&lt;/code&gt; 免费下载。</target>
        </trans-unit>
        <trans-unit id="5cb427e2a68f8e5f95a66a1dfb82ade3b982ce6f" translate="yes" xml:space="preserve">
          <source>A good start when programming efficiently is to know how much memory different data types and operations require. It is implementation-dependent how much memory the Erlang data types and other items consume, but the following table shows some figures for the &lt;code&gt;erts-8.0&lt;/code&gt; system in OTP 19.0.</source>
          <target state="translated">有效编程的一个好的开始是知道不同数据类型和操作需要多少内存。Erlang数据类型和其他项目消耗多少内存取决于实现方式，但是下表显示了OTP 19.0中 &lt;code&gt;erts-8.0&lt;/code&gt; 系统的一些数据。</target>
        </trans-unit>
        <trans-unit id="104d4b7a2a11dda4f50138a2b0c530944556b6b2" translate="yes" xml:space="preserve">
          <source>A good way to check if more IO poll threads are needed is to use &lt;code&gt;microstate accounting&lt;/code&gt; and see what the load of the IO poll thread is. If it is high it could be a good idea to add more threads.</source>
          <target state="translated">检查是否需要更多IO轮询线程的一种好方法是使用 &lt;code&gt;microstate accounting&lt;/code&gt; 并查看IO轮询线程的负载。如果该值很高，则最好添加更多线程。</target>
        </trans-unit>
        <trans-unit id="902246acf44b902caba68cbdbd165ab3a85407bd" translate="yes" xml:space="preserve">
          <source>A grammar to parse list expressions (with empty associated code):</source>
          <target state="translated">解析列表表达式的语法(有空的关联代码)。</target>
        </trans-unit>
        <trans-unit id="1046b82d616c92a5ac3eba8ae29c8d175e6a998a" translate="yes" xml:space="preserve">
          <source>A group nested under a parallel group starts executing in parallel with previous (parallel) test cases (no matter what properties the nested group has). However, as test cases are never executed in parallel with &lt;code&gt;init_per_group/2&lt;/code&gt; or &lt;code&gt;end_per_group/2&lt;/code&gt; of the same group, it is only after a nested group has finished that remaining parallel cases in the previous group become spawned.</source>
          <target state="translated">嵌套在并行组下的组开始与先前（并行）测试用例并行执行（无论嵌套组具有什么属性）。但是，由于测试用例永远不会与同一组的 &lt;code&gt;init_per_group/2&lt;/code&gt; 或 &lt;code&gt;end_per_group/2&lt;/code&gt; 并行执行，因此只有在嵌套组完成后才产生前一组中剩余的并行用例。</target>
        </trans-unit>
        <trans-unit id="2bac3d793bd4b0481740f078d1dd54e8fa1f7130" translate="yes" xml:space="preserve">
          <source>A group of functions or processes can be called within a transaction. A transaction can include statements that read, write, or delete data from the DBMS. Many such transactions can run concurrently, and the programmer does not need to explicitly synchronize the processes that manipulate the data.</source>
          <target state="translated">在一个事务中可以调用一组函数或进程。一个事务可以包括从DBMS中读取、写入或删除数据的语句。许多这样的事务可以并发运行,程序员不需要明确地同步操作数据的进程。</target>
        </trans-unit>
        <trans-unit id="05cb23555bdd306501c7337362942fb611d143f7" translate="yes" xml:space="preserve">
          <source>A group of processes can be accessed by a common name. For example, if there is a group named &lt;code&gt;foobar&lt;/code&gt;, there can be a set of processes (which can be located on different nodes) that are all members of the group &lt;code&gt;foobar&lt;/code&gt;. There are no special functions for sending a message to the group. Instead, client functions are to be written with the functions &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; to determine which processes are members of the group. Then the message can be sent to one or more group members.</source>
          <target state="translated">可以使用通用名称访问一组进程。例如，如果有一个名为 &lt;code&gt;foobar&lt;/code&gt; 的组，则可以有一组进程（可以位于不同的节点上），这些进程都是该组 &lt;code&gt;foobar&lt;/code&gt; 成员。没有特殊功能可以向群组发送消息。取而代之的是，应使用 &lt;code&gt;&lt;a href=&quot;#get_members-1&quot;&gt;get_members/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_local_members-1&quot;&gt;get_local_members/1&lt;/a&gt;&lt;/code&gt; 函数编写客户端函数，以确定哪些进程是该组的成员。然后，可以将邮件发送给一个或多个组成员。</target>
        </trans-unit>
        <trans-unit id="5a3229fa1db1fe8eed7e1f7d567d0b55b01718ab" translate="yes" xml:space="preserve">
          <source>A group that starts with (?| resets the capturing parentheses numbers in each alternative (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt;). The assertions at the start of each branch check the next UTF-8 character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of the character are then captured by the appropriate number of groups.</source>
          <target state="translated">以（？|开头的组会重置每个替代项中的捕获括号数字（请参见 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 部分）。每个分支开头的断言会检查下一个UTF-8字符，以获取其编码使用1、2、3，或4个字节，然后按适当数量的组捕获字符的各个字节。</target>
        </trans-unit>
        <trans-unit id="6db07dc0cd651815b5c72435ed2208f519f62680" translate="yes" xml:space="preserve">
          <source>A guard G is a non-empty sequence of guard tests &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt;, and Rep(G) = &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt;.</source>
          <target state="translated">保护G是保护测试 &lt;code&gt;Gt_1, ..., Gt_k&lt;/code&gt; 和Rep（G）= &lt;code&gt;[Rep(Gt_1), ..., Rep(Gt_k)]&lt;/code&gt; 的非空序列。</target>
        </trans-unit>
        <trans-unit id="9da1b8fcba29590ca36e99b9fdb91354688f306d" translate="yes" xml:space="preserve">
          <source>A guard sequence Gs is a sequence of guards &lt;code&gt;G_1; ...; G_k&lt;/code&gt;, and Rep(Gs) = &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt;. If the guard sequence is empty, then Rep(Gs) = &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">保护序列Gs是保护序列 &lt;code&gt;G_1; ...; G_k&lt;/code&gt; 和Rep（Gs）= &lt;code&gt;[Rep(G_1), ..., Rep(G_k)]&lt;/code&gt; 。如果保护序列为空，则Rep（Gs）= &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e607c9ab56bd394d6c9eeddb457df24a34026a6" translate="yes" xml:space="preserve">
          <source>A guard test Gt is one of the following:</source>
          <target state="translated">警卫测试Gt是以下之一。</target>
        </trans-unit>
        <trans-unit id="0958ebfcb794773c3476244fc72f207f83085686" translate="yes" xml:space="preserve">
          <source>A handle to driver-specific data, passed to the driver callbacks. It is a pointer, and is most often type cast to a specific pointer in the driver.</source>
          <target state="translated">驱动程序特定数据的句柄,传递给驱动程序回调。它是一个指针,通常会被类型转换为驱动中的特定指针。</target>
        </trans-unit>
        <trans-unit id="fdc243bdb933b5a71a48ce564407f75cabaaebaf" translate="yes" xml:space="preserve">
          <source>A handler callback module must export:</source>
          <target state="translated">必须导出一个处理程序回调模块。</target>
        </trans-unit>
        <trans-unit id="31be10ebd1dea0e036e6cc2ff50b43986eb9b610" translate="yes" xml:space="preserve">
          <source>A handler can be removed by calling &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt;. Logger calls &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt;, and removes the handler's configuration from the configuration database.</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;logger#remove_handler-1&quot;&gt;logger:remove_handler(Id)&lt;/a&gt;&lt;/code&gt; 删除处理程序。记录器调用 &lt;code&gt;HModule:removing_handler(Config)&lt;/code&gt; ，并从配置数据库中删除处理程序的配置。</target>
        </trans-unit>
        <trans-unit id="8b450cb00cc7d0fceaaaa8e163bad6a1a09d773b" translate="yes" xml:space="preserve">
          <source>A handler is defined as a module exporting at least the following callback function:</source>
          <target state="translated">一个处理程序被定义为至少输出以下回调函数的模块。</target>
        </trans-unit>
        <trans-unit id="a23d43ddf6d207f81a92e3f11ea5d88e0322baa2" translate="yes" xml:space="preserve">
          <source>A hidden node is a node started with the command-line flag &lt;code&gt;-hidden&lt;/code&gt;. Connections between hidden nodes and other nodes are not transitive, they must be set up explicitly. Also, hidden nodes does not show up in the list of nodes returned by &lt;code&gt;nodes()&lt;/code&gt;. Instead, &lt;code&gt;nodes(hidden)&lt;/code&gt; or &lt;code&gt;nodes(connected)&lt;/code&gt; must be used. This means, for example, that the hidden node is not added to the set of nodes that &lt;code&gt;global&lt;/code&gt; is keeping track of.</source>
          <target state="translated">隐藏节点是以命令行标记 &lt;code&gt;-hidden&lt;/code&gt; 开头的节点。隐藏节点和其他节点之间的连接不是可传递的，必须显式设置它们。另外，隐藏节点也不会显示在由 &lt;code&gt;nodes()&lt;/code&gt; 返回的节点列表中。而是必须使用 &lt;code&gt;nodes(hidden)&lt;/code&gt; 或 &lt;code&gt;nodes(connected)&lt;/code&gt; 。例如，这意味着未将隐藏节点添加到 &lt;code&gt;global&lt;/code&gt; 跟踪的节点集中。</target>
        </trans-unit>
        <trans-unit id="3ad527cdee0b441182ba0bc41ca62d2081d24f24" translate="yes" xml:space="preserve">
          <source>A histogram of block sizes where each interval's upper bound is twice as high as the one before it.</source>
          <target state="translated">一个块大小的直方图,其中每个区间的上界是它之前的两倍。</target>
        </trans-unit>
        <trans-unit id="ad63f98e4ec8a5df7f88023c80bfbc7bf7d5bd26" translate="yes" xml:space="preserve">
          <source>A hook function (cf. the &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; type) is passed the current syntax tree node, the context, and a continuation. The context can be examined and manipulated by functions such as &lt;code&gt;get_ctxt_user/1&lt;/code&gt; and &lt;code&gt;set_ctxt_user/2&lt;/code&gt;. The hook must return a &quot;document&quot; data structure (see &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt;); this may be constructed in part or in whole by applying the continuation function. For example, the following is a trivial hook:</source>
          <target state="translated">挂钩函数（参见 &lt;code&gt;&lt;a href=&quot;#type-hook&quot;&gt;hook()&lt;/a&gt;&lt;/code&gt; 类型）被传递给当前的语法树节点，上下文和延续。可以使用诸如 &lt;code&gt;get_ctxt_user/1&lt;/code&gt; 和 &lt;code&gt;set_ctxt_user/2&lt;/code&gt; 之类的函数来检查和操作上下文。挂钩必须返回&amp;ldquo;文档&amp;rdquo;数据结构（请参见 &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best/2&lt;/a&gt;&lt;/code&gt; ）；这可以通过应用延续函数来部分或全部构建。例如，以下是一个琐碎的钩子：</target>
        </trans-unit>
        <trans-unit id="1edf358d74594d5d0d07749392202e53a874bde3" translate="yes" xml:space="preserve">
          <source>A job that alternates between I/O bound and CPU bound can be reclassified and rescheduled using &lt;code&gt;enif_schedule_nif&lt;/code&gt; so that it executes on the correct type of dirty scheduler at all times. For more information see the documentation of the &lt;code&gt;erl(1)&lt;/code&gt; command line arguments &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 重新分类和重新安排在I / O绑定和CPU绑定之间切换的作业，以便始终在正确的脏调度程序类型上执行该作业。有关更多信息，请参见 &lt;code&gt;erl(1)&lt;/code&gt; 命令行参数 &lt;code&gt;&lt;a href=&quot;erl#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erl#+SDio&quot;&gt;+SDio&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="58867f002dc318ccf9bce1131e2694062d5333ed" translate="yes" xml:space="preserve">
          <source>A larger buffer limit allows processes to buffer more outgoing messages over the distribution. When the buffer limit has been reached, sending processes will be suspended until the buffer size has shrunk. The buffer limit is per distribution channel. A higher limit gives lower latency and higher throughput at the expense of higher memory use.</source>
          <target state="translated">更大的缓冲区限制允许进程在分发过程中缓冲更多的外发消息。当达到缓冲区限制时,发送进程将被暂停,直到缓冲区大小缩小。缓冲区限制是针对每个分发通道的。较高的限制可以提供较低的延迟和较高的吞吐量,但代价是较高的内存使用量。</target>
        </trans-unit>
        <trans-unit id="06a81726c24b8781e74e0cf024d9ccac67383c44" translate="yes" xml:space="preserve">
          <source>A level in term &lt;code&gt;CpuTopology&lt;/code&gt; can be omitted if only one entry exists and &lt;code&gt;InfoList&lt;/code&gt; is empty.</source>
          <target state="translated">如果只有一个条目并且 &lt;code&gt;InfoList&lt;/code&gt; 为空，则可以省略术语 &lt;code&gt;CpuTopology&lt;/code&gt; 的级别。</target>
        </trans-unit>
        <trans-unit id="dce227656c4a97473171d894829d7b5055a34016" translate="yes" xml:space="preserve">
          <source>A library application that cannot be started or stopped, does not need any application callback module.</source>
          <target state="translated">一个不能启动或停止的库应用程序,不需要任何应用程序回调模块。</target>
        </trans-unit>
        <trans-unit id="f1237e5b11078ec794450ace16c7850dee19ffaa" translate="yes" xml:space="preserve">
          <source>A line breakpoint can also be created (and deleted) by double-clicking the line when the module is displayed in the View Module window or Attach Process window.</source>
          <target state="translated">在 &quot;查看模块 &quot;窗口或 &quot;附加进程 &quot;窗口中显示模块时,也可以通过双击行来创建(和删除)行断点。</target>
        </trans-unit>
        <trans-unit id="25e27b31c8e51ff696a72775acff4cd63fac142f" translate="yes" xml:space="preserve">
          <source>A line breakpoint is created at a certain line in a module.</source>
          <target state="translated">在模块的某一行创建断点。</target>
        </trans-unit>
        <trans-unit id="98ca655fbbfd2af69c799f1de396c9692c8ffecf" translate="yes" xml:space="preserve">
          <source>A line level calls analysis of &lt;code&gt;channel&lt;/code&gt; can be written to a file using &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;cover:analysis_to_file/1&lt;/code&gt; 将 &lt;code&gt;channel&lt;/code&gt; 线路级别的呼叫分析写入文件：</target>
        </trans-unit>
        <trans-unit id="30f9e5debe76dcfd36d855503d282295078ca73b" translate="yes" xml:space="preserve">
          <source>A link can be removed by calling the BIF &lt;code&gt;unlink(Pid)&lt;/code&gt;.</source>
          <target state="translated">可以通过调用BIF &lt;code&gt;unlink(Pid)&lt;/code&gt; 来删除链接。</target>
        </trans-unit>
        <trans-unit id="b8b621ff75576ed0db731737d0b2db8dd71853fd" translate="yes" xml:space="preserve">
          <source>A link existed between the local process and the remote process at the time of the crash.</source>
          <target state="translated">崩溃时,本地进程和远程进程之间存在链接。</target>
        </trans-unit>
        <trans-unit id="71334f2a43a0426d62a5d4505c43986a1e04107a" translate="yes" xml:space="preserve">
          <source>A link is broken. &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes, and &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; contains the reason for the exit.</source>
          <target state="translated">链接断开。 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 包含链接进程的pid，而 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 包含退出原因。</target>
        </trans-unit>
        <trans-unit id="f6d5b20cc777398a2954a5f904e0c368fb34c735" translate="yes" xml:space="preserve">
          <source>A link to all runs executed from a certain directory is written in the log named &lt;code&gt;all_runs.html&lt;/code&gt; and direct links to all tests (the latest results) are written to the top-level &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">从某个目录执行的所有运行的链接都写在名为 &lt;code&gt;all_runs.html&lt;/code&gt; 的日志中，而所有测试（最新结果）的直接链接都写在顶级 &lt;code&gt;index.html&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="c9ed186e6c9cb98bafec7585f14769f53a755b9c" translate="yes" xml:space="preserve">
          <source>A list comprehension returns a list, where the elements are the result of evaluating &lt;code&gt;Expr&lt;/code&gt; for each combination of generator list elements and bit string generator elements, for which all filters are true.</source>
          <target state="translated">列表推导返回一个列表，其中的元素是对生成器列表元素和位字符串生成器元素的每种组合求值 &lt;code&gt;Expr&lt;/code&gt; 的结果，对于这些组合，所有过滤器均为真。</target>
        </trans-unit>
        <trans-unit id="02a87e72df2e9591f46019f9ed75098ceee2e35d" translate="yes" xml:space="preserve">
          <source>A list comprehension:</source>
          <target state="translated">一个清单的理解。</target>
        </trans-unit>
        <trans-unit id="7085d8980ae301152b6ee803668c44a99ddba230" translate="yes" xml:space="preserve">
          <source>A list is a compound data type with a variable number of terms.</source>
          <target state="translated">列表是一种具有可变项数的复合数据类型。</target>
        </trans-unit>
        <trans-unit id="cdf78c94ee3134a5064c3958c1d7c8e4a3de8736" translate="yes" xml:space="preserve">
          <source>A list must be specified with the number of elements, including the tail, which is the last term preceding &lt;code&gt;ERL_DRV_LIST&lt;/code&gt;.</source>
          <target state="translated">必须指定一个列表，其中包含元素的数量，包括尾部，这是 &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; 之前的最后一项。</target>
        </trans-unit>
        <trans-unit id="70b8617890707dfd903ea1026d415236f1bdc921" translate="yes" xml:space="preserve">
          <source>A list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">可能包含错误指示的 &quot;ActionReply &quot;记录列表。</target>
        </trans-unit>
        <trans-unit id="51c375d52fb989d38f521acbea65939966bc14e9" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;UpdateOp&lt;/code&gt; can be supplied to do many update operations within the object. The operations are carried out in the order specified in the list. If the same counter position occurs more than once in the list, the corresponding counter is thus updated many times, each time based on the previous result. The return value is a list of the new counter values from each update operation in the same order as in the operation list. If an empty list is specified, nothing is updated and an empty list is returned. If the function fails, no updates are done.</source>
          <target state="translated">可以提供 &lt;code&gt;UpdateOp&lt;/code&gt; 的列表以在对象内执行许多更新操作。按照列表中指定的顺序执行操作。如果相同的计数器位置在列表中出现多次，则相应的计数器将因此多次更新，每次都是基于先前的结果。返回值是每个更新操作的新计数器值的列表，其顺序与操作列表中的顺序相同。如果指定了一个空列表，则不进行任何更新，并返回一个空列表。如果功能失败，则不会进行任何更新。</target>
        </trans-unit>
        <trans-unit id="030f0cbd94947cdf93b77d371b60c32ef8fca036" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Memory}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Memory&lt;/code&gt; is how much memory it occupies</source>
          <target state="translated">&lt;code&gt;{Name, Memory}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Name&lt;/code&gt; 是一个片段 &lt;code&gt;Name&lt;/code&gt; ， &lt;code&gt;Memory&lt;/code&gt; 是它占用的内存量</target>
        </trans-unit>
        <trans-unit id="c72f78c95adc9eeb9cf8ccea551cf18350671fbd" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Name, Size}&lt;/code&gt; tuples, where &lt;code&gt;Name&lt;/code&gt; is a fragment &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Size&lt;/code&gt; is how many records it contains</source>
          <target state="translated">&lt;code&gt;{Name, Size}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Name&lt;/code&gt; 是片段 &lt;code&gt;Name&lt;/code&gt; ，而 &lt;code&gt;Size&lt;/code&gt; 是其中包含的记录数</target>
        </trans-unit>
        <trans-unit id="e2180b4c9facbabd3ef7f26e9137ff364cfb6bb1" translate="yes" xml:space="preserve">
          <source>A list of &lt;code&gt;{Pos,Value}&lt;/code&gt; can be supplied to update many elements within the same object. If the same position occurs more than once in the list, the last value in the list is written. If the list is empty or the function fails, no updates are done. The function is also atomic in the sense that other processes can never see any intermediate results.</source>
          <target state="translated">可以提供 &lt;code&gt;{Pos,Value}&lt;/code&gt; 列表来更新同一对象中的许多元素。如果同一位置在列表中出现多次，则写入列表中的最后一个值。如果列表为空或功能失败，则不进行任何更新。在其他进程永远看不到任何中间结果的意义上，该函数也是原子的。</target>
        </trans-unit>
        <trans-unit id="b3c0a15b7c94f033790cb5a9578215ba2c5eb2b7" translate="yes" xml:space="preserve">
          <source>A list of &lt;strong&gt;release upgrade instructions&lt;/strong&gt;, see &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt;. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by &lt;code&gt;systools&lt;/code&gt; when creating the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">&lt;strong&gt;版本升级说明的&lt;/strong&gt;列表，请参阅 &lt;code&gt;&lt;a href=&quot;#Release%20Upgrade%20Instructions&quot;&gt;Release Upgrade Instructions&lt;/a&gt;&lt;/code&gt; 。建议仅使用高级说明。创建 &lt;code&gt;relup&lt;/code&gt; 文件时，这些工具会由 &lt;code&gt;systools&lt;/code&gt; 自动转换为低级指令。</target>
        </trans-unit>
        <trans-unit id="9313069dff4ca94cf23c29546a7ad4ed8220831c" translate="yes" xml:space="preserve">
          <source>A list of DER-encoded certificates in trust order ending with the peer certificate.</source>
          <target state="translated">DER编码的证书列表,按信任顺序排列,以对等证书结束。</target>
        </trans-unit>
        <trans-unit id="cfdc5fa9c2f2d452137349f08f0ebdc7cd06e86e" translate="yes" xml:space="preserve">
          <source>A list of active checkpoints can be obtained with the following functions:</source>
          <target state="translated">可以通过以下函数获得活动检查点的列表。</target>
        </trans-unit>
        <trans-unit id="22e1cd424af636813424f38dcaf9d38efccd215c" translate="yes" xml:space="preserve">
          <source>A list of all valid Erlang Top configuration parameters is available in module &lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;etop&quot;&gt;etop&lt;/a&gt;&lt;/code&gt; 模块中提供了所有有效的Erlang Top配置参数的列表。</target>
        </trans-unit>
        <trans-unit id="84f87e145849ab0fff970812ed60b4958a7995b9" translate="yes" xml:space="preserve">
          <source>A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the dictionary of the application in question. At decode, such AVPs are represented as diameter_avp records in the &lt;code&gt;'AVP'&lt;/code&gt; field of a decoded message or Grouped AVP, the first alternate that succeeds in decoding the AVP setting the record's value field. At encode, values in an &lt;code&gt;'AVP'&lt;/code&gt; list can be passed as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of such a tuple.</source>
          <target state="translated">备用词典模块的列表，可使用这些词典模块来对相关应用程序的词典未定义的AVP进行编码/解码。在解码时，此类AVP表示为已解码消息或分组AVP 的 &lt;code&gt;'AVP'&lt;/code&gt; 字段中的diameter_avp记录，这是成功解码设置记录值字段的AVP的第一个备用项。在编码时， &lt;code&gt;'AVP'&lt;/code&gt; 列表中的值可以作为AVP名称/值2元组传递，并且没有替代定义此类元组的AVP是一种编码错误。</target>
        </trans-unit>
        <trans-unit id="bcb8af967c3f5df09119723a75e7c020769c5e61" translate="yes" xml:space="preserve">
          <source>A list of application versions that the application depends on. An example of such an application version is &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt;. Application versions specified as runtime dependencies are minimum requirements. That is, a larger application version than the one specified in the dependency satisfies the requirement. For information about how to compare application versions, see section &lt;code&gt;Versions&lt;/code&gt; in the System Principles User's Guide.</source>
          <target state="translated">应用程序依赖的应用程序版本的列表。这种应用程序版本的一个示例是 &lt;code&gt;&quot;kernel-3.0&quot;&lt;/code&gt; 。指定为运行时依赖项的应用程序版本是最低要求。也就是说，比依赖关系中指定的版本更大的应用程序版本可以满足要求。有关如何比较应用程序版本的信息，请参阅《系统原理用户指南》中的&amp;ldquo; &lt;code&gt;Versions&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="85bcb2be6c30593796c07db13b64536f31aab04f" translate="yes" xml:space="preserve">
          <source>A list of applications that are included by an application included in the release. The list must be a subset of the included applications specified in the application resource file (&lt;code&gt;Application.app&lt;/code&gt;) and overrides this value. Defaults to the same value as in the application resource file.</source>
          <target state="translated">版本中包含的应用程序包含的应用程序列表。该列表必须是在应用程序资源文件（ &lt;code&gt;Application.app&lt;/code&gt; ）中指定的包括的应用程序的子集，并覆盖此值。缺省值为与应用程序资源文件中的值相同。</target>
        </trans-unit>
        <trans-unit id="73a81a79f1a7098f6cb205944af55c35f111d222" translate="yes" xml:space="preserve">
          <source>A list of atoms corresponding to atoms in the &lt;code&gt;NamedBitList&lt;/code&gt; in the &lt;code&gt;BIT STRING&lt;/code&gt; definition. A &lt;code&gt;BIT STRING&lt;/code&gt; with symbolic names is always decoded to the format shown in the following example:</source>
          <target state="translated">对应于 &lt;code&gt;BIT STRING&lt;/code&gt; 定义中 &lt;code&gt;NamedBitList&lt;/code&gt; 中原子的原子列表。甲 &lt;code&gt;BIT STRING&lt;/code&gt; 用符号名总是解码以在下面的示例中所示的格式：</target>
        </trans-unit>
        <trans-unit id="4416e89ecd0bec31a83597e47f21c9429cab1bb6" translate="yes" xml:space="preserve">
          <source>A list of binaries. This datatype is useful to use together with &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">二进制列表。将此数据类型与 &lt;code&gt;&lt;a href=&quot;erl_nif#enif_inspect_iovec&quot;&gt;enif_inspect_iovec&lt;/a&gt;&lt;/code&gt; 一起使用非常有用。</target>
        </trans-unit>
        <trans-unit id="64654646df6b843e592f4468159e2fedaaec3b28" translate="yes" xml:space="preserve">
          <source>A list of functions specified in option &lt;code&gt;Startup&lt;/code&gt; are executed after startup of the node. Notice that all used modules are to be present in the code path on &lt;code&gt;Host&lt;/code&gt;.</source>
          <target state="translated">在节点启动后，将执行选项 &lt;code&gt;Startup&lt;/code&gt; 中指定的功能列表。注意，所有使用的模块都应存在于 &lt;code&gt;Host&lt;/code&gt; 的代码路径中。</target>
        </trans-unit>
        <trans-unit id="79b9f4cc16d6de8c7e19f996e3ff20895acaba69" translate="yes" xml:space="preserve">
          <source>A list of key-value tuples (that is, a property list) containing runtime configuration data passed from the configuration functions to the test cases.</source>
          <target state="translated">一个包含从配置函数传递给测试用例的运行时配置数据的键值元组列表(即属性列表)。</target>
        </trans-unit>
        <trans-unit id="53072cdf6c2b3e1f0ce0b618f29746a989ccb6e4" translate="yes" xml:space="preserve">
          <source>A list of low-level release upgrade instructions, see &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt;. It consists of the release upgrade instructions from the respective application upgrade files (high-level instructions are translated to low-level instructions), in the same order as in the start script.</source>
          <target state="translated">低级版本升级说明列表，请参阅 &lt;code&gt;&lt;a href=&quot;appup&quot;&gt;appup(4)&lt;/a&gt;&lt;/code&gt; 。它包含来自各个应用程序升级文件的发行升级说明（高级指令转换为低级指令），其顺序与启动脚本中的顺序相同。</target>
        </trans-unit>
        <trans-unit id="c5458cb9ed4430c9a1044722c1c9f0ec73351850" translate="yes" xml:space="preserve">
          <source>A list of match specifications. An empty list is equivalent to &lt;code&gt;true&lt;/code&gt;. For a description of match specifications, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。空列表等效于 &lt;code&gt;true&lt;/code&gt; 。有关匹配规格的说明，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4f24e9180cc135394011e3f9e98998139bc43ae7" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which can be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。匹配在列表 &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; 。 &lt;code&gt;Node&lt;/code&gt; 是发送方的节点名称。 &lt;code&gt;Sender&lt;/code&gt; 是发件人的进程或端口标识，如果发件人未知，则为 &lt;code&gt;undefined&lt;/code&gt; 的原子（远程发件人就是这种情况）。 &lt;code&gt;Msg&lt;/code&gt; 是消息项。可以使用保护功能 &lt;code&gt;self/0&lt;/code&gt; 访问接收过程的pid 。空列表与 &lt;code&gt;true&lt;/code&gt; 相同。有关更多信息，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1ae6c5016a51b941ea9b569f5d1e616278b56ff4" translate="yes" xml:space="preserve">
          <source>A list of match specifications. The matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;. An empty list is the same as &lt;code&gt;true&lt;/code&gt;. For more information, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">比赛规格清单。匹配在列表 &lt;code&gt;[Receiver, Msg]&lt;/code&gt; 。 &lt;code&gt;Receiver&lt;/code&gt; 是接收方的进程或端口标识， &lt;code&gt;Msg&lt;/code&gt; 是消息项。发送进程的PID可以与保护功能进行访问 &lt;code&gt;self/0&lt;/code&gt; 。空列表与 &lt;code&gt;true&lt;/code&gt; 相同。有关更多信息，请参见《用户指南》 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 中的&amp;ldquo; 匹配规格 &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f891abb57f22c043046c0acca9828e5f72f099a9" translate="yes" xml:space="preserve">
          <source>A list of monitors (started by &lt;code&gt;monitor/2&lt;/code&gt;) that are active for the process. For a local process monitor or a remote process monitor by a process identifier, the list consists of:</source>
          <target state="translated">该进程处于活动状态的监视器列表（由 &lt;code&gt;monitor/2&lt;/code&gt; 开头）。对于具有过程标识符的本地过程监视器或远程过程监视器，该列表包括：</target>
        </trans-unit>
        <trans-unit id="1e09e85b1d23a2d1904ace9e97601c063a94ad34" translate="yes" xml:space="preserve">
          <source>A list of node names (atoms), the group nodes.</source>
          <target state="translated">节点名称(原子)的列表,即组节点。</target>
        </trans-unit>
        <trans-unit id="f513e60b833a271eafeea13f285937ef60a9f36a" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes currently synchronized with the local node.</source>
          <target state="translated">节点名称列表,当前与本地节点同步的组节点。</target>
        </trans-unit>
        <trans-unit id="d5813c5a7e310a9d07043782acc2491f544da810" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes to which there are currently no connections.</source>
          <target state="translated">节点名称的列表,即目前没有连接的组节点。</target>
        </trans-unit>
        <trans-unit id="ede2a365270db1734a514f8930fed986e258eb67" translate="yes" xml:space="preserve">
          <source>A list of node names, the group nodes with which the local node has failed to synchronize.</source>
          <target state="translated">节点名称的列表,即本地节点未能同步的组节点。</target>
        </trans-unit>
        <trans-unit id="68320e1e6e32580922546695a30d4ffc50df4758" translate="yes" xml:space="preserve">
          <source>A list of objects and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则返回一个对象列表和一个延续，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 匹配其他对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="795b45a529dceb8a27da1be92835aa76262ca94d" translate="yes" xml:space="preserve">
          <source>A list of pids, specifying the processes that have subscribed to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages.</source>
          <target state="translated">pid列表，指定已订阅 &lt;code&gt;nodeup&lt;/code&gt; 和 &lt;code&gt;nodedown&lt;/code&gt; 消息的进程。</target>
        </trans-unit>
        <trans-unit id="bbc2862b14b19fa3c52a7c39935bdc51459df8ec" translate="yes" xml:space="preserve">
          <source>A list of process identifiers monitoring the process (with &lt;code&gt;monitor/2&lt;/code&gt;).</source>
          <target state="translated">监视进程的进程标识符列表（使用 &lt;code&gt;monitor/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="798f3c6d606c88936e16d8fb3e746a3c0d7e414f" translate="yes" xml:space="preserve">
          <source>A list of start phases and corresponding start arguments for the application. If this key is present, the application master, in addition to the usual call to &lt;code&gt;Module:start/2&lt;/code&gt;, also calls &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; for each start phase defined by key &lt;code&gt;start_phases&lt;/code&gt;. Only after this extended start procedure, &lt;code&gt;application:start(Application)&lt;/code&gt; returns.</source>
          <target state="translated">应用程序的启动阶段和相应的启动参数的列表。如果存在此密钥，则除了通常调用 &lt;code&gt;Module:start/2&lt;/code&gt; 之外，应用程序主控 &lt;code&gt;Module:start_phase(Phase,Type,PhaseArgs)&lt;/code&gt; 为每个由 &lt;code&gt;start_phases&lt;/code&gt; 定义的启动阶段调用Module：start_phase（Phase，Type，PhaseArgs）。仅在此扩展的启动过程之后， &lt;code&gt;application:start(Application)&lt;/code&gt; 才返回。</target>
        </trans-unit>
        <trans-unit id="edf21767ef6072f1fd3b3c1a6a4c7c161dc74414" translate="yes" xml:space="preserve">
          <source>A list of the characters in the matched token.</source>
          <target state="translated">匹配标记中的字符列表。</target>
        </trans-unit>
        <trans-unit id="8133b9a65a9c55bb804a98f418e83c6fd30bd2dd" translate="yes" xml:space="preserve">
          <source>A list of the nodes that do not exist</source>
          <target state="translated">不存在的节点列表。</target>
        </trans-unit>
        <trans-unit id="4787cc71f8b45d2d5a1e6a23232994156e3e6848" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server does not exist</source>
          <target state="translated">服务器不存在的节点列表。</target>
        </trans-unit>
        <trans-unit id="23fbc37251525e0fbe5e6808d56771dd9e1bb61d" translate="yes" xml:space="preserve">
          <source>A list of the nodes where the server terminated before sending any reply.</source>
          <target state="translated">服务器在发送任何回复前终止的节点列表。</target>
        </trans-unit>
        <trans-unit id="86b3af01504c95f1ff0a3bad6e86965e662943b1" translate="yes" xml:space="preserve">
          <source>A list of tokens produced by the scanner should end with a special &lt;code&gt;end_of_input&lt;/code&gt; tuple which the parser is looking for. The format of this tuple should be &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt;, where &lt;code&gt;Endsymbol&lt;/code&gt; is an identifier that is distinguished from all the terminal and non-terminal categories of the syntax rules. The &lt;code&gt;Endsymbol&lt;/code&gt; may be declared in the grammar file (see below).</source>
          <target state="translated">扫描程序生成的令牌列表应以解析器正在寻找的特殊 &lt;code&gt;end_of_input&lt;/code&gt; 元组结尾。该元组的格式应为 &lt;code&gt;{Endsymbol, LastLineNumber}&lt;/code&gt; ，其中 &lt;code&gt;Endsymbol&lt;/code&gt; 是与语法规则的所有终端和非终端类别区分开的标识符。该 &lt;code&gt;Endsymbol&lt;/code&gt; 可以在语法文件中声明（见下文）。</target>
        </trans-unit>
        <trans-unit id="c2109516cde7b07bab03027450759556426aff7c" translate="yes" xml:space="preserve">
          <source>A list of tuples containing results for individual schedulers as well as aggregated averages. &lt;code&gt;Util&lt;/code&gt; is the scheduler utilization as a floating point value between 0.0 and 1.0. &lt;code&gt;Percent&lt;/code&gt; is the same utilization as a more human readable string expressed in percent.</source>
          <target state="translated">元组列表，其中包含各个调度程序的结果以及汇总的平均值。 &lt;code&gt;Util&lt;/code&gt; 是调度程序的利用率，它是介于0.0和1.0之间的浮点值。 &lt;code&gt;Percent&lt;/code&gt; 与以百分比表示的更易理解的字符串的利用率相同。</target>
        </trans-unit>
        <trans-unit id="2ea742332d3293e5cbb6278b7055ef5cb1f029ed" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each function in a module, in decreasing &lt;code&gt;FuncCallCount&lt;/code&gt; order.</source>
          <target state="translated">以 &lt;code&gt;FuncCallCount&lt;/code&gt; 降序排列的元组列表，每个元组用于模块中的每个函数。</target>
        </trans-unit>
        <trans-unit id="d414f3936cc6ab0feb3f8f3f242331f59448312d" translate="yes" xml:space="preserve">
          <source>A list of tuples, one for each module except &lt;code&gt;cprof&lt;/code&gt;, in decreasing &lt;code&gt;ModCallCount&lt;/code&gt; order.</source>
          <target state="translated">元组的列表，一个用于除了每个模块 &lt;code&gt;cprof&lt;/code&gt; ，以递减 &lt;code&gt;ModCallCount&lt;/code&gt; 顺序。</target>
        </trans-unit>
        <trans-unit id="2a515d4554cb24670f64c931a7f1c050e2d9f77e" translate="yes" xml:space="preserve">
          <source>A list representing the tail elements of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">一个表示列表 &lt;code&gt;t&lt;/code&gt; 的尾元素的列表。</target>
        </trans-unit>
        <trans-unit id="49c534723b00f62164b408805f640dc737cc5620" translate="yes" xml:space="preserve">
          <source>A list sorted as follows:</source>
          <target state="translated">名单排序如下:</target>
        </trans-unit>
        <trans-unit id="f5ef252277490863011469cba50309fcc2a552c0" translate="yes" xml:space="preserve">
          <source>A list where the tail is a list is sometimes called a &lt;strong&gt;proper list&lt;/strong&gt;. It is allowed to have a list where the tail is not a list, for example, &lt;code&gt;[a|b]&lt;/code&gt;. However, this type of list is of little practical use.</source>
          <target state="translated">尾部为列表的列表有时称为&lt;strong&gt;适当列表&lt;/strong&gt;。允许有一个尾部不是列表的列表，例如 &lt;code&gt;[a|b]&lt;/code&gt; 。但是，这种类型的列表几乎没有实际用途。</target>
        </trans-unit>
        <trans-unit id="efe540ae45894e0fdbc313179169b5e104e7d954" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list Each element can be:</source>
          <target state="translated">具有与 &lt;code&gt;Cols&lt;/code&gt; 列表一样多的元素的列表每个元素可以是：</target>
        </trans-unit>
        <trans-unit id="9b2d1080e5c727bcb4180b6c054a8305dfd68dfc" translate="yes" xml:space="preserve">
          <source>A list with as many elements as the &lt;code&gt;Cols&lt;/code&gt; list, where each element is the value of the corresponding column. Each element can be:</source>
          <target state="translated">具有与 &lt;code&gt;Cols&lt;/code&gt; 列表一样多的元素的列表，其中每个元素是对应列的值。每个元素可以是：</target>
        </trans-unit>
        <trans-unit id="1f4d38e7e775065b86b76958019e087be5338c72" translate="yes" xml:space="preserve">
          <source>A list with integers &amp;gt; 255 is considered an error if the Unicode translation modifier is not specified:</source>
          <target state="translated">如果未指定Unicode转换修饰符，则整数&amp;gt; 255的列表将被视为错误：</target>
        </trans-unit>
        <trans-unit id="14565d44a02de06df96d7cafd4c87d042823638e" translate="yes" xml:space="preserve">
          <source>A listbox containing the names of all interpreted modules</source>
          <target state="translated">一个包含所有被解释模块名称的列表框。</target>
        </trans-unit>
        <trans-unit id="d04bc0e41b8be3fc83734efd80c9fb1225163fbf" translate="yes" xml:space="preserve">
          <source>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;transport&lt;/code&gt; info returned by a server with a single client connection might look as follows.</source>
          <target state="translated">侦听传输的信息呈现方式略有不同，因为同一 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 可能存在多个接受的连接。由具有单个客户端连接的服务器返回的 &lt;code&gt;transport&lt;/code&gt; 信息可能如下所示。</target>
        </trans-unit>
        <trans-unit id="9f635b77fbd8f2fa61daabd2f18c04196f559460" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字 &lt;code&gt;&lt;a href=&quot;#query_list_comprehension&quot;&gt;query list comprehension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17c58bfa57cd941d6af606b21964e3471f8b0dec" translate="yes" xml:space="preserve">
          <source>A literal data character</source>
          <target state="translated">字面数据字符</target>
        </trans-unit>
        <trans-unit id="b9eff8ef6bae96d4d99cb1d0d45944faf85b28e0" translate="yes" xml:space="preserve">
          <source>A literal string can be written instead of an element:</source>
          <target state="translated">可以写一个文字字符串来代替元素。</target>
        </trans-unit>
        <trans-unit id="c5bb25cde669006f83df9c8db3230c71118a01ae" translate="yes" xml:space="preserve">
          <source>A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded, the new module instance needs to load its own NIF library (or maybe choose not to). The new module instance can, however, choose to load the exact same NIF library as the old code if it wants to. Sharing the dynamic library means that static data defined by the library is shared as well. To avoid unintentionally shared static data between module instances, each Erlang module version can keep its own private data. This private data can be set when the NIF library is loaded and later retrieved by calling &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已加载的NIF库与已加载它的Erlang模块实例相关。如果模块已升级，则新模块实例需要加载自己的NIF库（或选择不加载）。但是，新模块实例可以选择加载与旧代码完全相同的NIF库。共享动态库意味着也共享库定义的静态数据。为了避免模块实例之间意外共享静态数据，每个Erlang模块版本都可以保留自己的私有数据。可以在加载NIF库时设置此私有数据，并稍后通过调用 &lt;code&gt;&lt;a href=&quot;#enif_priv_data&quot;&gt;enif_priv_data&lt;/a&gt;&lt;/code&gt; 进行检索。</target>
        </trans-unit>
        <trans-unit id="3b6d76f899d39de86797bece2df0524e5c5bc58f" translate="yes" xml:space="preserve">
          <source>A log file can be opened more than once by giving different values to option &lt;code&gt;name&lt;/code&gt; or by using the same file when distributing a log on different nodes. It is up to the user of module &lt;code&gt;disk_log&lt;/code&gt; to ensure that not more than one disk log process has write access to any file, otherwise the file can be corrupted.</source>
          <target state="translated">日志文件可以通过授予期权不同的值被打开不止一次 &lt;code&gt;name&lt;/code&gt; 或通过分发不同节点上的日志时使用相同的文件。模块 &lt;code&gt;disk_log&lt;/code&gt; 的用户要确保对一个文件的写访问权限不超过一个磁盘日志进程，否则该文件可能会损坏。</target>
        </trans-unit>
        <trans-unit id="0f75009c18af2951c814381c778a999ec618f179" translate="yes" xml:space="preserve">
          <source>A log file for one particular test case. Also called the test case log file.</source>
          <target state="translated">一个特定测试用例的日志文件。也叫测试用例日志文件。</target>
        </trans-unit>
        <trans-unit id="6a0809efff21f90864c4f42725c904032725ee3b" translate="yes" xml:space="preserve">
          <source>A logical error is when a program does not behave as intended, but does not crash. An example is that nothing happens when a button in a graphical user interface is clicked.</source>
          <target state="translated">逻辑错误是指一个程序没有按照预期的方式运行,但没有崩溃。例如,当点击图形用户界面中的一个按钮时,没有任何事情发生。</target>
        </trans-unit>
        <trans-unit id="5ca61b37a0ea4d7b34c40913d6020ff25d24aa5f" translate="yes" xml:space="preserve">
          <source>A long queue of requests can cause a user-perceived delay, as earlier requests can take a long time to complete. The HTTP/1.1 specification suggests a limit of two persistent connections per server, which is the default value of option &lt;code&gt;max_sessions&lt;/code&gt;.</source>
          <target state="translated">较长的请求队列可能会导致用户察觉到延迟，因为较早的请求可能需要很长时间才能完成。HTTP / 1.1规范建议每个服务器限制两个持久连接，这是选项 &lt;code&gt;max_sessions&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="4935bb183b98bea21599c5ff3981cab6721e4f54" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; is replaced with &lt;code&gt;Replacement&lt;/code&gt;, where all occurrences of a variable &lt;code&gt;Var&lt;/code&gt; from the macro definition are replaced with the corresponding argument &lt;code&gt;Arg&lt;/code&gt;.</source>
          <target state="translated">宏 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 被 &lt;code&gt;Replacement&lt;/code&gt; 替换，其中所有来自宏定义的变量 &lt;code&gt;Var&lt;/code&gt; 都被替换为对应的参数 &lt;code&gt;Arg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d257ea7c2cd44ef76446306fb9244bed68bdcdf" translate="yes" xml:space="preserve">
          <source>A macro &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; with a (possibly empty) list of arguments results in an error message if there is at least one definition of &lt;code&gt;Func&lt;/code&gt; with arguments, but none with N arguments.</source>
          <target state="translated">如果至少有一个带参数的 &lt;code&gt;Func&lt;/code&gt; 定义，但是没有N个参数 &lt;code&gt;?Func(Arg1,...,ArgN)&lt;/code&gt; 带有（可能为空）参数列表的宏？Func（Arg1，...，ArgN）会导致错误消息。</target>
        </trans-unit>
        <trans-unit id="73f534c58d9ea31eaf8fb9427562c3ead1595373" translate="yes" xml:space="preserve">
          <source>A macro definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the macro.</source>
          <target state="translated">宏定义可以放在模块的属性和函数声明中的任何位置,但定义必须在使用宏之前。</target>
        </trans-unit>
        <trans-unit id="b023cfdfd3e8c944def982069911746c56dbb5ff" translate="yes" xml:space="preserve">
          <source>A macro is also used when spawning the server process:</source>
          <target state="translated">在生成服务器进程时,也会用到一个宏。</target>
        </trans-unit>
        <trans-unit id="7f21e1aec85a7381be96d5bfbfec7f097bd47be9" translate="yes" xml:space="preserve">
          <source>A macro is defined as follows:</source>
          <target state="translated">宏的定义如下:</target>
        </trans-unit>
        <trans-unit id="ce03814050d5f8680e3201e0fe96acef21b95f3d" translate="yes" xml:space="preserve">
          <source>A macro is used as follows:</source>
          <target state="translated">宏的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="88726427099902153bb75f43bd476a92b9488c2a" translate="yes" xml:space="preserve">
          <source>A manager generates commands and receives notifications from agents. There usually are only a few managers in a system.</source>
          <target state="translated">管理员生成命令并接收来自代理的通知。一个系统中通常只有几个管理器。</target>
        </trans-unit>
        <trans-unit id="11e6d2013425970bf367a17f1b0c89bb48e7ff98" translate="yes" xml:space="preserve">
          <source>A map containing information about a specific thread. The percentages in the map can be either run-time or real-time depending on if &lt;code&gt;runtime&lt;/code&gt; or &lt;code&gt;realtime&lt;/code&gt; was requested from &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;system&lt;/code&gt; is the percentage of total system time for this specific thread.</source>
          <target state="translated">包含有关特定线程信息的映射。映射中的百分比可以是运行时或实时的，具体取决于是否从 &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 请求 &lt;code&gt;runtime&lt;/code&gt; 或 &lt;code&gt;realtime&lt;/code&gt; 。 &lt;code&gt;system&lt;/code&gt; 是此特定线程在系统总时间中所占的百分比。</target>
        </trans-unit>
        <trans-unit id="c1a5aa45e09b54b7bc479445ee3316a7d38b6bc0" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states and the number of microseconds spent in it.</source>
          <target state="translated">一张地图,包含了不同的微观状态核算状态以及在其中花费的微秒数。</target>
        </trans-unit>
        <trans-unit id="55baef3a4a4f36d3a95ce66a57813b6156ada372" translate="yes" xml:space="preserve">
          <source>A map containing the different microstate accounting states. Each value in the map contains another map with the percentage of time that this thread has spent in the specific state. Both the percentage of &lt;code&gt;system&lt;/code&gt; time and the time for that specific &lt;code&gt;thread&lt;/code&gt; is part of the map.</source>
          <target state="translated">包含不同微状态会计状态的地图。映射中的每个值都包含另一个映射，以及该线程在特定状态下所花费的时间百分比。 &lt;code&gt;system&lt;/code&gt; 时间百分比和该特定 &lt;code&gt;thread&lt;/code&gt; 的时间都属于映射。</target>
        </trans-unit>
        <trans-unit id="55c86ea1a266f601e2fcf39f41d436ed4bb1d415" translate="yes" xml:space="preserve">
          <source>A map is a compound data type with a variable number of key-value associations:</source>
          <target state="translated">地图是一种复合数据类型,其键值关联的数量可变。</target>
        </trans-unit>
        <trans-unit id="6df3d7501dc214f5a620dc3e70ec00231ed3a7da" translate="yes" xml:space="preserve">
          <source>A map iterator is only useful during the lifetime of environment &lt;code&gt;env&lt;/code&gt; that the &lt;code&gt;map&lt;/code&gt; belongs to. The iterator must be destroyed by calling &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">一种地图迭代器是环境的寿命期间只有用 &lt;code&gt;env&lt;/code&gt; ，该 &lt;code&gt;map&lt;/code&gt; 属于。必须通过调用 &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_destroy&quot;&gt;enif_map_iterator_destroy&lt;/a&gt;&lt;/code&gt; 销毁迭代器：</target>
        </trans-unit>
        <trans-unit id="48183a4afcb12654d2835dae35952f5ae81cc70f" translate="yes" xml:space="preserve">
          <source>A map must be specified with the number of key-value pairs &lt;code&gt;N&lt;/code&gt;. The key-value pairs must precede the &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; in this order: &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt;. Duplicate keys are not allowed.</source>
          <target state="translated">必须使用键-值对 &lt;code&gt;N&lt;/code&gt; 的数量指定映射。键值对必须按以下顺序在 &lt;code&gt;ERL_DRV_MAP&lt;/code&gt; 之前： &lt;code&gt;key1,value1,key2,value2,...,keyN,valueN&lt;/code&gt; 。不允许重复的密钥。</target>
        </trans-unit>
        <trans-unit id="31783f08d32874056a3057b68b1693f84e957994" translate="yes" xml:space="preserve">
          <source>A match specification can turn on or off sequential tracing. This function returns a match specification, which turns on sequential tracing with the specified &lt;code&gt;Flags&lt;/code&gt;.</source>
          <target state="translated">匹配规范可以打开或关闭顺序跟踪。该函数返回一个匹配规范，这将导通顺序追踪具有指定 &lt;code&gt;Flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6ddfb750b1e05982e25e257ab27afe27127e930" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;'receive'&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;, &lt;code&gt;is_seq_trace&lt;/code&gt;, &lt;code&gt;get_seq_token&lt;/code&gt;, &lt;code&gt;set_seq_token&lt;/code&gt;, &lt;code&gt;enable_trace&lt;/code&gt;, &lt;code&gt;disable_trace&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;silent&lt;/code&gt;, and &lt;code&gt;process_dump&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'receive'&lt;/code&gt; 跟踪的匹配规范可以使用所有保护和主体函数，但 &lt;code&gt;caller&lt;/code&gt; ， &lt;code&gt;is_seq_trace&lt;/code&gt; ， &lt;code&gt;get_seq_token&lt;/code&gt; ， &lt;code&gt;set_seq_token&lt;/code&gt; ， &lt;code&gt;enable_trace&lt;/code&gt; ， &lt;code&gt;disable_trace&lt;/code&gt; ， &lt;code&gt;trace&lt;/code&gt; ， &lt;code&gt;silent&lt;/code&gt; 和 &lt;code&gt;process_dump&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="3c1a2a4c3c454f94b1fa52f933e896cf4b6f1dcf" translate="yes" xml:space="preserve">
          <source>A match specification for &lt;code&gt;send&lt;/code&gt; trace can use all guard and body functions except &lt;code&gt;caller&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 跟踪的匹配规范可以使用除 &lt;code&gt;caller&lt;/code&gt; 以外的所有保护和主体功能。</target>
        </trans-unit>
        <trans-unit id="775d888e22b3e82c594b4190a83e5f1b3950e566" translate="yes" xml:space="preserve">
          <source>A match specification used in &lt;code&gt;ets(3)&lt;/code&gt; can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">&lt;code&gt;ets(3)&lt;/code&gt; 中使用的匹配规范可以在以下&lt;strong&gt;非正式&lt;/strong&gt;语法中进行描述：</target>
        </trans-unit>
        <trans-unit id="83306dec354257cfad7ed48f591c0ff422b66b68" translate="yes" xml:space="preserve">
          <source>A match specification used in tracing can be described in the following &lt;strong&gt;informal&lt;/strong&gt; grammar:</source>
          <target state="translated">可以在以下&lt;strong&gt;非正式&lt;/strong&gt;语法中描述用于跟踪的匹配规范：</target>
        </trans-unit>
        <trans-unit id="c3565e8901b4b3516619d211f5de1eb7c7f5a2de" translate="yes" xml:space="preserve">
          <source>A match specification, see above.</source>
          <target state="translated">匹配规格,见上文。</target>
        </trans-unit>
        <trans-unit id="bfda4d3ad9a01b6a5ad6d226917a35814c884393" translate="yes" xml:space="preserve">
          <source>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).</source>
          <target state="translated">字符串 &quot;aaaa &quot;的匹配总是失败,但每次回溯发生之前都会进行调用(在本例中,10次)。</target>
        </trans-unit>
        <trans-unit id="6f29c903e3589affa8d324ed95b31c5c61e91931" translate="yes" xml:space="preserve">
          <source>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the &lt;code&gt;mmap&lt;/code&gt; system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</source>
          <target state="translated">内存段分配器。其他分配器使用它来分配内存段，并且仅在具有 &lt;code&gt;mmap&lt;/code&gt; 系统调用的系统上可用。被释放的内存段在销毁之前会在段缓存中保留一段时间。分配段后，将尽可能使用缓存的段，而不是创建新的段。这样可以减少进行系统调用的次数。</target>
        </trans-unit>
        <trans-unit id="95c010e88e46ea60a66fde46681834435a05128c" translate="yes" xml:space="preserve">
          <source>A minimal example of a NIF library can look as follows:</source>
          <target state="translated">一个最小的NIF库的例子如下。</target>
        </trans-unit>
        <trans-unit id="87e74e52d3b9087104d60a0e55cc35f5604c3259" translate="yes" xml:space="preserve">
          <source>A minimum Windows NT installation with networking needs 250 MB, and an extra 130 MB for the swap file.</source>
          <target state="translated">最低限度的Windows NT安装与网络需要250MB,额外的130MB用于交换文件。</target>
        </trans-unit>
        <trans-unit id="ccca12c026cce7e56e7fa3fc8b384f432861042d" translate="yes" xml:space="preserve">
          <source>A misbehaving filter will be removed.</source>
          <target state="translated">行为不当的过滤器将被移除。</target>
        </trans-unit>
        <trans-unit id="06a13e586eee527b77c49434cc8f50ec42065c62" translate="yes" xml:space="preserve">
          <source>A module attribute consists of a tag and a value:</source>
          <target state="translated">一个模块属性由一个标签和一个值组成。</target>
        </trans-unit>
        <trans-unit id="dab39b0e69b099bf9e59a93c7991371da0a76b13" translate="yes" xml:space="preserve">
          <source>A module can also be used to represent a test set; see &lt;code&gt;ModuleName&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">模块也可以用来表示测试集。请参阅下面&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 下的 &lt;code&gt;ModuleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c521c6a7b79de7232798a925aa632173f772fa44" translate="yes" xml:space="preserve">
          <source>A module can be specified by its module name (atom) or filename.</source>
          <target state="translated">一个模块可以由它的模块名(原子)或文件名来指定。</target>
        </trans-unit>
        <trans-unit id="4d45b4986dc3244ccb1e4bc16129b111cc4334f7" translate="yes" xml:space="preserve">
          <source>A module can export some types to declare that other modules are allowed to refer to them as &lt;strong&gt;remote types&lt;/strong&gt;. This declaration has the following form:</source>
          <target state="translated">模块可以导出某些类型，以声明允许其他模块将它们称为&lt;strong&gt;远程类型&lt;/strong&gt;。该声明具有以下形式：</target>
        </trans-unit>
        <trans-unit id="c7142355abe56d1cdac6e2f4354e4ece086ad515" translate="yes" xml:space="preserve">
          <source>A module can use data generated by previous modules in the Erlang webserver API module sequence or generate data to be used by consecutive Erlang Web Server API modules. This is possible owing to an internal list of key-value tuples, referred to as interaction data.</source>
          <target state="translated">一个模块可以使用Erlang webserver API模块序列中前一个模块生成的数据,也可以生成数据供连续的Erlang Web Server API模块使用。之所以能够做到这一点,是因为有一个内部的键值元组列表,被称为交互数据。</target>
        </trans-unit>
        <trans-unit id="18900dbf59944d973af029df61cc566921cfdcc4" translate="yes" xml:space="preserve">
          <source>A module contains an &lt;code&gt;-on_load function&lt;/code&gt;.</source>
          <target state="translated">一个模块包含一个 &lt;code&gt;-on_load function&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93157c2c246b2925926264e6f2195084f98fb551" translate="yes" xml:space="preserve">
          <source>A module declaration consists of a sequence of forms, which are either function declarations or attributes.</source>
          <target state="translated">一个模块声明由一系列形式组成,这些形式可以是函数声明,也可以是属性。</target>
        </trans-unit>
        <trans-unit id="610a0d8699dc82d5f83c6e9ce3301c3d01553b3b" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour. The info functions of this module will be called at various stages of delivery.</source>
          <target state="translated">实现 &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; 行为的模块。该模块的信息功能将在交付的各个阶段被调用。</target>
        </trans-unit>
        <trans-unit id="c6984ab40887600f2a1370e3539c8ccdba1c5de4" translate="yes" xml:space="preserve">
          <source>A module is included more than once in &lt;code&gt;Modules&lt;/code&gt;.</source>
          <target state="translated">一个模块不止一次包含在 &lt;code&gt;Modules&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cd8890dc272bd36c3a480c734c6925501fff4e99" translate="yes" xml:space="preserve">
          <source>A module specified as a &lt;code&gt;transport_module&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; must implement the interface documented here. The interface consists of a function with which diameter starts a transport process and a message interface with which the transport process communicates with the process that starts it (aka its parent).</source>
          <target state="translated">指定为一个模块 &lt;code&gt;transport_module&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 必须实现这里记录的接口。该接口包括一个函数，直径用于启动传输过程；消息接口，用于与传输过程与启动它的过程（即其父进程）进行通信。</target>
        </trans-unit>
        <trans-unit id="492b06093c2441b11284458e2b4d042f4ba5283d" translate="yes" xml:space="preserve">
          <source>A monitor can be removed by calling &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt;.</source>
          <target state="translated">可以通过调用 &lt;code&gt;erlang:demonitor(Ref)&lt;/code&gt; 删除监视器。</target>
        </trans-unit>
        <trans-unit id="1c985866a716b1f38553284b766cb9d078544843" translate="yes" xml:space="preserve">
          <source>A monitor created as &lt;code&gt;unloaded_only&lt;/code&gt; behaves exactly as one created as &lt;code&gt;unloaded&lt;/code&gt; except that the &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; message is never sent, but the monitor instead persists until the driver &lt;strong&gt;really&lt;/strong&gt; gets unloaded.</source>
          <target state="translated">为创建一个监视器 &lt;code&gt;unloaded_only&lt;/code&gt; 的行为完全是一个为创建 &lt;code&gt;unloaded&lt;/code&gt; 除了 &lt;code&gt;{'UP', reference(), driver, Name, unload_cancelled}&lt;/code&gt; 从不发送消息，但显示器，而不是持续直到司机&lt;strong&gt;真的&lt;/strong&gt;被卸载。</target>
        </trans-unit>
        <trans-unit id="e224d8a9f9c0d94e691cbfa15fef0b1fe2f4e60f" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the Erlang runtime system. Erlang monotonic time increases since some unspecified point in time. To retrieve it, call &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang运行时系统提供的单调增加的时间。从某个未指定的时间点开始，Erlang单调时间增加。要检索它，请调用 &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bcff3bd090752a02621fd3d2ad9e629fddd5e95" translate="yes" xml:space="preserve">
          <source>A monotonically increasing time provided by the OS. This time does not leap and has a relatively steady frequency although not completely correct. However, it is not uncommon that OS monotonic time stops if the system is suspended. This time typically increases since some unspecified point in time that is not connected to &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. This type of time is not necessarily provided by all OSs.</source>
          <target state="translated">操作系统提供的单调增加的时间。尽管不是完全正确，但此时间不会跳跃并且具有相对稳定的频率。但是，如果系统挂起，则操作系统单调时间停止的情况并不罕见。该时间通常会增加，因为某些未指定的时间点未连接到 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 。并非所有操作系统都必须提供这种类型的时间。</target>
        </trans-unit>
        <trans-unit id="5712c1400575e91c9656e681e7475784bdfd9eda" translate="yes" xml:space="preserve">
          <source>A more complicated example with two quad core processors, each processor in its own NUMA node. The ordering of logical processors is a bit weird. This to give a better example of identifier lists:</source>
          <target state="translated">一个更复杂的例子,有两个四核处理器,每个处理器在自己的NUMA节点上。逻辑处理器的排序有点奇怪。这是为了给标识符列表一个更好的例子。</target>
        </trans-unit>
        <trans-unit id="a0d3ff79b050cf4e67f5f12480ec66e526e82e53" translate="yes" xml:space="preserve">
          <source>A more detailed internal representation of the state of this process.</source>
          <target state="translated">对这一过程的状态进行更详细的内部表述。</target>
        </trans-unit>
        <trans-unit id="f3c43b55cc6e4ec72f53a82fa0f070f9038b700e" translate="yes" xml:space="preserve">
          <source>A more precise language for MIB specification</source>
          <target state="translated">更精确的MIB规范语言</target>
        </trans-unit>
        <trans-unit id="d9a6a54885c00dec728fc7fc51d18dd588db7351" translate="yes" xml:space="preserve">
          <source>A more refined version of this format handler is function &lt;code&gt;handle_gc/4&lt;/code&gt; in module &lt;code&gt;multitrace.erl&lt;/code&gt; included in directory &lt;code&gt;src&lt;/code&gt; of the Observer application.</source>
          <target state="translated">此格式处理程序的一个更完善的版本是Observer应用程序的目录 &lt;code&gt;src&lt;/code&gt; 中包含的 &lt;code&gt;multitrace.erl&lt;/code&gt; 模块中的 &lt;code&gt;handle_gc/4&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="5d37f040ad3ea680b60e046bb149872d221815ff" translate="yes" xml:space="preserve">
          <source>A multi-lingual SNMP manager.</source>
          <target state="translated">一个多语言的SNMP管理器。</target>
        </trans-unit>
        <trans-unit id="9e37a488733c4647d4a17da583fd3b03c8d0d81b" translate="yes" xml:space="preserve">
          <source>A name (an Erlang atom) associated with a data value read from a configuration file.</source>
          <target state="translated">一个与从配置文件中读取的数据值相关联的名称(一个Erlang原子)。</target>
        </trans-unit>
        <trans-unit id="2416bd3c84f93d0172f4762c1b29e0836c7a7539" translate="yes" xml:space="preserve">
          <source>A name and association to configuration data introduced through a require statement, or a call to &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt;.</source>
          <target state="translated">通过require语句或对 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 的调用（例如 &lt;code&gt;ct:require(mynodename,{node,[telnet]})&lt;/code&gt; )引入的配置数据的名称和关联。</target>
        </trans-unit>
        <trans-unit id="64a56d53bccebb00764e45b858a26b5ebf2ade91" translate="yes" xml:space="preserve">
          <source>A name constructed from the name of the function in which they are created</source>
          <target state="translated">由创建它们的函数名称构建的名称。</target>
        </trans-unit>
        <trans-unit id="ccf5e0e4e127bfae4bef5668c5a9b13172a11e7a" translate="yes" xml:space="preserve">
          <source>A name for the data must be allocated in the suite using &lt;code&gt;require&lt;/code&gt; (see the example above). Pass this name as argument &lt;code&gt;SnmpAppConfName&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ct_snmp&lt;/code&gt; specifies default values for some &lt;code&gt;SNMP&lt;/code&gt; application configuration parameters (such as &lt;code&gt;{verbosity,trace}&lt;/code&gt; for parameter &lt;code&gt;config&lt;/code&gt;). This set of defaults is merged with the parameters specified by the user. The user values override &lt;code&gt;ct_snmp&lt;/code&gt; defaults.</source>
          <target state="translated">数据名称必须在套件中使用 &lt;code&gt;require&lt;/code&gt; 分配（请参见上面的示例）。将此名称作为参数 &lt;code&gt;SnmpAppConfName&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start/3&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ct_snmp&lt;/code&gt; 为某些 &lt;code&gt;SNMP&lt;/code&gt; 应用程序配置参数（例如，参数 &lt;code&gt;config&lt;/code&gt; 的 &lt;code&gt;{verbosity,trace}&lt;/code&gt; ）指定默认值。这组默认值与用户指定的参数合并。用户值将覆盖 &lt;code&gt;ct_snmp&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="5489bf9abf580e46c80a7d46f5c6b357c56bfd5f" translate="yes" xml:space="preserve">
          <source>A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.</source>
          <target state="translated">这个动词总是需要一个名字。在一个模式中可以有任意多的(*MARK)实例,它们的名字不一定是唯一的。</target>
        </trans-unit>
        <trans-unit id="37561d5bd1b8f3c3ed788a8368cee35cffb7641d" translate="yes" xml:space="preserve">
          <source>A native function doing &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; before returning degrades responsiveness of the VM, and can cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that can occur because of lengthy work can also vary between Erlang/OTP releases.</source>
          <target state="translated">在返回之前进行 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;lengthy work&lt;/a&gt;&lt;/code&gt; 本机功能会降低VM的响应能力，并可能导致其他奇怪的行为。这种奇怪的行为包括但不限于极端的内存使用情况以及调度程序之间的不良负载平衡。在Erlang / OTP发行版之间，由于冗长的工作而可能发生的奇怪行为也可能有所不同。</target>
        </trans-unit>
        <trans-unit id="054cf9ceb563ed6f90ffbc9bbce068da6480e085" translate="yes" xml:space="preserve">
          <source>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM &lt;strong&gt;cannot&lt;/strong&gt; provide the same services as provided when executing Erlang code, such as pre-emptive scheduling or memory protection. If the native function does not behave well, the whole VM will misbehave.</source>
          <target state="translated">执行本机功能作为VM的本机代码的直接扩展。执行不是在安全的环境中进行的。VM &lt;strong&gt;无法&lt;/strong&gt;提供执行Erlang代码时提供的相同服务，例如抢先式调度或内存保护。如果本机功能运行不正常，则整个VM都会出现异常。</target>
        </trans-unit>
        <trans-unit id="5d7156f3c126c629744aa907155b989bd0af5b92" translate="yes" xml:space="preserve">
          <source>A native function that crash will crash the whole VM.</source>
          <target state="translated">一个原生函数如果崩溃,会使整个虚拟机崩溃。</target>
        </trans-unit>
        <trans-unit id="a596b85ce60a4ebd518468dd4ada66946ee5ba8d" translate="yes" xml:space="preserve">
          <source>A native signed 64-bit integer type.</source>
          <target state="translated">一个原生的有符号的64位整数类型。</target>
        </trans-unit>
        <trans-unit id="d333b99d2c176e6cef29cdbe662fff2fc82351f6" translate="yes" xml:space="preserve">
          <source>A native unsigned 64-bit integer type.</source>
          <target state="translated">本机无符号64位整数类型。</target>
        </trans-unit>
        <trans-unit id="1a25fa736ef55d7f9c1d89a3af60f13910153e4c" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;WindowBits&lt;/code&gt; value makes zlib ignore the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">如果 &lt;code&gt;WindowBits&lt;/code&gt; 值为负，则zlib将忽略流中的zlib标头（和校验和）。请注意，zlib源仅将此作为未记录的功能提及。</target>
        </trans-unit>
        <trans-unit id="bff6f239743ba458b6fef3d31577263304f30dcc" translate="yes" xml:space="preserve">
          <source>A negative length can be used to extract bytes at the end of a binary:</source>
          <target state="translated">负长度可以用来提取二进制末尾的字节。</target>
        </trans-unit>
        <trans-unit id="6a5647dc70e502438e63ae1f528d8168602285f6" translate="yes" xml:space="preserve">
          <source>A negative response can look as follows:</source>
          <target state="translated">消极的反应可以如下:</target>
        </trans-unit>
        <trans-unit id="acfd9f30ed035c8f515380634a9f49e2e6305307" translate="yes" xml:space="preserve">
          <source>A negative value causes the termination of the runtime system to wait indefinitely until the crash dump file has been completly written. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">负值会导致运行时系统终止无限期等待，直到完全写入故障转储文件为止。这是如果选项默认 &lt;code&gt;-heart&lt;/code&gt; 是&lt;strong&gt;不会&lt;/strong&gt;传递到 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="9ad2ef1372f693b05aa57e2e774e90e14b42ac7f" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation.</source>
          <target state="translated">例如,网络接口过滤器可以在测试期间使用或用于负载调节。</target>
        </trans-unit>
        <trans-unit id="a5da2ab0a310bd02dc005df1f2a390906381786a" translate="yes" xml:space="preserve">
          <source>A network interface filter can e.g. be used during testing or for load regulation. If the intended use is load regulation, see also &lt;code&gt;req_limit&lt;/code&gt; and the function &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">网络接口过滤器可以例如在测试期间使用或用于负载调节。如果预期用途是负载调节，则另请参见 &lt;code&gt;req_limit&lt;/code&gt; 和函数 &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;register_notification_filter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a37e856dd2d89d23cca0a3d2993676ef15b297" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;person&lt;/code&gt; record is created as follows:</source>
          <target state="translated">创建新的 &lt;code&gt;person&lt;/code&gt; 记录，如下所示：</target>
        </trans-unit>
        <trans-unit id="0cb57df1a585271753d77c0b683d96263a8aeb0a" translate="yes" xml:space="preserve">
          <source>A new boot script was generated, without the &lt;code&gt;local&lt;/code&gt; option set, before the release package was made. In the release package, all application directories are placed under &lt;code&gt;lib&lt;/code&gt;. You do not know where the release package will be installed, so no hard-coded absolute paths are allowed.</source>
          <target state="translated">在制作发行包之前，生成了一个新的引导脚本，没有设置 &lt;code&gt;local&lt;/code&gt; 选项。在发行包中，所有应用程序目录均位于 &lt;code&gt;lib&lt;/code&gt; 下。您不知道发行软件包的安装位置，因此不允许使用硬编码的绝对路径。</target>
        </trans-unit>
        <trans-unit id="0cd3d52715f74b16be431ae39bdcad7432af2c3a" translate="yes" xml:space="preserve">
          <source>A new interface &lt;code&gt;delete/1&lt;/code&gt; is now added to handle the case when a process wants to discard an index table (i.e. to build a completely new). Any application using transient snmp indexes has to be modified to handle this.</source>
          <target state="translated">现在添加了一个新的接口 &lt;code&gt;delete/1&lt;/code&gt; 来处理当进程要放弃索引表（即构建一个全新表）时的情况。任何使用瞬态snmp索引的应用程序都必须进行修改才能处理。</target>
        </trans-unit>
        <trans-unit id="7813433a94ab5122a108632d44422a9630945f8c" translate="yes" xml:space="preserve">
          <source>A new process is started by the application of &lt;code&gt;Module:Function&lt;/code&gt; to &lt;code&gt;Args&lt;/code&gt;. The process is monitored at the same time. Returns the process identifier and a reference for the monitor. Otherwise works like &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;Module:Function&lt;/code&gt; 应用于 &lt;code&gt;Args&lt;/code&gt; 可以启动一个新过程。同时监视该过程。返回进程标识符和监视器的引用。否则像 &lt;code&gt;&lt;a href=&quot;#spawn-3&quot;&gt;spawn/3&lt;/a&gt;&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="4c6aeb17dbb1f994107439b1a93fe0bdeabaadd7" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value and &lt;code&gt;OldRecords&lt;/code&gt; contains the records before the operation is performed. Notice that the new content depends on the table type.</source>
          <target state="translated">一条新记录已被写入。 &lt;code&gt;NewRecord&lt;/code&gt; 包含新记录值，而 &lt;code&gt;OldRecords&lt;/code&gt; 包含执行操作之前的记录。请注意，新内容取决于表类型。</target>
        </trans-unit>
        <trans-unit id="eecdd1aca65c090cd037cecb43b60372b3e2d23d" translate="yes" xml:space="preserve">
          <source>A new record has been written. &lt;code&gt;NewRecord&lt;/code&gt; contains the new record value.</source>
          <target state="translated">一条新记录已被写入。 &lt;code&gt;NewRecord&lt;/code&gt; 包含新的记录值。</target>
        </trans-unit>
        <trans-unit id="bcbee27c7629c70c521974bc4a2ef6365b44965e" translate="yes" xml:space="preserve">
          <source>A new version of the &lt;code&gt;ch_app.app&lt;/code&gt; file must now be created, where the version is updated:</source>
          <target state="translated">现在必须创建 &lt;code&gt;ch_app.app&lt;/code&gt; 文件的新版本，并在该版本中进行更新：</target>
        </trans-unit>
        <trans-unit id="207842ca1ef434b687fe891079409854db11ce8f" translate="yes" xml:space="preserve">
          <source>A newline convention can also be specified by starting a pattern string with one of the following five sequences:</source>
          <target state="translated">也可以通过以下列五个序列之一开始模式字符串来指定换行约定。</target>
        </trans-unit>
        <trans-unit id="810a5966eb1e7ee3bb3f54687643fa10446c0bcc" translate="yes" xml:space="preserve">
          <source>A newly spawned Erlang process uses 309 words of memory in the non-SMP emulator without HiPE support. (SMP support and HiPE support both add to this size.) The size can be found as follows:</source>
          <target state="translated">在没有HiPE支持的非SMP模拟器中,一个新生成的Erlang进程会使用309个字的内存(SMP支持和HiPE支持都会增加这个大小)。(SMP支持和HiPE支持都会增加这个字数。)字数的大小可以如下所示。</target>
        </trans-unit>
        <trans-unit id="06c8c9ea0c1555c71b7dd9ae8ee6da8f6b7d0bc2" translate="yes" xml:space="preserve">
          <source>A nice feature is that a test specification that includes node information can still be used as input to the regular &lt;code&gt;Common Test&lt;/code&gt; server (as described in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;). The result is that any test specified to run on a node with the same name as the &lt;code&gt;Common Test&lt;/code&gt; node in question (typically &lt;code&gt;ct@somehost&lt;/code&gt; if started with the &lt;code&gt;ct_run&lt;/code&gt; program), is performed. Tests without explicit node association are always performed too, of course.</source>
          <target state="translated">一个不错的功能是，包含节点信息的测试规范仍可以用作常规 &lt;code&gt;Common Test&lt;/code&gt; 服务器的输入（如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 一节中所述）。结果是，执行了任何指定在与所讨论的 &lt;code&gt;Common Test&lt;/code&gt; 节点同名的节点上运行的测试（如果从 &lt;code&gt;ct_run&lt;/code&gt; 程序启动，则通常为 &lt;code&gt;ct@somehost&lt;/code&gt; ）。当然，也总是执行没有显式节点关联的测试。</target>
        </trans-unit>
        <trans-unit id="7ee9953adae41a7655f8d2084b4fa873e00e82bf" translate="yes" xml:space="preserve">
          <source>A node can crash (probably a buggy one, hence traced). Use &lt;code&gt;resume&lt;/code&gt; to resume tracing on the node automatically when it gets back. The failing node then tries to reconnect to trace control node when &lt;code&gt;Runtime_Tools&lt;/code&gt; is started. This implies that &lt;code&gt;Runtime_Tools&lt;/code&gt; must be included in the startup chain of other nodes (if not, you can still resume tracing by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; manually, that is, by an RPC call).</source>
          <target state="translated">节点可能崩溃（可能是有故障的节点，因此已被跟踪）。使用 &lt;code&gt;resume&lt;/code&gt; 可在节点返回时自动在节点上继续跟踪。然后，启动 &lt;code&gt;Runtime_Tools&lt;/code&gt; 时，发生故障的节点将尝试重新连接到跟踪控制节点。这意味着 &lt;code&gt;Runtime_Tools&lt;/code&gt; 必须包含在其他节点的启动链中（如果没有，您仍然可以通过手动启动 &lt;code&gt;Runtime_Tools&lt;/code&gt; ，即通过RPC调用来恢复跟踪）。</target>
        </trans-unit>
        <trans-unit id="e9ed4743bc1cec802b20617a0fd885483b2dd9dc" translate="yes" xml:space="preserve">
          <source>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</source>
          <target state="translated">节点通过EPMD(在其他主机)获取另一个节点的端口号,发起连接请求。</target>
        </trans-unit>
        <trans-unit id="4faa439d4cf9e40f5ce1dc04ca048d241e286cf4" translate="yes" xml:space="preserve">
          <source>A node of type &lt;code&gt;map_expr&lt;/code&gt; is a leaf node if and only if it has no argument and no fields. A node of type &lt;code&gt;map_type&lt;/code&gt; is a leaf node if and only if it has no fields (&lt;code&gt;any_size&lt;/code&gt;). A node of type &lt;code&gt;tuple&lt;/code&gt; is a leaf node if and only if its arity is zero. A node of type &lt;code&gt;tuple_type&lt;/code&gt; is a leaf node if and only if it has no elements (&lt;code&gt;any_size&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;map_expr&lt;/code&gt; 类型的节点是且仅当它没有参数且没有字段时，才是叶节点。类型为 &lt;code&gt;map_type&lt;/code&gt; 的节点是且仅当它没有字段（ &lt;code&gt;any_size&lt;/code&gt; ）时，才是叶节点。当且仅当其Arity为零时， &lt;code&gt;tuple&lt;/code&gt; 类型的节点才是叶节点。类型为 &lt;code&gt;tuple_type&lt;/code&gt; 的节点是且仅当它没有任何元素时才是叶节点（ &lt;code&gt;any_size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cb52c93cebdeac0dab7fcc67ec63e9553ad8a863" translate="yes" xml:space="preserve">
          <source>A node running on Windows can only start slave nodes on the host on which it is running.</source>
          <target state="translated">在Windows上运行的节点只能启动其所在主机上的从属节点。</target>
        </trans-unit>
        <trans-unit id="9d21f5fbd84596b473f63ef2991ce0e43cba7cfb" translate="yes" xml:space="preserve">
          <source>A node started in this way is fully functional, using TLS as the distribution protocol.</source>
          <target state="translated">以这种方式启动的节点完全可以使用TLS作为分发协议。</target>
        </trans-unit>
        <trans-unit id="fc7f66a0ac45a7c84f0bb5f9e9d30342b7788580" translate="yes" xml:space="preserve">
          <source>A node started in this way will only be able to communicate with other nodes using SSL/TLS distribution over IPv6.</source>
          <target state="translated">以这种方式启动的节点将只能通过IPv6使用SSL/TLS分发与其他节点通信。</target>
        </trans-unit>
        <trans-unit id="15e879d0b785427426139719e5c9dfe725a5b841" translate="yes" xml:space="preserve">
          <source>A node started with command-line flag &lt;code&gt;-hidden&lt;/code&gt; (see &lt;code&gt;erl(1)&lt;/code&gt;) is said to be a &lt;strong&gt;hidden&lt;/strong&gt; node. A hidden node establishes hidden connections to nodes not part of the same global group, but normal (visible) connections to nodes part of the same global group.</source>
          <target state="translated">以命令行标志 &lt;code&gt;-hidden&lt;/code&gt; （请参见 &lt;code&gt;erl(1)&lt;/code&gt; ）开头的节点被称为&lt;strong&gt;隐藏&lt;/strong&gt;节点。隐藏节点会建立与不属于同一全局组的节点的隐藏连接，但会建立与属于同一全局组的节点的普通（可见）连接。</target>
        </trans-unit>
        <trans-unit id="20c980faeffa1454b2f85d7502b23e1c0b0103b4" translate="yes" xml:space="preserve">
          <source>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</source>
          <target state="translated">节点通过关闭节点注册时建立的与EPMD的TCP连接来解除自己在EPMD中的注册。</target>
        </trans-unit>
        <trans-unit id="d42befae27c8be5c2d1b9032dc8b9a0535e6021b" translate="yes" xml:space="preserve">
          <source>A node with a long node name cannot communicate with a node with a short node name.</source>
          <target state="translated">长节点名的节点不能与短节点名的节点通信。</target>
        </trans-unit>
        <trans-unit id="5608a2aa0096e2c431c4d688274c5bfed3dfbe6a" translate="yes" xml:space="preserve">
          <source>A node with name &lt;code&gt;Name@Host&lt;/code&gt; already exists.</source>
          <target state="translated">名称为 &lt;code&gt;Name@Host&lt;/code&gt; 节点已存在。</target>
        </trans-unit>
        <trans-unit id="9de4833cf4636cc7347017906607c0375ae36fb9" translate="yes" xml:space="preserve">
          <source>A non-local return from a function. If evaluated within a &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; returns value &lt;code&gt;Any&lt;/code&gt;. Example:</source>
          <target state="translated">函数的非本地返回。如果在 &lt;code&gt;catch&lt;/code&gt; 中求值，则 &lt;code&gt;catch&lt;/code&gt; 返回值 &lt;code&gt;Any&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="3104d91a116c49b17930265301a213974b99a618" translate="yes" xml:space="preserve">
          <source>A non-terminal category can be used at the left hand side (= &lt;code&gt;lhs&lt;/code&gt;, or &lt;code&gt;head&lt;/code&gt;) of a grammar rule. It can also appear at the right hand side of rules.</source>
          <target state="translated">可以在语法规则的左侧（= &lt;code&gt;lhs&lt;/code&gt; 或 &lt;code&gt;head&lt;/code&gt; ）使用非终止类别。它也可以出现在规则的右侧。</target>
        </trans-unit>
        <trans-unit id="522676de41bafa253c8f310dce88c669f1124e1c" translate="yes" xml:space="preserve">
          <source>A nonempty list &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; of syntax trees. This is equivalent to passing &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt;.</source>
          <target state="translated">语法树的非空列表 &lt;code&gt;[E1, ..., Ej]&lt;/code&gt; 。这等效于传递 &lt;code&gt;conjunction([E1, ..., Ej])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a728b05450ce93eb12d475c06f9983d66527797f" translate="yes" xml:space="preserve">
          <source>A nonempty list of lists of syntax trees &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt;, which is equivalent to passing &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt;.</source>
          <target state="translated">语法树列表的非空列表 &lt;code&gt;[[E1_1, ..., E1_k1], ..., [Ej_1, ..., Ej_kj]]&lt;/code&gt; ，等效于传递 &lt;code&gt;disjunction([conjunction([E1_1, ..., E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfe0accad3b0782ec5f58066cb4e83f925efd4a7" translate="yes" xml:space="preserve">
          <source>A normal file is really a process so it can be used as an I/O device (see &lt;code&gt;io&lt;/code&gt;). Therefore, when data is written to a normal file, the sending of the data to the file process, copies all data that are not binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the file is opened on another node, or if the file server runs as slave to the file server of another node, also binaries are copied.</source>
          <target state="translated">普通文件实际上是一个过程，因此可以用作I / O设备（请参阅 &lt;code&gt;io&lt;/code&gt; ）。因此，在将数据写入普通文件时，将数据发送到文件过程会复制所有不是二进制文件的数据。因此，建议以二进制模式打开文件并写入二进制文件。如果在另一个节点上打开文件，或者文件服务器作为另一个节点的文件服务器的从属服务器运行，则还会复制二进制文件。</target>
        </trans-unit>
        <trans-unit id="c470da7bdfad13769766d01b29332c73881e0c5a" translate="yes" xml:space="preserve">
          <source>A normal installation of Windows NT 4.0, with Service Pack 4 or later, is required for an embedded Windows NT running OTP.</source>
          <target state="translated">运行OTP的嵌入式Windows NT需要正常安装Windows NT 4.0和Service Pack 4或更高版本。</target>
        </trans-unit>
        <trans-unit id="b9be4139254b3d41e2b3331c9e7f9cdccd473c9d" translate="yes" xml:space="preserve">
          <source>A normal scheduler thread.</source>
          <target state="translated">一个普通的调度器线程。</target>
        </trans-unit>
        <trans-unit id="1ba3e6a43cfdf42b7ee92131fc56ef43d47532de" translate="yes" xml:space="preserve">
          <source>A notable return value is &lt;code&gt;{error, closed}&lt;/code&gt; indicating that the socket is closed.</source>
          <target state="translated">一个显着的返回值是 &lt;code&gt;{error, closed}&lt;/code&gt; 指示套接字已关闭。</target>
        </trans-unit>
        <trans-unit id="3b3bb227d33cdecc5e31e4a78df3f54b111efcf9" translate="yes" xml:space="preserve">
          <source>A notation that tells which part of the type to be decoded</source>
          <target state="translated">一个告诉类型的哪一部分要被解码的符号。</target>
        </trans-unit>
        <trans-unit id="d7dc1e195006c9ad7d9414abaacea8ee8034b8fa" translate="yes" xml:space="preserve">
          <source>A notation that tells which parts of the message structure to be excluded from decode</source>
          <target state="translated">告知信息结构中哪些部分要被排除在解码之外的符号。</target>
        </trans-unit>
        <trans-unit id="027b96af0679f806c12b49fa73f516241d045fca" translate="yes" xml:space="preserve">
          <source>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt;&lt;strong&gt;unless&lt;/strong&gt; the module and function names are explicitly stated in the call, as in e.g. &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt;. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</source>
          <target state="translated">警告提示：如果将远程函数的名称传递给内置函数 &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;spawn&lt;/code&gt; &lt;strong&gt;，&lt;/strong&gt;则Igor无法做任何事情，&lt;strong&gt;除非&lt;/strong&gt;在调用中明确声明了模块和函数的名称，例如 &lt;code&gt;apply(lists, reverse, [Xs])&lt;/code&gt; 。在所有其他情况下，Igor都不会更改此类调用，并警告用户可能需要手动编辑。</target>
        </trans-unit>
        <trans-unit id="bb34c061995c9bd9c3bf3fd5336b0597518696e6" translate="yes" xml:space="preserve">
          <source>A notification filter is a module implementing the &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; behaviour. A filter is added/deleted using the functions: &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通知过滤器是实现 &lt;code&gt;&lt;a href=&quot;snmpa_notification_filter&quot;&gt;snmpa_notification_filter&lt;/a&gt;&lt;/code&gt; 行为的模块。使用以下功能添加/删除过滤器： &lt;code&gt;&lt;a href=&quot;snmpa#register_notification_filter&quot;&gt;snmpa:register_notification_filter&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa#unregister_notification_filter&quot;&gt;snmpa:unregister_notification_filter&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23a7337393f51adec78486c788d793b331d07279" translate="yes" xml:space="preserve">
          <source>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</source>
          <target state="translated">一个空函数值(即,一个接受零参数的fun)。例子。</target>
        </trans-unit>
        <trans-unit id="e5362e0c25c0703bb5ca7c53501e9fabd30aa894" translate="yes" xml:space="preserve">
          <source>A number (starting with 0) indicating the number of that fun within that function</source>
          <target state="translated">一个数字(从0开始),表示该函数中该fun的数量。</target>
        </trans-unit>
        <trans-unit id="cf27cfd569963d1d3e948b114051da6fdcf3d00a" translate="yes" xml:space="preserve">
          <source>A number of objects must be present for the SSH application to work. Thoose objects are per default stored in files. The default names, paths and file formats are the same as for &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;. Keys could be generated with the &lt;code&gt;ssh-keygen&lt;/code&gt; program from OpenSSH. See the &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须存在许多对象，SSH应用程序才能正常工作。默认情况下，选择对象存储在文件中。默认名称，路径和文件格式与 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 相同。可以使用OpenSSH 的 &lt;code&gt;ssh-keygen&lt;/code&gt; 程序生成密钥。请参阅《 &lt;code&gt;&lt;a href=&quot;using_ssh#running-an-erlang-ssh-daemon&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c32086c997452421cf26bca4ec5f8f37980a88f" translate="yes" xml:space="preserve">
          <source>A one-line description of the application.</source>
          <target state="translated">对申请的单线描述;</target>
        </trans-unit>
        <trans-unit id="7676e10e4c0c5db81948c82045b717673602dd63" translate="yes" xml:space="preserve">
          <source>A one-shot timer, that is, a timer created by evaluating any of the functions &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; is not linked to any process. Hence, such a timer is removed only when it reaches its time-out, or if it is explicitly removed by a call to &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一次性计时器，即通过评估函数 &lt;code&gt;&lt;a href=&quot;#apply_after-4&quot;&gt;apply_after/4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#send_after-3&quot;&gt;send_after/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#send_after-2&quot;&gt;send_after/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#exit_after-3&quot;&gt;exit_after/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#exit_after-2&quot;&gt;exit_after/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#kill_after-2&quot;&gt;kill_after/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#kill_after-1&quot;&gt;kill_after/1&lt;/a&gt;&lt;/code&gt; 中的任何一个函数创建的计时器均未链接到任何过程。因此，仅在达到超时或通过调用 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 显式删除该计时器时，才将其删除。</target>
        </trans-unit>
        <trans-unit id="652f0a6b7da70ccce812924b966b0be33a66985d" translate="yes" xml:space="preserve">
          <source>A packet is a line-terminated by a delimiter byte, default is the latin-1 newline character. The delimiter byte is included in the returned packet unless the line was truncated according to option &lt;code&gt;line_length&lt;/code&gt;.</source>
          <target state="translated">数据包是由定界符字节终止的行，默认为latin-1换行符。分隔符字节包含在返回的数据包中，除非根据选项 &lt;code&gt;line_length&lt;/code&gt; 截断了该行。</target>
        </trans-unit>
        <trans-unit id="243cae021af59d36fb2ba67a11310414b8344606" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt;, where &lt;code&gt;LineNumber&lt;/code&gt; is a nonnegative integer and &lt;code&gt;SimpleTest&lt;/code&gt; is another simple test object. &lt;code&gt;LineNumber&lt;/code&gt; should indicate the source line of the test. Pairs like this are usually only created via &lt;code&gt;?_test(...)&lt;/code&gt; macros; see &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一对 &lt;code&gt;{LineNumber, SimpleTest}&lt;/code&gt; ，其中 &lt;code&gt;LineNumber&lt;/code&gt; 是一个非负整数，而 &lt;code&gt;SimpleTest&lt;/code&gt; 是另一个简单的测试对象。 &lt;code&gt;LineNumber&lt;/code&gt; 应该指示测试的源行。通常只通过 &lt;code&gt;?_test(...)&lt;/code&gt; 宏来创建这样的对。请参阅 &lt;code&gt;&lt;a href=&quot;#Basic_macros&quot;&gt;Basic macros&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="defb50c3733240a6d3613348a3d9ea0d5e3378d6" translate="yes" xml:space="preserve">
          <source>A parallel test case has a private I/O server as its group leader. (For a description of the group leader concept, see &lt;code&gt;ERTS&lt;/code&gt;). The central I/O server process, which handles the output from regular test cases and configuration functions, does not respond to I/O messages during execution of parallel groups. This is important to understand to avoid certain traps, like the following:</source>
          <target state="translated">并行测试用例具有专用I / O服务器作为其组长。（有关组长概念的描述，请参阅 &lt;code&gt;ERTS&lt;/code&gt; ）。中央I / O服务器进程处理常规测试用例和配置功能的输出，在并行组执行期间不响应I / O消息。了解这一点很重要，以避免出现某些陷阱，如下所示：</target>
        </trans-unit>
        <trans-unit id="59ee8343e4e789ac929459cd04d582cafeb246fb" translate="yes" xml:space="preserve">
          <source>A parameterized type is to be considered as an embedded type. Each time such a type is referenced, an instance of it is defined. Thus, in the following example a record with name &lt;code&gt;'Seq_b'&lt;/code&gt; is generated in the &lt;code&gt;.hrl&lt;/code&gt; file and is used to hold values:</source>
          <target state="translated">参数化类型将被视为嵌入式类型。每次引用这种类型时，都会定义其实例。因此，在下面的例子中有名的记录 &lt;code&gt;'Seq_b'&lt;/code&gt; 在生成 &lt;code&gt;.hrl&lt;/code&gt; 文件，并且用于保持值：</target>
        </trans-unit>
        <trans-unit id="024ff9d111af56355737a8c26860d8a633650503" translate="yes" xml:space="preserve">
          <source>A parenthesized subpattern (including assertions)</source>
          <target state="translated">一个括号内的子模式(包括断言)</target>
        </trans-unit>
        <trans-unit id="3ea3805acd22f42cb11f366b367ef59a1e1dc7d4" translate="yes" xml:space="preserve">
          <source>A parse transformation that translates fun syntax into match specifications.</source>
          <target state="translated">一个将趣味语法转化为匹配规范的解析转换。</target>
        </trans-unit>
        <trans-unit id="991f645ed0dc31daba5645f487f69d46fc37f314" translate="yes" xml:space="preserve">
          <source>A partial delivery failure. In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">部分交付失败。在Erlang / SCTP绑定的当前实现中，此事件在内部转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。</target>
        </trans-unit>
        <trans-unit id="fb726df29d93231b466c44dbe8038aa91fcb314b" translate="yes" xml:space="preserve">
          <source>A pattern can be selected to narrow the profiling. For instance a specific module can be selected, and only the code executed in that module will be profiled.</source>
          <target state="translated">可以选择一种模式来缩小剖析范围。例如,可以选择一个特定的模块,并且只对该模块中执行的代码进行剖析。</target>
        </trans-unit>
        <trans-unit id="c67b6c7226586d1f049336989af73704b318b899" translate="yes" xml:space="preserve">
          <source>A pattern has the same structure as a term but can contain unbound variables.</source>
          <target state="translated">模式的结构与术语相同,但可以包含非绑定变量。</target>
        </trans-unit>
        <trans-unit id="430efb2a85da18740aa7226ea60c97fb378ca179" translate="yes" xml:space="preserve">
          <source>A pattern is a term that can contain:</source>
          <target state="translated">模式是一个术语,可以包含。</target>
        </trans-unit>
        <trans-unit id="17c671d86e70778fccd78b1c171062748a656776" translate="yes" xml:space="preserve">
          <source>A pattern that matches a certain record is created in the same way as a record is created:</source>
          <target state="translated">与某条记录相匹配的模式,其创建方式与创建记录的方式相同。</target>
        </trans-unit>
        <trans-unit id="086559c23f422f88dfb22263e5064971fda50484" translate="yes" xml:space="preserve">
          <source>A peer's DiameterIdentity is not required when initiating a connection: the identify is received at capabilities exchange, at which time the connection can be rejected if the identity is objectionable.</source>
          <target state="translated">启动连接时不需要对等体的DiameterIdentity:身份标识在能力交换时接收,此时如果身份标识有异议,可以拒绝连接。</target>
        </trans-unit>
        <trans-unit id="6ac1afaee6db30631244af22883394c04ea016de" translate="yes" xml:space="preserve">
          <source>A piece of data of any data type is called a &lt;strong&gt;term&lt;/strong&gt;.</source>
          <target state="translated">任何数据类型的数据都称为&lt;strong&gt;术语&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="27a9280a59a327bcaa7fa4531cf4080082cc2a4d" translate="yes" xml:space="preserve">
          <source>A pointer to a function to execute in the created thread.</source>
          <target state="translated">指向要在创建的线程中执行的函数的指针。</target>
        </trans-unit>
        <trans-unit id="2425be4490c62b2d9ac48f8dfb6dca6c94bc6de8" translate="yes" xml:space="preserve">
          <source>A pointer to a thread identifier variable.</source>
          <target state="translated">一个指向线程标识符变量的指针。</target>
        </trans-unit>
        <trans-unit id="bdca82216af70bfb4f52fcc1c479301f1b25be42" translate="yes" xml:space="preserve">
          <source>A pointer to an integer. The integer is used both for passing input and output sizes (see below).</source>
          <target state="translated">一个指向整数的指针。该整数用于传递输入和输出大小(见下文)。</target>
        </trans-unit>
        <trans-unit id="9e7bc1ca5fcc169a07a734702da7afb3a87a923b" translate="yes" xml:space="preserve">
          <source>A pointer to an output buffer.</source>
          <target state="translated">指向输出缓冲区的指针。</target>
        </trans-unit>
        <trans-unit id="78c2fb1c9ead9f20103777b7ae3edafb6a2eea4e" translate="yes" xml:space="preserve">
          <source>A pointer to another port structure, which is either the listen port from which this port is accepting a connection or conversely. The &quot;partner relation&quot; is always bidirectional.</source>
          <target state="translated">一个指向另一个端口结构的指针,它既可以是这个端口接受连接的监听端口,也可以反过来。伙伴关系 &quot;总是双向的。</target>
        </trans-unit>
        <trans-unit id="aae44b20ecd8d8611c610749c380b8aec87c9bfa" translate="yes" xml:space="preserve">
          <source>A pointer to argument to the &lt;code&gt;func&lt;/code&gt; function.</source>
          <target state="translated">指向 &lt;code&gt;func&lt;/code&gt; 函数的参数的指针。</target>
        </trans-unit>
        <trans-unit id="2f4cacb4211d371a86050f3b2bf4514f77eeffa8" translate="yes" xml:space="preserve">
          <source>A pointer to the contents of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">指向 &lt;code&gt;t&lt;/code&gt; 内容的指针。</target>
        </trans-unit>
        <trans-unit id="ec5991945ec65c59205cb652ca3121b479552f42" translate="yes" xml:space="preserve">
          <source>A pointer to the function that implements the NIF.</source>
          <target state="translated">指向实现NIF的函数的指针。</target>
        </trans-unit>
        <trans-unit id="d4bf94b670a866ff43aac180a11292d00d614edb" translate="yes" xml:space="preserve">
          <source>A pointer to thread options to use or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">指向要使用的线程选项的指针或 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1206cda26f132192edd3659328975e4d3cafd278" translate="yes" xml:space="preserve">
          <source>A port can be set to use binaries instead of lists of bytes. It is then not necessary to invent any encoding/decoding scheme. Erl_Interface functions are used for unpacking the binary and convert it into a struct similar to an Erlang term. Such a struct can be manipulated in different ways, be converted to the Erlang external format, and sent to Erlang.</source>
          <target state="translated">可以将 port 设置为使用二进制文件而不是字节列表。这样就不需要发明任何编码/解码方案。Erl_Interface 函数用于解压二进制文件,并将其转换为一个类似于 Erlang 术语的结构。这样的结构可以用不同的方式进行操作,转换为Erlang外部格式,并发送给Erlang。</target>
        </trans-unit>
        <trans-unit id="c39dd0f30e9a0ba72b5dacc6b581f2019abf49ac" translate="yes" xml:space="preserve">
          <source>A port data lock is reference counted, and when the reference count reaches zero, it is destroyed. The emulator at least increments the reference count once when the lock is created and decrements it once the port associated with the lock terminates. The emulator also increments the reference count when an async job is enqueued and decrements it when an async job has been invoked. Also, the driver is responsible for ensuring that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented by &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">端口数据锁被引用计数，当引用计数达到零时，它将被销毁。创建锁时，仿真器至少会增加一次参考计数，一旦与锁关联的端口终止，模拟器就会将其递减。当排队异步作业时，仿真器还会增加引用计数，而在调用异步作业时，模拟器也会减少引用计数。而且，驾驶员有责任确保在驾驶员最后一次使用锁之前，参考计数不为零。可以分别通过 &lt;code&gt;&lt;a href=&quot;#driver_pdl_get_refc&quot;&gt;driver_pdl_get_refc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#driver_pdl_inc_refc&quot;&gt;driver_pdl_inc_refc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#driver_pdl_dec_refc&quot;&gt;driver_pdl_dec_refc&lt;/a&gt;&lt;/code&gt; 读取，递增和递减引用计数。</target>
        </trans-unit>
        <trans-unit id="293c8a353a9462ae3b6bfddcb9d1223abb498be9" translate="yes" xml:space="preserve">
          <source>A port driver is a linked-in driver that is accessible as a port from an Erlang program. It is a shared library (SO in UNIX, DLL in Windows), with special entry points. The Erlang runtime system calls these entry points when the driver is started and when data is sent to the port. The port driver can also send data to Erlang.</source>
          <target state="translated">移植驱动程序是一个链接在一起的驱动程序,它可以作为一个端口从 Erlang 程序中访问。它是一个共享库 (在 UNIX 中是 SO,在 Windows 中是 DLL),具有特殊的入口点。Erlang 运行时系统会在驱动程序启动和数据被发送到 port 时调用这些入口点。端口驱动程序也可以向 Erlang 发送数据。</target>
        </trans-unit>
        <trans-unit id="3c0708dd623cb47c7df1202d9dbfe1fbb7d19e65" translate="yes" xml:space="preserve">
          <source>A port identifier identifies an Erlang port.</source>
          <target state="translated">一个端口标识符标识一个 Erlang 端口。</target>
        </trans-unit>
        <trans-unit id="19b3ddd399fc086f92748ad13d0d6c9f12e76af1" translate="yes" xml:space="preserve">
          <source>A port identifier refers into a port table and a node table, which also consumes memory.</source>
          <target state="translated">一个端口标识符指入一个端口表和一个节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="18856ffa7bc1d834314eb745f89d3f4ac81cef62" translate="yes" xml:space="preserve">
          <source>A port identifier. In contrast to port ID terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPort&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPort&lt;/code&gt; is an opaque type.</source>
          <target state="translated">端口标识符。与端口ID术语（ &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 的实例）相比， &lt;code&gt;ErlNifPort&lt;/code&gt; 是自包含的，并且不受任何 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; 约束。 &lt;code&gt;ErlNifPort&lt;/code&gt; 是不透明的类型。</target>
        </trans-unit>
        <trans-unit id="a5794b57a917a22a654e45737ed3a63e4f792f19" translate="yes" xml:space="preserve">
          <source>A port that is connected to a listen socket. This port does not do much, no data pumping is done on this socket, but read data is available when one is trying to do an accept on the port.</source>
          <target state="translated">一个连接到监听套接字的端口。这个端口的作用不大,在这个套接字上不做任何数据泵送,但当人们想在这个端口上做接受时,可以读取数据。</target>
        </trans-unit>
        <trans-unit id="e728f787c7fc14ca780c0ed99792cf4bab0d04bc" translate="yes" xml:space="preserve">
          <source>A positive integer or &lt;code&gt;infinity&lt;/code&gt;, defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">正整数或 &lt;code&gt;infinity&lt;/code&gt; ，默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ff16a10dbcc92f0a90f938ecb26a69d5a07cb38" translate="yes" xml:space="preserve">
          <source>A positive integer or the atom &lt;code&gt;undefined_serial&lt;/code&gt; (in case no messages has been sent).</source>
          <target state="translated">正整数或原子 &lt;code&gt;undefined_serial&lt;/code&gt; （如果未发送消息）。</target>
        </trans-unit>
        <trans-unit id="a0b0b2de29f48def22ce618959435b19ac7becd8" translate="yes" xml:space="preserve">
          <source>A positive integer representing the absolute maximum size a string returned from this formatter can have. If the formatted string is longer, after possibly being limited by &lt;code&gt;chars_limit&lt;/code&gt; or &lt;code&gt;depth&lt;/code&gt;, it is truncated.</source>
          <target state="translated">一个正整数，表示从此格式化程序返回的字符串可以具有的绝对最大大小。如果格式化的字符串较长，则可能会被 &lt;code&gt;chars_limit&lt;/code&gt; 或 &lt;code&gt;depth&lt;/code&gt; 限制后，将被截断。</target>
        </trans-unit>
        <trans-unit id="8432f1221b4e6180daa30dde8c243b5ace3ee8ed" translate="yes" xml:space="preserve">
          <source>A positive integer representing the maximum depth to which terms shall be printed by this formatter. Format strings passed to this formatter are rewritten. The format controls ~p and ~w are replaced with ~P and ~W, respectively, and the value is used as the depth parameter. For details, see &lt;code&gt;io:format/2,3&lt;/code&gt; in STDLIB.</source>
          <target state="translated">一个正整数，表示此格式化程序将打印术语的最大深度。传递给此格式化程序的格式化字符串将被重写。格式控件〜p和〜w分别替换为〜P和〜W，并且该值用作深度参数。有关详细信息，请参见STDLIB中的 &lt;code&gt;io:format/2,3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b666ac2b38c4545ad7cf98d3da66419760a1f1f" translate="yes" xml:space="preserve">
          <source>A positive integer representing the value of the option with the same name to be used when calling &lt;code&gt;io_lib:format/3&lt;/code&gt;. This value limits the total number of characters printed for each log event. Notice that this is a soft limit. For a hard truncation limit, see option &lt;code&gt;max_size&lt;/code&gt;.</source>
          <target state="translated">一个正整数，表示与调用 &lt;code&gt;io_lib:format/3&lt;/code&gt; 时使用的名称相同的选项的值。此值限制为每个日志事件打印的字符总数。请注意，这是一个软限制。有关硬截断限制，请参见选项 &lt;code&gt;max_size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00810275831c468fa832818d7831816d4d68cc76" translate="yes" xml:space="preserve">
          <source>A positive integer, defaults to 1.</source>
          <target state="translated">一个正整数,默认为1。</target>
        </trans-unit>
        <trans-unit id="eae0729316a72e8195f927b7d08f3a3e873b0f72" translate="yes" xml:space="preserve">
          <source>A possible output from the system's &lt;code&gt;sequential_tracer&lt;/code&gt; can be like this:</source>
          <target state="translated">系统的 &lt;code&gt;sequential_tracer&lt;/code&gt; 可能输出可能是这样的：</target>
        </trans-unit>
        <trans-unit id="af7898411039ac7f27c7f7c532905e5b1d3ef4a9" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;Big(X)&lt;/code&gt; is defined, which is &lt;code&gt;true&lt;/code&gt; if its argument is greater that 10:</source>
          <target state="translated">定义了谓词 &lt;code&gt;Big(X)&lt;/code&gt; ，如果其参数大于10 ，则为 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e7d9312c9e6373085b2581d401f52947630c30ca" translate="yes" xml:space="preserve">
          <source>A predicate is a function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;any&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if there is a term &lt;code&gt;X&lt;/code&gt; in the list such that &lt;code&gt;P(X)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">谓词是返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的函数。 &lt;code&gt;any&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，如果有一个术语 &lt;code&gt;X&lt;/code&gt; 在列表中，使得 &lt;code&gt;P(X)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a559512ddfd19a254b3dc8766e06627c3cf21e5" translate="yes" xml:space="preserve">
          <source>A prefix is optional but can be be used to disambiguate between record and constant names resulting from similarly named messages and AVPs in different Diameter applications.</source>
          <target state="translated">前缀是可选的,但可用于在不同Diameter应用中类似命名的消息和AVP所产生的记录和常量名称之间进行混淆。</target>
        </trans-unit>
        <trans-unit id="c17bae9646cdd5e9bda0a78a3791df32fbe7c33e" translate="yes" xml:space="preserve">
          <source>A previously loaded module contains an &lt;code&gt;-on_load&lt;/code&gt; function that never finished.</source>
          <target state="translated">先前加载的模块包含从未完成的 &lt;code&gt;-on_load&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="1b8f8657029f4d6aa6e01af505f0ff328ca9512f" translate="yes" xml:space="preserve">
          <source>A problem can arise if a replicated table on one node is initiated, but &lt;code&gt;Mnesia&lt;/code&gt; deduces that another (remote) replica is more recent than the replica existing on the local node, and the initialization procedure does not proceed. In this situation, a call to &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt;, suspends the caller until the remote node has initialized the table from its local disc and the node has copied the table over the network to the local node.</source>
          <target state="translated">如果在一个节点上启动了一个复制表，则可能会出现问题，但是 &lt;code&gt;Mnesia&lt;/code&gt; 推断出另一个（远程）副本比本地节点上存在的副本更新，并且初始化过程不会继续进行。在这种情况下，对 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables/2&lt;/a&gt;&lt;/code&gt; 的调用将挂起调用方，直到远程节点已从其本地磁盘初始化该表并且该节点已通过网络将该表复制到了本地节点。</target>
        </trans-unit>
        <trans-unit id="8ebbb1fef06e8f55da3f26cfd1b065a870dd9421" translate="yes" xml:space="preserve">
          <source>A process calling &lt;code&gt;spawn&lt;/code&gt;, &lt;code&gt;spawn_link&lt;/code&gt;, &lt;code&gt;spawn_monitor&lt;/code&gt;, or &lt;code&gt;spawn_opt&lt;/code&gt; is scheduled out immediately after completing the call. When higher modified timing levels are used, the caller also sleeps for a while after it is scheduled out.</source>
          <target state="translated">完成调用后，将立即调度调用 &lt;code&gt;spawn&lt;/code&gt; ， &lt;code&gt;spawn_link&lt;/code&gt; ， &lt;code&gt;spawn_monitor&lt;/code&gt; 或 &lt;code&gt;spawn_opt&lt;/code&gt; 的进程。当使用较高的已修改计时级别时，呼叫者在安排好时间后还会睡眠一会儿。</target>
        </trans-unit>
        <trans-unit id="072b0b4dc3c07ad9ff81bf5af27f95232daef7d4" translate="yes" xml:space="preserve">
          <source>A process can also be terminated if it receives an exit signal with another exit reason than &lt;code&gt;normal&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果进程收到退出信号的原因是 &lt;code&gt;normal&lt;/code&gt; 退出，退出原因也可能是其他原因，请参见 &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f16a41a56038d323a59c139120b39c4d98df3227" translate="yes" xml:space="preserve">
          <source>A process can also call the function &lt;code&gt;exit(Pid,Reason)&lt;/code&gt;. This results in an exit signal with exit reason &lt;code&gt;Reason&lt;/code&gt; being emitted to &lt;code&gt;Pid&lt;/code&gt;, but does not affect the calling process.</source>
          <target state="translated">进程还可以调用函数 &lt;code&gt;exit(Pid,Reason)&lt;/code&gt; 。这将导致退出信号，退出原因 &lt;code&gt;Reason&lt;/code&gt; 被发送到 &lt;code&gt;Pid&lt;/code&gt; ，但不影响调用过程。</target>
        </trans-unit>
        <trans-unit id="e6966f7ea916abf9765baf180b15bfc451003b50" translate="yes" xml:space="preserve">
          <source>A process can be set to trap exit signals by calling:</source>
          <target state="translated">进程可以通过调用来设置退出信号陷阱。</target>
        </trans-unit>
        <trans-unit id="51d9fe10dcef55d7d44c0442f222152ab34ddbe3" translate="yes" xml:space="preserve">
          <source>A process can be suspended by multiple processes and can be suspended multiple times by a single process. A suspended process does not leave the suspended state until its suspend count reaches zero. The suspend count of &lt;code&gt;Suspendee&lt;/code&gt; is decreased when &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; is called by the same process that called &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt;. All increased suspend counts on other processes acquired by a process are automatically decreased when the process terminates.</source>
          <target state="translated">一个进程可以被多个进程挂起，并且可以被单个进程多次挂起。挂起的进程直到其挂起计数达到零时才离开挂起状态。挂起的计数 &lt;code&gt;Suspendee&lt;/code&gt; 时减小 &lt;code&gt;&lt;a href=&quot;#resume_process-1&quot;&gt;erlang:resume_process(Suspendee)&lt;/a&gt;&lt;/code&gt; 由相同的过程称为调用 &lt;code&gt;erlang:suspend_process(Suspendee)&lt;/code&gt; 。当进程终止时，由该进程获取的其他进程上所有增加的挂起计数将自动减少。</target>
        </trans-unit>
        <trans-unit id="32f69066cd227a9815efdfec6c96cb7e6e8de0aa" translate="yes" xml:space="preserve">
          <source>A process can terminate itself by calling one of the following BIFs:</source>
          <target state="translated">一个进程可以通过调用以下BIF来终止自己。</target>
        </trans-unit>
        <trans-unit id="bd5238f73e1d44a290b4f80529059292d57da507" translate="yes" xml:space="preserve">
          <source>A process fixes a table by calling &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt;. The table remains fixed until the process releases it by calling &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt;, or until the process terminates.</source>
          <target state="translated">进程通过调用 &lt;code&gt;safe_fixtable(Tab, true)&lt;/code&gt; 修复表。该表将保持固定状态，直到进程通过调用 &lt;code&gt;safe_fixtable(Tab, false)&lt;/code&gt; 释放该表，或者直到该进程终止。</target>
        </trans-unit>
        <trans-unit id="42b2c1b73ec6ef9ef96e79e9e9449854c76818bb" translate="yes" xml:space="preserve">
          <source>A process identifier (pid). In contrast to pid terms (instances of &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;), &lt;code&gt;ErlNifPid&lt;/code&gt;s are self-contained and not bound to any &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ErlNifPid&lt;/code&gt; is an opaque type.</source>
          <target state="translated">进程标识符（pid）。与pid术语（ &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 的实例）相反， &lt;code&gt;ErlNifPid&lt;/code&gt; 是自包含的，并且不受任何 &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;environment&lt;/a&gt;&lt;/code&gt; 约束。 &lt;code&gt;ErlNifPid&lt;/code&gt; 是不透明的类型。</target>
        </trans-unit>
        <trans-unit id="37148f5c507ec0173b138452557614229468263f" translate="yes" xml:space="preserve">
          <source>A process identifier as in &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt;. Represents the process in which the fun was created.</source>
          <target state="translated">如 &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 中的过程标识符。表示创建乐趣的过程。</target>
        </trans-unit>
        <trans-unit id="10461d2fc7608d820f0dfe163bcb992712ebe48a" translate="yes" xml:space="preserve">
          <source>A process identifier refers into a process table and a node table, which also consumes memory.</source>
          <target state="translated">进程标识符指入一个进程表和一个节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="69b2f4b3ae91aebe493ff76d27f3c271b8cfb661" translate="yes" xml:space="preserve">
          <source>A process identifier, pid, identifies a process.</source>
          <target state="translated">进程标识符pid标识一个进程。</target>
        </trans-unit>
        <trans-unit id="98c8d95b2cf9ab7d1d26152983625cb3f9b34934" translate="yes" xml:space="preserve">
          <source>A process in a supervision tree is expected to terminate with the same reason as its parent.</source>
          <target state="translated">监督树中的进程应该与它的父进程以相同的理由终止。</target>
        </trans-unit>
        <trans-unit id="d6ba7c3c946bdd4b03479883e86c12f1505bd1d6" translate="yes" xml:space="preserve">
          <source>A process is created by calling &lt;code&gt;spawn&lt;/code&gt;:</source>
          <target state="translated">通过调用 &lt;code&gt;spawn&lt;/code&gt; 创建一个进程：</target>
        </trans-unit>
        <trans-unit id="655669bae8fcf2c6bd4e506e48fb385c11ebcc8b" translate="yes" xml:space="preserve">
          <source>A process is said to &lt;strong&gt;use&lt;/strong&gt; a module &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is listed in the &lt;code&gt;Modules&lt;/code&gt; part of the child specification used to start the process, see &lt;code&gt;supervisor(3)&lt;/code&gt;. In the case of &lt;code&gt;gen_event&lt;/code&gt;, an event manager process is said to use &lt;code&gt;Mod&lt;/code&gt; if &lt;code&gt;Mod&lt;/code&gt; is an installed event handler.</source>
          <target state="translated">的方法被说成&lt;strong&gt;使用&lt;/strong&gt;一个模块 &lt;code&gt;Mod&lt;/code&gt; 如果 &lt;code&gt;Mod&lt;/code&gt; 在列出 &lt;code&gt;Modules&lt;/code&gt; 用于启动过程中的子规范的一部分，见 &lt;code&gt;supervisor(3)&lt;/code&gt; 。在 &lt;code&gt;gen_event&lt;/code&gt; 的情况下，如果 &lt;code&gt;Mod&lt;/code&gt; 是已安装的事件处理程序，则说事件管理器进程使用 &lt;code&gt;Mod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce5d54306fa5b34ccef5a88ec9ab67fc328d882" translate="yes" xml:space="preserve">
          <source>A process is said to terminate &lt;strong&gt;normally&lt;/strong&gt;, if the exit reason is the atom &lt;code&gt;normal&lt;/code&gt;. A process with no more code to execute terminates normally.</source>
          <target state="translated">如果退出原因是原子 &lt;code&gt;normal&lt;/code&gt; ，则称该过程&lt;strong&gt;正常&lt;/strong&gt;终止。没有更多代码可执行的进程将正常终止。</target>
        </trans-unit>
        <trans-unit id="c38c68c3f6186a6925602a46f9f750d6d6a871ba" translate="yes" xml:space="preserve">
          <source>A process started using one of these functions stores information (for example, about the ancestors and initial call) that is needed for a process in a supervision tree.</source>
          <target state="translated">使用这些函数之一启动的进程会存储监督树中进程所需的信息(例如,关于祖先和初始调用)。</target>
        </trans-unit>
        <trans-unit id="8a720c57ae355af10862b0bdc7f574cf5fde79d5" translate="yes" xml:space="preserve">
          <source>A process terminates when there is nothing more for it to do, that is, the last function it calls simply returns and does not call another function. Another way for a process to terminate is for it to call &lt;code&gt;exit/1&lt;/code&gt;. The argument to &lt;code&gt;exit/1&lt;/code&gt; has a special meaning, which is discussed later. In this example, &lt;code&gt;exit(normal)&lt;/code&gt; is done, which has the same effect as a process running out of functions to call.</source>
          <target state="translated">当没有其他事情要做时，进程终止，也就是说，它调用的最后一个函数只是返回而不会调用另一个函数。进程终止的另一种方法是调用 &lt;code&gt;exit/1&lt;/code&gt; 。 &lt;code&gt;exit/1&lt;/code&gt; 的参数具有特殊含义，稍后将进行讨论。在此示例中，完成 &lt;code&gt;exit(normal)&lt;/code&gt; 的操作与退出要调用的函数的进程的效果相同。</target>
        </trans-unit>
        <trans-unit id="b7284987fd39b3d4aa792c2690fb0c00bf937e45" translate="yes" xml:space="preserve">
          <source>A process terminates with an exit reason &lt;code&gt;{Reason,Stack}&lt;/code&gt; when a run-time error occurs. See &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">发生运行时错误时 &lt;code&gt;{Reason,Stack}&lt;/code&gt; 进程将以退出原因{Reason，Stack}终止。请参阅 &lt;code&gt;&lt;a href=&quot;errors#exit_reasons&quot;&gt;Exit Reasons&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f5ab350433257813ae5457fda256563bb26173" translate="yes" xml:space="preserve">
          <source>A process that has subscribed receives the messages &lt;code&gt;{nodeup, Node}&lt;/code&gt; and &lt;code&gt;{nodedown, Node}&lt;/code&gt; when a group node connects or disconnects, respectively.</source>
          <target state="translated">当组节点连接或断开连接时，已订阅的进程将分别收到消息 &lt;code&gt;{nodeup, Node}&lt;/code&gt; 和 &lt;code&gt;{nodedown, Node}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88f957222cd12e5811bc10dccb60ff786260ced6" translate="yes" xml:space="preserve">
          <source>A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old heap contains mostly garbage. To ensure a fullsweep occasionally, set &lt;code&gt;Number&lt;/code&gt; to a suitable value, such as 10 or 20.</source>
          <target state="translated">数据寿命短的进程很少或永远不会被完全清除，也就是说，旧堆主要包含垃圾。为确保偶尔进行全扫，请将 &lt;code&gt;Number&lt;/code&gt; 设置为适当的值，例如10或20。</target>
        </trans-unit>
        <trans-unit id="b02ce9655d7ee12a68cc9c922758cfe90268e361" translate="yes" xml:space="preserve">
          <source>A process that terminates emits an &lt;strong&gt;exit signal&lt;/strong&gt; with an &lt;strong&gt;exit reason&lt;/strong&gt; that says something about which error has occurred. Normally, some information about the error is printed to the terminal.</source>
          <target state="translated">终止的过程会发出&lt;strong&gt;退出信号&lt;/strong&gt;，其&lt;strong&gt;退出原因&lt;/strong&gt;说明发生了什么错误。通常，有关错误的一些信息会打印到终端上。</target>
        </trans-unit>
        <trans-unit id="4c1ad1b1dc6212b6747cc5b78c88b6a9bc5616a4" translate="yes" xml:space="preserve">
          <source>A process uses a module if the name is listed in &lt;code&gt;Modules&lt;/code&gt; in the child specification for the process.</source>
          <target state="translated">如果名称在该进程的子规范的&amp;ldquo; &lt;code&gt;Modules&lt;/code&gt; 中列出，则该进程将使用模块。</target>
        </trans-unit>
        <trans-unit id="d52b7cef11e2674343ad2926d3e4df68d2f02770" translate="yes" xml:space="preserve">
          <source>A process which encounters a runtime error (for example, divide by zero, bad match, trying to call a function that does not exist and so on) exits with an error, that is, has an &lt;strong&gt;abnormal&lt;/strong&gt; exit. A process which executes &lt;code&gt;exit(Reason)&lt;/code&gt; where &lt;code&gt;Reason&lt;/code&gt; is any Erlang term except the atom &lt;code&gt;normal&lt;/code&gt;, also has an abnormal exit.</source>
          <target state="translated">遇到运行时错误（例如，被零除，不匹配，尝试调用不存在的函数等）的进程将退出，并显示错误，即&lt;strong&gt;异常&lt;/strong&gt;退出。一个执行 &lt;code&gt;exit(Reason)&lt;/code&gt; 的进程，其中 &lt;code&gt;Reason&lt;/code&gt; 是除原子 &lt;code&gt;normal&lt;/code&gt; 之外的任何Erlang术语，也有异常的退出。</target>
        </trans-unit>
        <trans-unit id="d8cf739fd5b866124284242faae0350386ccbc38" translate="yes" xml:space="preserve">
          <source>A process which executes &lt;code&gt;exit(normal)&lt;/code&gt; or simply runs out of things to do has a &lt;strong&gt;normal&lt;/strong&gt; exit.</source>
          <target state="translated">执行 &lt;code&gt;exit(normal)&lt;/code&gt; 或干脆要用完的事情的进程将具有&lt;strong&gt;正常&lt;/strong&gt;退出。</target>
        </trans-unit>
        <trans-unit id="d70973a9129b09df85556ba1f21b22c9c9188ac7" translate="yes" xml:space="preserve">
          <source>A process-bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process-bound environments between NIF calls.</source>
          <target state="translated">进程绑定的环境包含了调用Erlang进程的瞬时信息。这个环境只在提供它作为参数的线程中有效,直到NIF返回。因此,在NIF调用之间存储进程绑定环境的指针是无用和危险的。</target>
        </trans-unit>
        <trans-unit id="8439869a5f898e9ec34e7c4ce1fd0dfa05b36050" translate="yes" xml:space="preserve">
          <source>A program development technique where you continuously write tests &lt;strong&gt;before&lt;/strong&gt; you implement the code that is supposed to pass those tests. This can help you focus on solving the right problems, and not make a more complicated implementation than necessary, by letting the unit tests determine when a program is &quot;done&quot;: if it fulfils its specifications, there is no need to keep adding functionality.</source>
          <target state="translated">一种程序开发技术，&lt;strong&gt;在&lt;/strong&gt;实现应该通过这些测试的代码&lt;strong&gt;之前&lt;/strong&gt;，您要连续编写测试。通过让单元测试确定程序何时&amp;ldquo;完成&amp;rdquo;，这可以帮助您专注于解决正确的问题，而不用进行比必要的复杂的实现：如果程序满足其规范，则无需继续添加功能。</target>
        </trans-unit>
        <trans-unit id="31698109f367fecfe3048c58496050f0b7013f39" translate="yes" xml:space="preserve">
          <source>A program works regardless of the data location. It makes no difference whether the data resides on the local node or on a remote node.</source>
          <target state="translated">一个程序无论在哪个数据位置都能工作。无论数据是驻留在本地节点还是远程节点上,都没有区别。</target>
        </trans-unit>
        <trans-unit id="31abad1a30c128c77e1602c287c4f23c333d4d5c" translate="yes" xml:space="preserve">
          <source>A programming language is not much use if you only can run code from the shell. So here is a small Erlang program. Enter it into a file named &lt;code&gt;tut.erl&lt;/code&gt; using a suitable text editor. The file name &lt;code&gt;tut.erl&lt;/code&gt; is important, and also that it is in the same directory as the one where you started &lt;code&gt;erl&lt;/code&gt;). If you are lucky your editor has an Erlang mode that makes it easier for you to enter and format your code nicely (see &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; in Tools User's Guide), but you can manage perfectly well without. Here is the code to enter:</source>
          <target state="translated">如果只能从Shell运行代码，则编程语言没有太大用处。这是一个小的Erlang程序。使用适当的文本编辑器将其输入到名为 &lt;code&gt;tut.erl&lt;/code&gt; 的文件中。文件名 &lt;code&gt;tut.erl&lt;/code&gt; 很重要，而且它与您启动 &lt;code&gt;erl&lt;/code&gt; 的目录位于同一目录中。如果幸运的话，您的编辑器提供了一种Erlang模式，可以使您轻松轻松地很好地输入和格式化代码（请参阅 &lt;code&gt;The Erlang mode for Emacs&lt;/code&gt; 工具用户指南》中的Emacs的Erlang模式），但是如果没有它，则可以很好地进行管理。这是要输入的代码：</target>
        </trans-unit>
        <trans-unit id="01bea3eff51113f444f36e486039be93438b9aa1" translate="yes" xml:space="preserve">
          <source>A progress report is issued when a supervisor starts or restarts a child. A progress report contains the following items:</source>
          <target state="translated">当主管开始或重新开始一个儿童时,会发出一份进度报告。进度报告包含以下项目:</target>
        </trans-unit>
        <trans-unit id="dfa1a1d7586f8b047c09414dbfe4922da8132644" translate="yes" xml:space="preserve">
          <source>A protocol-independent equivalent of &lt;code&gt;tos&lt;/code&gt; above. Setting priority implies setting &lt;code&gt;tos&lt;/code&gt; as well.</source>
          <target state="translated">上面 &lt;code&gt;tos&lt;/code&gt; 的与协议无关的等效项。设置优先级也意味着要设置 &lt;code&gt;tos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dcc85d5e6a8d3b2dabc11b50011d74738e45c9a" translate="yes" xml:space="preserve">
          <source>A proxy-authorization header using the provided username and password is added to the request.</source>
          <target state="translated">使用提供的用户名和密码的代理授权头被添加到请求中。</target>
        </trans-unit>
        <trans-unit id="fca72e9fdf4fbe435757ecdf4f89e484c25bdd95" translate="yes" xml:space="preserve">
          <source>A pseudo-terminal has been requested for the session. &lt;code&gt;Terminal&lt;/code&gt; is the value of the TERM environment variable value, that is, &lt;code&gt;vt100&lt;/code&gt;. Zero dimension parameters must be ignored. The character/row dimensions override the pixel dimensions (when non-zero). Pixel dimensions refer to the drawable area of the window. &lt;code&gt;Opcode&lt;/code&gt; in the &lt;code&gt;TerminalModes&lt;/code&gt; list is the mnemonic name, represented as a lowercase Erlang atom, defined in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt;, Section 8. It can also be an &lt;code&gt;Opcode&lt;/code&gt; if the mnemonic name is not listed in the RFC. Example: &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt;. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已为该会话请求了伪终端。 &lt;code&gt;Terminal&lt;/code&gt; 是TERM环境变量值的值，即 &lt;code&gt;vt100&lt;/code&gt; 。零尺寸参数必须忽略。字符/行尺寸会覆盖像素尺寸（非零时）。像素尺寸是指窗口的可绘制区域。 &lt;code&gt;Opcode&lt;/code&gt; 在 &lt;code&gt;TerminalModes&lt;/code&gt; 列表是助记符名称，表示为小写二郎原子，所述 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 的第8章它也可以是一个 &lt;code&gt;Opcode&lt;/code&gt; ，如果助记符名称没有在RFC列出。示例： &lt;code&gt;OP code: 53, mnemonic name ECHO erlang atom: echo&lt;/code&gt; 。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#ptty_alloc-4&quot;&gt;ssh_connection:ptty_alloc/4&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="d53dd83df64a4aed582356aeff9d756b34b98db4" translate="yes" xml:space="preserve">
          <source>A qualifier Q is one of the following:</source>
          <target state="translated">修饰词Q是下列之一。</target>
        </trans-unit>
        <trans-unit id="16e918dd54f68fd1cee2a154501ced6dc2ab06fa" translate="yes" xml:space="preserve">
          <source>A query handle is evaluated in the following order:</source>
          <target state="translated">查询句柄的评估顺序如下。</target>
        </trans-unit>
        <trans-unit id="f61712a9538d9f895b83ffb3d3be147091cb2096" translate="yes" xml:space="preserve">
          <source>A raw option request &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; can be used to get information about socket options not (explicitly) supported by the emulator. The use of raw socket options makes the code non-portable, but allows the Erlang programmer to take advantage of unusual features present on the current platform.</source>
          <target state="translated">原始选项请求 &lt;code&gt;RawOptReq = {raw, Protocol, OptionNum, ValueSpec}&lt;/code&gt; 可用于获取有关仿真器不（明确）支持的套接字选项的信息。使用原始套接字选项使代码不可移植，但允许Erlang程序员利用当前平台上存在的异常功能。</target>
        </trans-unit>
        <trans-unit id="8ff008f39f98c26bb673531ccb371655a692f01c" translate="yes" xml:space="preserve">
          <source>A recommended starting point for the first-time user is the documentation of the &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; data type, and the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于初次使用的用户，建议的起点是 &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; 数据类型和函数 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="1e58752debf6eb10b77ef1dd1dbb8c914a8de4f8" translate="yes" xml:space="preserve">
          <source>A record definition can be placed anywhere among the attributes and function declarations of a module, but the definition must come before any usage of the record.</source>
          <target state="translated">记录的定义可以放在一个模块的属性和函数声明中的任何地方,但定义必须在记录的任何使用之前出现。</target>
        </trans-unit>
        <trans-unit id="ba583d421bbddc518a0b6122d30465ab600660d3" translate="yes" xml:space="preserve">
          <source>A record definition consists of the name of the record, followed by the field names of the record. Record and field names must be atoms. Each field can be given an optional default value. If no default value is supplied, &lt;code&gt;undefined&lt;/code&gt; is used.</source>
          <target state="translated">记录定义包括记录的名称，然后是记录的字段名称。记录和字段名称必须是原子。可以为每个字段提供一个可选的默认值。如果未提供默认值，则使用 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bbaae8298ac3d9e6e938e77fc79043b34deaf0a" translate="yes" xml:space="preserve">
          <source>A record has possibly been deleted with &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;OldRecord&lt;/code&gt; contains the value of the old record, as stated as argument by the application. Notice that other records with the same key can remain in the table if it is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">一条记录可能已通过 &lt;code&gt;&lt;a href=&quot;mnesia#delete_object-1&quot;&gt;mnesia:delete_object/1&lt;/a&gt;&lt;/code&gt; 删除。 &lt;code&gt;OldRecord&lt;/code&gt; 包含旧记录的值，如应用程序作为参数所述。请注意，如果类型为 &lt;code&gt;bag&lt;/code&gt; ，则具有相同键的其他记录可以保留在表中。</target>
        </trans-unit>
        <trans-unit id="72d63fe5211c7ae3ef0a86204219aaaa2f059f47" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. However, a record is not a true data type. Instead, record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB).</source>
          <target state="translated">记录是用于存储固定数量的元素的数据结构。它具有命名字段，并且类似于C中的结构。但是，记录不是真正的数据类型。而是在编译过程中将记录表达式转换为元组表达式。因此，除非采取特殊措施，否则外壳无法理解记录表达式。有关详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="10b1bbed2ccfee04b70ac0a61eb0d3ccdccb28c7" translate="yes" xml:space="preserve">
          <source>A record is a data structure for storing a fixed number of elements. It has named fields and is similar to a struct in C. Record expressions are translated to tuple expressions during compilation. Therefore, record expressions are not understood by the shell unless special actions are taken. For details, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">记录是用于存储固定数量的元素的数据结构。它具有命名字段，类似于C中的结构。在编译过程中，记录表达式会转换为元组表达式。因此，除非采取特殊措施，否则外壳无法理解记录表达式。有关详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="c08da4f4936f6c7ef6c5c849615f4e5aa16f8d6a" translate="yes" xml:space="preserve">
          <source>A record is defined as:</source>
          <target state="translated">记录的定义是:</target>
        </trans-unit>
        <trans-unit id="2caff8ac97a88a40d8081c22ddabb3164e9d8ee2" translate="yes" xml:space="preserve">
          <source>A record that describes an employee can look as follows:</source>
          <target state="translated">描述员工的记录可以如下所示:</target>
        </trans-unit>
        <trans-unit id="ea49bf259e7f3ffbeb1c63e53edd2986c4da3837" translate="yes" xml:space="preserve">
          <source>A reference is a term that is unique in an Erlang runtime system, created by calling &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">引用是在Erlang运行时系统中唯一的术语，通过调用 &lt;code&gt;make_ref/0&lt;/code&gt; 创建。</target>
        </trans-unit>
        <trans-unit id="14e8331cdb8c151b2856ff19909f37919f2942e9" translate="yes" xml:space="preserve">
          <source>A reference refers into a node table, which also consumes memory.</source>
          <target state="translated">引用指入节点表,也会消耗内存。</target>
        </trans-unit>
        <trans-unit id="0a4f0d6f1f9b5df543605d7bc8edbd15d630e93c" translate="yes" xml:space="preserve">
          <source>A registered name.</source>
          <target state="translated">一个注册名称;</target>
        </trans-unit>
        <trans-unit id="4417be038ecab856e8399ba11dec3102f33f7d40" translate="yes" xml:space="preserve">
          <source>A registered send operation has occurred and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; contains the pid of the sender. The message is in &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;.</source>
          <target state="translated">发生了已注册的发送操作，并且 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 包含发送者的pid。该消息在 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="e77a6a05b56401cd9d0ab970f691941ff41f5126" translate="yes" xml:space="preserve">
          <source>A registered send operation occurred. &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contains the pid of the sender.</source>
          <target state="translated">发生注册的发送操作。 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 包含发送者的pid。</target>
        </trans-unit>
        <trans-unit id="f8d3748e235b7729da3350a0d2920104b36dba36" translate="yes" xml:space="preserve">
          <source>A registry that has previously been created with &lt;code&gt;ei_reg_open()&lt;/code&gt; is closed, and all the objects it contains are freed.</source>
          <target state="translated">关闭先前使用 &lt;code&gt;ei_reg_open()&lt;/code&gt; 创建的注册表，并释放其中包含的所有对象。</target>
        </trans-unit>
        <trans-unit id="d54a6449f65944104c58b103284695849e8fb0c0" translate="yes" xml:space="preserve">
          <source>A regular expression based lexical analyzer generator for Erlang, similar to lex or flex.</source>
          <target state="translated">一个基于正则表达式的Erlang词汇分析生成器,类似于lex或flex。</target>
        </trans-unit>
        <trans-unit id="d1dac6b0a35eaa9eeb715296367bf1003d8ca372" translate="yes" xml:space="preserve">
          <source>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:</source>
          <target state="translated">正则表达式是一种从左到右与主题字符串匹配的模式。大多数字符在模式中代表自己,并与主题中的相应字符相匹配。作为一个微不足道的例子,下面的模式匹配了主题字符串中与自己相同的部分。</target>
        </trans-unit>
        <trans-unit id="72879a85f0e7c023321bf2bf93898f7dd0d964ea" translate="yes" xml:space="preserve">
          <source>A relation R in X is &lt;strong&gt;reflexive&lt;/strong&gt; if x R x for every element x of X, it is &lt;strong&gt;symmetric&lt;/strong&gt; if x R y implies that y R x, and it is &lt;strong&gt;transitive&lt;/strong&gt; if x R y and y R z imply that x R z.</source>
          <target state="translated">如果X的每个元素x的x R x是X，则X中的关系R是&lt;strong&gt;自反的&lt;/strong&gt;，如果x R y表示y R x 是&lt;strong&gt;对称的&lt;/strong&gt;，并且x R y和y R z表示x R z 是可&lt;strong&gt;传递的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d4e299db49e468c2bde2833d058721d987434955" translate="yes" xml:space="preserve">
          <source>A relation in a set is an &lt;strong&gt;equivalence relation&lt;/strong&gt; if it is reflexive, symmetric, and transitive.</source>
          <target state="translated">如果集合中的&lt;strong&gt;关系&lt;/strong&gt;是自反的，对称的和可传递的，则它是&lt;strong&gt;等价关系&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0ebab014aefe1952987eeb358deade3e55cb740e" translate="yes" xml:space="preserve">
          <source>A relational/object hybrid data model that is suitable for telecommunications applications.</source>
          <target state="translated">适合电信应用的关系/对象混合数据模型。</target>
        </trans-unit>
        <trans-unit id="bdbc21562cd7fcdf1a6c8c8fdaf7713b768b8540" translate="yes" xml:space="preserve">
          <source>A release package can also contain:</source>
          <target state="translated">释放包还可以包含:</target>
        </trans-unit>
        <trans-unit id="70a237d6b6ad6eae7ebaff5d81629ed2d641cc80" translate="yes" xml:space="preserve">
          <source>A release package is always to contain:</source>
          <target state="translated">一个发布包总是要包含:</target>
        </trans-unit>
        <trans-unit id="ec17e9f9c454053a070fd20ff7eeb8af0a65c4c3" translate="yes" xml:space="preserve">
          <source>A release resource file, &lt;code&gt;Name.rel&lt;/code&gt;</source>
          <target state="translated">发布资源文件 &lt;code&gt;Name.rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa054e2d79bd8ac06f390024625251631581f417" translate="yes" xml:space="preserve">
          <source>A release upgrade file, &lt;code&gt;relup&lt;/code&gt;</source>
          <target state="translated">发行升级文件， &lt;code&gt;relup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe2e6189285d97d6577d1e21b467c08a9445c7c" translate="yes" xml:space="preserve">
          <source>A released application must follow a certain structure.</source>
          <target state="translated">一个发布的应用必须遵循一定的结构。</target>
        </trans-unit>
        <trans-unit id="1ffc64bafad7783a2c6df745a520b71eddb2ea11" translate="yes" xml:space="preserve">
          <source>A relup script can only have one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and it must always be placed at the end. If the relup is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;, this is automatically ensured.</source>
          <target state="translated">relup脚本只能有一个 &lt;code&gt;restart_emulator&lt;/code&gt; 指令，并且必须始终将其放在最后。如果relup由 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成，则会自动确保。</target>
        </trans-unit>
        <trans-unit id="c55e43ee14cb55c89c46dda7dd3c64e06ed074e9" translate="yes" xml:space="preserve">
          <source>A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (directly or through NFS).</source>
          <target state="translated">不能使用远程Erlang文件服务器。运行Erlang节点的计算机必须能够访问文件系统(直接或通过NFS)。</target>
        </trans-unit>
        <trans-unit id="a57b69cf3ad43e824a3831ee7e57db92ae3dde80" translate="yes" xml:space="preserve">
          <source>A remote execution can terminate violently because of a signal. Then this message can be received. For details on valid string values, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; Section 6.10, which shows a special case of these signals.</source>
          <target state="translated">远程执行会由于信号而剧烈终止。然后可以接收到此消息。有关有效字符串值的详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt;RFC 4254&lt;/a&gt;&lt;/code&gt; 第6.10节，其中显示了这些信号的特殊情况。</target>
        </trans-unit>
        <trans-unit id="cfa0f3b36cc97b41ae10c4a61219216ab07da247" translate="yes" xml:space="preserve">
          <source>A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.</source>
          <target state="translated">如果存在来自X上Y的任何pid，端口，引用或funs（Erlang数据类型），或者X和Y已连接，则远程节点Y必须为节点X已知。节点同时/曾经知道的最大远程节点数受节点名称可用的 &lt;code&gt;&lt;a href=&quot;#atoms&quot;&gt;maximum number of atoms&lt;/a&gt;&lt;/code&gt; 限制。除节点名称原子外，所有与远程节点有关的数据都将被垃圾收集。</target>
        </trans-unit>
        <trans-unit id="2ef0e40b8a94e3602eaf0a08318e503302907b08" translate="yes" xml:space="preserve">
          <source>A reply sent with this function is not visible in &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug output.</source>
          <target state="translated">使用此功能发送的回复在 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; debug输出中不可见。</target>
        </trans-unit>
        <trans-unit id="d65b57be2761081067ca64ced4646ffe5f623f66" translate="yes" xml:space="preserve">
          <source>A report callback is used by the formatter to transform log messages on report form to a format string and arguments. The report callback can be specified in the metadata for the log event. If no report callback exists in metadata, &lt;code&gt;logger_formatter&lt;/code&gt; will use &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; as default callback.</source>
          <target state="translated">格式化程序使用报告回调将报告表单上的日志消息转换为格式字符串和参数。可以在日志事件的元数据中指定报告回调。如果元数据中不存在报告回调，则 &lt;code&gt;logger_formatter&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;logger#format_report-1&quot;&gt;logger:format_report/1&lt;/a&gt;&lt;/code&gt; 作为默认回调。</target>
        </trans-unit>
        <trans-unit id="3cb325283449bed9030a0b8eb054228f9049d2fb" translate="yes" xml:space="preserve">
          <source>A representaion of a part (or range) in a binary. &lt;code&gt;Start&lt;/code&gt; is a zero-based offset into a &lt;code&gt;binary()&lt;/code&gt; and &lt;code&gt;Length&lt;/code&gt; is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative &lt;code&gt;Length&lt;/code&gt;, so that the part of the binary begins at &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; and is -&lt;code&gt;Length&lt;/code&gt; long. This is useful for referencing the last &lt;code&gt;N&lt;/code&gt; bytes of a binary as &lt;code&gt;{size(Binary), -N}&lt;/code&gt;. The functions in this module always return &lt;code&gt;part()&lt;/code&gt;s with positive &lt;code&gt;Length&lt;/code&gt;.</source>
          <target state="translated">二进制中一部分（或范围）的表示。 &lt;code&gt;Start&lt;/code&gt; 是 &lt;code&gt;binary()&lt;/code&gt; 从零开始的偏移量，而 &lt;code&gt;Length&lt;/code&gt; 是该部分的长度。作为此模块中功能的输入，允许使用反向 &lt;code&gt;Length&lt;/code&gt; 规格，并以负的Length构造，以便二进制文件的一部分从 &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; 开始，且长度为 &lt;code&gt;Length&lt;/code&gt; 。这对于将二进制文件的最后 &lt;code&gt;N&lt;/code&gt; 个字节引用为 &lt;code&gt;{size(Binary), -N}&lt;/code&gt; 很有用。此模块中的函数始终返回具有正 &lt;code&gt;Length&lt;/code&gt; 的 &lt;code&gt;part()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cd076e54cc70b0a6f690c2fbc8ae7eee141d7ed" translate="yes" xml:space="preserve">
          <source>A representation of the current context of the pretty-printer. Can be accessed in hook functions.</source>
          <target state="translated">pretty-printer当前上下文的表示。可以在钩子函数中访问。</target>
        </trans-unit>
        <trans-unit id="489f7c9165ae17355e87065058b1cd9bf9bd345f" translate="yes" xml:space="preserve">
          <source>A request to http://your.server.org/cgi-bin/example/httpd_example:yahoo would refer to httpd_example:yahoo/3 or, if that does not exist, httpd_example:yahoo/2 and http://your.server.org/cgi-bin/example/other:yahoo would not be allowed to execute.</source>
          <target state="translated">对 http://your.server.org/cgi-bin/example/httpd_example:yahoo 的请求将引用 httpd_example:yahoo/3,如果该请求不存在,httpd_example:yahoo/2 和 http://your.server.org/cgi-bin/example/other:yahoo 将不允许执行。</target>
        </trans-unit>
        <trans-unit id="aa222544811c186e688c873a3b1f9169cad3037b" translate="yes" xml:space="preserve">
          <source>A request to terminate the transport process after having received DPA in response to DPR. The transport process should exit. &lt;code&gt;Pid&lt;/code&gt; is the pid() of the parent process.</source>
          <target state="translated">在收到响应DPR的DPA后终止传输过程的请求。运输过程应退出。 &lt;code&gt;Pid&lt;/code&gt; 是父进程的pid（）。</target>
        </trans-unit>
        <trans-unit id="7e78eeac55809d5c5a5db06a988ff97769682bea" translate="yes" xml:space="preserve">
          <source>A required variable can also be given a default value to be used if the variable is not found in any configuration file. To specify a default value, add a tuple on the form &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; to the test case information list (the position in the list is irrelevant).</source>
          <target state="translated">如果在任何配置文件中都找不到必需的变量，则还可以为其指定默认值。要指定默认值，请将格式为 &lt;code&gt;{default_config,ConfigVariableName,Value}&lt;/code&gt; 的元组添加到测试用例信息列表（列表中的位置无关）。</target>
        </trans-unit>
        <trans-unit id="c1229803283f11562375509c222552c10accf62d" translate="yes" xml:space="preserve">
          <source>A resource term can be serialized with &lt;code&gt;term_to_binary&lt;/code&gt; and later be fully recreated if the resource object is still alive when &lt;code&gt;binary_to_term&lt;/code&gt; is called. A &lt;strong&gt;stale&lt;/strong&gt; resource term will be returned from &lt;code&gt;binary_to_term&lt;/code&gt; if the resource object has been deallocated. &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; will return false for stale resource terms.</source>
          <target state="translated">如果在调用 &lt;code&gt;binary_to_term&lt;/code&gt; 时资源对象仍然处于活动状态，则可以使用 &lt;code&gt;term_to_binary&lt;/code&gt; 序列化资源术语，然后完全重新创建资源术语。如果已释放资源对象， &lt;code&gt;binary_to_term&lt;/code&gt; 从binary_to_term返回一个&lt;strong&gt;过时的&lt;/strong&gt;资源术语。 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 将返回false为过时资源方面。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50ae922c622293c13dbc2965d257c86fc95a1f21" translate="yes" xml:space="preserve">
          <source>A resource to be managed is represented by a managed object, which resides in the MIB. In an SNMP MIB, the managed objects are either:</source>
          <target state="translated">一个要管理的资源由一个管理对象来表示,它驻留在MIB中。在SNMP MIB中,被管理对象是:</target>
        </trans-unit>
        <trans-unit id="d797a366df3377e950dd7503223fc79e6918d3ba" translate="yes" xml:space="preserve">
          <source>A returned error reason can be converted into a readable string using &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 将返回的错误原因转换为可读的字符串。</target>
        </trans-unit>
        <trans-unit id="e1717e1bc6c4fa58d53cbf11fb5819e00bdd83ca" translate="yes" xml:space="preserve">
          <source>A rudimentary DNS client.</source>
          <target state="translated">一个基本的DNS客户端。</target>
        </trans-unit>
        <trans-unit id="dd25b98d67a3d5acbff27d930ee3340ca6349672" translate="yes" xml:space="preserve">
          <source>A run-time error can also be emulated by calling &lt;code&gt;erlang:error(Reason)&lt;/code&gt; or &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt;.</source>
          <target state="translated">也可以通过调用 &lt;code&gt;erlang:error(Reason)&lt;/code&gt; 或 &lt;code&gt;erlang:error(Reason, Args)&lt;/code&gt; 来模拟运行时错误。</target>
        </trans-unit>
        <trans-unit id="bb56303785fbc88fcc2408a8fd31a4003ffe1f34" translate="yes" xml:space="preserve">
          <source>A run-time error is another name for an exception of class &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">运行时错误是类 &lt;code&gt;error&lt;/code&gt; 异常的别称。</target>
        </trans-unit>
        <trans-unit id="608acd283e8c59f26f33232a215b266093ace6dd" translate="yes" xml:space="preserve">
          <source>A run-time error is when a crash occurs. An example is when an operator is applied to arguments of the wrong type. The Erlang programming language has built-in features for handling of run-time errors.</source>
          <target state="translated">运行时错误是指发生崩溃。一个例子是当一个运算符被应用到错误类型的参数时。Erlang编程语言具有处理运行时错误的内置功能。</target>
        </trans-unit>
        <trans-unit id="1f38ec391b2ae32351853cf5569dd5468c7febd8" translate="yes" xml:space="preserve">
          <source>A runtime system Lock Profiling tool.</source>
          <target state="translated">一个运行时系统锁分析工具。</target>
        </trans-unit>
        <trans-unit id="95c23e7c0085aa6a0c7d2ad3fa2a9bf1781844a4" translate="yes" xml:space="preserve">
          <source>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:</source>
          <target state="translated">反斜杠的第二种用法是以可见的方式对模式中的非打印字符进行编码。除了终止模式的二进制零之外,非打印字符的出现没有限制。当通过文本编辑准备一个模式时,使用以下转义序列之一往往比它所代表的二进制字符更容易。</target>
        </trans-unit>
        <trans-unit id="a201830f8803ef3e185325b4733be9adee2043a8" translate="yes" xml:space="preserve">
          <source>A second way to specify the configuration file is to set environment variable &lt;code&gt;ERL_INETRC&lt;/code&gt; to the full name of the file. Example (bash):</source>
          <target state="translated">指定配置文件的第二种方法是将环境变量 &lt;code&gt;ERL_INETRC&lt;/code&gt; 设置为文件的全名。示例（重击）：</target>
        </trans-unit>
        <trans-unit id="3ab326930bafdf3ccbffeefe99fd3e37e21b2a36" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf16&lt;/code&gt; can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</source>
          <target state="translated">&lt;code&gt;utf16&lt;/code&gt; 类型的段可以匹配二进制文件中的2或4个字节。如果匹配位置的二进制文件不包含Unicode代码点的合法UTF-16编码，则匹配失败。（请参阅RFC-2781或Unicode标准。）</target>
        </trans-unit>
        <trans-unit id="39d79b140754fe8ea4a56be0590e56af2f7d1ffd" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf32&lt;/code&gt; can match 4 bytes in the binary in the same way as an &lt;code&gt;integer&lt;/code&gt; segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</source>
          <target state="translated">&lt;code&gt;utf32&lt;/code&gt; 类型的段可以匹配二进制文件中的4个字节，就像 &lt;code&gt;integer&lt;/code&gt; 段匹配32位一样。如果结果整数超出上述合法范围，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="9984182f8f78656080573a1d2d8804143caf4c98" translate="yes" xml:space="preserve">
          <source>A segment of type &lt;code&gt;utf8&lt;/code&gt; matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</source>
          <target state="translated">如果匹配位置的二进制文件包含有效的UTF-8序列，则 &lt;code&gt;utf8&lt;/code&gt; 类型的段将匹配二进制文件中的1-4个字节。（请参阅RFC-3629或Unicode标准。）</target>
        </trans-unit>
        <trans-unit id="a68e30a75c41fb283b1d801f37a87f7e17458fd0" translate="yes" xml:space="preserve">
          <source>A selective receive cannot be used from a &lt;code&gt;gen_statem&lt;/code&gt; behavior as for any &lt;code&gt;gen_*&lt;/code&gt; behavior, as the receive statement is within the &lt;code&gt;gen_*&lt;/code&gt; engine itself. It must be there because all &lt;code&gt;sys&lt;/code&gt; compatible behaviors must respond to system messages and therefore do that in their engine receive loop, passing non-system messages to the callback module.</source>
          <target state="translated">对于任何 &lt;code&gt;gen_*&lt;/code&gt; 行为，不能从 &lt;code&gt;gen_statem&lt;/code&gt; 行为使用选择性接收，因为receive语句位于 &lt;code&gt;gen_*&lt;/code&gt; 引擎本身内。之所以必须存在，是因为所有与 &lt;code&gt;sys&lt;/code&gt; 兼容的行为都必须响应系统消息，并因此在其引擎接收循环中执行此操作，从而将非系统消息传递给回调模块。</target>
        </trans-unit>
        <trans-unit id="784ef7e594348fdd6dc02214ab3a2844aad416d3" translate="yes" xml:space="preserve">
          <source>A sequence group can have subgroups. Such subgroups can have any property, that is, they are not required to also be sequences. If you want the status of the subgroup to affect the sequence on the level above, return &lt;code&gt;{return_group_result,Status}&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt;, as described in section &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; in Writing Test Suites. A failed subgroup (&lt;code&gt;Status == failed&lt;/code&gt;) causes the execution of a sequence to fail in the same way a test case does.</source>
          <target state="translated">序列组可以具有子组。这样的子组可以具有任何属性，即，它们也不必是序列。如果希望子组的状态影响上述级别的顺序 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 中返回{return_group_result，Status}，如编写测试套件中的 &lt;code&gt;&lt;a href=&quot;write_test_chapter#repeated_groups&quot;&gt;Repeated Groups&lt;/a&gt;&lt;/code&gt; 一节中所述。失败的子组（ &lt;code&gt;Status == failed&lt;/code&gt; ）导致序列的执行失败，就像测试用例一样。</target>
        </trans-unit>
        <trans-unit id="d3c229a36faac40695a5902fc9fc7dd25d6c2813" translate="yes" xml:space="preserve">
          <source>A sequence of test cases is defined as a test case group with a &lt;code&gt;sequence&lt;/code&gt; property. Test case groups are defined through function &lt;code&gt;groups/0&lt;/code&gt; in the test suite (for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">测试用例序列被定义为具有 &lt;code&gt;sequence&lt;/code&gt; 属性的测试用例组。测试用例组通过测试套件中的功能 &lt;code&gt;groups/0&lt;/code&gt; 定义（有关详细信息，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 一节）。</target>
        </trans-unit>
        <trans-unit id="c3bba90a5446a96b415be975533162f2c93173c4" translate="yes" xml:space="preserve">
          <source>A server (daemon) is started with &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt;. Possible channel handlers (subsystems) are declared with the &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; option when the daemon is started.</source>
          <target state="translated">服务器（守护程序）以 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#daemon-2&quot;&gt;daemon/3&lt;/a&gt;&lt;/code&gt; 启动。启动守护程序时，可能使用 &lt;code&gt;&lt;a href=&quot;#type-subsystem_daemon_option&quot;&gt;subsystem&lt;/a&gt;&lt;/code&gt; 选项声明了可能的通道处理程序（子系统）。</target>
        </trans-unit>
        <trans-unit id="7591fe377fd82c97d5cbe48dffa3dba89975a255" translate="yes" xml:space="preserve">
          <source>A server only does x509-path validation in mode &lt;code&gt;verify_peer&lt;/code&gt;, as it then sends a certificate request to the client (this message is not sent if the verify option is &lt;code&gt;verify_none&lt;/code&gt;). You can then also want to specify option &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt;.</source>
          <target state="translated">服务器仅在 &lt;code&gt;verify_peer&lt;/code&gt; 模式下进行x509路径验证，因为它随后向客户端发送证书请求（如果verify选项为 &lt;code&gt;verify_none&lt;/code&gt; ,则不会发送此消息）。然后，您还可以指定选项 &lt;code&gt;fail_if_no_peer_cert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d55cabe8354d1d604d4df37a3e5535ff9d3abddc" translate="yes" xml:space="preserve">
          <source>A server which receives just enough requests to never become idle will score a CPU utilization of 100%. If the server receives 50% more requests, it will still score 100%. When the system load is calculated with the percentage formula shown previously, the load will increase from 80% to 87%.</source>
          <target state="translated">一台服务器如果收到的请求刚好够多,永远不会闲置,那么它的CPU利用率就会达到100%。如果服务器多收到50%的请求,它的得分仍然是100%。如果用前面所示的百分比公式计算系统负载,负载将从80%增加到87%。</target>
        </trans-unit>
        <trans-unit id="49249370ad03c7d756d03cbc940860544a07d772" translate="yes" xml:space="preserve">
          <source>A server- or client-channel process can choose to close their session by sending a close event.</source>
          <target state="translated">一个服务器或客户端通道进程可以选择通过发送关闭事件来关闭他们的会话。</target>
        </trans-unit>
        <trans-unit id="80df1578413d7127e8d72a01fdf816a3b3d60cac" translate="yes" xml:space="preserve">
          <source>A server-side subssystem (channel) server is requested by the client with &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">客户端使用 &lt;code&gt;&lt;a href=&quot;ssh_connection#subsystem-4&quot;&gt;ssh_connection:subsystem/4&lt;/a&gt;&lt;/code&gt; 请求服务器端子系统（通道）服务器。</target>
        </trans-unit>
        <trans-unit id="6d3204ae6a9c144bcf2930bab159f079cdea0012" translate="yes" xml:space="preserve">
          <source>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">服务定义了本地实现的Diameter节点，指定了在能力交换期间要通告的能力。使用 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 将传输添加到服务中。</target>
        </trans-unit>
        <trans-unit id="b4b0724093ca8cf67b42fd8065ef62234f98ab2d" translate="yes" xml:space="preserve">
          <source>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; is passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">服务必须为其打算支持的每个Diameter应用程序配置一个元组。对于传出请求，相关的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 传递给 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; ，而对于传入请求，消息头中的应用程序标识符确定应用程序，该标识符在应用程序的 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary&lt;/a&gt;&lt;/code&gt; 文件中指定。</target>
        </trans-unit>
        <trans-unit id="aaffe8ed9bffeb5034f89141848d697c4f8ddf46" translate="yes" xml:space="preserve">
          <source>A service started as &lt;code&gt;stand_alone&lt;/code&gt;, that is, the service is not started as part of the &lt;code&gt;Inets&lt;/code&gt; application, lose all OTP application benefits, such as soft upgrade. The &lt;code&gt;stand_alone&lt;/code&gt;-service is linked to the process that started it. Usually some supervision functionality is still in place and in some sense the calling process becomes the top supervisor.</source>
          <target state="translated">以 &lt;code&gt;stand_alone&lt;/code&gt; 形式启动的服务，也就是说，该服务不是作为 &lt;code&gt;Inets&lt;/code&gt; 应用程序的一部分启动的，失去了所有OTP应用程序的优势，例如软升级。该 &lt;code&gt;stand_alone&lt;/code&gt; -service被链接到启动它的过程。通常，某些监督功能仍然存在，并且从某种意义上讲，呼叫过程成为最高主管。</target>
        </trans-unit>
        <trans-unit id="e8a6a012891bda48b015b0c9afa1553acf746ed9" translate="yes" xml:space="preserve">
          <source>A service that does not use shared peers will always pass the empty list as the second argument of &lt;code&gt;pick_peer/4&lt;/code&gt; callbacks.</source>
          <target state="translated">不使用共享对等方的服务将始终将空列表作为 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调的第二个参数传递。</target>
        </trans-unit>
        <trans-unit id="10b22bcc7e1248f51cdd1cbb03116a8abb78e603" translate="yes" xml:space="preserve">
          <source>A service to read internally formatted wrap disk logs.</source>
          <target state="translated">读取内部格式化的包盘日志的服务。</target>
        </trans-unit>
        <trans-unit id="948069c04efacc3c5dcde4803a65b30408e7f31d" translate="yes" xml:space="preserve">
          <source>A session opened in this way is closed using function &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数关闭以这种方式打开的会话。</target>
        </trans-unit>
        <trans-unit id="f8dce1ed875eff8e76251a001abc25f652960e66" translate="yes" xml:space="preserve">
          <source>A set of calls between strongly connected components is a sorted list without duplicates of &lt;code&gt;ComponentCall&lt;/code&gt;.</source>
          <target state="translated">在强连接的组件之间的一组调用是一个排序列表，没有 &lt;code&gt;ComponentCall&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="710107e57e111e349884878304dfebbb60768c1a" translate="yes" xml:space="preserve">
          <source>A set of calls is represented by a sorted list without duplicates of &lt;code&gt;call()&lt;/code&gt;.</source>
          <target state="translated">一组调用由排序列表表示，没有 &lt;code&gt;call()&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="a5ec339bfafa729e7589bcb584094f5693b62949" translate="yes" xml:space="preserve">
          <source>A set of constants is represented by a sorted list without duplicates of &lt;code&gt;constant()&lt;/code&gt;.</source>
          <target state="translated">一组常量由一个排序列表表示，没有 &lt;code&gt;constant()&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="46692ec19a49b0489e3ac224ff31df52bd24aef0" translate="yes" xml:space="preserve">
          <source>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see &lt;code&gt;send_chunk_start/2&lt;/code&gt;, &lt;code&gt;send_chunk/2&lt;/code&gt;, and &lt;code&gt;send_chunk_end/1&lt;/code&gt;. For receive, see &lt;code&gt;recv_chunk_start/2&lt;/code&gt; and &lt;code&gt;recv_chunk/&lt;/code&gt;).</source>
          <target state="translated">提供了一组功能，用于发送和接收要存储在远程文件中的文件的连续部分。有关发送，请参见 &lt;code&gt;send_chunk_start/2&lt;/code&gt; ， &lt;code&gt;send_chunk/2&lt;/code&gt; 和 &lt;code&gt;send_chunk_end/1&lt;/code&gt; 。有关接收，请参见 &lt;code&gt;recv_chunk_start/2&lt;/code&gt; 和 &lt;code&gt;recv_chunk/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a9d7c3dd3508b04f4667584c78e7f619f9eb1de" translate="yes" xml:space="preserve">
          <source>A set of line numbered function calls is represented by a sorted list without duplicates of &lt;code&gt;CallAt&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数调用由排序列表表示，没有 &lt;code&gt;CallAt&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="6b7c151fe3e99d8bd5f4ffa52f47c3f04812cf74" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions and function calls is represented by a sorted list without duplicates of &lt;code&gt;AllLines&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数和函数调用由排序列表表示，没有 &lt;code&gt;AllLines&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="840dbd2f93a5198291444ddc8bbccef2c8f9c9ff" translate="yes" xml:space="preserve">
          <source>A set of line numbered functions is represented by a sorted list without duplicates of &lt;code&gt;DefineAt&lt;/code&gt;.</source>
          <target state="translated">一组行编号的函数由一个排序列表表示，没有 &lt;code&gt;DefineAt&lt;/code&gt; 重复项。</target>
        </trans-unit>
        <trans-unit id="3a5c61082d9404d5c0adf57236aa5f42fbc02337" translate="yes" xml:space="preserve">
          <source>A set of strongly connected components is a sorted list without duplicates of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">一组强连接的组件是一个排序列表，没有 &lt;code&gt;Component&lt;/code&gt; 的重复项。</target>
        </trans-unit>
        <trans-unit id="ac0087ee308abd483706f991654adce8870956a6" translate="yes" xml:space="preserve">
          <source>A set of tables is created. The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates the required database tables. The options available with &lt;code&gt;ArgList&lt;/code&gt; are explained in &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将创建一组表。函数 &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 创建所需的数据库表。 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#create_tables&quot;&gt;Create New Tables&lt;/a&gt;&lt;/code&gt; 中说明了 &lt;code&gt;ArgList&lt;/code&gt; 可用的选项。</target>
        </trans-unit>
        <trans-unit id="19f06211d11839665e84e1ea20d520a0f11afac6" translate="yes" xml:space="preserve">
          <source>A set of test cases sharing configuration functions and execution properties. The execution properties specify if the test cases in the group are to be executed in random order, in parallel, or in sequence, and if the execution of the group is be repeated. Test case groups can also be nested. That is, a group can, besides test cases, contain subgroups.</source>
          <target state="translated">一组共享配置功能和执行属性的测试用例。执行属性指定了测试用例组中的测试用例是以随机顺序、并行还是顺序执行,以及测试用例组的执行是否会被重复。测试用例组也可以嵌套。也就是说,一个组除了测试用例之外,还可以包含子组。</target>
        </trans-unit>
        <trans-unit id="12949a595f1f2f62a415607d8b62df7565321239" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 和 &lt;code&gt;report_warnings&lt;/code&gt; 的简写形式。</target>
        </trans-unit>
        <trans-unit id="63beb5981caaa740ca850381d113e7457110327c" translate="yes" xml:space="preserve">
          <source>A short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return_errors&lt;/code&gt; 和 &lt;code&gt;return_warnings&lt;/code&gt; 的简写形式。</target>
        </trans-unit>
        <trans-unit id="7ea5611de1365c235cc088e3d33261341dcca035" translate="yes" xml:space="preserve">
          <source>A signal can be delivered to the remote process/service using the following message. Some systems do not support signals, in which case they are to ignore this message. There is currently no function to generate this event as the signals referred to are on OS-level and not something generated by an Erlang program.</source>
          <target state="translated">可以使用以下信息向远程进程/服务传递信号。有些系统不支持信号,在这种情况下,它们会忽略这个消息。目前还没有产生这个事件的功能,因为所提到的信号是在操作系统级别的,而不是由Erlang程序产生的东西。</target>
        </trans-unit>
        <trans-unit id="42eda09ed588353be26cc09cfa2d978f18b6e4d1" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for representation of time.</source>
          <target state="translated">一个有符号的64位整数类型,用于表示时间。</target>
        </trans-unit>
        <trans-unit id="2ec4fc4bbc8342af35d07fe169518f0743782cba" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer type for time representation.</source>
          <target state="translated">一个有符号的64位整数类型,用于表示时间。</target>
        </trans-unit>
        <trans-unit id="38a842896cfe88c4a3ddef8d3cf91788c49c732c" translate="yes" xml:space="preserve">
          <source>A signed integer type, the size of &lt;code&gt;ErlDrvSizeT&lt;/code&gt;.</source>
          <target state="translated">一个有符号整数类型，其大小为 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0fe9a2b6f1d0a57855755f4b057af6a3783f46" translate="yes" xml:space="preserve">
          <source>A similar syntax as for module attributes is used for specifying types and function specifications:</source>
          <target state="translated">类似于模块属性的语法被用于指定类型和函数规格。</target>
        </trans-unit>
        <trans-unit id="8a8c55df8388e2c8abf4b42d441b92ec7fc5ed46" translate="yes" xml:space="preserve">
          <source>A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</source>
          <target state="translated">一个简单的调用计数分析工具,使用断点对运行时性能影响最小。</target>
        </trans-unit>
        <trans-unit id="c5cb837e5d2ca7e262291078f0d5802db7966be5" translate="yes" xml:space="preserve">
          <source>A simple Erlang SCTP client that uses the &lt;code&gt;connect_init&lt;/code&gt; API:</source>
          <target state="translated">使用 &lt;code&gt;connect_init&lt;/code&gt; API的简单Erlang SCTP客户端：</target>
        </trans-unit>
        <trans-unit id="d0c9a192d81f4fa039cbd886ce4bd4a73ce2b099" translate="yes" xml:space="preserve">
          <source>A simple configuration handling driver, asking an external server for configuration data, can be implemented as follows:</source>
          <target state="translated">可以实现一个简单的配置处理驱动,向外部服务器索取配置数据,具体如下。</target>
        </trans-unit>
        <trans-unit id="94159518c423ba9ecd622c20fd73db453e69d787" translate="yes" xml:space="preserve">
          <source>A simple distributed agent can be managed without sub-agents. The instrumentation functions can use distributed Erlang to communicate with other parts of the application. However, a sub-agent can be used on each node if this generates too much unnecessary traffic. A sub-agent processes requests per incoming SNMP request, not per variable. Therefore the network traffic is minimized.</source>
          <target state="translated">一个简单的分布式代理可以在没有子代理的情况下进行管理。仪表功能可以使用分布式Erlang与应用程序的其他部分进行通信。然而,如果产生过多不必要的流量,可以在每个节点上使用一个子代理。子代理处理每个传入的SNMP请求,而不是每个变量。因此,网络流量是最小的。</target>
        </trans-unit>
        <trans-unit id="37a291b9ccd26ae2e858205df24cc14753b44a96" translate="yes" xml:space="preserve">
          <source>A simple example of how to use the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">一个简单的例子,说明如何使用SNMP开发工具包的管理器组件。</target>
        </trans-unit>
        <trans-unit id="e0d43223e0be204bdc5f431e2cd09f2620cd3cba" translate="yes" xml:space="preserve">
          <source>A simple example of how to write agent test cases, using the new manager.</source>
          <target state="translated">一个简单的例子,说明如何使用新管理器编写代理测试用例。</target>
        </trans-unit>
        <trans-unit id="a47de2d4ec5f53818458005215063c067e9f2a3e" translate="yes" xml:space="preserve">
          <source>A simple example. A single quad core processor can be described as follows:</source>
          <target state="translated">一个简单的例子。单个四核处理器可以描述如下。</target>
        </trans-unit>
        <trans-unit id="dd61143e005b303fe8d62ae782f18058638458a2" translate="yes" xml:space="preserve">
          <source>A simple handler that prints to the terminal can be implemented as follows:</source>
          <target state="translated">一个打印到终端的简单处理程序可以实现如下。</target>
        </trans-unit>
        <trans-unit id="d231f36ed1b4dce67cc3b50e0ae15aa4df7e9395" translate="yes" xml:space="preserve">
          <source>A simple interactive configuration tool. Simple configuration files can be generated, but more complex configurations still have to be edited manually.</source>
          <target state="translated">一个简单的交互式配置工具。可以生成简单的配置文件,但更复杂的配置仍需手动编辑。</target>
        </trans-unit>
        <trans-unit id="9bb0a791b7816e17ce1b48c1aee66bf6abe2e694" translate="yes" xml:space="preserve">
          <source>A simple solution would be to use the &lt;code&gt;name&lt;/code&gt; field as the key instead of the &lt;code&gt;idno&lt;/code&gt; field, but that would cause problems if the names were not unique. A more general solution would be to create a second table with &lt;code&gt;name&lt;/code&gt; as key and &lt;code&gt;idno&lt;/code&gt; as data, that is, to index (invert) the table regarding the &lt;code&gt;name&lt;/code&gt; field. Clearly, the second table would have to be kept consistent with the master table. Mnesia can do this for you, but a home brew index table can be very efficient compared to the overhead involved in using Mnesia.</source>
          <target state="translated">一个简单的解决方案是使用 &lt;code&gt;name&lt;/code&gt; 字段作为键而不是 &lt;code&gt;idno&lt;/code&gt; 字段，但是如果名称不是唯一的，那将会引起问题。一个更通用的解决方案是创建第二个表，该表的 &lt;code&gt;name&lt;/code&gt; 为key， &lt;code&gt;idno&lt;/code&gt; 为数据，即对与 &lt;code&gt;name&lt;/code&gt; 字段有关的表进行索引（反转）。显然，第二张表必须与主表保持一致。Mnesia可以为您做到这一点，但是与使用Mnesia所涉及的开销相比，家庭酿造索引表可以非常有效。</target>
        </trans-unit>
        <trans-unit id="a677c35bea852cdbf8756b158d2b8bcbf8d2e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue the following commands:</source>
          <target state="translated">一个简单的方法是发出以下命令。</target>
        </trans-unit>
        <trans-unit id="464b91e40e2a3cb96819c357b1617d8db059e71c" translate="yes" xml:space="preserve">
          <source>A simple way to do this is to issue these commands:</source>
          <target state="translated">一个简单的方法是发出这些命令。</target>
        </trans-unit>
        <trans-unit id="eea77823d49a9512680d9b481e0a65ed1b7a8abb" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;~&lt;/code&gt; is expected in the input.</source>
          <target state="translated">输入中应包含单个 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3145e708c1deab465a16f4608e04895d3f01b3" translate="yes" xml:space="preserve">
          <source>A single atom represents a module name, and is equivalent to &lt;code&gt;{module, ModuleName}&lt;/code&gt;. This is often used as in the call &lt;code&gt;eunit:test(some_module)&lt;/code&gt;.</source>
          <target state="translated">单个原子表示模块名称，并且等效于 &lt;code&gt;{module, ModuleName}&lt;/code&gt; 。通常在调用 &lt;code&gt;eunit:test(some_module)&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="437abe5f66fc807f023b84e5b53bea27300039ac" translate="yes" xml:space="preserve">
          <source>A single binary can be sent with &lt;code&gt;driver_output_binary()&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;driver_output_binary()&lt;/code&gt; 发送单个二进制文件。</target>
        </trans-unit>
        <trans-unit id="d82ab9afcf3b874d81d1b01e2b29a3023c6ead3c" translate="yes" xml:space="preserve">
          <source>A single line (as in former example) is requested with the following &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">随以下 &lt;code&gt;Request&lt;/code&gt; 一行（如前例所示）：</target>
        </trans-unit>
        <trans-unit id="91eb11dd51a7d947aa277af7b00518dd07ecd8dd" translate="yes" xml:space="preserve">
          <source>A single string represents the path of a file or directory, and is equivalent to &lt;code&gt;{file, Path}&lt;/code&gt;, or &lt;code&gt;{dir, Path}&lt;/code&gt;, respectively, depending on what &lt;code&gt;Path&lt;/code&gt; refers to in the file system.</source>
          <target state="translated">单个字符串表示文件或目录的路径，并分别等效于 &lt;code&gt;{file, Path}&lt;/code&gt; 或 &lt;code&gt;{dir, Path}&lt;/code&gt; ，具体取决于 &lt;code&gt;Path&lt;/code&gt; 在文件系统中所指的是什么。</target>
        </trans-unit>
        <trans-unit id="f128070bab19006a2ef91c51aaca808921167bc6" translate="yes" xml:space="preserve">
          <source>A single test included in a test suite. A test case is implemented as a function in a test suite module.</source>
          <target state="translated">包含在测试套件中的单个测试。测试用例是作为测试套件模块中的一个函数来实现的。</target>
        </trans-unit>
        <trans-unit id="c6134a35a4b3aed44a3d6f996738074a3183b087" translate="yes" xml:space="preserve">
          <source>A single, well-defined test, that somehow can be uniquely identified. When executed, the test case either &lt;strong&gt;passes&lt;/strong&gt; or &lt;strong&gt;fails&lt;/strong&gt;; the test report should identify exactly which test cases failed.</source>
          <target state="translated">可以明确识别单个定义明确的测试。执行时，测试用例要么&lt;strong&gt;通过&lt;/strong&gt;要么&lt;strong&gt;失败&lt;/strong&gt;；测试报告应准确确定哪些测试用例失败。</target>
        </trans-unit>
        <trans-unit id="ff7e932fb59b9670681676d154f390a5b9707270" translate="yes" xml:space="preserve">
          <source>A situation where it might be useful to add an algorithm is when one need to use a supported but disabled one. An example is the &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; which nowadays is very unsecure and therefore disabled. It is however still supported and might be used.</source>
          <target state="translated">当需要使用受支持但已禁用的算法时，添加一种算法可能会很有用。一个例子是 &lt;code&gt;'diffie-hellman-group1-sha1'&lt;/code&gt; ，如今它非常不安全，因此被禁用。但是，它仍然受支持并且可以使用。</target>
        </trans-unit>
        <trans-unit id="c8a737055966988fa33536560d8ee3886f563bb5" translate="yes" xml:space="preserve">
          <source>A skeleton is a piece of pre-written code that can be inserted into the buffer. Erlang mode comes with a set of predefined skeletons. The skeletons can be accessed either from the Erlang menu of from commands named &lt;code&gt;tempo-template-erlang-*&lt;/code&gt;, as the skeletons is defined using the standard Emacs package &quot;tempo&quot;. Here follows a brief description of the available skeletons:</source>
          <target state="translated">骨架是一段可以插入缓冲区的预写代码。Erlang模式带有一组预定义的框架。可以从名为 &lt;code&gt;tempo-template-erlang-*&lt;/code&gt; 的命令的Erlang菜单中访问骨架，因为骨架是使用标准Emacs软件包&amp;ldquo; tempo&amp;rdquo;定义的。以下是可用骨架的简要说明：</target>
        </trans-unit>
        <trans-unit id="3fbeb5f6d202d2f6a94d6926e8772e60f8395d0b" translate="yes" xml:space="preserve">
          <source>A sketch of the procedure employed:</source>
          <target state="translated">采用的程序简述;</target>
        </trans-unit>
        <trans-unit id="347ad9db1092bfae38de28e8384c541f8eda0f16" translate="yes" xml:space="preserve">
          <source>A slogan indicating the reason for the dump</source>
          <target state="translated">说明倾倒原因的口号</target>
        </trans-unit>
        <trans-unit id="c82db0ac725e371be4e92cf842d525309be1a960" translate="yes" xml:space="preserve">
          <source>A small &lt;code&gt;ssh&lt;/code&gt; subsystem that echoes N bytes can be implemented as shown in the following example:</source>
          <target state="translated">可以实现一个回显N个字节的小型 &lt;code&gt;ssh&lt;/code&gt; 子系统，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="ee793e88b05c2c54637d37d2dc3b6df251a95612" translate="yes" xml:space="preserve">
          <source>A small note about each failed test case.</source>
          <target state="translated">关于每个失败的测试案例的一个小说明。</target>
        </trans-unit>
        <trans-unit id="89269626521455c0533dcc1024e681dcdd2fe91d" translate="yes" xml:space="preserve">
          <source>A small number of &quot;-&quot; flags exist, which now actually are emulator flags, see the description below.</source>
          <target state="translated">存在少量的&quot;-&quot;标志,现在实际上是仿真器标志,请看下面的说明。</target>
        </trans-unit>
        <trans-unit id="b8571dea892b8010a396168429a316241eeb9263" translate="yes" xml:space="preserve">
          <source>A soft limit on the number of characters returned. When the number of characters is reached, remaining structures are replaced by &quot;&lt;code&gt;...&lt;/code&gt;&quot;. &lt;code&gt;CharsLimit&lt;/code&gt; defaults to -1, which means no limit on the number of characters returned.</source>
          <target state="translated">对返回的字符数的软限制。当达到字符数时，其余结构将替换为&amp;ldquo; &lt;code&gt;...&lt;/code&gt; &amp;rdquo;。 &lt;code&gt;CharsLimit&lt;/code&gt; 默认为-1，这意味着返回的字符数没有限制。</target>
        </trans-unit>
        <trans-unit id="c5403e8588747737164215b85effd60defff4f50" translate="yes" xml:space="preserve">
          <source>A sorted list of &lt;code&gt;{Node, Count}&lt;/code&gt; tuples that are sorted in increasing &lt;code&gt;Count&lt;/code&gt; order. &lt;code&gt;Count&lt;/code&gt; is the total number of replicas that this fragmented table hosts on each &lt;code&gt;Node&lt;/code&gt;. The list always contains at least all nodes in &lt;code&gt;node_pool&lt;/code&gt;. Nodes that do not belong to &lt;code&gt;node_pool&lt;/code&gt; are put last in the list even if their &lt;code&gt;Count&lt;/code&gt; is lower.</source>
          <target state="translated">&lt;code&gt;{Node, Count}&lt;/code&gt; 元组的排序列表，以递增的 &lt;code&gt;Count&lt;/code&gt; 顺序排序。 &lt;code&gt;Count&lt;/code&gt; 是此碎片表在每个 &lt;code&gt;Node&lt;/code&gt; 上托管的副本总数。该列表始​​终至少包含 &lt;code&gt;node_pool&lt;/code&gt; 中的所有节点。不属于 &lt;code&gt;node_pool&lt;/code&gt; 的节点即使其 &lt;code&gt;Count&lt;/code&gt; 较低，也会放在列表的最后。</target>
        </trans-unit>
        <trans-unit id="920a6a7e45bffb0b7a8b87d5da85daae27b47541" translate="yes" xml:space="preserve">
          <source>A space-separated string specifying the program to be executed. The second field is typically a command name such as &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">用空格分隔的字符串，指定要执行的程序。第二个字段通常是命令名称，例如 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bbb00e915060a377363fa9765e2fd6a815cb4ee" translate="yes" xml:space="preserve">
          <source>A special item that consists of (? followed by a number &amp;gt; 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.</source>
          <target state="translated">由（？后跟数字&amp;gt; 0和右括号组成的特殊项目是给定数字子模式的递归子例程调用，如果该子模式在该子模式内发生（如果不是，则为非递归子例程调用。 ，特殊项目（？R）或（？0）是整个正则表达式的递归调用。</target>
        </trans-unit>
        <trans-unit id="b5d7d4630bf6e699f86315587f52b147af8c7634" translate="yes" xml:space="preserve">
          <source>A special routine invoked with &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. It works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to &lt;code&gt;port_control/3&lt;/code&gt; arrives in &lt;code&gt;buf&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt;. The driver can send data back, using &lt;code&gt;*rbuf&lt;/code&gt; and &lt;code&gt;rlen&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 调用的特殊例程。对于Erlang驱动程序，它的工作原理类似于&amp;ldquo; ioctl&amp;rdquo;。指定给 &lt;code&gt;port_control/3&lt;/code&gt; 的数据到达 &lt;code&gt;buf&lt;/code&gt; 和 &lt;code&gt;len&lt;/code&gt; 。驱动程序可以使用 &lt;code&gt;*rbuf&lt;/code&gt; 和 &lt;code&gt;rlen&lt;/code&gt; 将数据发送回去。</target>
        </trans-unit>
        <trans-unit id="818bed6690afd85a8e837d5ce544a94b65462268" translate="yes" xml:space="preserve">
          <source>A special type of error is when no actual invalid integers or bytes are found, but a trailing &lt;code&gt;binary()&lt;/code&gt; consists of too few bytes to decode the last character. This error can occur if bytes are read from a file in chunks or if binaries in other ways are split on non-UTF character boundaries. An &lt;code&gt;incomplete&lt;/code&gt; tuple is then returned instead of the &lt;code&gt;error&lt;/code&gt; tuple. It consists of the same parts as the &lt;code&gt;error&lt;/code&gt; tuple, but the tag is &lt;code&gt;incomplete&lt;/code&gt; instead of &lt;code&gt;error&lt;/code&gt; and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</source>
          <target state="translated">错误的一种特殊类型是找不到实际无效的整数或字节，但是尾随的 &lt;code&gt;binary()&lt;/code&gt; 包含的字节太少而无法解码最后一个字符。如果从文件中分块读取字节或以其他方式在非UTF字符边界上分割二进制文件，则可能发生此错误。一个 &lt;code&gt;incomplete&lt;/code&gt; 那么行会返回，而不是 &lt;code&gt;error&lt;/code&gt; 的元组。它由与 &lt;code&gt;error&lt;/code&gt; 元组相同的部分组成，但是标签是 &lt;code&gt;incomplete&lt;/code&gt; 而不是 &lt;code&gt;error&lt;/code&gt; ，并且最后一个元素始终保证是由（到目前为止）有效UTF字符的第一部分组成的二进制文件。</target>
        </trans-unit>
        <trans-unit id="eebe590a8a4fd637cbd36f90802e9523ed6a4512" translate="yes" xml:space="preserve">
          <source>A specification (or contract) for a function is given using the &lt;code&gt;-spec&lt;/code&gt; attribute. The general format is as follows:</source>
          <target state="translated">使用 &lt;code&gt;-spec&lt;/code&gt; 属性给出功能的规范（或合同）。通用格式如下：</target>
        </trans-unit>
        <trans-unit id="7dc4ccb3d8ddcce0db9cf1c2ea5d5fda23fcb4be" translate="yes" xml:space="preserve">
          <source>A state change cancels a &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; and any new transition option of this type belongs to the new state.</source>
          <target state="translated">状态更改会取消 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; ,并且此类型的任何新过渡选项都属于新状态。</target>
        </trans-unit>
        <trans-unit id="1ce1fae1923f3d7397b496fc579d7f7f29266cd7" translate="yes" xml:space="preserve">
          <source>A status, which is &lt;strong&gt;active&lt;/strong&gt; or &lt;strong&gt;inactive&lt;/strong&gt;. An inactive breakpoint is ignored.</source>
          <target state="translated">状态，&lt;strong&gt;处于活动状态&lt;/strong&gt;或非&lt;strong&gt;活动状态&lt;/strong&gt;。无效的断点将被忽略。</target>
        </trans-unit>
        <trans-unit id="cb3254f6f71d42ad5babf60af6c4beadc5fe794a" translate="yes" xml:space="preserve">
          <source>A sticky lock is a lock that stays in place at a node, after the transaction that first acquired the lock has terminated. To illustrate this, assume that the following transaction is executed:</source>
          <target state="translated">粘性锁是指在首次获取锁的事务终止后,仍然保持在一个节点上的锁。为了说明这一点,假设执行以下事务。</target>
        </trans-unit>
        <trans-unit id="0d036eed01d979d152da2689054b2a8a3616ab3b" translate="yes" xml:space="preserve">
          <source>A string containing the OTP release number (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">包含OTP发行版号的字符串（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_otp_release&quot;&gt;erlang:system_info(otp_release)&lt;/a&gt;&lt;/code&gt; 返回的相同）。</target>
        </trans-unit>
        <trans-unit id="7a887f90504538f7764832dfb1ec18f08b3d4d4e" translate="yes" xml:space="preserve">
          <source>A string containing the regular expression</source>
          <target state="translated">包含正则表达式的字符串</target>
        </trans-unit>
        <trans-unit id="e0f49966a17385c888cdd7ff3581d6cc3b4a55ee" translate="yes" xml:space="preserve">
          <source>A string containing the version number of the runtime system (the same as returned by &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">包含运行时系统版本号的字符串（与 &lt;code&gt;&lt;a href=&quot;erlang#system_info_version&quot;&gt;erlang:system_info(version)&lt;/a&gt;&lt;/code&gt; 返回的版本号相同）。</target>
        </trans-unit>
        <trans-unit id="a067c189aea167f729e4e4094e5cef684c3ebe5a" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable names using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) and &lt;code&gt;$=&lt;/code&gt; characters are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">一个字符串，其中包含特定操作系统上使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码的环境变量名称的有效字符。请注意，尤其不允许使用空字符（整数值零）和 &lt;code&gt;$=&lt;/code&gt; 字符。但是，请注意，并非所有无效字符都必定会导致primitiv操作失败，但可能会产生无效结果。</target>
        </trans-unit>
        <trans-unit id="70f78f37d5d4757bbdf76a8e2359db2143d09529" translate="yes" xml:space="preserve">
          <source>A string containing valid characters on the specific OS for environment variable values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. Note that specifically null characters (integer value zero) are not allowed. However, note that not all invalid characters necessarily will cause the primitiv operations to fail, but may instead produce invalid results.</source>
          <target state="translated">一个字符串，其中包含特定操作系统上使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码的环境变量值的有效字符。请注意，明确不允许使用空字符（整数值零）。但是，请注意，并非所有无效字符都必定会导致primitiv操作失败，但可能会产生无效结果。</target>
        </trans-unit>
        <trans-unit id="9de478315c2065a78cf4db328a67478bae83694c" translate="yes" xml:space="preserve">
          <source>A string describing the error is obtained with the following call:</source>
          <target state="translated">通过下面的调用可以得到一个描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="ee46978e6166eeae1dd2570aa404c6015d82f71d" translate="yes" xml:space="preserve">
          <source>A string identifying the created thread. It is used to identify the thread in planned future debug functionality.</source>
          <target state="translated">一个标识创建线程的字符串。它用于在未来计划的调试功能中识别线程。</target>
        </trans-unit>
        <trans-unit id="a6d553d44ab1b8299b71777d9750b77ba466363e" translate="yes" xml:space="preserve">
          <source>A string in this module is represented by &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt;, that is, a list of codepoints, binaries with UTF-8-encoded codepoints (&lt;strong&gt;UTF-8 binaries&lt;/strong&gt;), or a mix of the two.</source>
          <target state="translated">此模块中的字符串由 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 表示，即代码点列表，带有UTF-8编码的代码点的&lt;strong&gt;二进制文件&lt;/strong&gt;（&lt;strong&gt;UTF-8二进制文件&lt;/strong&gt;）或二者的组合。</target>
        </trans-unit>
        <trans-unit id="d11f0427336c725f5ed476d29c20afbd08fe897b" translate="yes" xml:space="preserve">
          <source>A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.</source>
          <target state="translated">读取一串非空格字符。如果指定了字段宽度,则读取这个字符数,并删除所有尾部的空白字符。返回一个Erlang字符串(字符列表)。</target>
        </trans-unit>
        <trans-unit id="64783b9aab5a7910a29cafe20f9a64dc124f28e3" translate="yes" xml:space="preserve">
          <source>A string representing atom &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">表示原子 &lt;code&gt;t&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="3d7e23be6d1d7577f504730a2152e66a4301352e" translate="yes" xml:space="preserve">
          <source>A string that describes the error is obtained with the following call:</source>
          <target state="translated">通过下面的调用可以得到一个描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="6b058a7796b9b771b09e5ec69321b91ea4d6b069" translate="yes" xml:space="preserve">
          <source>A string version of &lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt;. When the query handle is evaluated, the fun created by the parse transform is interpreted by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. The query string is to be one single QLC terminated by a period.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#q-1&quot;&gt;q/1,2&lt;/a&gt;&lt;/code&gt; 的字符串版本。评估查询句柄时，由 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 解释由解析转换创建的乐趣。查询字符串将是一个以句点结尾的单个QLC。</target>
        </trans-unit>
        <trans-unit id="e691523a7275fa4ec7b2002f9ce045f810aebbb7" translate="yes" xml:space="preserve">
          <source>A string with no adjacent dots.</source>
          <target state="translated">一个没有相邻点的字符串。</target>
        </trans-unit>
        <trans-unit id="7b45ae634d5f2aacf52f18c9890284a21d2682fc" translate="yes" xml:space="preserve">
          <source>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs.</source>
          <target state="translated">一个存根模块描述符包含模块名称、导出的函数列表和模块属性列表。每个函数由它的名称(包括它的arity),以及它所调用的相应模块和函数来描述。(属性应该总是匹配的。)属性只是用键值对来描述。</target>
        </trans-unit>
        <trans-unit id="8dff76e790c867438fab881dad7f0b72bb5ec367" translate="yes" xml:space="preserve">
          <source>A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:</source>
          <target state="translated">一个不包含|字符的子模式只是包围选项的一部分,它不是一个只有一个选项的嵌套交替。(*THEN)的效果超越了这样的子模式,延伸到了包围的备选方案。考虑下面的模式,其中A、B等是复杂的模式片段,在这个层次上不包含任何|字符。</target>
        </trans-unit>
        <trans-unit id="359594612c2eb9a5932465070d74beae6a372eb0" translate="yes" xml:space="preserve">
          <source>A subpattern that is referenced by name can appear in the pattern before or after the reference.</source>
          <target state="translated">用名字引用的子模式可以在引用之前或之后出现在模式中。</target>
        </trans-unit>
        <trans-unit id="d8554111ace0a51aa20ae047b50f0d90058ec0d6" translate="yes" xml:space="preserve">
          <source>A subroutine call to a subpattern (recursive or otherwise)</source>
          <target state="translated">对子模式的子程序调用(递归或其他)。</target>
        </trans-unit>
        <trans-unit id="1e9e2570d27c2595d94b29222dcc52f4683b8c79" translate="yes" xml:space="preserve">
          <source>A subset of all semantic checks on types are implemented. For example, strictly the &lt;code&gt;TimeTicks&lt;/code&gt; may not be sub-classed but the compiler allows this (standard MIBs must pass through the compiler) (deviates from SMIv2 only).</source>
          <target state="translated">类型的所有语义检查的子集都已实现。例如，严格地讲， &lt;code&gt;TimeTicks&lt;/code&gt; 可能不会被子类化，但是编译器允许这样做（标准MIB必须通过编译器）（仅与SMIv2不同）。</target>
        </trans-unit>
        <trans-unit id="29bc759fe88a2b272d7f7e146c9840a7ce6ba6f5" translate="yes" xml:space="preserve">
          <source>A successful match of a segment of a &lt;code&gt;utf&lt;/code&gt; type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</source>
          <target state="translated">&lt;code&gt;utf&lt;/code&gt; 类型的段的成功匹配将导致范围为0..16＃D7FF或16＃E000..16＃10FFFF的整数。如果返回值超出这些范围，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="0dd5399d68fd62c8aa61dea1b9cd129c66c4e135" translate="yes" xml:space="preserve">
          <source>A suggestion, in kilowords, on how large a stack to use. A value &amp;lt; 0 means default size.</source>
          <target state="translated">以千字为单位的有关使用多大堆栈的建议。值&amp;lt;0表示默认大小。</target>
        </trans-unit>
        <trans-unit id="d2bcf77bf32e3c737f6132f4ba89272aa61deb33" translate="yes" xml:space="preserve">
          <source>A suitable &lt;code&gt;erlang_pid&lt;/code&gt; can be constructed from the &lt;code&gt;ei_cnode&lt;/code&gt; structure by the following example code:</source>
          <target state="translated">可以通过以下示例代码从 &lt;code&gt;ei_cnode&lt;/code&gt; 结构构造一个合适的 &lt;code&gt;erlang_pid&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e635ab7a6524cfed54f5074b2c5f201fa29a542e" translate="yes" xml:space="preserve">
          <source>A summary of all the run test cases.</source>
          <target state="translated">所有运行测试案例的摘要。</target>
        </trans-unit>
        <trans-unit id="490b87fb70901b3cf146b436d3ad3d6969ae85d3" translate="yes" xml:space="preserve">
          <source>A summary of allocated block sizes (including their headers) grouped by their &lt;code&gt;Origin&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">按其 &lt;code&gt;Origin&lt;/code&gt; 和 &lt;code&gt;Type&lt;/code&gt; 分组的已分配块大小（包括其标题）的摘要。</target>
        </trans-unit>
        <trans-unit id="42e4170b78b8fb9e3847e667242b4de5cec174c5" translate="yes" xml:space="preserve">
          <source>A supervisor bridge assumes the functions for starting and stopping the subsystem to be located in a callback module exporting a predefined set of functions.</source>
          <target state="translated">监理桥假设启动和停止子系统的功能位于一个回调模块中,导出一组预定义的功能。</target>
        </trans-unit>
        <trans-unit id="f8e585f469018050c24b2320c6df8c355fe43361" translate="yes" xml:space="preserve">
          <source>A supervisor can have one of the following &lt;strong&gt;restart strategies&lt;/strong&gt; specified with the &lt;code&gt;strategy&lt;/code&gt; key in the above map:</source>
          <target state="translated">主管可以在上图中使用 &lt;code&gt;strategy&lt;/code&gt; 密钥指定以下&lt;strong&gt;重启策略&lt;/strong&gt;之一：</target>
        </trans-unit>
        <trans-unit id="2b7d18f5eb25e50d03987db777d14f147e150acb" translate="yes" xml:space="preserve">
          <source>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</source>
          <target state="translated">监督者希望在导出预定义函数集的回调模块中指定要监督的子进程的定义。</target>
        </trans-unit>
        <trans-unit id="f82d3f2d9f94a9fc80489eaf4729fa8c31535cf1" translate="yes" xml:space="preserve">
          <source>A supervisor for the SNMP agent Processes</source>
          <target state="translated">一个SNMP代理的监督员处理</target>
        </trans-unit>
        <trans-unit id="07d7e065bf97522ff7b29841ee97a5f3abaaa707" translate="yes" xml:space="preserve">
          <source>A supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it is to keep its child processes alive by restarting them when necessary.</source>
          <target state="translated">监督器负责启动、停止和监控它的子进程。监督者的基本思想是在必要时通过重新启动子进程来保持其活力。</target>
        </trans-unit>
        <trans-unit id="8efae13f8c7942b2ac38b9a2a73eb196c3d0a6ff" translate="yes" xml:space="preserve">
          <source>A supervisor report is issued when a supervised child terminates unexpectedly. A supervisor report contains the following items:</source>
          <target state="translated">当受监管儿童意外终止时,会发出一份监管人报告。监护人报告包含以下内容:</target>
        </trans-unit>
        <trans-unit id="2d5726e30c2bfdd999c9a419984c8b7f106bff81" translate="yes" xml:space="preserve">
          <source>A supervisor with restart strategy &lt;code&gt;simple_one_for_one&lt;/code&gt; is a simplified &lt;code&gt;one_for_one&lt;/code&gt; supervisor, where all child processes are dynamically added instances of the same process.</source>
          <target state="translated">具有重启策略 &lt;code&gt;simple_one_for_one&lt;/code&gt; 的管理程序是简化的 &lt;code&gt;one_for_one&lt;/code&gt; 管理程序，其中所有子进程都是动态添加的同一进程的实例。</target>
        </trans-unit>
        <trans-unit id="4a17c6d57373e353ac6abb1cd3af415a947ff039" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. &lt;code&gt;Suspendee&lt;/code&gt; eventually suspends unless it is resumed before it could suspend. The caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; returns immediately, regardless of whether &lt;code&gt;Suspendee&lt;/code&gt; has suspended yet or not. The point in time when &lt;code&gt;Suspendee&lt;/code&gt; suspends cannot be deduced from other events in the system. It is only guaranteed that &lt;code&gt;Suspendee&lt;/code&gt;&lt;strong&gt;eventually&lt;/strong&gt; suspends (unless it is resumed). If no &lt;code&gt;asynchronous&lt;/code&gt; options has been passed, the caller of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; is blocked until &lt;code&gt;Suspendee&lt;/code&gt; has suspended.</source>
          <target state="translated">挂起请求被发送到被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程。除非被恢复之前被暂停，否则被 &lt;code&gt;Suspendee&lt;/code&gt; 最终将被暂停。不管 &lt;code&gt;Suspendee&lt;/code&gt; 是否已暂停， &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的调用方都会立即返回。无法从系统中的其他事件推论被 &lt;code&gt;Suspendee&lt;/code&gt; 挂起的时间点。仅保证被 &lt;code&gt;Suspendee&lt;/code&gt; &lt;strong&gt;最终会&lt;/strong&gt;暂停（除非它被恢复）。如果未传递任何 &lt;code&gt;asynchronous&lt;/code&gt; 选项，则将阻止 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; 的调用方，直到 &lt;code&gt;Suspendee&lt;/code&gt; 挂起为止。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b4e7d3e689427411ff502e735d917aa357caf7" translate="yes" xml:space="preserve">
          <source>A suspend request is sent to the process identified by &lt;code&gt;Suspendee&lt;/code&gt;. When the suspend request has been processed, a reply message is sent to the caller of this function. The reply is on the form &lt;code&gt;{ReplyTag, State}&lt;/code&gt; where &lt;code&gt;State&lt;/code&gt; is either:</source>
          <target state="translated">挂起请求被发送到被 &lt;code&gt;Suspendee&lt;/code&gt; 标识的过程。处理了挂起请求后，会向此函数的调用方发送一条回复消息。回复的格式为 &lt;code&gt;{ReplyTag, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 可以是：</target>
        </trans-unit>
        <trans-unit id="dab5b92521d5334adcd3b34a7cd584da12e53036" translate="yes" xml:space="preserve">
          <source>A syntax tree can be transformed to the &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; representation with the &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 函数将语法树转换为 &lt;code&gt;&lt;a href=&quot;#type-erl_parse&quot;&gt;erl_parse()&lt;/a&gt;&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="7fe7a01f61caca49ad408b9e314c2eab8ae04b7a" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">系统I / O向量，由Unix 上的 &lt;code&gt;writev&lt;/code&gt; 和Win32 上的 &lt;code&gt;WSASend&lt;/code&gt; 使用。在 &lt;code&gt;ErlIOVec&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="0af2eabcce5a60d4fed7164c28fadc9a20e4493d" translate="yes" xml:space="preserve">
          <source>A system I/O vector, as used by &lt;code&gt;writev&lt;/code&gt; on Unix and &lt;code&gt;WSASend&lt;/code&gt; on Win32. It is used in &lt;code&gt;ErlNifIOVec&lt;/code&gt; and by &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统I / O向量，由Unix 上的 &lt;code&gt;writev&lt;/code&gt; 和Win32 上的 &lt;code&gt;WSASend&lt;/code&gt; 使用。它在 &lt;code&gt;ErlNifIOVec&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#enif_ioq_peek&quot;&gt;enif_ioq_peek&lt;/a&gt;&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="616d063d630bdaee784166c5d2aa3d7079333cc2" translate="yes" xml:space="preserve">
          <source>A system configuration file, &lt;code&gt;sys.config&lt;/code&gt;</source>
          <target state="translated">系统配置文件 &lt;code&gt;sys.config&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a27085bf58c10c3bac131eedf2381b0839b7998" translate="yes" xml:space="preserve">
          <source>A system configuration source file, &lt;code&gt;sys.config.src&lt;/code&gt;</source>
          <target state="translated">系统配置源文件 &lt;code&gt;sys.config.src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c879d34c3ec9d9665df9efe9db8cf8d5df6abde2" translate="yes" xml:space="preserve">
          <source>A system limit has been reached. See &lt;code&gt;Efficiency Guide&lt;/code&gt; for information about system limits.</source>
          <target state="translated">已达到系统限制。有关系统限制的信息，请参见《 &lt;code&gt;Efficiency Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b8fdecfc617b9fa3706b79edfcf234ce5f241ff" translate="yes" xml:space="preserve">
          <source>A tab followed by character &quot;3&quot;</source>
          <target state="translated">字符 &quot;3 &quot;后面的标签</target>
        </trans-unit>
        <trans-unit id="7d11781c842639135820e9eada3b27c9a8d0d9ad" translate="yes" xml:space="preserve">
          <source>A table called &lt;code&gt;myTable&lt;/code&gt; has five columns. The first two are keys (not accessible), and the table has three rows. The instrumentation function for this table is called &lt;code&gt;my_table&lt;/code&gt;.</source>
          <target state="translated">名为 &lt;code&gt;myTable&lt;/code&gt; 的表有五列。前两个是键（不可访问），该表有三行。该表的检测功能称为 &lt;code&gt;my_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75534734c58db0aa05f9239f37f6428de398c20c" translate="yes" xml:space="preserve">
          <source>A table identifier, as returned by &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个表标识符，由 &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="9f0fe364ceb37c8d8dc5f9217f78c519dc139c59" translate="yes" xml:space="preserve">
          <source>A table may contain columns that are used internally, but should not be visible to a manager. These internal columns must be the last columns in the table. The &lt;code&gt;set&lt;/code&gt; operation will not work with this arrangement, because there are columns that the agent does not know about. This situation is handled by adding values for the internal columns in the &lt;code&gt;set&lt;/code&gt; function.</source>
          <target state="translated">一个表可能包含内部使用的列，但对管理者而言不可见。这些内部列必须是表中的最后一列。该 &lt;code&gt;set&lt;/code&gt; 操作不会有这种安排的工作，因为有列，代理不知道。通过在 &lt;code&gt;set&lt;/code&gt; 函数中为内部列添加值来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="3ccf87ca282ead9bb584834a165823229be63f73" translate="yes" xml:space="preserve">
          <source>A table object</source>
          <target state="translated">一个表格对象</target>
        </trans-unit>
        <trans-unit id="57b2065e432402661ed8ccb643e2901e6965c10a" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt; has either zero or one record per key, whereas a table of type &lt;code&gt;bag&lt;/code&gt; can have an arbitrary number of records per key. The key for each record is always the first attribute of the record.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;ordered_set&lt;/code&gt; 类型的表每个键具有零个或一个记录，而 &lt;code&gt;bag&lt;/code&gt; 类型的表每个键可以具有任意数量的记录。每个记录的键始终是记录的第一个属性。</target>
        </trans-unit>
        <trans-unit id="338d3dd5c9171dcfa74ab3490bd081525d78c330" translate="yes" xml:space="preserve">
          <source>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</source>
          <target state="translated">一个不需要在最后反转列表的尾递归函数比体递归函数快,完全不构造任何项的尾递归函数也是如此(例如,一个对列表中所有整数求和的函数)。</target>
        </trans-unit>
        <trans-unit id="6ed306bfabb588bedad1a38ebc28c88dc1ee79a9" translate="yes" xml:space="preserve">
          <source>A target system may have several releases but the one given as &lt;code&gt;boot_rel&lt;/code&gt; will be used as default when the system is booting up.</source>
          <target state="translated">目标系统可能有多个发行版，但在系统启动时将使用默认的 &lt;code&gt;boot_rel&lt;/code&gt; 发行版。</target>
        </trans-unit>
        <trans-unit id="92a162c972e0a2da1ef36842b8e1183dc63976d3" translate="yes" xml:space="preserve">
          <source>A term in which the state machine implementation is to store any server data it needs. The difference between this and the &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state.</source>
          <target state="translated">状态机实现用来存储所需的任何服务器数据的术语。此与 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 本身之间的区别在于，此数据的更改不会导致重试延迟的事件。因此，如果此数据中的更改将更改要处理的事件集，则该数据项将成为状态的一部分。</target>
        </trans-unit>
        <trans-unit id="f59430379cf9648470c25a50d2a2c81bb2b89218" translate="yes" xml:space="preserve">
          <source>A term, if the event handler is removed because of an error. Which term depends on the error.</source>
          <target state="translated">一个术语,如果事件处理程序因为错误而被删除。哪个术语取决于错误。</target>
        </trans-unit>
        <trans-unit id="9594dc172a1a303c23e2c7f885380aa1c05fad93" translate="yes" xml:space="preserve">
          <source>A test case can handle several connections to one or more target systems, instruments, and traffic generators in parallel to perform the necessary actions for a test. The handling of many connections in parallel is one of the major strengths of &lt;code&gt;Common Test&lt;/code&gt;, thanks to the efficient support for concurrency in the Erlang runtime system, which &lt;code&gt;Common Test&lt;/code&gt; users can take great advantage of.</source>
          <target state="translated">一个测试用例可以并行处理到一个或多个目标系统，仪器和流量生成器的多个连接，以执行测试所需的动作。并行处理多个连接是 &lt;code&gt;Common Test&lt;/code&gt; 的主要优势之一，这要归功于Erlang运行时系统中对并发的有效支持， &lt;code&gt;Common Test&lt;/code&gt; 用户可以充分利用它。</target>
        </trans-unit>
        <trans-unit id="3f0276c5d34cae70dd7c0725d3127cfdb7e17a06" translate="yes" xml:space="preserve">
          <source>A test case failure is specified as a runtime error (a crash), no matter what the reason for termination is. If you use Erlang pattern matching effectively, you can take advantage of this property. The result is concise and readable test case functions that look much more like scripts than actual programs. A simple example:</source>
          <target state="translated">测试用例失败被指定为运行时错误(崩溃),无论终止的原因是什么。如果你有效地使用Erlang模式匹配,你可以利用这个属性。其结果是简洁和可读的测试用例函数,看起来更像脚本而不是实际的程序。一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="57803d84844b81148f638909cfbdf834fb63a201" translate="yes" xml:space="preserve">
          <source>A test case group can be repeated a certain number of times (specified by an integer) or indefinitely (specified by &lt;code&gt;forever&lt;/code&gt;). The repetition can also be stopped too early if any or all cases fail or succeed, that is, if any of the properties &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, &lt;code&gt;repeat_until_any_ok&lt;/code&gt;, &lt;code&gt;repeat_until_all_fail&lt;/code&gt;, or &lt;code&gt;repeat_until_all_ok&lt;/code&gt; is used. If the basic &lt;code&gt;repeat&lt;/code&gt; property is used, status of test cases is irrelevant for the repeat operation.</source>
          <target state="translated">一个测试用例组可以重复一定次数（由整数指定）或无限次（由 &lt;code&gt;forever&lt;/code&gt; 指定）。如果任何或所有情况失败或成功，也就是使用任何属性 &lt;code&gt;repeat_until_any_fail&lt;/code&gt; ， &lt;code&gt;repeat_until_any_ok&lt;/code&gt; ， &lt;code&gt;repeat_until_all_fail&lt;/code&gt; 或 &lt;code&gt;repeat_until_all_ok&lt;/code&gt; ，也可以过早停止重复。如果使用基本的 &lt;code&gt;repeat&lt;/code&gt; 属性，则测试用例的状态与重复操作无关。</target>
        </trans-unit>
        <trans-unit id="70f3b406878b1ad27d06f47209f488fb0090bedb" translate="yes" xml:space="preserve">
          <source>A test case group is a set of test cases sharing configuration functions and execution properties. Test case groups are defined by function &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; according to the following syntax:</source>
          <target state="translated">测试用例组是一组共享配置功能和执行属性的测试用例。测试用例组由功能 &lt;code&gt;&lt;a href=&quot;common_test#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 根据以下语法定义：</target>
        </trans-unit>
        <trans-unit id="e797bd2be17f58c7efe8dfeff204b02c5adaa5d5" translate="yes" xml:space="preserve">
          <source>A test case is considered successful if it returns to the caller, no matter what the returned value is. However, a few return values have special meaning as follows:</source>
          <target state="translated">如果一个测试用例返回给调用者,无论返回值是什么,都被认为是成功的。但是,有几个返回值具有以下特殊意义:</target>
        </trans-unit>
        <trans-unit id="dcc50de966066784aa8d897c8ffe49a70bbe3620" translate="yes" xml:space="preserve">
          <source>A test is performed by running one or more test suites. A test suite consists of test cases, configuration functions, and information functions. Test cases can be grouped in so called test case groups. A test suite is an Erlang module and test cases are implemented as Erlang functions. Test suites are stored in test directories.</source>
          <target state="translated">测试是通过运行一个或多个测试套件来进行的。一个测试套件由测试用例、配置功能和信息功能组成。测试用例可以分成所谓的测试用例组。一个测试套件是一个Erlang模块,测试用例以Erlang函数的形式实现。测试套件存储在测试目录中。</target>
        </trans-unit>
        <trans-unit id="82b0d4348a040296baa971a336f70137d0143756" translate="yes" xml:space="preserve">
          <source>A test set can be easily created by placing a sequence of test objects in a list. If &lt;code&gt;T_1&lt;/code&gt;, ..., &lt;code&gt;T_N&lt;/code&gt; are individual test objects, then &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; is a test set consisting of those objects (in that order).</source>
          <target state="translated">通过将一系列测试对象放在列表中，可以轻松创建测试集。如果 &lt;code&gt;T_1&lt;/code&gt; ，...， &lt;code&gt;T_N&lt;/code&gt; 是单独的测试对象，则 &lt;code&gt;[T_1, ..., T_N]&lt;/code&gt; 是由这些对象组成（按该顺序）的测试集。</target>
        </trans-unit>
        <trans-unit id="850a2b153e54fe3302effc5897fd48daf6d71d85" translate="yes" xml:space="preserve">
          <source>A test suite is an ordinary Erlang module that contains test cases. It is recommended that the module has a name on the form &lt;code&gt;*_SUITE.erl&lt;/code&gt;. Otherwise, the directory and auto compilation function in &lt;code&gt;Common Test&lt;/code&gt; cannot locate it (at least not by default).</source>
          <target state="translated">测试套件是包含测试用例的普通Erlang模块。建议模块使用 &lt;code&gt;*_SUITE.erl&lt;/code&gt; 形式的名称。否则， &lt;code&gt;Common Test&lt;/code&gt; 中的目录和自动编译功能将无法找到它（至少默认情况下不会）。</target>
        </trans-unit>
        <trans-unit id="c6a46a09bfa35f6d6a3e0deef8196b3ea6cd2281" translate="yes" xml:space="preserve">
          <source>A test term can also specify one or more test suites, groups, or test cases to be skipped. Skipped suites, groups, and cases are not executed and show up in the HTML log files as &lt;code&gt;SKIPPED&lt;/code&gt;.</source>
          <target state="translated">一个测试术语还可以指定一个或多个要跳过的测试套件，组或测试用例。跳过的套件，组和案例不会执行，并以 &lt;code&gt;SKIPPED&lt;/code&gt; 的形式显示在HTML日志文件中。</target>
        </trans-unit>
        <trans-unit id="fc9a7da069ee22047038749756cf97523761175f" translate="yes" xml:space="preserve">
          <source>A textual comment describing the service. Not mandatory, but shows up as the service description in the Windows service manager.</source>
          <target state="translated">描述服务的文本注释。不是必须的,但会在Windows服务管理器中显示为服务描述。</target>
        </trans-unit>
        <trans-unit id="1b69647db9e6ba8a0e002c236579c1374755b41d" translate="yes" xml:space="preserve">
          <source>A the time of writing this, the latest released version of SystemTap is version 1.6. Erlang's DTrace support requires a MACRO that was introduced after that release. So either get a newer release or build SystemTap from git yourself (see: http://sourceware.org/systemtap/getinvolved.html)</source>
          <target state="translated">在写这篇文章的时候,SystemTap最新发布的版本是1.6版本。Erlang的DTrace支持需要一个MACRO,而这个MACRO是在这个版本之后引入的,所以要么得到一个新的版本,要么自己从git上构建SystemTap(见:)。所以,要么得到一个更新的版本,要么自己从git中构建SystemTap(见:http://sourceware.org/systemtap/getinvolved.html)。</target>
        </trans-unit>
        <trans-unit id="9b18f6bb3b01d76a4dfa566d98c87a28d7f6b44e" translate="yes" xml:space="preserve">
          <source>A third alternative is to download and install MSYS2 from:</source>
          <target state="translated">第三种选择是从以下地方下载并安装MSYS2:</target>
        </trans-unit>
        <trans-unit id="f9c4754ee9c691b3be255533c56967a9f65767a3" translate="yes" xml:space="preserve">
          <source>A third usage is to block login attempts from a missbehaving peer. The &lt;code&gt;State&lt;/code&gt; described above can be used for this. The return value &lt;code&gt;disconnect&lt;/code&gt; is useful for this.</source>
          <target state="translated">第三种用法是阻止来自行为不端的对等方的登录尝试。的 &lt;code&gt;State&lt;/code&gt; 可以将上述用于此目的。返回值 &lt;code&gt;disconnect&lt;/code&gt; 对此很有用。</target>
        </trans-unit>
        <trans-unit id="dd9a2152eb9572e05f0a61d8511698051e7c78f8" translate="yes" xml:space="preserve">
          <source>A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If &lt;code&gt;exit_value == NULL&lt;/code&gt;, the exit value of the terminated thread is ignored, otherwise the exit value of the terminated thread is stored at &lt;code&gt;*exit_value&lt;/code&gt;.</source>
          <target state="translated">一个线程只能连接一次。多次连接的行为是不确定的，有可能导致模拟器崩溃。如果 &lt;code&gt;exit_value == NULL&lt;/code&gt; ，则忽略终止线程的退出值，否则终止线程的退出值存储在 &lt;code&gt;*exit_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="713f4e1d5b50f7df039ee9fe6e1996e2572d7a3a" translate="yes" xml:space="preserve">
          <source>A thread identifier can be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; does possibly not give the expected result.</source>
          <target state="translated">线程终止后，可以非常快地重用线程标识符。因此，如果自保存线程标识符以来对应于所涉及线程标识符之一的线程已终止，则 &lt;code&gt;erl_drv_equal_tids&lt;/code&gt; 的结果可能不会给出预期的结果。</target>
        </trans-unit>
        <trans-unit id="cad763d5e07983c99c13f14998b109764ecd9488" translate="yes" xml:space="preserve">
          <source>A time stamp as returned by the BIF &lt;code&gt;now()&lt;/code&gt;.</source>
          <target state="translated">BIF &lt;code&gt;now()&lt;/code&gt; 返回的时间戳。</target>
        </trans-unit>
        <trans-unit id="09f8c7e2d1b4631a8a0fd8e3a936590e5cfc3d7c" translate="yes" xml:space="preserve">
          <source>A time warp is a leap forwards or backwards in time. That is, the difference of time values taken before and after the time warp does not correspond to the actual elapsed time.</source>
          <target state="translated">时空扭曲是指时间的向前或向后跳跃。也就是说,时间扭曲前后的时间值之差与实际经过的时间不一致。</target>
        </trans-unit>
        <trans-unit id="cd86c3e0b5292795cee07d9ad33f244af7a25314" translate="yes" xml:space="preserve">
          <source>A time-out feature inherited from &lt;code&gt;gen_statem&lt;/code&gt;'s predecessor &lt;code&gt;gen_fsm&lt;/code&gt;, is an event time-out, that is, if an event arrives the timer is cancelled. You get either an event or a time-out, but not both.</source>
          <target state="translated">从 &lt;code&gt;gen_statem&lt;/code&gt; 的前身 &lt;code&gt;gen_fsm&lt;/code&gt; 继承的超时功能是事件超时，即，如果事件到达，计时器将被取消。您会得到一个事件或一个超时，但不会同时发生。</target>
        </trans-unit>
        <trans-unit id="e4e7c858b3f4a06a0ae20e24345812eb57867da0" translate="yes" xml:space="preserve">
          <source>A time-out value of &lt;code&gt;0&lt;/code&gt; (zero) means that time-outs are disabled. Calling a &lt;code&gt;_tmo&lt;/code&gt; function with the last argument as &lt;code&gt;0&lt;/code&gt; is therefore the same thing as calling the function without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">超时值为 &lt;code&gt;0&lt;/code&gt; （零）表示禁用了超时。因此，调用最后一个参数为 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;_tmo&lt;/code&gt; 函数与调用不带 &lt;code&gt;_tmo&lt;/code&gt; 后缀的函数是一样的事情。</target>
        </trans-unit>
        <trans-unit id="e51396500c23760a237e8c8ce1759124abbdb2b6" translate="yes" xml:space="preserve">
          <source>A timeout, in seconds, for how long the &lt;code&gt;memsup&lt;/code&gt; process should wait for a result from a memory check. If the timeout expires, a warning message &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; is issued via &lt;code&gt;error_logger&lt;/code&gt; and any pending, synchronous client calls will return a dummy value. Normally, this situation should not occur. There have been cases on Linux, however, where the pseudo file from which system data is read is temporarily unavailable when the system is heavily loaded.</source>
          <target state="translated">超时（以秒为单位），表示 &lt;code&gt;memsup&lt;/code&gt; 进程应等待内存检查结果的时间。如果超时到期， &lt;code&gt;&quot;OS_MON (memsup) timeout&quot;&lt;/code&gt; 通过 &lt;code&gt;error_logger&lt;/code&gt; 发出警告消息&amp;ldquo; OS_MON（memsup）超时&amp;rdquo;，并且任何未决的同步客户端调用都将返回虚拟值。通常，这种情况不应发生。但是，在Linux上有一些情况，当系统负载很重时，从中读取系统数据的伪文件暂时不可用。</target>
        </trans-unit>
        <trans-unit id="68ff3c996ac6d98f27aaaac3ca2c11d67e8039ea" translate="yes" xml:space="preserve">
          <source>A timer can always be removed by calling &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">始终可以通过调用 &lt;code&gt;&lt;a href=&quot;#cancel-1&quot;&gt;cancel/1&lt;/a&gt;&lt;/code&gt; 来删除计时器。</target>
        </trans-unit>
        <trans-unit id="726a053f638d7072079d375380c92439b2bbdb5e" translate="yes" xml:space="preserve">
          <source>A timer reference.</source>
          <target state="translated">一个定时器参考。</target>
        </trans-unit>
        <trans-unit id="94ea6da4ccb85a54c3d9ad09e70c59b90ddafcec" translate="yes" xml:space="preserve">
          <source>A timestamp produced with &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;erlang:system_time(microsecond)&lt;/code&gt; 产生的时间戳。</target>
        </trans-unit>
        <trans-unit id="224b47a99ccb8f9ad2636eb28064f8326a8f1842" translate="yes" xml:space="preserve">
          <source>A timetrap can also be set or reset dynamically during the execution of a test case, or configuration function. This is done by calling &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt;. This function cancels the current timetrap and starts a new one (that stays active until time-out, or end of the current function).</source>
          <target state="translated">也可以在执行测试用例或配置功能期间动态设置或重置时间陷阱。这是通过调用 &lt;code&gt;&lt;a href=&quot;ct#timetrap-1&quot;&gt;ct:timetrap/1&lt;/a&gt;&lt;/code&gt; 来完成的。此功能取消当前的时间陷阱并开始一个新的时间陷阱（直到超时或当前功能结束，该时间陷阱一直处于活动状态）。</target>
        </trans-unit>
        <trans-unit id="8f213ae236a5f4c3df724a5656b6f24789d1f1a8" translate="yes" xml:space="preserve">
          <source>A tool for applying XSLT stylesheets to XML documents. Download xsltproc from &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种将XSLT样式表应用于XML文档的工具。从 &lt;code&gt;&lt;a href=&quot;http://xmlsoft.org/XSLT/xsltproc2.html&quot;&gt;http://xmlsoft.org/XSLT/xsltproc2.html&lt;/a&gt;&lt;/code&gt; 下载xsltproc 。</target>
        </trans-unit>
        <trans-unit id="08f1e7c2bddf5c69b2f61fa1070545348579586c" translate="yes" xml:space="preserve">
          <source>A trace port is an Erlang port to a dynamically linked in driver that handles trace messages directly, without the overhead of sending them as messages in the Erlang virtual machine.</source>
          <target state="translated">跟踪端口是指向动态链接的驱动程序的Erlang端口,它可以直接处理跟踪消息,而不需要在Erlang虚拟机中作为消息发送。</target>
        </trans-unit>
        <trans-unit id="12ee06a6ceec6852b8fcedb1fbb55e6e9c5f6756" translate="yes" xml:space="preserve">
          <source>A trace server started in this way will simply display the trace messages in a formatted way in the Erlang shell (i. e. use io:format). See &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; for a description of how the trace message handler can be customized.</source>
          <target state="translated">以这种方式启动的跟踪服务器将仅以格式化的方式在Erlang Shell中显示跟踪消息（即，使用io：format）。有关如何自定义跟踪消息处理程序的描述，请参见 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c312d23149bf55415c7facde91760776534bda23" translate="yes" xml:space="preserve">
          <source>A trace token contains a label and a set of flags. Both the label and the flags are set in both alternatives above.</source>
          <target state="translated">一个跟踪标记包含一个标签和一组标志。标签和标志都是在上述两种选择中设置的。</target>
        </trans-unit>
        <trans-unit id="a0a3ada2bd3e540543826094f00fde5f11b86200" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will consist of &lt;code&gt;Erlang monotonic time&lt;/code&gt; and a monotonically increasing integer. The time-stamp has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用将为每个跟踪事件生成严格的单调时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。时间戳将由 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 和单调递增的整数组成。时间戳与 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="60097663814cb4e095c2a6a722349f6b5a5bf437" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a strict monotonic timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;. Timestamps will use &lt;code&gt;Erlang monotonic time&lt;/code&gt;. The time-stamp has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用将为每个跟踪事件生成严格的单调时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。时间戳将使用 &lt;code&gt;Erlang monotonic time&lt;/code&gt; 。时间戳与 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 产生的格式和值相同。</target>
        </trans-unit>
        <trans-unit id="82d8ecb25fb90aa7ddd424dd220b83a7b34ebd81" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables a timestamp to be generated for each traced event. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），用于启用/禁用为每个跟踪事件生成的时间戳。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e634022f908badf152e1987898bd0b2c230015" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on explicit calls to &lt;code&gt;seq_trace:print/1&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），用于启用/禁用对 &lt;code&gt;seq_trace:print/1&lt;/code&gt; 的显式调用的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bde9aedc5e9c949b0aa2b17f37ee8c40d03b21b6" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message reception. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用邮件接收时的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9c367670f41b59db0e6ecd2630bb172d3da0c69" translate="yes" xml:space="preserve">
          <source>A trace token flag (&lt;code&gt;true | false&lt;/code&gt;) which enables/disables tracing on message sending. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">跟踪令牌标志（ &lt;code&gt;true | false&lt;/code&gt; ），启用/禁用对邮件发送的跟踪。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fef110e2f0ab9e0376d172bcb7bfe8b65a404cd6" translate="yes" xml:space="preserve">
          <source>A transaction system makes it possible to execute two or more processes concurrently that manipulate the same record. The programmer does not need to check that the updates are synchronous; this is overseen by the transaction handler. All programs accessing the database through the transaction system can be written as if they had sole access to the data.</source>
          <target state="translated">一个事务系统可以同时执行两个或更多的进程来操作同一记录。程序员不需要检查更新是否同步;这是由事务处理程序监督的。所有通过事务系统访问数据库的程序都可以被编写成好像它们有对数据的唯一访问权一样。</target>
        </trans-unit>
        <trans-unit id="040494e8706d570977340364653c32d0f74758d8" translate="yes" xml:space="preserve">
          <source>A transport can both override its service's capabilities and restrict its supported Diameter applications so &quot;service = Diameter node as identified by Origin-Host&quot; is not necessarily the case.</source>
          <target state="translated">传输既可以覆盖其服务的能力,也可以限制其支持的Diameter应用,所以 &quot;服务=Origin-Host识别的Diameter节点 &quot;不一定是这样。</target>
        </trans-unit>
        <trans-unit id="023338b0c93aa9ea43a308354e8c6cb312d2e262" translate="yes" xml:space="preserve">
          <source>A transport process can expect messages of the following types from its parent.</source>
          <target state="translated">传输过程可以从其父体那里得到以下类型的消息:</target>
        </trans-unit>
        <trans-unit id="c02ea719b68545a61ef8005dfcb9fa67f5f85090" translate="yes" xml:space="preserve">
          <source>A transport process must implement the message interface documented below. It should retain the pid of its parent, monitor the parent and terminate if it dies. It should not link to the parent. It should exit if its transport connection with its peer is lost.</source>
          <target state="translated">传输过程必须实现下文所述的消息接口。它应该保留其父体的pid,监控父体,并在父体死亡时终止。它不应该连接到父进程。如果它与对等体的传输连接丢失,它应该退出。</target>
        </trans-unit>
        <trans-unit id="22cab074839dd6633c044492cf9e00d79ad7b9b9" translate="yes" xml:space="preserve">
          <source>A transport process should send messages of the following types to its parent.</source>
          <target state="translated">传输过程应向其父体发送下列类型的消息:</target>
        </trans-unit>
        <trans-unit id="90161712010dfd82bbaf6035b7ca236a047b2d07" translate="yes" xml:space="preserve">
          <source>A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is to continue as active (&lt;strong&gt;enable&lt;/strong&gt;), or to become inactive (&lt;strong&gt;disable&lt;/strong&gt;), or to be removed (&lt;strong&gt;delete&lt;/strong&gt;).</source>
          <target state="translated">触发动作。到达断点时，触发动作指定该断点是继续为活动状态（&lt;strong&gt;enable&lt;/strong&gt;），还是变为不活动状态（&lt;strong&gt;disable&lt;/strong&gt;），或将其删除（&lt;strong&gt;delete&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="f841f79d498699c727c107e3b0ca4c79fda4714f" translate="yes" xml:space="preserve">
          <source>A true embedded system must start when the system boots. This section accounts for the necessary configurations needed to achieve that.</source>
          <target state="translated">一个真正的嵌入式系统必须在系统启动时启动。本节介绍了实现这一目标所需的必要配置。</target>
        </trans-unit>
        <trans-unit id="1e80ac87b4ba604d5c15b3ca4c06f00704683ae7" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt;. The &lt;code&gt;HashAlgoSpec&lt;/code&gt; specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the &lt;code&gt;accept_callback()&lt;/code&gt;. The &lt;code&gt;HashALgoSpec&lt;/code&gt; is either an atom or a list of atoms as the first argument in &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt;. If it is a list of hash algorithm names, the &lt;code&gt;FingerPrint&lt;/code&gt; argument in the &lt;code&gt;accept_callback()&lt;/code&gt; will be a list of fingerprints in the same order as the corresponding name in the &lt;code&gt;HashAlgoSpec&lt;/code&gt; list.</source>
          <target state="translated">元组 &lt;code&gt;{HashAlgoSpec, accept_callback}&lt;/code&gt; 。所述 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 指定哪些散列算法应被用于计算所述指纹在的呼叫中使用 &lt;code&gt;accept_callback()&lt;/code&gt; 。所述 &lt;code&gt;HashALgoSpec&lt;/code&gt; 或者是一个原子或原子作为第一个参数的列表 &lt;code&gt;public_key:ssh_hostkey_fingerprint/2&lt;/code&gt; 。如果是散列算法名称列表，该 &lt;code&gt;FingerPrint&lt;/code&gt; 在参数 &lt;code&gt;accept_callback()&lt;/code&gt; 将在相同的顺序，在对应的名字指纹列表 &lt;code&gt;HashAlgoSpec&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="cf7e5e9de3bf6f4c7060bdc6cec37d2c3b2e6d0c" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Major,Minor}&lt;/code&gt; containing the major and minor version of the file format for ETS table dumps. This version field was added beginning with STDLIB 1.5.1. Files dumped with older versions return &lt;code&gt;{0,0}&lt;/code&gt; in this field.</source>
          <target state="translated">元组 &lt;code&gt;{Major,Minor}&lt;/code&gt; ,包含ETS表转储文件格式的主要版本和次要版本。此版本字段是从STDLIB 1.5.1开始添加的。使用旧版本转储的文件在此字段中返回 &lt;code&gt;{0,0}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07bab1189c6299dfc8d87b9698a9d20069024cab" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; for function calls</source>
          <target state="translated">函数调用的元组 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c425ef8b5c09edd293415683557a467b94cc4b" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{registered_name,node_name}&lt;/code&gt; is used instead of just the &lt;code&gt;registered_name&lt;/code&gt;.</source>
          <target state="translated">使用元组 &lt;code&gt;{registered_name,node_name}&lt;/code&gt; 而不是仅使用 &lt;code&gt;registered_name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f3f0f1a112bc371fc9fac3b642164488b8dd6fb" translate="yes" xml:space="preserve">
          <source>A tuple &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt;, where &lt;code&gt;ModuleName&lt;/code&gt; and &lt;code&gt;FunctionName&lt;/code&gt; are atoms, referring to the function &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</source>
          <target state="translated">元组 &lt;code&gt;{test, ModuleName, FunctionName}&lt;/code&gt; ，其中 &lt;code&gt;ModuleName&lt;/code&gt; 和 &lt;code&gt;FunctionName&lt;/code&gt; 是原子，引用函数 &lt;code&gt;ModuleName:FunctionName/0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7faaaea4addaa524ef387ae744a4927d4b84f230" translate="yes" xml:space="preserve">
          <source>A tuple is a compound data type with a fixed number of terms:</source>
          <target state="translated">元组是一种具有固定数量项的复合数据类型。</target>
        </trans-unit>
        <trans-unit id="df982bb074bb2bcc07a3f3574312720f45bcca1f" translate="yes" xml:space="preserve">
          <source>A tuple must be specified with the number of elements. (The elements precede the &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; term.)</source>
          <target state="translated">必须使用元素数指定一个元组。（这些元素在 &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; 术语之前。）</target>
        </trans-unit>
        <trans-unit id="d813ebdb5f103f06a944c56ba2c1950a8ea79499" translate="yes" xml:space="preserve">
          <source>A tuple of a size equal to &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; is returned. The tuple elements are integers or the atom &lt;code&gt;unbound&lt;/code&gt;. Logical processor identifiers are represented as integers. The &lt;code&gt;N&lt;/code&gt;th element of the tuple equals the current binding for the scheduler with the scheduler identifier equal to &lt;code&gt;N&lt;/code&gt;. For example, if the schedulers are bound, &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; returns the identifier of the logical processor that the calling process is executing on.</source>
          <target state="translated">返回大小等于 &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; 的元组。元组元素是整数或原子 &lt;code&gt;unbound&lt;/code&gt; 。逻辑处理器标识符以整数表示。所述 &lt;code&gt;N&lt;/code&gt; 元组的第i个元素等于当前用于与标识符等于调度器调度器结合 &lt;code&gt;N&lt;/code&gt; 。例如，如果绑定了调度程序，则 &lt;code&gt;element(erlang:system_info(scheduler_id), erlang:system_info(scheduler_bindings))&lt;/code&gt; 返回在其上执行调用过程的逻辑处理器的标识符。</target>
        </trans-unit>
        <trans-unit id="810d5b526b8906970f984c1b3db62a6c47f80147" translate="yes" xml:space="preserve">
          <source>A tuple of size three containing: the segment number, the &lt;code&gt;last segment indicator&lt;/code&gt; and finally a list of 'ActionReply' records possibly containing error indications. This is of course only possible if the reply was segmented.</source>
          <target state="translated">大小为三的元组，包含：段号， &lt;code&gt;last segment indicator&lt;/code&gt; 以及最后一个&amp;ldquo; ActionReply&amp;rdquo;记录列表，可能包含错误指示。当然，这仅在答复被分段的情况下才可能。</target>
        </trans-unit>
        <trans-unit id="3dd7bc1a3405fbef606b572d8949507a33cc4df9" translate="yes" xml:space="preserve">
          <source>A tuple of the bindings and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching further objects by calling &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则将返回绑定的元组和延续，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 匹配其他对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="6c722068339f5605671934079ecb1e3f17e82123" translate="yes" xml:space="preserve">
          <source>A tuple of the results of applying the match specification and a continuation is returned, unless the table is empty, in which case &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. The continuation is to be used when matching more objects by calling &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非表为空，否则将返回应用匹配规范和延续的结果的元组，在这种情况下，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。通过调用 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 匹配更多对象时，将使用延续。</target>
        </trans-unit>
        <trans-unit id="24035af62a2fdeb2d8901fd0ee530961ccde951f" translate="yes" xml:space="preserve">
          <source>A tuple passed using the external format of Erlang.</source>
          <target state="translated">使用Erlang的外部格式传递的元组。</target>
        </trans-unit>
        <trans-unit id="8690cf67b400404bcc0f4ff1dceb7bb83944c22f" translate="yes" xml:space="preserve">
          <source>A tuple where the elements are of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">一个元素为 &lt;code&gt;T&lt;/code&gt; 类型的元组。</target>
        </trans-unit>
        <trans-unit id="b4c3a805c0c5a81f38e677fa3cd9def6b983c21d" translate="yes" xml:space="preserve">
          <source>A tuple with the string and the options for compilation</source>
          <target state="translated">一个包含字符串和编译选项的元组。</target>
        </trans-unit>
        <trans-unit id="151bd15a2cb84f42df927246cfbe8c0dd7313819" translate="yes" xml:space="preserve">
          <source>A type specifier list TSL for a bitstring element is a sequence of type specifiers &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt;, and Rep(TSL) = &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt;.</source>
          <target state="translated">位串元素的类型说明符列表TSL是类型说明符 &lt;code&gt;TS_1 - ... - TS_k&lt;/code&gt; ，并且Rep（TSL）= &lt;code&gt;[Rep(TS_1), ..., Rep(TS_k)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08976fc5cbfe03343391c63ca50f5f50c10b8d0b" translate="yes" xml:space="preserve">
          <source>A typical (compress) usage is as follows:</source>
          <target state="translated">典型的(压缩)用法如下。</target>
        </trans-unit>
        <trans-unit id="126a0170061e6a79a71ccf9406ef6f3af55349d4" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;.erlang&lt;/code&gt; file contains a set of search paths, for example:</source>
          <target state="translated">典型的 &lt;code&gt;.erlang&lt;/code&gt; 文件包含一组搜索路径，例如：</target>
        </trans-unit>
        <trans-unit id="72082aa56cd4d1e59057d7f28996bf925833376c" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;Common Test&lt;/code&gt; test suite using &lt;code&gt;ct_property_test&lt;/code&gt; is organized as follows:</source>
          <target state="translated">使用 &lt;code&gt;ct_property_test&lt;/code&gt; 的典型 &lt;code&gt;Common Test&lt;/code&gt; 测试套件的组织方式如下：</target>
        </trans-unit>
        <trans-unit id="6ef96d247bf0039ba1ccb9fddcabd0176ac0a0c3" translate="yes" xml:space="preserve">
          <source>A typical error reason is:</source>
          <target state="translated">一个典型的错误原因是:</target>
        </trans-unit>
        <trans-unit id="05d8d9f5d6888b35439d18b6e544520b23957a25" translate="yes" xml:space="preserve">
          <source>A typical error reason:</source>
          <target state="translated">一个典型的错误原因。</target>
        </trans-unit>
        <trans-unit id="9061494e205704eb0cdfcf7a4c046c23d96666b9" translate="yes" xml:space="preserve">
          <source>A typical implementation on Unix is to do &lt;code&gt;close((int)event)&lt;/code&gt;.</source>
          <target state="translated">在Unix上，典型的实现是执行 &lt;code&gt;close((int)event)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="541396ef46ffec4bf5fa435c55b2863004f29300" translate="yes" xml:space="preserve">
          <source>A typical operation could include the following steps:</source>
          <target state="translated">一个典型的操作可以包括以下步骤:</target>
        </trans-unit>
        <trans-unit id="50f89c2180f830349252137c0faf845e512001e7" translate="yes" xml:space="preserve">
          <source>A typical overload situation occurs when the applications perform more updates on disc resident tables than &lt;code&gt;Mnesia&lt;/code&gt; can handle. Ignoring this kind of overload can lead to a situation where the disc space is exhausted (regardless of the size of the tables stored on disc).</source>
          <target state="translated">当应用程序在磁盘驻留表上执行的更新数量超过 &lt;code&gt;Mnesia&lt;/code&gt; 所能处理的数量时，就会发生典型的过载情况。忽略这种过载可能导致磁盘空间用尽的情况（无论存储在磁盘上的表的大小如何）。</target>
        </trans-unit>
        <trans-unit id="acb703e9dec014081d4b1835cb51aaeb3d0b76b2" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to replace unbounded-size control sequences like &lt;code&gt;~w&lt;/code&gt; and &lt;code&gt;~p&lt;/code&gt; with the depth-limited variants &lt;code&gt;~W&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; before formatting to text in, for example, a logger.</source>
          <target state="translated">一个典型的使用这个功能是替代无界尺寸控制序列等 &lt;code&gt;~w&lt;/code&gt; 和 &lt;code&gt;~p&lt;/code&gt; 与深度限定变体 &lt;code&gt;~W&lt;/code&gt; 和 &lt;code&gt;~P&lt;/code&gt; 格式化到文本中，例如，记录器之前。</target>
        </trans-unit>
        <trans-unit id="3807873b97b8b82278afb2ef76e8ea8f9bb29594" translate="yes" xml:space="preserve">
          <source>A unique identifier for a filter.</source>
          <target state="translated">过滤器的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="aeb6160c71f6b3c49b7dc45e065a90d43611f9a7" translate="yes" xml:space="preserve">
          <source>A unique identifier for a handler instance.</source>
          <target state="translated">处理器实例的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="35c6d039fac0be1661199d1ae0d64a6d99224787" translate="yes" xml:space="preserve">
          <source>A useful dispatch function that can be used from client functions. It returns a process on the local node, if such a process exists. Otherwise, it selects one randomly.</source>
          <target state="translated">一个有用的调度函数,可以从客户端函数中使用。如果本地节点上存在一个进程,它就返回这样一个进程。否则,它会随机选择一个进程。</target>
        </trans-unit>
        <trans-unit id="f5bfc38acae2f40bfaee12c264aaf4416d8847f9" translate="yes" xml:space="preserve">
          <source>A useful number.</source>
          <target state="translated">一个有用的数字。</target>
        </trans-unit>
        <trans-unit id="5f280d2fcfe90c0ab1a22509cb3602587fb270ec" translate="yes" xml:space="preserve">
          <source>A useful way of looking at parts of lists, is by using &quot;|&quot;. This is best explained by an example using the shell:</source>
          <target state="translated">查看列表部分的一个有用的方法是使用&quot;|&quot;。最好的解释是使用shell的一个例子。</target>
        </trans-unit>
        <trans-unit id="14fd4e6872c372a6c8cb217dbc2352699bd53754" translate="yes" xml:space="preserve">
          <source>A user defined identity representing this notification send operation.</source>
          <target state="translated">一个用户定义的身份,代表这个通知发送操作。</target>
        </trans-unit>
        <trans-unit id="2a353ec2b424bd07df4385f13b10e3ea7d64ca54" translate="yes" xml:space="preserve">
          <source>A user is being blocked from access.</source>
          <target state="translated">有用户被阻止访问。</target>
        </trans-unit>
        <trans-unit id="0c5079fbb762cb2270895845abfb45816e3f4e3e" translate="yes" xml:space="preserve">
          <source>A user is being removed from the block list.</source>
          <target state="translated">一个用户正在被从阻止列表中删除。</target>
        </trans-unit>
        <trans-unit id="101ba63129c1dab0968eb1083541b31cda478b02" translate="yes" xml:space="preserve">
          <source>A user is identified by its UserMid, which must be a legal Megaco MID.</source>
          <target state="translated">一个用户是由它的UserMid识别的,它必须是一个合法的Megaco MID。</target>
        </trans-unit>
        <trans-unit id="fd3a9f3997e885cf7dcc7677ac20d4c9631d90cc" translate="yes" xml:space="preserve">
          <source>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</source>
          <target state="translated">一个用户可以根据Erlang/OTP的应用概念在.config文件中静态配置,也可以通过megaco:start_user/2的参数动态启动,这些配置设置可以在以后通过megaco:update_conn_info/2更新。</target>
        </trans-unit>
        <trans-unit id="1504430f3d4afc3f6c812eb47a15e10f01419f56" translate="yes" xml:space="preserve">
          <source>A user may have a number of &quot;virtual&quot; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</source>
          <target state="translated">一个用户可以与其他用户建立若干 &quot;虚拟 &quot;连接。一个MG最多连接到一个MGC,而一个MGC可以连接到任何数量的MG。对于每个连接,用户选择一个传输服务、一个编码方案和一个用户回调模块。</target>
        </trans-unit>
        <trans-unit id="e67f458b7905dc65a23e9c34758bfcdd553eff54" translate="yes" xml:space="preserve">
          <source>A user process can subscribe on the events generated by &lt;code&gt;Mnesia&lt;/code&gt;. The following two functions are provided:</source>
          <target state="translated">用户进程可以订阅 &lt;code&gt;Mnesia&lt;/code&gt; 生成的事件。提供以下两个功能：</target>
        </trans-unit>
        <trans-unit id="a930c1684ddd9a6efd75c38df17f190cbc0c2e7d" translate="yes" xml:space="preserve">
          <source>A user variable is employed for holding the &lt;code&gt;digraph&lt;/code&gt; representation of the function graph for use in many queries. The reason is efficiency. As opposed to the &lt;code&gt;=&lt;/code&gt; operator, the &lt;code&gt;:=&lt;/code&gt; operator saves a value for subsequent analyses. Here might be the place to note that equal subexpressions within a query are evaluated only once; &lt;code&gt;=&lt;/code&gt; cannot be used for speeding things up.</source>
          <target state="translated">用户变量用于保存功能图的 &lt;code&gt;digraph&lt;/code&gt; 表示，以用于许多查询。原因是效率。与 &lt;code&gt;=&lt;/code&gt; 运算符相反， &lt;code&gt;:=&lt;/code&gt; 运算符会保存一个值以用于后续分析。在这里可能需要注意的是，查询中的相等子表达式仅被评估一次； &lt;code&gt;=&lt;/code&gt; 不能用于加快速度。</target>
        </trans-unit>
        <trans-unit id="5dca3db2b5e814aa2f8b6c5ddad967e0eb6d4fd1" translate="yes" xml:space="preserve">
          <source>A user-defined instrumentation function for each object attaches the managed objects to real resources. This function is called by the agent on a &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; operation. The function could read some hardware register, perform a calculation, or whatever is necessary to implement the semantics associated with the conceptual variable. These functions must be written both for scalar variables and for tables. They are specified in the association file, which is a text file. In this file, the &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;, or symbolic name for each managed object, is associated with an Erlang tuple &lt;code&gt;{Module,&lt;/code&gt;&lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;ListOfExtraArguments}&lt;/code&gt;.</source>
          <target state="translated">每个对象的用户定义的检测功能将被管理对象附加到实际资源。代理在 &lt;code&gt;get&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 操作上调用此函数。该函数可以读取一些硬件寄存器，执行计算或执行与概念变量关联的语义所需的任何操作。必须为标量变量和表编写这些函数。它们在关联文件（文本文件）中指定。在此文件中， &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 或每个托管对象的符号名称与Erlang元组 &lt;code&gt;{Module,&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; ， &lt;code&gt;ListOfExtraArguments}&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="3c4272ec5ada9781d28edc9d23bde5292b08de6e" translate="yes" xml:space="preserve">
          <source>A user-defined parameter passed from the function &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;. It is used in the return value of &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从函数 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 传递的用户定义参数。它用于 &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1,2&lt;/a&gt;&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="ab19e68c658754f6d616e8a9359af12c979f8b2d" translate="yes" xml:space="preserve">
          <source>A user-perceived character, consisting of one or more codepoints.</source>
          <target state="translated">用户感知的字符,由一个或多个码点组成。</target>
        </trans-unit>
        <trans-unit id="8c487c4839c1da9e5bc76ca352a5448a09547f8c" translate="yes" xml:space="preserve">
          <source>A valid chain must have at least a ROOT and a peer cert. The root cert can be given either as a cert pre-generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or as root cert generation options.    A root certificate generated by &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;.   For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; below.    This is a subset of the type &lt;code&gt;ssl:ssl_option()&lt;/code&gt;. &lt;code&gt;PrivateKey&lt;/code&gt; is what &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; returns.</source>
          <target state="translated">有效链必须至少具有ROOT和对等证书。根证书既可以作为 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 预先生成的证书，也可以作为根证书生成选项给出。由 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 生成的根证书。有关可用选项，请参见下面的 &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; 。这是 &lt;code&gt;ssl:ssl_option()&lt;/code&gt; 类型的子集。 &lt;code&gt;PrivateKey&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; 返回的内容。</target>
        </trans-unit>
        <trans-unit id="d8b7f3becec263c2ea738b6691bf529e9d0210ac" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has SMP support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统具有SMP支持，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac91e865bee333c1075b80d53873b9d3418a7c3" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has support for dirty scheduler threads; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统支持脏调度程序线程，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec437d87d8ab2a59f963ce8195782385431267f" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;!= 0&lt;/code&gt; if the runtime system has thread support; otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果运行时系统具有线程支持，则值 &lt;code&gt;!= 0&lt;/code&gt; 。否则为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4ba959b8daba0b753bc8f2d86eb3f9db8c6578e" translate="yes" xml:space="preserve">
          <source>A value in the &lt;code&gt;msg&lt;/code&gt; field does &lt;strong&gt;not&lt;/strong&gt; imply an absence of decode errors. The &lt;code&gt;errors&lt;/code&gt; field should also be examined.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 字段中的值并不表示&lt;strong&gt;不&lt;/strong&gt;存在解码错误。该 &lt;code&gt;errors&lt;/code&gt; 领域也应进行检查。</target>
        </trans-unit>
        <trans-unit id="24b9fc9ee791392b2ee5f6e020d0a3fa901804d7" translate="yes" xml:space="preserve">
          <source>A value must be provided for all variables, which lack default values in the MIB.</source>
          <target state="translated">必须为所有变量提供一个值,这些变量在MIB中缺乏默认值。</target>
        </trans-unit>
        <trans-unit id="c6977869e984d6fd810d1cba7c1d446b28da9624" translate="yes" xml:space="preserve">
          <source>A value must have length at least 1.</source>
          <target state="translated">一个值的长度必须至少为1。</target>
        </trans-unit>
        <trans-unit id="5445236ba06b6cb9e9bcd38ff5b377fb1c4caffb" translate="yes" xml:space="preserve">
          <source>A value of this type is encoded as an &lt;code&gt;open type&lt;/code&gt;.</source>
          <target state="translated">此类型的值被编码为 &lt;code&gt;open type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c03ee0717973a910f7c750d1a0679fb27eb9cdb9" translate="yes" xml:space="preserve">
          <source>A variable cannot be assigned a new value unless first removed. Variables assigned to by the &lt;code&gt;=&lt;/code&gt; operator are removed at the end of the query, while variables assigned to by the &lt;code&gt;:=&lt;/code&gt; operator can only be removed by calls to &lt;code&gt;forget&lt;/code&gt;. There are no user variables when module data need to be set up again; if any of the functions that make it necessary to set up module data again is called, all user variables are forgotten.</source>
          <target state="translated">除非先将变量删除，否则无法为其分配新值。由 &lt;code&gt;=&lt;/code&gt; 运算符分配的变量将在查询结束时删除，而由 &lt;code&gt;:=&lt;/code&gt; 运算符分配的变量只能通过调用 &lt;code&gt;forget&lt;/code&gt; 来删除。当需要再次设置模块数据时，没有用户变量。如果调用了需要再次设置模块数据的任何函数，则所有用户变量都将被忽略。</target>
        </trans-unit>
        <trans-unit id="5646fa290bab26490d3e95c3eda24f90bfb3cb85" translate="yes" xml:space="preserve">
          <source>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</source>
          <target state="translated">变量是一个表达式。如果一个变量与一个值绑定,那么返回值就是这个值。未绑定的变量只允许在模式中使用。</target>
        </trans-unit>
        <trans-unit id="ad98bc5cb949befd1ed83fe57c5fe19294f99fe2" translate="yes" xml:space="preserve">
          <source>A variable name that is not in the environment results in an error.</source>
          <target state="translated">一个不在环境中的变量名会导致错误。</target>
        </trans-unit>
        <trans-unit id="d4d78baa7493d760df88a559b3a2f6209c0e9bbb" translate="yes" xml:space="preserve">
          <source>A variant of this is to use a &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt;. The state is then modeled with for example a tuple &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt;.</source>
          <target state="translated">这种方法的一种变体是将 &lt;code&gt;&lt;a href=&quot;#Complex%20State&quot;&gt;Complex State&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;#One%20Event%20Handler&quot;&gt;One Event Handler&lt;/a&gt;&lt;/code&gt; 。然后使用例如元组 &lt;code&gt;{MainFSMState,SubFSMState}&lt;/code&gt; 对状态进行建模。</target>
        </trans-unit>
        <trans-unit id="d89b8938a6cae035d7fea046259542e22b9f6ee1" translate="yes" xml:space="preserve">
          <source>A web server can be configured to start when starting the &lt;code&gt;Inets&lt;/code&gt; application, or dynamically in runtime by calling the &lt;code&gt;Inets&lt;/code&gt; application API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; or &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;. The configuration options, also called properties, are as follows:</source>
          <target state="translated">可以将Web服务器配置为在启动 &lt;code&gt;Inets&lt;/code&gt; 应用程序时启动，或者通过调用 &lt;code&gt;Inets&lt;/code&gt; 应用程序API &lt;code&gt;inets:start(httpd, ServiceConfig)&lt;/code&gt; 或 &lt;code&gt;inets:start(httpd, ServiceConfig, How)&lt;/code&gt; 在运行时动态启动，请参见 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 。配置选项也称为属性，如下所示：</target>
        </trans-unit>
        <trans-unit id="b7054606b43999cf69240d9ae96069173e833e99" translate="yes" xml:space="preserve">
          <source>A word boundary is a position in the subject string where the current character and the previous character do not both match \w or \W (that is, one matches \w and the other matches \W), or the start or end of the string if the first or last character matches \w, respectively. In UTF mode, the meanings of \w and \W can be changed by setting option &lt;code&gt;ucp&lt;/code&gt;. When this is done, it also affects \b and \B. PCRE and Perl do not have a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However, whatever follows \b normally determines which it is. For example, the fragment \ba matches &quot;a&quot; at the start of a word.</source>
          <target state="translated">单词边界是主题字符串中当前字符和前一个字符都不都匹配\ w或\ W（即，一个匹配\ w而另一个匹配\ W）或该字符的开始或结尾的位置。如果第一个或最后一个字符分别与\ w匹配，则为字符串。在UTF模式下，可以通过设置选项 &lt;code&gt;ucp&lt;/code&gt; 来更改\ w和\ W的含义。完成此操作后，它还会影响\ b和\ B。 PCRE和Perl没有单独的&amp;ldquo;单词开头&amp;rdquo;或&amp;ldquo;单词结尾&amp;rdquo;元序列。但是，\ b后面的所有内容通常确定是哪个。例如，片段\ ba在单词的开头匹配&amp;ldquo; a&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="62d9a28c75bb240da271eb7051702080009f9364" translate="yes" xml:space="preserve">
          <source>A wrap disk log file consists of many files, called index files. A log file can be opened and closed. Also, a single index file can be opened separately. If a non-existent or non-internally formatted file is opened, an error message is returned. If the file is corrupt, no attempt is made to repair it, but an error message is returned.</source>
          <target state="translated">一个包盘日志文件由许多文件组成,称为索引文件。一个日志文件可以被打开和关闭。此外,还可以单独打开一个索引文件。如果打开了一个不存在的或非内部格式化的文件,将返回一个错误信息。如果文件损坏,不试图修复它,但会返回一条错误信息。</target>
        </trans-unit>
        <trans-unit id="0eb179692808865df9fddfd61d123acd14ceb6dd" translate="yes" xml:space="preserve">
          <source>A wrap files specification is used to limit the disk space consumed by the trace. The trace is written to a limited number of files each with a limited size. The actual filenames are &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt;, where &lt;code&gt;SeqCnt&lt;/code&gt; counts as a decimal string from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;WrapCnt&lt;/code&gt; and then around again from &lt;code&gt;0&lt;/code&gt;. When a trace term written to the current file makes it longer than &lt;code&gt;WrapSize&lt;/code&gt;, that file is closed, if the number of files in this wrap trace is as many as &lt;code&gt;WrapCnt&lt;/code&gt; the oldest file is deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped, there are at most &lt;code&gt;WrapCnt&lt;/code&gt; trace files saved with a size of at least &lt;code&gt;WrapSize&lt;/code&gt; (but not much bigger), except for the last file that might even be empty. The default values are &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; and &lt;code&gt;WrapCnt = 8&lt;/code&gt;.</source>
          <target state="translated">包装文件规范用于限制跟踪消耗的磁盘空间。跟踪被写入到数量有限的文件中，每个文件的大小均受限制。实际的文件名是 &lt;code&gt;Filename ++ SeqCnt ++ Suffix&lt;/code&gt; ，其中 &lt;code&gt;SeqCnt&lt;/code&gt; 计为从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;WrapCnt&lt;/code&gt; 的十进制字符串，然后再从 &lt;code&gt;0&lt;/code&gt; 开始。当写入当前文件的跟踪项的长度大于 &lt;code&gt;WrapSize&lt;/code&gt; 时，将关闭该文件，如果此环绕跟踪中的文件数与 &lt;code&gt;WrapCnt&lt;/code&gt; 一样,则最早的文件将被删除，然后将打开一个新文件成为当前文件。因此，当包装跟踪停止时，最多有 &lt;code&gt;WrapCnt&lt;/code&gt; 跟踪文件的保存大小至少为 &lt;code&gt;WrapSize&lt;/code&gt; （但不大），但最后一个文件可能为空。默认值为 &lt;code&gt;WrapSize = 128*1024&lt;/code&gt; 和 &lt;code&gt;WrapCnt = 8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a037e42e51e318b55fc1948fa5a1661147cd7c" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The attributes and &lt;code&gt;TabDef&lt;/code&gt; are forwarded to &lt;code&gt;mnesia:create_table/2&lt;/code&gt;. For example, if the table is to reside as &lt;code&gt;disc_only_copies&lt;/code&gt; on all nodes, a call looks as follows:</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 的包装函数，该函数创建具有适当 &lt;code&gt;attributes&lt;/code&gt; 集的表（如果不存在现有表）。属性和 &lt;code&gt;TabDef&lt;/code&gt; 被转发到 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; 。例如，如果表要作为 &lt;code&gt;disc_only_copies&lt;/code&gt; 驻留在所有节点上，则调用看起来如下：</target>
        </trans-unit>
        <trans-unit id="36b94a437ad5d966a2bc660ff3e1289bcc1b9fd7" translate="yes" xml:space="preserve">
          <source>A wrapper function for &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, which creates a table (if there is no existing table) with an appropriate set of &lt;code&gt;attributes&lt;/code&gt;. The table only resides on the local node and its storage type is the same as the &lt;code&gt;schema&lt;/code&gt; table on the local node, that is, &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; or &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:create_table/2&lt;/code&gt; 的包装函数，该函数创建具有适当 &lt;code&gt;attributes&lt;/code&gt; 集的表（如果不存在现有表）。该表仅驻留在本地节点上，并且其存储类型与本地节点上的 &lt;code&gt;schema&lt;/code&gt; 表相同，即 &lt;code&gt;{ram_copies,[node()]}&lt;/code&gt; 或 &lt;code&gt;{disc_copies,[node()]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bab14cb554b0f0419a6e027fa857770d1ae7636" translate="yes" xml:space="preserve">
          <source>A write operation on a &lt;code&gt;disc_copies&lt;/code&gt; table replica is performed in two steps. First the write operation is appended to a log file, then the actual operation is performed in RAM.</source>
          <target state="translated">对 &lt;code&gt;disc_copies&lt;/code&gt; 表副本的写操作分两个步骤执行。首先，将写操作附加到日志文件，然后在RAM中执行实际操作。</target>
        </trans-unit>
        <trans-unit id="d9843d85d25b1bd741fdb98939b327e3138b2bfb" translate="yes" xml:space="preserve">
          <source>A zlib stream, see &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">zlib流，请参阅 &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17afbf6d1d5b871c5ae0cee1ba18a4f7071dc38b" translate="yes" xml:space="preserve">
          <source>A: Cygwin, MSYS or MSYS2 is the environment, which closely resembles the environment found on any Unix machine. It's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, Cygwin/MSYS/MSYS2 tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; and &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt;. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in Cygwin/MSYS/MSYS2 are Unix-like paths with &quot;forward slashes&quot; (/) and no drive letters. The Cygwin specific command &lt;code&gt;cygpath&lt;/code&gt; is used for most of the path conversions in a Cygwin environment. Other tools are used (when needed) in the corresponding MSYS and MSYS2 environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way.</source>
          <target state="translated">答：Cygwin，MSYS或MSYS2是环境，它与任何Unix计算机上的环境都非常相似。几乎就像您在Windows中拥有一台虚拟Unix计算机一样。在给定某些参数的情况下进行配置，然后创建环境环境的gnu-make用来构建系统的makefile。但是，大多数实际的编译器等不是Cygwin / MSYS / MSYS2工具，因此我们编写了几个包装器（Bourne-shell脚本），它们位于 &lt;code&gt;$ERL_TOP/etc/win32/cygwin_tools&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/etc/win32/msys_tools&lt;/code&gt; 。它们都进行参数转换和Unix环境中常见的开关，以适合本机Windows工具。当然，最引人注目的是路径，在Cygwin / MSYS / MSYS2中，路径是类似Unix的路径，带有&amp;ldquo;正斜杠&amp;rdquo;（/），并且没有驱动器号。 Cygwin特定命令 &lt;code&gt;cygpath&lt;/code&gt; 在Cygwin环境中用于大多数路径转换。 （在需要时）在相应的MSYS和MSYS2环境中使用其他工具。幸运的是，大多数编译器接受正斜杠而不是反斜杠作为路径分隔符，但是尽管如此，仍然必须正确设置驱动器号等。包装脚本不是通用的，例如cc.sh可以理解并翻译每个可能的gcc选项，并将正确的选项传递给cl.exe。原则是脚本足够强大，可以构建Erlang / OTP，仅此而已。他们可能需要扩展才能应对Erlang开发过程中的更改，这就是我们将它们变成shell脚本而不是Perl脚本的原因之一。我们相信他们更容易理解和改变。</target>
        </trans-unit>
        <trans-unit id="4d1ee8b13defdb6f13a0a5e7daa4cf8a74b29540" translate="yes" xml:space="preserve">
          <source>A: For Cygwin, MSYS and MSYS2 alike, we try to use the latest releases available when building. What versions you use shouldn't really matter. We try to include workarounds for the bugs we've found in different Cygwin/MSYS/MSYS2 releases. Please help us add workarounds for new Cygwin/MSYS/MSYS2-related bugs as soon as you encounter them. Also please do submit bug reports to the appropriate Cygwin, MSYS and/or MSYS2 developers. The GCC we used for 21 was version 4.8.1 (MinGW 32bit) and 4.8.5 (MSYS2 64bit). We used VC++ 12.0 (i.e. Visual studio 2013), Sun's JDK 1.6.0_45 (32bit) and Sun's JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 1.0.2d. Please read the next section for details on what you need.</source>
          <target state="translated">答:对于Cygwin,MSYS和MSYS2一样,我们在构建时尽量使用最新的版本。你使用的版本并不重要。我们会尽量将我们在不同的Cygwin/MSYS/MSYS2版本中发现的错误的解决方法加入其中。请帮助我们添加与Cygwin/MSYS/MSYS2相关的新错误的解决方法,一旦你遇到这些错误。也请将错误报告提交给相应的Cygwin、MSYS和/或MSYS2开发者。我们在21中使用的GCC是4.8.1版本(MinGW 32bit)和4.8.5版本(MSYS2 64bit)。我们使用了VC++12.0(即Visual studio 2013)、Sun的JDK 1.6.0_45(32位)和Sun的JDK 1.7.0_1(64位)、NSIS 2.46和Win32 OpenSSL 1.0.2d。请阅读下一节,了解您所需要的详细内容。</target>
        </trans-unit>
        <trans-unit id="731d5bc0547d3ee14b9d073a740322bb562e4b26" translate="yes" xml:space="preserve">
          <source>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen.</source>
          <target state="translated">答:不,永远不会。要保持项目文件的更新,并在VC++图形用户界面中完成OTP构建的所有步骤,这种麻烦根本不值得,甚至不可能。用于Erlang/OTP的VC++项目文件将永远不会发生。</target>
        </trans-unit>
        <trans-unit id="521d37ede1551a08a3beff1206807c9cd55ca94a" translate="yes" xml:space="preserve">
          <source>A: No, not really, but see this as a step in the right direction.</source>
          <target state="translated">答:不,不是,但认为这是一个正确的方向。</target>
        </trans-unit>
        <trans-unit id="58e458048a7a9548592140528083c14b19023a3f" translate="yes" xml:space="preserve">
          <source>A: No, the result will be a pure Windows binary, and as far as I know, it's not possible to make a Cygwin binary yet. That is of course something desirable, but there are still some problems with the dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP emulation in Cygwin, which, I'm sure of, will improve, but still has some problems. Fixing those problems might be easy or might be hard. I suggest you try yourself and share your experience. No one would be happier if a simple &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; would produce a fully fledged Cygwin binary.</source>
          <target state="translated">答：不，结果将是纯Windows二进制文件，据我所知，尚无法制作Cygwin二进制文件。当然，这是合乎需要的，但是动态链接（动态Erlang驱动程序加载）以及Cygwin中的TCP / IP仿真仍然存在一些问题，我敢肯定，这些问题会有所改善，但仍然存在一些问题。解决这些问题可能很容易，也可能很难。我建议您尝试一下，并分享您的经验。如果一个简单的 &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt; 可以生成完整的Cygwin二进制文件，那么没有人会更高兴。</target>
        </trans-unit>
        <trans-unit id="f58ec10da79cf14638b87d58a71fefc5754e9d5f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the Cygwin environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. The Windows SDK is however enough to build Erlang, you do not need to buy Visual C++, just download the SDK (SDK version 8.1 == Visual studio 2013).</source>
          <target state="translated">答:不,很遗憾不是。你仍然需要微软的Visual C++。一个Bourne-shell脚本(cc.sh)包装了Visual C++编译器,并在Cygwin环境中运行它。构建Erlang所需的所有其他工具都是免费/开源的,但不是C编译器。不过Windows SDK足以构建Erlang,你不需要购买Visual C++,只需要下载SDK(SDK版本8.1 ==Visual studio 2013)。</target>
        </trans-unit>
        <trans-unit id="a599e8e13ccfd4f3e0504f6192bcbcf31a59938f" translate="yes" xml:space="preserve">
          <source>A: No, unfortunately we haven't got time to help with Cygwin/MSYS/MSYS2 related user problems, please read related websites, newsgroups and mailing lists.</source>
          <target state="translated">答:不,很遗憾我们没有时间帮助解决Cygwin/MSYS/MSYS2相关的用户问题,请阅读相关网站、新闻组和邮件列表。</target>
        </trans-unit>
        <trans-unit id="210dcbb21de47a153ba938b86b20600d7d480a0c" translate="yes" xml:space="preserve">
          <source>A: OK, I admit, one of the files is compiled using Cygwin's or MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, &lt;code&gt;beam_emu.c&lt;/code&gt; benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows.</source>
          <target state="translated">答：好的，我承认，其中一个文件是使用Cygwin或MinGW的GCC编译的，然后使用小型C语言将生成的目标代码转换为兼容MS VC ++的coff。这是因为该特定文件 &lt;code&gt;beam_emu.c&lt;/code&gt; 能够使用GCC标签即值扩展而受益匪浅，该扩展将仿真器性能提高了50％。不幸的是，这确实（尚未）意味着所有OTP都可以使用GCC进行编译。该特定源代码不执行任何系统特定的操作，实际上是因为在Windows上使用GCC对其进行了编译。</target>
        </trans-unit>
        <trans-unit id="97fcb970b445ac9a87b96b37bf7ea3a4ab4cab29" translate="yes" xml:space="preserve">
          <source>A: Well, it's not expensive, it's free (as in free beer). Just download and install the latest Windows SDK from Microsoft and all the tools you need are there. The included debugger (WinDbg) is also quite usable. That's what I used when porting Erlang to 64bit Windows. Another reason to use later Microsoft compilers is DLL compatibility. DLL's using a new version of the standard library might not load if the VM is compiled with an old VC++ version. So we should aim to use the latest freely available SDK and compiler.</source>
          <target state="translated">答:嗯,不贵,是免费的(就像免费啤酒一样)。只要从微软下载并安装最新的Windows SDK,你需要的所有工具都在那里。附带的调试器(WinDbg)也很好用。我在将Erlang移植到64位Windows时就是用的这个。使用后来的微软编译器的另一个原因是DLL的兼容性。如果虚拟机是用旧的VC++版本编译的,那么使用新版本标准库的DLL可能无法加载。所以我们应该以使用最新的免费SDK和编译器为目标。</target>
        </trans-unit>
        <trans-unit id="c041ae7e57578688a11137a9916f0588de32a73f" translate="yes" xml:space="preserve">
          <source>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one.</source>
          <target state="translated">答:部分原因是它是一个很好的编译器--真的!事实上,在R11版本的后期,已经可以用mingw代替visual C++进行编译了(你可能会在一些脚本和目录中看到它的残余)。事实上,在R11版本的后期,已经可以使用mingw而不是visual C++进行编译了(你可能会在一些脚本和目录中看到残留的痕迹)。不幸的是,Windows的SMP版本的开发破坏了mingw构建,我们选择专注于VC++构建,因为VC++版本的性能更好。mingw构建可能会回来,但只要VC++能提供更好的性能,商业构建将是VC++的。</target>
        </trans-unit>
        <trans-unit id="8315e42a391d74c84bc127e20d99aa2c7b6bc114" translate="yes" xml:space="preserve">
          <source>A: Yes, we use the exact same build procedure.</source>
          <target state="translated">答:是的,我们使用完全相同的构建程序。</target>
        </trans-unit>
        <trans-unit id="436942b9131313ac7f725ef0106016a7cb814a52" translate="yes" xml:space="preserve">
          <source>API for a SSL/TLS CRL (Certificate Revocation List) cache.</source>
          <target state="translated">用于SSL/TLS CRL(证书撤销列表)缓存的API。</target>
        </trans-unit>
        <trans-unit id="a23c8e20572073978952d048d9433a8575f6a97d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang NIF library.</source>
          <target state="translated">Erlang NIF库的API函数。</target>
        </trans-unit>
        <trans-unit id="361d551affb47befd80fca6479fe8a167dc7036d" translate="yes" xml:space="preserve">
          <source>API functions for an Erlang driver.</source>
          <target state="translated">Erlang驱动的API函数。</target>
        </trans-unit>
        <trans-unit id="d310425c434730e2f59306f932cf1691ae572d78" translate="yes" xml:space="preserve">
          <source>API functions to write customized SSH clients and servers applications</source>
          <target state="translated">用于编写定制化SSH客户端和服务器应用程序的API函数。</target>
        </trans-unit>
        <trans-unit id="72bf5fea06a2041d232930267f67048618c99f45" translate="yes" xml:space="preserve">
          <source>API module for Logger, the standard logging facility in Erlang/OTP.</source>
          <target state="translated">Logger的API模块,这是Erlang/OTP中的标准日志设施。</target>
        </trans-unit>
        <trans-unit id="0be52be7a0efe4a62d99e98efb97a08aef84fe41" translate="yes" xml:space="preserve">
          <source>API module for public-key infrastructure.</source>
          <target state="translated">公钥基础设施的API模块。</target>
        </trans-unit>
        <trans-unit id="76827dde5bd6ab1accea3ccbe25374a63afc24e6" translate="yes" xml:space="preserve">
          <source>ARM: ARMv5TE (i.e. XScale) processors should work. Both big-endian and little-endian modes are supported.</source>
          <target state="translated">ARM。ARMv5TE(即XScale)处理器应该可以使用。支持big-endian和little-endian模式。</target>
        </trans-unit>
        <trans-unit id="ca8c02ce6c85a255754680e86371209b9b2680ce" translate="yes" xml:space="preserve">
          <source>ARM: Linux</source>
          <target state="translated">ARM:Linux</target>
        </trans-unit>
        <trans-unit id="d9932f6f9e0505be61dc8fcd25736c1bf8cf818f" translate="yes" xml:space="preserve">
          <source>ASCII value or unicode code-point of the character &lt;strong&gt;&lt;code&gt;char&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">字符&lt;strong&gt; &lt;code&gt;char&lt;/code&gt; 的&lt;/strong&gt; ASCII值或Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="196ab313cd92b6ea93995c7fc93f081f77b30992" translate="yes" xml:space="preserve">
          <source>ASN.1 DER-encoded entity as an Erlang binary.</source>
          <target state="translated">ASN.1 DER编码的实体为Erlang二进制。</target>
        </trans-unit>
        <trans-unit id="368efd7c5142e650553f401aa461d1b76d069901" translate="yes" xml:space="preserve">
          <source>ASN.1 compiler and compile-time support functions</source>
          <target state="translated">ASN.1 编译器和编译时支持功能。</target>
        </trans-unit>
        <trans-unit id="c009d6d020f91e9075e192687145f1f9183e3b17" translate="yes" xml:space="preserve">
          <source>ASN.1 has both primitive and constructed types:</source>
          <target state="translated">ASN.1有原始类型和构造类型。</target>
        </trans-unit>
        <trans-unit id="cfcd66d008f9b63d7b919bdf916303779861fe19" translate="yes" xml:space="preserve">
          <source>ASN.1 is a formal language for describing data structures to be exchanged between distributed computer systems. The purpose of ASN.1 is to have a platform and programming language independent notation to express types using a standardized set of rules for the transformation of values of a defined type into a stream of bytes. This stream of bytes can then be sent on any type of communication channel. This way, two applications written in different programming languages running on different computers, and with different internal representation of data, can exchange instances of structured data types.</source>
          <target state="translated">ASN.1是一种描述分布式计算机系统之间交换的数据结构的正式语言。ASN.1的目的是拥有一种独立于平台和编程语言的符号,以使用一套标准化的规则来表达类型,将定义类型的值转换为字节流。然后,这个字节流可以在任何类型的通信通道上发送。这样,两个用不同编程语言编写的、在不同计算机上运行的、具有不同内部数据表示方式的应用程序就可以交换结构化数据类型的实例。</target>
        </trans-unit>
        <trans-unit id="3b1ea2d9df3b25e2e5fe146441abf268990d9a8f" translate="yes" xml:space="preserve">
          <source>ASN.1 is used in two different ways in SNMP. The SMI is based on ASN.1, and the messages in the protocol are defined by using ASN.1.</source>
          <target state="translated">ASN.1在SNMP中以两种不同的方式使用。SMI是基于ASN.1的,协议中的消息是使用ASN.1定义的。</target>
        </trans-unit>
        <trans-unit id="18afe0241096372d9207a097906f4cc9e96ca40a" translate="yes" xml:space="preserve">
          <source>ASN.1 itself specifies indefinitely large integers. Erlang systems with version 4.3 and higher support very large integers, in practice indefinitely large integers.</source>
          <target state="translated">ASN.1本身规定了无限大整数。4.3及以上版本的Erlang系统支持非常大的整数,实际上是无限大的整数。</target>
        </trans-unit>
        <trans-unit id="1b5feca556ffbb7ecdf53e29fcc97d476a5bf5f3" translate="yes" xml:space="preserve">
          <source>ASN.1 module &lt;code&gt;People&lt;/code&gt; is now accepted and the abstract syntax tree is saved in file &lt;code&gt;People.asn1db&lt;/code&gt;. The generated Erlang code is compiled using the Erlang compiler and loaded into the Erlang runtime system. There is now an API for &lt;code&gt;encode/2&lt;/code&gt; and &lt;code&gt;decode/2&lt;/code&gt; in module &lt;code&gt;People&lt;/code&gt;, which is called like:</source>
          <target state="translated">现在接受ASN.1模块 &lt;code&gt;People&lt;/code&gt; ，并且抽象语法树保存在文件 &lt;code&gt;People.asn1db&lt;/code&gt; 中。使用Erlang编译器编译生成的Erlang代码，并将其加载到Erlang运行时系统中。现在在 &lt;code&gt;People&lt;/code&gt; 模块中有一个用于 &lt;code&gt;encode/2&lt;/code&gt; 和 &lt;code&gt;decode/2&lt;/code&gt; 的API ，其名称如下：</target>
        </trans-unit>
        <trans-unit id="38ab94405d2e97c97a998a6475af5251fa89b825" translate="yes" xml:space="preserve">
          <source>ASN.1 supports a wide variety of character sets. The main difference between an &lt;code&gt;OCTET STRING&lt;/code&gt; and a character string is that the &lt;code&gt;OCTET STRING&lt;/code&gt; has no imposed semantics on the bytes delivered.</source>
          <target state="translated">ASN.1支持多种字符集。一之间的主要区别 &lt;code&gt;OCTET STRING&lt;/code&gt; 和字符串就是 &lt;code&gt;OCTET STRING&lt;/code&gt; 已没有征收上提供的字节语义。</target>
        </trans-unit>
        <trans-unit id="00118b8d7398e0597bbf5e3a9b1a946f91c275ba" translate="yes" xml:space="preserve">
          <source>ASN.1 type present in the Public Key applications ASN.1 specifications.</source>
          <target state="translated">公钥应用ASN.1规范中存在的ASN.1类型。</target>
        </trans-unit>
        <trans-unit id="999234c8b850d2864e4971ba3f6a923f854d60c2" translate="yes" xml:space="preserve">
          <source>ASN1 file. It creates an &lt;code&gt;.erl&lt;/code&gt;, &lt;code&gt;.hrl&lt;/code&gt;, and &lt;code&gt;.asn1db&lt;/code&gt; file from an &lt;code&gt;.asn1&lt;/code&gt; file. Also compiles the &lt;code&gt;.erl&lt;/code&gt; using the Erlang compiler unless option &lt;code&gt;+noobj&lt;/code&gt; is specified.</source>
          <target state="translated">ASN1文件。它创建了一个 &lt;code&gt;.erl&lt;/code&gt; ， &lt;code&gt;.hrl&lt;/code&gt; 和 &lt;code&gt;.asn1db&lt;/code&gt; 从文件 &lt;code&gt;.asn1&lt;/code&gt; 文件。此外编译 &lt;code&gt;.erl&lt;/code&gt; 使用Erlang的编译器，除非选项 &lt;code&gt;+noobj&lt;/code&gt; 指定。</target>
        </trans-unit>
        <trans-unit id="3f4ea8e8df4b539a09e4694a57b64fe87acc6aa2" translate="yes" xml:space="preserve">
          <source>AVP Codes</source>
          <target state="translated">AVP代码</target>
        </trans-unit>
        <trans-unit id="5f07924d7df0ed6c7a91768f9fe2d84ed905e783" translate="yes" xml:space="preserve">
          <source>AVP Considerations</source>
          <target state="translated">AVP的考虑因素</target>
        </trans-unit>
        <trans-unit id="358dba47c0c1d2a1ab4897c5be6e756cf7939cf1" translate="yes" xml:space="preserve">
          <source>AVP Flags</source>
          <target state="translated">AVP旗帜</target>
        </trans-unit>
        <trans-unit id="147e947b2ccddb2127e44e91cd77c7172c834c87" translate="yes" xml:space="preserve">
          <source>AVP Header</source>
          <target state="translated">AVP头</target>
        </trans-unit>
        <trans-unit id="db689f171790fb1bc972a968ef05e4c119e28132" translate="yes" xml:space="preserve">
          <source>AVP Occurrence Tables</source>
          <target state="translated">AVP发生表</target>
        </trans-unit>
        <trans-unit id="7b38fc4069f3bc947361bf1d7d5e19953586e35e" translate="yes" xml:space="preserve">
          <source>AVP Values</source>
          <target state="translated">AVP值</target>
        </trans-unit>
        <trans-unit id="c483ce0c3913a6678d954f208b0703dcb0e25b18" translate="yes" xml:space="preserve">
          <source>AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</source>
          <target state="translated">在能力交换期间,在发出的CER或CEA信息中发送的AVP值。可在服务和传输上配置,后者的值优先。具有以下类型之一:</target>
        </trans-unit>
        <trans-unit id="2c0e57636791ead050a384bc77e79f8d2fe33260" translate="yes" xml:space="preserve">
          <source>AVPs are decoded into a list of diameter_avp records in &lt;code&gt;avps&lt;/code&gt; field of diameter_packet records independently of &lt;code&gt;decode_format&lt;/code&gt;.</source>
          <target state="translated">AVP被独立于 &lt;code&gt;avps&lt;/code&gt; 解码为直径_包记录的avps字段中的直径 &lt;code&gt;decode_format&lt;/code&gt; 记录列表。</target>
        </trans-unit>
        <trans-unit id="84bf21f5193b0af6e24655608ac0e30ceef7e07a" translate="yes" xml:space="preserve">
          <source>AVPs defined in the RFC are defined in dictionaries provided by diameter. Their proper use in application messages is the responsibility of the user.</source>
          <target state="translated">RFC中定义的AVPs是在直径提供的字典中定义的。它们在应用消息中的正确使用是用户的责任。</target>
        </trans-unit>
        <trans-unit id="6734299ae0f748faa6b52d7e11abf2d0c25ca64f" translate="yes" xml:space="preserve">
          <source>AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</source>
          <target state="translated">用于构建外发CER/CEA信息的AVP。值优先于有关服务的任何指定值。</target>
        </trans-unit>
        <trans-unit id="5816a66e2c13a6d76644d2e1d9520bcb6dbe4591" translate="yes" xml:space="preserve">
          <source>Aa a list of binary digits (0 or 1). This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if option &lt;strong&gt;legacy_bit_string&lt;/strong&gt; is given.</source>
          <target state="translated">Aa二进制数字列表（0或1）。接受此格式作为编码功能的输入，如果给出了&lt;strong&gt;legacy_bit_string&lt;/strong&gt;选项，&lt;strong&gt;则将&lt;/strong&gt; &lt;code&gt;BIT STRING&lt;/code&gt; 解码为该格式。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5bdc897b18ae8c316a38939d3d1d0e98477ad32" translate="yes" xml:space="preserve">
          <source>Abandon carrier free block min limit. A valid &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; is a positive integer representing a block size limit. The largest free block in a carrier must be at least &lt;code&gt;bytes&lt;/code&gt; large, for the carrier to be abandoned. The default is zero but can be changed in the future.</source>
          <target state="translated">放弃无载波最小限制。有效的 &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt; 是表示块大小限制的正整数。载波中最大的空闲块必须至少为 &lt;code&gt;bytes&lt;/code&gt; 大，以便放弃该载波。默认值为零，但以后可以更改。</target>
        </trans-unit>
        <trans-unit id="2e058521811c5ddbaf236521691a6aac5c91e2d2" translate="yes" xml:space="preserve">
          <source>Abandon carrier number limit. A valid &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</source>
          <target state="translated">放弃运营商数量限制。有效的 &lt;code&gt;&amp;lt;amount&amp;gt;&lt;/code&gt; 是一个正整数，代表每个分配器实例的最大被放弃载波数。默认值为1000，实际上将禁用该限制，但是以后可以更改。</target>
        </trans-unit>
        <trans-unit id="ddd8504b781a1a9f6d7b92f1aa500221a0c4787e" translate="yes" xml:space="preserve">
          <source>Abandon carrier utilization limit. A valid &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; is an integer in the range &lt;code&gt;[0, 100]&lt;/code&gt; representing utilization in percent. When a utilization value &amp;gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If &lt;code&gt;de&lt;/code&gt; (default enabled) is passed instead of a &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt;, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to &lt;code&gt;de&lt;/code&gt;, but this can be changed in the future.</source>
          <target state="translated">放弃运营商利用率限制。有效的 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; 是范围 &lt;code&gt;[0, 100]&lt;/code&gt; 0，100]中的整数，以百分比表示利用率。使用利用率值&amp;gt; 0时，允许分配器实例放弃多块载波。如果传递了 &lt;code&gt;de&lt;/code&gt; （默认启用）而不是 &lt;code&gt;&amp;lt;utilization&amp;gt;&lt;/code&gt; ，则使用建议的非零利用率值。选择的值取决于分配器类型，并且可以在ERTS版本之间进行更改。默认为 &lt;code&gt;de&lt;/code&gt; ，但是将来可以更改。</target>
        </trans-unit>
        <trans-unit id="99ed550f3cfb54b7e586b3d6dae1d5c6c29740db" translate="yes" xml:space="preserve">
          <source>Ability to start an Erlang emulator with more flags (any flags supported by &lt;code&gt;erl&lt;/code&gt; are supported).</source>
          <target state="translated">可以使用更多标志来启动Erlang仿真器（支持 &lt;code&gt;erl&lt;/code&gt; 支持的任何标志）。</target>
        </trans-unit>
        <trans-unit id="31592e98a78da975e62737d1409cd4fb77bffb8e" translate="yes" xml:space="preserve">
          <source>Abnormally terminates the association specified by &lt;code&gt;Assoc&lt;/code&gt;, without flushing of unsent data. The socket itself remains open. Other associations opened on this socket are still valid, and the socket can be used in new associations.</source>
          <target state="translated">异常终止由 &lt;code&gt;Assoc&lt;/code&gt; 指定的关联，而不刷新未发送的数据。插座本身保持打开状态。在此套接字上打开的其他关联仍然有效，并且可以在新的关联中使用该套接字。</target>
        </trans-unit>
        <trans-unit id="54e07c4e032173c30d3e1d7eccc1fc09c4351b63" translate="yes" xml:space="preserve">
          <source>Abort-Session-Answer</source>
          <target state="translated">Abort-Session-Answer</target>
        </trans-unit>
        <trans-unit id="aa6a977eb79f01d2748881fca70eaba063d40819" translate="yes" xml:space="preserve">
          <source>Abort-Session-Request</source>
          <target state="translated">Abort-Session-Request</target>
        </trans-unit>
        <trans-unit id="53f8d6aa2f451847b8dbd7813ad859f16188a7eb" translate="yes" xml:space="preserve">
          <source>Aborting a Session</source>
          <target state="translated">中止会话</target>
        </trans-unit>
        <trans-unit id="b90030936dbb152015b9486771f1ada8423bb6a8" translate="yes" xml:space="preserve">
          <source>Aborts the current association without flushing any unsent data</source>
          <target state="translated">在不刷新任何未发送数据的情况下中止当前关联。</target>
        </trans-unit>
        <trans-unit id="32505d42e4f66e192dcee78817ac876d40a66d28" translate="yes" xml:space="preserve">
          <source>Aborts the currently executing test case. The user must know with certainty which test case is currently executing. The function is therefore only safe to call from a function that has been called (or synchronously invoked) by the test case.</source>
          <target state="translated">终止当前正在执行的测试用例。用户必须确定知道当前正在执行的测试用例。因此该函数只有在被测试用例调用(或同步调用)的函数中调用才是安全的。</target>
        </trans-unit>
        <trans-unit id="d5a894573c68d878cab4cb98be562e26f9a7f0d1" translate="yes" xml:space="preserve">
          <source>Aborts the test run if one or more suites fail to compile (described earlier).</source>
          <target state="translated">如果一个或多个套件编译失败,则中止测试运行(前面已经说明)。</target>
        </trans-unit>
        <trans-unit id="0744eff0f05c525e12f11abc8717d631608439c4" translate="yes" xml:space="preserve">
          <source>Absolute &lt;code&gt;Time&lt;/code&gt; value. The &lt;code&gt;Time&lt;/code&gt; value is interpreted as an absolute Erlang monotonic time in milliseconds.</source>
          <target state="translated">绝对 &lt;code&gt;Time&lt;/code&gt; 值。该 &lt;code&gt;Time&lt;/code&gt; 值被解释为以毫秒为单位的绝对二郎单调的时间。</target>
        </trans-unit>
        <trans-unit id="6f0553231a05faffe297bc7acf9cdaa15d3ad0d6" translate="yes" xml:space="preserve">
          <source>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">绝对最大高速缓存不合适（以千字节为单位）。如果内存段缓存中的某个段的大小超过了所请求的大小且超过了此参数的值，则该段不会被重用。默认为 &lt;code&gt;4096&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06e7393a1c9fa0746c02d1ffbcea8603bb27631f" translate="yes" xml:space="preserve">
          <source>Absolute offset.</source>
          <target state="translated">绝对偏移。</target>
        </trans-unit>
        <trans-unit id="44496adc987c03d870e59213dad3144a175329ee" translate="yes" xml:space="preserve">
          <source>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an &lt;code&gt;mseg_alloc&lt;/code&gt; singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">绝对单块载波缩减阈值（以千字节为单位）。当缩小 &lt;code&gt;mseg_alloc&lt;/code&gt; 单个块载体中的某个块时，如果未使用的内存量小于此阈值，则该载体将保持不变，否则该载体将被缩小。另请参见 &lt;code&gt;&lt;a href=&quot;#M_rsbcst&quot;&gt;rsbcst&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff57be685f71df6825a00bb0dd0675ff72e59819" translate="yes" xml:space="preserve">
          <source>Absolute time-out time</source>
          <target state="translated">绝对超时时间</target>
        </trans-unit>
        <trans-unit id="87b7af24fbc7dca667aaef7cedf788bba72797a9" translate="yes" xml:space="preserve">
          <source>Abstract Data Type for SNMP Indexing</source>
          <target state="translated">用于SNMP索引的抽象数据类型</target>
        </trans-unit>
        <trans-unit id="5609a156333d78829625afc9b9f892be80c713da" translate="yes" xml:space="preserve">
          <source>Abstract Erlang syntax trees.</source>
          <target state="translated">抽象的Erlang语法树。</target>
        </trans-unit>
        <trans-unit id="0fc0a26f5661ecd86fced093abdeb714aebff28c" translate="yes" xml:space="preserve">
          <source>Abstract data type for FIFO queues.</source>
          <target state="translated">FIFO队列的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="0036b597c9166dc75f5f416f3d4f8e2976e568cd" translate="yes" xml:space="preserve">
          <source>Abstract datatype for the annotations of the Erlang Compiler.</source>
          <target state="translated">Erlang编译器注释的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="60de543c8b0a2bf7a7b2b18c9b9c6e2e54182daa" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang clause.</source>
          <target state="translated">一个Erlang子句的抽象形式。</target>
        </trans-unit>
        <trans-unit id="d6672e8badf7c19620dd4aaaf05ad582f5d5750e" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang expression.</source>
          <target state="translated">Erlang表达式的抽象形式。</target>
        </trans-unit>
        <trans-unit id="39fe847d06d62d8e80b55d37a59200693c709fd2" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang form.</source>
          <target state="translated">一个Erlang形式的抽象形式。</target>
        </trans-unit>
        <trans-unit id="b2f998c312eeafe0281400d148af41f390922671" translate="yes" xml:space="preserve">
          <source>Abstract form of an Erlang type.</source>
          <target state="translated">Erlang类型的抽象形式。</target>
        </trans-unit>
        <trans-unit id="9e50abdb48c5e81f25cc8ea3044d328ca8ac2fce" translate="yes" xml:space="preserve">
          <source>Accept the connection.</source>
          <target state="translated">接受连接。</target>
        </trans-unit>
        <trans-unit id="632efb93ff14184018a35197a6178c2417c5bf58" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listen socket. &lt;code&gt;ListenSocket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. The socket returned is to be passed to &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; to complete handshaking, that is, establishing the SSL/TLS/DTLS connection.</source>
          <target state="translated">在侦听套接字上接受传入的连接请求。 &lt;code&gt;ListenSocket&lt;/code&gt; 必须是 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 返回的套接字。返回的套接字将传递给 &lt;code&gt;&lt;a href=&quot;#handshake-2&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 以完成握手，即建立SSL / TLS / DTLS连接。</target>
        </trans-unit>
        <trans-unit id="69d043ef57e7745987475e175cb8e488f0827aa5" translate="yes" xml:space="preserve">
          <source>Accepts an incoming connection request on a listening socket. &lt;code&gt;Socket&lt;/code&gt; must be a socket returned from &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out value in milliseconds. Defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">在侦听套接字上接受传入的连接请求。 &lt;code&gt;Socket&lt;/code&gt; 必须是从 &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; 返回的套接字。 &lt;code&gt;Timeout&lt;/code&gt; 以毫秒为单位指定超时值。默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cebb4f984dd0627e66700aca28cb0e1a5e9b377" translate="yes" xml:space="preserve">
          <source>Accepts from the listen socket identified by the specified identification number. The identification number is retrieved with the &lt;code&gt;uds_control&lt;/code&gt; routine.</source>
          <target state="translated">从由指定标识号标识的侦听套接字接受。使用 &lt;code&gt;uds_control&lt;/code&gt; 例程检索标识号。</target>
        </trans-unit>
        <trans-unit id="804ff6a7ca49a544473ae24cb9339afd2154136e" translate="yes" xml:space="preserve">
          <source>Access globally registered names.</source>
          <target state="translated">访问全球注册的名称。</target>
        </trans-unit>
        <trans-unit id="119dea3e192ecc9326f47133ed54d5f5ec4367c3" translate="yes" xml:space="preserve">
          <source>Access rights must be set so that all nodes in the pool have the authority to access each other.</source>
          <target state="translated">必须设置访问权限,使池中所有节点都有相互访问的权限。</target>
        </trans-unit>
        <trans-unit id="7a783c4df63409ddf4859d4d9c63884928a701bd" translate="yes" xml:space="preserve">
          <source>Access to TCP/IP protocols.</source>
          <target state="translated">进入TCP/IP协议。</target>
        </trans-unit>
        <trans-unit id="cb621788e34fed8e0f28301fdda0b265d5b636b7" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/17/foo would cause the server to run the script /web/17/cgi-bin/foo.</source>
          <target state="translated">访问http://your.server.org/cgi-bin/17/foo 会导致服务器运行脚本/web/17/cgi-bin/foo。</target>
        </trans-unit>
        <trans-unit id="a462746b4ce0075f7024ce8c93ee0d727108ca1e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/cgi-bin/foo would cause the server to run the script /web/cgi-bin/foo.</source>
          <target state="translated">访问http://your.server.org/cgi-bin/foo 会导致服务器运行脚本/web/cgi-bin/foo。</target>
        </trans-unit>
        <trans-unit id="50c06117af6e8e6670291bbfd27326b9ace3849a" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/docs/ would return http://your.server.org/docs/index.html or http://your.server.org/docs/welcome.html if index.html does not exist.</source>
          <target state="translated">如果index.html不存在,访问http://your.server.org/docs/将返回http://your.server.org/docs/index.html或http://your.server.org/docs/welcome.html。</target>
        </trans-unit>
        <trans-unit id="55663d7fd0c514824e934bdabda94079e8fc90bd" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/image/foo.gif would refer to the file /ftp/pub/image/foo.gif.</source>
          <target state="translated">访问http://your.server.org/image/foo.gif,将参考文件/ftp/pub/image/foo.gif。</target>
        </trans-unit>
        <trans-unit id="7455d0c1b31ee765842e7d4c484ec0f7dd272b9e" translate="yes" xml:space="preserve">
          <source>Access to http://your.server.org/~bob/foo.gif would refer to the file /home/bob/public/foo.gif. In an Apache-like configuration file, &lt;code&gt;Re&lt;/code&gt; is separated from &lt;code&gt;Replacement&lt;/code&gt; with one single space, and as expected backslashes do not need to be backslash escaped, the same example would become:</source>
          <target state="translated">访问http://your.server.org/~bob/foo.gif将引用文件/home/bob/public/foo.gif。在类似Apache的配置文件中， &lt;code&gt;Re&lt;/code&gt; 与 &lt;code&gt;Replacement&lt;/code&gt; 用一个空格分开，并且由于不需要反斜杠转义，因此相同的示例将变为：</target>
        </trans-unit>
        <trans-unit id="a5376bb41fa3654f4b966a3b6b6e89c5279df85f" translate="yes" xml:space="preserve">
          <source>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</source>
          <target state="translated">AccessMod:all_keys(ActivityId,Opaque,Tab,LockKind)</target>
        </trans-unit>
        <trans-unit id="6f94df94a3e7a36d86e327efa5167226380b0374" translate="yes" xml:space="preserve">
          <source>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:delete(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="b5445c5aafa2ff9673bac795581de2bbc41c0c0f" translate="yes" xml:space="preserve">
          <source>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</source>
          <target state="translated">AccessMod:delete_object(ActivityId,Opaque,Tab,RecXS,LockKind)</target>
        </trans-unit>
        <trans-unit id="3e7316c12d79f02736aee472f82ff47536afd350" translate="yes" xml:space="preserve">
          <source>AccessMod:first(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:first(ActivityId,Opaque,Tab)</target>
        </trans-unit>
        <trans-unit id="b3f5ad115c23452c24775618b9441d204cbd0d17" translate="yes" xml:space="preserve">
          <source>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_match_object(ActivityId,Opaque,Tab,Pattern,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="64b8364a718a756d7a35ce5b28a17687b5f7875e" translate="yes" xml:space="preserve">
          <source>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</source>
          <target state="translated">AccessMod:index_read(ActivityId,Opaque,Tab,SecondaryKey,Attr,LockKind)</target>
        </trans-unit>
        <trans-unit id="405ecfd3752c77ca520244aedede4b5587dbac66" translate="yes" xml:space="preserve">
          <source>AccessMod:last(ActivityId, Opaque, Tab)</source>
          <target state="translated">AccessMod:last(ActivityId,Opaque,Tab)</target>
        </trans-unit>
        <trans-unit id="0fe0be60df449ead6d34747d5036ed4f5deeb071" translate="yes" xml:space="preserve">
          <source>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</source>
          <target state="translated">AccessMod:lock(ActivityId,Opaque,LockItem,LockKind)</target>
        </trans-unit>
        <trans-unit id="7f89b76e80a1cb03dd0d79dad619cfd7ed1b75a0" translate="yes" xml:space="preserve">
          <source>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</source>
          <target state="translated">AccessMod:match_object(ActivityId,Opaque,Tab,Pattern,LockKind)</target>
        </trans-unit>
        <trans-unit id="2eb39b70c8643684acb852d676bca64e66ecf08b" translate="yes" xml:space="preserve">
          <source>AccessMod:next(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:next(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="377e160f1491a996cf09b6412ddf1f19b01e4596" translate="yes" xml:space="preserve">
          <source>AccessMod:prev(ActivityId, Opaque, Tab, Key)</source>
          <target state="translated">AccessMod:prev(ActivityId,Opaque,Tab,Key)</target>
        </trans-unit>
        <trans-unit id="3240408ebba47649936190643d81115a2facdad7" translate="yes" xml:space="preserve">
          <source>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</source>
          <target state="translated">AccessMod:read(ActivityId,Opaque,Tab,Key,LockKind)</target>
        </trans-unit>
        <trans-unit id="f4ae75249d02d33c6b19d3db539b11ddf2e8c3b7" translate="yes" xml:space="preserve">
          <source>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</source>
          <target state="translated">AccessMod:table_info(ActivityId,Opaque,Tab,InfoItem)</target>
        </trans-unit>
        <trans-unit id="593b1df980f5bc3e0025a26bd60fd36b84ab2a86" translate="yes" xml:space="preserve">
          <source>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</source>
          <target state="translated">AccessMod:write(ActivityId,Opaque,Tab,Rec,LockKind)</target>
        </trans-unit>
        <trans-unit id="38bb0b3771b790d4a4246ea93a50f0538d3b9ae5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;Mnesia&lt;/code&gt; tables from a QLC list comprehension must always be done within a transaction. Consider the following function:</source>
          <target state="translated">从QLC列表理解访问 &lt;code&gt;Mnesia&lt;/code&gt; 表必须始终在事务内完成。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="d4e0ceeb0457db320ec7c5e806ad2aa7f79465dd" translate="yes" xml:space="preserve">
          <source>Accessing an entry beyond the last set entry also returns the default value, if the array does not have fixed size:</source>
          <target state="translated">如果数组没有固定的大小,那么访问超过最后一个设置的条目也会返回默认值。</target>
        </trans-unit>
        <trans-unit id="555bba9fd6c14d06717b8dc43b3cc1f3a8debed5" translate="yes" xml:space="preserve">
          <source>Accessing an unset entry returns default value:</source>
          <target state="translated">访问未设置的条目会返回默认值。</target>
        </trans-unit>
        <trans-unit id="436be26b911d05b439e447f05501826f189bbbef" translate="yes" xml:space="preserve">
          <source>According to good practices certificates should not use IP-addresses as &quot;server names&quot;. It would be very surprising if this happen outside a closed network.</source>
          <target state="translated">根据良好做法,证书不应使用IP地址作为 &quot;服务器名称&quot;。如果这种情况发生在封闭的网络之外,那将是非常令人惊讶的。</target>
        </trans-unit>
        <trans-unit id="89a4478d0cf104e90423519324b8b69d771bbee7" translate="yes" xml:space="preserve">
          <source>According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</source>
          <target state="translated">根据神话，使用尾部递归函数以反向构建列表，然后调用 &lt;code id=&quot;tail_recursive&quot;&gt;lists:reverse/1&lt;/code&gt; 比以身体递归函数以正确顺序构建列表要快；原因是身体递归函数比尾递归函数使用更多的内存。</target>
        </trans-unit>
        <trans-unit id="2c1de79f36acb95726c8b2c2f40931be25c53188" translate="yes" xml:space="preserve">
          <source>Accounting</source>
          <target state="translated">Accounting</target>
        </trans-unit>
        <trans-unit id="576eaeceb1da93e9cd8653f97cabbf793c67007b" translate="yes" xml:space="preserve">
          <source>Accounting AVP Table</source>
          <target state="translated">会计AVP表</target>
        </trans-unit>
        <trans-unit id="76507b1aa8142b5faffaa0f07c625ec43966a2b9" translate="yes" xml:space="preserve">
          <source>Accounting AVPs</source>
          <target state="translated">会计助理检察官</target>
        </trans-unit>
        <trans-unit id="9a7ff18e07e31b5c000920070a2994c9d40115bb" translate="yes" xml:space="preserve">
          <source>Accounting Application Extension and Requirements</source>
          <target state="translated">会计应用推广及要求</target>
        </trans-unit>
        <trans-unit id="e635c0e384e30717aefe63c449ad41cb13b32539" translate="yes" xml:space="preserve">
          <source>Accounting Command Codes</source>
          <target state="translated">会计命令代码</target>
        </trans-unit>
        <trans-unit id="50de3db981430abf69687c31bfddbc582f239b78" translate="yes" xml:space="preserve">
          <source>Accounting Records</source>
          <target state="translated">会计记录</target>
        </trans-unit>
        <trans-unit id="44b909aba948aa304a039b3c325904ad3054b180" translate="yes" xml:space="preserve">
          <source>Accounting Session State Machine</source>
          <target state="translated">会计会话状态机</target>
        </trans-unit>
        <trans-unit id="c15004aaef4f7a17d065e02f132efa0a95238fb5" translate="yes" xml:space="preserve">
          <source>Accounting is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">核算是用户的责任:直径不实现这个状态机。</target>
        </trans-unit>
        <trans-unit id="3abb791315e4021643390d032dcd3ee861202b30" translate="yes" xml:space="preserve">
          <source>Accounting-Answer</source>
          <target state="translated">Accounting-Answer</target>
        </trans-unit>
        <trans-unit id="348fbc285b20d73c4251ffc831b8fc2daa3046c1" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP</source>
          <target state="translated">会计-实时-所需AVP</target>
        </trans-unit>
        <trans-unit id="4913676d8f98f760d1dc436d2423796cf2783306" translate="yes" xml:space="preserve">
          <source>Accounting-Realtime-Required AVP Values</source>
          <target state="translated">会计-实时-要求的AVP值</target>
        </trans-unit>
        <trans-unit id="a41e3ac9cf5023d32cd91b4a3e716042b6c367b5" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Number AVP</source>
          <target state="translated">会计-记录-编号AVP</target>
        </trans-unit>
        <trans-unit id="b804c4b652a1521f5cb9135277fefe013043b5f6" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP</source>
          <target state="translated">会计-记录-类型AVP</target>
        </trans-unit>
        <trans-unit id="8df79aebdffebcd5564a4906eb6116d78fd976e9" translate="yes" xml:space="preserve">
          <source>Accounting-Record-Type AVP Values</source>
          <target state="translated">会计-记录-类型AVP值</target>
        </trans-unit>
        <trans-unit id="3f4954249bb9c6c0d9946303733718179dac9afc" translate="yes" xml:space="preserve">
          <source>Accounting-Request</source>
          <target state="translated">Accounting-Request</target>
        </trans-unit>
        <trans-unit id="cb2f33108011b0c4743b447ccd4a9acfb53d2777" translate="yes" xml:space="preserve">
          <source>Accounting-Sub-Session-Id AVP</source>
          <target state="translated">会计-子会议-ID AVP</target>
        </trans-unit>
        <trans-unit id="356f92ff6ca6eed8d6a653c61fd409eb10ae68df" translate="yes" xml:space="preserve">
          <source>Accounting-related messages and AVPs are defined in provided dictionaries. Their proper use is the user's responsibility.</source>
          <target state="translated">与会计有关的信息和AVPs在所提供的字典中定义。用户有责任正确使用它们。</target>
        </trans-unit>
        <trans-unit id="4b31db96c0a841f9a7113ac5bbc52a214e1829fa" translate="yes" xml:space="preserve">
          <source>Acct-Application-Id AVP</source>
          <target state="translated">Acct-Application-Id AVP</target>
        </trans-unit>
        <trans-unit id="4cabe3c0597d0d6af37709b22cdb0a59a5dae54e" translate="yes" xml:space="preserve">
          <source>Acct-Interim-Interval AVP</source>
          <target state="translated">会计临时间隔AVP</target>
        </trans-unit>
        <trans-unit id="1e0b1bf1afd755a9ceed94d413ee8713ddf31cc4" translate="yes" xml:space="preserve">
          <source>Acct-Multi-Session-Id AVP</source>
          <target state="translated">帐户-多环节-ID AVP</target>
        </trans-unit>
        <trans-unit id="73a3b6a3e03bc80ba04f6bde167f6434da42cc10" translate="yes" xml:space="preserve">
          <source>Acct-Session-Id AVP</source>
          <target state="translated">帐户-会话-ID AVP</target>
        </trans-unit>
        <trans-unit id="1a968060d9b2a6b964d729cfbd1eea55cfdc2c19" translate="yes" xml:space="preserve">
          <source>Accumulated waiting time for this lock. This could be greater than actual wall clock time, it is accumulated for all threads. Trylock conflicts does not accumulate time.</source>
          <target state="translated">这个锁的累计等待时间。这个时间可能大于实际的挂钟时间,它是所有线程的累积时间。Trylock冲突不累计时间。</target>
        </trans-unit>
        <trans-unit id="d9ecd9efddc0ef5836c8bbbde646a0d66732f097" translate="yes" xml:space="preserve">
          <source>Accumulates cover results over multiple tests. See section &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; in the Users's Guide.</source>
          <target state="translated">累积多个测试的覆盖结果。请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;cover_chapter#cross_cover&quot;&gt;Cross Cover Analysis&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="be2701277b8bc3bbce61a03a361606bf878d1187" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 精度和精确度</target>
        </trans-unit>
        <trans-unit id="875e7dcdc327d43caf0dcdf9d04b310d14d9feaf" translate="yes" xml:space="preserve">
          <source>Accuracy and precision of &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 准确性和精确度</target>
        </trans-unit>
        <trans-unit id="58eae709361b11b3ca7bd3fc358b5d94391cf26b" translate="yes" xml:space="preserve">
          <source>Acknowledges the start of the port.</source>
          <target state="translated">确认端口的启动。</target>
        </trans-unit>
        <trans-unit id="788233b34a130f2756fb1eaafa64431bb5c3d2da" translate="yes" xml:space="preserve">
          <source>Acknowledgment of a successful TLS handshake. &lt;code&gt;Ref&lt;/code&gt; is the reference() received in the &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; message in response to which the reply is sent. A transport must exit if a handshake is not successful.</source>
          <target state="translated">TLS握手成功的确认。 &lt;code&gt;Ref&lt;/code&gt; 是在 &lt;code&gt;{diameter, {tls, Ref, Type, Bool}}&lt;/code&gt; 消息中收到的reference（），响应是对此发送回复。如果握手失败，则传输必须退出。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
