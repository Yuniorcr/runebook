<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="96944a938969e87b4c95a2f4e616168d80a2498e" translate="yes" xml:space="preserve">
          <source>This function is prefered to the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; since it also uses the peer host port number and may return an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f73d9ee417d276ccc051fe8c7286c91cdfa3ca2" translate="yes" xml:space="preserve">
          <source>This function is prefered to the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; since it also uses the peer host port number and may return an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cecf54e230f7f661ec7cac637bf313533f3b79" translate="yes" xml:space="preserve">
          <source>This function is primarily intended for debugging purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f026cbf93039d50d6677012488768de3756669" translate="yes" xml:space="preserve">
          <source>This function is primarily intended for debugging purpose. It is not recommended to print very large terms with &lt;code&gt;%T&lt;/code&gt;. The function may change &lt;code&gt;errno&lt;/code&gt;, even if successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c84159cb077e05ce5ab18f138db97ded3cd0f6a" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in load regulation scenarios.</source>
          <target state="translated">这个功能主要是在负荷调节的情况下有用。</target>
        </trans-unit>
        <trans-unit id="6d1c283b0d188ab1dc083d2737684fc3b5d9bcb5" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in testing/debugging scenarios.</source>
          <target state="translated">该功能主要用于测试/调试场景。</target>
        </trans-unit>
        <trans-unit id="11584ee6be5c439d09214f1f99df3af124d2da3b" translate="yes" xml:space="preserve">
          <source>This function is probably mainly useful when called from outside of Erlang, for example from a driver written in C.</source>
          <target state="translated">这个函数可能主要是在从Erlang以外的地方调用时有用,比如从C语言编写的驱动中调用。</target>
        </trans-unit>
        <trans-unit id="4f09fd5f852628b21d18838bb6ca42850a7a35b0" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt; length work&lt;/a&gt;&lt;/code&gt; into a number of repeated NIF calls without the need to create threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353504af3c988d4810cedc709216e313aaafe762" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; into a number of repeated NIF calls without the need to create threads.</source>
          <target state="translated">提供此功能是为了更好地支持协作调度，提高系统响应速度，并更容易防止由于NIF独占调度程序线程而导致的VM异常行为。它可以用于将 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; 划分为多个重复的NIF调用，而无需创建线程。</target>
        </trans-unit>
        <trans-unit id="5db90f14f3c432301e447b05ad0cb6592973631a" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and to make it easier to prevent misbehaviors of the VM because of a port monopolizing a scheduler thread. It can be used when dividing lengthy work into some repeated driver callback calls, without the need to use threads.</source>
          <target state="translated">提供这个功能的目的是为了更好的支持协同调度,提高系统响应速度,并且更容易防止因为某个端口垄断调度线程而导致虚拟机的错误行为。当把冗长的工作分成一些重复的驱动回调调用时,可以使用这个功能,而不需要使用线程。</target>
        </trans-unit>
        <trans-unit id="3bd60d1367a2a2c9bf42897b1642d4f588cea06f" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">在应用程序代码中很少需要此功能。Mnesia使用它来提供分布式 &lt;code&gt;select/3&lt;/code&gt; 和 &lt;code&gt;select/1&lt;/code&gt; 序列。普通应用程序将使用Mnesia或避免将延续文件转换为外部格式。</target>
        </trans-unit>
        <trans-unit id="5802ba7a3becc5d64b340383668b0fe991f19bfe" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by application Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">在应用程序代码中很少需要此功能。应用程序Mnesia使用它来提供分布式 &lt;code&gt;select/3&lt;/code&gt; 和 &lt;code&gt;select/1&lt;/code&gt; 序列。普通应用程序将使用Mnesia或避免将延续文件转换为外部格式。</target>
        </trans-unit>
        <trans-unit id="650535937ca4ee466c191b80e09fe3d66b3c7b8e" translate="yes" xml:space="preserve">
          <source>This function is retained for backward compatibility. Function &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; is usually more convenient.</source>
          <target state="translated">保留此功能是为了向后兼容。函数 &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; 通常更方便。</target>
        </trans-unit>
        <trans-unit id="6fd26f567334e9666b6ef2abb401ce9925581958" translate="yes" xml:space="preserve">
          <source>This function is retained for compatibility with code generated by the interface compiler and with code following examples in the same application.</source>
          <target state="translated">为了与接口编译器生成的代码以及在同一应用程序中跟随示例的代码兼容,保留了这个函数。</target>
        </trans-unit>
        <trans-unit id="2ec3a9c47a6657144eaa21b3b30c6a1d0a500e42" translate="yes" xml:space="preserve">
          <source>This function is retired in favour for &lt;code&gt;Module:add_host_key/4&lt;/code&gt; which is the prefered API function. The calling SSH application will still try the &lt;code&gt;add_host_key/3&lt;/code&gt; if the call to &lt;code&gt;add_host_key/4&lt;/code&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e78105846a08290dcf6601bbb2dd5b4df92b17b" translate="yes" xml:space="preserve">
          <source>This function is retired in favour for &lt;code&gt;Module:is_host_key/5&lt;/code&gt; which is the prefered API function. The calling SSH application will still try the &lt;code&gt;is_host_key/4&lt;/code&gt; if the call to &lt;code&gt;is_host_key/5&lt;/code&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dbb81151f11a2a8e21a08672e2edd99a02d468" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;init:stop()&lt;/code&gt;, that is, it causes the node to stop in a controlled fashion.</source>
          <target state="translated">此函数是 &lt;code&gt;init:stop()&lt;/code&gt; 的简写形式，即，它导致节点以受控方式停止。</target>
        </trans-unit>
        <trans-unit id="4e31e42d4190f9153fc006e0f381fb267c91b114" translate="yes" xml:space="preserve">
          <source>This function is synchronous, which means that it will return when the discovery process has been completed or failed.</source>
          <target state="translated">这个函数是同步的,也就是说,当发现过程完成或失败时,它将返回。</target>
        </trans-unit>
        <trans-unit id="150a92472ac42c9c7a48db8f21312fa587e954eb" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;code&gt;&lt;a href=&quot;#getaddrinfo-1&quot;&gt;getaddrinfo&lt;/a&gt;&lt;/code&gt;. It converts a socket address to a corresponding host and service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b12149d93ef786b7d3d69bbe25e8a31d0409df0" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;code&gt;&lt;a href=&quot;#getnameinfo-1&quot;&gt;getnameinfo&lt;/a&gt;&lt;/code&gt;. It converts host and service to a corresponding socket address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e3218f152791a8b7bcc054591cf10cd806a3e6" translate="yes" xml:space="preserve">
          <source>This function is the only way for a driver to send data to &lt;strong&gt;other&lt;/strong&gt; processes than the port owner process. Parameter &lt;code&gt;receiver&lt;/code&gt; specifies the process to receive the data.</source>
          <target state="translated">该功能是驱动程序将数据发送到端口所有者进程以外的&lt;strong&gt;其他&lt;/strong&gt;进程的唯一方法。参数 &lt;code&gt;receiver&lt;/code&gt; 指定接收数据的过程。</target>
        </trans-unit>
        <trans-unit id="5d488a4d40159f9a0721dbdd5dad71579d3aee31" translate="yes" xml:space="preserve">
          <source>This function is thread-safe.</source>
          <target state="translated">这个功能是线程安全的。</target>
        </trans-unit>
        <trans-unit id="b9706d58a2352e8890b72cebf3416ed3ffff9ffe" translate="yes" xml:space="preserve">
          <source>This function is to be repeatedly called, while it returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;.</source>
          <target state="translated">该函数将被重复调用，同时返回 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe9a923027f6092daec4890f5b0a9af15bfddae" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;code&gt;erl_interface&lt;/code&gt; to create the Mnesia table if it does not already exist.</source>
          <target state="translated">&lt;code&gt;erl_interface&lt;/code&gt; 使用此函数创建Mnesia表（如果尚不存在）。</target>
        </trans-unit>
        <trans-unit id="e0ea944547ae0efb5c6ac097415a9890edb2fa66" translate="yes" xml:space="preserve">
          <source>This function is used by a process module to take care of system messages. The process receives a &lt;code&gt;{system, From, Msg}&lt;/code&gt; message and passes &lt;code&gt;Msg&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; to this function.</source>
          <target state="translated">处理模块使用此功能来处理系统消息。进程接收 &lt;code&gt;{system, From, Msg}&lt;/code&gt; 消息，并将 &lt;code&gt;Msg&lt;/code&gt; 和 &lt;code&gt;From&lt;/code&gt; 传递给此函数。</target>
        </trans-unit>
        <trans-unit id="e2a112b495b39abcd5586ec3664e29d01231ac87" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to accept a connection from a client process.</source>
          <target state="translated">这个函数被服务器进程用来接受来自客户端进程的连接。</target>
        </trans-unit>
        <trans-unit id="898bb0d30e504dc801429a9370b05b766f512338" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling this function, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">服务器进程使用此功能向本地名称服务器EPMD注册，从而允许其他进程使用注册的名称发送消息。在调用此函数之前，进程应在打开的套接字上调用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;listen()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70ccee3033b802a87c1b5086a81572b1cdf9f072" translate="yes" xml:space="preserve">
          <source>This function is used by drivers to provide the emulator with events to check for. This enables the emulator to call the driver when something has occurred asynchronously.</source>
          <target state="translated">这个函数被驱动程序用来为仿真器提供事件检查。这使得仿真器能够在异步事件发生时调用驱动程序。</target>
        </trans-unit>
        <trans-unit id="563d0e5f94af6836101c3632fc208eb6264d3ee8" translate="yes" xml:space="preserve">
          <source>This function is used by functions &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; to present process information.</source>
          <target state="translated">功能 &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; 使用此功能来显示过程信息。</target>
        </trans-unit>
        <trans-unit id="73986afc84809f75a6e12a693ebaed3b04b098c2" translate="yes" xml:space="preserve">
          <source>This function is used by the &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; function to prepare a document before being laid out as text.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; 函数使用此功能在将其布置为文本之前准备文档。</target>
        </trans-unit>
        <trans-unit id="af91dcbbafd0b245aac20abd673102bff806bdf0" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active TPKT connection.</source>
          <target state="translated">该功能用于关闭活动的 TPKT 连接。</target>
        </trans-unit>
        <trans-unit id="341959533bbd5fb6c13fba9bb6518b33337f67e1" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active UDP socket.</source>
          <target state="translated">该函数用于关闭一个活动的UDP套接字。</target>
        </trans-unit>
        <trans-unit id="c203b5dc275784f420edfae2f16a2aed1ae6aa56" translate="yes" xml:space="preserve">
          <source>This function is used for starting new TPKT listening socket for TCP/IP. The option list contains the socket definitions.</source>
          <target state="translated">该函数用于启动新的TCP/IP的TPKT监听套接字。选项列表包含套接字的定义。</target>
        </trans-unit>
        <trans-unit id="77b263a5f923ead126acb1e02db37792ff404de1" translate="yes" xml:space="preserve">
          <source>This function is used for starting the TCP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">该函数用于启动TCP/IP传输服务。使用exit(TransportRef,Reason)来停止传输服务。</target>
        </trans-unit>
        <trans-unit id="03f7bc8e389fa4c3de41f19125ec838b559c7fc6" translate="yes" xml:space="preserve">
          <source>This function is used for starting the UDP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">该函数用于启动UDP/IP传输服务。使用exit(TransportRef,Reason)可以停止传输服务。</target>
        </trans-unit>
        <trans-unit id="8eb43517a5b84f85e08e21015c8ab03e885b41f1" translate="yes" xml:space="preserve">
          <source>This function is used for stepping over one or more encoded terms in a buffer, to directly access later term.</source>
          <target state="translated">该函数用于跳过缓冲区中的一个或多个编码术语,直接访问后面的术语。</target>
        </trans-unit>
        <trans-unit id="9487b4eae0bc40d60b1b4e845725399492924f17" translate="yes" xml:space="preserve">
          <source>This function is used in conjunction with the monitor function.</source>
          <target state="translated">本功能与显示器功能配合使用。</target>
        </trans-unit>
        <trans-unit id="2f9f35e4a07c284d87e14bf146829705627cc610" translate="yes" xml:space="preserve">
          <source>This function is used to change the megaco trace level.</source>
          <target state="translated">该功能用于改变Megaco跟踪级别。</target>
        </trans-unit>
        <trans-unit id="2fe77e313940172591551e60898f1f31caf15867" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function must be invoked repeatedly until a reply is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0589fc6f384589ed19cac5275eb2aa5617dc52" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c0870f45ffc4ca4a9ca9e31e399ae3114cd98e" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9905970e8ef361713ff0dc6a231017daa7b1f422" translate="yes" xml:space="preserve">
          <source>This function is used to convert a socket_handle() to a inet_socket(). inet_socket() is a plain socket, see the inet module for more info.</source>
          <target state="translated">这个函数用于将socket_handle()转换为inet_socket()。 inet_socket()是一个普通的socket,更多信息请参见inet模块。</target>
        </trans-unit>
        <trans-unit id="872fb743adffaedcd340beb243b7412272596a11" translate="yes" xml:space="preserve">
          <source>This function is used to do a control operation on the active trace port driver on the given node (&lt;code&gt;Nodename&lt;/code&gt;). Which operations are allowed as well as their return values depend on which trace driver is used.</source>
          <target state="translated">此功能用于在给定节点（ &lt;code&gt;Nodename&lt;/code&gt; ）上的活动跟踪端口驱动程序上执行控制操作。允许哪些操作以及它们的返回值取决于所使用的跟踪驱动程序。</target>
        </trans-unit>
        <trans-unit id="322561e5d565d22195eae197df02cf59dd3cfda9" translate="yes" xml:space="preserve">
          <source>This function is used to flush the internal buffers held by a trace port driver. Currently only the file trace driver supports this operation. Returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">此功能用于刷新跟踪端口驱动程序所拥有的内部缓冲区。当前，只有文件跟踪驱动程序支持此操作。返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34e95da5a86e41022a5ff2d5944cdec50a72a3f2" translate="yes" xml:space="preserve">
          <source>This function is used to get the machines interface addresses, possibly filtered according to &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09103efe5f0276f6c79d552dc6e48c891087e8e" translate="yes" xml:space="preserve">
          <source>This function is used to open a TPKT connection.</source>
          <target state="translated">该功能用于打开TPKT连接。</target>
        </trans-unit>
        <trans-unit id="757eb6e7834e636a4181b74283f0227f0e2ffefa" translate="yes" xml:space="preserve">
          <source>This function is used to open an UDP/IP socket.</source>
          <target state="translated">该功能用于打开一个UDP/IP套接字。</target>
        </trans-unit>
        <trans-unit id="810c1759ff4f2ee4359ad6e55e1e0716e8de8e16" translate="yes" xml:space="preserve">
          <source>This function is used to perform pattern matching similar to that done in Erlang. For matching rules and more examples, see section &lt;code&gt;Pattern Matching&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">该功能用于执行模式匹配，类似于在Erlang中进行的模式匹配。有关匹配规则和更多示例，请参见《 Erlang参考手册》中的&amp;ldquo; &lt;code&gt;Pattern Matching&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="8225c2b0b7a823b2c3db31843555cf08b0b1c58a" translate="yes" xml:space="preserve">
          <source>This function is used to reset (disable) trace for the given module(s).</source>
          <target state="translated">该函数用于重置(禁用)指定模块的跟踪。</target>
        </trans-unit>
        <trans-unit id="5e4eb0cb134962fb3cf2970562621b143268d3f7" translate="yes" xml:space="preserve">
          <source>This function is used to set up default trace on function(s) for the given module or modules. The scope of the trace will be all &lt;strong&gt;exported&lt;/strong&gt; functions (both the call info and the return value). Timestamp info will also be included.</source>
          <target state="translated">此功能用于为给定的一个或多个模块设置功能的默认跟踪。跟踪的范围将是所有&lt;strong&gt;导出的&lt;/strong&gt;函数（调用信息和返回值）。时间戳信息也将包括在内。</target>
        </trans-unit>
        <trans-unit id="cb8a8d71cb3f7af3283d816d0841f08d24b9568d" translate="yes" xml:space="preserve">
          <source>This function is used to set up trace on function(s) for the given module or modules.</source>
          <target state="translated">该函数用于为给定模块设置函数的跟踪。</target>
        </trans-unit>
        <trans-unit id="03c0831d3d5485f7597cd0b7a56cfb11e2d8d606" translate="yes" xml:space="preserve">
          <source>This function is used to start megaco tracing at a given &lt;code&gt;Level&lt;/code&gt; and direct result to the given &lt;code&gt;Destination&lt;/code&gt;.</source>
          <target state="translated">此函数用于在给定的 &lt;code&gt;Level&lt;/code&gt; 开始megaco跟踪，并将结果定向到给定的 &lt;code&gt;Destination&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5198a41fa4397f2b825350859ef9349761d440d3" translate="yes" xml:space="preserve">
          <source>This function is used to start the flex scanner. It locates the library and loads the linked in driver.</source>
          <target state="translated">该函数用于启动柔性扫描仪。它定位库并加载链接的驱动程序。</target>
        </trans-unit>
        <trans-unit id="9cbb65fd2f2f55ed5a8fdfcfbb54dede2d39cbef" translate="yes" xml:space="preserve">
          <source>This function is used to stop megaco tracing.</source>
          <target state="translated">该功能用于停止Megaco追踪。</target>
        </trans-unit>
        <trans-unit id="aa9a7f11a1203465f0dab2a3fff9289e46f67958" translate="yes" xml:space="preserve">
          <source>This function is used to stop the flex scanner. It also unloads the driver.</source>
          <target state="translated">该功能用于停止柔性扫描仪。它还可以卸载驱动程序。</target>
        </trans-unit>
        <trans-unit id="e8a075a6ae0116d88a212adb66cf154d84ef51cc" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;gen_server&lt;/code&gt; process. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518ba4fb55f90139dcdab88d5abe032b9b970f77" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt; process. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbf7b175bd6a91d71de3da23ac87dc3b0142537" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; from the event manager. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1834d21edb25fe321739aff4973157dc0f8ba281" translate="yes" xml:space="preserve">
          <source>This function is used when implementing an alternative distribution carrier using processes as distribution controllers. &lt;code&gt;DHandle&lt;/code&gt; is retrived via the callback &lt;code&gt;f_handshake_complete&lt;/code&gt;. More information can be found in the documentation of &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt;.</source>
          <target state="translated">当使用流程作为分发控制器来实现备用分发载体时，将使用此功能。 &lt;code&gt;DHandle&lt;/code&gt; 通过回调retrived &lt;code&gt;f_handshake_complete&lt;/code&gt; 。可在《 &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt; 的文档中找到更多信息。</target>
        </trans-unit>
        <trans-unit id="44824ba63eb3b307aabd6873ec5a1a332b6ba401" translate="yes" xml:space="preserve">
          <source>This function is used when segmentation has been configured. So, for this to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">配置了分段后，将使用此功能。因此，要使其正常工作，&lt;strong&gt;必须&lt;/strong&gt;完全支持此功能！</target>
        </trans-unit>
        <trans-unit id="12a35f0dbe51b5e3f1ecec001171f5281b1d71b2" translate="yes" xml:space="preserve">
          <source>This function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">此功能可用作开发和测试期间的快捷方式，但不得在生产系统中使用。有关如何为实时系统配置Logger的信息，请参见《内核用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 部分和 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="0e08d85e1b9bab386f133ff706c8c19be0cec717" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_server&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value, as well as how its status appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current status of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">对于这些情况，此功能对于更改 &lt;code&gt;gen_server&lt;/code&gt; 状态的形式和外观很有用。希望更改 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回值以及其状态如何出现在终止错误日志中的回调模块，将导出 &lt;code&gt;format_status/2&lt;/code&gt; 实例，该实例返回一个描述 &lt;code&gt;gen_server&lt;/code&gt; 进程当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="09f573635e783a4ad23c419f9139aab803708c3f" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_statem&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value and how its status appears in termination error logs exports an instance of &lt;code&gt;format_status/2&lt;/code&gt;, which returns a term describing the current status of the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">对于这些情况，此功能对于更改 &lt;code&gt;gen_statem&lt;/code&gt; 状态的形式和外观很有用。希望更改 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 返回值以及其状态如何在终止错误日志中显示的回调模块将导出 &lt;code&gt;format_status/2&lt;/code&gt; 的实例，该实例返回一个描述 &lt;code&gt;gen_statem&lt;/code&gt; 当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="b7792553fb70da23062b7be9ff4e7b99b4bb7f20" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the event handler state for these cases. An event handler callback module wishing to change the the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value as well as how its state appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current state of the event handler.</source>
          <target state="translated">对于这些情况，此功能对于更改事件处理程序状态的形式和外观很有用。希望更改 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 返回值以及其状态在终止错误日志中的显示方式的事件处理程序回调模块，导出 &lt;code&gt;format_status/2&lt;/code&gt; 的实例，该实例返回描述事件处理程序当前状态的术语。</target>
        </trans-unit>
        <trans-unit id="610385401f6f02f433fd707df3e351fe5fa74f60" translate="yes" xml:space="preserve">
          <source>This function is useful if coverage data from different systems is to be merged.</source>
          <target state="translated">如果要合并来自不同系统的覆盖数据,该功能非常有用。</target>
        </trans-unit>
        <trans-unit id="98a04423b1194d9a1f5fa9b90393dfa8d11918f4" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_server&lt;/code&gt; process behavior provides.</source>
          <target state="translated">当需要比 &lt;code&gt;gen_server&lt;/code&gt; 进程行为提供的复杂的初始化过程时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="8e0b171472c534adf0757b7201fbb51bc8b8ffd0" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_statem&lt;/code&gt; behavior provides.</source>
          <target state="translated">当需要比 &lt;code&gt;gen_statem&lt;/code&gt; 行为提供的复杂的初始化过程时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="cea361e65fc7577a23ace8db8f6fec22077e2877" translate="yes" xml:space="preserve">
          <source>This function is usefull for flow control.</source>
          <target state="translated">该功能适用于流量控制。</target>
        </trans-unit>
        <trans-unit id="eb2ddaa9fc04efddf630666c492e456ec637176e" translate="yes" xml:space="preserve">
          <source>This function makes sure the engine is loaded just once and the ID is added to the internal engine list of OpenSSL. The following calls to the function will check if the ID is loaded and then just get a new reference to the engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46b30ae03aba38f2d6dbaebe599182eb938575a" translate="yes" xml:space="preserve">
          <source>This function may return an updated &lt;code&gt;NewExtraInfo&lt;/code&gt; that will be used in subsequent calls to the callback functions. Intended for future use.</source>
          <target state="translated">此函数可能返回更新的 &lt;code&gt;NewExtraInfo&lt;/code&gt; ，将在后续对回调函数的调用中使用。供将来使用。</target>
        </trans-unit>
        <trans-unit id="0ffae6b0af7395d12b556d9a92b8b8453169f33e" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数可能恰好返回 &lt;code&gt;0.0&lt;/code&gt; ，这对于某些应用程序可能是致命的。如果不希望这样，则可以使用 &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; 来获取时间间隔 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; ，或者使用 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca39a4b036275d0803e561bc49de6198f5110e47" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数可能恰好返回 &lt;code&gt;0.0&lt;/code&gt; ，这对于某些应用程序可能是致命的。如果不希望这样，可以使用 &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; 来获取时间间隔 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; ，或者改用 &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ce28b85ea3b55e10e44c23baa40c3964f84d6e" translate="yes" xml:space="preserve">
          <source>This function modifies the emulated environment used by &lt;code&gt;os:putenv/2&lt;/code&gt; and not the environment used by libc's &lt;code&gt;putenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;putenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">此函数修改 &lt;code&gt;os:putenv/2&lt;/code&gt; 所使用的仿真环境，而不是libc的 &lt;code&gt;putenv(3)&lt;/code&gt; 或类似环境所使用的环境。&lt;strong&gt;需要&lt;/strong&gt;同步的驱动程序将需要自己进行同步，但要记住，它们是有一定隔离的。 &lt;code&gt;putenv(3)&lt;/code&gt; 及其朋友&lt;strong&gt;不是线程安全的，&lt;/strong&gt;并且可能导致无关的代码行为异常或使模拟器崩溃。</target>
        </trans-unit>
        <trans-unit id="7d9bfad73b174be24fda46b6c6997bb2f07b83e7" translate="yes" xml:space="preserve">
          <source>This function must be called before any of the others in the &lt;code&gt;Erl_Interface&lt;/code&gt; library to initialize the library functions. The arguments must be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">在初始化 &lt;code&gt;Erl_Interface&lt;/code&gt; 库中的任何其他函数之前，必须先调用此函数。参数必须指定为 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebd9a39191cb32abe8a7e5735ecc342ac8656f1e" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will never return.</source>
          <target state="translated">必须通过与 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 相同的进程来调用此函数，否则它将永远不会返回。</target>
        </trans-unit>
        <trans-unit id="19959c57c9d15d692c85ae027062ec2bc955b6f2" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will only return &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">必须通过与 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 相同的进程来调用此函数，否则它将仅返回 &lt;code&gt;timeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb3502ac60b18fe8cef093c946cf825538bc7b7" translate="yes" xml:space="preserve">
          <source>This function must be called immediately after &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt;, before any call of &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">必须在 &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 之后立即调用此函数，然后再调用 &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b75dd99eca2ff3b13955cd576db05e608645330" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case (not executing in a parallel group) has called function &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在测试用例（不在并行组中执行）调用函数 &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt; 之后，必须继续调用此函数。</target>
        </trans-unit>
        <trans-unit id="05df078881db876012ab67fef726a729b94ff9d8" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case has called &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt;. If the paused test case, &lt;code&gt;TestCase&lt;/code&gt;, executes in a parallel group, this function, rather than &lt;code&gt;continue/0&lt;/code&gt;, must be used to let the test case proceed.</source>
          <target state="translated">测试用例 &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; 之后，必须继续调用此函数。如果暂停的测试用例 &lt;code&gt;TestCase&lt;/code&gt; 在并行组中执行，则必须使用此函数而不是 &lt;code&gt;continue/0&lt;/code&gt; 来使测试用例继续进行。</target>
        </trans-unit>
        <trans-unit id="df6ca91336232bf4dc1b262219129b2c8bee458f" translate="yes" xml:space="preserve">
          <source>This function must be used by a process that has been started by a &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; function. It tells &lt;code&gt;Parent&lt;/code&gt; that the process has initialized itself, has started, or has failed to initialize itself.</source>
          <target state="translated">必须由 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; 函数启动的进程使用此函数。它告诉 &lt;code&gt;Parent&lt;/code&gt; 进程已初始化，启动或初始化失败。</target>
        </trans-unit>
        <trans-unit id="4eb57f4a5bbafdd8247f55548e5ee187fd56dc8b" translate="yes" xml:space="preserve">
          <source>This function needs to be called as a transaction. Assume that you wish to write a function that both calls the function &lt;code&gt;add_subscriber/1&lt;/code&gt; and is in itself protected by the context of a transaction. By calling &lt;code&gt;add_subscriber/1&lt;/code&gt; from within another transaction, a nested transaction is created.</source>
          <target state="translated">此功能需要作为事务调用。假设您希望编写一个既调用 &lt;code&gt;add_subscriber/1&lt;/code&gt; 函数又受事务上下文保护的函数。通过从另一个事务中调用 &lt;code&gt;add_subscriber/1&lt;/code&gt; ，将创建一个嵌套事务。</target>
        </trans-unit>
        <trans-unit id="17d0fec42839f72178e4fd55a2c5164e6b9bf6ce" translate="yes" xml:space="preserve">
          <source>This function only succeeds in platforms that provide this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb288dde170ca25e8a4e8d2927079c35992755a" translate="yes" xml:space="preserve">
          <source>This function only succeeds in platforms that provide this feature. When it succeeds, space is preallocated for the file but the file size might not be updated. This behaviour depends on the preallocation implementation. To guarantee that the file size is updated, truncate the file to the new size.</source>
          <target state="translated">此功能只有在提供此功能的平台上才会成功。当它成功时,文件的空间会被预分配,但文件大小可能不会被更新。这种行为取决于预分配的实现。为了保证文件大小得到更新,将文件截断为新的大小。</target>
        </trans-unit>
        <trans-unit id="b9d0851586e3645c6e0718dc09f5fec49d8fc898" translate="yes" xml:space="preserve">
          <source>This function performs the following transformation:</source>
          <target state="translated">该函数执行以下转换:</target>
        </trans-unit>
        <trans-unit id="681ee068d504344b07045ef0edae3fb7a6646520" translate="yes" xml:space="preserve">
          <source>This function prints all elements of a list onto a stream:</source>
          <target state="translated">该函数将列表中的所有元素打印到一个流中。</target>
        </trans-unit>
        <trans-unit id="826961bd42fe30f9ebbd7b4d33db709f59c3b696" translate="yes" xml:space="preserve">
          <source>This function produce the same encoding as &lt;code&gt;&lt;a href=&quot;#term_to_binary-1&quot;&gt;term_to_binary/1&lt;/a&gt;&lt;/code&gt;, but with another return type. The call &lt;code&gt;iolist_to_binary(term_to_iovec(Term))&lt;/code&gt; will produce exactly the same result as the call &lt;code&gt;term_to_binary(Term)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a527ff828c71994c974c257269fdedc8e4cd10" translate="yes" xml:space="preserve">
          <source>This function produce the same encoding as &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt;, but with another return type. The call &lt;code&gt;iolist_to_binary(term_to_iovec(Term, Opts))&lt;/code&gt; will produce exactly the same result as &lt;code&gt;term_to_binary(Term, Opts)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd07fdc0e97d4adf4e29f31e2cc86ba2b8eaea2" translate="yes" xml:space="preserve">
          <source>This function produces a list of information about the megaco application. Such as users and their config, connections and their config, statistics and so on.</source>
          <target state="translated">这个功能会产生一个关于megaco应用程序的信息列表,比如用户和他们的配置,连接和他们的配置,统计等等。比如用户和他们的配置,连接和他们的配置,统计数据等等。</target>
        </trans-unit>
        <trans-unit id="4aec40bb5deb9daace1e8128ff80ca5cbdbd3ab4" translate="yes" xml:space="preserve">
          <source>This function provides a low-level interface to the pretty printer, returning a flexible representation of possible layouts, independent of the paper width eventually to be used for formatting. This can be included as part of another document and/or further processed directly by the functions in the &lt;code&gt;prettypr&lt;/code&gt; module, or used in a hook function (see &lt;code&gt;format/2&lt;/code&gt; for details).</source>
          <target state="translated">此功能为漂亮的打印机提供了一个低级界面，返回了可能的布局的灵活表示形式，而与最终用于格式化的纸张宽度无关。这可以作为另一个文档的一部分包含和/或由 &lt;code&gt;prettypr&lt;/code&gt; 模块中的函数直接进行进一步处理，或在挂钩函数中使用（有关详细信息，请参阅 &lt;code&gt;format/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="292e6a8f5a93138af65b2381d7cdb5c0c6c34358" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. (The update is done atomically, that is, no process can access the ETS table in the middle of the operation.)</source>
          <target state="translated">这个函数提供了一种高效的方法来更新一个或多个计数器,而不需要麻烦地查找一个对象,通过增量元素来更新对象,并将得到的对象再次插入到表中。更新是以原子方式进行的,也就是说,没有任何进程可以在操作中间访问ETS表)。</target>
        </trans-unit>
        <trans-unit id="de1914d725b6a19d0c54d0cc47eafecc7c8a1cad" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. The operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9e675f31114737aa33341ede5a5aba5db53e0d" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more elements within an object, without the trouble of having to look up, update, and write back the entire object.</source>
          <target state="translated">该函数提供了一种有效的方法来更新对象中的一个或多个元素,而不需要查找、更新和回写整个对象。</target>
        </trans-unit>
        <trans-unit id="a2ad4c84411a21e47a169513c1d529c2c69b36bc" translate="yes" xml:space="preserve">
          <source>This function reads &quot;messages&quot;, which means that regardless of how much we want to read, it returns when we get a message (if the buffer size is too small, the message will be truncated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bfd8b3c8c6d13aec0aa1766324ac529d7e9c46" translate="yes" xml:space="preserve">
          <source>This function reads &quot;messages&quot;, which means that regardless of how much we want to read, it returns when we get a message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b5d7fcc798e3adcd6205abd49a5e2a97894217" translate="yes" xml:space="preserve">
          <source>This function reads match specifications from a file (possibly) generated by the &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; function. It checks the syntax of all match specifications and verifies that they are correct. The error handling principle is &quot;all or nothing&quot;, i. e. if some of the match specifications are wrong, none of the specifications are added to the list of saved match specifications for the running system.</source>
          <target state="translated">该函数从 &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 函数生成的文件（可能）中读取匹配规范。它检查所有匹配规范的语法并验证它们是否正确。错误处理原则是&amp;ldquo;全部或全部&amp;rdquo;，即如果某些匹配规范错误，则不会将任何规范添加到正在运行的系统的已保存匹配规范列表中。</target>
        </trans-unit>
        <trans-unit id="4c87d8b732e8491a29379bc4f4e018b87a77b776" translate="yes" xml:space="preserve">
          <source>This function reads the emulated environment used by &lt;code&gt;os:getenv/1&lt;/code&gt; and not the environment used by libc's &lt;code&gt;getenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;getenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">此函数读取 &lt;code&gt;os:getenv/1&lt;/code&gt; 所使用的仿真环境，而不读取libc的 &lt;code&gt;getenv(3)&lt;/code&gt; 或类似环境所使用的环境。&lt;strong&gt;需要&lt;/strong&gt;同步的驱动程序将需要自己进行同步，但要记住，它们是有一定隔离的。 &lt;code&gt;getenv(3)&lt;/code&gt; 及其朋友&lt;strong&gt;不是线程安全的，&lt;/strong&gt;并且可能导致无关的代码行为异常或使模拟器崩溃。</target>
        </trans-unit>
        <trans-unit id="10a11b74ad5663559d5b504d02b42b896b8198c8" translate="yes" xml:space="preserve">
          <source>This function requires root privileges to succeed.</source>
          <target state="translated">该功能需要root权限才能成功。</target>
        </trans-unit>
        <trans-unit id="d15610f3a7143920acbea774174ec7657558cf9c" translate="yes" xml:space="preserve">
          <source>This function retreives information about what the platform supports, such as if SCTP is supported, or which socket options are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e0d6537277d523e6c2dd7e69081c04d55238d6" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;Default&lt;/code&gt; if no term has been stored with the key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062c8ae0406bce16cb74fa7ee50a7f220f4495f9" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued through &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果服务器由于预期的原因终止，则此函数返回 &lt;code&gt;ok&lt;/code&gt; 。除了 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 之外的任何其他原因都会导致通过 &lt;code&gt;logger(3)&lt;/code&gt; 发出错误报告。默认的 &lt;code&gt;Reason&lt;/code&gt; 是 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b619b8eb3b06a0c1f9ee95ad936ded887fe9b1f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{continue | finished, Output}&lt;/code&gt;, where Output is the data that was decompressed in this call. New input can be queued up on each call if desired, and the function will return &lt;code&gt;{finished, Output}&lt;/code&gt; once all queued data has been decompressed.</source>
          <target state="translated">此函数返回 &lt;code&gt;{continue | finished, Output}&lt;/code&gt; ，其中Output是在此调用中解压缩的数据。如果需要，可以在每个调用中将新的输入排队，并且一旦所有排队的数据都已解压缩，该函数将返回 &lt;code&gt;{finished, Output}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fe5f1399ea4e26d1526efcdd913ad89693dd38c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;, when there is more output available, and &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; is to be used to read it.</source>
          <target state="translated">当有更多可用输出时 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 此函数返回{more，Decompressed}，并且将使用 &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; 来读取它。</target>
        </trans-unit>
        <trans-unit id="57c7b411ef596e9d3dc2dccd3a829fab7afcf559" translate="yes" xml:space="preserve">
          <source>This function returns a non-zero value if the time-slice has been exhausted, and zero if the callback is allowed to continue execution. If a non-zero value is returned, the driver callback is to return as soon as possible in order for the port to be able to yield.</source>
          <target state="translated">如果时间片已经耗尽,这个函数返回一个非零值,如果回调被允许继续执行,则返回零值。如果返回一个非零的值,则驱动回调应尽快返回,以使 port 能够屈服。</target>
        </trans-unit>
        <trans-unit id="b34ef5ebb7e9ff07df93e070c922fe104914c7bc" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; of the named table identified by &lt;code&gt;TableName&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if no such table exists. The &lt;code&gt;tid()&lt;/code&gt; can be used in place of the table name in all operations, which is slightly faster since the name does not have to be resolved on each call.</source>
          <target state="translated">此函数返回由 &lt;code&gt;TableName&lt;/code&gt; 标识的命名表的 &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; ，如果不存在这样的表，则返回 &lt;code&gt;undefined&lt;/code&gt; 。该 &lt;code&gt;tid()&lt;/code&gt; 来代替表名的所有操作，这稍微快一些，因为该名称不必在每次调用待解决使用。</target>
        </trans-unit>
        <trans-unit id="50dd77bc2f5d6e06a832906b2c12c471d8aa9340" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;Adler&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;Adler1&lt;/code&gt;, &lt;code&gt;Adler2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">该函数返回 &lt;code&gt;Adler&lt;/code&gt; 的校验和 &lt;code&gt;[Data1,Data2]&lt;/code&gt; ，只需要 &lt;code&gt;Adler1&lt;/code&gt; ， &lt;code&gt;Adler2&lt;/code&gt; ，和 &lt;code&gt;Size2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="254134ddf194a5bc8b6a55dc528e9535675c6294" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;CRC&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;CRC1&lt;/code&gt;, &lt;code&gt;CRC2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">该函数返回 &lt;code&gt;CRC&lt;/code&gt; 的校验和 &lt;code&gt;[Data1,Data2]&lt;/code&gt; ，只需要 &lt;code&gt;CRC1&lt;/code&gt; ， &lt;code&gt;CRC2&lt;/code&gt; ，和 &lt;code&gt;Size2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfe8f7ec0382a52a177f156ebe5c3e11685e6528" translate="yes" xml:space="preserve">
          <source>This function returns the default encoding for Erlang source files (if no encoding comment is present) in the currently running release. In Erlang/OTP R16B, &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) was returned. As from Erlang/OTP 17.0, &lt;code&gt;utf8&lt;/code&gt; is returned.</source>
          <target state="translated">此函数返回当前正在运行的发行版中Erlang源文件的默认编码（如果不存在编码注释）。在Erlang / OTP R16B中，返回了 &lt;code&gt;latin1&lt;/code&gt; （按字节编码）。从Erlang / OTP 17.0开始，返回 &lt;code&gt;utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ac5e4c95ff19314b1e92b03b1fbc6ddb4df1f4" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process or, if no user tag is present, the last user tag sent to the process together with a message (in the same way as &lt;code&gt;sequential trace tokens&lt;/code&gt; are spread to other processes together with messages. For an explanation of how user tags can be spread together with messages, see &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt;. If no tag is found or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">此函数返回在当前进程中设置的用户标签，或者，如果不存在用户标签，则返回发送到该进程的最后一个用户标签以及一条消息（与 &lt;code&gt;sequential trace tokens&lt;/code&gt; 与消息一起散布到其他进程的方式相同）。有关如何将用户标记与消息一起传播的说明，请参见 &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt; 。如果找不到标记或动态跟踪不可用，则它将返回 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad3f3a41d62bdc7c42feabe41234fd9722d7cb98" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process. If no tag is set or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">该函数返回当前进程中设置的用户标签。如果未设置标签或动态跟踪不可用，则返回 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="644324c7c6a31f16ffa3ae52932ba3909ce2be83" translate="yes" xml:space="preserve">
          <source>This function returns the verbosity level for the specified logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt; User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to read the general verbosity level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd79f4e47f62cf59b521bcb089167a8d5c5fd14f" translate="yes" xml:space="preserve">
          <source>This function returns the verbosity level for the specified logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to read the general verbosity level.</source>
          <target state="translated">此函数返回指定日志记录类别的详细级别。有关详细信息，请参见《 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 》。使用 &lt;code&gt;default&lt;/code&gt; 值读取常规详细程度。</target>
        </trans-unit>
        <trans-unit id="9213458608b1e7bf5d8b4e1a7eb828c4aad8ff78" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and a new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">此函数从字典返回值，而没有该值的新字典将返回该值。如果字典中不存在该键，则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf35b3402a76d292262e9d707c75231902c52bf" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">此函数从字典和新字典返回值，而没有该值。如果字典中不存在该键，则返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4620a951555900d51d4b19f86794013a12f92c5b" translate="yes" xml:space="preserve">
          <source>This function runs the measurement on all the &lt;strong&gt;official&lt;/strong&gt; codecs; pretty, compact, ber, per and erlang.</source>
          <target state="translated">此功能在所有&lt;strong&gt;官方&lt;/strong&gt;编解码器上运行测量；漂亮，紧凑，误码率，per和erlang。</target>
        </trans-unit>
        <trans-unit id="4d644d2c0042513fa733b8a7d873cf8a04730f5c" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to add the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:init([])&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;add_handler&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the event handler.</source>
          <target state="translated">此函数向注册为 &lt;code&gt;error_man&lt;/code&gt; 的事件管理器发送一条消息，告诉它添加事件处理程序 &lt;code&gt;terminal_logger&lt;/code&gt; 。事件管理器调用回调函数 &lt;code&gt;terminal_logger:init([])&lt;/code&gt; ，其中参数 &lt;code&gt;[]&lt;/code&gt; 是 &lt;code&gt;add_handler&lt;/code&gt; 的第三个参数。预期 &lt;code&gt;init&lt;/code&gt; 返回 &lt;code&gt;{ok, State}&lt;/code&gt; ，其中 &lt;code&gt;State&lt;/code&gt; 是事件处理程序的内部状态。</target>
        </trans-unit>
        <trans-unit id="9488c1c7cd2d72dbd05ee8b3a4cf579cbfcc3089" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to delete the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;delete_handler&lt;/code&gt;. &lt;code&gt;terminate&lt;/code&gt; is to be the opposite of &lt;code&gt;init&lt;/code&gt; and do any necessary cleaning up. Its return value is ignored.</source>
          <target state="translated">此函数向注册为 &lt;code&gt;error_man&lt;/code&gt; 的事件管理器发送一条消息，告诉它删除事件处理程序 &lt;code&gt;terminal_logger&lt;/code&gt; 。事件管理器调用回调函数 &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt; ，其中参数 &lt;code&gt;[]&lt;/code&gt; 是 &lt;code&gt;delete_handler&lt;/code&gt; 的第三个参数。 &lt;code&gt;terminate&lt;/code&gt; 与 &lt;code&gt;init&lt;/code&gt; 相反，并进行必要的清理。它的返回值被忽略。</target>
        </trans-unit>
        <trans-unit id="01064956f3c5f10087dfedd98caeabdab20043f6" translate="yes" xml:space="preserve">
          <source>This function sets the user tag of the current process. The user tag is a binary(), but can be specified as any iodata(), which is automatically converted to a binary by this function.</source>
          <target state="translated">该函数设置当前进程的用户标签。用户标签是二进制(),但也可以指定为任何iodata(),该函数会自动将其转换为二进制。</target>
        </trans-unit>
        <trans-unit id="61313460b8aa3e37c5b58b57b47f109e6ec0573c" translate="yes" xml:space="preserve">
          <source>This function sets up a subscription for NETCONF event notifications of the specified stream type, matching the specified filter. The calling process receives notifications as messages of type &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数为指定流类型的NETCONF事件通知设置订阅，与指定的过滤器匹配。调用过程接收通知，作为 &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt; 类型为notify（）的消息。</target>
        </trans-unit>
        <trans-unit id="ae2f0db4a2d6577440241530db91576d86c351bc" translate="yes" xml:space="preserve">
          <source>This function should be used by custom Logger handlers to make configuration consistent no matter which handler the system uses. Normal usage is to add a call to &lt;code&gt;logger:add_handlers/1&lt;/code&gt; just after the processes that the handler needs are started, and pass the application's &lt;code&gt;logger&lt;/code&gt; configuration as the argument. For example:</source>
          <target state="translated">定制Logger处理程序应使用此功能，以使配置一致，无论系统使用哪个处理程序。通常的用法是在处理程序所需的进程启动后立即添加对 &lt;code&gt;logger:add_handlers/1&lt;/code&gt; 的调用，并将应用程序的 &lt;code&gt;logger&lt;/code&gt; 配置作为参数传递。例如：</target>
        </trans-unit>
        <trans-unit id="f301b3f0b8c0209d0cf4fd9f62efd0855d383514" translate="yes" xml:space="preserve">
          <source>This function should be used whenever the &lt;code&gt;ScopedPDU&lt;/code&gt; is encrypted.</source>
          <target state="translated">每当对 &lt;code&gt;ScopedPDU&lt;/code&gt; 进行加密时，都应使用此功能。</target>
        </trans-unit>
        <trans-unit id="92119a39fe094fc4b7f2725a3cd542c77c8004c7" translate="yes" xml:space="preserve">
          <source>This function should be used with care!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6163aa7d8dcc271f09c1955760210bfef0a047d1" translate="yes" xml:space="preserve">
          <source>This function should only be used for micro-benchmarks; it sets &lt;code&gt;copy_save&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for the duration of the call, which can quickly lead to running out of memory.</source>
          <target state="translated">此功能应仅用于微基准测试；它将在整个调用过程 &lt;code&gt;copy_save&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，这会很快导致内存不足。</target>
        </trans-unit>
        <trans-unit id="378340ac7df7630dbeb8cb5d900d9bad24c77182" translate="yes" xml:space="preserve">
          <source>This function should, besides spawning the connection supervisor, also create a distribution controller. The distribution controller is either a process or a port which is responsible for dispatching traffic.</source>
          <target state="translated">这个函数除了生成连接监控器,还应该创建一个分发控制器。分布控制器可以是一个进程,也可以是一个端口,负责调度流量。</target>
        </trans-unit>
        <trans-unit id="d4d47d2b2af731fd5c9c26e6262581d877c04f00" translate="yes" xml:space="preserve">
          <source>This function shuts down a previously started trace client. The &lt;code&gt;Pid&lt;/code&gt; argument is the process id returned from the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">此功能关闭以前启动的跟踪客户端。所述 &lt;code&gt;Pid&lt;/code&gt; 参数是从返回进程id &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; 呼叫。</target>
        </trans-unit>
        <trans-unit id="1762fe9d329cecf345c08b9b7958cf3995f81b8e" translate="yes" xml:space="preserve">
          <source>This function spawns and links to a new process, an event manager.</source>
          <target state="translated">该函数生成并链接到一个新的进程,即事件管理器。</target>
        </trans-unit>
        <trans-unit id="550809e278a777ab2f212797a3d8588ff2bdddcd" translate="yes" xml:space="preserve">
          <source>This function starts a server on the local node that will be the recipient of all trace messages. All subsequent calls to &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; will result in messages sent to the newly started trace server.</source>
          <target state="translated">此功能在本地节点上启动服务器，该服务器将成为所有跟踪消息的收件人。对 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 的所有后续调用将导致消息发送到新启动的跟踪服务器。</target>
        </trans-unit>
        <trans-unit id="02bf735444f615dc9059203b498c83b1b1c490d8" translate="yes" xml:space="preserve">
          <source>This function starts a trace client that reads the output created by a trace port driver and handles it in mostly the same way as a tracer process created by the &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">此函数启动跟踪客户端，该客户端读取由跟踪端口驱动程序创建的输出，并以与 &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; 函数创建的跟踪进程几乎相同的方式处理该输出。</target>
        </trans-unit>
        <trans-unit id="71ed1ace1cba19901a1c4410fa55742720248a3e" translate="yes" xml:space="preserve">
          <source>This function starts a tracer server with additional parameters on the local node. The first parameter, the &lt;code&gt;Type&lt;/code&gt;, indicates if trace messages should be handled by a receiving process (&lt;code&gt;process&lt;/code&gt;), by a tracer port (&lt;code&gt;port&lt;/code&gt;) or by a tracer module (&lt;code&gt;module&lt;/code&gt;). For a description about tracer ports see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; and for a tracer modules see &lt;code&gt;erl_tracer&lt;/code&gt;.</source>
          <target state="translated">此功能使用本地节点上的其他参数启动跟踪服务器。第一个参数 &lt;code&gt;Type&lt;/code&gt; 指示是否应由接收进程（ &lt;code&gt;process&lt;/code&gt; ），跟踪器端口（ &lt;code&gt;port&lt;/code&gt; ）或跟踪器模块（ &lt;code&gt;module&lt;/code&gt; ）处理跟踪消息。有关跟踪器端口的描述，请参见 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ；对于跟踪器模块，请参见 &lt;code&gt;erl_tracer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b87e561423bace774990128b77e86ad6df9e413" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with all codec configs. &lt;code&gt;Factor&lt;/code&gt; (defaults to &lt;code&gt;1&lt;/code&gt;) processes are started for every supported codec config.</source>
          <target state="translated">此功能使用所有编解码器配置启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试。为每个受支持的编解码器配置启动 &lt;code&gt;Factor&lt;/code&gt; （默认为 &lt;code&gt;1&lt;/code&gt; ）过程。</target>
        </trans-unit>
        <trans-unit id="792ed4cb1314be5885f62ea62a3ebeadcd5147c2" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with codec configs not using any drivers (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; without &lt;code&gt;flex&lt;/code&gt;, &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; without &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; without &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此函数使用不使用任何驱动程序的编解码器配置启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试（即，没有 &lt;code&gt;flex&lt;/code&gt; ， &lt;code&gt;ber&lt;/code&gt; 和 &lt;code&gt;per&lt;/code&gt; ,没有 &lt;code&gt;driver&lt;/code&gt; 和 &lt;code&gt;erlang&lt;/code&gt; ,没有 &lt;code&gt;compressed&lt;/code&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;code&gt;compact&lt;/code&gt; ）。与运行标准测试时（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）启动的进程数量相同。每个进程对它们的消息进行编码和解码。 （对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="ad7b4c53c1b5220bc2673b30cb62ee3a8a2764a4" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the driver using codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;, and &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; with &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; with &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此功能启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试，只有使用的编解码器CONFIGS（即司机 &lt;code&gt;pretty&lt;/code&gt; 和 &lt;code&gt;compact&lt;/code&gt; 有 &lt;code&gt;flex&lt;/code&gt; ，和 &lt;code&gt;ber&lt;/code&gt; 和 &lt;code&gt;per&lt;/code&gt; 与 &lt;code&gt;driver&lt;/code&gt; 和 &lt;code&gt;erlang&lt;/code&gt; 与 &lt;code&gt;compressed&lt;/code&gt; ）。与运行标准测试时（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）启动的进程数量相同。每个进程对它们的消息进行编码和解码。 （对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="a169f04fb06754d3d77f607833509158a7205503" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the flex codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">此函数仅使用flex编解码器配置（即，使用 &lt;code&gt;flex&lt;/code&gt; &lt;strong&gt;既&lt;/strong&gt; &lt;code&gt;pretty&lt;/code&gt; 又 &lt;code&gt;compact&lt;/code&gt; ）来启动&lt;strong&gt;mstone1&lt;/strong&gt;性能测试。与运行标准测试时启动的进程数量相同（使用 &lt;code&gt;start/0,1&lt;/code&gt; 函数）。每个进程对它们的消息进行编码和解码。（对于所有进程）总共处理的消息数是mstone值。</target>
        </trans-unit>
        <trans-unit id="198cdb7eaaa9d51f54f530ef45039bacb833b143" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone2&lt;/strong&gt; performance test with all codec configs. Processes are created dynamically. Each process make &lt;strong&gt;one&lt;/strong&gt; run through their messages (decoding and encoding messages) and then exits. When one process exits, a new is created with the same codec config and set of messages.</source>
          <target state="translated">此功能使用所有编解码器配置启动&lt;strong&gt;mstone2&lt;/strong&gt;性能测试。进程是动态创建的。每个进程化妆&lt;strong&gt;一个&lt;/strong&gt;通过它们的消息（解码和编码的消息），然后退出运行。当一个进程退出时，将使用相同的编解码器配置和消息集创建一个新消息。</target>
        </trans-unit>
        <trans-unit id="3f645d23afcc815891f3acc3933eab5ba5bdfcf9" translate="yes" xml:space="preserve">
          <source>This function starts the evaluation of a digit map with megaco:eval_digit_map/1 and sends a sequence of events to it megaco:report_digit_event/2 in order to simplify testing of digit maps.</source>
          <target state="translated">这个函数从megaco:eval_digit_map/1开始对数字图进行评估,并向其发送事件序列megaco:report_digit_event/2,以简化数字图的测试。</target>
        </trans-unit>
        <trans-unit id="4a3fae66ed7c3cc4e51664a7096a153b2497b47c" translate="yes" xml:space="preserve">
          <source>This function starts the standalone &lt;code&gt;nteventlog&lt;/code&gt; process and, if &lt;code&gt;start_link/2&lt;/code&gt; is used, links to it.</source>
          <target state="translated">此函数启动独立的 &lt;code&gt;nteventlog&lt;/code&gt; 进程，如果使用了 &lt;code&gt;start_link/2&lt;/code&gt; ，则链接到该进程。</target>
        </trans-unit>
        <trans-unit id="51eab0810670dc8d97c68c1365bff9e556a60d4b" translate="yes" xml:space="preserve">
          <source>This function takes a list of 'ActionRequest' records and has three main options:</source>
          <target state="translated">该函数接收一个 &quot;ActionRequest &quot;记录列表,有三个主要选项。</target>
        </trans-unit>
        <trans-unit id="b830d311ae4ee73ecebdc71d2c40db38f6b5103e" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified managed agents, without checking if any of them exist. To change a registered managed agent, the agent must first be unregistered.</source>
          <target state="translated">该函数尝试注册指定的受管代理,而不检查它们是否存在。要改变已注册的管理代理,必须先解除代理的注册。</target>
        </trans-unit>
        <trans-unit id="97a729927e14b719ca944a21f7b5b57eca599bd8" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified users, without checking if any of them exist. To change a registered user, the user must first be unregistered.</source>
          <target state="translated">该函数尝试注册指定的用户,而不检查是否有用户存在。要改变一个已注册的用户,必须先解除该用户的注册。</target>
        </trans-unit>
        <trans-unit id="b10454e8f4725b8a0eb4da465ee57ecb2b75d61c" translate="yes" xml:space="preserve">
          <source>This function updates the configuration data from which the specified configuration variable was read, and returns the (possibly) new value of this variable.</source>
          <target state="translated">该函数更新从指定配置变量中读取的配置数据,并返回该变量的(可能)新值。</target>
        </trans-unit>
        <trans-unit id="ca81e8a0f9544f8a61bc496a4e260c146099af94" translate="yes" xml:space="preserve">
          <source>This function used to return &lt;code&gt;false&lt;/code&gt; for BIFs before Erlang/OTP 18.0.</source>
          <target state="translated">对于Erlang / OTP 18.0之前的BIF，此函数用于返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae9274ef2248b4bd36f346fff38a572567648823" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; just like &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数使用解析程序选项 &lt;code&gt;search&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="21fc2b9bb4c2e8f025026e93df306e88dd67e182" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; that is a list of domain names. If the name to resolve contains no dots, it is prepended to each domain name in the search list, and they are tried in order. If the name contains dots, it is first tried as an absolute name and if that fails, the search list is used. If the name has a trailing dot, it is supposed to be an absolute name and the search list is not used.</source>
          <target state="translated">此功能使用作为域名列表的解析器选项 &lt;code&gt;search&lt;/code&gt; 。如果要解析的名称不包含点，则将其放在搜索列表中的每个域名之前，并按顺序尝试。如果名称包含点，则首先尝试将其作为绝对名称，如果失败，则使用搜索列表。如果名称带有结尾点，则应将其视为绝对名称，并且不使用搜索列表。</target>
        </trans-unit>
        <trans-unit id="66f0f7dcf3e6aeb3b05425d374f015271bc5c8f8" translate="yes" xml:space="preserve">
          <source>This function uses the NIF library to determine if dynamic tracing is available. Usually calling &lt;code&gt;erlang:system_info/1&lt;/code&gt; is a better indicator of the availability of dynamic tracing.</source>
          <target state="translated">此函数使用NIF库来确定动态跟踪是否可用。通常，调用 &lt;code&gt;erlang:system_info/1&lt;/code&gt; 可以更好地指示动态跟踪的可用性。</target>
        </trans-unit>
        <trans-unit id="21d638edd5b52a38a30d020b01f40281508b0f05" translate="yes" xml:space="preserve">
          <source>This function uses the module &lt;code&gt;rand&lt;/code&gt; to generate new keys. The seed it uses may be initialized by calling &lt;code&gt;rand:seed/1&lt;/code&gt; or &lt;code&gt;rand:seed/2&lt;/code&gt; before this function is first called.</source>
          <target state="translated">此函数使用模块 &lt;code&gt;rand&lt;/code&gt; 生成新密钥。可以通过在第一次调用此函数之前调用 &lt;code&gt;rand:seed/1&lt;/code&gt; 或 &lt;code&gt;rand:seed/2&lt;/code&gt; 来初始化它使用的种子。</target>
        </trans-unit>
        <trans-unit id="971c66faa137257bfd2753c3d5426c0e180b495e" translate="yes" xml:space="preserve">
          <source>This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms.</source>
          <target state="translated">这个函数在Erlang/OTP R16中被引入,作为支持UTF-8原子的第一步的一部分。</target>
        </trans-unit>
        <trans-unit id="d681ac22ff0dcd99cf6793970b0001c494cacadb" translate="yes" xml:space="preserve">
          <source>This function was originally intenden for debugging purpose. It is not recommended to print very large terms with &lt;code&gt;%T&lt;/code&gt;. The function may change &lt;code&gt;errno&lt;/code&gt;, even if successful.</source>
          <target state="translated">此功能最初旨在调试。不建议使用 &lt;code&gt;%T&lt;/code&gt; 打印很大的术语。该函数可能会更改 &lt;code&gt;errno&lt;/code&gt; ，即使成功也是如此。</target>
        </trans-unit>
        <trans-unit id="59044a92e08961dca9d0df91cd84e6bdf2e387c0" translate="yes" xml:space="preserve">
          <source>This function will fail with a &lt;code&gt;badarg&lt;/code&gt; exception if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc1aaa0050da285abdb43a70baab76906a3247e" translate="yes" xml:space="preserve">
          <source>This function will return the identity of test- and group leader processes that are still running at the time of this call. &lt;code&gt;TestProcs&lt;/code&gt; are processes in the system that have a Common Test IO process as group leader. &lt;code&gt;SharedGL&lt;/code&gt; is the central Common Test IO process, responsible for printing to log files for configuration functions and sequentially executing test cases. &lt;code&gt;OtherGLs&lt;/code&gt; are Common Test IO processes that print to log files for test cases in parallel test case groups.</source>
          <target state="translated">该函数将返回在此调用时仍在运行的测试领导者组和组领导者进程的标识。 &lt;code&gt;TestProcs&lt;/code&gt; 是系统中具有Common Test IO进程作为组长的进程。 &lt;code&gt;SharedGL&lt;/code&gt; 是中央通用测试IO流程，负责打印到配置功能的日志文件并按顺序执行测试用例。 &lt;code&gt;OtherGLs&lt;/code&gt; 是Common Test IO进程，可打印到并行测试用例组中的测试用例的日志文件。</target>
        </trans-unit>
        <trans-unit id="f14e5a0a13df62695dcaadc50e2282e18baef924" translate="yes" xml:space="preserve">
          <source>This function will save all match specifications saved during the session (during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;) and built-in match specifications in a text file with the name designated by &lt;code&gt;Name&lt;/code&gt;. The format of the file is textual, why it can be edited with an ordinary text editor, and then restored with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能会将会话期间（在调用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 期间）保存的所有匹配规范以及内置的匹配规范保存在文本文件中，该文本文件的名称由 &lt;code&gt;Name&lt;/code&gt; 指定。该文件的格式为文本格式，为什么可以使用常规文本编辑器进行编辑，然后使用 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 恢复该文件。</target>
        </trans-unit>
        <trans-unit id="fe5d78839a608e23473c4be1eb43fd59136f1578" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此函数作为 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 起作用，但仅禁用使用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 设置的跟踪（不使用 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 设置）。</target>
        </trans-unit>
        <trans-unit id="4f73b00efb28d22de61c21b36ad8a83ee49cefed" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此函数作为 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 起作用，但仅禁用使用 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 设置的跟踪（不使用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f3521fe756e0c4e17603d964e71f79b819ca2cc" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, but enables tracing for local calls (and local functions) as well as for global calls (and functions).</source>
          <target state="translated">此函数的工作方式为 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; ，但可以跟踪本地调用（和本地函数）以及全局调用（和函数）。</target>
        </trans-unit>
        <trans-unit id="649cc8a65ee1157009a2026f80b85a94281bddef" translate="yes" xml:space="preserve">
          <source>This function works exactly as &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt;, but allows you to write your own handler function. The handler function works mostly as the one described in &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but will also have to be prepared to handle trace messages of the form &lt;code&gt;{drop, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of dropped messages. This pseudo trace message will only occur if the ip trace driver is used.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 完全一样，但是允许您编写自己的处理函数。处理程序函数的工作原理与 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 中描述的函数相同，但还必须准备处理 &lt;code&gt;{drop, N}&lt;/code&gt; 形式的跟踪消息，其中 &lt;code&gt;N&lt;/code&gt; 是已删除消息的数量。仅当使用ip跟踪驱动程序时，才会出现此伪跟踪消息。</target>
        </trans-unit>
        <trans-unit id="e3613eb939658a1c4e7abb497a6aeaed611fdecc" translate="yes" xml:space="preserve">
          <source>This function works exactly the same way as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; except that it is asynchronous instead of synchronous. The spawned process will link with the caller when created. If an &lt;code&gt;Error&lt;/code&gt; occurs while doing the cover analysis the process will crash with the same error reason as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; would return.</source>
          <target state="translated">该函数的工作方式与 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 完全相同，不同之处在于它是异步的而不是同步的。创建后，生成的进程将与调用方链接。如果进行覆盖分析时发生 &lt;code&gt;Error&lt;/code&gt; ，则该过程将崩溃，并返回与 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 相同的错误原因。</target>
        </trans-unit>
        <trans-unit id="41248f0d6e585aea101cd90cc6b6f5d6fd5821da" translate="yes" xml:space="preserve">
          <source>This function, similar to &lt;code&gt;timer:sleep/1&lt;/code&gt; in STDLIB, suspends the test case for a specified time. However, this function also multiplies &lt;code&gt;Time&lt;/code&gt; with the &lt;code&gt;multiply_timetraps&lt;/code&gt; value (if set) and under certain circumstances also scales up the time automatically if &lt;code&gt;scale_timetraps&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">此功能类似于STDLIB中的 &lt;code&gt;timer:sleep/1&lt;/code&gt; ，可将测试用例暂停指定的时间。但是，此功能也倍增 &lt;code&gt;Time&lt;/code&gt; 与 &lt;code&gt;multiply_timetraps&lt;/code&gt; 值（如果设置），并在某些情况下还可扩展至如果自动时间 &lt;code&gt;scale_timetraps&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; （默认是 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="285cbe2f9f5c577e4d9b2e978e114e422218a0dd" translate="yes" xml:space="preserve">
          <source>This functionality can be used to avoid that one process overloads a database on another node.</source>
          <target state="translated">这个功能可以用来避免一个进程在另一个节点上过载数据库。</target>
        </trans-unit>
        <trans-unit id="1e696e3030e058d7399f33e7d6312da8bd0dec58" translate="yes" xml:space="preserve">
          <source>This functionality is deprecated as of OTP 23, and will be removed in OTP 24. Reasonably new &lt;code&gt;gcc&lt;/code&gt; compilers will issue deprecation warnings. In order to disable these warnings, define the macro &lt;code&gt;EI_NO_DEPR_WARN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f663a6b926446bfebbbdc0b7d15882ae1bccc35" translate="yes" xml:space="preserve">
          <source>This functionality is only provided when using &lt;code&gt;BER&lt;/code&gt; (option &lt;code&gt;ber&lt;/code&gt;).</source>
          <target state="translated">仅在使用 &lt;code&gt;BER&lt;/code&gt; （选项 &lt;code&gt;ber&lt;/code&gt; ）时才提供此功能。</target>
        </trans-unit>
        <trans-unit id="03d45e2ad58e3bd143a9c7b2c50773493705e610" translate="yes" xml:space="preserve">
          <source>This functionality is used both when the transaction sender is used and for segmentation. So, for either of those to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">使用事务发送者时和分段时都使用此功能。因此，对于其中任何一个都必须工作，&lt;strong&gt;必须&lt;/strong&gt;完全支持此功能！</target>
        </trans-unit>
        <trans-unit id="018c73d63f139a3baee06c9daba146659fa3ed6c" translate="yes" xml:space="preserve">
          <source>This functionality is used when a client process communicates with a file i/o-server to spread the user tag to the I/O-server and then down to the efile_drv driver. By using &lt;code&gt;spread_tag/1&lt;/code&gt; and &lt;code&gt;restore_tag/1&lt;/code&gt;, one can enable or disable spreading of user tags to other processes and then restore the previous state of the user tag. The TagData returned from this call contains all previous information so the state (including any previously spread user tags) will be completely restored by a later call to &lt;code&gt;restore_tag/1&lt;/code&gt;.</source>
          <target state="translated">当客户端进程与文件I / O服务器通信以将用户标签传播到I / O服务器，然后传播到efile_drv驱动程序时，将使用此功能。通过使用 &lt;code&gt;spread_tag/1&lt;/code&gt; 和 &lt;code&gt;restore_tag/1&lt;/code&gt; ，可以启用或禁用将用户标签传播到其他进程，然后恢复用户标签的先前状态。从此调用返回的TagData包含所有先前的信息，因此状态（包括任何以前传播的用户标签）将在以后对 &lt;code&gt;restore_tag/1&lt;/code&gt; 的调用中完全恢复。</target>
        </trans-unit>
        <trans-unit id="1bfce0af83883f449ffeeed0bed57f3f0c60c686" translate="yes" xml:space="preserve">
          <source>This functionality works together with option &lt;code&gt;ber&lt;/code&gt;. It enables the specialized decodes, see Section &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能与 &lt;code&gt;ber&lt;/code&gt; 一起使用。它启用了特殊解码，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b7b1c65d65cff1e78b722d7d85e687fe5927d13" translate="yes" xml:space="preserve">
          <source>This functions differs from &lt;code&gt;token&lt;/code&gt; in that it will continue to scan tokens upto and including an &lt;code&gt;{end_token,Token}&lt;/code&gt; has been scanned (see next section). It will then return all the tokens. This is typically used for scanning grammars like Erlang where there is an explicit end token, &lt;code&gt;'.'&lt;/code&gt;. If no end token is found then the whole file will be scanned and returned. If an error occurs then all tokens upto and including the next end token will be skipped.</source>
          <target state="translated">此功能与 &lt;code&gt;token&lt;/code&gt; 不同之处在于，它将继续扫描令牌，直到包括已扫描的 &lt;code&gt;{end_token,Token}&lt;/code&gt; （请参阅下一节）。然后它将返回所有令牌。通常用于扫描像Erlang这样的语法，其中有一个明确的结束标记 &lt;code&gt;'.'&lt;/code&gt; 。如果未找到结束令牌，则将扫描并返回整个文件。如果发生错误，则将跳过所有令牌，包括下一个结束令牌。</target>
        </trans-unit>
        <trans-unit id="78c42db04efcc05657be0800818fa1802af33516" translate="yes" xml:space="preserve">
          <source>This functions discards all options in the begining of the lines of thoose files when reading them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3c88f30a1cd5b57516c27de9ff90f9c75fa259" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5b9819acc50428faeeffeac0e065c79843eb3c" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18e02167a85c9b4d903d206ff737224c9a5b3ea" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e988c48e237b3372b652c8e3639563f7969c8f32" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1aa52c0f139d5d8a6f71a168c88c9470f952129" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75829b451d464b595a1024dec90085ca0093abce" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留此功能是为了向后兼容，新代码不得使用此功能。请使用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="66d11c99d3b8bf1e2077d0f21b72e0ab032ea87c" translate="yes" xml:space="preserve">
          <source>This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again.</source>
          <target state="translated">这个函数提供了一种更新计数器的方法,不需要查找对象,通过递增元素更新对象,并将得到的对象再次插入表中。</target>
        </trans-unit>
        <trans-unit id="2b70ec5aa36c1075bf590864c6a36436ad975b12" translate="yes" xml:space="preserve">
          <source>This generates a &lt;code&gt;relup&lt;/code&gt; file with instructions for how to upgrade from version &quot;A&quot; (&quot;ch_rel-1&quot;) to version &quot;B&quot; (&quot;ch_rel-2&quot;) and how to downgrade from version &quot;B&quot; to version &quot;A&quot;.</source>
          <target state="translated">这将生成一个 &lt;code&gt;relup&lt;/code&gt; 文件，其中包含有关如何从版本&amp;ldquo; A&amp;rdquo;（&amp;ldquo; ch_rel-1&amp;rdquo;）升级到版本&amp;ldquo; B&amp;rdquo;（&amp;ldquo; ch_rel-2&amp;rdquo;）以及如何从版本&amp;ldquo; B&amp;rdquo;降级到版本&amp;ldquo; A&amp;rdquo;的说明。</target>
        </trans-unit>
        <trans-unit id="c116938db051375fe0e1532d328cb08b14b31015" translate="yes" xml:space="preserve">
          <source>This gives &lt;code&gt;D = 273&lt;/code&gt;, &lt;code&gt;E = 00&lt;/code&gt;, and F binds to a binary of size 1: &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt;.</source>
          <target state="translated">这样得到 &lt;code&gt;D = 273&lt;/code&gt; ， &lt;code&gt;E = 00&lt;/code&gt; ，并且F绑定到大小为1的二进制文件： &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b265622dae76f6ead2d5384e91874a0a56b738" translate="yes" xml:space="preserve">
          <source>This gives a binary of size 4. Here, a &lt;strong&gt;size expression&lt;/strong&gt; is used for the variable &lt;code&gt;C&lt;/code&gt; to specify a 16-bits segment of &lt;code&gt;Bin2&lt;/code&gt;.</source>
          <target state="translated">这给出了大小为4的二进制文件。这里，&lt;strong&gt;大小表达式&lt;/strong&gt;用于变量 &lt;code&gt;C&lt;/code&gt; 来指定 &lt;code&gt;Bin2&lt;/code&gt; 的16位段。</target>
        </trans-unit>
        <trans-unit id="9304ac5067de60ffef75db2d0f27153eea8fd249" translate="yes" xml:space="preserve">
          <source>This gives a set of binary logs, for example:</source>
          <target state="translated">例如,这给出了一组二进制日志。</target>
        </trans-unit>
        <trans-unit id="efb5947a696c40715e3fb71363beaeb5efc4f051" translate="yes" xml:space="preserve">
          <source>This gives an entry for &lt;code&gt;m1&lt;/code&gt; also in the cover log for test run &lt;code&gt;s2&lt;/code&gt;. The problem is that this only reflects the coverage by &lt;code&gt;s2&lt;/code&gt; tests, not the accumulated result over &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;. This is where the cross cover mechanism comes in handy.</source>
          <target state="translated">这在测试运行 &lt;code&gt;s2&lt;/code&gt; 的覆盖日志中也提供了 &lt;code&gt;m1&lt;/code&gt; 的条目。问题在于，这仅反映了 &lt;code&gt;s2&lt;/code&gt; 测试的覆盖率，而不反映 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 上的累积结果。这是横盖机制派上用场的地方。</target>
        </trans-unit>
        <trans-unit id="713b4a71335dbed07b61ab42f009c85295637765" translate="yes" xml:space="preserve">
          <source>This gives no result of length &amp;gt; 0 and we are at the last position, so the global search is complete.</source>
          <target state="translated">这不会给出length&amp;gt; 0的结果，并且我们位于最后一个位置，因此全局搜索已完成。</target>
        </trans-unit>
        <trans-unit id="e365e009b84d303f259288c46a5cf1337ae2825c" translate="yes" xml:space="preserve">
          <source>This gives the list of all elements in L1 that are not contained in L2.</source>
          <target state="translated">这给出了L1中不包含在L2中的所有元素的列表。</target>
        </trans-unit>
        <trans-unit id="79f96c1766aa59b316c1112142e724a0ac8f12f4" translate="yes" xml:space="preserve">
          <source>This gives the same result. &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; is in the guard part and therefore discards anything that does not have an &lt;code&gt;empyear&lt;/code&gt; (bound to &lt;code&gt;'$2'&lt;/code&gt; in the head) less than 2000, as the guard in the &lt;code&gt;foldr/3&lt;/code&gt; example.</source>
          <target state="translated">这给出了相同的结果。 &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; 位于后卫部分，因此丢弃没有 &lt;code&gt;empyear&lt;/code&gt; （在头部绑定到 &lt;code&gt;'$2'&lt;/code&gt; 年）的任何内容，作为 &lt;code&gt;foldr/3&lt;/code&gt; 中的后卫例。</target>
        </trans-unit>
        <trans-unit id="22d1dda5ab8530e1e0b433f6ea95f6b6b7eda6d3" translate="yes" xml:space="preserve">
          <source>This gives two binaries of size 3, with the following evaluations:</source>
          <target state="translated">这样就得到了两个大小为3的二进制,其评价如下。</target>
        </trans-unit>
        <trans-unit id="5bdfea051354f0bf5fa426336e15ae7b72111a2a" translate="yes" xml:space="preserve">
          <source>This grammar can be used to generate a parser which parses list expressions, such as &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; provided that your scanner tokenizes, for example, the input &lt;code&gt;(peter charles)&lt;/code&gt; as follows:</source>
          <target state="translated">此语法可用于生成解析器，用于解析列表表达式，例如 &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; 前提是您的扫描器将其标记为例如，输入 &lt;code&gt;(peter charles)&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="c5c33f8292424d5d8afd6fb208cfbfa703f594e5" translate="yes" xml:space="preserve">
          <source>This handler behaves much like &lt;code&gt;logger_std_h&lt;/code&gt;, except it uses &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; as its destination.</source>
          <target state="translated">该处理程序的行为与 &lt;code&gt;logger_std_h&lt;/code&gt; 相似，不同之处 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 它使用disk_log作为目的地。</target>
        </trans-unit>
        <trans-unit id="dcaca3a309669115a5d10a160b27e110b7d53cd4" translate="yes" xml:space="preserve">
          <source>This handler ignores events that do not originate from the &lt;code&gt;error_logger&lt;/code&gt; API, or from within OTP. This means that if your code uses the Logger API for logging, then your log events will be discarded by this handler.</source>
          <target state="translated">此处理程序将忽略不是源自 &lt;code&gt;error_logger&lt;/code&gt; API或OTP内部的事件。这意味着，如果您的代码使用Logger API进行日志记录，则此处理程序将丢弃您的日志事件。</target>
        </trans-unit>
        <trans-unit id="575502000290e2f076b35060118636479ce93a20" translate="yes" xml:space="preserve">
          <source>This handler is provided for backwards compatibility only. It is not started by default, but will be automatically started the first time an &lt;code&gt;error_logger&lt;/code&gt; event handler is added with &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt; error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29807c3684400c3becd59e5edf9ba096157cab01" translate="yes" xml:space="preserve">
          <source>This handler is provided for backwards compatibility only. It is not started by default, but will be automatically started the first time an &lt;code&gt;error_logger&lt;/code&gt; event handler is added with &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供此处理程序仅是为了向后兼容。它默认情况下未启动，但是在第一次使用 &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; 添加 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序时将自动启动。</target>
        </trans-unit>
        <trans-unit id="87e5ec8533eb6addfe606eccdf0a8555b2e81bc0" translate="yes" xml:space="preserve">
          <source>This has the same effect as setting option &lt;code&gt;ucp&lt;/code&gt;: it causes sequences such as \d and \w to use Unicode properties to determine character types, instead of recognizing only characters with codes &amp;lt; 256 through a lookup table.</source>
          <target state="translated">这与设置选项 &lt;code&gt;ucp&lt;/code&gt; 具有相同的效果：它使诸如\ d和\ w之类的序列使用Unicode属性确定字符类型，而不是通过查找表仅识别代码&amp;lt;256的字符。</target>
        </trans-unit>
        <trans-unit id="0c156c0c2fc33946d9fbadad8702601855c80e09" translate="yes" xml:space="preserve">
          <source>This has the same effect as the above, &lt;strong&gt;if and only if&lt;/strong&gt; megaco has sent at least one pending message for this request (during the processing of the request). If no pending message has been sent, then immediate acknowledgement will &lt;strong&gt;not&lt;/strong&gt; be requested.</source>
          <target state="translated">&lt;strong&gt;当且仅当&lt;/strong&gt; megaco为该请求发送了至少一个挂起消息时（在处理请求期间），这具有与上述相同的效果。如果未发送任何待处理消息，则&lt;strong&gt;不会&lt;/strong&gt;请求立即确认。</target>
        </trans-unit>
        <trans-unit id="4ede3cfedbb971a104b9a8ef6799913490ca75be" translate="yes" xml:space="preserve">
          <source>This has the same effect as the following:</source>
          <target state="translated">这与下面的效果是一样的。</target>
        </trans-unit>
        <trans-unit id="e0d90b246b1198d103c86bc16c013de08162e8ce" translate="yes" xml:space="preserve">
          <source>This has the value &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, &lt;code&gt;{file,LogFileName}&lt;/code&gt;, or &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt;.</source>
          <target state="translated">其值为 &lt;code&gt;standard_io&lt;/code&gt; ， &lt;code&gt;standard_error&lt;/code&gt; ， &lt;code&gt;{file,LogFileName}&lt;/code&gt; 或 &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa9ae8726a4cc0244638ba67ad2025c382e5beef" translate="yes" xml:space="preserve">
          <source>This implementation-dependent function increments the reduction counter for the calling process. In the Beam emulator, the reduction counter is normally incremented by one for each function and BIF call. A context switch is forced when the counter reaches the maximum number of reductions for a process (2000 reductions in Erlang/OTP R12B).</source>
          <target state="translated">这个与实现相关的函数为调用过程递增还原计数器。在Beam仿真器中,通常每个函数和BIF调用的还原计数器都会递增一个。当计数器达到一个进程的最大还原数(在Erlang/OTP R12B中为2000个还原数)时,会强制进行上下文切换。</target>
        </trans-unit>
        <trans-unit id="a8d3c24a386f367f78241d2e4bac7b7d69305c8c" translate="yes" xml:space="preserve">
          <source>This implies that for an included application, the set of start phases must be a subset of the set of phases defined for the primary application. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">这意味着对于一个包含的应用程序，开始阶段集必须是为主要应用程序定义的一组阶段集的子集。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="394da9d3e5810d24a5bd1b236db1807f4d4bd66f" translate="yes" xml:space="preserve">
          <source>This included file will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cc03c618eaaba02c392d8b6d5e3541aa6478d4" translate="yes" xml:space="preserve">
          <source>This index is used to separate the implementation of the SNMP ordering from the actual implementation of the table. The SNMP ordering, that is implementation of GET NEXT, is implemented in this module.</source>
          <target state="translated">该索引用于将SNMP排序的实现与表的实际实现分开。SNMP排序,也就是GET NEXT的实现,在本模块中实现。</target>
        </trans-unit>
        <trans-unit id="4da9986920c604b316098093467baaddac2eb487" translate="yes" xml:space="preserve">
          <source>This indicates that the variable &lt;code&gt;File&lt;/code&gt;, which is defined inside the fun, collides with the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside the fun.</source>
          <target state="translated">这表明变量 &lt;code&gt;File&lt;/code&gt; ，它的乐趣中定义的，与可变碰撞 &lt;code&gt;File&lt;/code&gt; ，它的乐趣之外定义。</target>
        </trans-unit>
        <trans-unit id="cfea72aa373ef570cea99287f1170facd64d6eef" translate="yes" xml:space="preserve">
          <source>This inform the user which target addresses the notification was sent to.</source>
          <target state="translated">这将告知用户通知的目标地址是哪个。</target>
        </trans-unit>
        <trans-unit id="0d129bafd72948232df4b45a85096033eb4d3888" translate="yes" xml:space="preserve">
          <source>This information can be invalid for some implementations.</source>
          <target state="translated">这些信息对于某些实现来说可能是无效的。</target>
        </trans-unit>
        <trans-unit id="7aae2c9ba176a7a3f9d606f61a083bbbedd09c9d" translate="yes" xml:space="preserve">
          <source>This information can be produced by the functions &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; but this is a simple way to get it all at once.</source>
          <target state="translated">此信息可以由功能 &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; 生成,但这是一次一次性获取所有信息的简单方法。</target>
        </trans-unit>
        <trans-unit id="710dd978424ecc04fc2bf1003714cbd1fde00ea0" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="61fde3bec5255dca0919656dc9b966cbee0da75a" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="eaf22384b8506971667ec0cacf5790e4084dc39b" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 检索此信息。</target>
        </trans-unit>
        <trans-unit id="962a2ecfcacf4f2ae7569863ad3b0745fd8bd9b5" translate="yes" xml:space="preserve">
          <source>This information can be used to traverse the chain of function calls, using the &lt;strong&gt;Up&lt;/strong&gt; and &lt;strong&gt;Down&lt;/strong&gt; buttons in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 中的&amp;ldquo; &lt;strong&gt;向上&amp;rdquo;&lt;/strong&gt;和&amp;ldquo; &lt;strong&gt;向下&amp;rdquo;&lt;/strong&gt;按钮，可以使用此信息遍历函数调用链。</target>
        </trans-unit>
        <trans-unit id="9a325aae80341287a8eab869857564f9b28b86fd" translate="yes" xml:space="preserve">
          <source>This information is used by the release handler during upgrades and downgrades, see &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">版本处理程序在升级和降级期间将使用此信息，请参阅 &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="201452c6ed23592af55381e4e0078166857bb6b2" translate="yes" xml:space="preserve">
          <source>This information is useful when an external entity (for example, an IDE) provides additional code for a running node. If the code server is in interactive mode, it only has to add the path to the code. If the code server is in embedded mode, the code must be loaded with &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当外部实体（例如，IDE）为运行中的节点提供附加代码时，此信息很有用。如果代码服务器处于交互模式，则只需将路径添加到代码。如果代码服务器处于嵌入式模式，则必须使用 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 加载代码。</target>
        </trans-unit>
        <trans-unit id="5a8323563f351cf2bca8245a5765d1e7287f26f8" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address acknowledged the notification.</source>
          <target state="translated">这将通知用户,这个目标地址确认了该通知。</target>
        </trans-unit>
        <trans-unit id="1baf8ed33916a0e4003152e45bbc117558b69aff" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge notification.</source>
          <target state="translated">这将通知用户,这个目标地址没有确认通知。</target>
        </trans-unit>
        <trans-unit id="e9c0fbf4edafb48f201f8b1170f9bfbfe552c23a" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge the notification.</source>
          <target state="translated">这将告知用户,这个目标地址没有确认通知。</target>
        </trans-unit>
        <trans-unit id="083ac1279739f945b13a461e8bb4339d8dfde4a8" translate="yes" xml:space="preserve">
          <source>This informs the user which target addresses the notification was sent to.</source>
          <target state="translated">这将通知用户通知被发送到哪个目标地址。</target>
        </trans-unit>
        <trans-unit id="d7e452d2d7924302fbdea18276d798ae79408dc5" translate="yes" xml:space="preserve">
          <source>This instruction is not related to upgrades of ERTS or any of the core applications. It can be used by any application to force a restart of the emulator after all upgrade instructions are executed.</source>
          <target state="translated">该指令与ERTS或任何核心应用程序的升级无关。任何应用程序都可以使用它来强制在所有升级指令执行后重新启动模拟器。</target>
        </trans-unit>
        <trans-unit id="b27e8eb36b131c032f8c3fba207f37d792a31d2a" translate="yes" xml:space="preserve">
          <source>This instruction is similar to &lt;code&gt;restart_new_emulator&lt;/code&gt;, except it must be placed at the end of the &lt;code&gt;relup&lt;/code&gt; file. It is not related to an upgrade of the emulator or the core applications, but can be used by any application when a complete reboot of the system is required.</source>
          <target state="translated">该指令与 &lt;code&gt;restart_new_emulator&lt;/code&gt; 相似，不同的是它必须放在 &lt;code&gt;relup&lt;/code&gt; 文件的末尾。它与仿真器或核心应用程序的升级无关，但是当需要完全重新引导系统时，任何应用程序都可以使用它。</target>
        </trans-unit>
        <trans-unit id="4e2ff5aadab857bef7cc042cfddbfd7f94365d61" translate="yes" xml:space="preserve">
          <source>This instruction is used when changing to a new emulator version, or when any of the core applications Kernel, STDLIB, or SASL is upgraded. If a system reboot is needed for another reason, the &lt;code&gt;restart_emulator&lt;/code&gt; instruction is to be used instead.</source>
          <target state="translated">当更改为新的仿真器版本时，或者在升级任何核心应用程序内核，STDLIB或SASL时，都使用此指令。如果由于其他原因需要重新引导系统，则将使用 &lt;code&gt;restart_emulator&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="538ffcc030d6ff15bd0bfff773ddaca2d61087a9" translate="yes" xml:space="preserve">
          <source>This instruction is used when the application ERTS, Kernel, STDLIB, or SASL is upgraded. It shuts down the current emulator and starts a new one. All processes are terminated gracefully, and the new version of ERTS, Kernel, STDLIB, and SASL are used when the emulator restarts. Only one &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is allowed in the &lt;code&gt;relup&lt;/code&gt; file, and it must be placed first. &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures this when the &lt;code&gt;relup&lt;/code&gt; file is generated. The rest of the instructions in the &lt;code&gt;relup&lt;/code&gt; file is executed after the restart as a part of the boot script.</source>
          <target state="translated">升级应用程序ERTS，内核，STDLIB或SASL时使用此指令。它关闭当前的模拟器并启动一个新的模拟器。仿真器重新启动后，所有进程都会正常终止，并且将使用新版本的ERTS，内核，STDLIB和SASL。 &lt;code&gt;relup&lt;/code&gt; 文件中只允许使用一个 &lt;code&gt;restart_new_emulator&lt;/code&gt; 指令，并且必须将其放在第一位。 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 在生成 &lt;code&gt;relup&lt;/code&gt; 文件时确保这一点。 &lt;code&gt;relup&lt;/code&gt; 文件中的其余指令在重新启动后作为启动脚本的一部分执行。</target>
        </trans-unit>
        <trans-unit id="395215bf28142de440c81ef55b87f4169a80aec6" translate="yes" xml:space="preserve">
          <source>This instruction is written in the configuration file in the following format:</source>
          <target state="translated">该指令以如下格式写入配置文件。</target>
        </trans-unit>
        <trans-unit id="45862ec3de83aecdeb3f0430fc20ad3e86777590" translate="yes" xml:space="preserve">
          <source>This instruction requires that the system is started with heartbeat monitoring, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS and the &lt;code&gt;heart(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">此说明要求系统以心跳监视启动，请参阅ERTS中的 &lt;code&gt;erl(1)&lt;/code&gt; 手册页和内核中的 &lt;code&gt;heart(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="eb9abbefd34b9022f0d676607ac6737850a70742" translate="yes" xml:space="preserve">
          <source>This instruction synchronizes the release installation with other nodes. Each &lt;code&gt;Node&lt;/code&gt; must evaluate this command with the same &lt;code&gt;Id&lt;/code&gt;. The local node waits for all other nodes to evaluate the instruction before execution continues. If a node goes down, it is considered to be an unrecoverable error, and the local node is restarted from the old release. There is no time-out for this instruction, which means that it can hang forever.</source>
          <target state="translated">该指令将发布安装与其他节点同步。每个 &lt;code&gt;Node&lt;/code&gt; 必须使用相同的 &lt;code&gt;Id&lt;/code&gt; 评估此命令。本地节点在执行继续之前等待所有其他节点评估指令。如果节点发生故障，则认为这是不可恢复的错误，并且本地节点将从旧版本重新启动。该指令没有超时，这意味着它可以永远挂起。</target>
        </trans-unit>
        <trans-unit id="72381508b412cca34ddf14083712fc31b9f93e31" translate="yes" xml:space="preserve">
          <source>This interface (or at least the name of the functions) is kept for backward compatibility. Using &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; in the option list gives the same effect regarding the port killing.</source>
          <target state="translated">保留此接口（或至少是函数名称）是为了向后兼容。使用 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; 选项列表中给出了关于港口杀灭效果相同。</target>
        </trans-unit>
        <trans-unit id="986a779296a267e9889a055a42330bfd68321abf" translate="yes" xml:space="preserve">
          <source>This internal event is used by the &lt;code&gt;Common Test&lt;/code&gt; Master process to synchronize particular file operations.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master进程使用此内部事件来同步特定的文件操作。</target>
        </trans-unit>
        <trans-unit id="c34c80ee3e756933a25868fd55ba9046da3c1c47" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; is finished compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">此内部事件表示 &lt;code&gt;Common Test&lt;/code&gt; 已完成目录 &lt;code&gt;Dir&lt;/code&gt; 中的模块编译。</target>
        </trans-unit>
        <trans-unit id="19fd863c53f0cce4ca256baeac321a61b8c0e924" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; starts compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">此内部事件表明 &lt;code&gt;Common Test&lt;/code&gt; 开始在目录 &lt;code&gt;Dir&lt;/code&gt; 中编译模块。</target>
        </trans-unit>
        <trans-unit id="918379111cbe178fe4429e0dda42e1bb45186e43" translate="yes" xml:space="preserve">
          <source>This internal name cannot be changed, it is fixed even if the service is renamed. &lt;code&gt;erlsrv&lt;/code&gt; generates a unique internal name when a service is created. It is recommended to keep to the default if release handling is to be used for the application.</source>
          <target state="translated">此内部名称无法更改，即使重命名服务也已固定。创建服务时， &lt;code&gt;erlsrv&lt;/code&gt; 会生成一个唯一的内部名称。如果要对应用程序使用发布处理，建议保持默认值。</target>
        </trans-unit>
        <trans-unit id="1c853aa37495f77100d3057f3fa259e2e5e59b2e" translate="yes" xml:space="preserve">
          <source>This is 86 % of the total run time, and as we saw before it is the close operation the absolutely biggest contributor. We find a comparison ratio a little bit up in the call stack:</source>
          <target state="translated">这占了总运行时间的86%,正如我们之前所看到的,这是接近操作的绝对最大贡献者。我们在调用堆栈中找到一个比较比例,在上面一点。</target>
        </trans-unit>
        <trans-unit id="4e69295f5174adc14ac6944e7fdc5af01c54eae9" translate="yes" xml:space="preserve">
          <source>This is a 4-component structure called &lt;code&gt;Pdu&lt;/code&gt;. By default, a &lt;code&gt;SEQUENCE&lt;/code&gt; is represented by a record in Erlang. It can also be represented as a map; see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt; Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt;. For each &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; in an ASN.1 module an Erlang record declaration is generated. For &lt;code&gt;Pdu&lt;/code&gt;, a record like the following is defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ef9e4644f03eaf56584c4a5bfb4c37698548ad" translate="yes" xml:space="preserve">
          <source>This is a 4-component structure called &lt;code&gt;Pdu&lt;/code&gt;. By default, a &lt;code&gt;SEQUENCE&lt;/code&gt; is represented by a record in Erlang. It can also be represented as a map; see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt;. For each &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; in an ASN.1 module an Erlang record declaration is generated. For &lt;code&gt;Pdu&lt;/code&gt;, a record like the following is defined:</source>
          <target state="translated">这是一个称为 &lt;code&gt;Pdu&lt;/code&gt; 的4组件结构。默认情况下， &lt;code&gt;SEQUENCE&lt;/code&gt; 由Erlang中的记录表示。它也可以表示为地图。请参见 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 。对于ASN.1模块中的每个 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; ，都会生成一个Erlang记录声明。对于 &lt;code&gt;Pdu&lt;/code&gt; ，定义了以下记录：</target>
        </trans-unit>
        <trans-unit id="0b39193a0d84108c992a285788d5dba07f9d62b4" translate="yes" xml:space="preserve">
          <source>This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt; that on a 64 bit Erlang system executes only about 40% slower than the default &lt;code&gt;exsss&lt;/code&gt; algorithm but with much longer period and better statistical properties, and on the flip side a larger state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9073fcd29e4e73c44d40722439de79f01a5b836" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt; monotonically increasing&lt;/a&gt;&lt;/code&gt; time, but &lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt; strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; time. That is, consecutive calls to &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; can produce the same result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccf5d389b6bb13934731f8a21547b98c0616cd1" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; time, but &lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; time. That is, consecutive calls to &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; can produce the same result.</source>
          <target state="translated">这是一个 &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; 时间，但&lt;strong&gt;没有&lt;/strong&gt;一个 &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 的时间。也就是说，连续调用 &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; 可以产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="3e773a13c08b29bd1b0b27e610e6a3ca5907aef0" translate="yes" xml:space="preserve">
          <source>This is a callback function intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">这是一个回调函数,目的是当一些传输模块收到收到的消息时调用。实际使用哪种传输方式由用户自行选择。</target>
        </trans-unit>
        <trans-unit id="6aaabdad85afb5297ef14e644ed60c642bdf1f64" translate="yes" xml:space="preserve">
          <source>This is a change from signed to unsigned. This can cause problems for, for example, loop termination conditions and error conditions if you only change the types all over the place.</source>
          <target state="translated">这是从有符号到无符号的变化。这可能会导致一些问题,例如,如果你只把类型改来改去,就会出现循环终止条件和错误条件。</target>
        </trans-unit>
        <trans-unit id="3196a6c5d44daf25b6d6681360eca21c5be5b270" translate="yes" xml:space="preserve">
          <source>This is a common error in test suites. It is assumed that the current directory is the same as the author used as current directory when the test case was developed. Many test cases even try to write scratch files to this directory. Instead &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt; are to be used to locate data and for writing scratch files.</source>
          <target state="translated">这是测试套件中的常见错误。假定当前目录与开发测试用例时用作当前目录的作者相同。许多测试用例甚至尝试将暂存文件写入此目录。而是使用 &lt;code&gt;data_dir&lt;/code&gt; 和 &lt;code&gt;priv_dir&lt;/code&gt; 来定位数据和写入暂存文件。</target>
        </trans-unit>
        <trans-unit id="360f48fae93411aaa84a534df910e9385d6dd358" translate="yes" xml:space="preserve">
          <source>This is a corrected version of the previous default algorithm, that now has been superseded by Xoroshiro116+ (&lt;code&gt;exrop&lt;/code&gt;). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &amp;lt; 15%) faster than &lt;code&gt;exrop&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是先前默认算法的更正版本，现已被Xoroshiro116 +（ &lt;code&gt;exrop&lt;/code&gt; ）取代。由于没有本地58位循环指令，因此该算法的执行速度比 &lt;code&gt;exrop&lt;/code&gt; 快（例如，&amp;lt;15％）。请参阅 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7aa23baa63f4887daf2bf3feb0b72e5a926fef" translate="yes" xml:space="preserve">
          <source>This is a dangerous feature that must be used with care. By unintentional mixing of directories, you can easily end up with an inconsistent database, if the same backup is installed on more than one directory.</source>
          <target state="translated">这是一个危险的功能,必须谨慎使用。通过无意中混合目录,如果在多个目录上安装了相同的备份,则很容易导致数据库不一致。</target>
        </trans-unit>
        <trans-unit id="d05cf3f16d8e8cf9241491563959ff3c97154893" translate="yes" xml:space="preserve">
          <source>This is a definition of an external generic BEAM instruction. Most importantly it specifices that the opcode is 64. It also defines that it has two operands. The BEAM assembler will use the opcode when creating &lt;code&gt;.beam&lt;/code&gt; files. The compiler does not really need the arity, but it will use it as an internal sanity check when assembling the BEAM code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00205e610ec0a95f3eebcf63dbbba8372b336cc5" translate="yes" xml:space="preserve">
          <source>This is a handler for Logger that offers circular (wrapped) logs by using &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt;. Multiple instances of this handler can be added to Logger, and each instance prints to its own disk log file, created with the name and settings specified in the handler configuration.</source>
          <target state="translated">这是Logger的处理程序，它通过使用 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 提供循环（包装）日志。可以将该处理程序的多个实例添加到Logger，并且每个实例均打印到其自己的磁盘日志文件，该文件使用在处理程序配置中指定的名称和设置创建。</target>
        </trans-unit>
        <trans-unit id="f1702c7d8fabc70bf82459bbec9093c02074634c" translate="yes" xml:space="preserve">
          <source>This is a large reference document. For casual use of this module, and for most real world applications, the descriptions of functions &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; are enough to getting started.</source>
          <target state="translated">这是一个很大的参考文件。对于该模块的随意使用以及在大多数实际应用中，函数 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; 的描述足以入门。</target>
        </trans-unit>
        <trans-unit id="9ae3bc7ed27ccefa917b875115824ef1a0ed8195" translate="yes" xml:space="preserve">
          <source>This is a legacy clause mostly for &lt;code&gt;Destination = {local, Binary}&lt;/code&gt; where &lt;code&gt;PortZero&lt;/code&gt; is superfluous. It is equivalent to &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt;, the clause right above here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92aeefe62fe3eb6482bb9d89ca3cfa9570836ae6" translate="yes" xml:space="preserve">
          <source>This is a more developed variant of the older &lt;code&gt;&lt;a href=&quot;#type-run_time_error&quot;&gt;run_time_error()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe64ae08d8239e916a24e614514fb557dd71251" translate="yes" xml:space="preserve">
          <source>This is a normal Erlang/OTP application descriptor, as found in an &lt;code&gt;.app&lt;/code&gt; file. The resulting test set consists of the modules listed in the &lt;code&gt;modules&lt;/code&gt; entry in &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">这是一个普通的Erlang / OTP应用程序描述符，可以在 &lt;code&gt;.app&lt;/code&gt; 文件中找到。生成的测试集由 &lt;code&gt;Info&lt;/code&gt; 的 &lt;code&gt;modules&lt;/code&gt; 条目中列出的模块组成。</target>
        </trans-unit>
        <trans-unit id="cc0886c68b7d31b43eac50f2f501f0e29c21db91" translate="yes" xml:space="preserve">
          <source>This is a normal, healthy, return value if the call was just placed to inform the emulator that you have no further use of the driver. It is the most common return value in the most common &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; described in the introduction.</source>
          <target state="translated">如果只是为了告知仿真器您不再使用驱动程序而进行了调用，则这是一个正常的，健康的返回值。在引言中介绍的最常见的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; 它是最常见的返回值。</target>
        </trans-unit>
        <trans-unit id="a74b91a12c8bd155dd6272fb26f51914a5b6669f" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan one token from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan a token or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;token()&lt;/code&gt; with more characters to try an scan the token. This is continued until a token has been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">这是一个重入呼叫，尝试从 &lt;code&gt;Chars&lt;/code&gt; 扫描一个令牌。如果 &lt;code&gt;Chars&lt;/code&gt; 中有足够的字符可以扫描令牌或检测到错误，则将返回 &lt;code&gt;{done,...}&lt;/code&gt; 。否则 &lt;code&gt;{cont,Cont}&lt;/code&gt; 将返回{cont，Cont}，其中在下一次对 &lt;code&gt;token()&lt;/code&gt; 的调用中使用 &lt;code&gt;Cont&lt;/code&gt; 时,将使用更多字符尝试扫描令牌。继续进行直到扫描了令牌为止。 &lt;code&gt;Cont&lt;/code&gt; 最初是 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd5f47604323fa85263c477df2f49651a6e3df8c" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan tokens from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan tokens or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;tokens()&lt;/code&gt; with more characters to try an scan the tokens. This is continued until all tokens have been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">这是重入呼叫，以尝试从 &lt;code&gt;Chars&lt;/code&gt; 扫描令牌。如果 &lt;code&gt;Chars&lt;/code&gt; 中有足够的字符来扫描令牌或检测到错误，则将返回 &lt;code&gt;{done,...}&lt;/code&gt; 。否则 &lt;code&gt;{cont,Cont}&lt;/code&gt; 将返回{cont，Cont}，其中在下一次对 &lt;code&gt;tokens()&lt;/code&gt; 的调用中使用 &lt;code&gt;Cont&lt;/code&gt; 时，使用更多字符尝试扫描令牌。继续进行直到所有令牌都被扫描为止。 &lt;code&gt;Cont&lt;/code&gt; 最初是 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed7d83881b92d8f8849b160af3bcd9a10b096707" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;report_errors&lt;/code&gt; 和 &lt;code&gt;report_warnings&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="274dc8f24a407d0b1cda6dac95a4fedcd1f99a11" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;return_errors&lt;/code&gt; 和 &lt;code&gt;return_warnings&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="161cf6b2273cd2e876452ed9511de7c5f7ad17eb" translate="yes" xml:space="preserve">
          <source>This is a shorter and clearer form of &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Time = infinity&lt;/code&gt; which cancels a time-out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b415593166c4a9ddd5fa9eb4f27a156aba749468" translate="yes" xml:space="preserve">
          <source>This is a simple example of starting the TFTP server and reading the content of a sample file using the TFTP client.</source>
          <target state="translated">这是一个启动TFTP服务器并使用TFTP客户端读取样本文件内容的简单例子。</target>
        </trans-unit>
        <trans-unit id="3281f2cefa8864b51e113449543fc81b263cbe51" translate="yes" xml:space="preserve">
          <source>This is a simplified sequence describing what &lt;code&gt;trace_pattern&lt;/code&gt; goes through when adding a new breakpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808da979a84710e3348d8f0999feea04935b391f" translate="yes" xml:space="preserve">
          <source>This is a slight modification of the ping pong program where both processes are spawned from the same &lt;code&gt;start/1&lt;/code&gt; function, and the &quot;ping&quot; process can be spawned on a separate node. Notice the use of the &lt;code&gt;link&lt;/code&gt; BIF. &quot;Ping&quot; calls &lt;code&gt;exit(ping)&lt;/code&gt; when it finishes and this causes an exit signal to be sent to &quot;pong&quot;, which also terminates.</source>
          <target state="translated">这是对乒乓程序的略微修改，其中两个进程都从相同的 &lt;code&gt;start/1&lt;/code&gt; 函数生成，并且&amp;ldquo; ping&amp;rdquo;进程可以在单独的节点上生成。注意 &lt;code&gt;link&lt;/code&gt; BIF 的使用。&amp;ldquo; Ping&amp;rdquo; 完成时会调用 &lt;code&gt;exit(ping)&lt;/code&gt; ，这会导致将退出信号发送到&amp;ldquo; pong&amp;rdquo;，后者也会终止。</target>
        </trans-unit>
        <trans-unit id="73a9a1cddaa9852a0011d5e8ce12699ed0d05497" translate="yes" xml:space="preserve">
          <source>This is a so-called Erlang I/O ErrorInfo structure; see the &lt;code&gt;io(3)&lt;/code&gt; module for details.</source>
          <target state="translated">这就是所谓的Erlang I / O ErrorInfo结构。有关详细信息，请参见 &lt;code&gt;io(3)&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="e343f368517e25b67cf5e58932e33d7c4ed349a4" translate="yes" xml:space="preserve">
          <source>This is a standard macro (that is, defined by the system, not by the user). &lt;code&gt;?MODULE&lt;/code&gt; is always replaced by the name of the current module (that is, the &lt;code&gt;-module&lt;/code&gt; definition near the start of the file). There are more advanced ways of using macros with, for example, parameters (*manual*).</source>
          <target state="translated">这是一个标准宏（即由系统而不是由用户定义）。 &lt;code&gt;?MODULE&lt;/code&gt; 始终替换为当前模块的名称（即，文件开头附近的 &lt;code&gt;-module&lt;/code&gt; 定义）。有使用参数等宏的更高级方法，例如，参数（* manual *）。</target>
        </trans-unit>
        <trans-unit id="69b7150a1e2635ac10627a958161be921d3a386e" translate="yes" xml:space="preserve">
          <source>This is a statistics event with current count of successful, skipped, and failed test cases so far. This event is sent after the end of each test case, immediately following event &lt;code&gt;tc_done&lt;/code&gt;.</source>
          <target state="translated">这是一个统计事件，到目前为止，当前有成功，跳过和失败的测试用例计数。在每个测试用例结束后，紧随事件 &lt;code&gt;tc_done&lt;/code&gt; 之后发送此事件。</target>
        </trans-unit>
        <trans-unit id="d357df916eaf2872bc4e68740c1b378e80709c63" translate="yes" xml:space="preserve">
          <source>This is a stronger method where the ssh protocol brings the user name, the user's public key and some cryptographic information which we could ignore here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398909e587f906e89bc126a8eb8fdfd6b8204296" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated &lt;code&gt;select/2&lt;/code&gt; calls.</source>
          <target state="translated">这是一个有用的调试和测试工具，尤其是在编写复杂的 &lt;code&gt;select/2&lt;/code&gt; 调用时。</target>
        </trans-unit>
        <trans-unit id="ef77778e97bbcd3de76e5cb922449c0969559f39" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated match specifications.</source>
          <target state="translated">这是一个有用的调试和测试工具,特别是在编写复杂的匹配规格时。</target>
        </trans-unit>
        <trans-unit id="cc0b0332cdc379fcfaab7b7f81af77dfd65580d0" translate="yes" xml:space="preserve">
          <source>This is a useful way to test a generated boot script locally.</source>
          <target state="translated">这是一个测试本地生成的启动脚本的有用方法。</target>
        </trans-unit>
        <trans-unit id="978194809925fd52d8e900a08a5d143726fc77cb" translate="yes" xml:space="preserve">
          <source>This is a utility function meant to be used in the shell for printing the allowed characters in each major URI component, and also in the most important characters sets. Please note that this function does not replace the ABNF rules defined by the standards, these character sets are derived directly from those aformentioned rules. For more information see the &lt;code&gt;&lt;a href=&quot;uri_string_usage#percent_encoding&quot;&gt;Uniform Resource Identifiers&lt;/a&gt;&lt;/code&gt; chapter in stdlib's Users Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1d072ab39ba63d2cf9e54937425fb41a6e24e0" translate="yes" xml:space="preserve">
          <source>This is a utility function used to inspect, for instance, memory usage, in a simple way.</source>
          <target state="translated">这是一个用于检查内存使用情况的实用函数,例如,以简单的方式。</target>
        </trans-unit>
        <trans-unit id="1e82946d829123c6910c06194e9e7cebf010cb22" translate="yes" xml:space="preserve">
          <source>This is a utility function, that can be useful when e.g. debugging instrumentation functions.</source>
          <target state="translated">这是一个实用函数,在调试仪器功能时很有用。</target>
        </trans-unit>
        <trans-unit id="638f44b006e9ddc55b07c2ecf8dd004cd4e662bc" translate="yes" xml:space="preserve">
          <source>This is a utility function; see &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; for further details.</source>
          <target state="translated">这是一个实用程序功能；有关更多详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4ecf4af35ccbc508f0f2a3b4017f2147f96a8d" translate="yes" xml:space="preserve">
          <source>This is accomplished as follows:</source>
          <target state="translated">具体做法如下:</target>
        </trans-unit>
        <trans-unit id="c701533d2b77a06763413555d9faee562dbae932" translate="yes" xml:space="preserve">
          <source>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt; enif_send&lt;/a&gt;&lt;/code&gt;. Information about thread primitives is provided below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1661232769f6d1b51ba5b2ab390488adc40b1764" translate="yes" xml:space="preserve">
          <source>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt;. Information about thread primitives is provided below.</source>
          <target state="translated">这是通过将工作分配给NIF库管理的另一个线程，从NIF返回并等待结果来完成的。线程可以使用 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 将结果发送回Erlang进程。下面提供了有关线程基元的信息。</target>
        </trans-unit>
        <trans-unit id="a3a5884eaf41dfb2c20bb095d899f4bb1aee0421" translate="yes" xml:space="preserve">
          <source>This is all that has to be done! Now the manager can read, add, and modify rows. Also, you can use the ordinary Mnesia API to access the table from your programs. The only explicit action is to create the Mnesia table, an action the user has to perform in order to create the required table schemas.</source>
          <target state="translated">这就是所有要做的事情! 现在经理可以读取、添加和修改行。同时,你可以使用普通的Mnesia API从你的程序中访问表。唯一显式的操作是创建Mnesia表,用户必须执行这个操作才能创建所需的表模式。</target>
        </trans-unit>
        <trans-unit id="2b23a1bbf224deed4021f7affe8851472e761554" translate="yes" xml:space="preserve">
          <source>This is allowed in ASN.1 and the ASN.1-to-Erlang compiler supports this recursive type. A value for this type is assigned in Erlang as follows:</source>
          <target state="translated">这在ASN.1中是允许的,ASN.1-to-Erlang编译器支持这个递归类型。这个类型的值在Erlang中分配如下。</target>
        </trans-unit>
        <trans-unit id="b9c60488fe7be932bfbb686280514f6095ca5c3b" translate="yes" xml:space="preserve">
          <source>This is also handled automatically by the megaco application. First of all, segmentation is only attempted if so configured, see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; option. Secondly, megaco relies on the ability of the used codec to encode action replies, which is the smallest component the megaco application handles when segmenting. Thirdly, the reply will be segmented only if the sum of the size of the action replies (plus an arbitrary message header size) are greater then the specified max message size (see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; option). Finally, if segmentation is decided, then each action reply will make up its own (segment) message.</source>
          <target state="translated">megaco应用程序也会自动处理此问题。首先，仅在进行了分段配置后才尝试分段，请参见 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; 选项。其次，megaco依赖于所使用的编解码器对动作回复进行编码的能力，这是megaco应用程序进行分段时处理的最小组件。第三，仅当动作答复的大小之和（加上任意的消息头大小）大于指定的最大消息大小（请参见 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; 选项）时，才对答复进行分段。最后，如果确定了分段，则每个操作答复将组成其自己的（分段）消息。</target>
        </trans-unit>
        <trans-unit id="c22b40b578529e2c84690ed6b337febcebea2978" translate="yes" xml:space="preserve">
          <source>This is also the case for functions &lt;code&gt;red/2&lt;/code&gt;, &lt;code&gt;blue/2&lt;/code&gt;, and &lt;code&gt;green/2&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;red/2&lt;/code&gt; ， &lt;code&gt;blue/2&lt;/code&gt; 和 &lt;code&gt;green/2&lt;/code&gt; 也是这种情况。</target>
        </trans-unit>
        <trans-unit id="66cae3829517c0c1511c6c613a5e64f898384f8a" translate="yes" xml:space="preserve">
          <source>This is an abstract representation of syntax tree node attributes; see the function &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是语法树节点属性的抽象表示。参见功能 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f87e2d574185c8fa053abdd8e9a5dea9632b99eb" translate="yes" xml:space="preserve">
          <source>This is an enhanced subset of the operations provided by the &lt;code&gt;&lt;a href=&quot;rpc&quot;&gt;rpc&lt;/a&gt;&lt;/code&gt; module. Enhanced in the sense that it makes it possible to distinguish between returned value, raised exceptions, and other errors. &lt;code&gt;erpc&lt;/code&gt; also has better performance and scalability than the original &lt;code&gt;rpc&lt;/code&gt; implementation. However, current &lt;code&gt;rpc&lt;/code&gt; module will utilize &lt;code&gt;erpc&lt;/code&gt; in order to also provide these properties when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2128cfc6cbe9e874c7e25ecf50f44f2ff9c59c9d" translate="yes" xml:space="preserve">
          <source>This is an enhancement of &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. It gives the possibility to:</source>
          <target state="translated">这是对 &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 的增强。它使可能性：</target>
        </trans-unit>
        <trans-unit id="bb4355c46a241b6ccaa141fa3ca19310a4e18377" translate="yes" xml:space="preserve">
          <source>This is an example of an &quot;atomic group&quot;, details are provided below.</source>
          <target state="translated">这是一个 &quot;原子组 &quot;的例子,详情见下文。</target>
        </trans-unit>
        <trans-unit id="2afe84bec16e754c046d7de19fb9588006197ad9" translate="yes" xml:space="preserve">
          <source>This is an example of writing and then reading a tar file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1ddb6f8bac020a202291b264051bd5948a4982" translate="yes" xml:space="preserve">
          <source>This is an extremly dangerous function. You use it on your own risk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdd0e3d179b7cbbf8f37996643142fe64dc77b4" translate="yes" xml:space="preserve">
          <source>This is an intentionally rough guide to the relative costs of different calls. It is based on benchmark figures run on Solaris/Sparc:</source>
          <target state="translated">这是对不同呼叫的相对成本的一个有意的粗略指导。它是根据在Solaris/Sparc上运行的基准数字得出的。</target>
        </trans-unit>
        <trans-unit id="f4c4ab4d5f5e4f366b3c529f50a5c1512948dcaf" translate="yes" xml:space="preserve">
          <source>This is an interface module for the Reltool application.</source>
          <target state="translated">这是一个Reltool应用的接口模块。</target>
        </trans-unit>
        <trans-unit id="03e3358ac9f51a5518985ca7ba361683826cf828" translate="yes" xml:space="preserve">
          <source>This is an opaque data type that identifies a monitor.</source>
          <target state="translated">这是一种不透明的数据类型,用于标识显示器。</target>
        </trans-unit>
        <trans-unit id="45feb4b3d79044c88ed9b57379b548682c9417a6" translate="yes" xml:space="preserve">
          <source>This is an optimization to achieve very efficient concurrent &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operations at the expense of potential read inconsistency and memory consumption per counter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ef7d5997459d409e40c1dbe84146420ac9b4f9" translate="yes" xml:space="preserve">
          <source>This is any extra info the user wants to have supplied when the functions in the callback module is called.</source>
          <target state="translated">这是当回调模块中的函数被调用时,用户希望提供的任何额外信息。</target>
        </trans-unit>
        <trans-unit id="08a7da6db995a217d09a30c00205bf365c46e13e" translate="yes" xml:space="preserve">
          <source>This is as of Erlang/OTP 17.0 the default. It forces any floats in the term to be encoded in a more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to a textual representation). As from Erlang/OTP R11B-4, &lt;code&gt;binary_to_term/1&lt;/code&gt; can decode this representation.</source>
          <target state="translated">这是默认的Erlang / OTP 17.0版本。它将强制以更节省空间和更精确的方式（即采用64位IEEE格式，而不是转换为文本表示形式）对术语中的所有浮点进行编码。从Erlang / OTP R11B-4起， &lt;code&gt;binary_to_term/1&lt;/code&gt; 可以解码此表示形式。</target>
        </trans-unit>
        <trans-unit id="113749aad29dc1cdbedc3b815e734a581ecdd057" translate="yes" xml:space="preserve">
          <source>This is bad luck, the process was garbage collecting when the crash dump was written. The rest of the information for this process is limited.</source>
          <target state="translated">这下可倒霉了,写崩溃转储的时候,这个进程正在收集垃圾。这个过程的其他信息是有限的。</target>
        </trans-unit>
        <trans-unit id="2b06c013992850341fe5a82bf55411c7f74bcdc5" translate="yes" xml:space="preserve">
          <source>This is because record definitions are only available at compile time, not at runtime. For details on records in the shell, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">这是因为记录定义仅在编译时可用，而在运行时不可用。有关shell中记录的详细信息，请参见STDLIB中的 &lt;code&gt;shell(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="8afd6050f97c61cdb32e6c96ba6b457c161482c6" translate="yes" xml:space="preserve">
          <source>This is called &lt;strong&gt;synchronized code replacement&lt;/strong&gt; and for this the following instructions are used:</source>
          <target state="translated">这称为&lt;strong&gt;同步代码替换&lt;/strong&gt;，为此使用以下说明：</target>
        </trans-unit>
        <trans-unit id="646259e147d9a776464db65bc4bea0ac6f13d14c" translate="yes" xml:space="preserve">
          <source>This is done by adding or deleting the &lt;code&gt;error_logger_file_h&lt;/code&gt; event handler, and thus indirectly adding &lt;code&gt;error_logger&lt;/code&gt; as a Logger handler.</source>
          <target state="translated">通过添加或删除 &lt;code&gt;error_logger_file_h&lt;/code&gt; 事件处理程序，然后间接将 &lt;code&gt;error_logger&lt;/code&gt; 添加为Logger处理程序来完成此操作。</target>
        </trans-unit>
        <trans-unit id="681acf8836c69537b79e14e48dcac39812f986dc" translate="yes" xml:space="preserve">
          <source>This is done by manipulating the Logger configuration. The function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">这可以通过操作Logger配置来完成。该功能在开发和测试期间可用作快捷方式，但不得在生产系统中使用。有关如何为实时系统配置Logger的信息，请参见《内核用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 部分和 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="180abcd23e113c6f5993e0e4b65009873a53afdd" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, &lt;code&gt;Return&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. &lt;code&gt;Config&lt;/code&gt; in this case is the same &lt;code&gt;Config&lt;/code&gt; as the testcase is called with. &lt;code&gt;Return&lt;/code&gt; is the value returned by the testcase. If the testcase fails by crashing, &lt;code&gt;Return&lt;/code&gt; is &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt;.</source>
          <target state="translated">这在称为 &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt; 的CTH函数中完成。这些函数采用 &lt;code&gt;SuiteName&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; （组或测试用例名称，如果适用）， &lt;code&gt;Config&lt;/code&gt; ， &lt;code&gt;Return&lt;/code&gt; 和 &lt;code&gt;CTHState&lt;/code&gt; 作为参数。 &lt;code&gt;Config&lt;/code&gt; 在这种情况下，相同 &lt;code&gt;Config&lt;/code&gt; 的测试用例被调用。 &lt;code&gt;Return&lt;/code&gt; 是测试用例返回的值。如果测试用例因崩溃而失败，则 &lt;code&gt;Return&lt;/code&gt; 为 &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ab57d9407d3cc2fec5c4c069b356365d21838b" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;.</source>
          <target state="translated">这在称为 &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt; 的CTH函数中完成。这些函数采用 &lt;code&gt;SuiteName&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; （组或测试用例的名称，如果适用）， &lt;code&gt;Config&lt;/code&gt; 和 &lt;code&gt;CTHState&lt;/code&gt; 作为参数。CTH函数的返回值始终是套件/组/测试的结果与更新的 &lt;code&gt;CTHState&lt;/code&gt; 的组合。</target>
        </trans-unit>
        <trans-unit id="bfd349ddda4246be97d235609d023e3a44aa81a6" translate="yes" xml:space="preserve">
          <source>This is done until the end of the list is reached, that is, the list is empty:</source>
          <target state="translated">直到到达列表的末端,即列表为空。</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">这相当于</target>
        </trans-unit>
        <trans-unit id="d11de2ea50c52f849f3bde4848fccd123f17645d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">这等效于 &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt; ，但可能更有效。</target>
        </trans-unit>
        <trans-unit id="5c2e34b39e7cb8fbbca41e01630396e57161f9bd" translate="yes" xml:space="preserve">
          <source>This is equivalent to a call to:</source>
          <target state="translated">这相当于呼吁:</target>
        </trans-unit>
        <trans-unit id="b89997f1aaabac9326c311cc6347ce9ddb0e3b91" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt;:</source>
          <target state="translated">这等效于调用 &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b99c8c34be448e6bbcfec89b94bf9160fbaeb4a" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt;:</source>
          <target state="translated">这等效于调用 &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="97a7c564e0e141ccb4b750a31aa63ab870cbb904" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following specification:</source>
          <target state="translated">这相当于下面的规范。</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">这相当于:</target>
        </trans-unit>
        <trans-unit id="4b93967cb769ce4a169bcbd657ff004f71b25464" translate="yes" xml:space="preserve">
          <source>This is expanded to:</source>
          <target state="translated">这扩大到:</target>
        </trans-unit>
        <trans-unit id="732ce2a7a4465b34c1eb7162718b1da76d4ed1e9" translate="yes" xml:space="preserve">
          <source>This is experimental code that can be changed or removed anytime without any warning.</source>
          <target state="translated">这是实验性的代码,可以随时更改或删除,没有任何警告。</target>
        </trans-unit>
        <trans-unit id="1093a321a621a1d24d25a283757e5229ec776381" translate="yes" xml:space="preserve">
          <source>This is followed by a call to &lt;code&gt;open/4&lt;/code&gt; before any read/write access is performed. &lt;code&gt;AcceptedOptions&lt;/code&gt; is sent to the server, which replies with the options that it accepts. These are then forwarded to &lt;code&gt;open/4&lt;/code&gt; as &lt;code&gt;SuggestedOptions&lt;/code&gt;.</source>
          <target state="translated">在执行任何读/写访问之前，随后调用 &lt;code&gt;open/4&lt;/code&gt; 。 &lt;code&gt;AcceptedOptions&lt;/code&gt; 被发送到服务器，服务器以其接受的选项进行回复。然后将它们作为 &lt;code&gt;SuggestedOptions&lt;/code&gt; 转发到 &lt;code&gt;open/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef43207effbfa0c4bc3102645253272383b860ee" translate="yes" xml:space="preserve">
          <source>This is handled automatically by the megaco application. There is however one thing that need to be configured by the user, the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">这是由megaco应用程序自动处理的。但是，用户需要配置一件事情， &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="29f190ed43ce30d7d9b9d196be4fa299d1c36697" translate="yes" xml:space="preserve">
          <source>This is if it is used in the context of the match operator as in the example.</source>
          <target state="translated">如果它是在匹配操作符的上下文中使用的,如本例。</target>
        </trans-unit>
        <trans-unit id="7b6a3bc9957c826c254223da8d53ebcc53f4e171" translate="yes" xml:space="preserve">
          <source>This is illustrated in the following table:</source>
          <target state="translated">下表说明了这一点。</target>
        </trans-unit>
        <trans-unit id="3a9346a5e9e0ffd489af06c1ad2635ffc6b9ae2c" translate="yes" xml:space="preserve">
          <source>This is implementattion depended. That is, it depends on the module. For each module a specific set of options are valid. For the module provided with the app, these options are supported:</source>
          <target state="translated">这是实现上的依赖。也就是说,它取决于模块。对于每个模块,都有一组特定的选项是有效的。对于应用程序提供的模块,这些选项都是支持的。</target>
        </trans-unit>
        <trans-unit id="114d08a8e002db6d0c9182141940ed632dd9d634" translate="yes" xml:space="preserve">
          <source>This is in effect a progress report.</source>
          <target state="translated">这实际上是一份进度报告。</target>
        </trans-unit>
        <trans-unit id="a159e1612a81f8d86b525155c551f0929580069d" translate="yes" xml:space="preserve">
          <source>This is no longer the case. If you require &lt;code&gt;'undefined'&lt;/code&gt; in your record field type, you must explicitly add it to the typespec, as in the 2nd example.</source>
          <target state="translated">这已不再是这种情况。如果在记录字段类型中需要 &lt;code&gt;'undefined'&lt;/code&gt; ，则必须像第二个示例一样将其显式添加到typespec中。</target>
        </trans-unit>
        <trans-unit id="33403ecb7959eebc92f2663aeded4a8c6c3bee94" translate="yes" xml:space="preserve">
          <source>This is normally a wise decision, but it can be disastrous if the nodes have been disconnected because of a communication failure, as the &lt;code&gt;Mnesia&lt;/code&gt; normal table load mechanism does not cope with communication failures.</source>
          <target state="translated">这通常是明智的决定，但是如果节点由于通信故障而断开连接，则可能会造成灾难性的后果，因为 &lt;code&gt;Mnesia&lt;/code&gt; 普通表加载机制无法应对通信故障。</target>
        </trans-unit>
        <trans-unit id="868d49c485867e5bfe4e2b7dfc7ac02d90106823" translate="yes" xml:space="preserve">
          <source>This is normally the default &lt;code&gt;malloc&lt;/code&gt; implementation used on the specific OS.</source>
          <target state="translated">通常，这是特定OS上使用的默认 &lt;code&gt;malloc&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="9dde21bfce3c688dc390548f3494e7bf552bd9fc" translate="yes" xml:space="preserve">
          <source>This is not a full-fledged resolver, only a DNS client that relies on asking trusted recursive name servers.</source>
          <target state="translated">这不是一个成熟的解析器,只是一个依靠询问可信递归名称服务器的DNS客户端。</target>
        </trans-unit>
        <trans-unit id="836326e8e7b02322f5679431a9ac0cf2a7bdaf26" translate="yes" xml:space="preserve">
          <source>This is not a proper Unicode representation, but the representation used for characters before the Unicode standard. It can still be used to represent character code points in the Unicode standard with numbers &amp;lt; 256, which exactly corresponds to the ISO Latin-1 character set. In Erlang, this is commonly denoted &lt;code&gt;latin1&lt;/code&gt; encoding, which is slightly misleading as ISO Latin-1 is a character code range, not an encoding.</source>
          <target state="translated">这不是正确的Unicode表示形式，而是用于Unicode标准之前的字符的表示形式。在Unicode标准中，它仍然可以用来表示数字&amp;lt;256的字符代码点，该数字完全对应于ISO Latin-1字符集。在Erlang中，通常将其表示为 &lt;code&gt;latin1&lt;/code&gt; 编码，由于ISO Latin-1是字符代码范围而不是编码，因此会稍有误导。</target>
        </trans-unit>
        <trans-unit id="2c58e7e1b5e3d20a4fa526ed7b8e2cfc77c34073" translate="yes" xml:space="preserve">
          <source>This is not entirely safe, as it is vulnerable against takeover attacks, but it is a tradeoff between fair safety and performance.</source>
          <target state="translated">这并不是完全安全的,因为它容易受到接管攻击,但这是公平安全和性能之间的权衡。</target>
        </trans-unit>
        <trans-unit id="43d40b61a5fa7c9dc787ea193a5ed313e523277b" translate="yes" xml:space="preserve">
          <source>This is not important if you do not postpone events. But if you later decide to start postponing some events, then the design flaw of not having separate states when they should be, might become a hard to find bug.</source>
          <target state="translated">如果你不推迟事件,这并不重要。但如果你后来决定开始推迟一些事件,那么该有的时候没有单独的状态的设计缺陷,可能会成为一个很难发现的bug。</target>
        </trans-unit>
        <trans-unit id="a61dc5f6b213458abec4f8eccdc89fe38585fdf1" translate="yes" xml:space="preserve">
          <source>This is not important if you do not postpone events. But if you later decide to start postponing some events, then the design flaw of not having separate states when they should be, might become a hard-to-find bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f78e9c138cff8dcc48b10d2119a79c6c5f383e" translate="yes" xml:space="preserve">
          <source>This is not the wanted result. To achieve the desired effect, &lt;code&gt;select&lt;/code&gt; must be written as follows:</source>
          <target state="translated">这不是想要的结果。为了达到理想的效果， &lt;code&gt;select&lt;/code&gt; 必须编写如下：</target>
        </trans-unit>
        <trans-unit id="b7f69a6080f0d1385f2abcc049f00ad9be5341c1" translate="yes" xml:space="preserve">
          <source>This is perhaps the most central module in the entirety of the &lt;code&gt;et&lt;/code&gt; suite. The &lt;code&gt;Collector&lt;/code&gt; needs &quot;filters&quot; to convert the &lt;code&gt;Raw Trace Data&lt;/code&gt; into &quot;events&quot; that it can display. The &lt;code&gt;et_selector&lt;/code&gt; module provides the default &lt;code&gt;Filter&lt;/code&gt; and some API calls to manage the &lt;code&gt;Trace Pattern&lt;/code&gt;. The &lt;code&gt;Selector&lt;/code&gt; provides various functions that achieve the following:</source>
          <target state="translated">这也许是整个 &lt;code&gt;et&lt;/code&gt; 套件中最核心的模块。该 &lt;code&gt;Collector&lt;/code&gt; 需要&amp;ldquo;过滤器&amp;rdquo;的转换 &lt;code&gt;Raw Trace Data&lt;/code&gt; 为&amp;ldquo;事件&amp;rdquo;，它可以显示。该 &lt;code&gt;et_selector&lt;/code&gt; 模块提供的默认 &lt;code&gt;Filter&lt;/code&gt; 以及一些API调用来管理 &lt;code&gt;Trace Pattern&lt;/code&gt; 。该 &lt;code&gt;Selector&lt;/code&gt; 提供了实现以下多种功能：</target>
        </trans-unit>
        <trans-unit id="bd78b41da72f8f6a1b1b335bee4881061346e4af" translate="yes" xml:space="preserve">
          <source>This is possibly a little clearer.</source>
          <target state="translated">这一点可能比较清楚。</target>
        </trans-unit>
        <trans-unit id="7063cc576e9b11f727c2ae0cabc7e8bc7b76b64e" translate="yes" xml:space="preserve">
          <source>This is primarily a way to show the effects of using the reentrant flex scanner instead of the non-reentrant.</source>
          <target state="translated">这主要是为了展示使用再入式柔性扫描仪而非再入式的效果。</target>
        </trans-unit>
        <trans-unit id="7f43cbca3b6fcf016e7da8036914af019823f1d9" translate="yes" xml:space="preserve">
          <source>This is read as follows: The list of X such that X is taken from the list &lt;code&gt;[1,2,a,...]&lt;/code&gt; and X is greater than 3.</source>
          <target state="translated">内容如下：X的列表，使得X从列表 &lt;code&gt;[1,2,a,...]&lt;/code&gt; 中获取,并且X大于3。</target>
        </trans-unit>
        <trans-unit id="e5bbd1957b21e024367be0eb839936ca962e71f8" translate="yes" xml:space="preserve">
          <source>This is received by the client, which in turn does &lt;code&gt;exit(normal)&lt;/code&gt; and terminates. If &lt;code&gt;keysearch&lt;/code&gt; returns &lt;code&gt;{value,{From,Name}}&lt;/code&gt; it is certain that the user is logged on and that his name (peter) is in variable &lt;code&gt;Name&lt;/code&gt;.</source>
          <target state="translated">这是由客户端接收的，客户端依次 &lt;code&gt;exit(normal)&lt;/code&gt; 并终止。如果 &lt;code&gt;keysearch&lt;/code&gt; 返回 &lt;code&gt;{value,{From,Name}}&lt;/code&gt; ，则可以确定用户已登录并且其名称（字符）在变量 &lt;code&gt;Name&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="81a8f87d1727d52beaa427ce4936112ae848bc0b" translate="yes" xml:space="preserve">
          <source>This is received by the client.</source>
          <target state="translated">这是由客户收到的。</target>
        </trans-unit>
        <trans-unit id="6c40d6a299f26d7b05469a35afc3ecd07bd6f779" translate="yes" xml:space="preserve">
          <source>This is simply an erlang compatible text-file with the following structure: &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt;.</source>
          <target state="translated">这只是一个与erlang兼容的文本文件，其结构如下： &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44863f1a9281f46194959277b2c84306dd047f31" translate="yes" xml:space="preserve">
          <source>This is slightly faster for probably the most common case that the input lists are not empty or very short. (Another advantage is that Dialyzer can deduce a better type for the &lt;code&gt;Xs&lt;/code&gt; variable.)</source>
          <target state="translated">对于可能最常见的输入列表不为空或非常短的情况，这会稍微快一些。（另一个优点是Dialyzer可以为 &lt;code&gt;Xs&lt;/code&gt; 变量推断出更好的类型。）</target>
        </trans-unit>
        <trans-unit id="709cd27ea3760e45f8fdbf83a2674e3dd14b99e2" translate="yes" xml:space="preserve">
          <source>This is slightly more efficient because here you do not build a list element only to copy it directly. (Or it would be more efficient if the compiler did not automatically rewrite &lt;code&gt;[H]++Acc&lt;/code&gt; to &lt;code&gt;[H|Acc]&lt;/code&gt;.)</source>
          <target state="translated">这会稍微提高效率，因为在这里您不构建列表元素只是为了直接复制它。（或者，如果编译器不自动将 &lt;code&gt;[H]++Acc&lt;/code&gt; 重写为 &lt;code&gt;[H|Acc]&lt;/code&gt; 效率会更高）。</target>
        </trans-unit>
        <trans-unit id="4f59ec1eb2875e58bffaa8ecb426dbb6d7dc8700" translate="yes" xml:space="preserve">
          <source>This is sometimes the only way to run distributed Erlang if the Domain Name System (DNS) is not running. No communication can exist between nodes running with flag &lt;code&gt;-sname&lt;/code&gt; and those running with flag &lt;code&gt;-name&lt;/code&gt;, as node names must be unique in distributed Erlang systems.</source>
          <target state="translated">如果域名系统（DNS）未运行，则有时这是运行分布式Erlang的唯一方法。使用标志 &lt;code&gt;-sname&lt;/code&gt; 运行的节点与使用标志 &lt;code&gt;-name&lt;/code&gt; 运行的节点之间不能存在通信，因为节点名称在分布式Erlang系统中必须唯一。</target>
        </trans-unit>
        <trans-unit id="570f8642744ae6cd3a9675f1aad4ee8419ad33a1" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the equivalent, but harder to read:</source>
          <target state="translated">这是等价的句法糖,但比较难读。</target>
        </trans-unit>
        <trans-unit id="9e186bc5c4bbfebc187d81afa7fc46f64f868bc5" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the following:</source>
          <target state="translated">这是下面的句法糖。</target>
        </trans-unit>
        <trans-unit id="922370e690d4cc53426a28eb4d41e24f43cfe114" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb54970de95599c4474802466e4b9431c5e1008a" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;SSL/TLS&lt;/code&gt; connectin configuration option.</source>
          <target state="translated">这是 &lt;code&gt;SSL/TLS&lt;/code&gt; 连接配置选项。</target>
        </trans-unit>
        <trans-unit id="5b502c6950dc7c3f81c03175a62672f14e273c7b" translate="yes" xml:space="preserve">
          <source>This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac881df38163ed7b3cad0912165225c572fc928" translate="yes" xml:space="preserve">
          <source>This is the default handler used by OTP. Multiple instances can be started, and each instance will write log events to a given destination, terminal or file.</source>
          <target state="translated">这是OTP使用的默认处理程序。可以启动多个实例,每个实例都会将日志事件写入指定的目标、终端或文件。</target>
        </trans-unit>
        <trans-unit id="c4d57523639a2e8a475bc6496773bdbfcedee6d9" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for tables.</source>
          <target state="translated">这是表格的默认仪表功能。</target>
        </trans-unit>
        <trans-unit id="8a590bd244aa7fba225f4a56cad227855876f150" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for variables.</source>
          <target state="translated">这是变量的默认工具功能。</target>
        </trans-unit>
        <trans-unit id="0ea769a678284ef3199b2e2888a8634fc4803cb9" translate="yes" xml:space="preserve">
          <source>This is the default. It means the &lt;code&gt;Time&lt;/code&gt; value is interpreted as a time in milliseconds &lt;strong&gt;relative&lt;/strong&gt; current &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是默认值。这意味着 &lt;code&gt;Time&lt;/code&gt; 值被解释为以毫秒为单位的&lt;strong&gt;相对&lt;/strong&gt;当前 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0db12e389b3a4261d748d8d5279be613afd3e185" translate="yes" xml:space="preserve">
          <source>This is the directory holding the files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95887b28149dccf1da49196a8c57540f2278c1d" translate="yes" xml:space="preserve">
          <source>This is the directory holding the server's files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b3e5ab542a5f0debc59c85dd91647f80797616" translate="yes" xml:space="preserve">
          <source>This is the disk log type, &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;halt&lt;/code&gt;. The option corresponds to the &lt;code&gt;type&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是磁盘日志类型， &lt;code&gt;wrap&lt;/code&gt; 或 &lt;code&gt;halt&lt;/code&gt; 。该选项对应于 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 数据类型中的 &lt;code&gt;type&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="79cf40aec82f5e3c6c095b9a7f24df20c5c7f299" translate="yes" xml:space="preserve">
          <source>This is the fastest way of calling a driver and get a response. It makes no context switch in the Erlang emulator and requires no message passing. It is suitable for calling C function to get faster execution, when Erlang is too slow.</source>
          <target state="translated">这是调用驱动程序并获得响应的最快方式。它在Erlang仿真器中不做上下文切换,也不需要传递消息。当Erlang太慢的时候,它适合于调用C函数来获得更快的执行速度。</target>
        </trans-unit>
        <trans-unit id="f997eb6e8d88cc346ac8a25ffea65575e19dddfd" translate="yes" xml:space="preserve">
          <source>This is the first function called when a notification delivery is in progress. It informs the &lt;code&gt;receiver&lt;/code&gt; which targets will get the notification. The result of the delivery will be provided via successive calls to &lt;code&gt;delivery_info/4&lt;/code&gt; function, see below.</source>
          <target state="translated">这是在进行通知传递时调用的第一个函数。它通知 &lt;code&gt;receiver&lt;/code&gt; 哪些目标将获得通知。传递的结果将通过连续调用 &lt;code&gt;delivery_info/4&lt;/code&gt; 函数来提供，请参见下文。</target>
        </trans-unit>
        <trans-unit id="ba21277d355183275053e3909ab979314fa50468" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. It is sent just before the &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; function returns successfully. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">这是频道收到的第一条消息。它是在 &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 函数成功返回之前发送的。如果服务器希望在不首先从客户端接收消息的情况下向客户端发送消息，则此功能特别有用。如果该消息对您的特定情况没有用，请立即返回 &lt;code&gt;{ok, State}&lt;/code&gt; 忽略它。</target>
        </trans-unit>
        <trans-unit id="ff43ffc2013d60b90dbeef0ec3d72ae3abfda509" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">这是频道收到的第一条消息。如果服务器希望在不首先从客户端接收消息的情况下向客户端发送消息，则此功能特别有用。如果该消息对您的特定情况没有用，请立即返回 &lt;code&gt;{ok, State}&lt;/code&gt; 忽略它。</target>
        </trans-unit>
        <trans-unit id="f4993527ae602c81dada40230c7e4b229f40c09c" translate="yes" xml:space="preserve">
          <source>This is the full name of the disk log file. The option corresponds to the &lt;code&gt;name&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是磁盘日志文件的全名。该选项对应于 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 数据类型中的 &lt;code&gt;name&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5982af784f6f1a00b591611686e14f6193a9f84c" translate="yes" xml:space="preserve">
          <source>This is the interface module for the &lt;code&gt;SSH&lt;/code&gt; application. The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. See &lt;code&gt;ssh(6)&lt;/code&gt; for details of supported RFCs, versions, algorithms and unicode handling.</source>
          <target state="translated">这是 &lt;code&gt;SSH&lt;/code&gt; 应用程序的接口模块。安全外壳（SSH）协议是用于通过不安全网络进行安全远程登录和其他安全网络服务的协议。有关受支持的RFC，版本，算法和unicode处理的详细信息，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f80630a3cb0a4f72ab077d535fc76e765cca2dca" translate="yes" xml:space="preserve">
          <source>This is the low-level function to unload (or decrement reference counts of) a driver. It can be used to force port killing, in much the same way as the driver option &lt;code&gt;kill_ports&lt;/code&gt; implicitly does. Also, it can trigger a monitor either because other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still have the driver loaded or because open ports use the driver.</source>
          <target state="translated">这是卸载（或减少参考计数）驱动程序的底层函数。它可以用来强制端口杀死，其方式与驱动程序选项 &lt;code&gt;kill_ports&lt;/code&gt; 隐式执行的方式几乎相同。另外，它可能会触发监视器，原因是其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 仍在加载驱动程序，或者是因为开放端口使用了该驱动程序。</target>
        </trans-unit>
        <trans-unit id="eacd6f28e2e16d27200f6b33be43d951190f1539" translate="yes" xml:space="preserve">
          <source>This is the magic macro to initialize a NIF library. It is to be evaluated in global file scope.</source>
          <target state="translated">这是初始化NIF库的神奇宏。它将在全局文件范围内执行。</target>
        </trans-unit>
        <trans-unit id="a9ed06a82672ebce7c45ad63610c5550104e76dd" translate="yes" xml:space="preserve">
          <source>This is the main option and it controls the configuration of Reltool. It can either be a &lt;code&gt;sys&lt;/code&gt; tuple or a name of a &lt;code&gt;file&lt;/code&gt; containing a sys tuple.</source>
          <target state="translated">这是主要选项，它控制Reltool的配置。它可以是 &lt;code&gt;sys&lt;/code&gt; 元组，也可以是包含sys元组的 &lt;code&gt;file&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="3c9044a0169d5c61331b09923e7b20b8bc8aa7f2" translate="yes" xml:space="preserve">
          <source>This is the maximum allowed queue length. If the message queue grows larger than this, the handler process is terminated.</source>
          <target state="translated">这是允许的最大队列长度。如果消息队列的长度大于这个长度,处理程序进程就会终止。</target>
        </trans-unit>
        <trans-unit id="b9f45ed64c3e0c4da54fbe1eb312ba76516ad0e2" translate="yes" xml:space="preserve">
          <source>This is the maximum memory size that the handler process is allowed to use. If the handler grows larger than this, the process is terminated.</source>
          <target state="translated">这是处理程序进程允许使用的最大内存大小。如果处理程序的大小大于这个值,则该进程将被终止。</target>
        </trans-unit>
        <trans-unit id="16038a3786bdd4dedf260d26283b919a880bb676" translate="yes" xml:space="preserve">
          <source>This is the maximum number of bytes that is written to a log file before disk_log proceeds with the next file in order, or generates an error in case of a full halt log. The option corresponds to the &lt;code&gt;MaxNoBytes&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是disk_log按顺序处理下一个文件之前写入日志文件的最大字节数，或者在完全停止日志的情况下生成错误。的选项对应于 &lt;code&gt;MaxNoBytes&lt;/code&gt; 在元件 &lt;code&gt;size&lt;/code&gt; 在属性 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="459f135a3a42608f2bd3388de6fc151cb8110783" translate="yes" xml:space="preserve">
          <source>This is the maximum number of events to handle within a &lt;code&gt;burst_limit_window_time&lt;/code&gt; time frame. After the limit is reached, successive events are dropped until the end of the time frame.</source>
          <target state="translated">这是在 &lt;code&gt;burst_limit_window_time&lt;/code&gt; 时间范围内要处理的最大事件数。达到限制后，将丢弃连续的事件，直到时间范围结束为止。</target>
        </trans-unit>
        <trans-unit id="f9d007efced8ad7291f6b7473c324b69730b4bdb" translate="yes" xml:space="preserve">
          <source>This is the maximum number of files that disk_log uses for its circular logging. The option corresponds to the &lt;code&gt;MaxNoFiles&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">这是disk_log用于其循环日志记录的最大文件数。的选项对应于 &lt;code&gt;MaxNoFiles&lt;/code&gt; 在元件 &lt;code&gt;size&lt;/code&gt; 在属性 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 的数据类型。</target>
        </trans-unit>
        <trans-unit id="88ddfe714e0b66558fbe57136603410b11130d4d" translate="yes" xml:space="preserve">
          <source>This is the new encoding of internal funs: &lt;code&gt;fun F/A&lt;/code&gt; and &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt;.</source>
          <target state="translated">这是内部 &lt;code&gt;fun F/A&lt;/code&gt; 的新编码：fun F / A和 &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="837460bd7445a65a68a00b613c75a7744d0ed82a" translate="yes" xml:space="preserve">
          <source>This is the printout header of one process. The printout contains only this one process since we did &lt;code&gt;fprof:apply/3&lt;/code&gt; which traces only the current process. Therefore the CNT and OWN columns perfectly matches the totals above. The ACC column is undefined since summing the ACC times of all calls in the process makes no sense - you would get something like the ACC value from totals above multiplied by the average depth of the call stack, or something.</source>
          <target state="translated">这是一个进程的打印头。由于我们执行了 &lt;code&gt;fprof:apply/3&lt;/code&gt; ，因此仅打印当前进程，因此打印输出仅包含此进程。因此，CNT和OWN列与上面的总数完全匹配。ACC列是未定义的，因为将过程中所有调用的ACC时间相加是没有意义的-您将从上面的总数中得到ACC值，再乘以调用堆栈的平均深度之类的值。</target>
        </trans-unit>
        <trans-unit id="ee530acee221ac3457f1090f43fd370b8436c96d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant formatted reader. The continuation of the first call to the functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">这是可重入格式的阅读器。对函数的第一次调用的继续必须为 &lt;code&gt;[]&lt;/code&gt; 。有关可重入输入方案如何工作的完整说明，请参见Armstrong，Virding，Williams：&amp;ldquo; Erlang中的并行编程&amp;rdquo;，第13章。</target>
        </trans-unit>
        <trans-unit id="ecd4a7ad5696bedde8f5f313930da44fe12f224d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant scanner, which scans characters until either a &lt;strong&gt;dot&lt;/strong&gt; ('.' followed by a white space) or &lt;code&gt;eof&lt;/code&gt; is reached. It returns:</source>
          <target state="translated">这是可重入的扫描器，它扫描字符直到到达&lt;strong&gt;点&lt;/strong&gt;（&amp;ldquo;。&amp;rdquo;后跟空白）或 &lt;code&gt;eof&lt;/code&gt; 。它返回：</target>
        </trans-unit>
        <trans-unit id="4c87585c82ab9ef5b43a4d3bd9e435a0da3d966d" translate="yes" xml:space="preserve">
          <source>This is the return type from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; and selects &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; and whether to do &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad3ae21f4d6378b9390fab772b58bcf9e24057d" translate="yes" xml:space="preserve">
          <source>This is the return type from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; and selects &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; and whether to do &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, or not.</source>
          <target state="translated">这是来自 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 的返回类型，它选择 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; 以及是否进行 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e8ab784b5603c6b44491c28cae41829d1e3589" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sol&lt;/code&gt;, but only for the first call to &lt;code&gt;link/1&lt;/code&gt; by the traced process.</source>
          <target state="translated">这与 &lt;code&gt;sol&lt;/code&gt; 相同，但仅适用于被跟踪进程首次调用 &lt;code&gt;link/1&lt;/code&gt; 的情况。</target>
        </trans-unit>
        <trans-unit id="5d44ec075c5224429b7e914e2c0f01b386f3e0fd" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sos&lt;/code&gt;, but only for the first process spawned by the traced process.</source>
          <target state="translated">这与 &lt;code&gt;sos&lt;/code&gt; 相同，但仅适用于被跟踪进程产生的第一个进程。</target>
        </trans-unit>
        <trans-unit id="5c9a7f10551e6fef6526100ea65361d85f3b3c5e" translate="yes" xml:space="preserve">
          <source>This is the same as calling &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与调用 &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="ae7c485681a5d5be425044d9a2ecba3267612e5e" translate="yes" xml:space="preserve">
          <source>This is the same as doing, e.g.:</source>
          <target state="translated">这与做,如。</target>
        </trans-unit>
        <trans-unit id="750c9c2130115cb398cd55807f2f8cb0dffbe5fd" translate="yes" xml:space="preserve">
          <source>This is the same as mapfold/4, with an identity function as the pre-operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70feac208b0fafbbf1031f0ed7f8654773e27d3" translate="yes" xml:space="preserve">
          <source>This is the same as:</source>
          <target state="translated">这与。</target>
        </trans-unit>
        <trans-unit id="3b5a14eeead1c5ce60108308f333bdf8d18e6154" translate="yes" xml:space="preserve">
          <source>This is the short story though, for the experienced and impatient:</source>
          <target state="translated">这虽然是短篇小说,适合有经验的人和没有耐心的人。</target>
        </trans-unit>
        <trans-unit id="5cabfd28d4ff30cee5147e828bd4dda97a0b5763" translate="yes" xml:space="preserve">
          <source>This is the standard handler for Logger. Multiple instances of this handler can be added to Logger, and each instance prints logs to &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, or to file.</source>
          <target state="translated">这是Logger的标准处理程序。可以将此处理程序的多个实例添加到Logger，每个实例将日志打印到 &lt;code&gt;standard_io&lt;/code&gt; ， &lt;code&gt;standard_error&lt;/code&gt; 或文件中。</target>
        </trans-unit>
        <trans-unit id="7d0bc914b2bcbf775df160b6a080adcaa1ab6b48" translate="yes" xml:space="preserve">
          <source>This is the start of a hiearchy of opaque data structures that can be examined with access functions in &lt;code&gt;inet_dns&lt;/code&gt;, which return lists of &lt;code&gt;{Field,Value}&lt;/code&gt; tuples. The arity 2 functions only return the value for a specified field.</source>
          <target state="translated">这是不透明的数据结构的一个hiearchy它可以与访问功能被检查的开始 &lt;code&gt;inet_dns&lt;/code&gt; ，其返回的列表 &lt;code&gt;{Field,Value}&lt;/code&gt; 元组。Arity 2函数仅返回指定字段的值。</target>
        </trans-unit>
        <trans-unit id="d98c71268352e941036bfc46f7ac63a11dac3adf" translate="yes" xml:space="preserve">
          <source>This is the sum of the runtime for all threads in the Erlang runtime system and can therefore be greater than the wall clock time.</source>
          <target state="translated">这是Erlang运行时系统中所有线程的运行时间之和,因此可以大于墙时钟时间。</target>
        </trans-unit>
        <trans-unit id="f65cd2322c237b869a90671095b9d99fc32d6542" translate="yes" xml:space="preserve">
          <source>This is the top supervisor for the agent part of the SNMP application. There is always one supervisor at each node with an SNMP agent (master agent or sub-agent).</source>
          <target state="translated">这是SNMP应用的代理部分的最高监督者。在每个有SNMP代理(主代理或子代理)的节点上总是有一个监督者。</target>
        </trans-unit>
        <trans-unit id="1c91fd8459d792120c638965b077037f75eb8c7b" translate="yes" xml:space="preserve">
          <source>This is the type definition for the supervisor flags:</source>
          <target state="translated">这是主管标志的类型定义。</target>
        </trans-unit>
        <trans-unit id="8fcf634babe6dda8ecdbe08e51d07e7fe457d1af" translate="yes" xml:space="preserve">
          <source>This is to allow a transport process to keep count of the number of incoming request messages that have not yet been answered or discarded, to allow it to regulate the amount of incoming traffic. Both diameter_tcp and diameter_sctp request acknowledgements when a &lt;code&gt;message_cb&lt;/code&gt; is configured, turning send/recv message into callbacks that can be used to regulate traffic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9847ce6094bdf607fe5e13ee0e480c77d4dbdfd9" translate="yes" xml:space="preserve">
          <source>This is to be added to the &lt;code&gt;start&lt;/code&gt; script.</source>
          <target state="translated">这将被添加到 &lt;code&gt;start&lt;/code&gt; 脚本中。</target>
        </trans-unit>
        <trans-unit id="9cc5dbd4b0a6027790eeb7362903f65abf0802cc" translate="yes" xml:space="preserve">
          <source>This is to provide options that changes its general behavior and &quot;sticks&quot; to the driver throughout its lifespan.</source>
          <target state="translated">这是为了提供改变其一般行为的选项,并在驱动器的整个生命周期内 &quot;坚持&quot;。</target>
        </trans-unit>
        <trans-unit id="63ab71f3a67c414cba27c6d8e2befb9085535d6d" translate="yes" xml:space="preserve">
          <source>This is transformed into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这被转换为对 &lt;code&gt;my_table&lt;/code&gt; 的一次调用：</target>
        </trans-unit>
        <trans-unit id="fad7abe2a96807b6a5b8ac7472f217897f8a19e9" translate="yes" xml:space="preserve">
          <source>This is used for &lt;strong&gt;three-way-handshake&lt;/strong&gt;.</source>
          <target state="translated">这用于&lt;strong&gt;三向握手&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="72036e52d82b37ea2fc4d48dfb5499c608ebb71d" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to non-local function &lt;code&gt;FuncSpec&lt;/code&gt; (&lt;code&gt;{Module,Func}&lt;/code&gt; or a fun) with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed. The return value &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; can be used to let the shell evaluate some other function than the one specified by &lt;code&gt;FuncSpec&lt;/code&gt; and &lt;code&gt;ArgList&lt;/code&gt;.</source>
          <target state="translated">这用于确定是否允许使用参数 &lt;code&gt;ArgList&lt;/code&gt; 调用非本地函数 &lt;code&gt;FuncSpec&lt;/code&gt; （ &lt;code&gt;{Module,Func}&lt;/code&gt; 或fun）。返回值 &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; 可用于让shell评估除 &lt;code&gt;FuncSpec&lt;/code&gt; 和 &lt;code&gt;ArgList&lt;/code&gt; 指定的函数以外的其他函数。</target>
        </trans-unit>
        <trans-unit id="d65885f8646585ffb41393b4d943ab7b9e09ca48" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to the local function &lt;code&gt;Func&lt;/code&gt; with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed.</source>
          <target state="translated">这用于确定是否允许使用参数 &lt;code&gt;ArgList&lt;/code&gt; 调用本地函数 &lt;code&gt;Func&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4567b676fadac5a76d27950b200211f3a0074958" translate="yes" xml:space="preserve">
          <source>This just tests that the function &lt;code&gt;lists:reverse(List)&lt;/code&gt; does not crash when &lt;code&gt;List&lt;/code&gt; is &lt;code&gt;[1,2,3]&lt;/code&gt;. It is not a great test, but many people write simple functions like this one to test the basic functionality of their code, and those tests can be used directly by EUnit, without changes, as long as their function names match.</source>
          <target state="translated">这只是测试 &lt;code&gt;List&lt;/code&gt; = &lt;code&gt;[1,2,3]&lt;/code&gt; 时函数 &lt;code&gt;lists:reverse(List)&lt;/code&gt; 是否不会崩溃。这不是一个很好的测试，但是许多人都编写了像这样的简单函数来测试其代码的基本功能，只要这些函数名称匹配，这些测试就可以直接由EUnit使用，而无需更改。</target>
        </trans-unit>
        <trans-unit id="fe9522c485cb7d376d5642accb7a321aad5a05ed" translate="yes" xml:space="preserve">
          <source>This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</source>
          <target state="translated">这种小括号一旦匹配,就会 &quot;锁死 &quot;它所包含的那部分模式,再往模式中的失败就无法回溯到它。不过,回溯过去到之前的项目,则可以正常工作。</target>
        </trans-unit>
        <trans-unit id="f0a2c7bf5aba6f668f53ccf49a4fb9c6251f30d9" translate="yes" xml:space="preserve">
          <source>This kind of transformation is useful when it is rare that an operand can be anything else but a register. In the case of &lt;code&gt;is_number/2&lt;/code&gt;, the second operand is always a register unless the compiler optimizations have been disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbfa7bf9a0333e3f4da00679d91e91a638c7487" translate="yes" xml:space="preserve">
          <source>This last example is a quite common case in during normal operation. For example, when a scheduler thread runs out of work it tries to steal work from another scheduler threads run queue. When searching for a victim to steal from there was a lot of juggling of run queue locks involved, and during the actual theft finalized by having to lock both run queues and the process. When one scheduler runs out of work, often others also do, causing lots of lock contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82013b529d675da98d4511e184ab7425bf09102f" translate="yes" xml:space="preserve">
          <source>This list is actually two - one for each direction server-to-client and client-to-server. Therefore it is possible but rare to have different algorithms in the two directions in one connection.</source>
          <target state="translated">这个列表实际上是两个--服务器到客户端和客户端到服务器两个方向各一个。因此,在一个连接中的两个方向上采用不同的算法是可能的,但很少见。</target>
        </trans-unit>
        <trans-unit id="cc0444143c5a31fc19d9928f133e7fc40ea61901" translate="yes" xml:space="preserve">
          <source>This list is also divided into two for the both directions</source>
          <target state="translated">此榜也分两路为两路</target>
        </trans-unit>
        <trans-unit id="b6fab8016bf79d1847d2c2ce6e88690dbf155eba" translate="yes" xml:space="preserve">
          <source>This list is not inspected by snmp (other then checking that its a list). Its the users responsibility to ensure that these are valid options and does not conflict with the &quot;normal&quot; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f65aaceb7dbec6b1fb6792cf70ed6c05f03495f" translate="yes" xml:space="preserve">
          <source>This list is subject to change at any time, as is the category any given lock may belong to.</source>
          <target state="translated">此列表随时可能发生变化,任何给定的锁可能属于的类别也是如此。</target>
        </trans-unit>
        <trans-unit id="8667cb466629d5430d9bcf4d289713494e360097" translate="yes" xml:space="preserve">
          <source>This macro can also be used for conditional compilation, but is more typically used to disable testing: If &lt;code&gt;NOTEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included, and &lt;code&gt;TEST&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; defined, then the code will be compiled with EUnit disabled. See also &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这个宏也可用于条件编译，但更通常用于禁用测试：如果 &lt;code&gt;NOTEST&lt;/code&gt; 定义&lt;strong&gt;之前&lt;/strong&gt;的EUnit头文件包含，并且 &lt;code&gt;TEST&lt;/code&gt; 是&lt;strong&gt;没有&lt;/strong&gt;定义的，那么代码将与EUnit禁用编译。另请参阅 &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea55c428a4bdb4cf9d02f848100f0c0c617b095" translate="yes" xml:space="preserve">
          <source>This macro could be used like this in order to share code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5114889d9a6e68c62a0a1992ed05dd66a4ea6679" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is &lt;strong&gt;disabled&lt;/strong&gt; at compile time. (Compare the &lt;code&gt;TEST&lt;/code&gt; macro.)</source>
          <target state="translated">每当在编译时&lt;strong&gt;禁用&lt;/strong&gt; EUnit时，都会始终定义此宏（为 &lt;code&gt;true&lt;/code&gt; ，除非用户先前将其定义为具有另一个值）。（比较 &lt;code&gt;TEST&lt;/code&gt; 宏。）&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ace903cd27c28d656c86413693b1c2b7cebb1c45" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is enabled at compile time. This can be used to place testing code within conditional compilation; see also the macros &lt;code&gt;NOTEST&lt;/code&gt; and &lt;code&gt;EUNIT&lt;/code&gt;.</source>
          <target state="translated">每当在编译时启用EUnit时，都会始终定义此宏（为 &lt;code&gt;true&lt;/code&gt; ，除非用户先前将其定义为具有另一个值）。这可用于将测试代码放入条件编译中。另请参见宏 &lt;code&gt;NOTEST&lt;/code&gt; 和 &lt;code&gt;EUNIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0e6792b17f6782871d2727d10c5675a63bdafd" translate="yes" xml:space="preserve">
          <source>This macro is always defined to &lt;code&gt;true&lt;/code&gt; whenever EUnit is enabled at compile time. This is typically used to place testing code within conditional compilation, as in:</source>
          <target state="translated">每当在编译时启用EUnit时，此宏始终定义为 &lt;code&gt;true&lt;/code&gt; 。这通常用于将测试代码放入条件编译中，如下所示：</target>
        </trans-unit>
        <trans-unit id="f9a17853871676c0efbbea7592f31b8e2c70ba24" translate="yes" xml:space="preserve">
          <source>This macro is useful in the setup and cleanup sections of fixtures, e.g., for creating and deleting files or perform similar operating system specific tasks, to make sure that the test system is informed of any failures.</source>
          <target state="translated">这个宏在固定装置的设置和清理部分很有用,例如,用于创建和删除文件或执行类似的操作系统特定任务,以确保测试系统被告知任何故障。</target>
        </trans-unit>
        <trans-unit id="3e065ddbb311347232c6065a89455d54a53e02c6" translate="yes" xml:space="preserve">
          <source>This makes it possible to extend the protocol with optional requests and for the clients to be somewhat backward compatible.</source>
          <target state="translated">这使得协议可以通过可选的请求进行扩展,并且客户机可以在一定程度上向后兼容。</target>
        </trans-unit>
        <trans-unit id="f4d660f58a84c58c9d56e335532b3deb651bfa98" translate="yes" xml:space="preserve">
          <source>This makes the &lt;code&gt;gen_statem&lt;/code&gt; call callback function &lt;code&gt;terminate/3&lt;/code&gt; just like for a supervised server and waits for the process to terminate.</source>
          <target state="translated">这使得 &lt;code&gt;gen_statem&lt;/code&gt; 调用回调函数的 &lt;code&gt;terminate/3&lt;/code&gt; 就像受监管的服务器一样，并等待进程终止。</target>
        </trans-unit>
        <trans-unit id="d7f81c6c5bf6cf515d1e9f111e538332017866ee" translate="yes" xml:space="preserve">
          <source>This makes the fragment independent of the parentheses in the larger pattern.</source>
          <target state="translated">这使得该片段独立于大图案中的括号。</target>
        </trans-unit>
        <trans-unit id="49587f7146156380abd9cd71341e113bb523de56" translate="yes" xml:space="preserve">
          <source>This manual describes the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册将 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 应用程序描述为Erlang / Open Telecom Platform开发环境的组成部分。假定读者熟悉Erlang开发环境，这在单独的用户指南中进行了描述。</target>
        </trans-unit>
        <trans-unit id="f54f98ecb63f059bc0f3f16893d00b0178de2ead" translate="yes" xml:space="preserve">
          <source>This manual describes the Megaco application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了Megaco应用程序,它是Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的用户指南中描述。</target>
        </trans-unit>
        <trans-unit id="3565b9c0bcf6e9edf6874ed477820b3f0f6afff4" translate="yes" xml:space="preserve">
          <source>This manual describes the Reltool application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了Reltool应用,它是Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的《用户指南》中描述。</target>
        </trans-unit>
        <trans-unit id="15184424397c18e9f422c74e5e74ac83b7f03ff2" translate="yes" xml:space="preserve">
          <source>This manual describes the SNMP development tool, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">本手册介绍了SNMP开发工具,作为Erlang/Open电信平台开发环境的一个组成部分。假设读者熟悉Erlang开发环境,这在另外的《用户指南》中介绍。</target>
        </trans-unit>
        <trans-unit id="193220694d15266d7cc69378ef8f2e63c4cd4f53" translate="yes" xml:space="preserve">
          <source>This match specification can be specified as the last argument to &lt;code&gt;tp&lt;/code&gt; or &lt;code&gt;tpl&lt;/code&gt;. The activated &lt;code&gt;Item&lt;/code&gt; then becomes a &lt;strong&gt;trigger&lt;/strong&gt; for sequential tracing. This means that if the item is called on a process with trace flag &lt;code&gt;call&lt;/code&gt; set, the process is &quot;contaminated&quot; with token &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">可以将此匹配规范指定为 &lt;code&gt;tp&lt;/code&gt; 或 &lt;code&gt;tpl&lt;/code&gt; 的最后一个参数。然后，激活的 &lt;code&gt;Item&lt;/code&gt; 将成为顺序跟踪的&lt;strong&gt;触发器&lt;/strong&gt;。这意味着，如果在设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; 的进程上调用该项目，则该进程被令牌 &lt;code&gt;seq_trace&lt;/code&gt; &amp;ldquo;污染&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b5770f3057dc3732a2c219c409191a4bcf36e051" translate="yes" xml:space="preserve">
          <source>This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of dynamic anchor, or &quot;I've started, so I must finish&quot;. The name of the most recently passed (*MARK) in the path is passed back when (*COMMIT) forces a match failure.</source>
          <target state="translated">这符合 &quot;xxaab&quot;,但不符合 &quot;aacaab&quot;。它可以被认为是一种动态锚,或者说 &quot;我已经开始了,所以我必须完成&quot;。当(*COMMIT)强制匹配失败时,路径中最近传递的(*MARK)的名称会被传回来。</target>
        </trans-unit>
        <trans-unit id="5a54f8d6fa87944f3859d8aacba8377d13f4ab03" translate="yes" xml:space="preserve">
          <source>This matches all characters that have the Unicode P (punctuation) property, plus those characters whose code points are less than 128 that have the S (Symbol) property.</source>
          <target state="translated">这将匹配所有具有Unicode P(标点符号)属性的字符,加上码点小于128的具有S(符号)属性的字符。</target>
        </trans-unit>
        <trans-unit id="4060f37dc8e959716bd75592eaf33dbbe9422b23" translate="yes" xml:space="preserve">
          <source>This matches characters that have glyphs that mark the page when printed. In Unicode property terms, it matches all characters with the L, M, N, P, S, or Cf properties, except for:</source>
          <target state="translated">它匹配那些在打印时有字形标记的字符。在Unicode属性中,它匹配所有具有L、M、N、P、S或Cf属性的字符,除了。</target>
        </trans-unit>
        <trans-unit id="80aa7005a5a9b662614697fc0718ba90f2d5eb3f" translate="yes" xml:space="preserve">
          <source>This matches the same characters as [:graph:] plus space characters that are not controls, that is, characters with the Zs property.</source>
          <target state="translated">这与[:graph:]加上非控制的空格字符,也就是带有Zs属性的字符相同。</target>
        </trans-unit>
        <trans-unit id="596241cc1fad7ba2b8c15f7e59f64a7ddc1befdd" translate="yes" xml:space="preserve">
          <source>This means that if there is more than one way to locate a group (and its test cases) in a path, the result of the group search operation is a number of tests, all of which are to be performed. &lt;code&gt;Common Test&lt;/code&gt; interprets a group specification that consists of a single name as follows:</source>
          <target state="translated">这意味着，如果在路径中找到一个组（及其测试用例）的方法不止一种，则组搜索操作的结果将是许多测试，所有这些测试都将执行。 &lt;code&gt;Common Test&lt;/code&gt; 解释由单个名称组成的组规范，如下所示：</target>
        </trans-unit>
        <trans-unit id="22a98636e075cad89494908c0027932db4587e6e" translate="yes" xml:space="preserve">
          <source>This means that no bit higher than 31 can be set.</source>
          <target state="translated">这意味着不能设置高于31的位。</target>
        </trans-unit>
        <trans-unit id="df996ca43fed811b9266d44d0025a342f366a979" translate="yes" xml:space="preserve">
          <source>This means that parameter values set in the other system configuration files and values set using &lt;code&gt;application:set_env/3&lt;/code&gt; are disregarded.</source>
          <target state="translated">这意味着将忽略其他系统配置文件中设置的参数值和使用 &lt;code&gt;application:set_env/3&lt;/code&gt; 设置的值。</target>
        </trans-unit>
        <trans-unit id="8f13bbc91d440e811da4676f3e7ca92ea54d9f50" translate="yes" xml:space="preserve">
          <source>This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM.</source>
          <target state="translated">这意味着,如果使用此选项降低限制,失控的正则表达式匹配可以更快地失败。默认值10,000,000被编译到Erlang虚拟机中。</target>
        </trans-unit>
        <trans-unit id="932d8129dcaf5494e901e2360eca271fe2d0ad88" translate="yes" xml:space="preserve">
          <source>This means that specifying another &lt;code&gt;.config&lt;/code&gt; file, or more &lt;code&gt;.config&lt;/code&gt; files, leads to inconsistent update of application configurations. There is, however, a syntax for &lt;code&gt;sys.config&lt;/code&gt; that allows pointing out other &lt;code&gt;.config&lt;/code&gt; files:</source>
          <target state="translated">这意味着指定另一个 &lt;code&gt;.config&lt;/code&gt; 文件或多个 &lt;code&gt;.config&lt;/code&gt; 文件会导致应用程序配置的更新不一致。但是， &lt;code&gt;sys.config&lt;/code&gt; 的语法允许指出其他 &lt;code&gt;.config&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="2200dc5ecc3e0975342e26ce8ac3610348c991da" translate="yes" xml:space="preserve">
          <source>This means that the application is preferably to be started at &lt;code&gt;cp1@cave&lt;/code&gt;. If &lt;code&gt;cp1@cave&lt;/code&gt; is down, the application is to be started at &lt;code&gt;cp2@cave&lt;/code&gt; or &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">这意味着该应用程序最好从 &lt;code&gt;cp1@cave&lt;/code&gt; 启动。如果 &lt;code&gt;cp1@cave&lt;/code&gt; 关闭，则应从 &lt;code&gt;cp2@cave&lt;/code&gt; 或 &lt;code&gt;cp3@cave&lt;/code&gt; 启动应用程序。</target>
        </trans-unit>
        <trans-unit id="106bb3bedaf49597cebe6d920a66bd4eef59b102" translate="yes" xml:space="preserve">
          <source>This means that the context (an opaque type) returned from streaming crypto functions (&lt;code&gt;hash_(init|update|final)&lt;/code&gt;, &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; and &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt;) is different and incompatible with regular builds when compiling crypto with FIPS support.</source>
          <target state="translated">这意味着从流式加密函数（ &lt;code&gt;hash_(init|update|final)&lt;/code&gt; ， &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; 和 &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt; ）返回的上下文（不透明类型）是不同的并且与常规构建不兼容。使用FIPS支持编译加密时。</target>
        </trans-unit>
        <trans-unit id="36077c72e710c444ae2797c20c5e8799b4acfa03" translate="yes" xml:space="preserve">
          <source>This means that the match specification is always a list of one or more tuples (of arity 3). The first element of the tuple is to be a pattern as described in &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The second element of the tuple is to be a list of 0 or more guard tests (described below). The third element of the tuple is to be a list containing a description of the value to return. In almost all normal cases, the list contains exactly one term that fully describes the value to return for each object.</source>
          <target state="translated">这意味着匹配规范始终是一个或多个元组（arity 3）的列表。元组的第一个元素将是 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 中描述的模式。元组的第二个元素将是0个或更多防护测试的列表（如下所述）。元组的第三个元素是一个列表，其中包含要返回的值的描述。在几乎所有正常情况下，列表仅包含一个术语，完整描述了每个对象要返回的值。</target>
        </trans-unit>
        <trans-unit id="f7aa9f1a915ce26bfe5ca3abc7eefe46479cfe4b" translate="yes" xml:space="preserve">
          <source>This means that when running, an included application is in fact part of the primary application, and a process in an included application considers itself belonging to the primary application.</source>
          <target state="translated">这意味着,当运行时,被包含的应用程序实际上是主应用程序的一部分,被包含的应用程序中的进程认为自己属于主应用程序。</target>
        </trans-unit>
        <trans-unit id="8c76b8edc5c31749772c3e7c79034a31599a007d" translate="yes" xml:space="preserve">
          <source>This mechanism causes the new versions of the emulator and core applications to run with the old version of other applications during startup. Thus, take extra care to avoid incompatibility. Incompatible changes in the core applications can in some situations be necessary. If possible, such changes are preceded by deprecation over two major releases before the actual change. To ensure the application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">这种机制会导致仿真器和核心应用程序的新版本在启动时与其他应用程序的旧版本一起运行。因此,要特别注意避免不兼容。在某些情况下,核心应用程序中不兼容的更改是必要的。如果可能的话,在实际更改之前,会先进行两个主要版本的废弃处理。为了确保应用程序不会因为不兼容的更改而崩溃,请务必尽快删除对废弃函数的任何调用。</target>
        </trans-unit>
        <trans-unit id="a72670e4d484ccee65dddc81403839166360c723" translate="yes" xml:space="preserve">
          <source>This mechanism is available with stateful session tickets. Session tickets can only be used once, subsequent use of the same ticket results in a full handshake. Stateful servers enforce this rule by maintaining a database of outstanding valid tickets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb636d25dca103bb579d81c3c480e31e05614f3" translate="yes" xml:space="preserve">
          <source>This mechanism is available with stateless session tickets. The server records a unique value derived from the ClientHello (PSK binder) in a given time window. The ticket's age is verified by using both the &quot;obsfuscated_ticket_age&quot; and an additional timestamp encrypted in the ticket data. As the used datastore allows false positives, apparent replays will be answered by doing a full 1-RTT handshake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8bf1c9c18b4055ffc901b397bc2abd52dda424" translate="yes" xml:space="preserve">
          <source>This mechanism is available with the stateless session tickets. As the ticket data has an embedded timestamp, the server can determine if a ClientHello was sent reasonably recently and accept the 0-RTT handshake, otherwise if falls back to a full 1-RTT handshake. This mechanism is tightly coupled with the previous one, it prevents storing an unlimited number of ClientHellos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3157f67a5eef33bc0f27dfb7ed55e0358006331" translate="yes" xml:space="preserve">
          <source>This message appears if &lt;code&gt;{ok, pending_driver}&lt;/code&gt; was returned from &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; for the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and then &lt;code&gt;{ok, already_loaded}&lt;/code&gt; is returned from a call to &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此消息出现如果 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 从返回 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 最后 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 驱动的，然后 &lt;code&gt;{ok, already_loaded}&lt;/code&gt; 是从一个调用返回 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7443815abce9a78b8f12e9b4a8006f7ab0678558" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway but the loading for some reason failed. The &lt;code&gt;Failure&lt;/code&gt; term is one of the errors that can be returned from &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;. The error term can be passed to &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; for translation into human readable form. Notice that the translation must be done in the same running Erlang virtual machine as the error was detected in.</source>
          <target state="translated">如果正在进行重新加载，但由于某种原因加载失败，则会出现此消息。该 &lt;code&gt;Failure&lt;/code&gt; 项是可以从返回的错误之一 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 。错误项可以传递给 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 以便翻译成人类可读的形式。请注意，转换必须在检测到错误的同一运行的Erlang虚拟机中完成。</target>
        </trans-unit>
        <trans-unit id="1fd84b520be9e9ea3d84c401734e82ebe7eac97d" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway, but the requesting &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; cancelled it by dying or calling &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;unload/1&lt;/code&gt;/&lt;code&gt;unload_driver/1&lt;/code&gt;) again before it was reloaded.</source>
          <target state="translated">如果正在进行重新加载，此消息将到达，但是请求 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 通过在重新加载之前死掉或 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 调用try_unload / 2（或 &lt;code&gt;unload/1&lt;/code&gt; / &lt;code&gt;unload_driver/1&lt;/code&gt; ）来取消了该消息。</target>
        </trans-unit>
        <trans-unit id="f4a65175ce43b7599632ccc7699bb308e42c19d5" translate="yes" xml:space="preserve">
          <source>This message format unfortunately differs slightly from the &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp&lt;/a&gt;&lt;/code&gt; message format with ancillary data, and from the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; return tuple format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fc14d584e2b14f026925a19521a06f0dcdade4" translate="yes" xml:space="preserve">
          <source>This message indicates that the (asynchronous) operation has been aborted. If, for instance, the socket has been closed (by another process), &lt;code&gt;Info&lt;/code&gt; will be &lt;code&gt;{SelectRef, closed}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bd04f8e274c08cef04fc4e45d10c02182267ab" translate="yes" xml:space="preserve">
          <source>This message is only sent to a transport process over whose &lt;code&gt;Inband-Security-Id&lt;/code&gt; configuration has indicated support for TLS.</source>
          <target state="translated">该消息仅发送到其 &lt;code&gt;Inband-Security-Id&lt;/code&gt; 配置指示支持TLS 的传输过程。</target>
        </trans-unit>
        <trans-unit id="c9fe7d956f6a48c7301aa47c203d863f991af167" translate="yes" xml:space="preserve">
          <source>This message is sent either immediately if the driver is already loaded and no reloading is pending, or when reloading is executed if reloading is pending.</source>
          <target state="translated">如果驱动程序已经加载,且没有等待重装,则立即发送该消息;如果重装等待,则在执行重装时发送。</target>
        </trans-unit>
        <trans-unit id="b59c3f75f12fd3dcb8bfccc7fe935cad829ca36a" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent if it for some reason decided to discard the pdu.</source>
          <target state="translated">如果主代理由于某种原因决定放弃pdu,则该消息由主代理发送。</target>
        </trans-unit>
        <trans-unit id="829114beb9c3f31023ae657dbb8e8d0e25c1f282" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a request is to be sent. The only request an agent can send is Inform-Request. The net if process needs to remember the request id and the Pid, and when a response is received for the request id, send it to Pid, using a &lt;code&gt;snmp_response_received&lt;/code&gt; message.</source>
          <target state="translated">当要发送请求时，此消息是从主代理发送的。代理可以发送的唯一请求是Inform-Request。净if进程需要记住请求ID和Pid，并在收到请求ID的响应时，使用 &lt;code&gt;snmp_response_received&lt;/code&gt; 消息将其发送到Pid 。</target>
        </trans-unit>
        <trans-unit id="e5f157b9c3b08af7fd2a99ceb91dfce727fcf26b" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a trap is to be sent.</source>
          <target state="translated">当要发送陷阱时,该消息由主代理发送。</target>
        </trans-unit>
        <trans-unit id="d441c31108c7576d3cbad8491a4c4b23596427f8" translate="yes" xml:space="preserve">
          <source>This message is sent if reloading was expected, but the (old) driver made itself permanent before reloading. It is also sent if the driver was permanent or statically linked-in when trying to create the monitor.</source>
          <target state="translated">如果预计要重新加载,但(旧的)驱动程序在重新加载之前就已经永久化了,则会发送此消息。如果在尝试创建监视器时,驱动程序是永久的或静态链接的,也会发送此消息。</target>
        </trans-unit>
        <trans-unit id="2a9a7c62be17cb4236568289a04568a0ca14d646" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but the driver made itself permanent before unloading. It is also sent if trying to monitor a permanent or statically linked-in driver.</source>
          <target state="translated">如果预计要卸载,但驱动程序在卸载前将自己变成了永久的,则会发送此消息。如果试图监控一个永久或静态链接的驱动程序,也会发送该消息。</target>
        </trans-unit>
        <trans-unit id="55cf023d178c69ab93cb5f5b6795668204cbf186" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but while the driver was waiting for all ports to get closed, a new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver appeared, and the unloading was cancelled.</source>
          <target state="translated">如果预期要卸载，则发送此消息，但是在驱动程序等待所有端口关闭时，出现了该驱动程序的新 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; ，并且取消了卸载。</target>
        </trans-unit>
        <trans-unit id="dedc90e7f76a59946b54f6f05a80249175f6e9ab" translate="yes" xml:space="preserve">
          <source>This message is sent to the Net If process by a process that has been configured to perfor &quot;active supervision&quot; of the Net If process. The Net If process should respond immediately with a &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e7b699a7ae096287dd7808194507f6d50b3e91" translate="yes" xml:space="preserve">
          <source>This message is sent to the Net if process from a master agent as a response to a previously received request.</source>
          <target state="translated">该消息由主代理发送到Net if进程,作为对先前收到的请求的响应。</target>
        </trans-unit>
        <trans-unit id="9a28b745a2e2cc7649e2af78230f7339cfe78c45" translate="yes" xml:space="preserve">
          <source>This message is used by the release handler to find which processes that execute a certain module. The process can later be suspended and ordered to perform a code change for one of its modules.</source>
          <target state="translated">这个消息被释放处理程序用来查找执行某个模块的进程。随后可以暂停该进程,并命令该进程对其某个模块进行代码修改。</target>
        </trans-unit>
        <trans-unit id="425958047f9810b0d871ee948d2497599b8d63d0" translate="yes" xml:space="preserve">
          <source>This message requests that the server starts execution of the given command. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd8dba6b75e3f001a723a1efc9d9ff4abf7b225" translate="yes" xml:space="preserve">
          <source>This message requests that the server starts execution of the given command. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该消息请求服务器开始执行给定命令。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="e80a2cab18ba8e56bb44cddb1d3f6a9bf9eb9c7d" translate="yes" xml:space="preserve">
          <source>This message requests that the user default shell is started at the other end. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt; ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e505234f686d8ab1a451d96190a8bff8adf1ec9a" translate="yes" xml:space="preserve">
          <source>This message requests that the user default shell is started at the other end. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此消息要求在另一端启动用户默认外壳程序。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="1fc986c5547b793c1d6d354a196fdaa59d4a31d9" translate="yes" xml:space="preserve">
          <source>This mode can also be activated with flag &lt;code&gt;silent&lt;/code&gt; to &lt;code&gt;erlang:trace/3&lt;/code&gt;.</source>
          <target state="translated">这种模式也可以与标志激活 &lt;code&gt;silent&lt;/code&gt; 到 &lt;code&gt;erlang:trace/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a11330d6901fd7311c10340dd7bf642645e942b" translate="yes" xml:space="preserve">
          <source>This mode fits well when you have a regular state diagram, like the ones in this chapter, which describes all events and actions belonging to a state visually around that state, and each state has its unique name.</source>
          <target state="translated">当你有一个常规的状态图时,这种模式很适合,就像本章中的状态图一样,围绕着这个状态,直观地描述属于一个状态的所有事件和动作,而且每个状态都有其唯一的名称。</target>
        </trans-unit>
        <trans-unit id="bb204752ab758821e61472ec417419d5f3d9971e" translate="yes" xml:space="preserve">
          <source>This mode is more or less a backward compatibility mode as from its introduction.</source>
          <target state="translated">从介绍来看,这种模式多少是一种后向兼容模式。</target>
        </trans-unit>
        <trans-unit id="1fd3b3df65466b11a5eaf44e2aee1317b4d62efd" translate="yes" xml:space="preserve">
          <source>This mode works equally well when you want to focus on one event at the time or on one state at the time, but function &lt;code&gt; Module:handle_event/4 &lt;/code&gt; quickly grows too large to handle without branching to helper functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172f14b940b1b2c6900b1372fa3316ca07a87e44" translate="yes" xml:space="preserve">
          <source>This mode works equally well when you want to focus on one event at the time or on one state at the time, but function &lt;code&gt;Module:handle_event/4&lt;/code&gt; quickly grows too large to handle without branching to helper functions.</source>
          <target state="translated">当您希望同时关注一个事件或某个时间处于一种状态时，此模式同样适用，但是功能 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 很快变得太大而无法分支到辅助函数。</target>
        </trans-unit>
        <trans-unit id="5fdef418c42eba77018e8e42460b63d278950bac" translate="yes" xml:space="preserve">
          <source>This model has only three different tables, and the employee records contain references to other records. The record has the following references:</source>
          <target state="translated">这个模型只有三个不同的表,雇员记录包含对其他记录的引用。该记录有以下引用:</target>
        </trans-unit>
        <trans-unit id="b3ce72021e00b147c9199fb77c9a3762a844a3df" translate="yes" xml:space="preserve">
          <source>This module also provides facilities for displaying status information about interpreted processes and break points.</source>
          <target state="translated">该模块还提供了显示解释过程和断点的状态信息的功能。</target>
        </trans-unit>
        <trans-unit id="817190ceec75c6fa4d3197e4a1b86534327d94e7" translate="yes" xml:space="preserve">
          <source>This module also supports the following annotations, which are used by various modules:</source>
          <target state="translated">本模块还支持以下注解,这些注解被各种模块使用。</target>
        </trans-unit>
        <trans-unit id="c1519372f968a7c83f80d29c6d04dbd62347e6bd" translate="yes" xml:space="preserve">
          <source>This module archives and extract files to and from a tar file. This module supports reading most common tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions to the USTAR format (sparse files most notably). It produces tar archives in USTAR format, unless the files being archived require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As such, &lt;code&gt;erl_tar&lt;/code&gt; supports tar archives produced by most all modern tar utilities, and produces tarballs which should be similarly portable.</source>
          <target state="translated">此模块将文件归档并解压缩到tar文件中。该模块支持读取最常见的tar格式，即v7，STAR，USTAR和PAX，以及一些GNU tar对USTAR格式的扩展（最稀疏的文件）。它会以USTAR格式生成tar存档，除非由于USTAR的限制（例如unicode元数据，文件名长度等）而使要存档的文件需要PAX格式。这样， &lt;code&gt;erl_tar&lt;/code&gt; 支持大多数现代tar实用程序生成的tar存档，并生成应具有类似可移植性的tarball。</target>
        </trans-unit>
        <trans-unit id="c93dc94853da5f65dd0f19dd1ea05a3d6a2b52f1" translate="yes" xml:space="preserve">
          <source>This module archives and extracts files to and from a zip archive. The zip format is specified by the &quot;ZIP Appnote.txt&quot; file, available on the PKWARE web site &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块将文件归档并从zip归档中提取文件。压缩格式由PKWARE网站 &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt; 上的&amp;ldquo; ZIP Appnote.txt&amp;rdquo;文件指定。</target>
        </trans-unit>
        <trans-unit id="5ebed77e7881e24d9d50b032e03940e9bdf36b09" translate="yes" xml:space="preserve">
          <source>This module can also be found in the &lt;code&gt;examples&lt;/code&gt; directory of the SASL application.</source>
          <target state="translated">该模块也可以在SASL应用程序的 &lt;code&gt;examples&lt;/code&gt; 目录中找到。</target>
        </trans-unit>
        <trans-unit id="1aca0b6e822b7c6d0a2dee5904564049e299817d" translate="yes" xml:space="preserve">
          <source>This module can also be viewed as a behaviour for an application implemented according to the OTP design principles as a supervision tree. The definition of how to start and stop the tree is to be located in an &lt;strong&gt;application callback module&lt;/strong&gt;, exporting a predefined set of functions.</source>
          <target state="translated">该模块也可以看作是根据OTP设计原则实现的应用程序的行为，它是监督树。如何启动和停止树的定义位于&lt;strong&gt;应用程序回调模块中&lt;/strong&gt;，并导出一组预定义的函数。</target>
        </trans-unit>
        <trans-unit id="46fe9ebbf441b09ed18ab05af78ee6b86682c8d6" translate="yes" xml:space="preserve">
          <source>This module can be used as follows:</source>
          <target state="translated">该模块可用于以下方面:</target>
        </trans-unit>
        <trans-unit id="64bd57a5a7fb8d785ba9c0f9a34dddc82e8e4902" translate="yes" xml:space="preserve">
          <source>This module can be used to render function and type documentation to be printed in a shell. It can only render EEP-48 documentation of the format &lt;code&gt;application/erlang+html&lt;/code&gt;. For more information about this format see &lt;code&gt;Documentation Storage&lt;/code&gt; in Erl_Docgen's User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686c65b4a65c34ff9cf138f3076e44dd59452f8f" translate="yes" xml:space="preserve">
          <source>This module can be used to run a set of Erlang nodes as a pool of computational processors. It is organized as a master and a set of slave nodes and includes the following features:</source>
          <target state="translated">这个模块可以用来运行一组Erlang节点作为计算处理器池。它被组织成一个主节点和一组从节点,包括以下功能。</target>
        </trans-unit>
        <trans-unit id="534f04f7c34a17a45122c6b169fa5d57730b66cd" translate="yes" xml:space="preserve">
          <source>This module communicates with the EPMD daemon, see &lt;code&gt;epmd&lt;/code&gt;. To implement your own epmd module please see &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Node Discovery for Erlang Distribution&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af82f371bff5810258c512bac2aa2370e799470c" translate="yes" xml:space="preserve">
          <source>This module communicates with the EPMD daemon, see &lt;code&gt;epmd&lt;/code&gt;. To implement your own epmd module please see &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt;</source>
          <target state="translated">该模块与EPMD守护程序通信，请参阅 &lt;code&gt;epmd&lt;/code&gt; 。要实现自己的epmd模块，请参阅《 &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b4ce3dec0f26e77853815afd7b3cb63b31d970f" translate="yes" xml:space="preserve">
          <source>This module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">当且仅当两个元素的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将其视为不同的元素。</target>
        </trans-unit>
        <trans-unit id="0be9d79105e371fa97debd95b84b58219b4279ea" translate="yes" xml:space="preserve">
          <source>This module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">当且仅当两个键的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将其视为不同的键。</target>
        </trans-unit>
        <trans-unit id="f7838291047ac4d60e0139ec156a7e643ad4faaa" translate="yes" xml:space="preserve">
          <source>This module consists of the following services:</source>
          <target state="translated">本模块由以下服务组成:</target>
        </trans-unit>
        <trans-unit id="ff598a317fac529d717bd1f848d0ec9eaa2f5e61" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting between different character representations. It converts between ISO Latin-1 characters and Unicode characters, but it can also convert between different Unicode encodings (like UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">这个模块包含了在不同字符表示之间进行转换的功能。它可以在ISO Latin-1字符和Unicode字符之间进行转换,也可以在不同的Unicode编码之间进行转换(如UTF-8、UTF-16和UTF-32)。</target>
        </trans-unit>
        <trans-unit id="b5b9240d86d995a89ac9eb37eda08d6f1ac2c51e" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; can be used for flattening deep lists.</source>
          <target state="translated">该模块包含用于在字符串（字符列表）之间进行转换的函数。它们用于实现 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 模块中的功能。无法保证从某些函数返回的字符列表是平坦的，它们可以是深列表。功能 &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; 可用于平整深层列表。</target>
        </trans-unit>
        <trans-unit id="837f779fb53a71d0c4ae19998076438feb1919ac" translate="yes" xml:space="preserve">
          <source>This module contains functions for encoding Erlang terms into a sequence of bytes, and for decoding Erlang terms from a sequence of bytes.</source>
          <target state="translated">这个模块包含了将Erlang术语编码成字节序列,以及将Erlang术语从字节序列中解码的函数。</target>
        </trans-unit>
        <trans-unit id="de911f7e348fe07047fba5ab0f536e33890e3df9" translate="yes" xml:space="preserve">
          <source>This module contains functions for inserting comments, described by position, indentation and text, as attachments on an abstract syntax tree, at the correct places.</source>
          <target state="translated">这个模块包含了用于插入注释的功能,这些注释由位置、缩进和文本描述,作为抽象语法树上的附件,放在正确的位置。</target>
        </trans-unit>
        <trans-unit id="59032641754c334d2119d69e35fd6099ad62842c" translate="yes" xml:space="preserve">
          <source>This module contains functions for list processing.</source>
          <target state="translated">该模块包含列表处理的功能。</target>
        </trans-unit>
        <trans-unit id="81e43c82257cd393c01258396233b38bac085577" translate="yes" xml:space="preserve">
          <source>This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang.</source>
          <target state="translated">这个模块包含了用于操作面向字节的二进制文件的函数。虽然大部分函数可以使用位元语法来提供,但这个库中的函数是高度优化的,预计会比纯Erlang编写的函数执行得更快或消耗更少的内存,或者两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="50ccc7ec1143773aaedcc8657aa657008607be3a" translate="yes" xml:space="preserve">
          <source>This module contains functions for maps processing.</source>
          <target state="translated">该模块包含地图处理的功能。</target>
        </trans-unit>
        <trans-unit id="50f0b83fe2516bf67a941d2bd6474f61aeee90ee" translate="yes" xml:space="preserve">
          <source>This module contains functions for parsing and handling URIs (&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;) and form-urlencoded query strings (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此模块包含用于解析和处理URI（ &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; ）和表单编码的查询字符串（ &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; ）的函数。</target>
        </trans-unit>
        <trans-unit id="ca7843662571b136297297d4631b70479e539fd0" translate="yes" xml:space="preserve">
          <source>This module contains functions for sending system messages used by programs, and messages used for debugging purposes.</source>
          <target state="translated">该模块包含了发送程序使用的系统消息和用于调试的消息的功能。</target>
        </trans-unit>
        <trans-unit id="49fe7206d616c14253dcbc198d4a64077934564a" translate="yes" xml:space="preserve">
          <source>This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge.</source>
          <target state="translated">这个模块包含对文件中的术语进行排序,合并已经排序的文件,以及检查文件的排序性的功能。从文件序列中读取包含二进制术语的块,在内存中进行内部排序并写入临时文件,合并后产生一个排序文件作为输出。合并是作为一种优化提供的;当文件已经排序时,它的速度更快,但它总是工作在排序而不是合并上。</target>
        </trans-unit>
        <trans-unit id="5326d602d1276804a6e5daef142fc199cc00ce06" translate="yes" xml:space="preserve">
          <source>This module contains functions for tokenizing (scanning) characters into Erlang tokens.</source>
          <target state="translated">该模块包含将字符标记化(扫描)为Erlang标记的功能。</target>
        </trans-unit>
        <trans-unit id="994f1f991d1dfea12bae127e267a7c21607503f3" translate="yes" xml:space="preserve">
          <source>This module contains functions to generate boot scripts (&lt;code&gt;.boot&lt;/code&gt;, &lt;code&gt;.script&lt;/code&gt;), a release upgrade file (&lt;code&gt;relup&lt;/code&gt;), and release packages.</source>
          <target state="translated">该模块包含用于生成引导脚本（ &lt;code&gt;.boot&lt;/code&gt; ， &lt;code&gt;.script&lt;/code&gt; ），发行升级文件（ &lt;code&gt;relup&lt;/code&gt; ）和发行包的函数。</target>
        </trans-unit>
        <trans-unit id="cfb41f0bba62101238346d92d97629a2935e3299" translate="yes" xml:space="preserve">
          <source>This module contains interface functions for the SSL/TLS/DTLS protocol. For detailed information about the supported standards see &lt;code&gt;ssl(6)&lt;/code&gt;.</source>
          <target state="translated">该模块包含SSL / TLS / DTLS协议的接口功能。有关支持的标准的详细信息，请参见 &lt;code&gt;ssl(6)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e018edcfc853c04e93bf82d4c3548bfbe011ff7" translate="yes" xml:space="preserve">
          <source>This module contains interface functions for the TLS/DTLS protocol. For detailed information about the supported standards see &lt;code&gt;ssl(6)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4c286324503fe5462bf11f1a2d003718ad9829" translate="yes" xml:space="preserve">
          <source>This module contains regular expression matching functions for strings and binaries.</source>
          <target state="translated">这个模块包含了字符串和二进制文件的正则表达式匹配函数。</target>
        </trans-unit>
        <trans-unit id="ef53274b9322e757bb4063af4f3183c6e84d40a8" translate="yes" xml:space="preserve">
          <source>This module contains services similar to Remote Procedure Calls. It also contains broadcast facilities and parallel evaluators. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</source>
          <target state="translated">该模块包含类似于远程过程调用的服务。它还包含广播设施和并行评估器。远程过程调用是一种在远程节点上调用一个函数并收集答案的方法,它用于收集远程节点上的信息,或者在远程节点上运行一个具有特定副作用的函数。它用于收集远程节点上的信息,或者在远程节点上运行一个具有特定副作用的函数。</target>
        </trans-unit>
        <trans-unit id="d58b9a536ce590d194f2de76046ad6eb75d92d75" translate="yes" xml:space="preserve">
          <source>This module contains some error printing routines taken from &quot;Advanced Programming in the UNIX Environment&quot; by W. Richard Stevens.</source>
          <target state="translated">这个模块包含了一些错误打印例程,这些例程来自于W.Richard Stevens的《UNIX环境下的高级编程》。</target>
        </trans-unit>
        <trans-unit id="d4648e09f07ca512b563c45755d232665770d52a" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the Erlang &lt;strong&gt;code server&lt;/strong&gt;, which deals with the loading of compiled code into a running Erlang runtime system.</source>
          <target state="translated">该模块包含Erlang &lt;strong&gt;代码服务器&lt;/strong&gt;的接口，该&lt;strong&gt;服务器&lt;/strong&gt;负责将已编译的代码加载到正在运行的Erlang运行时系统中。</target>
        </trans-unit>
        <trans-unit id="f512252f459f62899c4ec02d14e4f592e80d6fd9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the TPKT (TCP/IP) version transport protocol for Megaco/H.248.</source>
          <target state="translated">该模块包含了Megaco/H.248的TPKT(TCP/IP)版本传输协议的公共接口。</target>
        </trans-unit>
        <trans-unit id="e64245c6a67eefbaeb52b73410ca5898d27decb3" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the UDP/IP version transport protocol for Megaco/H.248.</source>
          <target state="translated">该模块包含Megaco/H.248的UDP/IP版本传输协议的公共接口。</target>
        </trans-unit>
        <trans-unit id="b0c49b48d28a03a73e07c75bceac59af417062b9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the flex scanner linked in driver. The flex scanner performs the scanning phase of text message decoding.</source>
          <target state="translated">该模块包含了与驱动中链接的flex扫描仪的公共接口。flex扫描仪执行文本信息解码的扫描阶段。</target>
        </trans-unit>
        <trans-unit id="028411a6308d39aee0db1a739a433763a7fa1e96" translate="yes" xml:space="preserve">
          <source>This module contains two routines: one general function for creating Erlang terms and one for pattern matching Erlang terms.</source>
          <target state="translated">这个模块包含两个例程:一个是用于创建Erlang术语的通用函数,一个是用于模式匹配Erlang术语的函数。</target>
        </trans-unit>
        <trans-unit id="43a0c1ee918b2bf11b8612b0b536425a9de08920" translate="yes" xml:space="preserve">
          <source>This module contains utilities on a higher level than the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">该模块包含比 &lt;code&gt;file&lt;/code&gt; 模块更高级别的实用程序。</target>
        </trans-unit>
        <trans-unit id="573d1a53ea7dfdc3e3251968a013dc54e7ff9915" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for easier measurement and calculation of scheduler utilization, otherwise obtained from calling the more primitive &lt;code&gt; statistics(scheduler_wall_time)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ca3e4fb9bfa2cb08015503e443bec03d7d012f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for easier measurement and calculation of scheduler utilization, otherwise obtained from calling the more primitive &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt;.</source>
          <target state="translated">此模块包含实用程序函数，这些函数可以更方便地测量和计算调度程序利用率，否则可以通过调用更原始的 &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8466a816803c9602c9c5da297825fe2d8738a12f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for working with the abstract data type defined in the module &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块包含实用程序函数，用于处理模块 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 中定义的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="6db7bd57b934dc58f231a5b9efdb7c6ce8fb29e8" translate="yes" xml:space="preserve">
          <source>This module contains various network utility functions.</source>
          <target state="translated">该模块包含各种网络实用功能。</target>
        </trans-unit>
        <trans-unit id="0d60840cdb8394c4bebe2baf925c2e4db6023faa" translate="yes" xml:space="preserve">
          <source>This module controls that the conditions in the requests are fulfilled. For example, a request can specify that the answer only is of interest if the content is unchanged since the last retrieval. If the content is changed, the range request is to be converted to a request for the whole file instead.</source>
          <target state="translated">这个模块可以控制请求中的条件是否得到满足。例如,一个请求可以指定只有当内容自上次检索以来没有变化时,才对答案感兴趣。如果内容发生了变化,则要将范围请求转换为对整个文件的请求。</target>
        </trans-unit>
        <trans-unit id="fe422acfcd694c2630daf21b44a7f9f2a2d5de80" translate="yes" xml:space="preserve">
          <source>This module deals with the composition and decomposition of &lt;strong&gt;syntactic&lt;/strong&gt; entities (as opposed to semantic ones); its purpose is to hide all direct references to the data structures used to represent these entities. With few exceptions, the functions in this module perform no semantic interpretation of their inputs, and in general, the user is assumed to pass type-correct arguments - if this is not done, the effects are not defined.</source>
          <target state="translated">该模块处理&lt;strong&gt;语法&lt;/strong&gt;实体（与语义实体相对）的组成和分解；其目的是隐藏对用于表示这些实体的数据结构的所有直接引用。除少数例外，此模块中的功能不对其输入进行语义解释，通常，假定用户传递类型正确的参数-如果不这样做，则效果未定义。</target>
        </trans-unit>
        <trans-unit id="cfa2f96a0a3bfeb4a366115418ce75043dff5047" translate="yes" xml:space="preserve">
          <source>This module defines Erlang BIFs, guard tests, and operators. This module is only of interest to programmers who manipulate Erlang code.</source>
          <target state="translated">这个模块定义了Erlang BIF、防护测试和操作符。这个模块只对操作Erlang代码的程序员感兴趣。</target>
        </trans-unit>
        <trans-unit id="b03bc08e3947730353e9a2f08b1653a85fdf21af" translate="yes" xml:space="preserve">
          <source>This module defines a callback behavior for user-defined hash functions of fragmented tables.</source>
          <target state="translated">该模块为用户定义的碎片表的哈希函数定义了一个回调行为。</target>
        </trans-unit>
        <trans-unit id="7910088bd4b8dc833f45c393721faa0c8e4f3457" translate="yes" xml:space="preserve">
          <source>This module defines a callback handler for the communication with an &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-miller-ssh-agent-02&quot;&gt;SSH Agent&lt;/a&gt;&lt;/code&gt; and can be used to replace the &lt;code&gt;default callback&lt;/code&gt;. This allows to issue signing requests to an agent that stores SSH private keys to perform authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161d77445ffa506093b357c536b61e4224bc87e7" translate="yes" xml:space="preserve">
          <source>This module defines an abstract data type for representing Core Erlang source code as syntax trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76441fb4ee13017766943030861f4ce7688ed9bd" translate="yes" xml:space="preserve">
          <source>This module defines an abstract data type for representing Erlang source code as syntax trees, in a way that is backwards compatible with the data structures created by the Erlang standard library parser module &lt;code&gt;erl_parse&lt;/code&gt; (often referred to as &quot;parse trees&quot;, which is a bit of a misnomer). This means that all &lt;code&gt;erl_parse&lt;/code&gt; trees are valid abstract syntax trees, but the reverse is not true: abstract syntax trees can in general not be used as input to functions expecting an &lt;code&gt;erl_parse&lt;/code&gt; tree. However, as long as an abstract syntax tree represents a correct Erlang program, the function &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; should be able to transform it to the corresponding &lt;code&gt;erl_parse&lt;/code&gt; representation.</source>
          <target state="translated">该模块定义了一种抽象数据类型，用于将Erlang源代码表示为语法树，其方式与Erlang标准库解析器模块 &lt;code&gt;erl_parse&lt;/code&gt; （通常称为&amp;ldquo; parse tree&amp;rdquo;）创建的数据结构向后兼容。用词不当）。这意味着所有 &lt;code&gt;erl_parse&lt;/code&gt; 树都是有效的抽象语法树，但事实并非如此：抽象语法树通常不能用作期望 &lt;code&gt;erl_parse&lt;/code&gt; 树的函数的输入。但是，只要抽象语法树表示正确的Erlang程序，函数 &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 应该能够将其转换为相应的 &lt;code&gt;erl_parse&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="e69c1a93aecab552763a38625c306d9fb09103f6" translate="yes" xml:space="preserve">
          <source>This module defines the Erlang Server Interface (ESI) API. It is a more efficient way of writing Erlang scripts for your &lt;code&gt;Inets&lt;/code&gt; web server than writing them as common CGI scripts.</source>
          <target state="translated">该模块定义Erlang服务器接口（ESI）API。与将它们编写为常见的CGI脚本相比，这是一种为 &lt;code&gt;Inets&lt;/code&gt; Web服务器编写Erlang脚本的更有效的方法。</target>
        </trans-unit>
        <trans-unit id="392313e4002a7778328cfb59fce4c77f8c1952d5" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib storage.</source>
          <target state="translated">该模块定义了SNMP代理mib存储的行为。</target>
        </trans-unit>
        <trans-unit id="7eff1b562e4fe0566ee0da7f6a9daaa2439e2f8b" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib-server data module. A &lt;code&gt;snmpa_mib_data&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义SNMP代理mib-server数据模块的行为。一个 &lt;code&gt;snmpa_mib_data&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="b0d76e366c3f9dcdfb5f12def1540b4e052163ce" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent discovery handler. A &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义代理发现处理程序的行为。一个 &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="e43530aefc8fe67ce3e1a2b7e5683063982513d3" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent error reporting. A &lt;code&gt;snmpa_error_report&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理错误报告的行为。一个 &lt;code&gt;snmpa_error_report&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="d81fb92749352083b3ab6bc64e61e21bf25c9749" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface filter. A &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理程序网络接口过滤器的行为。一个 &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="5412a13932b854a89270a84f2ceaaa33588e1121" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface. A &lt;code&gt;snmpa_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义代理网络接口的行为。一个 &lt;code&gt;snmpa_network_interface&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="3c921e60f1fd55471b897ea29e000de7226f0bb1" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent notification filters. A &lt;code&gt;snmpa_notification_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义代理通知过滤器的行为。一个 &lt;code&gt;snmpa_notification_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="8c813e504362483e091dd45b65c32a63841d6a1d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface filter. A &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义管理器网络接口过滤器的行为。一个 &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="1efae6ac4d1c40501e88954337a2c493e68e0103" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface. A &lt;code&gt;snmpm_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">该模块定义管理器网络接口的行为。一个 &lt;code&gt;snmpm_network_interface&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="70cf854e5d6063f7072b44e1cece8ac9b81a70b7" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager user. A &lt;code&gt;snmpm_user&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">此模块定义管理员用户的行为。一个 &lt;code&gt;snmpm_user&lt;/code&gt; 兼容的模块必须导出以下功能：</target>
        </trans-unit>
        <trans-unit id="468ccfe9ae0121bf6da5c3aaba9a0e4a3f14050d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the notification delivery information receiver.</source>
          <target state="translated">该模块定义了通知传递信息接收者的行为。</target>
        </trans-unit>
        <trans-unit id="118517391ac279d58d25f1693b404c970b02d3e5" translate="yes" xml:space="preserve">
          <source>This module defines the callback behaviour of Megaco users. A megaco_user compliant callback module must export the following functions:</source>
          <target state="translated">这个模块定义了Megaco用户的回调行为。一个符合megaco_user标准的回调模块必须输出以下函数。</target>
        </trans-unit>
        <trans-unit id="4c8aaa7d34274a9f4bb7dc956dc47a8e7e1445eb" translate="yes" xml:space="preserve">
          <source>This module defines what happens when certain types of errors occur.</source>
          <target state="translated">该模块定义了当某些类型的错误发生时的情况。</target>
        </trans-unit>
        <trans-unit id="5ffa259dadc9ae103670240a5de8cb07d4a0a997" translate="yes" xml:space="preserve">
          <source>This module does not support &quot;raw&quot; filenames (that is, files whose names do not comply with the expected encoding). Such files are ignored by the functions in this module.</source>
          <target state="translated">本模块不支持 &quot;原始 &quot;文件名(即文件名不符合预期的编码)。本模块的功能会忽略这些文件。</target>
        </trans-unit>
        <trans-unit id="d6653760221ddc3d83e211cede6e8be096bb7928" translate="yes" xml:space="preserve">
          <source>This module enables C-programs to communicate with Erlang nodes, using the Erlang distribution over TCP/IP.</source>
          <target state="translated">该模块使C程序能够与Erlang节点通信,使用Erlang发行版通过TCP/IP进行通信。</target>
        </trans-unit>
        <trans-unit id="263e76116a98bb1fd881761f209bf1ba1fce107d" translate="yes" xml:space="preserve">
          <source>This module enables users to enter the short form of some commonly used commands.</source>
          <target state="translated">该模块使用户可以输入一些常用命令的简写。</target>
        </trans-unit>
        <trans-unit id="3343ff3168dd5f14d02286d39c2ac78ec614ecd9" translate="yes" xml:space="preserve">
          <source>This module expands records in a module.</source>
          <target state="translated">本模块可扩展模块中的记录。</target>
        </trans-unit>
        <trans-unit id="a3732061720e8ab1db0a300e706fb90768269889" translate="yes" xml:space="preserve">
          <source>This module exports functions for running &lt;code&gt;Common Test&lt;/code&gt; nodes on multiple hosts in parallel.</source>
          <target state="translated">此模块导出用于在多个主机上并行运行 &lt;code&gt;Common Test&lt;/code&gt; 节点的功能。</target>
        </trans-unit>
        <trans-unit id="0503901901ce52a8d8d522c2fc6e6ad11e2ed29f" translate="yes" xml:space="preserve">
          <source>This module exports functions used by the &lt;code&gt;Common Test&lt;/code&gt; Master to start and stop &quot;slave&quot; nodes. It is the default callback module for the &lt;code&gt;{init, node_start}&lt;/code&gt; term in the Test Specification.</source>
          <target state="translated">此模块导出 &lt;code&gt;Common Test&lt;/code&gt; 主设备用来启动和停止&amp;ldquo;从&amp;rdquo;节点的功能。它是测试规范中 &lt;code&gt;{init, node_start}&lt;/code&gt; 术语的默认回调模块。</target>
        </trans-unit>
        <trans-unit id="5c1c8fa2fdb9c360a27bfb55873d503a480bf994" translate="yes" xml:space="preserve">
          <source>This module exports help functions for parsing of test specifications.</source>
          <target state="translated">该模块输出帮助函数,用于解析测试规范。</target>
        </trans-unit>
        <trans-unit id="a7e44b5175c847fa8191a306063c634fed83971d" translate="yes" xml:space="preserve">
          <source>This module exports help functions for performing code coverage analysis.</source>
          <target state="translated">该模块输出帮助函数,用于执行代码覆盖率分析。</target>
        </trans-unit>
        <trans-unit id="eb5bfcc59cc41439eaa702f52ecbd01d0b73eb7d" translate="yes" xml:space="preserve">
          <source>This module generates an HTML directory listing (Apache-style) if a client sends a request for a directory instead of a file. This module must be removed from the Modules config directive if directory listings is unwanted.</source>
          <target state="translated">如果客户端发送一个目录而不是文件的请求,这个模块会生成一个HTML目录列表(Apache风格)。如果不需要目录列表,必须从模块配置指令中删除该模块。</target>
        </trans-unit>
        <trans-unit id="ebf8cc7dad040f1beca78868efd260f249334a6e" translate="yes" xml:space="preserve">
          <source>This module handles invoking of CGI scripts.</source>
          <target state="translated">该模块处理CGI脚本的调用。</target>
        </trans-unit>
        <trans-unit id="474f6eb9d78d082e8b16b40b4a1c3de1a0cc963c" translate="yes" xml:space="preserve">
          <source>This module has been deprecated and will be removed in a furture release.</source>
          <target state="translated">该模块已被废止,将在后续版本中删除。</target>
        </trans-unit>
        <trans-unit id="4ead8db89a63c65e38113715680218a6fa71339b" translate="yes" xml:space="preserve">
          <source>This module has been reworked in Erlang/OTP 20 to handle &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; and operate on grapheme clusters. The &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt; old functions&lt;/a&gt;&lt;/code&gt; that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20277e2186104d73a70c009c74886d168752fafa" translate="yes" xml:space="preserve">
          <source>This module has been reworked in Erlang/OTP 20 to handle &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; and operate on grapheme clusters. The &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release.</source>
          <target state="translated">此模块已在Erlang / OTP 20中进行了重新处理，以处理 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 并在字素簇上运行。只能在Latin-1列表上作为输入使用的 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; 仍然可用，但不应使用，在以后的版本中将不推荐使用。</target>
        </trans-unit>
        <trans-unit id="e92193f0e2766adbb07bff2f6dfb2e47b5b38666" translate="yes" xml:space="preserve">
          <source>This module has three sets of interface functions: the &quot;Original API&quot;, the &quot;Extended API&quot;, and the &quot;Okasaki API&quot;.</source>
          <target state="translated">该模块有三组接口函数:&quot;原始API&quot;、&quot;扩展API &quot;和 &quot;冈崎API&quot;。</target>
        </trans-unit>
        <trans-unit id="e5308b8befdbb88760705def10e558c7d6f76c3f" translate="yes" xml:space="preserve">
          <source>This module helps running property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. One (or more) of the property testing tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94b28ea5c396cd8b2c46ddc4551b34a14bfd479" translate="yes" xml:space="preserve">
          <source>This module implements a client for file transfer according to a subset of the File Transfer Protocol (FTP), see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此模块根据文件传输协议（FTP）的子集实现用于文件传输的客户端，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b25912bf3af7bf1193b3fff50e47205181300228" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec measurement tool.</source>
          <target state="translated">该模块实现了一个简单的megaco编解码器测量工具。</target>
        </trans-unit>
        <trans-unit id="871eeb782d63d6630dd6a5d492a7b58d86850778" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了一个简单的基于megaco编解码器的性能工具。</target>
        </trans-unit>
        <trans-unit id="f9179ddef6a9ee16329a9f709abd6d55eba87a03" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco message transformation utility.</source>
          <target state="translated">该模块实现了一个简单的megaco消息转换工具。</target>
        </trans-unit>
        <trans-unit id="509079930c0c0a8b4797c4ad9534704e9e78b720" translate="yes" xml:space="preserve">
          <source>This module implements a text based interface to the &lt;code&gt;trace/3&lt;/code&gt; and the &lt;code&gt;trace_pattern/2&lt;/code&gt; BIFs. It makes it possible to trace functions, processes, ports and messages.</source>
          <target state="translated">该模块为 &lt;code&gt;trace/3&lt;/code&gt; 和 &lt;code&gt;trace_pattern/2&lt;/code&gt; BIF实现了基于文本的接口。它使跟踪功能，过程，端口和消息成为可能。</target>
        </trans-unit>
        <trans-unit id="c2d643bd7191e32f2c51494e11bf58ee73f4a435" translate="yes" xml:space="preserve">
          <source>This module implements an SSH FTP (SFTP) client. SFTP is a secure, encrypted file transfer service available for SSH.</source>
          <target state="translated">该模块实现了一个SSH FTP(SFTP)客户端。SFTP是一种安全的、加密的、适用于SSH的文件传输服务。</target>
        </trans-unit>
        <trans-unit id="03ef132a9564d822dda1f23634bee22efb87c0be" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over SCTP using &lt;code&gt;gen_sctp(3)&lt;/code&gt;. It can be specified as the value of a transport_module option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块使用 &lt;code&gt;gen_sctp(3)&lt;/code&gt; 在SCTP上实现直径传输。可以将其指定为 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 的transport_module选项的值，并实现在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 中记录的行为。</target>
        </trans-unit>
        <trans-unit id="88cb8b49f73b329262758743b81d712fdab5c653" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over TCP using &lt;code&gt;gen_tcp(3)&lt;/code&gt;. It can be specified as the value of a &lt;code&gt;transport_module&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. TLS security is supported, either as an upgrade following capabilities exchange or at connection establishment.</source>
          <target state="translated">该模块使用 &lt;code&gt;gen_tcp(3)&lt;/code&gt; 在TCP上实现直径传输。可以将其指定为 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;transport_module&lt;/code&gt; 选项的值，并实现在 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 中记录的行为。支持TLS安全性，可以作为功能交换后的升级或建立连接时使用。</target>
        </trans-unit>
        <trans-unit id="9266c44a4ba8cd9ee1a5c81b4c58c87a30706c84" translate="yes" xml:space="preserve">
          <source>This module implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments are added. It is well suited for scalable hash tables.</source>
          <target state="translated">这个模块实现了动态哈希,这是一种当新的碎片加入时,会很好地增长的哈希。它非常适合于可扩展的哈希表。</target>
        </trans-unit>
        <trans-unit id="237af1ed7b14daa8c6a596b37b3d9e9e2855eee1" translate="yes" xml:space="preserve">
          <source>This module implements interfaces to dynamic tracing, should such be compiled into the virtual machine. For a standard and/or commercial build, no dynamic tracing is available, in which case none of the functions in this module is usable or give any effect.</source>
          <target state="translated">该模块实现了动态跟踪的接口,如果将其编译到虚拟机中的话。对于标准的和/或商业的构建,没有动态跟踪,在这种情况下,本模块中的任何功能都不能使用或产生任何效果。</target>
        </trans-unit>
        <trans-unit id="e063dd1183a5694a263767c4e6d75bf203f69f0d" translate="yes" xml:space="preserve">
          <source>This module implements process groups. A message can be sent to one, some, or all group members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5567e19229f23540f47010e8b1ddd342e185fa20" translate="yes" xml:space="preserve">
          <source>This module implements process groups. Each message can be sent to one, some, or all group members.</source>
          <target state="translated">该模块实现了流程组。每条消息可以发送给一个、部分或所有组成员。</target>
        </trans-unit>
        <trans-unit id="2d68eba5044da7ce7cbcdeb1e9cede6cbfa2c8b7" translate="yes" xml:space="preserve">
          <source>This module implements some convenience functions for analyzing microstate accounting data. For details about how to use the basic api and what the different states represent see &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81520061930d4cb81104030ae03956c22721f688" translate="yes" xml:space="preserve">
          <source>This module implements some convenience functions for analyzing microstate accounting data. For details about how to use the basic api and what the different states represent see &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt;.</source>
          <target state="translated">该模块实现了一些方便的功能，用于分析微状态会计数据。有关如何使用基本api以及不同状态表示什么的详细信息，请参见 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d15b1e9aa28423920ee271c9eb3d3a739153bbd9" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone1&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了&lt;strong&gt;mstone1&lt;/strong&gt;工具，这是一个简单的基于&lt;strong&gt;megaco&lt;/strong&gt;编解码器的性能工具。</target>
        </trans-unit>
        <trans-unit id="251e35996e11df5d3eaaaf86f280ba3afa349ebe" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone2&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">该模块实现了&lt;strong&gt;mstone2&lt;/strong&gt;工具，这是一个简单的基于&lt;strong&gt;megaco&lt;/strong&gt;编解码器的性能工具。</target>
        </trans-unit>
        <trans-unit id="a53a9f4087442a15c8d05293fde6edfea4bb383c" translate="yes" xml:space="preserve">
          <source>This module implements the command-line interface for running tests and basic functions for &lt;code&gt;Common Test&lt;/code&gt; case issues, such as configuration and logging.</source>
          <target state="translated">该模块实现了用于运行测试的命令行界面以及针对 &lt;code&gt;Common Test&lt;/code&gt; 案例问题（例如配置和日志记录）的基本功能。</target>
        </trans-unit>
        <trans-unit id="c9a16d56697c4875fd3dc95099670093ace6758a" translate="yes" xml:space="preserve">
          <source>This module implements the main API for logging in Erlang/OTP. To create a log event, use the &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; or the log &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">该模块实现用于登录Erlang / OTP的主要API。要创建日志事件，请使用 &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; 或日志 &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="34096d8559e322df745393832ab2c6dfe7da7fb5" translate="yes" xml:space="preserve">
          <source>This module is a &lt;code&gt;gen_event&lt;/code&gt; handler module that can be installed in any &lt;code&gt;gen_event&lt;/code&gt; process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser (&lt;code&gt;rb(3)&lt;/code&gt;) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called &lt;code&gt;index&lt;/code&gt;, and report files &lt;code&gt;1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">该模块是 &lt;code&gt;gen_event&lt;/code&gt; 处理程序模块，可以安装在任何 &lt;code&gt;gen_event&lt;/code&gt; 进程中。它将所有发送到事件管理器的事件记录到磁盘上。每个事件均以二进制形式编写，这使得记录速度非常快。但是，必须使用诸如报告浏览器（ &lt;code&gt;rb(3)&lt;/code&gt; ）之类的工具来读取文件。事件被写入多个文件。使用完所有文件后，第一个文件将被重用和覆盖。目录位置，文件数和每个文件的大小都是可配置的。该目录将包括一个文件调用 &lt;code&gt;index&lt;/code&gt; ，并报告文件 &lt;code&gt;1, 2, ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91f4aea2b0c25de578d81458879b8b8a6606f33f" translate="yes" xml:space="preserve">
          <source>This module is a first step to run property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. A property testing tool like QuickCheck or PropEr is assumed to be installed.</source>
          <target state="translated">该模块是在 &lt;code&gt;Common Test&lt;/code&gt; 框架中运行基于属性的测试的第一步。假定已安装诸如QuickCheck或PropEr之类的属性测试工具。</target>
        </trans-unit>
        <trans-unit id="745e849710741c8126631867ff49314e84421edc" translate="yes" xml:space="preserve">
          <source>This module is a front end to the pretty-printing library module &lt;code&gt;prettypr&lt;/code&gt;, for text formatting of abstract syntax trees defined by the module &lt;code&gt;erl_syntax&lt;/code&gt;.</source>
          <target state="translated">该模块是一个前端的漂亮印刷库模块 &lt;code&gt;prettypr&lt;/code&gt; ，文本由模块定义的抽象语法树的格式 &lt;code&gt;erl_syntax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="771c2457f87cf1d0281342c6af1f3ab5bb5e2564" translate="yes" xml:space="preserve">
          <source>This module is also used by the test module described in the next section.</source>
          <target state="translated">这个模块也被下一节描述的测试模块使用。</target>
        </trans-unit>
        <trans-unit id="029ed3af3c0fa1d9308479815ba39c6258f71e21" translate="yes" xml:space="preserve">
          <source>This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of &lt;code&gt;ordered_set&lt;/code&gt;, see below, access time is proportional to the logarithm of the number of stored objects.)</source>
          <target state="translated">该模块是Erlang内置术语存储BIF的接口。这些提供了在Erlang运行时系统中存储大量数据的能力，并具有对数据的恒定访问时间。（对于 &lt;code&gt;ordered_set&lt;/code&gt; ，请参见下文，访问时间与存储对象数的对数成正比。）</target>
        </trans-unit>
        <trans-unit id="ab06f0be8cb17b619659641efccfa5a0d94a8229" translate="yes" xml:space="preserve">
          <source>This module is deprecated since OTP 23. Use the module &lt;code&gt;uri_string&lt;/code&gt; to properly handle URIs, this is the recommended module since OTP 21.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf3be01bc933bf9be0bb2caf2dc7622f94a43df" translate="yes" xml:space="preserve">
          <source>This module is deprecated. For a description of the Magic Cookie system, refer to &lt;code&gt;Distributed Erlang&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">该模块已弃用。有关Magic Cookie系统的说明，请参阅《 Erlang参考手册》中的&amp;ldquo; &lt;code&gt;Distributed Erlang&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2a93d2db2466d23d6026908c314c14a83563ca6b" translate="yes" xml:space="preserve">
          <source>This module is mainly intended for internal use within OTP, but it has two functions that are exported for public use.</source>
          <target state="translated">这个模块主要是供OTP内部使用的,但它有两个功能是输出给公众使用的。</target>
        </trans-unit>
        <trans-unit id="1a37f6b1919b03e1a3eef60f562daa64d563a0b3" translate="yes" xml:space="preserve">
          <source>This module is preloaded and contains the code for the &lt;code&gt;init&lt;/code&gt; system process that coordinates the startup of the system. The first function evaluated at startup is &lt;code&gt;boot(BootArgs)&lt;/code&gt;, where &lt;code&gt;BootArgs&lt;/code&gt; is a list of command-line arguments supplied to the Erlang runtime system from the local operating system; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">该模块已预先加载，其中包含用于协调系统启动的 &lt;code&gt;init&lt;/code&gt; 系统进程的代码。启动时评估的第一个函数是 &lt;code&gt;boot(BootArgs)&lt;/code&gt; ，其中 &lt;code&gt;BootArgs&lt;/code&gt; 是从本地操作系统提供给Erlang运行时系统的命令行参数列表；参见 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8550670270cc6c0c154e6b678e3322ac083e01" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling GET requests to regular files. GET requests for parts of files is handled by &lt;code&gt;mod_range&lt;/code&gt;.</source>
          <target state="translated">该模块负责处理对常规文件的GET请求。对部分文件的GET请求由 &lt;code&gt;mod_range&lt;/code&gt; 处理。</target>
        </trans-unit>
        <trans-unit id="539b25aff993fcacaf4286ade9ec0f542cedebde" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling HEAD requests to regular files. HEAD requests for dynamic content is handled by each module responsible for dynamic content.</source>
          <target state="translated">该模块负责处理对普通文件的HEAD请求。动态内容的HEAD请求由负责动态内容的各模块处理。</target>
        </trans-unit>
        <trans-unit id="d192cc2f42a8d904da0e0162e8485626f5ec3af9" translate="yes" xml:space="preserve">
          <source>This module is similar to &lt;code&gt;ets&lt;/code&gt; in that it provides a storage for Erlang terms that can be accessed in constant time, but with the difference that &lt;code&gt;persistent_term&lt;/code&gt; has been highly optimized for reading terms at the expense of writing and updating terms. When a persistent term is updated or deleted, a global garbage collection pass is run to scan all processes for the deleted term, and to copy it into each process that still uses it. Therefore, &lt;code&gt;persistent_term&lt;/code&gt; is suitable for storing Erlang terms that are frequently accessed but never or infrequently updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758181cc746f5e39f0bd67af3c9cff191b5c70fa" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt; erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce2d8127480b9b1949b76303752c4240c4a9505" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="translated">该模块是基本的Erlang解析器，它将令牌转换为形式（即顶级构造），表达式或术语的抽象形式。《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 描述了抽象格式。请注意，令牌列表必须以&lt;strong&gt;点&lt;/strong&gt;令牌结尾，以便解析函数可以接受（请参阅 &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt; ）模块。</target>
        </trans-unit>
        <trans-unit id="c5088feb51b7d364ba0408f5823e446921051046" translate="yes" xml:space="preserve">
          <source>This module is the default callback handler for the client's and the server's user and host &quot;database&quot; operations. All data, for instance key pairs, are stored in files in the normal file system. This page documents the files, where they are stored and configuration options for this callback module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2b019e4ec5090f2acbc77c196c921bcb3de610" translate="yes" xml:space="preserve">
          <source>This module is the default error report module, but can be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块是默认的错误报告模块，但可以显式配置，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84c431043a09432c4f87c8d3c357236a55bbfcb6" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0.</source>
          <target state="translated">这个模块是XML解析器的接口,它处理XML 1.0。</target>
        </trans-unit>
        <trans-unit id="3104bc131d319b6e5efc35816fb7e2161d34e06f" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0. The XML parser is activated through &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; or &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. It returns records of the type defined in xmerl.hrl. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">该模块是XML解析器的接口，它处理XML 1.0。XML解析器通过 &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 或 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 激活。它返回xmerl.hrl中定义的类型的记录。另请参阅有关自定义功能的 &lt;code&gt;tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c37b4a9c779ad7673d2176f38ce64f13f8e8ff9a" translate="yes" xml:space="preserve">
          <source>This module is the main EUnit user interface.</source>
          <target state="translated">该模块是EUnit的主要用户界面。</target>
        </trans-unit>
        <trans-unit id="380eae6ed1f14f5abc43a6827952590fc885d0c2" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块用作 &lt;code&gt;os_sup&lt;/code&gt; 的Windows后端，请参见 &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="418bac64df42298bb2e47d356802d620e125c0b8" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85cabe69b73c75cfce665849059c6c267e570fc3" translate="yes" xml:space="preserve">
          <source>This module is used by module &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; for managing distributed disk logs. The disk log names are used as group names, which means that some action can be needed to avoid name clashes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 模块使用此模块来管理分布式磁盘日志。磁盘日志名称用作组名称，这意味着可能需要采取一些措施来避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="2facc0dce78b1734ff96c5e2c414eea0b55cfeef" translate="yes" xml:space="preserve">
          <source>This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used.</source>
          <target state="translated">这个模块是由Mnesia应用程序使用的,它是 &quot;按原样 &quot;提供给那些对高效存储Erlang术语感兴趣的用户的。许多应用程序只需要在文件中存储一些术语。Mnesia增加了事务、查询和分发功能。Dets文件的大小不能超过2GB。如果需要更大的表,可以使用Mnesia中的表碎片。</target>
        </trans-unit>
        <trans-unit id="0a4a5f76c2f39ee7d14410f547c13073a7f0ccea" translate="yes" xml:space="preserve">
          <source>This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended.</source>
          <target state="translated">该模块用于检查Erlang代码是否存在非法语法和其他错误。它还对不推荐的编码实践提出警告。</target>
        </trans-unit>
        <trans-unit id="eeb466b5da365f466e8f7e7ccc932ed35a24cf1b" translate="yes" xml:space="preserve">
          <source>This module is used to load all Erlang modules into the system. The start script is also fetched with this low-level loader.</source>
          <target state="translated">这个模块用于将所有的Erlang模块加载到系统中。启动脚本也是通过这个低级加载器获取的。</target>
        </trans-unit>
        <trans-unit id="2290e1725f60788cc5c925cb7d57804f016396a1" translate="yes" xml:space="preserve">
          <source>This module is used to profile a program to find out how the execution time is used. Trace to file is used to minimize runtime performance impact.</source>
          <target state="translated">该模块用于对程序进行剖析,了解执行时间的使用情况。追踪到文件是用来最小化运行时的性能影响。</target>
        </trans-unit>
        <trans-unit id="cf791b13f3d789dba7e7d40b898243584bd114e9" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt; OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt; sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c89a4f0fda18575f2da9f933c35be2fd6e70e09" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt;OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该模块用于启动遵循 &lt;code&gt;OTP Design Principles&lt;/code&gt; 流程。具体来说，启动新进程时，OTP标准行为（例如 &lt;code&gt;gen_server&lt;/code&gt; 和 &lt;code&gt;gen_statem&lt;/code&gt; ）将使用此模块中的功能。这些功能还可用于启动&lt;strong&gt;特殊过程&lt;/strong&gt;，即符合OTP设计原则的用户定义过程。有关示例，请参见OTP设计原则中的 &lt;code&gt;sys and proc_lib&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="7f4ab243ee6586ee79497742f5b5a43934de147b" translate="yes" xml:space="preserve">
          <source>This module is usually part of the &lt;code&gt;erl_interface&lt;/code&gt; application, but is currently part of the Mnesia application.</source>
          <target state="translated">该模块通常是 &lt;code&gt;erl_interface&lt;/code&gt; 应用程序的一部分，但当前是Mnesia应用程序的一部分。</target>
        </trans-unit>
        <trans-unit id="1e34649b10e11074b5eecec6992267ea5de9baf9" translate="yes" xml:space="preserve">
          <source>This module maintains a cache of CRLs. CRLs can be added to the cache using the function &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt;, and optionally automatically fetched through HTTP if the following argument is specified:</source>
          <target state="translated">此模块维护CRL的缓存。可以使用 &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt; 函数将 CRL添加到缓存中，如果指定了以下参数，则可以选择通过HTTP自动获取CRL ：</target>
        </trans-unit>
        <trans-unit id="48cfe86ff08451c66cbfbd564bce30700dcbc33c" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt; global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99468bcd97490a51d234dfa1e1aa1f1b75181a01" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块可以将系统的节点划分为&lt;strong&gt;全局组&lt;/strong&gt;。每个全局组都有自己的全局名称空间，请参阅 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ac57e5b97d1c2443f197da3b8016c360ca297b4" translate="yes" xml:space="preserve">
          <source>This module makes it possible to read internally formatted wrap disk logs, see &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;wrap_log_reader&lt;/code&gt; does not interfere with &lt;code&gt;disk_log&lt;/code&gt; activities; there is however a bug in this version of the &lt;code&gt;wrap_log_reader&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块可以读取内部格式化的包装磁盘日志，请参阅 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;wrap_log_reader&lt;/code&gt; 不会干扰 &lt;code&gt;disk_log&lt;/code&gt; 活动；但是，在该版本的 &lt;code&gt;wrap_log_reader&lt;/code&gt; 中存在一个错误，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="989e49030b5db914fe14f640feffac69f14c2c8d" translate="yes" xml:space="preserve">
          <source>This module makes use of a directory where CRLs are stored in files named by the hash of the issuer name.</source>
          <target state="translated">该模块利用一个目录,将CRL存储在以发行商名称的哈希值命名的文件中。</target>
        </trans-unit>
        <trans-unit id="3e4a8e573560a8571cd9ef1e8a9e51dcf07a77f3" translate="yes" xml:space="preserve">
          <source>This module needs to be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要明确配置此模块，请参见 &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b605512fe66b8682ce8b37c4cf3e4fbe2e01d42" translate="yes" xml:space="preserve">
          <source>This module operates on grapheme clusters. A &lt;strong&gt;grapheme cluster&lt;/strong&gt; is a user-perceived character, which can be represented by several codepoints.</source>
          <target state="translated">该模块在字素簇上运行。字素&lt;strong&gt;簇&lt;/strong&gt;是用户感知的字符，可以由几个代码点表示。</target>
        </trans-unit>
        <trans-unit id="bb1c46b6a237b6087130260dff45a5cc687d6cba" translate="yes" xml:space="preserve">
          <source>This module performs DNS name resolving to recursive name servers.</source>
          <target state="translated">该模块对递归的名称服务器进行DNS名称解析。</target>
        </trans-unit>
        <trans-unit id="4ab7b3a5e783c28b801aa97ce3c793f0d6d021bc" translate="yes" xml:space="preserve">
          <source>This module performs an identity parse transformation of Erlang code. It is included as an example for users who wants to write their own parse transformers. If option &lt;code&gt;{parse_transform,Module}&lt;/code&gt; is passed to the compiler, a user-written function &lt;code&gt;parse_transform/2&lt;/code&gt; is called by the compiler before the code is checked for errors.</source>
          <target state="translated">此模块执行Erlang代码的身份解析转换。它是为想要编写自己的解析转换器的用户提供的示例。如果将选项 &lt;code&gt;{parse_transform,Module}&lt;/code&gt; 传递给编译器，则在检查代码是否存在错误之前，编译器将调用用户编写的函数 &lt;code&gt;parse_transform/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db95c0c571d0edee3b86863284018ac0d738f900" translate="yes" xml:space="preserve">
          <source>This module provide services similar to Remote Procedure Calls. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0037900bad0730ea9a030ba4069f75cb17a7f8b" translate="yes" xml:space="preserve">
          <source>This module provides (double-ended) FIFO queues in an efficient manner.</source>
          <target state="translated">该模块以高效的方式提供(双端)FIFO队列。</target>
        </trans-unit>
        <trans-unit id="86963c4e13e1aeb4e47cbb6c0a5df6d5e8a947ad" translate="yes" xml:space="preserve">
          <source>This module provides API functions to send SSH Connection Protocol events to the other side of an SSH channel.</source>
          <target state="translated">该模块提供API函数,用于将SSH连接协议事件发送到SSH通道的另一边。</target>
        </trans-unit>
        <trans-unit id="ce8b320b968902deab02747f5036f5e0f055ee88" translate="yes" xml:space="preserve">
          <source>This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees.</source>
          <target state="translated">这个模块提供了Arne Andersson教授的通用平衡树。与非平衡二叉树相比,这些树没有存储开销,而且其性能比AVL树更好。</target>
        </trans-unit>
        <trans-unit id="781b6c37f92636bd37c09e7bf44c27d67bf8df9d" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. An &lt;code&gt;orddict&lt;/code&gt; is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the &lt;strong&gt;Erlang term order&lt;/strong&gt;.</source>
          <target state="translated">该模块提供了 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 字典。一个 &lt;code&gt;orddict&lt;/code&gt; 是一个字典，其中对一个列表用于存储的键和值的表示。该列表按&lt;strong&gt;Erlang术语中&lt;/strong&gt;的键&lt;strong&gt;排序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="54ac9b6927419ddb4103884312f8097df3f2bb5a" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. The representation of a dictionary is not defined.</source>
          <target state="translated">该模块提供了 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 字典。未定义字典的表示。</target>
        </trans-unit>
        <trans-unit id="393cc80d6eca92a704f69151bc3d7efe95ae4615" translate="yes" xml:space="preserve">
          <source>This module provides a client api to the Lightweight Directory Access Protocol (LDAP).</source>
          <target state="translated">该模块为轻量级目录访问协议(LDAP)提供了一个客户端api。</target>
        </trans-unit>
        <trans-unit id="015ecfc007c07144fe6ae22676ba1b983919f2ff" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; Xoroshiro and Xorshift algorithms &lt;/a&gt;&lt;/code&gt; by Sebastiano Vigna. The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62d79bfd7ef0367f3e971c525740d763d760116" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms use the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="translated">该模块提供了伪随机数生成器。该模块包含许多算法。均匀分布算法使用 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; 的xoroshiro116 +和xorshift1024 *算法。正态分布算法在均匀分布算法的基础上使用 &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; 的Ziggurat方法。</target>
        </trans-unit>
        <trans-unit id="f99a3f1888d10fffd183a70ef4c3a34c9ed1aee3" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;code&gt;Mnesia&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt;, and other data structures that provide an iterator style traversal of objects.</source>
          <target state="translated">该模块为 &lt;code&gt;Mnesia&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt; 和其他提供对象迭代器样式遍历的数据结构提供查询接口。</target>
        </trans-unit>
        <trans-unit id="b710ecaed2fa7dbc6a10afe4f44c9844447837ab" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt; Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt; Erlang Reference Manual&lt;/code&gt; and &lt;code&gt; Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4250319025eafcb7ae410e50274c9a7bdf114b1e" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt;Erlang Reference Manual&lt;/code&gt; and &lt;code&gt;Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="translated">该模块提供了&lt;strong&gt;QLC表&lt;/strong&gt;的查询接口。典型的QLC表是Mnesia，ETS和Dets表。还提供了对用户定义表的支持，请参阅 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 。一个&lt;strong id=&quot;query_list_comprehension&quot;&gt;查询&lt;/strong&gt;使用表示&lt;strong&gt;查询列表综合&lt;/strong&gt;（QLCs）。查询的答案由QLC表中的数据确定，这些数据满足查询的QLC所表示的约束。 QLC与《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 和《 &lt;code&gt;Programming Examples&lt;/code&gt; 所述的普通列表理解类似，不同之处在于，模式中引入的变量不能用于列表表达式中。在没有优化和选项的情况下，例如 &lt;code&gt;cache&lt;/code&gt; 和 &lt;code&gt;unique&lt;/code&gt; （请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 部分，每个没有QLC表的QLC都会得出与相同的普通列表理解相同的答案列表。</target>
        </trans-unit>
        <trans-unit id="047710b1ad9fd2f027b84c9368779228a800a4da" translate="yes" xml:space="preserve">
          <source>This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in 'An efficient and portable pseudo-random number generator', Journal of Applied Statistics. AS183. 1982. Also Byte March 1987.</source>
          <target state="translated">这个模块提供了一个随机数生成器。该方法归功于B.A.Wichmann和I.D.Hill在 &quot;An efficient and portable pseudo-random number generator&quot;,Journal of Applied Statistics.AS183.B.A.Wichmann和I.D.Hill在 &quot;An efficient and portable pseudo-random number generator&quot;,Journal of Applied Statistics.1982.也是Byte 1987年3月。</target>
        </trans-unit>
        <trans-unit id="52aa0232673b318eae9c0f57627c3e65f31b22a8" translate="yes" xml:space="preserve">
          <source>This module provides a set of cryptographic functions.</source>
          <target state="translated">该模块提供了一组加密函数。</target>
        </trans-unit>
        <trans-unit id="c9cba1fc7e1e6375fe2609ded1dd8583269f1e82" translate="yes" xml:space="preserve">
          <source>This module provides a set of functions to do atomic operations towards mutable atomic variables. The implementation utilizes only atomic hardware instructions without any software level locking, which makes it very efficient for concurrent access. The atomics are organized into arrays with the following semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4f8c5f2a61de92835e1cf4cdaa069d643860a4" translate="yes" xml:space="preserve">
          <source>This module provides a set of functions to do operations towards shared mutable counter variables. The implementation does not utilize any software level locking, which makes it very efficient for concurrent access. The counters are organized into arrays with the following semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efbf1cf06a7e77fc1af683651fd7cc8b8da3411" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are sent to the &lt;code&gt;error_logger&lt;/code&gt; after a size check. Messages are truncated after 1024 chars. It is provided as an example.</source>
          <target state="translated">该模块提供了一种报告SNMP错误的简单机制。大小检查后，错误将发送到 &lt;code&gt;error_logger&lt;/code&gt; 。消息在1024个字符后被截断。作为示例提供。</target>
        </trans-unit>
        <trans-unit id="096fb2e3550a9bb0e5272f77db40c6b69c2ccf79" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are written to stdout using the &lt;code&gt;io&lt;/code&gt; module. It is provided as an simple example.</source>
          <target state="translated">该模块提供了一种报告SNMP错误的简单机制。使用 &lt;code&gt;io&lt;/code&gt; 模块将错误写入stdout 。它只是一个简单的示例。</target>
        </trans-unit>
        <trans-unit id="1286f91cbc25e7fd94773e366acdb66f0cb92b07" translate="yes" xml:space="preserve">
          <source>This module provides a term storage on file. The stored terms, in this module called &lt;strong&gt;objects&lt;/strong&gt;, are tuples such that one element is defined to be the key. A Dets &lt;strong&gt;table&lt;/strong&gt; is a collection of objects with the key at the same position stored on a file.</source>
          <target state="translated">此模块提供术语存储在文件中。在此模块中称为&lt;strong&gt;对象&lt;/strong&gt;的存储术语是元组，以便将一个元素定义为键。Dets &lt;strong&gt;表&lt;/strong&gt;是对象的集合，其中密钥位于文件中的相同位置。</target>
        </trans-unit>
        <trans-unit id="70f7f82b88797a35a1dc7be25685b1a8d3dd545e" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs (&quot;digraphs&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1620c061e4de1e2d509ff847686aeef840c94ae4" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="translated">本模块提供了一个标签定向图的版本。这里提供的图之所以是非正向图,是因为允许顶点之间有多条边。但是,这里使用的是有向图的习惯定义。</target>
        </trans-unit>
        <trans-unit id="d4cf7ab2f5fd96a0860285a8e510288d8e51d560" translate="yes" xml:space="preserve">
          <source>This module provides access to TCP/IP protocols.</source>
          <target state="translated">本模块提供对TCP/IP协议的访问。</target>
        </trans-unit>
        <trans-unit id="ce4f070d6f9440d796d3f2ff1b4d9fe245970d26" translate="yes" xml:space="preserve">
          <source>This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">该模块提供基于有向图的深度优先遍历的算法。有关有向图的基本功能，请参见 &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="590c0955f816427dea3514fb29ccfa4c0c1b4c12" translate="yes" xml:space="preserve">
          <source>This module provides an API for network socket. Functions are provided to create, delete and manupilate the sockets aswell as sending and reciving data on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c872a39dd86a1b96a68b0996c9785f1de2375352" translate="yes" xml:space="preserve">
          <source>This module provides an API for the network interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750641c760c68123c0ef647455d03f63c154be54" translate="yes" xml:space="preserve">
          <source>This module provides an API for the zlib library (&lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt;). It is used to compress and decompress data. The data format is described by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块为zlib库（ &lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt; ）提供了API 。它用于压缩和解压缩数据。数据格式由 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt; 描述。</target>
        </trans-unit>
        <trans-unit id="faf120ddebe052c8dc6014a2841d031820c05adf" translate="yes" xml:space="preserve">
          <source>This module provides an Erlang shell.</source>
          <target state="translated">这个模块提供了一个Erlang shell。</target>
        </trans-unit>
        <trans-unit id="ce785837b5ff1a707a464ab7d4098ba53cf3ddeb" translate="yes" xml:space="preserve">
          <source>This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of &lt;strong id=&quot;annotations&quot;&gt;annotations&lt;/strong&gt; as described in the following.</source>
          <target state="translated">该模块提供了一种抽象类型，Erlang编译器及其帮助程序模块使用该抽象类型来保存诸如列，行号和文本之类的数据。数据类型是&lt;strong id=&quot;annotations&quot;&gt;注释&lt;/strong&gt;的集合，如下所述。</target>
        </trans-unit>
        <trans-unit id="c240161f74f286924b1ecba60c9826a37e901d2d" translate="yes" xml:space="preserve">
          <source>This module provides an interface for loading and unloading &lt;strong&gt;Erlang linked-in drivers&lt;/strong&gt; in runtime.</source>
          <target state="translated">该模块提供了一个接口，用于在运行时加载和卸载&lt;strong&gt;Erlang链接的驱动程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0d50e0a3798c5432e0aff3d79f28ece00952d5f8" translate="yes" xml:space="preserve">
          <source>This module provides an interface to a number of mathematical functions.</source>
          <target state="translated">该模块提供了一些数学函数的接口。</target>
        </trans-unit>
        <trans-unit id="b5733344375dbedf0030d51fc4fa5b63269782bb" translate="yes" xml:space="preserve">
          <source>This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks.</source>
          <target state="translated">该模块为BEAM编译器创建的文件(&quot;BEAM文件&quot;)提供一个接口。所使用的格式是 &quot;EA IFF 1985 &quot;交换格式文件标准的变体,将数据分成几块。</target>
        </trans-unit>
        <trans-unit id="4c0abe15371bacb3988f25e8e42f9bd6deaa06d4" translate="yes" xml:space="preserve">
          <source>This module provides an interface to standard Erlang I/O servers. The output functions all return &lt;code&gt;ok&lt;/code&gt; if they are successful, or exit if they are not.</source>
          <target state="translated">该模块提供了到标准Erlang I / O服务器的接口。如果成功，所有输出函数都将返回 &lt;code&gt;ok&lt;/code&gt; ，否则将退出。</target>
        </trans-unit>
        <trans-unit id="bb92749dec61f65e77f765c953d790353efc379f" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the file system.</source>
          <target state="translated">该模块提供了一个文件系统的接口。</target>
        </trans-unit>
        <trans-unit id="0ea2060b34505717f9518e88bbe84cae8d4301f7" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the standard Erlang compiler. It can generate either a new file, which contains the object code, or return a binary, which can be loaded directly.</source>
          <target state="translated">这个模块提供了一个连接标准Erlang编译器的接口,它可以生成一个新的文件,其中包含对象代码,或者返回一个二进制文件,可以直接加载。它可以生成一个新的文件,其中包含对象代码,或者返回一个二进制文件,可以直接加载。</target>
        </trans-unit>
        <trans-unit id="1e596baf52d2a5d67161fc159d66bc7111b7496e" translate="yes" xml:space="preserve">
          <source>This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt;, the Erlang parser, or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块为Erlang表达式提供了解释器。表达式采用 &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt; ，Erlang解析器或 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 返回的抽象语法。</target>
        </trans-unit>
        <trans-unit id="71c532b071cf1e2933fea5e0754fde5565914b25" translate="yes" xml:space="preserve">
          <source>This module provides computation of local and universal time, day of the week, and many time conversion functions.</source>
          <target state="translated">本模块提供了本地时间、通用时间、星期和许多时间转换函数的计算。</target>
        </trans-unit>
        <trans-unit id="f095529d267dab0aeb8e3b8b1364f61d105a9b58" translate="yes" xml:space="preserve">
          <source>This module provides for basic user authentication using textual files, Dets databases, or Mnesia databases.</source>
          <target state="translated">该模块提供了使用文本文件、Dets数据库或Mnesia数据库的基本用户认证。</target>
        </trans-unit>
        <trans-unit id="c9257a7b2b5d2a4ae1e7c3b4a499e70e6fee999d" translate="yes" xml:space="preserve">
          <source>This module provides functions for allocating and deallocating memory.</source>
          <target state="translated">该模块提供了分配和重新分配内存的功能。</target>
        </trans-unit>
        <trans-unit id="d1acd3ec02989ce1863b1f9978f7179ed4f16a75" translate="yes" xml:space="preserve">
          <source>This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like &lt;code&gt;foo.erl&lt;/code&gt;, a long absolute name including a drive designator, a directory name like &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt;, or any variations in between.</source>
          <target state="translated">该模块提供了用于分析和处理文件名的功能。设计这些功能是为了使Erlang代码可以在具有不同文件名格式的许多不同平台上工作。文件名是指可用于表示文件的所有字符串。文件名可以是一个简短的相对名称，如 &lt;code&gt;foo.erl&lt;/code&gt; ，一个绝对的长名称，包括一个驱动器标识符，一个目录名，例如 &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt; ，或之间的任何变体。</target>
        </trans-unit>
        <trans-unit id="ba26786354c2721a7cffffe073a2f1107136ad72" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; through the user-level &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块提供使用SCTP协议与套接字进行通信的功能。该实现假定OS内核通过用户级 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 支持SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6237d5a917a923f45f8684296ea4f397f5ee1fec" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the TCP/IP protocol.</source>
          <target state="translated">该模块提供了使用TCP/IP协议与套接字进行通信的功能。</target>
        </trans-unit>
        <trans-unit id="047ce7d569f63519c312507e77fc10e7a0abdd77" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the UDP protocol.</source>
          <target state="translated">该模块提供了使用UDP协议与套接字进行通信的功能。</target>
        </trans-unit>
        <trans-unit id="4170af0d02bb4471c502310e774e78bff4f783ba" translate="yes" xml:space="preserve">
          <source>This module provides functions for creating and manipulating Erlang terms.</source>
          <target state="translated">该模块提供了创建和操作Erlang术语的功能。</target>
        </trans-unit>
        <trans-unit id="1e4339ab7b3c28859324758d30d70eff072c8031" translate="yes" xml:space="preserve">
          <source>This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master.</source>
          <target state="translated">该模块提供了启动Erlang从属节点的功能。所有由主节点启动的从节点在主节点终止时自动终止。所有在从节点产生的终端输出都会发回主节点。文件I/O是通过主节点完成的。</target>
        </trans-unit>
        <trans-unit id="b46a173f5bc0dfe98e3415de1917b5e2303db97e" translate="yes" xml:space="preserve">
          <source>This module provides functions for string processing.</source>
          <target state="translated">该模块提供了字符串处理的功能。</target>
        </trans-unit>
        <trans-unit id="fb4e067fc4ce218df6cee6a75080152b7287b4b0" translate="yes" xml:space="preserve">
          <source>This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element.</source>
          <target state="translated">本模块提供了对有限集和以集表示的关系的操作。直观地讲,集合是一个元素的集合;每个元素都属于集合,集合包含每个元素。</target>
        </trans-unit>
        <trans-unit id="9b7c8f4236f4ac7c20019baf55ac92c3062eac4e" translate="yes" xml:space="preserve">
          <source>This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application.</source>
          <target state="translated">本模块使用Arne Andersson教授的通用平衡树提供有序集。对于较大的集合,有序集比使用有序列表更有效,但这取决于应用。</target>
        </trans-unit>
        <trans-unit id="ba40f5b3e99d275a596aa07c0dff3f599128accf" translate="yes" xml:space="preserve">
          <source>This module provides per-directory user configurable access control.</source>
          <target state="translated">该模块提供每个目录用户可配置的访问控制。</target>
        </trans-unit>
        <trans-unit id="2c12c2072886f929b57ed6b57be79da289e76ef8" translate="yes" xml:space="preserve">
          <source>This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry.</source>
          <target state="translated">这个模块提供了对Windows注册表的读写访问。它本质上是一个围绕Win32 API调用的端口驱动程序,用于访问注册表。</target>
        </trans-unit>
        <trans-unit id="c778b6bf3c6ceb257250b7ae833621c36f93fd49" translate="yes" xml:space="preserve">
          <source>This module provides some limited support for concurrent access. All updates to single objects are guaranteed to be both &lt;strong&gt;atomic&lt;/strong&gt; and &lt;strong&gt;isolated&lt;/strong&gt;. This means that an updating operation to a single object either succeeds or fails completely without any effect (atomicity) and that no intermediate results of the update can be seen by other processes (isolation). Some functions that update many objects state that they even guarantee atomicity and isolation for the entire operation. In database terms the isolation level can be seen as &quot;serializable&quot;, as if all isolated operations are carried out serially, one after the other in a strict order.</source>
          <target state="translated">该模块为并发访问提供了一些有限的支持。保证对单个对象的所有更新都是&lt;strong&gt;原子的&lt;/strong&gt;和&lt;strong&gt;隔离的&lt;/strong&gt;。这意味着对单个对象的更新操作要么成功要么完全失败，而没有任何影响（原子性），并且其他过程也看不到更新的中间结果（隔离）。一些更新许多对象的函数表示，它们甚至可以保证整个操作的原子性和隔离性。用数据库术语来说，隔离级别可以看作是&amp;ldquo;可序列化的&amp;rdquo;，就好像所有隔离操作都是按顺序执行的，一个接一个地严格执行。</target>
        </trans-unit>
        <trans-unit id="e080461e2e77686f66945fda37287e52c6b43e16" translate="yes" xml:space="preserve">
          <source>This module provides support for communication between distributed Erlang nodes and C-nodes, in a manner that is transparent to Erlang processes.</source>
          <target state="translated">该模块以对Erlang进程透明的方式,为分布式Erlang节点和C节点之间的通信提供支持。</target>
        </trans-unit>
        <trans-unit id="9dd15c5a43f249c41879dce22695542c08e92337" translate="yes" xml:space="preserve">
          <source>This module provides support for registering, looking up, and unregistering names in the &lt;code&gt;global&lt;/code&gt; module. For more information, see &lt;code&gt;kernel:global&lt;/code&gt;.</source>
          <target state="translated">该模块支持在 &lt;code&gt;global&lt;/code&gt; 模块中注册，查找和取消注册名称。有关更多信息，请参见 &lt;code&gt;kernel:global&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acc44f686954a04de29fbc3692f9d04d65486748" translate="yes" xml:space="preserve">
          <source>This module provides support for storing key-value pairs in a table known as a registry, backing up registries to &lt;code&gt;Mnesia&lt;/code&gt; in an atomic manner, and later restoring the contents of a registry from &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">此模块提供支持，以将键值对存储在称为注册表的表中，以原子方式将注册表备份到 &lt;code&gt;Mnesia&lt;/code&gt; ，然后从 &lt;code&gt;Mnesia&lt;/code&gt; 恢复注册表的内容。</target>
        </trans-unit>
        <trans-unit id="c4fb892b992e614adc88b69df82b17ae13945733" translate="yes" xml:space="preserve">
          <source>This module provides the API to an HTTP/1.1 compatible client according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Caching is not supported.</source>
          <target state="translated">该模块根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 向与HTTP / 1.1兼容的客户端提供API 。不支持缓存。</target>
        </trans-unit>
        <trans-unit id="6480b6d56431c3c7e09177c0ce29744efb2ce799" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with miscellaneous utility functions.</source>
          <target state="translated">该模块为Erlang Web服务器API模块程序员提供了杂七杂八的实用功能。</target>
        </trans-unit>
        <trans-unit id="0b8c5916e2632e665c5b2f5f52d5c56b0a93bc00" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with utility functions for generic sockets communication. The appropriate communication mechanism is transparently used, that is, &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;.</source>
          <target state="translated">该模块为Erlang Web服务器API模块编程人员提供了用于通用套接字通信的实用程序功能。透明地使用了适当的通信机制，即 &lt;code&gt;ip_comm&lt;/code&gt; 或 &lt;code&gt;ssl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a178749a79e6fb26e39ef05fff26033dce75ac3" translate="yes" xml:space="preserve">
          <source>This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733.</source>
          <target state="translated">该模块提供了一个接口,用户可以通过该接口实现一个使用RFC 6733中定义的Diameter协议发送和接收消息的Diameter节点。</target>
        </trans-unit>
        <trans-unit id="2290d99631f95e83db0417df2bd64d3d9576bcac" translate="yes" xml:space="preserve">
          <source>This module provides the most basic API to the clients and servers that are part of the &lt;code&gt;Inets&lt;/code&gt; application, such as start and stop.</source>
          <target state="translated">此模块为 &lt;code&gt;Inets&lt;/code&gt; 应用程序中的客户端和服务器提供最基本的API ，例如启动和停止。</target>
        </trans-unit>
        <trans-unit id="c2dc289d587182daff0825395e7477905794ef0d" translate="yes" xml:space="preserve">
          <source>This module provides the parse transformation that makes calls to &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell.</source>
          <target state="translated">该模块提供了解析转换，该转换使对 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 的调用转换为文字匹配规范。当从Erlang shell调用时，它还为相同的功能提供后端。</target>
        </trans-unit>
        <trans-unit id="721a3117429eceb8f061f5e2899bcbfb40bdf110" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;dict&lt;/code&gt; considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有定义的表示形式。一个区别是，当 &lt;code&gt;dict&lt;/code&gt; 认为两个键不匹配时（ &lt;code&gt;=:=&lt;/code&gt; ）是不同的，而当且仅当两个键的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才认为两个键是不同的。</target>
        </trans-unit>
        <trans-unit id="f2cfe02c9b447eb5cee32eb141157e31208af9a7" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; module. One difference is that while this module considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;orddict&lt;/code&gt; considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口。一个区别是，虽然此模块将两个键如果不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，则 &lt;code&gt;orddict&lt;/code&gt; 将且仅当两个键不相等时才将两个键视为不同（ &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="38d6e52db1a80893122e1c828b20e43583ef95f9" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;ordsets&lt;/code&gt; considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有未定义的表示形式。一个区别是，尽管此模块将两个元素不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，而 &lt;code&gt;ordsets&lt;/code&gt; 仅当且仅当它们不相等时才将两个元素视为不同（ &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6fff0aaa0429816efbfd85cd732dd006ea6157aa" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;sets&lt;/code&gt; considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">该模块提供与 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 模块相同的接口，但具有定义的表示形式。一个区别是，尽管 &lt;code&gt;sets&lt;/code&gt; 将两个元素不匹配（ &lt;code&gt;=:=&lt;/code&gt; ）视为不同，但是当且仅当两个元素的比较不相等（ &lt;code&gt;==&lt;/code&gt; ）时，此模块才将两个元素视为不同。</target>
        </trans-unit>
        <trans-unit id="742e632c6552d16bd6d478a7d1daf12903965f79" translate="yes" xml:space="preserve">
          <source>This module provides useful functions related to time. Unless otherwise stated, time is always measured in &lt;strong&gt;milliseconds&lt;/strong&gt;. All timer functions return immediately, regardless of work done by another process.</source>
          <target state="translated">该模块提供了与时间有关的有用功能。除非另有说明，否则时间始终以&lt;strong&gt;毫秒为单位&lt;/strong&gt;。不管另一个进程完成什么工作，所有计时器功能都会立即返回。</target>
        </trans-unit>
        <trans-unit id="b7d4e83f9e995a297aeebc8e6a32d2dba035f338" translate="yes" xml:space="preserve">
          <source>This module provides utility functions for working with URIs, according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; ，此模块提供了用于处理URI的实用程序功能。</target>
        </trans-unit>
        <trans-unit id="69116d4fbcf6560d1469aa6a1f54ad5b50520175" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_channel.</source>
          <target state="translated">这个模块取代了ssh_channel。</target>
        </trans-unit>
        <trans-unit id="e4595252d25beb7eb4255174f697d15c0830a38f" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_daemon_channel.</source>
          <target state="translated">这个模块取代了ssh_daemon_channel。</target>
        </trans-unit>
        <trans-unit id="8aeeae3a06e268738003ec9e46ac483c94be8f5b" translate="yes" xml:space="preserve">
          <source>This module responses to requests for one or many ranges of a file. This is especially useful when downloading large files, as a broken download can be resumed.</source>
          <target state="translated">该模块响应对一个或多个文件范围的请求。这在下载大文件时特别有用,因为中断的下载可以恢复。</target>
        </trans-unit>
        <trans-unit id="181bfa906d54214c120e83123d1185ab071fc48e" translate="yes" xml:space="preserve">
          <source>This module runs CGI scripts whenever a file of a certain type or HTTP method (see &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;) is requested.</source>
          <target state="translated">每当请求某种类型或HTTP方法的文件（请参阅 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; ）时，此模块就会运行CGI脚本。</target>
        </trans-unit>
        <trans-unit id="6cf32be7983eb16f31b4b6b42dc9e21cb5289f56" translate="yes" xml:space="preserve">
          <source>This module tokenises and parses most Erlang source code without expanding preprocessor directives and macro applications, as long as these are syntactically &quot;well-behaved&quot;. Because the normal parse trees of the &lt;code&gt;erl_parse&lt;/code&gt; module cannot represent these things (normally, they are expanded by the Erlang preprocessor &lt;code&gt;epp(3)&lt;/code&gt; before the parser sees them), an extended syntax tree is created, using the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">只要在语法上&amp;ldquo;表现良好&amp;rdquo;，此模块就可以在不扩展预处理器指令和宏应用程序的情况下标记和解析大多数Erlang源代码。因为 &lt;code&gt;erl_parse&lt;/code&gt; 模块的普通语法树无法表示这些东西（通常，它们在解析器看到它们之前由Erlang预处理程序 &lt;code&gt;epp(3)&lt;/code&gt; 进行了扩展），所以使用 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 模块创建了扩展语法树。</target>
        </trans-unit>
        <trans-unit id="5da9ff3bf77e5f995d90689278c7a23b1597c8bb" translate="yes" xml:space="preserve">
          <source>This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on.</source>
          <target state="translated">这个模块使用的是当前键。它的工作原理和当前目录很像。从当前键中,可以获取值,可以列出子键,等等。</target>
        </trans-unit>
        <trans-unit id="ba20fa4df70d15689e43b0f44c7517efe1b08358" translate="yes" xml:space="preserve">
          <source>This module uses application &lt;code&gt;SSH&lt;/code&gt;, which provides detailed information about, for example, functions, types, and options.</source>
          <target state="translated">该模块使用应用程序 &lt;code&gt;SSH&lt;/code&gt; ，该应用程序提供有关例如功能，类型和选项的详细信息。</target>
        </trans-unit>
        <trans-unit id="c27440a34997ba37bea9913114676bb50554dcae" translate="yes" xml:space="preserve">
          <source>This module was written for one-to-many style sockets (type &lt;code&gt;seqpacket&lt;/code&gt;). With the addition of &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt;, one-to-one style sockets (type &lt;code&gt;stream&lt;/code&gt;) were introduced.</source>
          <target state="translated">该模块是为一对多样式套接字（类型 &lt;code&gt;seqpacket&lt;/code&gt; ）编写的。加上 &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt; ，引入了一对一样式的套接字（类型 &lt;code&gt;stream&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="606223ff437db337a77e6be8dc6a090de4bc5931" translate="yes" xml:space="preserve">
          <source>This modules contains the interface to the &lt;code&gt;heart&lt;/code&gt; process. &lt;code&gt;heart&lt;/code&gt; sends periodic heartbeats to an external port program, which is also named &lt;code&gt;heart&lt;/code&gt;. The purpose of the &lt;code&gt;heart&lt;/code&gt; port program is to check that the Erlang runtime system it is supervising is still running. If the port program has not received any heartbeats within &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds (defaults to 60 seconds), the system can be rebooted.</source>
          <target state="translated">该模块包含 &lt;code&gt;heart&lt;/code&gt; 过程的接口。 &lt;code&gt;heart&lt;/code&gt; 会定期向外部端口程序发送心跳，该程序也称为 &lt;code&gt;heart&lt;/code&gt; 。 &lt;code&gt;heart&lt;/code&gt; 程序的目的是检查它所监视的Erlang运行时系统是否仍在运行。如果端口程序在 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 秒（默认为60秒）内未收到任何心跳，则可以重新引导系统。</target>
        </trans-unit>
        <trans-unit id="a2f8a20f0be71ce686a1d45af49ce482f6a78d69" translate="yes" xml:space="preserve">
          <source>This must however be done with care, as function &lt;code&gt;{return_trace}&lt;/code&gt; in the match specification destroys tail recursiveness.</source>
          <target state="translated">但是，这必须谨慎进行，因为比赛规范中的函数 &lt;code&gt;{return_trace}&lt;/code&gt; 会破坏尾部递归性。</target>
        </trans-unit>
        <trans-unit id="68582ac86e79db46d57ee06207c511b4a861bfb5" translate="yes" xml:space="preserve">
          <source>This node uses some master nodes to store and fetch release information. All master nodes must be operational whenever release information is written by this node.</source>
          <target state="translated">该节点使用一些主节点来存储和获取发布信息。每当本节点写入发布信息时,所有的主节点都必须运行。</target>
        </trans-unit>
        <trans-unit id="e2b52bf50e58c3cc457e61abee1b9f82215c9813" translate="yes" xml:space="preserve">
          <source>This node.</source>
          <target state="translated">这个节点。</target>
        </trans-unit>
        <trans-unit id="768833241e4c41a51c30053841c9a5be0a33a799" translate="yes" xml:space="preserve">
          <source>This now works as expected:</source>
          <target state="translated">现在可以按预期工作了。</target>
        </trans-unit>
        <trans-unit id="4858903cb179e40729be5206f937b3196b299dba" translate="yes" xml:space="preserve">
          <source>This of course requires your editor to support UTF-8 as well. The same comment is also interpreted by functions like &lt;code&gt;file:consult/1&lt;/code&gt;, the release handler, and so on, so that you can have all text files in your source directories in UTF-8 encoding.</source>
          <target state="translated">当然，这需要您的编辑器也支持UTF-8。相同的注释也由诸如 &lt;code&gt;file:consult/1&lt;/code&gt; ，发行处理程序之类的函数解释，以便您可以将源目录中的所有文本文件都以UTF-8编码进行处理。</target>
        </trans-unit>
        <trans-unit id="dfffe74a9c7d9d5e838ee7506a86798e8b02c78d" translate="yes" xml:space="preserve">
          <source>This off-line utility function can be used to convert the old snmp application config (pre snmp-4.0) to the new snmp agent config (as of snmp-4.0).</source>
          <target state="translated">这个离线实用功能可以用来将旧的snmp应用程序配置(snmp-4.0之前)转换为新的snmp代理配置(从snmp-4.0开始)。</target>
        </trans-unit>
        <trans-unit id="bb2b5100380724d761bb0b871c669f6341e1d19e" translate="yes" xml:space="preserve">
          <source>This only applies if Erlang is started as a distributed node, i.e. if &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is specified. Otherwise, epmd is not started even if &lt;code&gt;-start_epmd true&lt;/code&gt; is given.</source>
          <target state="translated">仅当Erlang作为分布式节点启动时才适用，即，如果指定 &lt;code&gt;-name&lt;/code&gt; 或 &lt;code&gt;-sname&lt;/code&gt; 。否则，即使给定 &lt;code&gt;-start_epmd true&lt;/code&gt; ，也不会启动epmd。</target>
        </trans-unit>
        <trans-unit id="36578cd782b1b1c7c098e80e28d83efcfb473d12" translate="yes" xml:space="preserve">
          <source>This operation is best described with an example.</source>
          <target state="translated">这个操作最好用一个例子来说明。</target>
        </trans-unit>
        <trans-unit id="726740b93f9a38ad69503060d61e78fcfc4ed2e8" translate="yes" xml:space="preserve">
          <source>This operation returns both configuration and state data from the server.</source>
          <target state="translated">该操作同时返回服务器的配置和状态数据。</target>
        </trans-unit>
        <trans-unit id="c28d8949e39a67d4d2b916902211267c2c1b4e17" translate="yes" xml:space="preserve">
          <source>This option and option &lt;code&gt;match_limit&lt;/code&gt; are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</source>
          <target state="translated">此选项和选项 &lt;code&gt;match_limit&lt;/code&gt; 仅在极少数情况下使用。建议在篡改这些限制之前先了解PCRE库的内部。</target>
        </trans-unit>
        <trans-unit id="b28bd6e66a4a300d7c55eecf5ec9dbf9fcd4dd0a" translate="yes" xml:space="preserve">
          <source>This option appears to be VERY Linux specific, and its existence in future Linux kernel versions is also worrying since the option is part of RFC 2292 which is since long (2003) obsoleted by RFC 3542 that &lt;strong&gt;explicitly&lt;/strong&gt; removes this possibility to get packet information from a stream socket. For comparision: it has existed in FreeBSD but is now removed, at least since FreeBSD 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9af6a987f2d3bf6639d97909039e3b4c47dc6a" translate="yes" xml:space="preserve">
          <source>This option augments the host name extraction from URIs and other Reference IDs. It could for example be a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of:</source>
          <target state="translated">这个选项增强了从URI和其他参考ID中提取主机名的功能。例如,它可以是一个非常特殊的、没有标准化的URI。这个选项将一个Reference ID作为参数,并返回以下参数之一:1:</target>
        </trans-unit>
        <trans-unit id="21da80d80de6786a8c35eb55211f1719f7ad6a3e" translate="yes" xml:space="preserve">
          <source>This option can also be used to override the default renaming of calls which use obsolete function names.</source>
          <target state="translated">这个选项也可以用来覆盖使用过时函数名的调用的默认重命名。</target>
        </trans-unit>
        <trans-unit id="cdb004a99221b3f8badd722205d40d87fd8410dc" translate="yes" xml:space="preserve">
          <source>This option can be used for adding members to a distributed disk log. Defaults to &lt;code&gt;[]&lt;/code&gt;, which means that the log is local on the current node.</source>
          <target state="translated">此选项可用于将成员添加到分布式磁盘日志中。默认为 &lt;code&gt;[]&lt;/code&gt; ，这意味着日志在当前节点上是本地的。</target>
        </trans-unit>
        <trans-unit id="23765e948e554b57ee502bc4f444d5a5c23a77a3" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon execute exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case but in the error case.</source>
          <target state="translated">这个选项改变了守护进程执行来自客户端的exec-request的方式。如果返回值中的术语是非字符串类型,则会被格式化为字符串。在ok-case中不加尾部的换行,但在错误的情况下会加。</target>
        </trans-unit>
        <trans-unit id="cf09fbce9857f3de6b83082c36031fa1a2e47db0" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon executes exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53106c8ee8480a565ca1694a5aee9779aed8d667" translate="yes" xml:space="preserve">
          <source>This option changes the representation of the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; to use maps (instead of records). This option also suppresses the generation of &lt;code&gt;.hrl&lt;/code&gt; files.</source>
          <target state="translated">此选项将 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 类型的表示形式更改为使用映射（而不是记录）。此选项还禁止生成 &lt;code&gt;.hrl&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="91dab051c90259277cd95566eff3cf880c2a9995" translate="yes" xml:space="preserve">
          <source>This option controls the debug level of &lt;code&gt;wx&lt;/code&gt;. As its name indicates it is only useful for debugging. See &lt;code&gt;wx:debug/1&lt;/code&gt; for more info.</source>
          <target state="translated">此选项控制 &lt;code&gt;wx&lt;/code&gt; 的调试级别。顾名思义，它仅对调试有用。有关更多信息，请参见 &lt;code&gt;wx:debug/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec5e0644c323d96923ea009ec73a058e3e14790" translate="yes" xml:space="preserve">
          <source>This option controls the error handling behavior of Reltool. By default the window processes traps exit, but this behavior can altered by setting &lt;code&gt;trap_exit&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此选项控制Reltool的错误处理行为。默认情况下，窗口进程陷阱退出，但是可以通过将 &lt;code&gt;trap_exit&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 来改变此行为。</target>
        </trans-unit>
        <trans-unit id="c7e73575c5bb05401f153a1b408d8ff447357a91" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;true&lt;/code&gt; for backwards compatibility but we intend to remove the exception behavior in a future release. New code that needs to handle dictionaries manually should always specify &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，此选项默认为 &lt;code&gt;true&lt;/code&gt; ，但是我们打算在以后的版本中删除异常行为。需要手动处理字典的新代码应始终指定 &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24e5307f642c6711e98aa1e1851a0012231dc221" translate="yes" xml:space="preserve">
          <source>This option defines how the manager will handle the sending of response (acknowledgment) to received inform-requests.</source>
          <target state="translated">这个选项定义了管理者如何处理对收到的信息请求的响应(确认)发送。</target>
        </trans-unit>
        <trans-unit id="0b065ec1d28b81abfd2469427265be5e95f2a102" translate="yes" xml:space="preserve">
          <source>This option determines which &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; are to be received (through &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;) along with the data. The only exception is &lt;code&gt;data_io_event&lt;/code&gt;, which enables or disables receiving of &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; ancillary data, not events. By default, all flags except &lt;code&gt;adaptation_layer_event&lt;/code&gt; are enabled, although &lt;code&gt;sctp_data_io_event&lt;/code&gt; and &lt;code&gt;association_event&lt;/code&gt; are used by the driver itself and not exported to the user level.</source>
          <target state="translated">此选项确定要通过数据接收哪些 &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; （通过 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; ）。唯一的例外是 &lt;code&gt;data_io_event&lt;/code&gt; ，它启用或禁用 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 辅助数据而非事件的接收。默认情况下，尽管 &lt;code&gt;sctp_data_io_event&lt;/code&gt; 和 &lt;code&gt;association_event&lt;/code&gt; 由驱动程序本身使用，并且未导出到用户级别，但启用了 &lt;code&gt;adaptation_layer_event&lt;/code&gt; 以外的所有标志。</target>
        </trans-unit>
        <trans-unit id="1f54c1964a5e915a3b9d8124e81def1141091a66" translate="yes" xml:space="preserve">
          <source>This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. &lt;code&gt;run/3&lt;/code&gt; always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</source>
          <target state="translated">就&amp;ldquo;长期运行的BIF&amp;rdquo;而言，此选项绝不会影响Erlang VM的执行。 &lt;code&gt;run/3&lt;/code&gt; 始终以一定的时间间隔将控制权交还给Erlang进程的调度程序，以确保Erlang系统的实时属性。</target>
        </trans-unit>
        <trans-unit id="6af47b199e89cf536046513882864286cab54688" translate="yes" xml:space="preserve">
          <source>This option does not guarantee exclusiveness on file systems not supporting &lt;code&gt;O_EXCL&lt;/code&gt; properly, such as NFS. Do not depend on this option unless you know that the file system supports it (in general, local file systems are safe).</source>
          <target state="translated">此选项不能保证在不正确支持 &lt;code&gt;O_EXCL&lt;/code&gt; 的文件系统（例如NFS）上的排他性。除非您知道文件系统支持此选项，否则不要依赖此选项（通常，本地文件系统是安全的）。</target>
        </trans-unit>
        <trans-unit id="170942e99acf8590a0f93f95af96a97ad9b43a74" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="translated">此选项指导 &lt;code&gt;connect&lt;/code&gt; 功能如何在所连接的服务器提供客户端之前从未见过的主机密钥时如何操作。默认设置是在stdio上向用户询问是否接受或拒绝新的主机密钥。请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; ,以指定记录以前接受的主机密钥的文件 &lt;code&gt;known_hosts&lt;/code&gt; 的路径。另请参阅选项 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 以了解处理密钥的一般方法。</target>
        </trans-unit>
        <trans-unit id="e49306537910a313e44ea71c528fe60f8dac74f8" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3735f5d136203b9a8fbbbce887101fdaa70466" translate="yes" xml:space="preserve">
          <source>This option handles padding in the last block. If not set, no padding is done and any bytes in the last unfilled block is silently discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f90278834c86b23c99e6715014b42f0de28741" translate="yes" xml:space="preserve">
          <source>This option has no effect when the function is given an I/O device instead of a file name. Use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;raw&lt;/code&gt; mode to obtain a file descriptor first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f681818b307476626695654e1f4af8954537ac9" translate="yes" xml:space="preserve">
          <source>This option implies option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">此选项暗含选项 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b7df27500f11cd0120772f370d99f496bc69623" translate="yes" xml:space="preserve">
          <source>This option indicates weather the request should be resent until the reply is received, &lt;strong&gt;even&lt;/strong&gt; though a pending message has been received.</source>
          <target state="translated">此选项指示&lt;strong&gt;即使&lt;/strong&gt;已收到未决消息，&lt;strong&gt;也&lt;/strong&gt;应重新发送请求，直到收到答复为止。</target>
        </trans-unit>
        <trans-unit id="6ee2dcf0c6730f63f33d0e9b597dde90cc7553c6" translate="yes" xml:space="preserve">
          <source>This option indicates weather the transport module should be told if a message send is a resend or not.</source>
          <target state="translated">这个选项表示是否应该告诉传输模块发送的消息是否为重发。</target>
        </trans-unit>
        <trans-unit id="f41d25f928d777038d78ec54aa87e0b2645ebe41" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; (in either order) results in 2 scheduler threads (50% of 4) and 1 scheduler thread online (25% of 4).</source>
          <target state="translated">此选项与 &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; 设置交互。例如，在配置了8个逻辑核心和8个可用逻辑核心的系统上，选项 &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; （以任意顺序）的组合产生2个调度程序线程（4个的50％）和1个在线调度程序线程（占25％）。</target>
        </trans-unit>
        <trans-unit id="f69d8c25bc614477e7fde4538f00fb8866b22040" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; (in either order) results in 2 dirty CPU scheduler threads (50% of 4) and 1 dirty CPU scheduler thread online (25% of 4).</source>
          <target state="translated">此选项与 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 设置交互。例如，在配置了8个逻辑核心和8个可用逻辑核心的系统上，选项 &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; （以任意顺序）的组合会导致2个脏CPU调度程序线程（4个的50％）和1个肮脏的CPU调度程序线程联机（占25％）。</target>
        </trans-unit>
        <trans-unit id="1b1652a93096a292ea9f23a8fb30440e0918cbec" translate="yes" xml:space="preserve">
          <source>This option is a fast way to test whether a module will compile successfully. This is useful for code generators that want to verify the code that they emit. No code is generated. If warnings are enabled, warnings generated by the &lt;code&gt;erl_lint&lt;/code&gt; module (such as warnings for unused variables and functions) are also returned.</source>
          <target state="translated">此选项是测试模块是否将成功编译的快速方法。这对于想要验证其发出的代码的代码生成器很有用。没有代码生成。如果启用了警告，则还会返回 &lt;code&gt;erl_lint&lt;/code&gt; 模块生成的警告（例如，未使用的变量和函数的警告）。</target>
        </trans-unit>
        <trans-unit id="0bc4c98f53e89f54019044a7876ab12f92896246" translate="yes" xml:space="preserve">
          <source>This option is experimental.</source>
          <target state="translated">这个选项是试验性的。</target>
        </trans-unit>
        <trans-unit id="bebef7a4d11a54b9572f9f20a10693f30204b1e4" translate="yes" xml:space="preserve">
          <source>This option is highly recommended. It makes &lt;code&gt;run_erl&lt;/code&gt; run in the background completely detached from any controlling terminal and the command returns to the caller immediately. Without this option, &lt;code&gt;run_erl&lt;/code&gt; must be started using several tricks in the shell to detach it completely from the terminal in use when starting it. The option must be the first argument to &lt;code&gt;run_erl&lt;/code&gt; on the command line.</source>
          <target state="translated">强烈建议使用此选项。它使 &lt;code&gt;run_erl&lt;/code&gt; 在后台运行，与任何控制终端完全脱离，命令立即返回到调用者。如果没有此选项， &lt;code&gt;run_erl&lt;/code&gt; 必须在外壳中使用几个技巧来启动run_erl，以便在启动时将其与正在使用的终端完全分离。该选项必须是命令行上 &lt;code&gt;run_erl&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="799c0d875ea63318c2c432ae65671fb00f9b1962" translate="yes" xml:space="preserve">
          <source>This option is more useful. Here, reloading is queued if the driver is &lt;strong&gt;not&lt;/strong&gt; loaded by any other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, but the driver has opened ports, in which case &lt;code&gt;{ok, pending_driver}&lt;/code&gt; is returned (a &lt;code&gt;monitor&lt;/code&gt; option is recommended).</source>
          <target state="translated">此选项更有用。在此，如果驱动程序&lt;strong&gt;未&lt;/strong&gt;由任何其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 加载，但驱动程序已打开端口，则重新加载将排队，在这种情况下 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 将返回{ok，ending_driver}（建议使用 &lt;code&gt;monitor&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="25d785f39f2ca30f9744131492e2e56cf2d21d95" translate="yes" xml:space="preserve">
          <source>This option is not allowed on &lt;code&gt;raw&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 文件上不允许使用此选项。</target>
        </trans-unit>
        <trans-unit id="66882999b7df0a61e482c56ef50205c317d913f0" translate="yes" xml:space="preserve">
          <source>This option is not normally supported (see why below). OTP has to be explicitly built with the &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; configure option for this to be available. Since our implementation is &lt;strong&gt;nonblocking&lt;/strong&gt;, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the &lt;code&gt;Timeout&lt;/code&gt; argument to, for instance, the &lt;code&gt;&lt;a href=&quot;socket#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f57200882dc1e247d7d39a885535f951742ea8" translate="yes" xml:space="preserve">
          <source>This option is not normally supported (see why below). OTP has to be explicitly built with the &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; configure option for this to be available. Since our implementation is &lt;strong&gt;nonblocking&lt;/strong&gt;, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the &lt;code&gt;Timeout&lt;/code&gt; argument to, for instance, the &lt;code&gt;&lt;a href=&quot;socket#send-3&quot;&gt;send/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f286491eda734e921e24014e8a8a1eb9199ffbe" translate="yes" xml:space="preserve">
          <source>This option is not recommended.</source>
          <target state="translated">不建议使用此选项。</target>
        </trans-unit>
        <trans-unit id="f578117bb772460a22238ad9cfabbec82d626246" translate="yes" xml:space="preserve">
          <source>This option is only meaningful if option &lt;code&gt;binary&lt;/code&gt; was specified when the socket was created. If option &lt;code&gt;header&lt;/code&gt; is specified, the first &lt;code&gt;Size&lt;/code&gt; number bytes of data received from the socket are elements of a list, and the remaining data is a binary specified as the tail of the same list. For example, if &lt;code&gt;Size == 2&lt;/code&gt;, the data received matches &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt;.</source>
          <target state="translated">仅当创建套接字时指定了 &lt;code&gt;binary&lt;/code&gt; 选项时，此选项才有意义。如果指定了选项 &lt;code&gt;header&lt;/code&gt; ，则从套接字接收的数据的第一个 &lt;code&gt;Size&lt;/code&gt; Number字节是列表的元素，其余数据是指定为同一列表尾部的二进制文件。例如，如果 &lt;code&gt;Size == 2&lt;/code&gt; ，则接收到的数据与 &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6aa3b24e42c5627fceb7d3a4c574f35704adb386" translate="yes" xml:space="preserve">
          <source>This option is only supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;).</source>
          <target state="translated">仅标准外壳程序（ &lt;code&gt;group.erl&lt;/code&gt; ）支持此选项。</target>
        </trans-unit>
        <trans-unit id="b072703d1b18dfc3f9f5977b6079b835f0224f83" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the parameters specific to the peer address specified by &lt;code&gt;address&lt;/code&gt; within the association specified by &lt;code&gt;assoc_id&lt;/code&gt;. Field &lt;code&gt;address&lt;/code&gt; fmust be set by the caller; all other fields are filled in on return. If &lt;code&gt;assoc_id = 0&lt;/code&gt; (default), the &lt;code&gt;address&lt;/code&gt; is automatically translated into the corresponding association ID. This option is rarely used. For the semantics of all fields, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此选项是只读的。它确定参数专用于由指定的网络节点地址 &lt;code&gt;address&lt;/code&gt; 所指定的关联内 &lt;code&gt;assoc_id&lt;/code&gt; 。现场 &lt;code&gt;address&lt;/code&gt; 必须由调用方设置；所有其他字段均在返回时填写。如果 &lt;code&gt;assoc_id = 0&lt;/code&gt; （默认值），该 &lt;code&gt;address&lt;/code&gt; 将自动转换为相应的关联ID。此选项很少使用。有关所有字段的语义，请参阅 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195222e570592e1300b4b25ab1af9e1c8e8e90bb" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the status of the SCTP association specified by &lt;code&gt;assoc_id&lt;/code&gt;. The following are the possible values of &lt;code&gt;state&lt;/code&gt; (the state designations are mostly self-explanatory):</source>
          <target state="translated">此选项是只读的。它确定由 &lt;code&gt;assoc_id&lt;/code&gt; 指定的SCTP关联的状态。以下是 &lt;code&gt;state&lt;/code&gt; 的可能值（状态名称大多是不言而喻的）：</target>
        </trans-unit>
        <trans-unit id="2a7c2f54502986cac56e74f74f0507e617134fa9" translate="yes" xml:space="preserve">
          <source>This option is removed, it generates a fatal error if used.</source>
          <target state="translated">此选项已被删除,如果使用会产生致命的错误。</target>
        </trans-unit>
        <trans-unit id="0d0dc8c0d9bb7eab4181aa210080e8a3266e279c" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">默认情况下，此选项设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa903c4555e4c89c59fa07465d374edfda939a99" translate="yes" xml:space="preserve">
          <source>This option is supported by TLS 1.3 and above and only with stateless session tickets. Ticket lifetime, the number of tickets sent by the server and the maximum number of tickets stored by the server in stateful mode are configured by &lt;code&gt;application variables&lt;/code&gt;. See also &lt;code&gt; SSL's Users Guide, Anti-Replay Protection in TLS 1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e6a186e299c39a9ea4c11bb023a5500cff5bee" translate="yes" xml:space="preserve">
          <source>This option is supported by TLS 1.3 and above. See also &lt;code&gt; SSL's Users Guide, Session Tickets and Session Resumption in TLS 1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0aa3e98f799062b3c35a4a811d03b341b1e599" translate="yes" xml:space="preserve">
          <source>This option is supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;), the 'oldshell' (&lt;code&gt;user.erl&lt;/code&gt;), and the file I/O servers.</source>
          <target state="translated">标准外壳程序（ &lt;code&gt;group.erl&lt;/code&gt; ），&amp;ldquo;旧外壳程序&amp;rdquo;（ &lt;code&gt;user.erl&lt;/code&gt; ）和文件I / O服务器均支持此选项。</target>
        </trans-unit>
        <trans-unit id="b3a3a12611755048747534c6172534fba6193da6" translate="yes" xml:space="preserve">
          <source>This option is to be used only while running &lt;code&gt;erts_alloc_config(3)&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt; when using the created configuration.</source>
          <target state="translated">此选项仅在运行 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 时使用，&lt;strong&gt;而&lt;/strong&gt;在使用创建的配置时&lt;strong&gt;不可&lt;/strong&gt;用。</target>
        </trans-unit>
        <trans-unit id="889aee4f7fdaed4924ebd813f97d33cc589d7043" translate="yes" xml:space="preserve">
          <source>This option is typically used when building or modifying a PLT as in:</source>
          <target state="translated">该选项通常在构建或修改PLT时使用,如:。</target>
        </trans-unit>
        <trans-unit id="edf2a03815bd1d16fe28550db84f5fb84528060e" translate="yes" xml:space="preserve">
          <source>This option is used to &lt;strong&gt;reload&lt;/strong&gt; a driver from disk, most often in a code upgrade scenario. Having a &lt;code&gt;reload&lt;/code&gt; option also implies that parameter &lt;code&gt;Path&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; need to be consistent with earlier loads of the driver.</source>
          <target state="translated">此选项通常在代码升级方案中用于从磁盘&lt;strong&gt;重新加载&lt;/strong&gt;驱动程序。有一个 &lt;code&gt;reload&lt;/code&gt; 选项也意味着参数 &lt;code&gt;Path&lt;/code&gt; 并&lt;strong&gt;没有&lt;/strong&gt;需要与驱动程序的早期负荷相一致。</target>
        </trans-unit>
        <trans-unit id="cf140f37714af5051b513ac4d8ca12c2978c9cf5" translate="yes" xml:space="preserve">
          <source>This option only affects decentralized counters used for the counters that are keeping track of the memory consumption and the number of terms in ETS tables of type ordered_set with the write_concurrency option activated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51f4b2d1bb2d48353207aa92dd60bc3873e9f8f" translate="yes" xml:space="preserve">
          <source>This option should be set to &lt;code&gt;false&lt;/code&gt; since a sufficiently malicious peer can otherwise cause large amounts of memory to be consumed when decoded Diameter messages are passed between processes. The default value is for backwards compatibility.</source>
          <target state="translated">此选项应设置为 &lt;code&gt;false&lt;/code&gt; ,因为当在进程之间传递解码的Diameter消息时，足够恶意的对等方可能导致消耗大量内存。默认值为向后兼容。</target>
        </trans-unit>
        <trans-unit id="57817b80cdc930329e3a4d5793e370393a3211f0" translate="yes" xml:space="preserve">
          <source>This option specifies how basic mib data is stored. This option is used by two parts of the snmp agent: The mib-server and the symbolic-store.</source>
          <target state="translated">这个选项指定了基本mib数据的存储方式。这个选项被snmp代理的两个部分使用。mib服务器和符号存储。</target>
        </trans-unit>
        <trans-unit id="058b954e4120837a0a6cb03a7efdf187ce8adda6" translate="yes" xml:space="preserve">
          <source>This option specifies how the server will handle callback calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bffdd8047471540c8529b9376dd26910c55b7e" translate="yes" xml:space="preserve">
          <source>This option specifies if the server should actively supervise the net-if process. Note that this will only work if the used net-if process actually supports the protocol. See &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; behaviour for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5c27e867a6f1798699a8d8412847ef2c9f83ca" translate="yes" xml:space="preserve">
          <source>This option specifies if the user shall be notified of received segment replies or not.</source>
          <target state="translated">这个选项指定了是否要将收到的分段回复通知用户。</target>
        </trans-unit>
        <trans-unit id="e191bd75bc4b33a8992d72798fec2d5cb030668d" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific socket option &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt;, such as in Linux kernel 2.0.30 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">此选项使用特定于Linux的套接字选项 &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt; ，例如在Linux内核2.0.30或更高版本中，因此仅在针对此类操作系统编译运行时系统时才存在。</target>
        </trans-unit>
        <trans-unit id="2b531690e0f1058c69b2d245e35526e30090198c" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific syscall &lt;code&gt;setns()&lt;/code&gt;, such as in Linux kernel 3.0 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">此选项使用特定于Linux的syscall &lt;code&gt;setns()&lt;/code&gt; （例如在Linux内核3.0或更高版本中），因此仅在针对此类操作系统编译运行时系统时才存在。</target>
        </trans-unit>
        <trans-unit id="44252bdcc3d79897b51179b686a1c2db9495ee64" translate="yes" xml:space="preserve">
          <source>This option will be removed in a future release. The return value will always be &lt;code&gt;false&lt;/code&gt;, as the &lt;code&gt;elib_malloc&lt;/code&gt; allocator has been removed.</source>
          <target state="translated">此选项将在以后的版本中删除。返回值将始终为 &lt;code&gt;false&lt;/code&gt; ，因为 &lt;code&gt;elib_malloc&lt;/code&gt; 分配器已被删除。</target>
        </trans-unit>
        <trans-unit id="c0dabdcd13ff03271c7b6e7a946847dbd231dc01" translate="yes" xml:space="preserve">
          <source>This option will use a lot of memory when enabled, which must be reclaimed with &lt;code&gt;lcnt:rt_clear&lt;/code&gt;. Note that it makes no distinction between locks that were destroyed and locks for which counting was disabled, so enabling this option will disable changes to the lock category mask.</source>
          <target state="translated">启用此选项将占用大量内存，必须使用 &lt;code&gt;lcnt:rt_clear&lt;/code&gt; 进行回收。请注意，它在已销毁的锁和禁用计数的锁之间没有区别，因此启用此选项将禁用对锁类别掩码的更改。</target>
        </trans-unit>
        <trans-unit id="63372d9f26162432c70de9dd21cb0a2fa14e443c" translate="yes" xml:space="preserve">
          <source>This package contains modules for handling abstract syntax trees (ASTs) in Erlang, in a way that is compatible with the &quot;abstract format&quot; parse trees of the stdlib module &lt;code&gt;erl_parse&lt;/code&gt;, together with utilities for reading source files, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt;, and doing &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; in Erlang.</source>
          <target state="translated">此软件包包含用于处理Erlang中的抽象语法树（AST）的模块，该模块与stdlib模块 &lt;code&gt;erl_parse&lt;/code&gt; 的&amp;ldquo;抽象格式&amp;rdquo;解析树兼容，并且具有读取源文件的实用工具， &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt; ，并在Erlang中进行 &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa90d46e1988deecd458f84f25660e5efaeb6ec" translate="yes" xml:space="preserve">
          <source>This page presents a summary of values from all allocators underneath it.</source>
          <target state="translated">本页呈现的是其下所有分配器的数值汇总。</target>
        </trans-unit>
        <trans-unit id="239f6919f70832c0fd44ac0346db01f8572c3052" translate="yes" xml:space="preserve">
          <source>This pair of functions are used when open ports to the driver are to be killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; to allow for new driver code to get loaded.</source>
          <target state="translated">当使用 &lt;code&gt;driver_unloaded&lt;/code&gt; 原因终止驱动程序的开放端口以允许加载新的驱动程序代码时，将使用此功能对。</target>
        </trans-unit>
        <trans-unit id="1602bf3b2d8c23237b0a61febcf52e3e006d8036" translate="yes" xml:space="preserve">
          <source>This pair of functions is used when reloading is to be done after the last open port to the driver is closed.</source>
          <target state="translated">这对函数是在最后一个打开的驱动端口关闭后进行重装时使用的。</target>
        </trans-unit>
        <trans-unit id="f14b771e39c5dc99621a28cd9cae451233b4cbb8" translate="yes" xml:space="preserve">
          <source>This parameter contains a list of options that are given to &lt;code&gt;zip:create/3&lt;/code&gt; when application specific files are packaged into an archive. Only a subset of the options are supported. The most useful options in this context are the ones that control which types of files should be compressed. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">当将特定于应用程序的文件打包到归档文件中时，此参数包含 &lt;code&gt;zip:create/3&lt;/code&gt; 的选项列表。仅支持选项的子集。在这种情况下，最有用的选项是控制应压缩哪种类型的文件的选项。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e5c112e068eb199424c98749e9d0931666cadb" translate="yes" xml:space="preserve">
          <source>This parameter controls the application and escript inclusion policy. It defaults to &lt;code&gt;derived&lt;/code&gt; which means that the applications that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting, will only be included if any other (explicitly or implicitly included) application uses it. The value &lt;code&gt;include&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be included. &lt;code&gt;exclude&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be excluded.</source>
          <target state="translated">此参数控制应用程序和脚本包含策略。它默认为 &lt;code&gt;derived&lt;/code&gt; ，这意味着没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序仅在任何其他（显式或隐式包含）应用程序使用它的情况下才包括在内。该值 &lt;code&gt;include&lt;/code&gt; 表示将包括所有没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序和脚本。 &lt;code&gt;exclude&lt;/code&gt; 表示将排除所有没有任何明确的 &lt;code&gt;incl_cond&lt;/code&gt; 设置的应用程序和脚本。</target>
        </trans-unit>
        <trans-unit id="43b8b48e3d3e4e5f584a2110e61fc94f1dda52fb" translate="yes" xml:space="preserve">
          <source>This parameter controls the default handling of the &lt;code&gt;app&lt;/code&gt; files when a target system is generated. It defaults to &lt;code&gt;keep&lt;/code&gt; which means that &lt;code&gt;app&lt;/code&gt; files are copied to the target system and their contents are kept as they are. &lt;code&gt;strip&lt;/code&gt; means that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file where the non included modules are removed from the file. &lt;code&gt;all&lt;/code&gt; does also imply that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file, with the difference that all included modules are added to the file. If the application does not have any &lt;code&gt;app&lt;/code&gt; file a file will be created for &lt;code&gt;all&lt;/code&gt; but not for &lt;code&gt;keep&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;.</source>
          <target state="translated">生成目标系统时，此参数控制 &lt;code&gt;app&lt;/code&gt; 文件的默认处理。默认设置为 &lt;code&gt;keep&lt;/code&gt; ，这意味着将 &lt;code&gt;app&lt;/code&gt; 文件复制到目标系统，并将其内容保持原样。 &lt;code&gt;strip&lt;/code&gt; 表示从原始 &lt;code&gt;app&lt;/code&gt; 文件的内容生成了一个新的 &lt;code&gt;app&lt;/code&gt; 程序文件，其中未包含的模块已从文件中删除。 &lt;code&gt;all&lt;/code&gt; 均表示从原始 &lt;code&gt;app&lt;/code&gt; 文件的内容生成了一个新的 &lt;code&gt;app&lt;/code&gt; 程序文件，不同之处在于所有包含的模块均已添加到该文件中。如果该应用程序没有任何 &lt;code&gt;app&lt;/code&gt; 将为 &lt;code&gt;all&lt;/code&gt; 文件创建文件，但不会为 &lt;code&gt;keep&lt;/code&gt; 和 &lt;code&gt;strip&lt;/code&gt; 创建文件。</target>
        </trans-unit>
        <trans-unit id="178517341ccd2e5776c2cccf896941a880130c85" translate="yes" xml:space="preserve">
          <source>This parameter controls the module inclusion policy. It defaults to &lt;code&gt;all&lt;/code&gt; which means that if an application is included (either explicitly or implicitly) all modules in that application will be included. This implies that both modules that exist in the &lt;code&gt;ebin&lt;/code&gt; directory of the application, as well as modules that are named in the &lt;code&gt;app&lt;/code&gt; file will be included. If the parameter is set to &lt;code&gt;ebin&lt;/code&gt;, both modules in the &lt;code&gt;ebin&lt;/code&gt; directory and derived modules are included. If the parameter is set to &lt;code&gt;app&lt;/code&gt;, both modules in the &lt;code&gt;app&lt;/code&gt; file and derived modules are included. &lt;code&gt;derived&lt;/code&gt; means that only modules that are used by other included modules are included. The &lt;code&gt;mod_cond&lt;/code&gt; setting on system level is used as default for all applications.</source>
          <target state="translated">此参数控制模块包含策略。它默认为 &lt;code&gt;all&lt;/code&gt; ，这意味着，如果包含（显式或隐式）应用程序，则将包含该应用程序中的所有模块。这意味着将同时包含应用程序的 &lt;code&gt;ebin&lt;/code&gt; 目录中存在的两个模块以及 &lt;code&gt;app&lt;/code&gt; 文件中命名的模块。如果参数设置为 &lt;code&gt;ebin&lt;/code&gt; ，则将同时包含 &lt;code&gt;ebin&lt;/code&gt; 目录中的模块和派生模块。如果参数设置为 &lt;code&gt;app&lt;/code&gt; ，则将同时包含 &lt;code&gt;app&lt;/code&gt; 文件中的模块和派生模块。 &lt;code&gt;derived&lt;/code&gt; 表示仅包含其他随附模块使用的模块。系统级别的 &lt;code&gt;mod_cond&lt;/code&gt; 设置用作所有应用程序的默认设置。</target>
        </trans-unit>
        <trans-unit id="f35dbde0b2e6b7417fe1079d2c8cb135463fb518" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the &lt;code&gt;erl&lt;/code&gt; executable in the target system should automatically determine where it is installed or if it should use a hardcoded path to the installation. In the latter case the target system must be installed with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be used. If the system is relocatable, the file tree containing the target system can be moved to another location without re-installation. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此参数控制目标系统中的 &lt;code&gt;erl&lt;/code&gt; 可执行文件是否应自动确定其安装位置，或者是否应使用安装的硬编码路径。在后一种情况下，必须先使用 &lt;code&gt;reltool:install/2&lt;/code&gt; 来安装目标系统，然后才能使用它。如果系统可重定位，则可以将包含目标系统的文件树移动到另一个位置，而无需重新安装。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18eec3d4c813ec5a22514b8e2727f74034894ae8" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the module is included or not. By default the &lt;code&gt;mod_cond&lt;/code&gt; parameter on application and system level will be used to control whether the module is included or not. The value of &lt;code&gt;incl_cond&lt;/code&gt; overrides the module inclusion policy. &lt;code&gt;include&lt;/code&gt; implies that the module is included, while &lt;code&gt;exclude&lt;/code&gt; implies that the module is not included. &lt;code&gt;derived&lt;/code&gt; implies that the module is included if it is used by any other included module.</source>
          <target state="translated">此参数控制是否包含模块。默认情况下，应用程序和系统级别的 &lt;code&gt;mod_cond&lt;/code&gt; 参数将用于控制是否包含该模块。 &lt;code&gt;incl_cond&lt;/code&gt; 的值将覆盖模块包含策略。 &lt;code&gt;include&lt;/code&gt; 表示包含该模块，而 &lt;code&gt;exclude&lt;/code&gt; 表示不包含该模块。 &lt;code&gt;derived&lt;/code&gt; 表示如果该模块被任何其他包含的模块使用，则包含该模块。</target>
        </trans-unit>
        <trans-unit id="40145ab28fcdbc933f15879eca2c3243c28ec539" translate="yes" xml:space="preserve">
          <source>This parameter defines the error report type used when messages are sent to error logger using the default callback function. Default is &lt;code&gt;std_error&lt;/code&gt;, which means the events are handled by the standard event handler.</source>
          <target state="translated">此参数定义使用默认的回调函数将消息发送到错误记录器时使用的错误报告类型。默认值为 &lt;code&gt;std_error&lt;/code&gt; ，这意味着事件由标准事件处理程序处理。</target>
        </trans-unit>
        <trans-unit id="d8e1e13f6286b2183d8789f9f0f1c181e848b5c7" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;lib_dir&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">此参数与 &lt;code&gt;lib_dir&lt;/code&gt; 互斥。如果 &lt;code&gt;vsn&lt;/code&gt; 和 &lt;code&gt;lib_dir&lt;/code&gt; 都被省略，则将选择最新版本。</target>
        </trans-unit>
        <trans-unit id="e97c191330c9143719f39676fbf0d64a524888a9" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;vsn&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">该参数与 &lt;code&gt;vsn&lt;/code&gt; 互斥。如果 &lt;code&gt;vsn&lt;/code&gt; 和 &lt;code&gt;lib_dir&lt;/code&gt; 都被省略，则将选择最新版本。</target>
        </trans-unit>
        <trans-unit id="fccea6e9894e7980e5b72b89472e98f04ef2c3ca" translate="yes" xml:space="preserve">
          <source>This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">此参数的类型为 &lt;code&gt;dateTime&lt;/code&gt; ,并符合RFC3339。实现必须支持时区。</target>
        </trans-unit>
        <trans-unit id="950fdba8a7f8faa27a2238104e4fbd9416d168d5" translate="yes" xml:space="preserve">
          <source>This parameter is the name of the driver to be used in subsequent calls to function &lt;code&gt;erlang:open_port&lt;/code&gt; in ERTS. The name can be specified as an &lt;code&gt;iolist()&lt;/code&gt; or an &lt;code&gt;atom()&lt;/code&gt;. The name specified when loading is used to find the object file (with the help of &lt;code&gt;Path&lt;/code&gt; and the system-implied extension suffix, that is, &lt;code&gt;.so&lt;/code&gt;). The name by which the driver identifies itself must also be consistent with this &lt;code&gt;Name&lt;/code&gt; parameter, much as the module name of a Beam file much corresponds to its filename.</source>
          <target state="translated">此参数是在ERTS中对函数 &lt;code&gt;erlang:open_port&lt;/code&gt; 的后续调用中使用的驱动程序的名称。该名称可以指定为 &lt;code&gt;iolist()&lt;/code&gt; 或 &lt;code&gt;atom()&lt;/code&gt; 。加载时指定的名称用于查找目标文件（借助于 &lt;code&gt;Path&lt;/code&gt; 和系统隐含的扩展名后缀 &lt;code&gt;.so&lt;/code&gt; ）。驱动程序用来标识自身的 &lt;code&gt;Name&lt;/code&gt; 也必须与此Name参数保持一致，就像Beam文件的模块名称与其文件名非常对应一样。</target>
        </trans-unit>
        <trans-unit id="44b3acd62887c89fa3ae2ebe622fc74f4ca003b3" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_app_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制哪些特定于应用程序的文件不应包含在目标系统中。在被列入秩序，文件必须以某种过滤器匹配 &lt;code&gt;incl_app_filters&lt;/code&gt; 但不是在任何过滤 &lt;code&gt;excl_app_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f82af56ab8d93da6eddb3eddde55461bf95b47f" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files that should be included. Each file in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应包含哪些应用程序特定文件。应用程序中的每个文件必须至少匹配列出的正则表达式之一才能被包含。此外，文件可能不匹配 &lt;code&gt;excl_app_filters&lt;/code&gt; 中的任何过滤器，以便被包含。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a274c6a75bab058057d8bad1dd9c6f7fc4d783d1" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should be included. Each file in the target system must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt; in order to be included. Which application files should be included is controlled with the parameters &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应在系统中包括哪些文件。目标系统中的每个文件必须至少与列出的正则表达式之一匹配才能被包含。此外，这些文件可能不匹配 &lt;code&gt;excl_sys_filters&lt;/code&gt; 中的任何过滤器以便被包含。应使用参数 &lt;code&gt;incl_app_filters&lt;/code&gt; 和 &lt;code&gt;excl_app_filters&lt;/code&gt; 控制应包含哪些应用程序文件。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="110f1ed95034cf6ba82c260c7d3422382ccf8b06" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_sys_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制系统中的哪些文件不应包含在目标系统中。为了被包含，文件必须与 &lt;code&gt;incl_sys_filters&lt;/code&gt; 中的某些过滤器匹配，但与excl_sys_filters中的任何过滤器 &lt;code&gt;excl_sys_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff17bba9924b137232a805ed2fc26cbf5b146168" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should be included in an archive file (as opposed to being included as a regular directory outside the archive). Each top directory in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制应将应用程序中的哪些顶级目录包含在存档文件中（而不是作为存档外部的常规目录包含在内）。应用程序中的每个顶级目录必须至少匹配列出的正则表达式之一才能被包含。此外，文件可能不匹配 &lt;code&gt;excl_app_filters&lt;/code&gt; 中的任何过滤器，以便被包含。此参数默认为 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cccf208765941cdf1852be703e61e2a97e335ee" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should not be included in an archive file. In order to be included in the application archive, a top directory must match some filter in &lt;code&gt;incl_archive_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_archive_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt;.</source>
          <target state="translated">此参数通常包含一个正则表达式列表，这些正则表达式控制不应将应用程序中的哪些顶级目录包含在归档文件中。为了包含在应用程序归档中，顶层目录必须与 &lt;code&gt;incl_archive_filters&lt;/code&gt; 中的某些过滤器匹配，但与excl_archive_filters中的任何过滤器都 &lt;code&gt;excl_archive_filters&lt;/code&gt; 。此参数默认为 &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28343ed29b2c1e141aa76f8b0c8cab09dcd45849" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the Erlang emulator is statically installed at the client node. A node with a static emulator cannot dynamically switch to a new emulator, as the executable files are statically written into memory.</source>
          <target state="translated">这个参数指定了客户端节点是否静态安装了Erlang模拟器,静态安装的节点不能动态切换到新的模拟器,因为可执行文件是静态写入内存的。使用静态仿真器的节点不能动态切换到新的仿真器,因为可执行文件是静态写入内存的。</target>
        </trans-unit>
        <trans-unit id="755487bd7f381a96e683a265b03a5e040919d127" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the log file should be rotated or not. The value &lt;code&gt;infinity&lt;/code&gt; means the log file will grow indefinitely, while an integer value specifies at which file size (bytes) the file is rotated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df65b46110e980f8fa356aae1f4cdb59fbe6f4f" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the rotated log file archives shall be compressed or not. If set to &lt;code&gt;true&lt;/code&gt;, all archives are compressed with &lt;code&gt;gzip&lt;/code&gt;, and renamed to &lt;code&gt;FileName.N.gz&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a315afc7296583223ac7e17b44b0708aad5cc71" translate="yes" xml:space="preserve">
          <source>This parameter specifies the number of rotated log file archives to keep. This has meaning only if &lt;code&gt;&lt;a href=&quot;#max_no_bytes&quot;&gt;max_no_bytes&lt;/a&gt;&lt;/code&gt; is set to an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e064a3cd06dea7253b5c26ccbc32ee1140753f4" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt; Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50377640826220d17a47ef2e3ec41045600adb8" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这部分是在目标节点上完成的，对于本示例，我们希望该节点作为带有 &lt;code&gt;-heart&lt;/code&gt; 选项的嵌入式系统运行，从而允许节点的自动重启。有关更多信息，请参阅 &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bac7f8bcb72cbf602859c2bbd2ca1accde6e195" translate="yes" xml:space="preserve">
          <source>This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to</source>
          <target state="translated">我们所研究的这个特殊的示例模式包含了嵌套的无限重复,因此,当将该模式应用于不匹配的字符串时,使用占有式量化符来匹配非亲属的字符串是很重要的。例如,当该模式应用于</target>
        </trans-unit>
        <trans-unit id="cafdded1913809a983e1e03ea48bb5d4d797a73a" translate="yes" xml:space="preserve">
          <source>This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split.</source>
          <target state="translated">这个特殊的组符合两个字符序列CR和LF,或者单字符LF(换行,U+000A)、VT(垂直制表符,U+000B)、FF(换行,U+000C)、CR(回车,U+000D)或NEL(下一行,U+0085)中的一个。两个字符的序列被视为一个单元,不能分割。</target>
        </trans-unit>
        <trans-unit id="a1fd9cfe743405ab50e9a660ad376f4821d6a0dd" translate="yes" xml:space="preserve">
          <source>This particular server probably does not use heap memory worth hibernating for. To gain anything from hibernation, your server would have to produce non-insignificant garbage during callback execution, for which this example server can serve as a bad example.</source>
          <target state="translated">这个特定的服务器可能没有使用值得休眠的堆内存。要想从休眠中获得任何好处,你的服务器必须在回调执行过程中产生非重要的垃圾,对此,这个例子服务器可以作为一个糟糕的例子。</target>
        </trans-unit>
        <trans-unit id="dff69f09f8373963a046e44d87eb56b39d18544d" translate="yes" xml:space="preserve">
          <source>This pattern matches &lt;code&gt;a\nb&lt;/code&gt;, as LF is no longer a newline. If more than one of them is present, the last one is used.</source>
          <target state="translated">该模式与 &lt;code&gt;a\nb&lt;/code&gt; 匹配，因为LF不再是换行符。如果存在不止一个，则使用最后一个。</target>
        </trans-unit>
        <trans-unit id="426d65d492f0b3f8687db736206883352d79afcb" translate="yes" xml:space="preserve">
          <source>This pattern will match if the operands for &lt;code&gt;move&lt;/code&gt; are the same. If the pattern match, the instruction will be removed. (That used to be an actual rule a long time ago when the compiler would occasionally produce instructions such as &lt;code&gt;{move,{x,2},{x,2}}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f2d1b249ea341993b06eb398c25dbdc1e0f0e5" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt; erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f3552b260ce80c8512e7857145bb94d23327e2" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="translated">当用户通过调用 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt; 最终确定时间偏移时，此阶段开始。最终确定只能执行一次。</target>
        </trans-unit>
        <trans-unit id="ac25d4a9fb597e683c9984270c084780c2dc2975" translate="yes" xml:space="preserve">
          <source>This phase starts when the runtime system starts. A preliminary time offset based on current OS system time is determined. This offset is from now on to be fixed during the whole preliminary phase.</source>
          <target state="translated">这个阶段在运行时系统启动时开始。根据当前操作系统的系统时间确定一个初步的时间偏移。从现在起,这个偏移量在整个初始阶段都是固定的。</target>
        </trans-unit>
        <trans-unit id="a659cf785f049a86d756b9c813aaeb6a80c02b1c" translate="yes" xml:space="preserve">
          <source>This port is to represent the result of an accept operation. It is created when one wants to accept from a listen socket, and it is converted to a &lt;code&gt;portTypeCommand&lt;/code&gt; when the accept succeeds.</source>
          <target state="translated">此端口代表接受操作的结果。当一个人想从监听套接字接受时创建它，当接受成功时它被转换成 &lt;code&gt;portTypeCommand&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d46acb6abe2d76532e14cb270ed2c145b67edbb" translate="yes" xml:space="preserve">
          <source>This prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures, such as process identifiers, refs, and funs), and creation of new external function references. None of those resources are garbage collected, so unchecked creation of them can exhaust available memory.</source>
          <target state="translated">这可以防止直接创建新的原子,间接创建新的原子(因为它们被嵌入到某些结构中,如进程标识符、refs和funs),以及创建新的外部函数引用。这些资源都不是垃圾回收的,所以不加控制地创建它们会耗尽可用的内存。</target>
        </trans-unit>
        <trans-unit id="161ffdf8aa7fe91e902cf0c46062cf3c8c9ce913" translate="yes" xml:space="preserve">
          <source>This problem does not exist if all nodes are Erlang nodes.</source>
          <target state="translated">如果所有节点都是Erlang节点,这个问题就不存在。</target>
        </trans-unit>
        <trans-unit id="970e9bfda49ef81fc9970f5d3a17505b795bc146" translate="yes" xml:space="preserve">
          <source>This problem is best solved by using Mnesia instead.</source>
          <target state="translated">这个问题最好用Mnesia来代替解决。</target>
        </trans-unit>
        <trans-unit id="0b478a2b86cabc9871e0e9c3bdbf7e7c1549913b" translate="yes" xml:space="preserve">
          <source>This procedure differs from how it worked prior to Erlang/OTP 19.0. Before 19.0, only a contiguous memory block where the young heap and stack resided was considered to be part of the young heap. Heap fragments and messages were immediately copied into the young heap before they could be inspected by the Erlang program. The behaviour introduced in 19.0 is superior in many ways - most significantly it reduces the number of necessary copy operations and the root set for garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c05999f98fd47b44ec0f00834f055638c5316ef" translate="yes" xml:space="preserve">
          <source>This process cannot run in multiple instances on the same hardware. OS_Mon must be configured to start &lt;code&gt;os_sup&lt;/code&gt; on one node only if two or more Erlang nodes execute on the same machine.</source>
          <target state="translated">此过程无法在同一硬件上的多个实例中运行。仅当两个或多个Erlang节点在同一台计算机上执行时，才必须将OS_Mon配置为在一个节点上启动 &lt;code&gt;os_sup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb9e5caa10f9724817c37ffd6b5d433a1304dd3" translate="yes" xml:space="preserve">
          <source>This process executes &lt;code&gt;tut15:pong()&lt;/code&gt;. &lt;code&gt;Pong_PID&lt;/code&gt; is the process identity of the &quot;pong&quot; process. The function &lt;code&gt;start&lt;/code&gt; now creates another process &quot;ping&quot;:</source>
          <target state="translated">该过程执行 &lt;code&gt;tut15:pong()&lt;/code&gt; 。 &lt;code&gt;Pong_PID&lt;/code&gt; 是&amp;ldquo; pong&amp;rdquo;进程的进程标识。现在，该函数 &lt;code&gt;start&lt;/code&gt; 会创建另一个进程&amp;ldquo; ping&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="54ffc50690eb1a1de62954626b5c9e0167a4eba5" translate="yes" xml:space="preserve">
          <source>This process executes:</source>
          <target state="translated">这个过程的执行。</target>
        </trans-unit>
        <trans-unit id="327419876abc14c730314a0010b944c17b63d4fa" translate="yes" xml:space="preserve">
          <source>This program aids release handling on Windows systems. The program is to be called by the &lt;code&gt;erlsrv&lt;/code&gt; program, read up the release data file &lt;code&gt;start_erl.data&lt;/code&gt;, and start Erlang. Some options to &lt;code&gt;start_erl&lt;/code&gt; are added and removed by the release handler during upgrade with emulator restart (more specifically option &lt;code&gt;-data&lt;/code&gt;).</source>
          <target state="translated">该程序有助于Windows系统上的发行处理。该程序将由 &lt;code&gt;erlsrv&lt;/code&gt; 程序调用，读取发布数据文件 &lt;code&gt;start_erl.data&lt;/code&gt; ，然后启动Erlang。在模拟器重新启动的升级过程中，释放处理程序会添加和删除 &lt;code&gt;start_erl&lt;/code&gt; 的某些选项（更具体地说，选项 &lt;code&gt;-data&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="670a2482a63126e58239dc332359f8bc1dff0e73" translate="yes" xml:space="preserve">
          <source>This program is called when the machine is started. It can be modified or rewritten to suit a special system. By default, it must be called &lt;code&gt;start&lt;/code&gt; and reside in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. Another start program can be used, by using configuration parameter &lt;code&gt;start_prg&lt;/code&gt; in application SASL.</source>
          <target state="translated">机器启动时将调用该程序。可以对其进行修改或重写以适合特定的系统。默认情况下，它必须称为 &lt;code&gt;start&lt;/code&gt; 并驻留在 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 中。通过在应用程序SASL中使用配置参数 &lt;code&gt;start_prg&lt;/code&gt; ，可以使用另一个启动程序。</target>
        </trans-unit>
        <trans-unit id="4747c1263fbc28b515ca78f638cbd9259a9eb523" translate="yes" xml:space="preserve">
          <source>This program is distributed both in compiled form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\bin) and in source form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\src). The purpose of the source code is to ease customization of the program for local needs, such as cyclic restart detection. There is also a &quot;make&quot;-file, written for the &lt;code&gt;nmake&lt;/code&gt; program distributed with Microsoft Visual C++. This program can, however, be compiled with any Win32 C compiler (possibly with minor modifications).</source>
          <target state="translated">该程序以编译形式（在&amp;lt;Erlang根目录&amp;gt; \\ erts- &amp;lt;版本&amp;gt; \\ bin下）和源代码形式（在&amp;lt;Erlang根目录&amp;gt; \\ erts- &amp;lt;版本&amp;gt; \\ src下）分发。源代码的目的是简化针对本地需求（例如循环重启检测）的程序自定义。还有一个&amp;ldquo; make&amp;rdquo;文件，是为与Microsoft Visual C ++一起分发的 &lt;code&gt;nmake&lt;/code&gt; 程序编写的。但是，该程序可以使用任何Win32 C编译器进行编译（可能需要进行较小的修改）。</target>
        </trans-unit>
        <trans-unit id="5fbfadc49450aec422c508001aa868916550a963" translate="yes" xml:space="preserve">
          <source>This program is to set static parameters and environment variables such as &lt;code&gt;-sname Name&lt;/code&gt; and &lt;code&gt;HEART_COMMAND&lt;/code&gt; to reboot the machine.</source>
          <target state="translated">该程序用于设置静态参数和环境变量（例如 &lt;code&gt;-sname Name&lt;/code&gt; 和 &lt;code&gt;HEART_COMMAND&lt;/code&gt; )以重新引导计算机。</target>
        </trans-unit>
        <trans-unit id="c3f3c1fffec91449fdead388f394beeb915ca247" translate="yes" xml:space="preserve">
          <source>This program is used to attach to a running Erlang runtime system, started with &lt;code&gt;run_erl&lt;/code&gt;.</source>
          <target state="translated">该程序用于附加到以 &lt;code&gt;run_erl&lt;/code&gt; 开头的正在运行的Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="1f003599afc35a270db5f4b7d7b284e4c9e32aee" translate="yes" xml:space="preserve">
          <source>This program is used to start the emulator, but you will not be connected to the shell. &lt;code&gt;to_erl&lt;/code&gt; is used to connect to the Erlang shell.</source>
          <target state="translated">该程序用于启动仿真器，但您不会连接到外壳。 &lt;code&gt;to_erl&lt;/code&gt; 用于连接到Erlang shell。</target>
        </trans-unit>
        <trans-unit id="6687161d9309502a24c4f52312cb9d9b40349c81" translate="yes" xml:space="preserve">
          <source>This program starts the Erlang emulator with parameters &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; set. It reads data about where these files are located from a file named &lt;code&gt;start_erl.data&lt;/code&gt;, which is located in &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt;. Each new release introduces a new data file. This file is automatically generated by the release handler in Erlang.</source>
          <target state="translated">该程序使用参数 &lt;code&gt;-boot&lt;/code&gt; 和 &lt;code&gt;-config&lt;/code&gt; 设置启动Erlang仿真器。它从位于 &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 中的名为 &lt;code&gt;start_erl.data&lt;/code&gt; 的文件读取有关这些文件的位置的数据。每个新版本都会引入一个新的数据文件。该文件由Erlang中的发布处理程序自动生成。</target>
        </trans-unit>
        <trans-unit id="8f257f89dea065885b66a0cd478fca5389333698" translate="yes" xml:space="preserve">
          <source>This property is only valid if &lt;code&gt;auto_ack&lt;/code&gt; is true.</source>
          <target state="translated">仅当 &lt;code&gt;auto_ack&lt;/code&gt; 为true时，此属性才有效。</target>
        </trans-unit>
        <trans-unit id="5810ec17d7cb173c4fccedc7a14810f5d07c123d" translate="yes" xml:space="preserve">
          <source>This puts less load on the filesystem, but much more on the Erlang runtime system.</source>
          <target state="translated">这就减少了文件系统的负载,但却增加了Erlang运行时系统的负载。</target>
        </trans-unit>
        <trans-unit id="fe519e24650180a3fcf221d96e6f790286d56794" translate="yes" xml:space="preserve">
          <source>This query also removes duplicates but the answers are sorted. If there are many answers, temporary files are used. Notice that to get the first unique answer, all answers must be found and sorted. Both alternatives find duplicates by comparing answers, that is, if &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt; are answers found in that order, then &lt;code&gt;A2&lt;/code&gt; is a removed if &lt;code&gt;A1 == A2&lt;/code&gt;.</source>
          <target state="translated">该查询还删除重复项，但对答案进行排序。如果答案很多，则使用临时文件。请注意，要获得第一个唯一答案，必须找到所有答案并进行排序。两种选择都通过比较答案来查找重复项，也就是说，如果 &lt;code&gt;A1&lt;/code&gt; 和 &lt;code&gt;A2&lt;/code&gt; 是按该顺序找到的答案，那么如果 &lt;code&gt;A1 == A2&lt;/code&gt; ，则将 &lt;code&gt;A2&lt;/code&gt; 删除。</target>
        </trans-unit>
        <trans-unit id="c2f6bad75f3fbef13092a6a4222f43094d545fae" translate="yes" xml:space="preserve">
          <source>This query hits the feature of partially bound keys in table type &lt;code&gt;ordered_set&lt;/code&gt;, so that not the whole table needs to be searched, only the part containing keys beginning with &lt;code&gt;0&lt;/code&gt; is looked into.</source>
          <target state="translated">此查询具有表类型 &lt;code&gt;ordered_set&lt;/code&gt; 中部分绑定键的功能，因此不需要搜索整个表，只查找包含以 &lt;code&gt;0&lt;/code&gt; 开头的键的部分。</target>
        </trans-unit>
        <trans-unit id="671f4cec79d07856674afe86714dc175a1654c1b" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt; crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6a7904ebcd7549f287cc377bc5ea8dfe7feaba" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="translated">此随机数生成器在密码学上不强。如果需要强大的加密随机数生成器，请使用 &lt;code&gt;crypto&lt;/code&gt; 模块中的功能之一，例如 &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4aeff4461a7bf1567cdb7c34105213973f7dd8" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_all&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将从 &lt;code&gt;my_all&lt;/code&gt; 应用程序读取 &lt;code&gt;logger&lt;/code&gt; 配置参数，并启动配置的处理程序。配置的内容使用与 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt; 相同的规则。</target>
        </trans-unit>
        <trans-unit id="c00434ba7af79d001ca617ae07f4509311aeefbf" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_app&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd05537434a4630f9db4b01dfd929c70a6829e0d" translate="yes" xml:space="preserve">
          <source>This reads the entire contents of &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; into the specified registry. After the restore, all the objects in the registry are marked as unmodified, so a later backup only affects objects that you have modified since the restore.</source>
          <target state="translated">这 &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 的全部内容读入指定的注册表。还原后，注册表中的所有对象都标记为未修改，因此以后的备份仅影响自还原以来已修改的对象。</target>
        </trans-unit>
        <trans-unit id="e5017094927d4a8eb77c34c12688c26a383cd09d" translate="yes" xml:space="preserve">
          <source>This reference manual contains type descriptions generated from types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; in the &lt;code&gt; OTP Design Principles &lt;/code&gt; User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a79d754831b14cd54b94d9e66117a733bf984b" translate="yes" xml:space="preserve">
          <source>This reference manual describes types generated from the types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hiearchy, which makes them kind of hard to read.</source>
          <target state="translated">本参考手册描述了根据 &lt;code&gt;gen_statem&lt;/code&gt; 源代码中的类型生成的类型，因此它们是正确的。但是，生成的描述也反映了hiearchy的类型，这使它们难以阅读。</target>
        </trans-unit>
        <trans-unit id="1c8060b97047d75217dfaa592520c89dd24db028" translate="yes" xml:space="preserve">
          <source>This renders a result similar to the following:</source>
          <target state="translated">这将产生类似于以下的结果。</target>
        </trans-unit>
        <trans-unit id="9f783544c6147fb46866ca14f57f1cf28fd64491" translate="yes" xml:space="preserve">
          <source>This request asks for a complete list of all options supported by the I/O server as well as their current values.</source>
          <target state="translated">该请求要求提供I/O服务器支持的所有选项的完整列表,以及它们的当前值。</target>
        </trans-unit>
        <trans-unit id="c9ef467065f7f3147aa63fa765e54a5cacd5c45f" translate="yes" xml:space="preserve">
          <source>This request is not really used, it is to be regarded as a debug feature.</source>
          <target state="translated">这个要求并没有真正使用,要把它当作一个调试功能。</target>
        </trans-unit>
        <trans-unit id="d449ed2883b9cc55517ccad2ba93e587a2d92524" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt; net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed5461b3e3a2705d00654ef7851baa95f3c5a7b" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt;net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="translated">该请求通过Erlang函数 &lt;code&gt;net_adm:names/1,2&lt;/code&gt; 使用。将打开与EPMD的TCP连接，并发送此请求。</target>
        </trans-unit>
        <trans-unit id="fa4697a836ae0380ae5f8e0e273aa79c5259e1e7" translate="yes" xml:space="preserve">
          <source>This request kills the running EPMD. It is almost never used.</source>
          <target state="translated">这个请求会杀死正在运行的EPMD。几乎从不使用。</target>
        </trans-unit>
        <trans-unit id="c37139085c2a33777870615ebb189dd29f4711b3" translate="yes" xml:space="preserve">
          <source>This results in the following record:</source>
          <target state="translated">这样就有了以下记录:</target>
        </trans-unit>
        <trans-unit id="c6a3367c426977d974ddf7ae39a973d34adfaba6" translate="yes" xml:space="preserve">
          <source>This results in the following records:</source>
          <target state="translated">由此产生了以下记录:</target>
        </trans-unit>
        <trans-unit id="4754bd22d399a2af6e9567cb4368afe4e9a97e68" translate="yes" xml:space="preserve">
          <source>This return value is valid even if option &lt;code&gt;kill_ports&lt;/code&gt; was used, as killing ports can be a process that does not complete immediately. However, the condition is in that case transient. Monitors are always useful to detect when the driver is really unloaded.</source>
          <target state="translated">即使使用选项 &lt;code&gt;kill_ports&lt;/code&gt; ，此返回值也有效，因为终止端口可能是一个不会立即完成的过程。但是，在这种情况下，条件是瞬态的。监视器对于检测何时真正卸载驱动程序总是很有用的。</target>
        </trans-unit>
        <trans-unit id="61bce59fa6b3bc349ada24ae6e1accf7342572aa" translate="yes" xml:space="preserve">
          <source>This returns the driver structure. The macro &lt;code&gt;DRIVER_INIT&lt;/code&gt; defines the only exported function. All the other functions are static, and will not be exported from the library.</source>
          <target state="translated">这将返回驱动程序结构。宏 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 定义了唯一的导出函数。所有其他功能都是静态的，不会从库中导出。</target>
        </trans-unit>
        <trans-unit id="236d4116cd1bd104778ca12a47df3dca542bc4b6" translate="yes" xml:space="preserve">
          <source>This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result.</source>
          <target state="translated">这样就省去了先取一个键值,将新的值追加到存储值列表中,然后存储结果的麻烦。</target>
        </trans-unit>
        <trans-unit id="31f5366cf36758d97de45b416b180fe5021204ef" translate="yes" xml:space="preserve">
          <source>This scenario can occur if the driver code needs replacement during operation of the Erlang emulator. Implementing driver code replacement is a little more tedious than Beam code replacement, as one driver cannot be loaded as both &quot;old&quot; and &quot;new&quot; code. All &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded.</source>
          <target state="translated">如果在Erlang仿真器的操作过程中需要替换驱动程序代码，则会发生这种情况。由于不能同时以&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;代码加载一个驱动程序，因此实现驱动程序代码替换比Beam代码替换更加乏味。必须先关闭驱动程序的所有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; （没有打开的端口），然后才能卸载旧代码和加载新代码。</target>
        </trans-unit>
        <trans-unit id="503f88b8d41295f847befbf0174f96b5e1d17d21" translate="yes" xml:space="preserve">
          <source>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called &quot;dirty operations&quot;. The use of nested transactions is also described. The following topics are included:</source>
          <target state="translated">本节还介绍了锁定功能,包括表锁和粘性锁,以及绕过事务系统以提高速度和减少开销的替代功能。这些函数被称为 &quot;脏操作&quot;。还介绍了嵌套事务的使用。包括以下主题。</target>
        </trans-unit>
        <trans-unit id="ca13c61387c20120a915aa2aba2a70b09cc77ff8" translate="yes" xml:space="preserve">
          <source>This section contains information about all loaded modules.</source>
          <target state="translated">本节包含所有加载模块的信息。</target>
        </trans-unit>
        <trans-unit id="f0afb7bdb78aa30270d4c5341a78528374ecd48c" translate="yes" xml:space="preserve">
          <source>This section contains information about all the ETS tables in the system. The following fields are of interest for each table:</source>
          <target state="translated">本节包含系统中所有ETS表的信息。以下是每个表的相关字段:</target>
        </trans-unit>
        <trans-unit id="c705a253aaab772432302fcb590c6d71895de050" translate="yes" xml:space="preserve">
          <source>This section contains information about all the timers started with the BIFs &lt;code&gt;erlang:start_timer/3&lt;/code&gt; and &lt;code&gt;erlang:send_after/3&lt;/code&gt;. The following fields exist for each timer:</source>
          <target state="translated">本节包含有关所有以 &lt;code&gt;erlang:send_after/3&lt;/code&gt; &lt;code&gt;erlang:start_timer/3&lt;/code&gt; 和erlang：send_after / 3启动的计时器的信息。每个计时器存在以下字段：</target>
        </trans-unit>
        <trans-unit id="e593d062792a79977388f9b736ca5fdb84956c5e" translate="yes" xml:space="preserve">
          <source>This section contains simple introductory examples only. For a full description of the QLC query language, see the &lt;code&gt;qlc&lt;/code&gt; manual page in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">本节仅包含简单的介绍性示例。有关QLC查询语言的完整说明，请参见 &lt;code&gt;STDLIB&lt;/code&gt; 中的 &lt;code&gt;qlc&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="388bc7f1102a9ae9f2581325e4b4730cdd3f0142" translate="yes" xml:space="preserve">
          <source>This section demonstrates how simple it is to write a basic (yet for many module testing purposes, often sufficiently complex) test suite and execute its test cases. This is not necessarily obvious when you read the remaining sections in this User's Guide.</source>
          <target state="translated">本节演示了编写一个基本的(但对于许多模块测试来说,通常是足够复杂的)测试套件并执行其测试用例是多么简单。当您阅读本用户指南的其他章节时,这一点不一定很明显。</target>
        </trans-unit>
        <trans-unit id="e57241c5a98cbdf10642d048108a7272df13ecae" translate="yes" xml:space="preserve">
          <source>This section describes a simple driver for accessing a postgres database using the libpq C client library. Postgres is used because it is free and open source. For information on postgres, see &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本节描述了使用libpq C客户端库访问postgres数据库的简单驱动程序。使用Postgres是因为它是免费的开放源代码。有关postgres的信息，请访问 &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8941b0891a6ff874af251fbb759dca478d13c6f3" translate="yes" xml:space="preserve">
          <source>This section describes examples of how to use the Public Key API. Keys and certificates used in the following sections are generated only for testing the Public Key application.</source>
          <target state="translated">本节介绍了如何使用公钥API的例子。以下各节中使用的密钥和证书仅为测试公钥应用程序而生成。</target>
        </trans-unit>
        <trans-unit id="ba0088de53a90de56e1f80e0ac3933382d74faf7" translate="yes" xml:space="preserve">
          <source>This section describes how an embedded system is started. Four programs are involved and they normally reside in the directory &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. The only exception is the &lt;code&gt;start&lt;/code&gt; program, which can be located anywhere, and is also the only program that must be modified by the user.</source>
          <target state="translated">本节介绍如何启动嵌入式系统。涉及四个程序，它们通常位于目录 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 中。唯一的例外是 &lt;code&gt;start&lt;/code&gt; 程序，该程序可以位于任何地方，也是唯一必须由用户修改的程序。</target>
        </trans-unit>
        <trans-unit id="5dffe6465a9a88971444b067aa33f3c613e2da6a" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang distribution can use TLS to get extra verification and security.</source>
          <target state="translated">本节介绍了Erlang发行版如何使用TLS来获得额外的验证和安全。</target>
        </trans-unit>
        <trans-unit id="7ba1b8e520e730aff5ce60b5891f8456502ebe16" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang runtime system is configured for IP communication. It also explains how you can configure it for your needs by a configuration file. The information is primarily intended for users with special configuration needs or problems. There is normally no need for specific settings for Erlang to function properly on a correctly IP-configured platform.</source>
          <target state="translated">本节介绍了如何为IP通信配置Erlang运行时系统。它还解释了如何通过配置文件来配置它以满足你的需求。这些信息主要是为有特殊配置需求或问题的用户准备的。一般情况下,不需要特殊的设置,Erlang就可以在一个正确配置IP的平台上正常运行。</target>
        </trans-unit>
        <trans-unit id="b9ba9d8ce48a5e18d389572e80e439e457082f15" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install Cygwin, MSYS or MSYS2.</source>
          <target state="translated">本节介绍如何在Windows上构建Erlang仿真器和OTP库。请注意，如果没有Microsoft的开发工具和/或不想安装Cygwin，MSYS或MSYS2，则Windows二进制版本仍然是首选。</target>
        </trans-unit>
        <trans-unit id="dcc931582562f8a25cb00d5b918e90edbe2d35fd" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install WSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b49078ad714b83061016b41c527ea88a0ef01c" translate="yes" xml:space="preserve">
          <source>This section describes how to build your own driver for Erlang.</source>
          <target state="translated">本节介绍如何为Erlang构建自己的驱动程序。</target>
        </trans-unit>
        <trans-unit id="9ea8a2e527669401063f6aeee8dc65aebcbab675" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative carrier protocol for the Erlang distribution. The distribution is normally carried by TCP/IP. Here is explained a method for replacing TCP/IP with another protocol.</source>
          <target state="translated">本节介绍了如何为Erlang发行版实现一个替代的承载协议。该发行版通常由TCP/IP承载。这里解释了用另一种协议替代TCP/IP的方法。</target>
        </trans-unit>
        <trans-unit id="ef9194590c5bbba89fd68a31ae7705b884e62724" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative discovery mechanism for Erlang distribution. Discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port discovery.</source>
          <target state="translated">本节介绍了如何为Erlang发行版实现另一种发现机制。通常使用DNS和Erlang Port Mapper Daemon(EPMD)进行端口发现。</target>
        </trans-unit>
        <trans-unit id="da8047f598c0cf0b64db9a2f17dfe37a85e55406" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative node discovery mechanism for Erlang distribution. Node discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port registration and lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a63b1a98e975cb1778e4a9f8ed67fec8fb504f" translate="yes" xml:space="preserve">
          <source>This section describes how to write a Net if process.</source>
          <target state="translated">本节介绍如何编写Net if进程。</target>
        </trans-unit>
        <trans-unit id="a5a2806882d6d1e2d41fb571e953fc2694d49bf3" translate="yes" xml:space="preserve">
          <source>This section describes how to write a process that complies to the OTP design principles, without using a standard behaviour. Such a process is to:</source>
          <target state="translated">本节介绍如何在不使用标准行为的情况下,编写一个符合OTP设计原则的流程。这样的流程是为了:</target>
        </trans-unit>
        <trans-unit id="db110007d4cae55a5cd2784be2448b1464cdeff4" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;Mnesia&lt;/code&gt; transaction system and the transaction properties that make &lt;code&gt;Mnesia&lt;/code&gt; a fault-tolerant, distributed Database Management System (DBMS).</source>
          <target state="translated">本节介绍使 &lt;code&gt;Mnesia&lt;/code&gt; 成为容错分布式数据库管理系统（DBMS）的 &lt;code&gt;Mnesia&lt;/code&gt; 事务处理系统和事务属性。</target>
        </trans-unit>
        <trans-unit id="145559b08f0e7daceea91964fac1205f05f73a6b" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;erl_crash.dump&lt;/code&gt; file generated upon abnormal exit of the Erlang runtime system.</source>
          <target state="translated">本节描述了在Erlang运行时系统异常退出时生成的 &lt;code&gt;erl_crash.dump&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="615a4d70bf1eb0943d565d942619e06723c44a20" translate="yes" xml:space="preserve">
          <source>This section describes the ASN.1 types including their functionality, purpose, and how values are assigned in Erlang.</source>
          <target state="translated">这一节描述了ASN.1类型,包括它们的功能、目的以及在Erlang中如何赋值。</target>
        </trans-unit>
        <trans-unit id="4973acdcae6787712641efb91993666da08e3527" translate="yes" xml:space="preserve">
          <source>This section describes the basic steps when designing a &lt;code&gt;Mnesia&lt;/code&gt; database and the programming constructs that make different solutions available to the programmer. The following topics are included:</source>
          <target state="translated">本节介绍了设计 &lt;code&gt;Mnesia&lt;/code&gt; 数据库时的基本步骤以及为程序员提供不同解决方案的编程结构。包括以下主题：</target>
        </trans-unit>
        <trans-unit id="734f476df2959a2662d969893e8e7029abc0685e" translate="yes" xml:space="preserve">
          <source>This section describes the current state of standards compliance of the ssl application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf94ee7a5d096d374f74f2312ed2c9e2ebd27de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol introduced in Erlang/OTP R6. This description was previously located in &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; and has more or less been copied and &quot;formatted&quot; here. It has been almost unchanged since 1999, but the handshake has not changed much since then either.</source>
          <target state="translated">本节描述了Erlang / OTP R6中引入的分发握手协议。该描述以前位于 &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; ，在此或多或少已被复制和&amp;ldquo;格式化&amp;rdquo;。自1999年以来，它几乎没有变化，但握手至今也没有太大变化。</target>
        </trans-unit>
        <trans-unit id="c5d7bec7b79a0ae59b92c5e5f67ae7a72f8453de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol used between nodes to establishing a connection. The protocol was introduced in Erlang/OTP R6 and has remained unchanged until OTP 23. The changes made in OTP 23 were designed to be compatible with the older protocol version. That is an old node can still connect toward a new node and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76e009e16bdd01f805b9e968741d4585ed774f4" translate="yes" xml:space="preserve">
          <source>This section describes the functions available for schema management, all which return either of the following tuples:</source>
          <target state="translated">本节介绍了模式管理可用的函数,所有这些函数都返回以下图元组中的任何一个。</target>
        </trans-unit>
        <trans-unit id="b453da50a4aa889b5bfe6fc3855f07b9e605aebd" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net If process may choose to respond to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6589e4219f2138e744e1d40f56f69ff33d9cd04f" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net if process must be able to receive.</source>
          <target state="translated">本节描述了Net if进程必须能够接收的传入消息。</target>
        </trans-unit>
        <trans-unit id="ba803131ede9177f9bd28303113e3a91a6271ee1" translate="yes" xml:space="preserve">
          <source>This section describes the internal files that are created and maintained by the &lt;code&gt;Mnesia&lt;/code&gt; system. In particular, the workings of the &lt;code&gt;Mnesia&lt;/code&gt; log are described.</source>
          <target state="translated">本节介绍了由 &lt;code&gt;Mnesia&lt;/code&gt; 系统创建和维护的内部文件。特别是描述了 &lt;code&gt;Mnesia&lt;/code&gt; 日志的工作方式。</target>
        </trans-unit>
        <trans-unit id="16c349c9cdb2076b95c930dc72ed84bdd0fd6a91" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Solaris.</source>
          <target state="translated">本节介绍了OTP中与Solaris有关的操作系统特定部分。</target>
        </trans-unit>
        <trans-unit id="35c4d999a1922f58afda1ed0555720ff15b4c949" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Windows NT.</source>
          <target state="translated">本节介绍与Windows NT有关的OTP的操作系统特定部分。</target>
        </trans-unit>
        <trans-unit id="40285644d87303c5462b5e3de0dc15016aecc45b" translate="yes" xml:space="preserve">
          <source>This section describes the output format of the analyse command. See &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本节描述了analyze命令的输出格式。参见 &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56322ae43abba91cc149a5278e951f77e9967920" translate="yes" xml:space="preserve">
          <source>This section describes the rules for constructing binaries using the bit syntax. Unlike when constructing lists or tuples, the construction of a binary can fail with a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">本节介绍使用位语法构造二进制文件的规则。与构造列表或元组时不同，二进制文件的构造可能会因 &lt;code&gt;badarg&lt;/code&gt; 异常而失败。</target>
        </trans-unit>
        <trans-unit id="9c65c0615f3b377f5b341fdeacc78b3636ed30f2" translate="yes" xml:space="preserve">
          <source>This section describes the rules for matching binaries, using the bit syntax.</source>
          <target state="translated">本节介绍了使用位语法匹配二进制文件的规则。</target>
        </trans-unit>
        <trans-unit id="c4785eaeac1329ade355f9bd89d5b3faa13bbcad" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt; dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efdb6c16651b89d1df8757e4dbe192b22b7b9d8" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">本节描述了由 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 转换的稍有不同的匹配规范。</target>
        </trans-unit>
        <trans-unit id="56316fa96e48fce5d8864ec5f5ab650e8bc4aac3" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt; compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3b7f437eda66334d0b64118f5de15fc1fc7fab" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt;compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="translated">本节将Erlang程序的解析树的标准表示形式描述为Erlang术语。这种表示形式称为&lt;strong&gt;抽象格式&lt;/strong&gt;。处理此类解析树的函数为 &lt;code&gt;compile:forms/1,2&lt;/code&gt; 和以下模块中的函数：</target>
        </trans-unit>
        <trans-unit id="2174d2f040729649ef711f3e5635d25b5e2b5fd1" translate="yes" xml:space="preserve">
          <source>This section describes the use of the registry, a simple mechanism for storing key-value pairs in a C-node, as well as backing them up or restoring them from an &lt;code&gt;Mnesia&lt;/code&gt; table on an Erlang node. For more detailed information about the individual API functions, see the &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">本节介绍注册表的使用，注册表是一种简单的机制，用于在C节点中存储键值对，以及备份它们或从Erlang节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 表还原它们。有关各个API函数的更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="9871ac4ba76bd34221092f66dc88616fc9822501" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the &lt;strong&gt;state enter calls&lt;/strong&gt;, so this example first branches depending on state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e54bfa17aaa2c2d40ded61fef98685a45ccab20" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the state enter calls, so this example first branches depending on state:</source>
          <target state="translated">本节介绍使用一个 &lt;code&gt;handle_event/4&lt;/code&gt; 函数的示例更改内容。由于状态输入调用，先前使用的根据事件进行第一分支的方法在这里效果不佳，因此此示例根据状态进行第一分支：</target>
        </trans-unit>
        <trans-unit id="62fe5fd22b036a47305b864aea85d4d04ebc8617" translate="yes" xml:space="preserve">
          <source>This section illustrates procedural abstraction. Initially, the following two examples are written as conventional functions.</source>
          <target state="translated">本节说明程序抽象。最初,以下两个例子写成常规函数。</target>
        </trans-unit>
        <trans-unit id="cceb1f5cb17e39dece66daf2562fc578ef8e2eb3" translate="yes" xml:space="preserve">
          <source>This section includes examples of &lt;code&gt;.appup&lt;/code&gt; files for typical cases of upgrades/downgrades done in runtime.</source>
          <target state="translated">本节包括 &lt;code&gt;.appup&lt;/code&gt; 文件的示例，这些示例用于在运行时完成升级/降级的典型情况。</target>
        </trans-unit>
        <trans-unit id="7ea33b2a0ec7d517340851621821d8be874ccf07" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using &lt;strong&gt;state enter calls&lt;/strong&gt;, which deserves a new state diagram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8307ab1487485b0ab0c191a87d10ed0db502873" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using state enter calls, which deserves a new state diagram:</source>
          <target state="translated">本节包括了大部分提到的修改后的例子,还有一些使用状态输入调用的例子,这值得一个新的状态图。</target>
        </trans-unit>
        <trans-unit id="46836c7cf8344b6ce7b90b07cbf3092bf8c64800" translate="yes" xml:space="preserve">
          <source>This section informs on interoperability, that is, information exchange, between Erlang and other programming languages. The included examples mainly treat interoperability between Erlang and C.</source>
          <target state="translated">本节介绍Erlang和其他编程语言之间的互操作性,即信息交换。本节主要介绍Erlang和C语言之间的互操作性。</target>
        </trans-unit>
        <trans-unit id="89f49f8072fe70dfd2c365690f214b5fdc461dd8" translate="yes" xml:space="preserve">
          <source>This section introduces &lt;code&gt;Mnesia&lt;/code&gt; with an example database. This example is referenced in the following sections, where the example is modified to illustrate various program constructs. This section illustrates the following mandatory procedures through examples:</source>
          <target state="translated">本节介绍 &lt;code&gt;Mnesia&lt;/code&gt; 的示例数据库。以下各节中引用了此示例，其中对示例进行了修改以说明各种程序构造。本节通过示例说明以下强制性步骤：</target>
        </trans-unit>
        <trans-unit id="9ce26ca011dda9632c352924ddce457d60697ee5" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt; Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9ffc517c7f7beea672bf3a45f0d5c54e6718e6" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt;Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="translated">本部分是快速入门教程，可帮助您开始使用Erlang。本节中的所有内容都是真实的，但只有部分真实。例如，仅显示语法的最简单形式，而不显示所有深奥形式。另外，用*手册*表示大大简化的零件。这意味着可以在《 Erlang书》或《 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 找到有关该主题的更多信息。</target>
        </trans-unit>
        <trans-unit id="7681f5719ebc6c3947920d0c8b79f4d20d935db2" translate="yes" xml:space="preserve">
          <source>This section is about installing an embedded system. The following topics are considered:</source>
          <target state="translated">本节是关于安装嵌入式系统。考虑了以下主题:</target>
        </trans-unit>
        <trans-unit id="e1226c380377fda419e20eb5188c02f21ab8efb4" translate="yes" xml:space="preserve">
          <source>This section is about list functions that &lt;strong&gt;construct&lt;/strong&gt; lists. A tail-recursive function that does not construct a list runs in constant space, while the corresponding body-recursive function uses stack space proportional to the length of the list.</source>
          <target state="translated">本节关于&lt;strong&gt;构造&lt;/strong&gt;列表的列表函数。不构造列表的尾递归函数在恒定空间中运行，而相应的主体递归函数使用与列表长度成比例的堆栈空间。</target>
        </trans-unit>
        <trans-unit id="68c719f00318cfafeb4885e7d19be04a0e723344" translate="yes" xml:space="preserve">
          <source>This section is the Erlang reference manual. It describes the Erlang programming language.</source>
          <target state="translated">本节是Erlang参考手册。它描述了Erlang编程语言。</target>
        </trans-unit>
        <trans-unit id="6ef1c8ac7b879ac21c4bbd932c5c5aba836b3ebe" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;app(4)&lt;/code&gt; and &lt;code&gt;application(3)&lt;/code&gt; manual pages in Kernel.</source>
          <target state="translated">本节将与内核中的 &lt;code&gt;app(4)&lt;/code&gt; 和 &lt;code&gt;application(3)&lt;/code&gt; 手册页一起阅读。</target>
        </trans-unit>
        <trans-unit id="d050299e9360b73cf317b1cb6719eba05c8f8b67" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_event(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本部分将与STDLIB 的 &lt;code&gt;gen_event(3)&lt;/code&gt; 手册页一起阅读，在此详细描述了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="b25498b71adedf6dc2be1b461a7355670bd9865a" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in &lt;code&gt;stdlib&lt;/code&gt;, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本部分将与 &lt;code&gt;stdlib&lt;/code&gt; 中的 &lt;code&gt;gen_server(3)&lt;/code&gt; 手册页一起阅读，其中详细描述了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="e425baa0c9a68eb141d0fd0ffe5193c115033f3e" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_statem(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">本节将与STDLIB 的 &lt;code&gt;gen_statem(3)&lt;/code&gt; 手册页一起阅读，在此详细介绍了所有接口函数和回调函数。</target>
        </trans-unit>
        <trans-unit id="834b2272d947ac4550fa4f7cf0a1b4b54d61e0d3" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;rel(4)&lt;/code&gt;, &lt;code&gt;systools(3)&lt;/code&gt;, and &lt;code&gt;script(4)&lt;/code&gt; manual pages in SASL.</source>
          <target state="translated">本部分将与SASL中的 &lt;code&gt;rel(4)&lt;/code&gt; ， &lt;code&gt;systools(3)&lt;/code&gt; 和 &lt;code&gt;script(4)&lt;/code&gt; 手册页一起阅读。</target>
        </trans-unit>
        <trans-unit id="d930e6096fb887dbfeb97cc96dedbb64de3c9031" translate="yes" xml:space="preserve">
          <source>This section lists a few modules and BIFs to watch out for, not only from a performance point of view.</source>
          <target state="translated">本节列出了一些需要注意的模块和BIF,不仅从性能的角度来看。</target>
        </trans-unit>
        <trans-unit id="302cba4ce6be32265c131b8fff3be15369bb97a8" translate="yes" xml:space="preserve">
          <source>This section lists all funs. The following fields exist for each fun:</source>
          <target state="translated">本节列出了所有fun。每个fun都有以下字段。</target>
        </trans-unit>
        <trans-unit id="7bc1c1a16c9fc6835aa747c430d5753502607fd3" translate="yes" xml:space="preserve">
          <source>This section lists the open ports, their owners, any linked processes, and the name of their driver or external process.</source>
          <target state="translated">这一部分列出了开放的端口、它们的所有者、任何链接的进程,以及它们的驱动程序或外部进程的名称。</target>
        </trans-unit>
        <trans-unit id="251c858a6feb418633832df9c31b24c8b4f5a1b7" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using Native Implemented Functions (NIFs).</source>
          <target state="translated">本节概述了如何使用本机实现的功能（NIF）解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="e7bc2bafdedf8fd30afa495c12130ded7ddd3fc5" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a C node. Notice that a C node is not typically used for solving simple problems like this, a port is sufficient.</source>
          <target state="translated">本节概述了如何使用C节点解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。注意，C节点通常不用于解决诸如此类的简单问题，端口就足够了。</target>
        </trans-unit>
        <trans-unit id="d8b1fe16968a43f36d99fc7c39a89fadb4f26e24" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a linked-in port driver.</source>
          <target state="translated">本节概述了如何使用链接的端口驱动程序解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="6188e756764065c7ce79203e7dc5cecf3ee5f2b4" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a port and Erl_Interface. It is necessary to read the port example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; before reading this section.</source>
          <target state="translated">本节概述了如何使用端口和Erl_Interface 解决&amp;ldquo; &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 的示例问题的示例。这是必要的阅读端口例如 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 阅读本节之前。</target>
        </trans-unit>
        <trans-unit id="37a17f96d0247a59a445c39970b3c2ce5aa258a2" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in the &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; by using a port.</source>
          <target state="translated">本节概述了如何使用端口解决 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; 示例问题的示例。</target>
        </trans-unit>
        <trans-unit id="909ed75e66d95b03604cc684f38a417f30c36fa4" translate="yes" xml:space="preserve">
          <source>This section outlines the current Unicode support and gives some recipes for working with Unicode data.</source>
          <target state="translated">本节概述了当前的Unicode支持,并给出了一些处理Unicode数据的方法。</target>
        </trans-unit>
        <trans-unit id="f4548220d710b00d84d1083e484e819816bc4647" translate="yes" xml:space="preserve">
          <source>This section presents all the atoms in the system. This is only of interest if one suspects that dynamic generation of atoms can be a problem, otherwise this section can be ignored.</source>
          <target state="translated">本节介绍了系统中所有的原子。只有当人们怀疑原子的动态生成可能是一个问题时,才会对此感兴趣,否则本节可以忽略。</target>
        </trans-unit>
        <trans-unit id="e98a32dcb47ef919db3aef2c03013357cf7c9199" translate="yes" xml:space="preserve">
          <source>This section presents the generic protocol-independent model for use within an OTP-based NE. This model is used by all OAM components and can be used by the applications. The advantage of the model is that it clearly separates the resources from the management protocol. The resources do not need to be aware of which management protocol is used to manage the system. The same resources can therefore be managed with different protocols.</source>
          <target state="translated">本节介绍了在基于OTP的NE中使用的通用协议无关模型。这个模型被所有的OAM组件使用,并且可以被应用程序使用。该模型的优点是它明确地将资源与管理协议分开。资源不需要知道用哪个管理协议来管理系统。因此,相同的资源可以用不同的协议进行管理。</target>
        </trans-unit>
        <trans-unit id="16347e215e685cc8a7eb7375f07fbbb91f2c9603" translate="yes" xml:space="preserve">
          <source>This section provides a brief overview on how to write efficient drivers.</source>
          <target state="translated">本节简要介绍了如何编写高效的驱动程序。</target>
        </trans-unit>
        <trans-unit id="30913964bf9365a1caa81bfa4bb9ad170421d97f" translate="yes" xml:space="preserve">
          <source>This section provides a simplified demonstration of a &lt;code&gt;Mnesia&lt;/code&gt; system startup. The dialogue from the Erlang shell is as follows:</source>
          <target state="translated">本节提供了 &lt;code&gt;Mnesia&lt;/code&gt; 系统启动的简化演示。来自Erlang shell的对话框如下：</target>
        </trans-unit>
        <trans-unit id="ec0f201c25b61d89e7f6c76b13618afc0002a916" translate="yes" xml:space="preserve">
          <source>This section should be read with the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page in STDLIB, where all details about the supervisor behaviour is given.</source>
          <target state="translated">本节应与STDLIB 的 &lt;code&gt;supervisor(3)&lt;/code&gt; 手册页一起阅读，其中提供了有关supervisor行为的所有详细信息。</target>
        </trans-unit>
        <trans-unit id="859dc9ee797ee513900af80c0e4f3984de1a34df" translate="yes" xml:space="preserve">
          <source>This section shows a small example of how to set up client/server connections using the Erlang shell. The returned value of the &lt;code&gt;sslsocket&lt;/code&gt; is abbreviated with &lt;code&gt;[...]&lt;/code&gt; as it can be fairly large and is opaque.</source>
          <target state="translated">本节显示一个小示例，说明如何使用Erlang Shell设置客户端/服务器连接。 &lt;code&gt;sslsocket&lt;/code&gt; 的返回值缩写为 &lt;code&gt;[...]&lt;/code&gt; ,因为它可能相当大且不透明。</target>
        </trans-unit>
        <trans-unit id="1b3f3a6882bc6f1c999e3d6f053e34aa184902fb" translate="yes" xml:space="preserve">
          <source>This section starts with a simple example, showing a generator and a filter:</source>
          <target state="translated">本节从一个简单的例子开始,展示了一个发生器和一个滤波器。</target>
        </trans-unit>
        <trans-unit id="b10755987ebac7d338a7fd1a7c6bbec42a0583a6" translate="yes" xml:space="preserve">
          <source>This section tries to kill the old truths (or semi-truths) that have become myths.</source>
          <target state="translated">这一节试图扼杀那些已经成为神话的旧真理(或半真理)。</target>
        </trans-unit>
        <trans-unit id="4bc790cb1406d976325d74bbdbe32730d66b0176" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, as it explains important concepts, but this was written for an older driver interface so the examples do not work anymore. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">这部分是很久以前写的。它大多数都仍然有效，因为它解释了重要的概念，但这是为较旧的驱动程序界面编写的，因此这些示例不再起作用。鼓励读者阅读 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="b93f78b17719c3a40516be4872cc22d2aa5ee759" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, but some things have changed since then. Some updates have been made to the documentation of the driver presented here, but more can be done and is planned for the future. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">这部分是很久以前写的。大多数内容仍然有效，但此后发生了一些变化。已经对此处提供的驱动程序文档进行了一些更新，但是可以做很多事，并计划在将来进行。鼓励读者阅读 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="3acfdfded91bac52b2d4f66deb3db7bcfef3bb64" translate="yes" xml:space="preserve">
          <source>This sends a request with a specified connection header:</source>
          <target state="translated">这将发送一个带有指定连接头的请求。</target>
        </trans-unit>
        <trans-unit id="a989f27ccbc0cd1a9d3190ceeec551d99b4ccfce" translate="yes" xml:space="preserve">
          <source>This sends an HTTP request over a unix domain socket (experimental):</source>
          <target state="translated">这将通过unix域套接字发送一个HTTP请求(实验性的)。</target>
        </trans-unit>
        <trans-unit id="0367f390c138c4cdab5de93d4dcd533741c91409" translate="yes" xml:space="preserve">
          <source>This server can be started with the Kernel configuration parameter &lt;code&gt;start_boot_server&lt;/code&gt;.</source>
          <target state="translated">可以使用内核配置参数 &lt;code&gt;start_boot_server&lt;/code&gt; 启动该服务器。</target>
        </trans-unit>
        <trans-unit id="9a01d31508a13cbee6fd61e7f30640416fa3e960" translate="yes" xml:space="preserve">
          <source>This server is used to assist diskless Erlang nodes that fetch all Erlang code from another machine.</source>
          <target state="translated">这个服务器用来协助无盘的Erlang节点从另一台机器上获取所有Erlang代码。</target>
        </trans-unit>
        <trans-unit id="6d1e9f0f9d29165296c1877ce900cce295357757" translate="yes" xml:space="preserve">
          <source>This server is used to fetch all code, including the start script, if an Erlang runtime system is started with command-line flag &lt;code&gt;-loader inet&lt;/code&gt;. All hosts specified with command-line flag &lt;code&gt;-hosts Host&lt;/code&gt; must have one instance of this server running.</source>
          <target state="translated">如果使用命令行标志 &lt;code&gt;-loader inet&lt;/code&gt; 启动Erlang运行时系统，则此服务器用于获取所有代码，包括启动脚本。使用命令行标志 &lt;code&gt;-hosts Host&lt;/code&gt; 指定的所有主机主机必须正在运行此服务器的一个实例。</target>
        </trans-unit>
        <trans-unit id="b854dfbf08852692209c2c9428fe6541ba04a2b8" translate="yes" xml:space="preserve">
          <source>This session sets the system_tracer to the same process as the ordinary tracer process (i. e. &amp;lt;0.31.0&amp;gt;) and sets the trace pattern for the function &lt;code&gt;dbg:get_tracer&lt;/code&gt; to one that has the action of setting a sequential token. When the function is called by a traced process (all processes are traced in this case), the process gets &quot;contaminated&quot; by the token and &lt;code&gt;seq_trace&lt;/code&gt; messages are sent both for the server request and the response. The &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; after the call clears the &lt;code&gt;seq_trace&lt;/code&gt; token, why no messages are sent when the answer propagates via the shell to the console port. The output would otherwise have been more noisy.</source>
          <target state="translated">该会话将system_tracer设置为与普通跟踪器进程相同的进程（即&amp;lt;0.31.0&amp;gt;），并将函数 &lt;code&gt;dbg:get_tracer&lt;/code&gt; 的跟踪模式设置为具有设置顺序令牌的动作的跟踪模式。当被跟踪的进程调用该函数（在这种情况下将跟踪所有进程）时，该进程将被令牌&amp;ldquo;污染&amp;rdquo;，并为服务器请求和响应发送 &lt;code&gt;seq_trace&lt;/code&gt; 消息。所述 &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; 在调用之后清除 &lt;code&gt;seq_trace&lt;/code&gt; 令牌，为什么没有消息被发送通过壳到控制台端口答案传播时。否则，输出将更加嘈杂。</target>
        </trans-unit>
        <trans-unit id="cbd4292b15086fa99902265956cddedc9ff73138" translate="yes" xml:space="preserve">
          <source>This shared format is the heart of the EEP as it is what effectively allows cross-language collaboration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6dee944ecab0b445c18e6ceefaac7d931ceec9" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; are added first in the PATH.</source>
          <target state="translated">这应该对环境起到最后的作用，并且此后的建造应该很容易。您可以在不使用 &lt;code&gt;eval&lt;/code&gt; 的情况下运行 &lt;code&gt;./otp_build env_win32&lt;/code&gt; ，只是为了查看它的作用，并查看它设置的环境是否正常。如果可能的话，清除路径中的空格（改为使用DOS样式的短名称），将变量 &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt; ， &lt;code&gt;CC&lt;/code&gt; ， &lt;code&gt;CXX&lt;/code&gt; ， &lt;code&gt;AR&lt;/code&gt; 和 &lt;code&gt;RANLIB&lt;/code&gt; 设置为其各自的包装，并将目录 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; 首先添加到PATH中。</target>
        </trans-unit>
        <trans-unit id="03f198b6590c34f01a64a75908db7163cea9b266" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; are added first in the PATH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b5857195448594d0390d51817917a61df0959d" translate="yes" xml:space="preserve">
          <source>This should setup the additional environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785e08dd7a56c60e1bed8756d1974bdb847eb99" translate="yes" xml:space="preserve">
          <source>This shows another important non-obvious case: a clause guard, even if it's as simple as &lt;code&gt;Y &amp;gt; 0&lt;/code&gt;, always consists of a single disjunction of one or more conjunctions of tests, much like a tuple of tuples. Thus:</source>
          <target state="translated">这显示了另一个重要的非显而易见的情况：子句保护，即使它像 &lt;code&gt;Y &amp;gt; 0&lt;/code&gt; 一样简单，也总是由一个或多个测试连接的单个析取组成，就像一个元组的元组。从而：</target>
        </trans-unit>
        <trans-unit id="d79fe51d70506d4d2574ce2f8d6c698753c2450c" translate="yes" xml:space="preserve">
          <source>This signal is sent as a reply to a process previously sending a &lt;code&gt;&lt;a href=&quot;#SPAWN_REQUEST&quot;&gt;SPAWN_REQUEST&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640f93147afaa4bbce9c0970534b8a37095141af" translate="yes" xml:space="preserve">
          <source>This signal is sent by a call to the erlang:exit/2 bif</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7068d2c470c4b8af4e69cfc9fdf5935a4cd0cd8e" translate="yes" xml:space="preserve">
          <source>This signal is sent by the &lt;code&gt;&lt;a href=&quot;erlang#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; BIF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bcd8c5c7a896221b7a365d42f6767bd737b00ce" translate="yes" xml:space="preserve">
          <source>This signal is sent when a link has been broken</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa8ade625dd050384ebfe47137813125a13ed25" translate="yes" xml:space="preserve">
          <source>This signal will be ignored.</source>
          <target state="translated">此信号将被忽略。</target>
        </trans-unit>
        <trans-unit id="92abfd0b7a6c2f6f6e673410127b459c582c4efd" translate="yes" xml:space="preserve">
          <source>This signal will notify &lt;code&gt;erl_signal_server&lt;/code&gt; when it is received by the Erlang runtime system.</source>
          <target state="translated">当Erlang运行时系统接收到该信号时，它将通知 &lt;code&gt;erl_signal_server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edab6f17da92a0f0da17b2cdabee390180519ab6" translate="yes" xml:space="preserve">
          <source>This signal will use the default signal handler for the operating system.</source>
          <target state="translated">该信号将使用操作系统的默认信号处理器。</target>
        </trans-unit>
        <trans-unit id="da98f38cbd3a5312fa20fb0710bd3343db7b6751" translate="yes" xml:space="preserve">
          <source>This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \X matches one of these clusters.</source>
          <target state="translated">在Unicode中,这个简单的定义被扩展到包括更复杂的复合字符,给每个字符一个词素断裂属性,并创建规则,使用这些属性来定义扩展词素簇的边界。在8.31以后的PCRE版本中,\X与这些簇之一相匹配。</target>
        </trans-unit>
        <trans-unit id="e86121002d76857e44d3ab841a1269a83df96b05" translate="yes" xml:space="preserve">
          <source>This simple standard test, &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt;, a module which, using the &lt;code&gt;snmp_ex2_manager&lt;/code&gt; described in the previous section, implements a simple agent test utility.</source>
          <target state="translated">这个简单的标准测试 &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt; 是一个模块，该模块使用上 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 介绍的snmp_ex2_manager来实现一个简单的代理测试实用程序。</target>
        </trans-unit>
        <trans-unit id="dd2b5053ac3688fc735f48df406e257a6da53d21" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt; OTP Design Principles&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0034518115855077790a9986c987efa20b3785" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt;OTP Design Principles&lt;/code&gt;).</source>
          <target state="translated">通过使用OTP中的功能，可以更轻松地解决此类问题，这些功能还提供了动态更新代码的方法，等等（请参阅 &lt;code&gt;OTP Design Principles&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3b6d6c6628faa03b7c6f08bc646ad236cf4da32" translate="yes" xml:space="preserve">
          <source>This specialized decode decodes a subtype of a constructed value and is the fastest method to extract a subvalue. This decode is typically used when you want to inspect, for example, a version number, to be able to decide what to do with the entire value. The result is returned as &lt;code&gt;{ok,Value}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">这种专用解码对构造值的子类型进行解码，并且是提取子值的最快方法。通常，当您要检查版本号以决定如何处理整个值时，通常使用此解码。结果以 &lt;code&gt;{ok,Value}&lt;/code&gt; 或 &lt;code&gt;{error,Reason}&lt;/code&gt; 的形式返回。</target>
        </trans-unit>
        <trans-unit id="e6e3b86cfeba9cfc10be5c29dcc96ff101065bf4" translate="yes" xml:space="preserve">
          <source>This specifies the file modes to use when opening the log file, see &lt;code&gt;&lt;a href=&quot;file#open-2&quot;&gt;file:open/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;modes&lt;/code&gt; are not specified, the default list used is &lt;code&gt;[raw,append,delayed_write]&lt;/code&gt;. If &lt;code&gt;modes&lt;/code&gt; are specified, the list replaces the default modes list with the following adjustments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89922ee078d75b864b4466e994e9cf6b8e2ad24b" translate="yes" xml:space="preserve">
          <source>This specifies the name of the log file when the handler is of type &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e086b8dea4b8bfb5a0597b5900b1d75b0fef9f" translate="yes" xml:space="preserve">
          <source>This starts Erlang in its own window, with fully functioning command-line editing and scrollbars. All flags except &lt;code&gt;-oldshell&lt;/code&gt; work as they do for &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将在具有自己功能的命令行编辑和滚动条窗口中启动Erlang。除 &lt;code&gt;-oldshell&lt;/code&gt; 以外的所有标志都与 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="a43faa1a1676e12b0177f046a812f0d8364ec82d" translate="yes" xml:space="preserve">
          <source>This starts the Erlang runtime system and evaluates the following functions:</source>
          <target state="translated">这将启动Erlang运行时系统并评估以下函数。</target>
        </trans-unit>
        <trans-unit id="8bb8d3378772860a522d3a705d4cc5d40c409e79" translate="yes" xml:space="preserve">
          <source>This state data can be regarded as sensitive, and maybe not what you want in the error log because of some unpredictable event.</source>
          <target state="translated">这个状态数据可以说是敏感的,也许因为一些不可预知的事件,在错误日志中并不是你想要的。</target>
        </trans-unit>
        <trans-unit id="97c14a1eab4a2d73f912f341632799fc7862da43" translate="yes" xml:space="preserve">
          <source>This state transition action can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或将其 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用此状态转换动作。</target>
        </trans-unit>
        <trans-unit id="57901b1493b88f1a72b634f92f65ad89d7517d70" translate="yes" xml:space="preserve">
          <source>This step also implies that the Erlang code in the interface and distribution modules is written in such a way that it can be run in the startup phase. In particular, there can be no calls to the &lt;code&gt;application&lt;/code&gt; module or to any modules not loaded at boot time. That is, only &lt;code&gt;Kernel&lt;/code&gt;, &lt;code&gt;STDLIB&lt;/code&gt;, and the application itself can be used.</source>
          <target state="translated">此步骤还意味着，接口和分发模块中的Erlang代码是以可以在启动阶段运行的方式编写的。特别是，在启动时不能调用 &lt;code&gt;application&lt;/code&gt; 模块或任何未加载的模块。也就是说，只能使用 &lt;code&gt;Kernel&lt;/code&gt; ， &lt;code&gt;STDLIB&lt;/code&gt; 和应用程序本身。</target>
        </trans-unit>
        <trans-unit id="33eaf1a1a2a532c70f7ffcd5caaf8b22d9ff8909" translate="yes" xml:space="preserve">
          <source>This structure is to be used if all clients are running the same type of Erlang machine. If there are clients running different types of Erlang machines, or on different operating systems, the &lt;code&gt;clients&lt;/code&gt; directory can be divided into one subdirectory per type of Erlang machine. Alternatively, one &lt;code&gt;$ROOT&lt;/code&gt; can be set up per type of machine. For each type, some of the directories specified for the &lt;code&gt;$ROOT&lt;/code&gt; directory are to be included:</source>
          <target state="translated">如果所有客户端都在运行相同类型的Erlang计算机，则将使用此结构。如果有客户端在运行不同类型的Erlang计算机，或在不同的操作系统上运行，则可以将 &lt;code&gt;clients&lt;/code&gt; 目录划分为每种Erlang计算机类型的一个子目录。或者，可以为每种类型的机器设置一个 &lt;code&gt;$ROOT&lt;/code&gt; 。对于每种类型，将包括为 &lt;code&gt;$ROOT&lt;/code&gt; 目录指定的一些目录：</target>
        </trans-unit>
        <trans-unit id="ba107d8023d557fe4ebdc08a0485fead425f4a4c" translate="yes" xml:space="preserve">
          <source>This structure is used for all types of ports although some fields are useless for some types. The least memory consuming solution would be to arrange this structure as a union of structures. However, the multiple indirections in the code to access a field in such a structure would clutter the code too much for an example.</source>
          <target state="translated">这个结构适用于所有类型的 port,尽管有些字段对某些类型是无用的。最不消耗内存的解决方案是把这个结构安排成结构的联合。然而,在这样的结构中访问一个字段的代码中,多次的间接访问会使代码过于混乱。</target>
        </trans-unit>
        <trans-unit id="b9c807a7212c0db55e210d6237e55cf572102e59" translate="yes" xml:space="preserve">
          <source>This switches off logging for SSH and Telnet connections.</source>
          <target state="translated">这将关闭SSH和Telnet连接的日志记录。</target>
        </trans-unit>
        <trans-unit id="3c8936eaae5713c5223ec21e20e0d36d26fc0092" translate="yes" xml:space="preserve">
          <source>This switches off logging for all connection types.</source>
          <target state="translated">这将关闭所有连接类型的日志记录。</target>
        </trans-unit>
        <trans-unit id="f56bbb3abc53b0a624950444e1c66ce730f11613" translate="yes" xml:space="preserve">
          <source>This symbol should appear in the lhs of at least one grammar rule. This is the most general syntactic category which the parser ultimately will parse every input string into.</source>
          <target state="translated">这个符号应该出现在至少一条语法规则的lhs中。这是最通用的语法类别,解析器最终会将每个输入字符串解析为这个类别。</target>
        </trans-unit>
        <trans-unit id="f08fbd9f459967f29635f3f9f2adf9603031def1" translate="yes" xml:space="preserve">
          <source>This symmetric property is heavily used in our property test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f51a949c8210df35958e734e70df198be7b37d8" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt; dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ad3ed484ba9b2b41f2325fc27244234c66f278" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt;dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="translated">此语法等效于Runtime_Tools中的跟踪模式（请参见 &lt;code&gt;dbg(3)&lt;/code&gt; ）模块中使用的语法。</target>
        </trans-unit>
        <trans-unit id="47928f153f260fce7ed8db1828b373dc61ec71dc" translate="yes" xml:space="preserve">
          <source>This table lists the retired cipher names in the first column and suggests names to replace them with in the second column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2b2d8d451101694a58799b8409428a148a8058" translate="yes" xml:space="preserve">
          <source>This takes &lt;code&gt;H&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; in all possible ways. The result is the set of all lists &lt;code&gt;[H|T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the set of all possible permutations of &lt;code&gt;L&lt;/code&gt;, with &lt;code&gt;H&lt;/code&gt; removed:</source>
          <target state="translated">这会以所有可能的方式从 &lt;code&gt;L&lt;/code&gt; 夺取 &lt;code&gt;H&lt;/code&gt; 。结果是所有列表 &lt;code&gt;[H|T]&lt;/code&gt; 的集合，其中 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;L&lt;/code&gt; 的所有可能置换的集合，其中 &lt;code&gt;H&lt;/code&gt; 被除去：</target>
        </trans-unit>
        <trans-unit id="618f3633ac8c2cadd4289f1c5621d970e601a5ca" translate="yes" xml:space="preserve">
          <source>This term is the encoding for external funs: &lt;code&gt;fun M:F/A&lt;/code&gt;.</source>
          <target state="translated">该术语是外部的玩意儿编码： &lt;code&gt;fun M:F/A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beb3ae0ca905f496ce783ad12cff60bb9bb87bbd" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 0 of the external format; it has been superseded by &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此术语在外部格式的次要版本0中使用；它已被 &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; 取代。</target>
        </trans-unit>
        <trans-unit id="b517e1702cae7ec8ee019fdb69c857aa5330cfd8" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 1 of the external format.</source>
          <target state="translated">这个词用在外部格式的小版本1中。</target>
        </trans-unit>
        <trans-unit id="0860084b170b958eacacb8679369f69a7b4a4046" translate="yes" xml:space="preserve">
          <source>This term represents a bitstring whose length in bits does not have to be a multiple of 8. The &lt;code&gt;Len&lt;/code&gt; field is an unsigned 4 byte integer (big-endian). The &lt;code&gt;Bits&lt;/code&gt; field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant.</source>
          <target state="translated">该术语表示一个位串，其位长度不必是8的倍数 &lt;code&gt;Len&lt;/code&gt; 字段是一个无符号的4字节整数（big-endian）。所述 &lt;code&gt;Bits&lt;/code&gt; 字段是在最后一个字节用于在数据字段中的比特（1-8）的数量，从最显著位到最低显著计数。</target>
        </trans-unit>
        <trans-unit id="108bbd5cab7129c54f675f7643a23fb10026ce1d" translate="yes" xml:space="preserve">
          <source>This test specification declares that &lt;code&gt;node1@host1&lt;/code&gt; is to be started using the user callback function &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt;, and nodes &lt;code&gt;node1@host2&lt;/code&gt; and &lt;code&gt;node2@host2&lt;/code&gt; are to be started with the default callback module &lt;code&gt;ct_slave&lt;/code&gt;. The specified username and password are used to log on to remote host &lt;code&gt;host2&lt;/code&gt;. Also, function &lt;code&gt;module:function/0&lt;/code&gt; is evaluated on &lt;code&gt;node1@host3&lt;/code&gt;, and the result of this call is printed to the log.</source>
          <target state="translated">该测试规范声明将使用用户回调函数 &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt; 启动 &lt;code&gt;node1@host1&lt;/code&gt; ，并使用默认回调模块 &lt;code&gt;ct_slave&lt;/code&gt; 来启动节点 &lt;code&gt;node1@host2&lt;/code&gt; 和 &lt;code&gt;node2@host2&lt;/code&gt; 。指定的用户名和密码用于登录到远程主机 &lt;code&gt;host2&lt;/code&gt; 。同样，在 &lt;code&gt;node1@host3&lt;/code&gt; 上评估function &lt;code&gt;module:function/0&lt;/code&gt; ，并将此调用的结果打印到日志中。</target>
        </trans-unit>
        <trans-unit id="e29f7e984adbbfe8a53af166b10808cfa43c1c97" translate="yes" xml:space="preserve">
          <source>This tests all object files in the specified directory, as if they had been individually specified using &lt;code&gt;{file, FileName}&lt;/code&gt;.</source>
          <target state="translated">这将测试指定目录中的所有目标文件，就像使用 &lt;code&gt;{file, FileName}&lt;/code&gt; 分别指定了它们一样。</target>
        </trans-unit>
        <trans-unit id="76191fd55833467474b9c8b3bbd30d057e2c02a5" translate="yes" xml:space="preserve">
          <source>This the formatter callback function to be called from handlers. The log event is processed as follows:</source>
          <target state="translated">这是要从处理程序中调用的formatter回调函数。日志事件的处理方法如下。</target>
        </trans-unit>
        <trans-unit id="a753a4a3983a27e7aa021fa6ea24ccc7d272be01" translate="yes" xml:space="preserve">
          <source>This time argument 2 is used, which is the second element in the tuple. If this returns the atom &lt;code&gt;false&lt;/code&gt;, fred is not logged on and the following message is sent:</source>
          <target state="translated">使用此时间参数2，它是元组中的第二个元素。如果返回原子 &lt;code&gt;false&lt;/code&gt; ，则fred不会登录，并发送以下消息：</target>
        </trans-unit>
        <trans-unit id="15904ce64792364db6d7744d6d49fc6072f3ad19" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt; time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fffaa6a8f0644a7ea4fa7c7c74c76ec90d774c" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">在一般情况下，此时间&lt;strong&gt;不是&lt;/strong&gt;单调增加的时间。有关更多信息，请参见《用户指南》中的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="49beb73df376b7dea84521a1c52301d5531a79e4" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time.</source>
          <target state="translated">此时间&lt;strong&gt;不是&lt;/strong&gt;单调增加的时间。</target>
        </trans-unit>
        <trans-unit id="3748262d456a936f46c1ed22dababf257bb3fa6f" translate="yes" xml:space="preserve">
          <source>This time may or may not be an accurate view of POSIX time, and may or may not align with &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. The runtime system works towards aligning the two system times. Depending on the &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used, this can be achieved by letting Erlang system time perform a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此时间可能是POSIX时间的准确视图，也可能不是，并且可能与 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 不一致。运行时系统致力于使两个系统时间对齐。根据所使用的 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; ，可以通过让Erlang系统时间执行 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="83d87d01faae0b3a7fef0f76f0e3a3892ae23062" translate="yes" xml:space="preserve">
          <source>This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;.</source>
          <target state="translated">这次第一个断言看前面六个字符,检查前三个是数字,然后第二个断言检查前面三个字符是不是 &quot;999&quot;。</target>
        </trans-unit>
        <trans-unit id="14391b08125b325189f3dcbd403d72965af6b345" translate="yes" xml:space="preserve">
          <source>This time, since the shell was not involved, no other work was done in the system during the profiling. If you retry the same example with a freshly started Erlang emulator, but omit the command &lt;code&gt;l(random)&lt;/code&gt;, the analysis will show a lot more function calls done by &lt;code&gt;code_server&lt;/code&gt; and others to automatically load the module &lt;code&gt;random&lt;/code&gt;.</source>
          <target state="translated">这次，由于不涉及外壳，因此在概要分析期间，系统中没有其他工作。如果您使用刚启动的Erlang仿真 &lt;code&gt;code_server&lt;/code&gt; 试相同的示例，但是省略了命令 &lt;code&gt;l(random)&lt;/code&gt; ，则分析将显示code_server和其他人执行的许多函数调用，以自动 &lt;code&gt;random&lt;/code&gt; 加载模块。</target>
        </trans-unit>
        <trans-unit id="22a9f149405034822a960ba22d2e8646cd23a4b4" translate="yes" xml:space="preserve">
          <source>This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use.</source>
          <target state="translated">这一次,先尝试递归的替代方案,并继续递归,直到用完字符,这时递归失败。但这次我们有另一个更高层次的备选方案可以尝试。这就是显著的区别:在前一种情况下,剩余的备选方案是在更深的递归层次上,PCRE无法使用。</target>
        </trans-unit>
        <trans-unit id="c60619daf599e1009f83ff3339a4a66e29dc068d" translate="yes" xml:space="preserve">
          <source>This timer is started when the &lt;strong&gt;first&lt;/strong&gt; reply to an asynchronous request (issued using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; function) arrives. As long as this timer is running, replies will be delivered via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function, with their &quot;arrival number&quot; (see &lt;code&gt;UserReply&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function).</source>
          <target state="translated">当对异步请求的&lt;strong&gt;第一次&lt;/strong&gt;答复（使用 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; 函数发出）到达时，将启动此计时器。只要该定时器正在运行，答复将通过递送 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; 回调函数，与他们的&amp;ldquo;到达号码&amp;rdquo;（见 &lt;code&gt;UserReply&lt;/code&gt; 所述的 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; 回调函数）。</target>
        </trans-unit>
        <trans-unit id="7f582a8bac4499f4041fc098c02442c6d51efa18" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; (e.g. the last of the segment which makes up the reply) is received, but all segments has not yet been received.</source>
          <target state="translated">当接收到由 &lt;code&gt;segmentation complete token&lt;/code&gt; 指示的分段（例如，组成答复的分段的最后一个），但尚未接收到所有分段时，将启动此计时器。</target>
        </trans-unit>
        <trans-unit id="e5f2ade158232a7f92c6ed91597d402fd153194a" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; is received, but all segments has not yet been received.</source>
          <target state="translated">当接收到由 &lt;code&gt;segmentation complete token&lt;/code&gt; 指示的分段但尚未接收到所有分段时，将启动此计时器。</target>
        </trans-unit>
        <trans-unit id="706cbfbf9ab1807332ea2d94bd3ad6011d82aa07" translate="yes" xml:space="preserve">
          <source>This transaction can write the text &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 1000 times to the terminal. However, &lt;code&gt;Mnesia&lt;/code&gt; guarantees that each transaction will eventually run. As a result, &lt;code&gt;Mnesia&lt;/code&gt; is not only deadlock free, but also livelock free.</source>
          <target state="translated">此事务可以将文本 &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 终端1000次。但是， &lt;code&gt;Mnesia&lt;/code&gt; 保证每笔交易将最终运行。结果， &lt;code&gt;Mnesia&lt;/code&gt; 不仅无死锁，而且无活锁。</target>
        </trans-unit>
        <trans-unit id="c15707ecd3d8e52159c361dec50a35ae8f4adf88" translate="yes" xml:space="preserve">
          <source>This transaction returns the list &lt;code&gt;[{foo,1,3}]&lt;/code&gt; if table &lt;code&gt;foo&lt;/code&gt; is of type &lt;code&gt;set&lt;/code&gt;. However, the list &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; is returned if the table is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果表 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;set&lt;/code&gt; 类型 &lt;code&gt;[{foo,1,3}]&lt;/code&gt; 此事务返回列表[{foo，1,3}]。但是，如果表的类型为 &lt;code&gt;bag&lt;/code&gt; ,则返回列表 &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="896c645fd7197a5da200f81b1127c1a22b3d1e2d" translate="yes" xml:space="preserve">
          <source>This transformation renames a &lt;code&gt;select_val/3&lt;/code&gt; instruction with a constant source operand to &lt;code&gt;i_const_select_val/3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3aa65821e6e6bbdfa16d2cf5e6359a478a61f30" translate="yes" xml:space="preserve">
          <source>This transformation rule matches a call to the BIF &lt;code&gt;element/2&lt;/code&gt;. The operands will be captured and the function &lt;code&gt;gen_element()&lt;/code&gt; will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fb13c45e90d79c73f06a24d887642b21d76da" translate="yes" xml:space="preserve">
          <source>This translates to &lt;code&gt;TCP_NOPUSH&lt;/code&gt; on BSD and to &lt;code&gt;TCP_CORK&lt;/code&gt; on Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf13712351a4aa96ae94ff06cddb20f5ef75fe11" translate="yes" xml:space="preserve">
          <source>This tries to match &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; or &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; twice. If &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; appears, the function returns &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt;.</source>
          <target state="translated">这会尝试两次匹配 &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 。如果出现 &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; ，该函数将返回 &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53c27958e7fca3ba05175a738c3a146371fd4e49" translate="yes" xml:space="preserve">
          <source>This tuple only exists if &lt;code&gt;Function&lt;/code&gt; can be used with different clocks. &lt;code&gt;ClockId&lt;/code&gt; corresponds to the clock identifier used when calling &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;Function&lt;/code&gt; 可与不同的时钟一起使用时，该元组才存在。 &lt;code&gt;ClockId&lt;/code&gt; 对应于调用 &lt;code&gt;Function&lt;/code&gt; 时使用的时钟标识符。</target>
        </trans-unit>
        <trans-unit id="aa7524355b5ee56dd866d3d3779a64205a992024" translate="yes" xml:space="preserve">
          <source>This type defines all addresses (and flags) associated with the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceff633d5c12b0ab1b989cd600fd3b0c1f9b57c7" translate="yes" xml:space="preserve">
          <source>This type is assigned in Erlang as follows:</source>
          <target state="translated">这个类型在Erlang中分配如下。</target>
        </trans-unit>
        <trans-unit id="34e89a0a89b0d1a14764e553fc94c9f4fbe45d6d" translate="yes" xml:space="preserve">
          <source>This type is further described in application &lt;code&gt;xmerl&lt;/code&gt;.</source>
          <target state="translated">在应用程序 &lt;code&gt;xmerl&lt;/code&gt; 中进一步描述了这种类型。</target>
        </trans-unit>
        <trans-unit id="6be71fbb0606c9b749f47ff7cbc7a8e0ca516ae1" translate="yes" xml:space="preserve">
          <source>This type of time-out is useful for example to act on inactivity. Let us restart the code sequence if no button is pressed for say 30 seconds:</source>
          <target state="translated">这种类型的超时是很有用的,例如在不活动的情况下。让我们重新开始代码序列,如果30秒内没有按下按钮。</target>
        </trans-unit>
        <trans-unit id="0dd216aebaebb2374c204746cffeb0b8a3bfa66e" translate="yes" xml:space="preserve">
          <source>This utility function is used to create a formatted (pretty printable) string of the error reason received from either:</source>
          <target state="translated">这个实用函数用于创建一个格式化的(漂亮的可打印的)从任何一个收到的错误原因的字符串。</target>
        </trans-unit>
        <trans-unit id="e90f513c2d724696028de83a41a04ca02c00b03d" translate="yes" xml:space="preserve">
          <source>This utility is specific to Windows NT/2000/XP (and later versions of Windows). It allows Erlang emulators to run as services on the Windows system, allowing embedded systems to start without any user needing to log on. The emulator started in this way can be manipulated through the Windows services applet in a manner similar to other services.</source>
          <target state="translated">这个实用程序是专门针对Windows NT/2000/XP(以及更高版本的Windows)的,它允许Erlang仿真器在Windows系统上作为服务运行,允许嵌入式系统在不需要任何用户登录的情况下启动。它允许Erlang仿真器在Windows系统上作为服务运行,允许嵌入式系统在不需要任何用户登录的情况下启动。以这种方式启动的仿真器可以通过Windows服务小程序进行操作,其方式与其他服务类似。</target>
        </trans-unit>
        <trans-unit id="b55cb392aed5fc4d4c203d5436538e3f6a69fde3" translate="yes" xml:space="preserve">
          <source>This validation callback will be executed before any heartbeat is sent to the port program. For the validation to succeed it needs to return with the value &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">该验证回调将在任何心跳发送到端口程序之前执行。为了使验证成功，它需要返回 &lt;code&gt;ok&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3b8b5c1eef6ea78b8a30fd3fe8ec2afd6d40564e" translate="yes" xml:space="preserve">
          <source>This value can also be set through (OS) environment variable &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt;.</source>
          <target state="translated">也可以通过（OS）环境变量 &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt; 设置此值。</target>
        </trans-unit>
        <trans-unit id="58b09f82dfd17c02b5cc9bb38621d7a9dc8cc490" translate="yes" xml:space="preserve">
          <source>This value can be set at startup by passing command-line argument &lt;code&gt;+SDio&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">可以在启动时通过在 &lt;code&gt;erl(1)&lt;/code&gt; 中传递命令行参数 &lt;code&gt;+SDio&lt;/code&gt; 来设置此值。</target>
        </trans-unit>
        <trans-unit id="f2f1511a226b28ee2f7a6351d90cc98e92a8e944" translate="yes" xml:space="preserve">
          <source>This value might wrap due to limitations in the underlying functionality provided by the operating system that is used.</source>
          <target state="translated">由于使用的操作系统提供的底层功能的限制,这个值可能会被包裹。</target>
        </trans-unit>
        <trans-unit id="ae87da20fd16a3057a07a29b3ed216aa69d1b30e" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a disk_log sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">这个值,以毫秒为单位,指定处理程序进行disk_log同步操作的频率,以便将缓冲数据写入磁盘。处理程序会反复尝试这个操作,但是只有当有东西被记录下来的时候才会执行新的同步操作。</target>
        </trans-unit>
        <trans-unit id="562ee5839a71bc34778a37d5ff1caee77199d71c" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a file sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">这个值,以毫秒为单位,指定处理程序进行文件同步操作的频率,以便将缓冲数据写入磁盘。处理程序会反复尝试该操作,但只有在实际记录了某些内容时才会执行新的同步。</target>
        </trans-unit>
        <trans-unit id="8a7dae834a17e1bfd7dcc5067b03add360f4e974" translate="yes" xml:space="preserve">
          <source>This variable sets the maximum size of a crash dump file in bytes. The crash dump will be truncated if this limit is exceeded. If the variable is not set, no size limit is enforced by default. If the variable is set to &lt;code&gt;0&lt;/code&gt;, the runtime system does not even attempt to write a crash dump file.</source>
          <target state="translated">此变量设置故障转储文件的最大大小（以字节为单位）。如果超出此限制，崩溃转储将被截断。如果未设置该变量，则默认情况下不强制大小限制。如果变量设置为 &lt;code&gt;0&lt;/code&gt; ，则运行时系统甚至不会尝试写入故障转储文件。</target>
        </trans-unit>
        <trans-unit id="c8c996bd75b6c1e556e40ae90ed97ed437560b07" translate="yes" xml:space="preserve">
          <source>This variant is kept for compatibility.</source>
          <target state="translated">这个变体是为了兼容性而保留的。</target>
        </trans-unit>
        <trans-unit id="f23ebd696e347931712dab86d1982b0ebcb811ea" translate="yes" xml:space="preserve">
          <source>This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails.</source>
          <target state="translated">这个动词会使匹配成功结束,跳过模式的剩余部分。但是,当它在作为子程序调用的子模式内时,只有该子模式被成功结束。然后在外层继续匹配。如果在正断言中触发了(*ACCEPT),则断言成功;在负断言中,则断言失败。</target>
        </trans-unit>
        <trans-unit id="7d1a0e9b710171a3224e64c914a5b25f817e9dd9" translate="yes" xml:space="preserve">
          <source>This version (still) include three &lt;code&gt;pre version 3&lt;/code&gt; variants of the version 3 codec, beside the proper version 3. These versions, &lt;code&gt;prev3a | prev3b | prev3c&lt;/code&gt;, are &lt;strong&gt;deprecated&lt;/strong&gt;, and will be removed in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08ddef725078632007c7d27f955f2e16c27447f" translate="yes" xml:space="preserve">
          <source>This version encode atoms that can be represented by a latin1 string using latin1 encoding while only atoms that cannot be represented by latin1 are encoded using utf8.</source>
          <target state="translated">这个版本使用latin1编码对可以用latin1字符串表示的原子进行编码,而只有不能用latin1表示的原子使用utf8编码。</target>
        </trans-unit>
        <trans-unit id="d758c1fa288ff4bea6ef5e3e118de5ef6067101b" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;wrap_log_reader&lt;/code&gt; does not detect if &lt;code&gt;disk_log&lt;/code&gt; wraps to a new index file between a call to &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; and the first call to &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt;. If this occurs, the call to &lt;code&gt;chunk()&lt;/code&gt; reads the last logged items in the log file, as the opened index file was truncated by &lt;code&gt;disk_log&lt;/code&gt;.</source>
          <target state="translated">这个版本的 &lt;code&gt;wrap_log_reader&lt;/code&gt; 不会检测 &lt;code&gt;disk_log&lt;/code&gt; 是否在调用 &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; 和第一次调用 &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt; 之间包装到新的索引文件。如果发生这种情况，对调用 &lt;code&gt;chunk()&lt;/code&gt; 的操作将读取日志文件中最后记录的项目，因为打开的索引文件被 &lt;code&gt;disk_log&lt;/code&gt; 截断了。</target>
        </trans-unit>
        <trans-unit id="7892b8b3e220dc2d6df9f4226b75eda81b8a6c0a" translate="yes" xml:space="preserve">
          <source>This version of the stack is compliant with:</source>
          <target state="translated">这个版本的堆栈符合:</target>
        </trans-unit>
        <trans-unit id="240472a34becd16e12bb3376c31742854774737c" translate="yes" xml:space="preserve">
          <source>This version of the stack supports version 1, 2 and 3 as defined by:</source>
          <target state="translated">这个版本的堆栈支持以下定义的版本1、2和3。</target>
        </trans-unit>
        <trans-unit id="12b130ec0f7a537e5f469d318f402ce06f564884" translate="yes" xml:space="preserve">
          <source>This way the decoder will detect which version is used and then use the proper decoder.</source>
          <target state="translated">这样解码器会检测到使用的是哪个版本,然后使用合适的解码器。</target>
        </trans-unit>
        <trans-unit id="1fab39fc6a9980decfad2e7adaa7dbca6690bf5b" translate="yes" xml:space="preserve">
          <source>This weighted scheduler utilization will reach &lt;code&gt;1.0&lt;/code&gt; when schedulers are active the same amount of time as maximum available CPU time. If more schedulers exist than available logical processors, this value may be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">当调度程序处于活动状态的时间与最大可用CPU时间相同时，此加权调度程序利用率将达到 &lt;code&gt;1.0&lt;/code&gt; 。如果存在比可用逻辑处理器更多的调度程序，则此值可能大于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26f1c0ecf9835b048ce7fdf3cb11bce5cf430e0d" translate="yes" xml:space="preserve">
          <source>This will be transform into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这将转换为对 &lt;code&gt;my_table&lt;/code&gt; 的一次调用：</target>
        </trans-unit>
        <trans-unit id="5959df48b0bcfac9f4ae84eabd6aeaab1c573506" translate="yes" xml:space="preserve">
          <source>This will be transform into two calls to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">这将转换为对 &lt;code&gt;my_table&lt;/code&gt; 的两次调用：</target>
        </trans-unit>
        <trans-unit id="b0938e7a4bcaf966d8f8e1648d8bf77602bdb131" translate="yes" xml:space="preserve">
          <source>This will create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">这将在当前目录中创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="a8c674397ac895af2f7b4229947a7481b00df7c1" translate="yes" xml:space="preserve">
          <source>This will extract the string literal &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; into the variable &lt;code&gt;Foo&lt;/code&gt;. Note the use of the anonymous variable &lt;code&gt;9090&lt;/code&gt; to ignore the line number. To match and also bind a metavariable that must be an integer literal, we can use the convention of ending the integer with a 9, turning it into a Q-prefixed variable on the Erlang level (see the previous section).</source>
          <target state="translated">这会将字符串文字 &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; 提取到变量 &lt;code&gt;Foo&lt;/code&gt; 中。请注意使用匿名变量 &lt;code&gt;9090&lt;/code&gt; 来忽略行号。为了匹配并绑定必须是整数文字的元变量，我们可以使用以下约定：以9结尾的整数，将其转换为Erlang级别上的Q前缀变量（请参见上一节）。</target>
        </trans-unit>
        <trans-unit id="6844398e7182f73065c78df4a613dbb5c67fbf34" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;copy_save&lt;/code&gt; option is enabled; see &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt;.</source>
          <target state="translated">如果启用了 &lt;code&gt;copy_save&lt;/code&gt; 选项，则此操作将失败；参见 &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161516cb1d32cdac4670da18a1c368a544091541" translate="yes" xml:space="preserve">
          <source>This will have the following effect:</source>
          <target state="translated">这将产生以下效果:</target>
        </trans-unit>
        <trans-unit id="00ecf511290805869defd2329acd31f4e4c2838e" translate="yes" xml:space="preserve">
          <source>This will print the following in the default log:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876e81f13e31f8d2ed30e08e0458e7cd79ff32e8" translate="yes" xml:space="preserve">
          <source>This will print the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741ddd866b7f0cb141911125a2b18ae0245fffe3" translate="yes" xml:space="preserve">
          <source>This will produce a beam.smp.debug executable. The file are installed along side with the normal (opt) version &lt;code&gt;beam.smp&lt;/code&gt;.</source>
          <target state="translated">这将产生beam.smp.debug可执行文件。该文件与常规（opt）版本 &lt;code&gt;beam.smp&lt;/code&gt; 一起安装。</target>
        </trans-unit>
        <trans-unit id="4a278059021fec133659ebfed89d918e76c5e908" translate="yes" xml:space="preserve">
          <source>This will start a &lt;code&gt;Collector&lt;/code&gt;, a &lt;code&gt;Viewer&lt;/code&gt; and also start the tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The &lt;code&gt;Raw Trace Data&lt;/code&gt; is collected by the &lt;code&gt;Collector&lt;/code&gt; and a view of it is displayed on the screen by the &lt;code&gt;Viewer&lt;/code&gt;. You can define your own &quot;views&quot; of the data by implementing your own &lt;code&gt;Filter&lt;/code&gt; functions and register them in the &lt;code&gt;Viewer&lt;/code&gt;.</source>
          <target state="translated">这将启动一个 &lt;code&gt;Collector&lt;/code&gt; ，一个 &lt;code&gt;Viewer&lt;/code&gt; ,并且也开始跟踪 &lt;code&gt;et:trace_me/5&lt;/code&gt; 函数调用。的 &lt;code&gt;Raw Trace Data&lt;/code&gt; 是由收集的 &lt;code&gt;Collector&lt;/code&gt; 和它的一个视图显示由在屏幕上 &lt;code&gt;Viewer&lt;/code&gt; 。您可以通过实现自己的 &lt;code&gt;Filter&lt;/code&gt; 函数并将其注册到 &lt;code&gt;Viewer&lt;/code&gt; 中来定义自己的数据&amp;ldquo;视图&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f434217aa97015d51cfaae19becfd875effa6d0a" translate="yes" xml:space="preserve">
          <source>This works even if &lt;code&gt;A&lt;/code&gt; is less than &lt;code&gt;-1.0&lt;/code&gt;, since in that case, &lt;code&gt;math:sqrt/1&lt;/code&gt; is never evaluated.</source>
          <target state="translated">即使 &lt;code&gt;A&lt;/code&gt; 小于 &lt;code&gt;-1.0&lt;/code&gt; ，此方法也有效，因为在这种情况下，永远不会评估 &lt;code&gt;math:sqrt/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3252af803922384f63b13c1da6ba4644d77b472e" translate="yes" xml:space="preserve">
          <source>This works for those codecs that support partial decode of the version, currently &lt;strong&gt;text&lt;/strong&gt;, and ber_bin (&lt;code&gt;megaco_binary_encoder&lt;/code&gt; and &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt;).</source>
          <target state="translated">对于那些支持版本，当前&lt;strong&gt;文本&lt;/strong&gt;和ber_bin（ &lt;code&gt;megaco_binary_encoder&lt;/code&gt; 和 &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt; ）的部分解码的编解码器，此方法适用。</target>
        </trans-unit>
        <trans-unit id="68fb3cd1bc230ff55ec815a8606d4b126de4061a" translate="yes" xml:space="preserve">
          <source>This would give the same result as the earlier examples, namely:</source>
          <target state="translated">这样一来,就会得出与前面的例子相同的结果,即:</target>
        </trans-unit>
        <trans-unit id="f41ff74a32e2f2c5a120967bdd256a9d1fcf2924" translate="yes" xml:space="preserve">
          <source>This yields the following environment for &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">这为 &lt;code&gt;myapp&lt;/code&gt; 产生了以下环境：</target>
        </trans-unit>
        <trans-unit id="d50cfaeffc3214625910320412c7d6aae3538c57" translate="yes" xml:space="preserve">
          <source>Those option forms are kept only for compatibility and should not be used in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af7a09a50fb9a8406c64e603ab93839d0eeadbb" translate="yes" xml:space="preserve">
          <source>Those service could - and should - be disabled when they are not needed. The options &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are enabled per default but could be set to &lt;code&gt;disabled&lt;/code&gt; if not needed. The same options could also install handlers for the string(s) passed from the client to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfb63a03667f91e2dddce0870e2cddb4d2428fc" translate="yes" xml:space="preserve">
          <source>Those that are not part of an identified script are lumped together as &quot;Common&quot;. The following is the current list of scripts:</source>
          <target state="translated">那些不属于已确定的脚本的脚本被归纳为 &quot;通用&quot;。以下是当前的脚本清单。</target>
        </trans-unit>
        <trans-unit id="e0fb7ae92ade7541465dddf7bdde5e485e470cba" translate="yes" xml:space="preserve">
          <source>Those warnings cannot be disabled (except by disabling all warnings).</source>
          <target state="translated">这些警告不能被禁用(除非禁用所有警告)。</target>
        </trans-unit>
        <trans-unit id="c351ee3b38329481117c9035b830002ad412235a" translate="yes" xml:space="preserve">
          <source>Thread identifier.</source>
          <target state="translated">线程标识符。</target>
        </trans-unit>
        <trans-unit id="4f9adbdf3e9b777ac0a0a507f193e4d00d4e660e" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt; erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472d223957fc2ad616dbfe0655959f460d590ae4" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="translated">线程选项结构传递给 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 。存在以下字段：</target>
        </trans-unit>
        <trans-unit id="2d38b72cd000a892fe63ed8ba79ccaabfe4c2e80" translate="yes" xml:space="preserve">
          <source>Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are &amp;lt; 256, but they do work in this mode. The following are the extra escape sequences:</source>
          <target state="translated">提供了三个与字符具有特定属性匹配的转义序列。在8位非UTF-8模式下，这些序列仅限于测试代码点小于256的字符，但它们在此模式下有效。以下是额外的转义序列：</target>
        </trans-unit>
        <trans-unit id="48145c695e12f789bd065e16fe1bba615544dbc8" translate="yes" xml:space="preserve">
          <source>Three network messages to execute the two-phase commit protocol</source>
          <target state="translated">执行两阶段提交协议的三个网络消息。</target>
        </trans-unit>
        <trans-unit id="5b4d080b2f7b28c85cb580a4943bbfa952b77805" translate="yes" xml:space="preserve">
          <source>Three predefined resolve functions exist: &lt;code&gt;random_exit_name/3&lt;/code&gt;, &lt;code&gt;random_notify_name/3&lt;/code&gt;, and &lt;code&gt;notify_all_name/3&lt;/code&gt;. If no &lt;code&gt;Resolve&lt;/code&gt; function is defined, &lt;code&gt;random_exit_name&lt;/code&gt; is used. This means that one of the two registered processes is selected as correct while the other is killed.</source>
          <target state="translated">存在三个预定义的解析函数： &lt;code&gt;random_exit_name/3&lt;/code&gt; ， &lt;code&gt;random_notify_name/3&lt;/code&gt; 和 &lt;code&gt;notify_all_name/3&lt;/code&gt; 。如果未定义 &lt;code&gt;Resolve&lt;/code&gt; 功能，则使用 &lt;code&gt;random_exit_name&lt;/code&gt; 。这意味着两个注册进程中的一个被选择为正确，而另一个被杀死。</target>
        </trans-unit>
        <trans-unit id="789fe986bc68eef06a581bacefa09c9f316ad600" translate="yes" xml:space="preserve">
          <source>Three types of Dets tables exist:</source>
          <target state="translated">存在三种类型的Dets表。</target>
        </trans-unit>
        <trans-unit id="de17dda2df1b0a4a41a2a36ed513ae1a8fa82e62" translate="yes" xml:space="preserve">
          <source>Three types of logs are supported: transfer logs, security logs, and error logs. The de-facto standard Common Logfile Format is used for the transfer and security logging. There are numerous statistics programs available to analyze Common Logfile Format. The Common Logfile Format looks as follows:</source>
          <target state="translated">支持三种类型的日志:传输日志、安全日志和错误日志。传输日志和安全日志使用事实上的标准通用日志文件格式。有许多统计程序可以用来分析通用日志文件格式。通用日志文件格式的样子如下。</target>
        </trans-unit>
        <trans-unit id="6e9b97eab33817fa09e3b807cdad0cad941b514c" translate="yes" xml:space="preserve">
          <source>Three-per-em space</source>
          <target state="translated">三次元空间</target>
        </trans-unit>
        <trans-unit id="353307ebea91bdeb49e95a772ca9672b8b9ff1c9" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">最大文件大小的阈值（以字节为单位）。如果超出限制，传输将中止。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81e689740a1ea2ba496a99261372d7eb5ff76c39" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">最大活动连接数的阈值。如果超出限制，则守护程序拒绝建立新连接。默认值为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5d2d9adf32dacfb55f57f6ed9d271632c69577" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</source>
          <target state="translated">最大重试次数的阈值。默认情况下,服务器/客户端在超时后最多重发5次消息。</target>
        </trans-unit>
        <trans-unit id="0ef311c86e366780b4c01dfd6e2377efaa407576" translate="yes" xml:space="preserve">
          <source>Through CTHs the results of tests and configuration functions can be manipulated. The main purpose to do this with CTHs is to allow common patterns to be abstracted out from test suites and applied to multiple test suites without duplicating any code. All the callback functions for a CTH follow a common interface described hereafter.</source>
          <target state="translated">通过CTHs可以对测试和配置函数的结果进行操作。使用CTH的主要目的是允许从测试套件中抽象出共同的模式,并应用于多个测试套件,而无需重复任何代码。一个CTH的所有回调函数都遵循下面描述的通用接口。</target>
        </trans-unit>
        <trans-unit id="0aa7d917559b259354cb862e1c7d69350b345c76" translate="yes" xml:space="preserve">
          <source>Through a trigger function with a match specification created with &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过具有 &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt; 创建的匹配规范的触发函数。</target>
        </trans-unit>
        <trans-unit id="dee8ee6675b19f7cc839a400403e3a6bdfc64698" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;Mnesia&lt;/code&gt; (on one node) can hang if a double fault occurs, that is, when two nodes crash simultaneously and one attempts to start when the other refuses to start, for example, because of a hardware error.</source>
          <target state="translated">因此， &lt;code&gt;Mnesia&lt;/code&gt; （在一个节点上）如果发生双重故障（即，两个节点同时崩溃并且一个节点尝试启动而另一个节点由于硬件错误而拒绝启动）时尝试挂起，则可能会挂起。</target>
        </trans-unit>
        <trans-unit id="08620ab1394e488e40f6d760c0e43eb52ae9ae1e" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ch3&lt;/code&gt; must be loaded before &lt;code&gt;m1&lt;/code&gt;, in the upgrade case, and conversely in the downgrade case. &lt;code&gt;m1&lt;/code&gt; is said to be &lt;strong&gt;dependent on&lt;/strong&gt;&lt;code&gt;ch3&lt;/code&gt;. In a release handling instruction, this is expressed by the &lt;code&gt;DepMods&lt;/code&gt; element:</source>
          <target state="translated">因此，在升级情况下， &lt;code&gt;ch3&lt;/code&gt; 必须在 &lt;code&gt;m1&lt;/code&gt; 之前加载，而在降级情况下，则相反。据说 &lt;code&gt;m1&lt;/code&gt; &lt;strong&gt;取决于&lt;/strong&gt; &lt;code&gt;ch3&lt;/code&gt; 。在发布处理指令中，这由 &lt;code&gt;DepMods&lt;/code&gt; 元素表示：</target>
        </trans-unit>
        <trans-unit id="f4aac5229f9aff631f4112d990ef52e941da8602" translate="yes" xml:space="preserve">
          <source>Thus, Erlang pids contain information about where the process executes. So if you know the pid of a process, the &quot;!&quot; operator can be used to send it a message disregarding if the process is on the same node or on a different node.</source>
          <target state="translated">因此,Erlang的pid包含了进程在哪里执行的信息,所以如果你知道一个进程的pid,可以用&quot;!&quot;操作符向它发送消息,而不管这个进程是在同一个节点还是在不同的节点。因此,如果你知道一个进程的pid,就可以使用&quot;!&quot;操作符向它发送一条消息,而不管这个进程是在同一个节点上还是在不同的节点上。</target>
        </trans-unit>
        <trans-unit id="6cc9ac17e54e53ed54d89ecd362584a70502cce6" translate="yes" xml:space="preserve">
          <source>Thus, each table is made up of records, where the first element is a record name and the second element of the table is a key, which identifies the particular record in that table. The combination of the table name and a key is an arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; called the OID. For more information about the relationship beween the record name and the table name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">因此，每个表都由记录组成，其中第一个元素是记录名称，表的第二个元素是关键字，它标识该表中的特定记录。表名和键的组合是两个称为OID的两个元组 &lt;code&gt;{Tab, Key}&lt;/code&gt; 。有关记录名称和表名称之间的关系的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98419cf3e6cb70f3d1ec7c30e6c6cd8e96f4569b" translate="yes" xml:space="preserve">
          <source>Thus, groups of users with identical cookie files get Erlang nodes that can communicate freely and without interference from the magic cookie system. Users who want to run nodes on separate file systems must make certain that their cookie files are identical on the different file systems.</source>
          <target state="translated">这样,拥有相同cookie文件的用户群就得到了可以自由通信的Erlang节点,而不受魔法cookie系统的干扰。用户如果想在不同的文件系统上运行节点,必须保证他们在不同文件系统上的cookie文件是相同的。</target>
        </trans-unit>
        <trans-unit id="8100fa7ba98e8e96e75fe52a1370cae3f3496b11" translate="yes" xml:space="preserve">
          <source>Thus, in Erlang the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to encode a boolean value.</source>
          <target state="translated">因此，在Erlang中，原子 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 用于编码布尔值。</target>
        </trans-unit>
        <trans-unit id="6e7ecce73f034bf35ecbb506fb930930ac4b3eff" translate="yes" xml:space="preserve">
          <source>Thus, it can be assumed that if an application wants to use tables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, the application must perform some action similar to following before it can use the tables:</source>
          <target state="translated">因此，可以假定，如果应用程序要使用表 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，则该应用程序必须执行类似于以下的某些操作才能使用表：</target>
        </trans-unit>
        <trans-unit id="7e5bc2487ff82b85d2e3b10893d75ddc6f14f8fa" translate="yes" xml:space="preserve">
          <source>Thus, knowing the allowed structure it is easy to write a program that traverses the data structure and picks the information in the xmlElements records with name date.</source>
          <target state="translated">因此,知道了允许的结构,就很容易写出一个遍历数据结构的程序,并在xmlElements记录中选取名称为date的信息。</target>
        </trans-unit>
        <trans-unit id="b2e92eacbda98564b7e1dba01abee128e6082f80" translate="yes" xml:space="preserve">
          <source>Thus, the call &lt;code&gt;ch3:alloc()&lt;/code&gt; returns the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the &lt;code&gt;gen_server&lt;/code&gt; then waits for new requests, now with an updated list of available channels.</source>
          <target state="translated">因此，调用 &lt;code&gt;ch3:alloc()&lt;/code&gt; 返回分配的通道 &lt;code&gt;Ch&lt;/code&gt; ，然后 &lt;code&gt;gen_server&lt;/code&gt; 等待新请求，现在具有可用通道的更新列表。</target>
        </trans-unit>
        <trans-unit id="9ebad642bddf4ab3db22dd4beeeeb7f4311403f9" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-COMMUNITY-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-COMMUNITY-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="a7c61a5b14ab98813376fed50c0cd8d251b07679" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-FRAMEWORK-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-FRAMEWORK-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="612f9db5bba916759b754b605a4e539b1a5e5a7e" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-NOTIFICATION-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-NOTIFICATION-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="9d1588ecea3ad2284ae9aa05caccc396d78985d5" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-STANDARD-MIB和SNMPv2-MIB中的数据来自配置文件。</target>
        </trans-unit>
        <trans-unit id="43f6071a8cb0a08a947926938c79fe87f3b23556" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-TARGET-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,在调用该函数后,SNMP-TARGET-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="698103ec7a5a24bef7840c9a9eb88301e5ac5c6b" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,在调用该函数后,SNMP-USER-BASED-SM-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="b154aa3e0b0b0cb0972c7b7c21e5fa2a7b63dbbc" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">因此,调用该函数后,SNMP-VIEW-BASED-ACM-MIB中的数据就是配置文件中的数据。</target>
        </trans-unit>
        <trans-unit id="ece286b7b7e10c58b8006a0db1d818bda1598793" translate="yes" xml:space="preserve">
          <source>Thus, the defined callbacks are as follows:</source>
          <target state="translated">因此,定义的回调如下。</target>
        </trans-unit>
        <trans-unit id="c7283b7df46e07452f871697fbbb43dfaeb34c85" translate="yes" xml:space="preserve">
          <source>Thus, the following pattern matches all possible clauses:</source>
          <target state="translated">因此,以下模式符合所有可能的分句。</target>
        </trans-unit>
        <trans-unit id="a6da41a12dddbe97c927f5b83e0ea21b128613a3" translate="yes" xml:space="preserve">
          <source>Thus, the main representation of test sets is &lt;strong&gt;deep lists&lt;/strong&gt;, and a simple test object can be viewed as a test set containing only a single test; there is no difference between &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">因此，测试集的主要表示形式是&lt;strong&gt;深层列表&lt;/strong&gt;，一个简单的测试对象可以视为仅包含一个测试的测试集。 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;[T]&lt;/code&gt; 之间没有区别。</target>
        </trans-unit>
        <trans-unit id="72fc65dc129a4472605c016017814aa86198846c" translate="yes" xml:space="preserve">
          <source>Thus, the module is called &lt;strong&gt;tut&lt;/strong&gt;. Notice the full stop &quot;.&quot; at the end of the line. The files which are used to store the module must have the same name as the module but with the extension &quot;.erl&quot;. In this case the file name is &lt;code&gt;tut.erl&lt;/code&gt;. When using a function in another module, the syntax &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; is used. So the following means call function &lt;code&gt;double&lt;/code&gt; in module &lt;code&gt;tut&lt;/code&gt; with argument &quot;10&quot;.</source>
          <target state="translated">因此，该模块称为&lt;strong&gt;tut&lt;/strong&gt;。注意句号&amp;ldquo;。&amp;rdquo;在该行的末尾。用于存储模块的文件必须与模块具有相同的名称，但扩展名为&amp;ldquo; .erl&amp;rdquo;。在这种情况下，文件名是 &lt;code&gt;tut.erl&lt;/code&gt; 。在另一个模块中使用函数时，将使用语法 &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; 。因此，以下方法意味着在模块 &lt;code&gt;tut&lt;/code&gt; 中使用参数&amp;ldquo; 10&amp;rdquo; 来调用 &lt;code&gt;double&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c34ce3a6ce18ac5cd93d950cae3e6a6b1eaefbd7" translate="yes" xml:space="preserve">
          <source>Thus, two instances of the application run simultaneously during the takeover, so that data can be transferred from the old to the new instance. If this is not an acceptable behavior, parts of the old instance can be shut down when the new instance is started. However, the application cannot be stopped entirely, at least the top supervisor must remain alive.</source>
          <target state="translated">因此,在接管过程中,应用程序的两个实例同时运行,因此数据可以从旧实例转移到新实例。如果这不是一种可接受的行为,可以在新实例启动时关闭旧实例的部分内容。但是,应用程序不能完全停止,至少顶层主管必须保持活着。</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="4be1e581820721963019e692dc1f7707fda4ff7f" translate="yes" xml:space="preserve">
          <source>Ticket shall be used within specified time window (freshness checks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495255dc624907e5a1daae0dcc0d862cd07a65e4" translate="yes" xml:space="preserve">
          <source>Tidies Erlang source files in a directory and its subdirectories.</source>
          <target state="translated">整理一个目录及其子目录中的Erlang源文件。</target>
        </trans-unit>
        <trans-unit id="5ab18872f1a912f1810a74934cd2ae2c9eab483f" translate="yes" xml:space="preserve">
          <source>Tidies a syntax tree representation of a module definition. The given &lt;code&gt;Forms&lt;/code&gt; may be either a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. In either case, &lt;code&gt;Forms&lt;/code&gt; must represent a single complete module definition. The returned syntax tree has type &lt;code&gt;form_list&lt;/code&gt; and represents a tidied-up version of the same source code.</source>
          <target state="translated">整理模块定义的语法树表示形式。给定的 &lt;code&gt;Forms&lt;/code&gt; 可以是 &lt;code&gt;form_list&lt;/code&gt; 类型的单个语法树，也可以是表示&amp;ldquo;程序形式&amp;rdquo;的语法树列表。无论哪种情况， &lt;code&gt;Forms&lt;/code&gt; 必须代表一个完整的模块定义。返回的语法树的类型为 &lt;code&gt;form_list&lt;/code&gt; ,并表示同一源代码的整理版本。</target>
        </trans-unit>
        <trans-unit id="f1ca9281bec4536e142232511847b2d622b54efd" translate="yes" xml:space="preserve">
          <source>Tidies an Erlang source code file.</source>
          <target state="translated">整理一个Erlang源代码文件。</target>
        </trans-unit>
        <trans-unit id="82f374f21b06bcdcda1afc18f61cb6cebcc8d024" translate="yes" xml:space="preserve">
          <source>Tidies and pretty-prints Erlang source code, removing unused functions, updating obsolete constructs and function calls, etc.</source>
          <target state="translated">整理并漂亮地打印Erlang源代码,删除未使用的函数,更新过时的构造和函数调用等。</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="06efc4d93bae79312067fccb5a91a687ea053f84" translate="yes" xml:space="preserve">
          <source>Time Accuracy</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
