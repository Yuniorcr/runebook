<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="94ae17188be414c8f3700fb89b358ab0b027a799" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt; Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df33ce491bfcd444a606b910f4cb9ff07688b9" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">使用映射而不是记录来表示 &lt;code&gt;SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SET&lt;/code&gt; 类型。没有将生成 &lt;code&gt;.hrl&lt;/code&gt; 文件。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 的截面图表示。</target>
        </trans-unit>
        <trans-unit id="d6e7a5bbaac2fe1d22a38124df53d79bef29a950" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;killproc&lt;/code&gt; procedure in the above script can be combined with a call to &lt;code&gt;erl_call&lt;/code&gt;, for example:</source>
          <target state="translated">在上面的脚本中使用 &lt;code&gt;killproc&lt;/code&gt; 过程可以与对 &lt;code&gt;erl_call&lt;/code&gt; 的调用结合使用，例如：</target>
        </trans-unit>
        <trans-unit id="b3ca6ef9bc0eb0fd175268e16b224fb66ca6f3fe" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to receive messages:</source>
          <target state="translated">使用以下两个功能之一来接收信息。</target>
        </trans-unit>
        <trans-unit id="889a7015472f4f91d80360afa19301c38e311202" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to send messages:</source>
          <target state="translated">使用以下两个功能之一发送消息。</target>
        </trans-unit>
        <trans-unit id="4154e7c45ed1c09b28a8e036ce840111c118baa6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; to name directories to be searched for application files (equivalent to the &lt;code&gt;path&lt;/code&gt; in the option list for &lt;code&gt;systools:make_script/2&lt;/code&gt;).</source>
          <target state="translated">使用选项 &lt;code&gt;-I&lt;/code&gt; 可以为要搜索应用程序文件的目录命名（相当于 &lt;code&gt;systools:make_script/2&lt;/code&gt; 的选项列表中的 &lt;code&gt;path&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c5e91c4910f51c44ca054a05924c3387fce83e6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; with the name of a file to use that file as a customized prologue file (option &lt;code&gt;includefile&lt;/code&gt;).</source>
          <target state="translated">将选项 &lt;code&gt;-I&lt;/code&gt; 与文件名一起使用，以将该文件用作定制的序言文件（选项 &lt;code&gt;includefile&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d55bb82b3630e22429844da6211b0339bba98ea8" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;strong_validation&lt;/code&gt; to generate all warnings that the compiler would generate.</source>
          <target state="translated">使用选项 &lt;code&gt;strong_validation&lt;/code&gt; 生成编译器将生成的所有警告。</target>
        </trans-unit>
        <trans-unit id="7937b3339663cb4514ac276573d7e2c9e0dfd606" translate="yes" xml:space="preserve">
          <source>Use relaxed command checking only on systems with very limited interactive usage.</source>
          <target state="translated">仅在交互式使用非常有限的系统上使用放松的命令检查。</target>
        </trans-unit>
        <trans-unit id="7e8be1e3581d1297371b0474f66ebe7774bd9957" translate="yes" xml:space="preserve">
          <source>Use script &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">使用脚本 &lt;code&gt;etop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecdd13a57f7a43ae5c5be43fc2ede21e975f620a" translate="yes" xml:space="preserve">
          <source>Use selective decode instead of exclusive decode if you are interested in only a single subvalue.</source>
          <target state="translated">如果您只对单个子值感兴趣,请使用选择性解码而不是独占性解码。</target>
        </trans-unit>
        <trans-unit id="24a48f85522c3c675cca203ceb229fa7527ddbde" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;#compile_server&quot;&gt;compile server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc5a942c59a4e030f1c2785f2614bd8aa51f00a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;PAYLOAD_EXIT&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT_TT&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT2&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT2_TT&lt;/code&gt; and &lt;code&gt;PAYLOAD_MONITOR_P_EXIT&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt;s instead of the non-PAYLOAD variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc8ad2b93f84080dbc37116f7108a665d7b55ac" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SEND_SENDER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; instead of the &lt;code&gt;SEND&lt;/code&gt; control message and use the &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message instead of the &lt;code&gt;SEND_TT&lt;/code&gt; control message.</source>
          <target state="translated">使用 &lt;code&gt;SEND_SENDER&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; 代替 &lt;code&gt;SEND&lt;/code&gt; 控制消息，并使用 &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; 控制消息代替 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息。</target>
        </trans-unit>
        <trans-unit id="0eb13f68ed22ba4a08751c4363250d2b2b3fba90" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bin_opt_info&lt;/code&gt; option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;bin_opt_info&lt;/code&gt; 选项可使编译器打印许多有关二进制优化的信息。可以将其提供给编译器或 &lt;code&gt;erlc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c30d8bd130bb93833dc88f2efb2369af2066111" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;file&lt;/code&gt; module for files opened for bytewise access (&lt;code&gt;{encoding,latin1}&lt;/code&gt;).</source>
          <target state="translated">将 &lt;code&gt;file&lt;/code&gt; 模块用于为按字节访问而打开的文件（ &lt;code&gt;{encoding,latin1}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cec2d14858ca56aa4886d5cb596e4d1c4389bb5d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;io&lt;/code&gt; module when accessing files with any other encoding (for example &lt;code&gt;{encoding,uf8}&lt;/code&gt;).</source>
          <target state="translated">使用任何其他编码（例如 &lt;code&gt;{encoding,uf8}&lt;/code&gt; ）访问文件时，请使用 &lt;code&gt;io&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="9e21bc6d17c5f3138b318feb1664293ef1335717" translate="yes" xml:space="preserve">
          <source>Use the GUI.</source>
          <target state="translated">使用图形用户界面。</target>
        </trans-unit>
        <trans-unit id="e3f1aa1f6c936dd4bbcc665fff827922973d80d2" translate="yes" xml:space="preserve">
          <source>Use the following command to generate a .hrl file from an MIB:</source>
          <target state="translated">使用以下命令从MIB中生成一个.hrl文件。</target>
        </trans-unit>
        <trans-unit id="285645e77ad81adce8bdc1256d83d49b2f715165" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</source>
          <target state="translated">使用下面的include指令来访问这里和用户指南中描述的记录和常量宏。</target>
        </trans-unit>
        <trans-unit id="26340e5bfdecd44f5d627a8bf499337d449c9b39" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described in the following sections:</source>
          <target state="translated">使用下面的include指令来获得对以下章节中描述的记录和常量的访问。</target>
        </trans-unit>
        <trans-unit id="eaf38e520f81f823bc5c2944fc89ede2ea27b2c7" translate="yes" xml:space="preserve">
          <source>Use the function &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; to add new fragments and apply the usual schema manipulation functions (such as &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt;) on each fragment to perform the actual redistribution.</source>
          <target state="translated">使用函数 &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; 来添加新的片段，并在每个片段上应用常规的模式操作功能（例如 &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; ）以执行实际的重新分配。</target>
        </trans-unit>
        <trans-unit id="81d58859492a0e6cf67a695fecde344397df4fa0" translate="yes" xml:space="preserve">
          <source>Use the function describe_table/[2,3] to find out which ODBC data type that is expected for each column of that table. If a column has a data type that is described with capital letters, alas it is not currently supported by the param_query function. Too know which Erlang data type corresponds to an ODBC data type see the Erlang to ODBC data type &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">使用函数describe_table / [2,3]找出该表的每一列都需要哪种ODBC数据类型。如果列的数据类型用大写字母描述，那么param_query函数当前不支持该列。太了解哪种Erlang数据类型对应于ODBC数据类型，请参阅《用户指南》中的Erlang到ODBC数据类型 &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e938f8eaaf7a2fb5db93a5741c75b6c3d2b1e56" translate="yes" xml:space="preserve">
          <source>Use the functional API with a non-constant seed:</source>
          <target state="translated">使用非恒定种子的功能API。</target>
        </trans-unit>
        <trans-unit id="541ddc36dcd95bdf4f3b7b106057bafcf839da79" translate="yes" xml:space="preserve">
          <source>Use the map in the ssl key option:</source>
          <target state="translated">在ssl密钥选项中使用地图。</target>
        </trans-unit>
        <trans-unit id="8bedd4105b0c918e36403c94a86cea217070bfac" translate="yes" xml:space="preserve">
          <source>Use the same Erlang types to represent &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; as in OTP R16.</source>
          <target state="translated">使用与OTP R16中相同的Erlang类型表示 &lt;code&gt;BIT STRING&lt;/code&gt; 和 &lt;code&gt;OCTET STRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b8bf9ebaa15f0fd8cafa74076170d6b2f131de7" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt; {packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203bf7370538dd892cf94b38b1e17b25aedb4cc9" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="translated">使用套接字选项 &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; （或类似的选项）可以使接收器在知道已接收到所有数据时关闭连接。</target>
        </trans-unit>
        <trans-unit id="57d720aadc70a1b56241025a699cc74ef9ea249d" translate="yes" xml:space="preserve">
          <source>Use the specified PLT as the initial PLT. If the PLT was built during setup, the files are checked for consistency.</source>
          <target state="translated">使用指定的PLT作为初始PLT。如果PLT是在设置过程中建立的,则会检查文件的一致性。</target>
        </trans-unit>
        <trans-unit id="23a325631bef6112525e951a3d4952dbdf388985" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt; erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad77542229ec1d771e4e02b6524ee184d641040" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用从 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; 返回的值在当前运行时系统实例上创建唯一的名称。如果只需要正整数，则可以使用 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e36f8f2cb8b647a47cca517ff03d541469491a2" translate="yes" xml:space="preserve">
          <source>Use the values returned from &lt;code&gt;erlang:now/0&lt;/code&gt; to create a name unique on the current runtime system instance.</source>
          <target state="translated">使用从 &lt;code&gt;erlang:now/0&lt;/code&gt; 返回的值在当前运行时系统实例上创建唯一的名称。</target>
        </trans-unit>
        <trans-unit id="5a1a3d93db801fcbd6f501d39eac8cc569d5150c" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure, and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">失败的系统调用后使用此功能。打印出由调用方提供的消息，后跟描述失败原因的字符串，并且该过程以退出值 &lt;code&gt;1&lt;/code&gt; 终止。此函数不返回。</target>
        </trans-unit>
        <trans-unit id="60cd4eee7b91477f96873aee8f0c08a0e1659942" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure.</source>
          <target state="translated">在系统调用失败后使用此函数。打印调用者提供的信息,后面是一个描述失败原因的字符串。</target>
        </trans-unit>
        <trans-unit id="ac3be946393c47f35eede2756d19558abc69e73e" translate="yes" xml:space="preserve">
          <source>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</source>
          <target state="translated">只有在你知道自己在做什么的情况下,也就是在你自己的应用程序上,才能使用这个函数。它的值何时以及多久被应用程序读取一次,非常依赖于应用程序和配置参数。不小心使用这个函数会使应用程序处于一种奇怪的、不一致的、失灵的状态。</target>
        </trans-unit>
        <trans-unit id="8d1a6a43cff399c18914850f099af42f99ff52a6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; a specific match specification saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此函数可以&amp;ldquo;忘记&amp;rdquo;在调用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 期间保存的特定匹配规范。</target>
        </trans-unit>
        <trans-unit id="b6bca535e578b8f96edf192f36e88f0568555ba6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; all match specifications saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. This is useful when one wants to restore other match specifications from a file with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; to delete specific saved match specifications.</source>
          <target state="translated">使用此功能可以&amp;ldquo;忘记&amp;rdquo;在调用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 期间保存的所有匹配规范。当要从 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 的文件中恢复其他匹配规范时，此功能很有用。使用 &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; 删除特定的已保存匹配规范。</target>
        </trans-unit>
        <trans-unit id="d051de59e60744864ad96b5d4970120ccdf3ce13" translate="yes" xml:space="preserve">
          <source>Use this function to recall all match specifications previously used in the session (i. e. previously saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, and built-in match specifications. This is very useful, as a complicated match_spec can be quite awkward to write. Note that the match specifications are lost if &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">使用此函数可以调用会话中先前使用的所有匹配规范（即，先前在调用 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 时保存的匹配规范以及内置的匹配规范。这非常有用，因为编写复杂的match_spec可能很麻烦。如果调用 &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; ,则匹配规范将丢失。</target>
        </trans-unit>
        <trans-unit id="2f20da1728d7b0010525545f9f1f93fe66b04dcf" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt; User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c941b9c92bccb005e3755850980e1a4c93df1aed" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="translated">使用此功能可以设置或修改日志记录类别的详细级别。有关详细信息，请参见《 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 》。使用 &lt;code&gt;default&lt;/code&gt; 可设置一般详细程度。</target>
        </trans-unit>
        <trans-unit id="cb4f981450d616f53002b2dbe1a22bf77c775fe2" translate="yes" xml:space="preserve">
          <source>Use this function when a fatal error has occurred that is not because of a system call. The message provided by the caller is printed and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">发生并非由于系统调用引起的致命错误时，请使用此功能。打印出呼叫者提供的消息，并且过程以退出值 &lt;code&gt;1&lt;/code&gt; 终止。此函数不返回。</target>
        </trans-unit>
        <trans-unit id="927c6ba6b883da5a944bc17195e2455b95cac07d" translate="yes" xml:space="preserve">
          <source>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</source>
          <target state="translated">使用此功能时要非常谨慎,因为它会使现有的持久性数据过时。使用前请三思。</target>
        </trans-unit>
        <trans-unit id="03f95d87f375280efaeeb6fe8cafb649410d718d" translate="yes" xml:space="preserve">
          <source>Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use &lt;code&gt;ct_telnet&lt;/code&gt; and configure connections, specifically for UNIX hosts, see the &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">使用此模块可以设置Telnet连接，发送命令以及对结果进行字符串匹配。有关如何使用 &lt;code&gt;ct_telnet&lt;/code&gt; 和配置连接（特别是针对UNIX主机）的信息，请参见 &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d5d50bad282c0804f9a7e02550f10159ee185809" translate="yes" xml:space="preserve">
          <source>Use this option when receiving binaries from an untrusted source.</source>
          <target state="translated">当从不信任的源头接收二进制文件时,请使用此选项。</target>
        </trans-unit>
        <trans-unit id="01f5382feca2bb4947c345ec5297001b4439de6e" translate="yes" xml:space="preserve">
          <source>Use with extreme care.</source>
          <target state="translated">使用时要特别小心。</target>
        </trans-unit>
        <trans-unit id="926a25ba00ec3f71fce83c4ae2a582227ec44542" translate="yes" xml:space="preserve">
          <source>Used BIFs. &lt;code&gt;B&lt;/code&gt; is empty if &lt;code&gt;builtins&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all analyzed modules.</source>
          <target state="translated">使用的BIF。如果所有分析模块的 &lt;code&gt;builtins&lt;/code&gt; 函数均为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;B&lt;/code&gt; 为空。</target>
        </trans-unit>
        <trans-unit id="c11ee9255f50f3fa3a1ac060817b8601274af33d" translate="yes" xml:space="preserve">
          <source>Used Library Modules.</source>
          <target state="translated">二手图书馆模块。</target>
        </trans-unit>
        <trans-unit id="f2aba5aee8ae8ee86804bcb14e53b26b3dd95541" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt; enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt; ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaea96d1f0adade7428605a5b6a71a977e21c17f" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; 用于返回有关运行时系统的信息。包含与 &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; 相同的内容。</target>
        </trans-unit>
        <trans-unit id="42d74dbb12b0fb1f6ea1d95300289917f6910dc7" translate="yes" xml:space="preserve">
          <source>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</source>
          <target state="translated">由进程使用,为未定义的函数调用和未定义的注册进程重新定义错误处理程序。没有经验的用户不要使用这个标志,因为代码自动加载取决于错误处理模块的正确操作。</target>
        </trans-unit>
        <trans-unit id="021e8894d4cd8efeb3800e902cce4283561eaa59" translate="yes" xml:space="preserve">
          <source>Used by a server process to accept a connection from a client process.</source>
          <target state="translated">由服务器进程使用,接受来自客户端进程的连接。</target>
        </trans-unit>
        <trans-unit id="6c49623f58e59d8735fea69dd29c4f20e63decdd" translate="yes" xml:space="preserve">
          <source>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">服务器进程使用它来注册本地名称服务器EPMD，从而允许其他进程使用注册的名称来发送消息。在调用这两个函数之前，进程应在打开的套接字上调用 &lt;code&gt;bind()&lt;/code&gt; 和 &lt;code&gt;listen()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b328120a25406cfa5be9b6c7e4c0d4da319fda04" translate="yes" xml:space="preserve">
          <source>Used by a server process to setup a listen socket which later can be used for accepting connections from client processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5237d3789fea5df1f7ffca0fba9777e1547c1e" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Size&lt;/code&gt; is an expression that is to evaluate to an integer.</source>
          <target state="translated">在位字符串构造中使用的 &lt;code&gt;Size&lt;/code&gt; 是一个要计算为整数的表达式。</target>
        </trans-unit>
        <trans-unit id="a7cde552a3551769508a6d34af2b5b84e289881d" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Value&lt;/code&gt; is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</source>
          <target state="translated">在位字符串构造中使用， &lt;code&gt;Value&lt;/code&gt; 是一个表达式，可以求值为整数，浮点数或位字符串。如果表达式不是单个文字或变量，则将其括在括号中。</target>
        </trans-unit>
        <trans-unit id="319d7a71912a6a421ba26d32164c23729df90f10" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt; that evaluates to an integer. All variables in the guard expression must be already bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fa51f6619aef90e556b2317c4e8c8b56b58094" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be an integer, or a variable bound to an integer.</source>
          <target state="translated">用于位字符串匹配时， &lt;code&gt;Size&lt;/code&gt; 必须是整数，或者是绑定到整数的变量。</target>
        </trans-unit>
        <trans-unit id="a2ea25edea36db50d30cde55ba8333dc776429fb" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Value&lt;/code&gt; must be a variable, or an integer, float, or string.</source>
          <target state="translated">在用于位字符串匹配时， &lt;code&gt;Value&lt;/code&gt; 必须是变量，或者是整数，浮点数或字符串。</target>
        </trans-unit>
        <trans-unit id="00b8635528024d62633ce26ebc8ade8bf9cf1f13" translate="yes" xml:space="preserve">
          <source>Used in socket close message.</source>
          <target state="translated">用于套接字关闭信息中。</target>
        </trans-unit>
        <trans-unit id="37771a4a8b87640f401b1b514090e62c25bfd4a6" translate="yes" xml:space="preserve">
          <source>Used in socket data message.</source>
          <target state="translated">用于套接字数据信息中。</target>
        </trans-unit>
        <trans-unit id="94de0e417f3f0b14c77f33a57c9b9d9d4a4e16c3" translate="yes" xml:space="preserve">
          <source>Used to perform codec measurements. That is, to see what kind of performance can be expected by the different codecs provided by the megaco application.</source>
          <target state="translated">用于进行编解码器测量。也就是看megaco应用程序提供的不同编解码器的预期性能。</target>
        </trans-unit>
        <trans-unit id="c90819c1d1025e50a1c34d2b3826c5ef2c0b5b68" translate="yes" xml:space="preserve">
          <source>Used to set the network namespace during the open call. Only supported on the Linux platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c84b814113321eb30117cec8f04565b7ae8fc7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt; Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea4aa7eefddb763ba10cb9daaf61feb433c13d7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于在分布上设置跟踪。级别是不同的详细级别。更高的级别意味着更多的信息。另请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="444add2c3da696b8c15c1fad22d917131601a637" translate="yes" xml:space="preserve">
          <source>Used to trigger the replay feature and indicate that the replay is to start at the time specified. If &lt;code&gt;StartTime&lt;/code&gt; is not present, this is not a replay subscription. It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0558fbc4bfc3f98f9c0aff78f8bf8c889c7ae8" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;uniquely identifies the HTTP server.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; 一起使用，以唯一地标识HTTP服务器。这在虚拟化环境中很有用，在虚拟化环境中，可能有一个以上具有相同bind_address和端口的服务器。如果未显式设置此属性，则假定 &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; 唯一标识HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="770e0b9f1dc73dcbf183dcbbbc53e3cf5e4375d4" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;. If this property is not explicitly set, it is assumed that the the &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; uniquely identifies the SSH daemon.</source>
          <target state="translated">与 &lt;code&gt;ip-address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 一起使用以唯一地标识ssh守护程序。这在虚拟化环境中很有用，在虚拟化环境中，可能有多个服务器具有相同的 &lt;code&gt;ip-address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 。如果未显式设置此属性，则假定 &lt;code&gt;ip-address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 唯一标识SSH守护程序。</target>
        </trans-unit>
        <trans-unit id="adce6622f9543e73767624ada8f13763e382d86b" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;send_timeout&lt;/code&gt; to specify whether the socket is to be automatically closed when the send operation returns &lt;code&gt;{error,timeout}&lt;/code&gt;. The recommended setting is &lt;code&gt;true&lt;/code&gt;, which automatically closes the socket. Defaults to &lt;code&gt;false&lt;/code&gt; because of backward compatibility.</source>
          <target state="translated">与 &lt;code&gt;send_timeout&lt;/code&gt; 一起使用，以指定当send操作返回 &lt;code&gt;{error,timeout}&lt;/code&gt; 时是否自动关闭套接字。推荐的设置为 &lt;code&gt;true&lt;/code&gt; ，它将自动关闭套接字。由于向后兼容，默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07eb868bef5aa368e19bb894ec05dbc37d91a59f" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;{verify, verify_peer}&lt;/code&gt; by an TLS/DTLS server. If set to &lt;code&gt;true&lt;/code&gt;, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to &lt;code&gt;false&lt;/code&gt;, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</source>
          <target state="translated">TLS / DTLS服务器与 &lt;code&gt;{verify, verify_peer}&lt;/code&gt; 一起使用。如果设置为 &lt;code&gt;true&lt;/code&gt; ，则如果客户端没有要发送的证书（即发送空证书），则服务器将失败。如果设置为 &lt;code&gt;false&lt;/code&gt; ，则仅当客户端发送无效证书（空证书被视为有效）时，它才会失败。默认为false。</target>
        </trans-unit>
        <trans-unit id="5ec279a6fe9dd1161f2aa08b6ed9eb431c51ce40" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; has called &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; and has a trace token with flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; set to &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">当进程 &lt;code&gt;From&lt;/code&gt; 调用 &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; 并具有将标记 &lt;code&gt;print&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 并将 &lt;code&gt;label&lt;/code&gt; 设置为 &lt;code&gt;Label&lt;/code&gt; 的跟踪令牌时使用。</target>
        </trans-unit>
        <trans-unit id="ec8ed9ea4c0a02770b19230ee831fc7eabc65212" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent a message.</source>
          <target state="translated">当进程 &lt;code&gt;From&lt;/code&gt; 的跟踪令牌标志 &lt;code&gt;print&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，发送此消息时使用。</target>
        </trans-unit>
        <trans-unit id="5a6c5ffbc1f01a1110cfda8597d119f7cb6deda4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;send&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent information. &lt;code&gt;To&lt;/code&gt; may be a process identifier, a registered name on a node represented as &lt;code&gt;{NameAtom, NodeAtom}&lt;/code&gt;, or a node name represented as an atom. &lt;code&gt;From&lt;/code&gt; may be a process identifier or a node name represented as an atom. &lt;code&gt;Message&lt;/code&gt; contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532ecd45390412a4c37f8eaaaf1dd3a2bc7a9e4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives a message with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">使用时，一个进程 &lt;code&gt;To&lt;/code&gt; 接收带着一丝消息令牌具有标志 &lt;code&gt;'receive'&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d2aa763f5b505650b3a0a4c6cb3a9ea0e4cca03" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives information with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;To&lt;/code&gt; may be a process identifier, or a node name represented as an atom. &lt;code&gt;From&lt;/code&gt; may be a process identifier or a node name represented as an atom. &lt;code&gt;Message&lt;/code&gt; contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed866b317195673cc57f0bfced4e8f18f9deb039" translate="yes" xml:space="preserve">
          <source>Used when a restart of the emulator is required after all other upgrade instructions are executed. For more information about this instruction, see restart_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在执行所有其他升级指令后需要重新启动仿真器时使用。有关此指令的更多信息，请参见《 &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_emulator（低级）。</target>
        </trans-unit>
        <trans-unit id="b51ce444943f18b5b406c12d5de312dd469de6a1" translate="yes" xml:space="preserve">
          <source>Used when connection is up.</source>
          <target state="translated">连接时使用。</target>
        </trans-unit>
        <trans-unit id="98f3f0d6b5fe552d6fdd9e8a1ac4b1dbc95a1e0a" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. &lt;code&gt;{M, F, Arity}&lt;/code&gt; is specified instead of &lt;code&gt;{M, F, Args}&lt;/code&gt; in call trace messages.</source>
          <target state="translated">与 &lt;code&gt;call&lt;/code&gt; 跟踪标志一起使用。在呼叫跟踪消息中指定了 &lt;code&gt;{M, F, Arity}&lt;/code&gt; 而不是 &lt;code&gt;{M, F, Args}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35c8c1e7148c094e7f1037898138a703736b5c71" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. The &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return_from&lt;/code&gt;, and &lt;code&gt;return_to&lt;/code&gt; trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</source>
          <target state="translated">与 &lt;code&gt;call&lt;/code&gt; 跟踪标志一起使用。该 &lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;return_from&lt;/code&gt; 和 &lt;code&gt;return_to&lt;/code&gt; 如果这个标志设置跟踪消息被禁止，但如果有匹配规范他们正常执行。</target>
        </trans-unit>
        <trans-unit id="2a44c884d9e9ccdf7459174638e1116bfc6664fd" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f97b1230868a1d952f070b44e014ae71c9b348" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;call&lt;/code&gt; 跟踪标志一起使用。跟踪从跟踪函数返回到其调用方的返回。仅适用于与选项追踪功能， &lt;code&gt;local&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71278576734ac4954eb54529eb1f8e6a8e33b380" translate="yes" xml:space="preserve">
          <source>Used with the optional replay feature to indicate the newest notifications of interest. If &lt;code&gt;StopTime&lt;/code&gt; is not present, the notifications continues until the subscription is terminated. Must be used with and be later than &lt;code&gt;StartTime&lt;/code&gt;. Values of &lt;code&gt;StopTime&lt;/code&gt; in the future are valid. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fba48e276aeb34c1e005677779fd01f8c437d09" translate="yes" xml:space="preserve">
          <source>Useful BIFs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0771df2c0469ced91bfba340e5621231c3eb3f97" translate="yes" xml:space="preserve">
          <source>Useful for debugging. Prints the arguments sent to the emulator.</source>
          <target state="translated">对调试有用。打印发送到仿真器的参数。</target>
        </trans-unit>
        <trans-unit id="bda40ec80a6280d040ae6cb2132464ae8868382d" translate="yes" xml:space="preserve">
          <source>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</source>
          <target state="translated">只对性能调整有用。除非你知道执行时间或内存消耗有问题,否则不要使用这个选项,并确保该选项能改善问题。</target>
        </trans-unit>
        <trans-unit id="1b5232bbae53583af327fbf580fd761e961eb1ae" translate="yes" xml:space="preserve">
          <source>Useful options for the ASN.1 compiler:</source>
          <target state="translated">ASN.1编译器的有用选项。</target>
        </trans-unit>
        <trans-unit id="108800af422d061f509679723cbd223daa96eb6e" translate="yes" xml:space="preserve">
          <source>User Authentication (using Mnesia, Dets or plain text database)</source>
          <target state="translated">用户认证(使用Mnesia、Dets或纯文本数据库)</target>
        </trans-unit>
        <trans-unit id="ed5170cd339b4047e02379b1d218d6d630aafc71" translate="yes" xml:space="preserve">
          <source>User Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b544db80e74a2aaa321fb9ef1a50c8268a9abd0" translate="yes" xml:space="preserve">
          <source>User Supplied Socket Implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d7d2ae9aeff0edfea9298508c33c3156394dee" translate="yes" xml:space="preserve">
          <source>User authentication using text files, Dets, or Mnesia database.</source>
          <target state="translated">使用文本文件、Dets或Mnesia数据库进行用户认证。</target>
        </trans-unit>
        <trans-unit id="fdf44c259444d43d89a931e2c5f009d59f5246ec" translate="yes" xml:space="preserve">
          <source>User does not have privileges to create symbolic links (&lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; on Windows).</source>
          <target state="translated">用户没有创建符号链接的特权（Windows上为 &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bfa1d0c7af0339d4d928dbeac41cc561fc954a37" translate="yes" xml:space="preserve">
          <source>User info - Information related to megaco users. Read/Write.</source>
          <target state="translated">用户信息-与megaco用户相关的信息。读/写。</target>
        </trans-unit>
        <trans-unit id="5943eb1d1f04ded83e3e46ef3224b51f634ef059" translate="yes" xml:space="preserve">
          <source>User is not logged in.</source>
          <target state="translated">用户未登录。</target>
        </trans-unit>
        <trans-unit id="ad777a4590258aa35737d9328314ce537d2c9cb8" translate="yes" xml:space="preserve">
          <source>User login information</source>
          <target state="translated">用户登录信息</target>
        </trans-unit>
        <trans-unit id="6fb1ac68e43ee6fa885af993d59c13a42fa4cd33" translate="yes" xml:space="preserve">
          <source>User owning the public key.</source>
          <target state="translated">拥有公钥的用户。</target>
        </trans-unit>
        <trans-unit id="ba07b0c96db1af8dcefb2d9162e61ba1cb1cc53b" translate="yes" xml:space="preserve">
          <source>User's private key(s)</source>
          <target state="translated">用户的私钥</target>
        </trans-unit>
        <trans-unit id="31f9f489aed30f7126e13ae2a6c8aa3e1dfb69c4" translate="yes" xml:space="preserve">
          <source>User's public key</source>
          <target state="translated">用户的公钥</target>
        </trans-unit>
        <trans-unit id="9426098e573c085d3d557403caba209e6444ee08" translate="yes" xml:space="preserve">
          <source>User-Defined Boot Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a1ad1d15fcc5f9e499bc1732d0978996617997" translate="yes" xml:space="preserve">
          <source>User-Name AVP</source>
          <target state="translated">用户名称AVP</target>
        </trans-unit>
        <trans-unit id="de7eccf174631d1a9cc0a633fafcff4e91154a99" translate="yes" xml:space="preserve">
          <source>User-Specific Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d9701932fd2b8fbf1ff963e66877b3fb9d5041" translate="yes" xml:space="preserve">
          <source>User-defined entries can also be written to a configuration file by calling function &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt;, where &lt;code&gt;ConfigList&lt;/code&gt; is a list of &lt;code&gt;{Module,Function,Args}&lt;/code&gt;.</source>
          <target state="translated">用户定义的条目也可以通过调用函数 &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt; 写入配置文件，其中 &lt;code&gt;ConfigList&lt;/code&gt; 是 &lt;code&gt;{Module,Function,Args}&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="56ea86a7fa1494da2715a81abce4cab0c8f4eb29" translate="yes" xml:space="preserve">
          <source>User-defined event handlers can be added to handle application-specific events.</source>
          <target state="translated">可以添加用户自定义的事件处理程序来处理应用程序的特定事件。</target>
        </trans-unit>
        <trans-unit id="d44e29b83c2f61db1703ca0d31d257ddfa7ed010" translate="yes" xml:space="preserve">
          <source>User-specific data for use in hook functions. The default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">在挂钩函数中使用的用户特定数据。默认值为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18e7327216976d6005c52f79eedee5271cbeaf73" translate="yes" xml:space="preserve">
          <source>User-specific event handlers can be plugged into a &lt;code&gt;Common Test&lt;/code&gt; event manager, either by telling &lt;code&gt;Common Test&lt;/code&gt; to install them before the test run (described later), or by adding the handlers dynamically during the test run using &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; or &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt;. In the latter scenario, the reference of the &lt;code&gt;Common Test&lt;/code&gt; event manager is required. To get it, call &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; or (on the &lt;code&gt;Common Test&lt;/code&gt; Master node) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用户特定的事件处理程序可以插入 &lt;code&gt;Common Test&lt;/code&gt; 事件管理器中，方法是告诉 &lt;code&gt;Common Test&lt;/code&gt; 在测试运行之前安装它们（稍后描述），或者通过使用 &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; 或 &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt; 在测试运行期间动态添加处理程序：add_sup_handler / 3。在后一种情况下，需要 &lt;code&gt;Common Test&lt;/code&gt; 事件管理器的引用。要获取它，请调用 &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; 或（在 &lt;code&gt;Common Test&lt;/code&gt; Master节点上） &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca5c1acac21d9a3b6102ae9dadcfac83499ca32" translate="yes" xml:space="preserve">
          <source>UserMod:handle_connect/2</source>
          <target state="translated">UserMod:handle_connect/2</target>
        </trans-unit>
        <trans-unit id="f0d3fd03fc3def42c8da5fe622ad791ccaa1a0ea" translate="yes" xml:space="preserve">
          <source>UserMod:handle_message_error/3</source>
          <target state="translated">UserMod:handle_message_error/3</target>
        </trans-unit>
        <trans-unit id="a3bdb9436158799687b4418588b8647662e27155" translate="yes" xml:space="preserve">
          <source>UserMod:handle_syntax_error/3</source>
          <target state="translated">UserMod:handle_syntax_error/3</target>
        </trans-unit>
        <trans-unit id="7e0a148d93ed9e16bd5599754876deca380f643d" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_ack/4</source>
          <target state="translated">UserMod:handle_trans_ack/4</target>
        </trans-unit>
        <trans-unit id="d345f713a7834aaf56186658aec2115bcc13351b" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_reply/4</source>
          <target state="translated">UserMod:handle_trans_reply/4</target>
        </trans-unit>
        <trans-unit id="3884319e28f9e311d120dba2fbc454b53cead5a4" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_request/3</source>
          <target state="translated">UserMod:handle_trans_request/3</target>
        </trans-unit>
        <trans-unit id="3f6d997ef0e4d563bff3ecdcaff66971fd6b9762" translate="yes" xml:space="preserve">
          <source>Users are advised not to unregister system processes.</source>
          <target state="translated">建议用户不要取消注册系统进程。</target>
        </trans-unit>
        <trans-unit id="2d7d513ec1d0fa107e592cfc1c6289d5e8f86f88" translate="yes" xml:space="preserve">
          <source>Users are not allowed to define types with the same names as the predefined or built-in ones. This is checked by the compiler and its violation results in a compilation error.</source>
          <target state="translated">用户不允许定义与预定义或内置类型名称相同的类型。编译器会对此进行检查,违反规定会导致编译错误。</target>
        </trans-unit>
        <trans-unit id="259b250e47199fdb387584511bbacec343b879b8" translate="yes" xml:space="preserve">
          <source>Users may either explicitly be registered with megaco:start_user/2 and/or be statically configured by setting the application environment variable 'users' to a list of {UserMid, Config} tuples. See the function megaco:start_user/2 for details.</source>
          <target state="translated">用户可以通过megaco:start_user/2显式注册和/或通过将应用程序环境变量'users'设置为{UserMid,Config}元组列表来静态配置。详见函数megaco:start_user/2。</target>
        </trans-unit>
        <trans-unit id="944ad3a48b1f08bbcf2fb59d662131185d4fa39c" translate="yes" xml:space="preserve">
          <source>Uses a separate log file for every invocation of the service (&amp;lt;servicename&amp;gt;&lt;code&gt;.debug.&lt;/code&gt;&amp;lt;N&amp;gt;).</source>
          <target state="translated">对服务的每次调用使用单独的日志文件（&amp;lt;servicename&amp;gt; &lt;code&gt;.debug.&lt;/code&gt; &amp;lt;N&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="66ba2c7044af64caa2e9580c9ae81af796b430d1" translate="yes" xml:space="preserve">
          <source>Uses a sequence of wrap log files of limited size. As a wrap log file is filled up, further items are logged on to the next file in the sequence, starting all over with the first file when the last file is filled up.</source>
          <target state="translated">使用一个有限大小的缠绕日志文件序列,当一个缠绕日志文件被填满时,更多的项目将被记录到序列中的下一个文件中,当最后一个文件被填满时,将从第一个文件开始。当一个wrap日志文件被填满时,更多的项目将被记录到序列中的下一个文件中,当最后一个文件被填满时,将从第一个文件开始。</target>
        </trans-unit>
        <trans-unit id="63cc551f28fdc9de0a6c288edb557951e593faa7" translate="yes" xml:space="preserve">
          <source>Uses a specific or customised prologue file instead of default &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; which is otherwise included.</source>
          <target state="translated">使用特定或自定义的序言文件，而不使用默认的 &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; ，否则该文件将包含在内。</target>
        </trans-unit>
        <trans-unit id="cfb35a958a3524ef916a2dee520c654de0d97728" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a deep list of characters that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (described in section &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;) is processed.</source>
          <target state="translated">使用 &lt;code&gt;ErrorDescriptor&lt;/code&gt; 并返回描述错误的深层字符列表。处理 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构（在 &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 部分中描述）时，通常隐式调用此函数。</target>
        </trans-unit>
        <trans-unit id="c4139194e768c251d84b03abf5cd321d1df4d02c" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用 &lt;code&gt;ErrorDescriptor&lt;/code&gt; 并返回描述错误或警告的字符串。处理 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构时，通常会隐式调用此函数（请参见 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 一节）。</target>
        </trans-unit>
        <trans-unit id="81c0e97bc4b6d9f801ca4dae0a9674ebd48bf699" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt; Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93cef9ab961b13c52c3ee1286af209a4ef5d08b" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用 &lt;code&gt;ErrorDescriptor&lt;/code&gt; 并返回描述错误的字符串。处理 &lt;code&gt;ErrorInfo&lt;/code&gt; 结构时，通常会隐式调用此函数（请参见 &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; 一节）。</target>
        </trans-unit>
        <trans-unit id="4e240ed0f46a0e7052bee5a3dec802b98fe462d1" translate="yes" xml:space="preserve">
          <source>Uses test specification as input (described later).</source>
          <target state="translated">使用测试规范作为输入(后面会提到)。</target>
        </trans-unit>
        <trans-unit id="713999a06cadf66964b72d923b13701c303aa173" translate="yes" xml:space="preserve">
          <source>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it to use a specific value from the session security parameters.</source>
          <target state="translated">使用TLS会话的伪随机函数（PRF）生成额外的密钥材料。它要么使用用户生成的 &lt;code&gt;Secret&lt;/code&gt; 和 &lt;code&gt;Seed&lt;/code&gt; 值，要么使用原子来指示它使用会话安全性参数中的特定值。</target>
        </trans-unit>
        <trans-unit id="29fb0bd5ac8937f75326b05d56a7b9c426068b8d" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang Web Server API interaction data:</source>
          <target state="translated">使用以下Erlang Web Server API交互数据。</target>
        </trans-unit>
        <trans-unit id="6542021570e55732848d7c4ecf584a9f1fce4a50" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang web server API interaction data:</source>
          <target state="translated">使用以下Erlang web服务器API交互数据。</target>
        </trans-unit>
        <trans-unit id="9c87b085bc59aac65ced245c43dfb66c0a327d57" translate="yes" xml:space="preserve">
          <source>Uses the return value of command &lt;code&gt;N&lt;/code&gt; in the current command, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the return value of the &lt;code&gt;N&lt;/code&gt;th previous command is used (that is, &lt;code&gt;v(-1)&lt;/code&gt; uses the value of the previous command).</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; 为正，则使用当前命令中命令 &lt;code&gt;N&lt;/code&gt; 的返回值。如果为负，则使用第 &lt;code&gt;N&lt;/code&gt; 个前一个命令的返回值（即 &lt;code&gt;v(-1)&lt;/code&gt; 使用前一个命令的值）。</target>
        </trans-unit>
        <trans-unit id="eecb17cf153ec064278785165dee55062f6944c8" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt; file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7825c5becf2a7bc58af7be09180ec50f46648e4" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="translated">使用指定的目录作为当前目录。从zip归档文件中提取文件名时，会将其添加到文件名之前。（其作用类似于内核中的 &lt;code&gt;file:set_cwd/1&lt;/code&gt; ，但未更改全局 &lt;code&gt;cwd&lt;/code&gt; 属性。）</target>
        </trans-unit>
        <trans-unit id="70df806adc59e0170f9b3abdae1e333b936a59c8" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt; file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f356880e1a29c6875ae88d729105f2618d77c27f" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="translated">使用指定的目录作为当前工作目录（ &lt;code&gt;cwd&lt;/code&gt; ）。添加文件名时，这是文件名的前缀，尽管不在zip归档文件中（其作用类似于内核中的 &lt;code&gt;file:set_cwd/1&lt;/code&gt; ，但未更改全局 &lt;code&gt;cwd&lt;/code&gt; 属性。）。</target>
        </trans-unit>
        <trans-unit id="3b24dbe95482357a59b64bc1da6d8ac53437250c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-group top1 top2&lt;/code&gt;, or &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; gives the same result.</source>
          <target state="translated">使用 &lt;code&gt;-group top1 top2&lt;/code&gt; 或 &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; 可以得到相同的结果。</target>
        </trans-unit>
        <trans-unit id="88f4f21380171a61e0164a29d94211d35a1afc8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; enables this transform, unless the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined first.</source>
          <target state="translated">使用 &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; 启用此转换，除非首先定义了宏 &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c20e26276eb3aeb9f802837228801c44d2e93f19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; instead, but the &lt;code&gt;ets:select/2&lt;/code&gt; call is far more efficient. Without the translation provided by &lt;code&gt;ms_transform&lt;/code&gt;, one must struggle with writing match specifications terms to accommodate this.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; 和match规范，可以过滤出表中的行，并构造一个包含这些行中数据相关部分的元组列表。可以改用 &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; ，但是 &lt;code&gt;ets:select/2&lt;/code&gt; 调用效率更高。如果没有 &lt;code&gt;ms_transform&lt;/code&gt; 提供的翻译，则必须努力编写匹配规范术语来适应这一要求。</target>
        </trans-unit>
        <trans-unit id="c82c027de482fad19a39ea9d254bbafa02b405e5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cprof:analyse()&lt;/code&gt; in this example also shows approximately the same background work as in the first example.</source>
          <target state="translated">在此示例中使用 &lt;code&gt;cprof:analyse()&lt;/code&gt; 还显示了与第一个示例大致相同的背景工作。</target>
        </trans-unit>
        <trans-unit id="8c0e8375352b28a80765ea773ca843308851404f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ct_run -step [opts]&lt;/code&gt;, or by passing option &lt;code&gt;{step,Opts}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the following is possible:</source>
          <target state="translated">使用 &lt;code&gt;ct_run -step [opts]&lt;/code&gt; 或通过将选项 &lt;code&gt;{step,Opts}&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; }传递给ct：run_test / 1，可以进行以下操作：</target>
        </trans-unit>
        <trans-unit id="8f64a2837eaf7b8603ee4f3b40320c612c90d80f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;erl_drv_output_term()&lt;/code&gt; or &lt;code&gt;erl_drv_send_term()&lt;/code&gt;, a binary can be included in an Erlang term.</source>
          <target state="translated">使用 &lt;code&gt;erl_drv_output_term()&lt;/code&gt; 或 &lt;code&gt;erl_drv_send_term()&lt;/code&gt; ，可以在Erlang术语中包含二进制文件。</target>
        </trans-unit>
        <trans-unit id="22c339dd691e6a37b987bcf7700c90e985445f81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, we can combine the ease of use of the &lt;code&gt;ets:foldr/3&lt;/code&gt; and the efficiency of the pure &lt;code&gt;ets:select/2&lt;/code&gt; example:</source>
          <target state="translated">使用 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; ，我们可以将 &lt;code&gt;ets:foldr/3&lt;/code&gt; 的易用性与纯 &lt;code&gt;ets:select/2&lt;/code&gt; 的效率结合起来：</target>
        </trans-unit>
        <trans-unit id="8d06eaee0affa1e9d7ed35b71b0a99a0f3c00b54" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;list_to_atom/1&lt;/code&gt; to construct an atom that is passed to &lt;code&gt;apply/3&lt;/code&gt; as follows, is quite expensive and not recommended in time-critical code:</source>
          <target state="translated">使用 &lt;code&gt;list_to_atom/1&lt;/code&gt; 构造一个传递给 &lt;code&gt;apply/3&lt;/code&gt; 的原子，如下所示，它非常昂贵，因此在时间紧迫的代码中不建议使用：</target>
        </trans-unit>
        <trans-unit id="d46674608018d628e05f3f6b918685848c3d908c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;off_heap&lt;/code&gt; may seem like a nice way to get a more scalable system as you get very little contention on the main locks, however, allocating a heap fragment is more expensive than allocating on the heap of the receiving process. So if it is very unlikely that contention will occur, it is more efficient to try to allocate the message directly on the receiving process' heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcacc23564d64117fc9064f1fef0cef7f077dab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;on_heap&lt;/code&gt; will force all messages to be part of on the young heap which will increase the amount of data that the garbage collector has to move. So if a garbage collection is triggered while processing a large amount of messages, they will be copied to the young heap. This in turn will lead to that the messages will quickly be promoted to the old heap and thus increase its size. This may be good or bad depending on exactly what the process does. A large old heap means that the young heap will also be larger, which in turn means that less garbage collections will be triggered while processing the message queue. This will temporarly increase the throughput of the process at the cost of more memory usage. However, if after all the messages have been consumed the process enters a state where a lot less messages are being received. Then it may be a long time before the next fullsweep garbage collection happens and the messages that are on the old heap will be there until that happens. So while &lt;code&gt;on_heap&lt;/code&gt; is potentially faster than the other modes, it uses more memory for a longer time. This mode is the legacy mode which is almost how the message queue was handled before Erlang/OTP 19.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81394dd93922176e47458d5f3c15c2b0804bd134" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;scheduler_wall_time&lt;/code&gt; to calculate scheduler utilization:</source>
          <target state="translated">使用 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 计算调度程序利用率：</target>
        </trans-unit>
        <trans-unit id="862378469cf87dc0f0b44de7c775b81caef36dd4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;skip_suites&lt;/code&gt; and &lt;code&gt;skip_cases&lt;/code&gt; terms in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;skip_suites&lt;/code&gt; 和 &lt;code&gt;skip_cases&lt;/code&gt; 术语。</target>
        </trans-unit>
        <trans-unit id="ad8c3317a3e308fa4049e5bb381826628649bab5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;uri_string:percent_decode/1&lt;/code&gt; directly on a URI is not safe. This example shows, that after each consecutive application of the function the resulting URI will be changed. None of these URIs refer to the same resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf508ced4ee281be2348cd08d12f83a3f75cac1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes SSL or TLS vulnerable to the BEAST attack.</source>
          <target state="translated">使用 &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; 使SSL或TLS容易受到BEAST攻击。</target>
        </trans-unit>
        <trans-unit id="87dfbc56acc4a3ad5ee7a36ef57f4914ecd5323f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes TLS-1.0 vulnerable to the BEAST attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3b96a977f8581a203f0cc7479a4fa622cf64" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; makes TLS vulnerable to the Poodle attack.</source>
          <target state="translated">使用 &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; 使TLS容易受到Poodle攻击。</target>
        </trans-unit>
        <trans-unit id="1984579de8895e18f9ec4b106a61232ce3d2f9a9" translate="yes" xml:space="preserve">
          <source>Using Dialyzer from Erlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c74ea67a8bf514e98bacaa08d939dc388ff2c9" translate="yes" xml:space="preserve">
          <source>Using HiPE</source>
          <target state="translated">使用HiPE</target>
        </trans-unit>
        <trans-unit id="33d4374af52dd4c6d3bf7dd77f27a252b67bb304" translate="yes" xml:space="preserve">
          <source>Using Keys of Ets Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b8b2ecfeeac0dc6c8b30eb4f29ae6e32df930" translate="yes" xml:space="preserve">
          <source>Using Mnesia Functions</source>
          <target state="translated">使用Mnesia函数</target>
        </trans-unit>
        <trans-unit id="69b70d7925c3d595457eb50569e18e9253b0f84e" translate="yes" xml:space="preserve">
          <source>Using Mnesia tables as SNMP tables</source>
          <target state="translated">将Mnesia表用作SNMP表</target>
        </trans-unit>
        <trans-unit id="3313c0cf350dee6afc582a4e81b3944a9c28027c" translate="yes" xml:space="preserve">
          <source>Using Multiple Test Specification Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4556d3a05908d3a2fd5b120b9264ae977bdd001" translate="yes" xml:space="preserve">
          <source>Using QLC</source>
          <target state="translated">使用QLC</target>
        </trans-unit>
        <trans-unit id="eb75491192cbec18ddc3193ff609070567e4f298" translate="yes" xml:space="preserve">
          <source>Using QLC can be more expensive than using &lt;code&gt;Mnesia&lt;/code&gt; functions directly but offers a nice syntax.</source>
          <target state="translated">与直接使用 &lt;code&gt;Mnesia&lt;/code&gt; 函数相比，使用QLC可能会更昂贵，但提供了一种不错的语法。</target>
        </trans-unit>
        <trans-unit id="a066eefba1eeb1104df3eae5dd3e9fa8ab61feec" translate="yes" xml:space="preserve">
          <source>Using XML Configuration Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b888e7581a06a39525c04389ba7f49f831878208" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;msg_env&lt;/code&gt; of &lt;code&gt;NULL&lt;/code&gt; is an optimization, which groups together calls to &lt;code&gt;enif_alloc_env&lt;/code&gt;, &lt;code&gt;enif_make_copy&lt;/code&gt;, &lt;code&gt;enif_port_command&lt;/code&gt;, and &lt;code&gt;enif_free_env&lt;/code&gt; into one call. This optimization is only useful when a majority of the terms are to be copied from &lt;code&gt;env&lt;/code&gt; to &lt;code&gt;msg_env&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;msg_env&lt;/code&gt; 的 &lt;code&gt;NULL&lt;/code&gt; 是一种优化，这组一起呼吁 &lt;code&gt;enif_alloc_env&lt;/code&gt; ， &lt;code&gt;enif_make_copy&lt;/code&gt; ， &lt;code&gt;enif_port_command&lt;/code&gt; 和 &lt;code&gt;enif_free_env&lt;/code&gt; 到一个通话中。仅当将大多数术语从 &lt;code&gt;env&lt;/code&gt; 复制到 &lt;code&gt;msg_env&lt;/code&gt; 时，此优化才有用。</target>
        </trans-unit>
        <trans-unit id="6e05aace796b827cc7de5108dc65985d67668971" translate="yes" xml:space="preserve">
          <source>Using a bridge that maps control messages in a proprietary protocol to a standardized management protocol and conversely</source>
          <target state="translated">使用桥接器,将专有协议中的控制信息映射到标准化管理协议中,反之亦然</target>
        </trans-unit>
        <trans-unit id="23f87dc632b3b3a497eda26d1e0fd7f024ede833" translate="yes" xml:space="preserve">
          <source>Using a configuration target name (an alias) as reference.</source>
          <target state="translated">使用配置目标名称(别名)作为参考。</target>
        </trans-unit>
        <trans-unit id="1bd7819b4238a75d18eacbc298988f60839565ee" translate="yes" xml:space="preserve">
          <source>Using a driver binary instead of a normal buffer is often faster, as the emulator needs not to copy the data, only the pointer is used.</source>
          <target state="translated">使用驱动二进制而不是普通的缓冲区通常会更快,因为仿真器不需要复制数据,只需要使用指针。</target>
        </trans-unit>
        <trans-unit id="bd91214b8e2268d8b06993311ecee8c2eef8c119" translate="yes" xml:space="preserve">
          <source>Using a password protected private key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4f00d83853b9a89087a2b4d34b93f85e90b8b4" translate="yes" xml:space="preserve">
          <source>Using a proprietary control protocol</source>
          <target state="translated">使用专有控制协议</target>
        </trans-unit>
        <trans-unit id="8e93a7f8043acf2f93881fdb114964f55246a652" translate="yes" xml:space="preserve">
          <source>Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network.</source>
          <target state="translated">使用纯密码认证方案。在这里,纯文本密码在通过网络发送之前被加密。</target>
        </trans-unit>
        <trans-unit id="b4a6cc06302869126e46d43f8937deb8a274ac3e" translate="yes" xml:space="preserve">
          <source>Using a set of bits in the process identifier as index into an array seems hard to beat. By replacing the array of pointers with an array of our pointer sized atomic data type, a lookup will consist of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61ea81dc7d1d41a9c00c2e18e56e9bb004eb512" translate="yes" xml:space="preserve">
          <source>Using a trace port significantly lowers the overhead imposed by using tracing.</source>
          <target state="translated">使用跟踪端口大大降低了使用跟踪所带来的开销。</target>
        </trans-unit>
        <trans-unit id="ef1a11e39ee5139ba5f2dcc235a18443f44a0583" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;Timeout&lt;/code&gt; less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; are used), can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same &lt;code&gt;Socket&lt;/code&gt; (that is, source address and port), as the controlling process blocks until &lt;code&gt;connect/*&lt;/code&gt; returns. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; provides an alternative without this limitation.</source>
          <target state="translated">如果使用的 &lt;code&gt;Timeout&lt;/code&gt; 值小于操作系统建立关联所花费的最长时间（如果使用的是 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; 的默认值，则约为4.5分钟），可能会导致返回值不一致或不正确。这对于共享同一 &lt;code&gt;Socket&lt;/code&gt; （即源地址和端口）的关联特别重要，因为控制进程将阻塞直到 &lt;code&gt;connect/*&lt;/code&gt; 返回。 &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; 提供了一种没有此限制的替代方法。</target>
        </trans-unit>
        <trans-unit id="ac881e536beb671038423cc61533d8765126d30b" translate="yes" xml:space="preserve">
          <source>Using and especially configuring Logger can be difficult at times as there are many different options that can be changed and often more than one way to achieve the same result. This User's Guide tries to help by giving many different examples of how you can use logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba9ca7df52061ff3c5b19d7603144639874aa7f" translate="yes" xml:space="preserve">
          <source>Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand.</source>
          <target state="translated">使用行为也使其他程序员编写的代码更容易阅读和理解。即兴的编程结构虽然可能更有效率,但总是更难理解。</target>
        </trans-unit>
        <trans-unit id="be49034820244435a044e90d7061836773df04c0" translate="yes" xml:space="preserve">
          <source>Using binaries is faster if more than a few bytes are returned.</source>
          <target state="translated">如果返回的字节数超过几个,使用二进制文件会更快。</target>
        </trans-unit>
        <trans-unit id="86c27bef1bf11875cf4524858dc2b5b6d1f57e8f" translate="yes" xml:space="preserve">
          <source>Using global names</source>
          <target state="translated">使用全局名称</target>
        </trans-unit>
        <trans-unit id="83523a7442b26b6b81628c22227c3e6adc4deb1a" translate="yes" xml:space="preserve">
          <source>Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard.</source>
          <target state="translated">使用键盘交互式认证。这适用于不需要客户端任何特殊软件支持的交互式认证方法。相反,所有的认证数据都是从键盘输入的。</target>
        </trans-unit>
        <trans-unit id="1a390fb32c6eae4e12e20eb0d4d9a4b34d640e2f" translate="yes" xml:space="preserve">
          <source>Using one of the latter three requires good knowledge about the protocol and is not covered by this tutorial. See the SNMP, Inets, and Orber applications, respectively.</source>
          <target state="translated">使用后三种中的一种需要很好的协议知识,本教程不涉及。分别参见SNMP、Inets和Orber应用。</target>
        </trans-unit>
        <trans-unit id="5809e3cc4f955b265b3823ad9d7e5a15c18140e7" translate="yes" xml:space="preserve">
          <source>Using public key technology. RSA and DSA, X509-certificates are not supported.</source>
          <target state="translated">使用公钥技术。不支持RSA和DSA、X509证书。</target>
        </trans-unit>
        <trans-unit id="e0f94a2e35a5586c99778544bf1babebc9b68874" translate="yes" xml:space="preserve">
          <source>Using raw socket options requires detailed knowledge about the current operating system and TCP stack.</source>
          <target state="translated">使用原始套接字选项需要详细了解当前操作系统和TCP协议栈。</target>
        </trans-unit>
        <trans-unit id="c43bcf358f1478cc031c03e30ad078b80a07cfdf" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">不允许使用spawn选项 &lt;code&gt;monitor&lt;/code&gt; ，这会导致功能失败，原因是 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35f019fb91f46510f8e2ab9ec3e19f04bc02403c" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes this function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">不允许使用spawn选项 &lt;code&gt;monitor&lt;/code&gt; ，这会导致此功能失败，原因是 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a580b4208da4e796317767a96b5a26cf22e6b99" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed. It causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">不允许使用生成选项 &lt;code&gt;monitor&lt;/code&gt; 。它导致函数失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43a9c674a9710324d1b88cb77d06f6cc4e6cfec2" translate="yes" xml:space="preserve">
          <source>Using state functions:</source>
          <target state="translated">使用状态函数。</target>
        </trans-unit>
        <trans-unit id="d6a2d079afcf63d89e623e699169fa524219390a" translate="yes" xml:space="preserve">
          <source>Using the &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator to delete an element from a list is not a performance problem:</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo;运算符从列表中删除元素不是性能问题：</target>
        </trans-unit>
        <trans-unit id="2b4f7382590545933da8c1a5ca844a0b2dbf266e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, the size of the deep list can be calculated if sharing is ignored. It becomes the size of the list when it has been sent to another process or stored in an Ets table:</source>
          <target state="translated">如果忽略共享，则可以使用 &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF来计算深层列表的大小。当它被发送到另一个进程或存储在Ets表中时，它成为列表的大小：</target>
        </trans-unit>
        <trans-unit id="f45d11e06ad9c8b5b97c2a1d3733d7810b2b6a1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, it can be seen that the deep list only requires 22 words of heap space:</source>
          <target state="translated">使用 &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF，可以看到深列表仅需要22个单词的堆空间：</target>
        </trans-unit>
        <trans-unit id="69d1d8837258e11d9f37b8093e934034d0224323" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;match_object&lt;/code&gt; functions for traversing all table objects is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;match_object&lt;/code&gt; 函数遍历所有表对象比调用 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 或 &lt;code&gt;slot/2&lt;/code&gt; 更有效。</target>
        </trans-unit>
        <trans-unit id="cb9890e5b6fe40e8ce4e970b7ac20a2736549546" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;move&lt;/code&gt; instruction as an example, we will give a quick tour to show the main features of &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88489091684544e2ce31ba031314c433818b9650" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;select&lt;/code&gt; functions for traversing all objects of a table is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;select&lt;/code&gt; 函数遍历表的所有对象比调用 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 或 &lt;code&gt;slot/2&lt;/code&gt; 更有效。</target>
        </trans-unit>
        <trans-unit id="61a624a4dabba21043f9ab83195b8048f47a13d2" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;Options&lt;/strong&gt; menu, you can set which areas to be displayed. By default, all areas except the Trace area are displayed.</source>
          <target state="translated">使用&amp;ldquo; &lt;strong&gt;选项&amp;rdquo;&lt;/strong&gt;菜单，可以设置要显示的区域。默认情况下，将显示&amp;ldquo;跟踪&amp;rdquo;区域以外的所有区域。</target>
        </trans-unit>
        <trans-unit id="deaaf3fd831f16ebe5c78cc725732bfa850f0ae7" translate="yes" xml:space="preserve">
          <source>Using the BIFs &lt;code&gt;tuple_size/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</source>
          <target state="translated">使用 &lt;code&gt;tuple_size/1&lt;/code&gt; 和 &lt;code&gt;byte_size/1&lt;/code&gt; 为编译器和运行时系统提供了更多的优化机会。另一个优点是BIF为Dialyzer提供了更多类型信息。</target>
        </trans-unit>
        <trans-unit id="5ffd8340dfb4e279ea5e33db1e4fc34776f3431f" translate="yes" xml:space="preserve">
          <source>Using the Erlang Port Mapper Daemon (EPMD)</source>
          <target state="translated">使用Erlang端口映射程序(EPMD)</target>
        </trans-unit>
        <trans-unit id="74a23b01b4aba69b50c3d95e7b04c3987e9060d6" translate="yes" xml:space="preserve">
          <source>Using the Kernel configuration parameters above, one can set default options for all TCP sockets on a node, but use this with care. Options such as &lt;code&gt;{delay_send,true}&lt;/code&gt; can be specified in this way. The following is an example of starting an Erlang node with all sockets using delayed send:</source>
          <target state="translated">使用上面的内核配置参数，可以为节点上的所有TCP套接字设置默认选项，但是请谨慎使用。可以通过这种方式指定诸如 &lt;code&gt;{delay_send,true}&lt;/code&gt; 之类的选项。以下是使用延迟发送在所有套接字上启动Erlang节点的示例：</target>
        </trans-unit>
        <trans-unit id="d1a737c5f8225e696e7f3578db64802e348cec28" translate="yes" xml:space="preserve">
          <source>Using the SNMP Agent in a Distributed Environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980131d837205b9d57e4456d942aace527d0b1b4" translate="yes" xml:space="preserve">
          <source>Using the compile server does not always speed up the build, as the compile server sometimes must be restarted to ensure correctness. Here are some examples of situtations that force a restart:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13013135bcccdcdbbd4af4075c0fbd41fe4a1df" translate="yes" xml:space="preserve">
          <source>Using the configuration variable as reference.</source>
          <target state="translated">以配置变量为参考。</target>
        </trans-unit>
        <trans-unit id="6387e670864aedf383cf907c6d29480da77d049e" translate="yes" xml:space="preserve">
          <source>Using the erlc program, write like this</source>
          <target state="translated">使用erlc程序,这样写道</target>
        </trans-unit>
        <trans-unit id="cba5c7b8f3196008174c43d66ec7b6eeb23e5802" translate="yes" xml:space="preserve">
          <source>Using the following rule we can combine two &lt;code&gt;move&lt;/code&gt; instructions to a &lt;code&gt;move2&lt;/code&gt; instruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe6335c37dc35de5485bc852958929b084eb85" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;broadcast&lt;/code&gt; becomes:</source>
          <target state="translated">使用功能 &lt;code&gt;foreach&lt;/code&gt; ，功能 &lt;code&gt;broadcast&lt;/code&gt; 变为：</target>
        </trans-unit>
        <trans-unit id="3bd90c46e2dfc7b2e3d344d9519f155f341267df" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;print_list&lt;/code&gt; becomes:</source>
          <target state="translated">使用 &lt;code&gt;foreach&lt;/code&gt; 函数，函数 &lt;code&gt;print_list&lt;/code&gt; 变为：</target>
        </trans-unit>
        <trans-unit id="b09520015307c351db8684a091c45386c6ce9fb4" translate="yes" xml:space="preserve">
          <source>Using the monitor triggers in the call to &lt;code&gt;try_unload&lt;/code&gt; ensures that the monitor is added before the unloading is executed, meaning that the monitor is always properly triggered, which is not the case if &lt;code&gt;monitor/2&lt;/code&gt; is called separately.</source>
          <target state="translated">在对 &lt;code&gt;try_unload&lt;/code&gt; 的调用中使用监视器触发器可确保在执行卸载之前添加监视器，这意味着监视器始终会被正确触发，而如果单独调用 &lt;code&gt;monitor/2&lt;/code&gt; 则不会。</target>
        </trans-unit>
        <trans-unit id="e7fa3b27587f43d236bfc06bb5036ddb2f4e6201" translate="yes" xml:space="preserve">
          <source>Using the registry</source>
          <target state="translated">使用注册表</target>
        </trans-unit>
        <trans-unit id="ffb1c5489112873955c3175cf9ad9aba4db225d6" translate="yes" xml:space="preserve">
          <source>Using the same snapshots to calculate a total scheduler utilization:</source>
          <target state="translated">使用相同的快照来计算总的调度器利用率。</target>
        </trans-unit>
        <trans-unit id="a20644602b05608c2ad01e03c87f70e3ffe5b61d" translate="yes" xml:space="preserve">
          <source>Using the single time warp mode, the time offset is handled in two phases:</source>
          <target state="translated">使用单时翘模式,时间偏移分两个阶段处理。</target>
        </trans-unit>
        <trans-unit id="8eee4ea386e884fcda7fe99030e661fbbf1aa947" translate="yes" xml:space="preserve">
          <source>Using the specific path &lt;code&gt;-group [sub121]&lt;/code&gt; or &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; gives the same result in this example.</source>
          <target state="translated">在此示例中 &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; 使用特定路径 &lt;code&gt;-group [sub121]&lt;/code&gt; 或{group，[[sub121]]}可获得相同的结果。</target>
        </trans-unit>
        <trans-unit id="5c52f9666d83bbf64ddaeeafc9ca31c5700aca1b" translate="yes" xml:space="preserve">
          <source>Using these facts, the two small circles in the picture below can be combined.</source>
          <target state="translated">利用这些事实,可以把下图中的两个小圆组合起来。</target>
        </trans-unit>
        <trans-unit id="c051a5a3fd4ccf36ccc537b80db2ff67e34eac9f" translate="yes" xml:space="preserve">
          <source>Using this approach we keep the properties like identifier ordering, and identifier reuse while improving performance and scalability. It has one flaw, though. There is no guarantee that the operation will terminate. This can quite easily be fixed though, and will be fixed in the next release. We will get back to this below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa02cd7977a3da27f5010ebc2df637a05af28d4" translate="yes" xml:space="preserve">
          <source>Using this new lookup approach we wont modify any memory at all which is important. A lookup conceptually only read memory, now this is true in the implementation also which is important from a scalability perspective. The previous implementation modified the cache line containing the reference counter two times, and the cache line containing the corresponding lock two times at each lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63be83a0c1d3953deae8f0d528efae09e644ff83" translate="yes" xml:space="preserve">
          <source>Using this option makes mod_log and mod_disk_log error logs redundant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aadd39c7dc4683cf62fc0ed24ee58375d7f5d3" translate="yes" xml:space="preserve">
          <source>Using transactions is a way to guarantee that the distributed Mnesia database remains consistent, even when many different processes update it in parallel. However, if you have real-time requirements it is recommended to use &lt;code&gt;dirty&lt;/code&gt; operations instead of transactions. When using &lt;code&gt;dirty&lt;/code&gt; operations, you lose the consistency guarantee; this is usually solved by only letting one process update the table. Other processes must send update requests to that process.</source>
          <target state="translated">使用事务是一种保证分布式Mnesia数据库保持一致的方法，即使许多不同的进程并行更新它也是如此。但是，如果您有实时要求，建议使用 &lt;code&gt;dirty&lt;/code&gt; 操作而不是事务。使用 &lt;code&gt;dirty&lt;/code&gt; 操作时，您会失去一致性保证；这通常可以通过只允许一个进程更新表来解决。其他进程必须将更新请求发送到该进程。</target>
        </trans-unit>
        <trans-unit id="2cb7bee577205f37d65f9821375accf63f59b42f" translate="yes" xml:space="preserve">
          <source>Usually a few managers communicate with many agents.</source>
          <target state="translated">通常几个经理和很多代理商沟通。</target>
        </trans-unit>
        <trans-unit id="cdaebc21aedbdaa85649f3457b904bb990d3b2ea" translate="yes" xml:space="preserve">
          <source>Usually a line is added that is to state:</source>
          <target state="translated">通常会加上一行字,就是说明。</target>
        </trans-unit>
        <trans-unit id="f7c9ebf9950b5eb0782b3cd23c9a753ea0c5e533" translate="yes" xml:space="preserve">
          <source>Usually it suffices to detect time-outs on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, option &lt;code&gt;send_timeout&lt;/code&gt; comes in handy.</source>
          <target state="translated">通常，检测接收到的超时就足够了，因为大多数协议都包括来自服务器的某种确认，但是如果协议严格来说是一种方式，则可以使用 &lt;code&gt;send_timeout&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="72f960a27f294ee8a3a2af0d51fbe8531fe5bf1b" translate="yes" xml:space="preserve">
          <source>Usually one of &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;Application&quot;&lt;/code&gt; or &lt;code&gt;&quot;Security&quot;&lt;/code&gt;. Note that the NT eventlog viewer has another notion of category, which in most cases is totally meaningless and therefore not imported into Erlang. What is called a category here is one of the main three types of events occurring in a normal NT system.</source>
          <target state="translated">通常是 &lt;code&gt;&quot;System&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Application&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;Security&quot;&lt;/code&gt; 。请注意，NT事件日志查看器还有另一个类别概念，在大多数情况下，该类别完全没有意义，因此不会导入到Erlang中。这里所谓的类别是正常NT系统中发生的三种主要事件之一。</target>
        </trans-unit>
        <trans-unit id="eaa3a8b7b3a6f1f39061eab776dd864c04df5840" translate="yes" xml:space="preserve">
          <source>Usually, the entities defined in the MIB are called &lt;strong&gt;Managed Objects (MOs)&lt;/strong&gt;, although they do not have to be objects in the object-oriented way. For example, a simple scalar variable defined in a MIB is called an MO. The MOs are logical objects, not necessarily with a one-to-one mapping to the resources.</source>
          <target state="translated">通常，在MIB中定义的实体称为&lt;strong&gt;托管对象（MO）&lt;/strong&gt;，尽管它们不一定是面向对象的对象。例如，在MIB中定义的简单标量变量称为MO。MO是逻辑对象，不一定具有与资源的一对一映射。</target>
        </trans-unit>
        <trans-unit id="34333d124dba7ee56119ecbb8915169706ed629f" translate="yes" xml:space="preserve">
          <source>Utility for reading and creating 'zip' archives.</source>
          <target state="translated">用于读取和创建 &quot;zip &quot;档案的实用程序。</target>
        </trans-unit>
        <trans-unit id="4587d8ae182b07cd6c5ddcc7013d5c9b99960884" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;BITS&lt;/code&gt; to &lt;code&gt;OCTET-STRING&lt;/code&gt;.</source>
          <target state="translated">实用程序函数，用于将 &lt;code&gt;BITS&lt;/code&gt; 类型的值转换为 &lt;code&gt;OCTET-STRING&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e44844d0966f1f6069d31b91bf4a8abdb72b4d1" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;OCTET-STRING&lt;/code&gt; to &lt;code&gt;BITS&lt;/code&gt;.</source>
          <target state="translated">实用程序函数，用于将 &lt;code&gt;OCTET-STRING&lt;/code&gt; 类型的值转换为 &lt;code&gt;BITS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4388b46bdace9a8dd94930d061cd808992ffbdfc" translate="yes" xml:space="preserve">
          <source>Utility function that starts the applications &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;. Default type is &lt;code&gt;temporary&lt;/code&gt;. For more information, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">启动应用程序 &lt;code&gt;crypto&lt;/code&gt; ， &lt;code&gt;public_key&lt;/code&gt; 和 &lt;code&gt;ssh&lt;/code&gt; 的实用程序功能。默认类型是 &lt;code&gt;temporary&lt;/code&gt; 。有关更多信息，请参见内核中的 &lt;code&gt;application(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="4c7f90797d67794eeec5a51cfe794b557e3c3507" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formated printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions.</source>
          <target state="translated">实用程序函数，用于生成由 &lt;code&gt;versions1&lt;/code&gt; 和 &lt;code&gt;versions2&lt;/code&gt; 函数生成的版本信息的格式化打印输出。</target>
        </trans-unit>
        <trans-unit id="0bbbc215beb617665e30c05f1df892f3ab385b7d" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions</source>
          <target state="translated">实用程序函数，用于生成由 &lt;code&gt;versions1&lt;/code&gt; 和 &lt;code&gt;versions2&lt;/code&gt; 函数生成的版本信息的格式化打印输出</target>
        </trans-unit>
        <trans-unit id="e9ca3adcd5764dc7d65f56277bec220d9992d1f5" translate="yes" xml:space="preserve">
          <source>Utility function(s) to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; function</source>
          <target state="translated">实用程序函数，用于生成由 &lt;code&gt;versions1&lt;/code&gt; 函数生成的版本信息的格式化打印输出</target>
        </trans-unit>
        <trans-unit id="9e9a4acca18dc29ce31970a704bacd6a0999cfc7" translate="yes" xml:space="preserve">
          <source>Utility functions for Core Erlang case/receive clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d38534bb1763cd2ba3d18a6d7ecd6c0ae55401" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the agent config files.</source>
          <target state="translated">用于处理代理配置文件的实用功能。</target>
        </trans-unit>
        <trans-unit id="2afa581e37f140ef78590e09404a9aae431c2390" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the manager config files.</source>
          <target state="translated">用于处理管理器配置文件的实用功能。</target>
        </trans-unit>
        <trans-unit id="6433ab0ec2c7394b801c26a999984771d7a0ae8b" translate="yes" xml:space="preserve">
          <source>Utility functions used to retrieve some system and application info.</source>
          <target state="translated">用于检索一些系统和应用程序信息的实用功能。</target>
        </trans-unit>
        <trans-unit id="aa9f46ccd3ba41c02d70b7e973f34c959fc38d56" translate="yes" xml:space="preserve">
          <source>VACM is described in detail in RFC2275. Here is only a brief description given.</source>
          <target state="translated">在RFC2275中详细描述了VACM。这里只给出简单的描述。</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="c8a5c44daefed8fa60457df49456ebe3ace77f95" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BackupItems&lt;/code&gt; are the following tuples:</source>
          <target state="translated">有效的 &lt;code&gt;BackupItems&lt;/code&gt; 是以下元组：</target>
        </trans-unit>
        <trans-unit id="8f005ec226ccd5bd77580fd1619b366495013be6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BindType&lt;/code&gt;s:</source>
          <target state="translated">有效的 &lt;code&gt;BindType&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3768a7ccfdefa3ace61d00f77e188549db26cf0f" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;InfoTuple&lt;/code&gt;s with corresponding &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">有效的 &lt;code&gt;InfoTuple&lt;/code&gt; 以及相应的 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc05afbe09b2e8c8117fcc39f7f35cc60250e0d4" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for functions:</source>
          <target state="translated">功能的有效 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cf53d05dcad2f68d3d2da7de03839fc48e89fb6c" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for ports and processes:</source>
          <target state="translated">端口和进程的有效 &lt;code&gt;Item&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52a65f9e3e7dcb0306411c6c3f71279192f79ba0" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Option&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531c29f343d1120961be4920ea66239ca958e2cd" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Reply&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267195f93799c6c9557e8b18de85ebfc710db9e1" translate="yes" xml:space="preserve">
          <source>Valid Erlang expressions and guard sequences are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有效的Erlang表达式和保护序列在 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="b338a1ad5b1c7b18820779179ab41de826744b2b" translate="yes" xml:space="preserve">
          <source>Valid Return Values</source>
          <target state="translated">有效返回值</target>
        </trans-unit>
        <trans-unit id="efbf48a6212e82d31e363fa76b710eb93043cb0c" translate="yes" xml:space="preserve">
          <source>Valid categories are:</source>
          <target state="translated">有效类别为:</target>
        </trans-unit>
        <trans-unit id="e1cdb0f6fd9b5c7ae6270cdbd6aa6489ff170a68" translate="yes" xml:space="preserve">
          <source>Valid limits are values in the range &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt;. Limits are automatically adjusted to be sane. That is, the system adjusts values so that the low limit used is lower than or equal to the high limit used. By default the high limit is 8 kB and the low limit is 4 kB.</source>
          <target state="translated">有效限制是 &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt; 范围内的值。限制会自动调整为合理。也就是说，系统会调整值，以使使用的下限低于或等于使用的上限。默认情况下，上限为8 kB，下限为4 kB。</target>
        </trans-unit>
        <trans-unit id="ead2bf03d6fc68d606be1689e0611b409e03bb2a" translate="yes" xml:space="preserve">
          <source>Valid option:</source>
          <target state="translated">有效选项:</target>
        </trans-unit>
        <trans-unit id="2c6356256194f4dacdd3ceac883fb104c7079f63" translate="yes" xml:space="preserve">
          <source>Valid options &lt;code&gt;set_options&lt;/code&gt; are:</source>
          <target state="translated">有效的选项 &lt;code&gt;set_options&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="eeda404dab46510032ac078c150033a69675f334" translate="yes" xml:space="preserve">
          <source>Valid options depends on what options are supported by the node identified by &lt;code&gt;Node&lt;/code&gt;. A description of valid &lt;code&gt;Option&lt;/code&gt;s for the local node of current OTP version can be found in the documentation of &lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850c962c3f063b586578621ee12bbb84d6f38bb7" translate="yes" xml:space="preserve">
          <source>Valid options:</source>
          <target state="translated">有效选项:</target>
        </trans-unit>
        <trans-unit id="e4f1c0729761400496e047f8f256412e68cceee0" translate="yes" xml:space="preserve">
          <source>Valid return values</source>
          <target state="translated">有效的返回值</target>
        </trans-unit>
        <trans-unit id="1630b32c9530f31c96e521c8cf0ccc55338fbbc7" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;NodeType&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NodeType&lt;/code&gt; 的有效值：</target>
        </trans-unit>
        <trans-unit id="82b8127698b8ef2cfa8edc57143af42260620903" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element (Element).</source>
          <target state="translated">验证一个解析好的XML元素(元素)。</target>
        </trans-unit>
        <trans-unit id="b239d15c1167b7afc50fb4ba90a070cafbcead1e" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element towards an XML schema.</source>
          <target state="translated">验证一个经过解析的格式良好的XML元素,以达到XML模式。</target>
        </trans-unit>
        <trans-unit id="30aa57af8387dd9dda72f74225d0c83ea7830682" translate="yes" xml:space="preserve">
          <source>Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema.</source>
          <target state="translated">验证分两步进行。首先,它处理模式,将类型和结构信息保存在ets表中,然后向模式验证元素。</target>
        </trans-unit>
        <trans-unit id="d81dc9238e6ae4be4cef7714f7fca70a30cc0272" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;default&lt;/code&gt; states that the predefined properties are to be used.</source>
          <target state="translated">值 &lt;code&gt;default&lt;/code&gt; 指出预定义的属性将被使用。</target>
        </trans-unit>
        <trans-unit id="8f4b4232752a2d39d8445512cde28d28668f7d1f" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;force&lt;/code&gt; means that a reparation is made even if the table is properly closed. This is a seldom needed option.</source>
          <target state="translated">值 &lt;code&gt;force&lt;/code&gt; 意味着即使表已正确关闭也要进行赔偿。这是很少需要的选项。</target>
        </trans-unit>
        <trans-unit id="9fbeacf98f8026e5fab1b1d01a773952a1337a76" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables burst control and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">价值 &lt;code&gt;true&lt;/code&gt; 使突发脉冲控制和 &lt;code&gt;false&lt;/code&gt; 禁用它。</target>
        </trans-unit>
        <trans-unit id="e3e5e9f151e03304f82baa34e7f4f70c22fcd0d8" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables the feature and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">值 &lt;code&gt;true&lt;/code&gt; 启用该功能，并 &lt;code&gt;false&lt;/code&gt; 禁用它。</target>
        </trans-unit>
        <trans-unit id="54db79fce832cc1178c718ad9c79945056373188" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;undefined&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; (the argument list) is only to be used internally in &lt;code&gt;supervisor&lt;/code&gt;. If the restart type of the child is &lt;code&gt;temporary&lt;/code&gt;, the process is never to be restarted and therefore there is no need to store the real argument list. Value &lt;code&gt;undefined&lt;/code&gt; is then stored instead.</source>
          <target state="translated">值 &lt;code&gt;undefined&lt;/code&gt; 为 &lt;code&gt;A&lt;/code&gt; （参数列表），只有需要在内部使用 &lt;code&gt;supervisor&lt;/code&gt; 。如果子级的重新启动类型是 &lt;code&gt;temporary&lt;/code&gt; ，则永远不要重新启动该进程，因此无需存储实际参数列表。然后将存储 &lt;code&gt;undefined&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b4c13cbe61dee9b68ffaef6134995ebd910fbd5e" translate="yes" xml:space="preserve">
          <source>Value = IOString | atom() | integer()</source>
          <target state="translated">Value=IOString | atom()| integer()</target>
        </trans-unit>
        <trans-unit id="1bbca064dbc2becbd7d3555273dcd4ac5b367fab" translate="yes" xml:space="preserve">
          <source>Value of a configuration parameter.</source>
          <target state="translated">配置参数的值。</target>
        </trans-unit>
        <trans-unit id="384e64d4c66abb9cfb384072bb26c3dd0bab6612" translate="yes" xml:space="preserve">
          <source>Value to convert time unit for.</source>
          <target state="translated">要转换时间单位的值。</target>
        </trans-unit>
        <trans-unit id="768d2b954af31866b6e32d7a85e19622323f08f3" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;atom()&lt;/code&gt;</source>
          <target state="translated">值： &lt;code&gt;atom()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97045cfdad33dd3dba2b9ed63a6c87874f526b4d" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">值： &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a052394fb5d5289ec24690454284914e11a61275" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;integer()&lt;/code&gt;</source>
          <target state="translated">值： &lt;code&gt;integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813cf4fbeafa5124c59029940c3b8ba23a170cb6" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;on | off&lt;/code&gt;</source>
          <target state="translated">值： &lt;code&gt;on | off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65c8d38d0b9fb94d17867d4881ce4e1d9d89030a" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</source>
          <target state="translated">值： &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6970e248833158e8e073b58247bd68dcfc9cbf85" translate="yes" xml:space="preserve">
          <source>Values can be assigned in Erlang as follows:</source>
          <target state="translated">在Erlang中可以分配如下的值。</target>
        </trans-unit>
        <trans-unit id="2cb45cee19fe1842c7fe4075c27f3b1076ddd053" translate="yes" xml:space="preserve">
          <source>Values can be assigned to an ASN.1 type within the ASN.1 code itself, as opposed to the actions in the previous section where a value was assigned to an ASN.1 type in Erlang. The full value syntax of ASN.1 is supported and X.680 describes in detail how to assign values in ASN.1. A short example:</source>
          <target state="translated">值可以在ASN.1代码本身的范围内分配给ASN.1类型,而不是像上一节的操作那样,在Erlang中给ASN.1类型分配值。ASN.1支持完整的值语法,X.680详细描述了如何在ASN.1中赋值。一个简短的例子。</target>
        </trans-unit>
        <trans-unit id="0cebf5af2c916d50162daf2371942434d298c322" translate="yes" xml:space="preserve">
          <source>Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</source>
          <target state="translated">与Diameter头的R(equest)、P(roxiable)、E(rror)和T(Potentially re-transmitted message)标志相对应的值。</target>
        </trans-unit>
        <trans-unit id="96ef06f93f26e99ce4292fa7f5fd3f23d636c4eb" translate="yes" xml:space="preserve">
          <source>Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than &lt;code&gt;undefined&lt;/code&gt; implies a set V flag.</source>
          <target state="translated">AVP标头中的值分别对应于AVP代码，M标志，P标志和供应商ID。除 &lt;code&gt;undefined&lt;/code&gt; 之外的供应商ID 表示已设置V标志。</target>
        </trans-unit>
        <trans-unit id="a0444f2cacebf8b2705dc3aa6c687df85244bfd3" translate="yes" xml:space="preserve">
          <source>Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</source>
          <target state="translated">Diameter头的版本、消息长度、Command-Code、Application-ID、逐跳标识符和端到端标识符字段的值。</target>
        </trans-unit>
        <trans-unit id="25b7b3117ec67f563a385f6a6bbb3fc464310423" translate="yes" xml:space="preserve">
          <source>Values of these types are not currently parsed by diameter.</source>
          <target state="translated">这些类型的值目前不按直径解析。</target>
        </trans-unit>
        <trans-unit id="d14186fcac41fa3af58224092399d938dd7267c2" translate="yes" xml:space="preserve">
          <source>Values of this type can be assigned a value as an ordinary string as follows:</source>
          <target state="translated">这种类型的值可以像普通字符串一样被分配一个值,如下所示。</target>
        </trans-unit>
        <trans-unit id="297576f454c4d00030676aa9862a2b6c6efbd141" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;Emb&lt;/code&gt; can be assigned as follows:</source>
          <target state="translated">可以按以下方式分配 &lt;code&gt;Emb&lt;/code&gt; 类型的值：</target>
        </trans-unit>
        <trans-unit id="cee70396c85e9d16e65df42fd317982706258e73" translate="yes" xml:space="preserve">
          <source>Variable ::= - same as Erlang variables -</source>
          <target state="translated">变量 ::=-与 Erlang 变量相同 -</target>
        </trans-unit>
        <trans-unit id="748e5ba4cc296f39b4935e55b1705fc8ee581ce2" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;A&lt;/code&gt; is bound to the evaluated value of the list comprehension (&lt;code&gt;[1,2]&lt;/code&gt;). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a &lt;code&gt;badarg&lt;/code&gt; reason.</source>
          <target state="translated">变量 &lt;code&gt;A&lt;/code&gt; 绑定到列表理解（ &lt;code&gt;[1,2]&lt;/code&gt; ）的求值。编译器抱怨一条错误消息（&amp;ldquo;参数不是查询列表的理解&amp;rdquo;）；shell进程由于 &lt;code&gt;badarg&lt;/code&gt; 原因而停止。</target>
        </trans-unit>
        <trans-unit id="9a90e8a96c62ffb5d1cd6f65922e2fc9c80f1799" translate="yes" xml:space="preserve">
          <source>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</source>
          <target state="translated">变量绑定,以及在用户表达式中产生的本地进程字典变化都会被保存下来,变量可以在以后的命令中使用,以访问它们的值。绑定也可以被遗忘,这样变量就可以被重复使用。</target>
        </trans-unit>
        <trans-unit id="d0a8ee25c863aa2419107fceb204e47f57f1db36" translate="yes" xml:space="preserve">
          <source>Variable key length from 32 bits up to 448 bits</source>
          <target state="translated">密钥长度可从32位到448位不等。</target>
        </trans-unit>
        <trans-unit id="bfc036b2b9309c7bdc08e56f286b100a63accced" translate="yes" xml:space="preserve">
          <source>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</source>
          <target state="translated">可变的密钥长度从8位到2048位(通常在40和256位之间)。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="98c3d8899ac90eda2399d72ac989d5a5b85bf50c" translate="yes" xml:space="preserve">
          <source>Variables are bound to values through the &lt;strong&gt;pattern matching&lt;/strong&gt; mechanism. Pattern matching occurs when evaluating a function call, &lt;code&gt;case&lt;/code&gt;- &lt;code&gt;receive&lt;/code&gt;- &lt;code&gt;try&lt;/code&gt;- expressions and match operator (=) expressions.</source>
          <target state="translated">变量通过&lt;strong&gt;模式匹配&lt;/strong&gt;机制绑定到值。模式匹配在评估函数调用（ &lt;code&gt;case&lt;/code&gt; - &lt;code&gt;receive&lt;/code&gt; - &lt;code&gt;try&lt;/code&gt; -表达式和匹配运算符（=）表达式）时发生。</target>
        </trans-unit>
        <trans-unit id="2184e01d1f22737f67295ee5c99577b7f02640c4" translate="yes" xml:space="preserve">
          <source>Variables are bound to values using &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt;. Erlang uses &lt;strong&gt;single assignment&lt;/strong&gt;, that is, a variable can only be bound once.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt; 将变量绑定到值。Erlang使用&lt;strong&gt;单一分配&lt;/strong&gt;，即一个变量只能绑定一次。</target>
        </trans-unit>
        <trans-unit id="af1686696b0da48d910d4a99c77d1e302b425bc7" translate="yes" xml:space="preserve">
          <source>Variables can also be used to improve the readability of programs. For example, in function &lt;code&gt;list_max/2&lt;/code&gt; above, you can write:</source>
          <target state="translated">变量也可以用来提高程序的可读性。例如，在上面的函数 &lt;code&gt;list_max/2&lt;/code&gt; 中，您可以编写：</target>
        </trans-unit>
        <trans-unit id="e040ee86e634cf4aa0be3ce9492a2d6be860d5dc" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a fun.</source>
          <target state="translated">变量不能从fun中导出。</target>
        </trans-unit>
        <trans-unit id="9c57858e4cc8b9cf7467d2261e8b3c42734717f8" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a list comprehension.</source>
          <target state="translated">变量不能从列表理解中导出。</target>
        </trans-unit>
        <trans-unit id="f8d2854195ed04278e5b7b15a33240c69501a326" translate="yes" xml:space="preserve">
          <source>Variables exported from &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;case&lt;/code&gt; / &lt;code&gt;receive&lt;/code&gt; 导出的变量</target>
        </trans-unit>
        <trans-unit id="5eb952951e49a9b2fcfc380fe82f3b23f85123e9" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that the following works:</source>
          <target state="translated">可以导入环境中的变量,这样下面就可以了。</target>
        </trans-unit>
        <trans-unit id="ed92f2d37abdcb00aafc2e8c807cfc991b6f8842" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that this works:</source>
          <target state="translated">可以导入环境中的变量,这样就可以了。</target>
        </trans-unit>
        <trans-unit id="e88c0b53ad71637f25dfbd793cc2441d427e3881" translate="yes" xml:space="preserve">
          <source>Variables imported into matches</source>
          <target state="translated">输入到火柴中的变量</target>
        </trans-unit>
        <trans-unit id="1b2ab1f9eb238cbc2cccee8878b2d4f07a335e18" translate="yes" xml:space="preserve">
          <source>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</source>
          <target state="translated">趣头中的变量会对函数名和函数子句中围绕趣表达式的两个影子变量产生影子。绑定在fun体中的变量是fun体的局部变量。</target>
        </trans-unit>
        <trans-unit id="18d218f35a2e3577a6c500538445abcceb060b64" translate="yes" xml:space="preserve">
          <source>Variables in this section are only used, when configuring Erlang/OTP for cross compilation using &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt;.</source>
          <target state="translated">仅当使用 &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt; 配置Erlang / OTP进行交叉编译时，才使用本节中的变量。</target>
        </trans-unit>
        <trans-unit id="08df3acc57d3675cf908a2f26030ccd4ae2beb38" translate="yes" xml:space="preserve">
          <source>Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment &lt;code&gt;fun({A,B,C})&lt;/code&gt; is replaced by &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt;, and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; is translated into &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt;.</source>
          <target state="translated">fun开头出现的变量按匹配顺序按出现的顺序替换，因此片段 &lt;code&gt;fun({A,B,C})&lt;/code&gt; 替换为 &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt; ，等等。匹配规范中每次出现的此类变量都以相同的方式替换为匹配规范变量，以便将 &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; 转换为 &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0ae0e8be972f79e65125dff2b6c4f9cdfb890f0" translate="yes" xml:space="preserve">
          <source>Variables of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;s belong to an environment (&lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;). A term cannot be destructed individually, it is valid until its environment is destructed.</source>
          <target state="translated">&lt;code&gt;ERL_NIF_TERM&lt;/code&gt; 类型的变量可以引用任何Erlang术语。这是一种不透明类型，其值只能用作API函数的参数或用作NIF的返回值。所有 &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; s时对应的环境（ &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; ）。术语不能被单独破坏，它在其环境被破坏之前是有效的。</target>
        </trans-unit>
        <trans-unit id="debd1f76422a0d8de3199d01bf29f5e66c2af413" translate="yes" xml:space="preserve">
          <source>Variables shadowed in funs and list comprehensions</source>
          <target state="translated">变量在funs和列表理解中的影子。</target>
        </trans-unit>
        <trans-unit id="d19ebfb8e1f3e97056afbbe53540cc96bcfb11ed" translate="yes" xml:space="preserve">
          <source>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">变量以大写字母或下划线（_）开头。变量可以包含字母数字字符，下划线和 &lt;code&gt;@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09f862d436d21532b455bff8e767c989deff6bc5" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;_@&lt;/code&gt;, for example &lt;code&gt;_@bar&lt;/code&gt; or &lt;code&gt;_@Bar&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;_@&lt;/code&gt; 开头的变量，例如 &lt;code&gt;_@bar&lt;/code&gt; 或 &lt;code&gt;_@Bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1225854353b77d49f7cc40d13247de7c80827209" translate="yes" xml:space="preserve">
          <source>Variables starting with underscore (_), for example, &lt;code&gt;_Height&lt;/code&gt;, are normal variables, not anonymous. They are however ignored by the compiler in the sense that they do not generate any warnings for unused variables.</source>
          <target state="translated">以下划线（_）开头的变量，例如 &lt;code&gt;_Height&lt;/code&gt; ，是普通变量，不是匿名变量。但是，它们不会对未使用的变量生成任何警告，因此编译器会忽略它们。</target>
        </trans-unit>
        <trans-unit id="024d797490e6edf809ed5b6c2e34f4bc4f3bebd1" translate="yes" xml:space="preserve">
          <source>Variables take the form &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt;, where &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is &lt;strong&gt;undefined&lt;/strong&gt;. In the &lt;code&gt;MatchHead&lt;/code&gt; part, the special variable &lt;code&gt;'_'&lt;/code&gt; matches anything, and never gets bound (like &lt;code&gt;_&lt;/code&gt; in Erlang).</source>
          <target state="translated">变量采用 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 的形式，其中 &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; 是0到100,000,000（1e + 8）之间的整数。如果数字超出这些限制，则行为是&lt;strong&gt;不确定的&lt;/strong&gt;。在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中，特殊变量 &lt;code&gt;'_'&lt;/code&gt; 匹配任何内容，并且永远不会被绑定（如Erlang中的 &lt;code&gt;_&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="00bf9ad78f5cec1dd65d66ced1104921a78f995a" translate="yes" xml:space="preserve">
          <source>Variables that are defined before the fun, and that occur in function calls or guard tests within the fun, have the values they had outside the fun.</source>
          <target state="translated">在fun之前定义的变量,以及在fun中的函数调用或防护测试中出现的变量,其值在fun之外。</target>
        </trans-unit>
        <trans-unit id="bf0dcb58581abd4fe80849d394380c5cd405dc3e" translate="yes" xml:space="preserve">
          <source>Variables that are not included in the head are imported from the environment and made into match specification &lt;code&gt;const&lt;/code&gt; expressions. Example from the shell:</source>
          <target state="translated">头部中不包含的变量将从环境中导入，并制成匹配规范 &lt;code&gt;const&lt;/code&gt; 表达式。来自shell的示例：</target>
        </trans-unit>
        <trans-unit id="e0fa7e4c68a7ab8979529890e0791f677b7bd7ef" translate="yes" xml:space="preserve">
          <source>Variables that have been bound on the left side can be used on the right side. For example, this rule will rewrite all &lt;code&gt;move&lt;/code&gt; instructions to &lt;code&gt;assign&lt;/code&gt; instructions with the operands swapped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55df9f3ef32c412357dbc3a18bd56c7d4ce619de" translate="yes" xml:space="preserve">
          <source>Variance :: number(),</source>
          <target state="translated">差异 ::数字()。</target>
        </trans-unit>
        <trans-unit id="0e31c4461c806559eaf12528c8fe9a9d293a746d" translate="yes" xml:space="preserve">
          <source>Various &quot;isolate&quot;s</source>
          <target state="translated">各种 &quot;孤立 &quot;的</target>
        </trans-unit>
        <trans-unit id="a1d64fcf9bb61fad40e3871e66b33e563f5b1f28" translate="yes" xml:space="preserve">
          <source>Various Erlang net administration routines.</source>
          <target state="translated">各种Erlang网管理例程。</target>
        </trans-unit>
        <trans-unit id="f6b924712003f40d3f2878b1cac363cf1976078c" translate="yes" xml:space="preserve">
          <source>Vendor-Id AVP</source>
          <target state="translated">供应商-ID AVP</target>
        </trans-unit>
        <trans-unit id="48eb606505901d94f78b31e43f73e095bdf04786" translate="yes" xml:space="preserve">
          <source>Vendor-Specific-Application-Id AVP</source>
          <target state="translated">供应商特定应用-ID AVP</target>
        </trans-unit>
        <trans-unit id="e96f73110a27dcecf42e3942850fdb9a84214cad" translate="yes" xml:space="preserve">
          <source>Verbose = &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">详细= &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="adb0c527629b97acddda692f399e9ccb978796eb" translate="yes" xml:space="preserve">
          <source>Verbosity for a SNMP process. This specifies now much debug info is printed.</source>
          <target state="translated">SNMP进程的信息量。这指定了现在会打印很多调试信息。</target>
        </trans-unit>
        <trans-unit id="fee450697a5689ff92f9f50edecbf9c5c91da171" translate="yes" xml:space="preserve">
          <source>Verifies PKIX x.509 certificate signature.</source>
          <target state="translated">验证PKIX x.509证书签名。</target>
        </trans-unit>
        <trans-unit id="4326ee1947d5233b0586b451628ad661e97a0e04" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature</source>
          <target state="translated">核实数字签名</target>
        </trans-unit>
        <trans-unit id="d9ade396ed77dbd522a02203fe6942326134914f" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature.</source>
          <target state="translated">核实数字签名;</target>
        </trans-unit>
        <trans-unit id="b9525ebe014b53689fa4e11b528180aae4abeb4b" translate="yes" xml:space="preserve">
          <source>Verifies that the current location of the execution is visible in the code area.</source>
          <target state="translated">验证当前执行的位置在代码区是否可见。</target>
        </trans-unit>
        <trans-unit id="1dc4741dffd06fe660bc6cd57000623888541a03" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;Cert&lt;/code&gt; is the &lt;code&gt;CRL&lt;/code&gt; signer.</source>
          <target state="translated">验证 &lt;code&gt;Cert&lt;/code&gt; 是 &lt;code&gt;CRL&lt;/code&gt; 签名者。</target>
        </trans-unit>
        <trans-unit id="f040269483ba291a5dc58f8344423a743ace3bf6" translate="yes" xml:space="preserve">
          <source>Verify with an engine stored public key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536244f4cc64c32141c5753233b90a09618435ae" translate="yes" xml:space="preserve">
          <source>Verifying</source>
          <target state="translated">Verifying</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d5417e5a99f86d22c5664ec343d3a6c2609ec65a" translate="yes" xml:space="preserve">
          <source>Version 1.6.10 or later of the &lt;strong&gt;asn1&lt;/strong&gt; application.</source>
          <target state="translated">1.6.10或更高版本的&lt;strong&gt;asn1&lt;/strong&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="a661417de642bc6b468d76fe5b3c6bc8775de7ac" translate="yes" xml:space="preserve">
          <source>Version 3.11 or later of &lt;strong&gt;this&lt;/strong&gt; application.</source>
          <target state="translated">&lt;strong&gt;此&lt;/strong&gt;应用程序的3.11版或更高版本。</target>
        </trans-unit>
        <trans-unit id="2c53b65799c019b459fedea45335868fd7a802d8" translate="yes" xml:space="preserve">
          <source>Version downgrade protection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554f7abde7f492a763703dbbf95c1a1680dca835" translate="yes" xml:space="preserve">
          <source>Version downgrade protection mechanism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9406ae17f9404f81cf7cdbb053a74c6ecc560456" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e5ca082097444de77af1c9fd7d0a5134aed383" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="translated">已将其 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; 字段设置为 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 的驱动程序启用了版本管理。 &lt;code&gt;erl_driver.h&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="21b8714f6e355164babd4f77276d9b70c8b55f19" translate="yes" xml:space="preserve">
          <source>Version numbers in general are only partially ordered. However, normal version numbers (with three parts) as of OTP 17.0 have a total or linear order. This applies both to normal OTP versions and normal application versions.</source>
          <target state="translated">一般来说,版本号只有部分顺序。但是,从OTP 17.0开始,正常的版本号(有三部分)有一个总的或线性的顺序。这既适用于正常的OTP版本,也适用于正常的应用程序版本。</target>
        </trans-unit>
        <trans-unit id="e126978ac6222c855c920d79411bed5cf12c2966" translate="yes" xml:space="preserve">
          <source>Version of an application included in the release.</source>
          <target state="translated">版本中包含的应用程序的版本。</target>
        </trans-unit>
        <trans-unit id="473be10b81925976c7e4903e9b43ac593c8ae1c5" translate="yes" xml:space="preserve">
          <source>Version of the application.</source>
          <target state="translated">应用程序的版本。</target>
        </trans-unit>
        <trans-unit id="9a7876f7a0f780d649e426501cf895ebbd7b0903" translate="yes" xml:space="preserve">
          <source>Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</source>
          <target state="translated">竖条字符用于分隔备选模式。例如,以下图案与 &quot;gilbert &quot;或 &quot;sullivan &quot;相匹配。</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">垂直标签</target>
        </trans-unit>
        <trans-unit id="5fd82a7e8d422aaa4b53ae82c82d9414739c27a0" translate="yes" xml:space="preserve">
          <source>Vertical tab (VT)</source>
          <target state="translated">纵向标签(VT)</target>
        </trans-unit>
        <trans-unit id="089b74a153ec7d14e48cc1b72fe57aef02d54503" translate="yes" xml:space="preserve">
          <source>Vertical tab.</source>
          <target state="translated">纵向标签。</target>
        </trans-unit>
        <trans-unit id="29e9914d64c8384c209127eaf16006134a978f22" translate="yes" xml:space="preserve">
          <source>Very similar to &lt;code&gt;portTypeAcceptor&lt;/code&gt;, an intermediate stage between the request for a connect operation and that the socket is connected to an accepting ditto in the other end. When the sockets are connected, the port switches type to &lt;code&gt;portTypeCommand&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;portTypeAcceptor&lt;/code&gt; 非常相似，它是连接操作请求与套接字在另一端连接到接受同上之间的中间阶段。连接套接字后，端口开关的类型为 &lt;code&gt;portTypeCommand&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e64e0bec8b57844c72ad51fbe4f769f2b726868" translate="yes" xml:space="preserve">
          <source>Viewer menu:</source>
          <target state="translated">查看器菜单。</target>
        </trans-unit>
        <trans-unit id="a76c37f0a0334ff643407ad5eae8341e4157dd19" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 (Visual Studio 12.0). Download and run the web installer from:</source>
          <target state="translated">Visual Studio 2013(Visual Studio 12.0)。下载并运行网络安装程序,从。</target>
        </trans-unit>
        <trans-unit id="244d869d05e05e311d391ddca36084184536284d" translate="yes" xml:space="preserve">
          <source>Visual Studio 2019 Download and run the installer from: &lt;code&gt;&lt;a href=&quot;http://visualstudio.microsoft.com/downloads&quot;&gt;http://visualstudio.microsoft.com/downloads&lt;/a&gt;&lt;/code&gt; Install C++ and SDK packages to the default installation directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915e18af7a75d3dbbd7d92286c7e2d9ac312998" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="translated">瞧！ &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; 启动Erlang Windows Shell。</target>
        </trans-unit>
        <trans-unit id="a6f93d383c4325ccf160b881c9d175a89508dbb1" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 23-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716dd3292ee085b4712046407eb276268b149ea2" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="translated">自愿让其他进程（如果有）有机会执行。使用此函数类似于 &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt; ，除了 &lt;code&gt;yield()&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="8fb00b6962541e4e4e75cf39aece6826243afc2a" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; true end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e07124d37d04067c5b24ce9f8122728b6c492ef" translate="yes" xml:space="preserve">
          <source>VxWorks Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d736ea0f1fc6aa3f95dc939e7dc07d919541f69e" translate="yes" xml:space="preserve">
          <source>WSL: Install WSL and Ubuntu in Windows 10 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;https://docs.microsoft.com/en-us/windows/wsl/install-win10&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebf20f8d1333c6ed323b151df8d0b75baeab5a0" translate="yes" xml:space="preserve">
          <source>Wait for an ack.</source>
          <target state="translated">等到一声 &quot;啊&quot;。</target>
        </trans-unit>
        <trans-unit id="4d14f3abfec373cbe89f6626aa814e6ca203b696" translate="yes" xml:space="preserve">
          <source>Wait for reply after having received a pending message.</source>
          <target state="translated">收到待处理信息后,等待回复。</target>
        </trans-unit>
        <trans-unit id="03a3dd1877c6b650ce26278dad8e2fb191a587d5" translate="yes" xml:space="preserve">
          <source>Wait for reply.</source>
          <target state="translated">等待答复。</target>
        </trans-unit>
        <trans-unit id="8094e62f79c4399dd8f66ec127a5866ea7c65659" translate="yes" xml:space="preserve">
          <source>Wait for thread progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fa9326ddb841f72c6292157f69d607e668076c" translate="yes" xml:space="preserve">
          <source>Wait or poll for a response message to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process using &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;RequestId&lt;/code&gt; should be the value returned from the previously made &lt;code&gt;erpc:send_request()&lt;/code&gt; call, and the corresponding response should not already have been received and handled to completion by &lt;code&gt;&lt;a href=&quot;#check_response-2&quot;&gt;erpc:check_response()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;erpc:wait_response()&lt;/code&gt;. &lt;code&gt;WaitTime&lt;/code&gt; equals the time to wait in milliseconds (or the atom &lt;code&gt;infinity&lt;/code&gt;) during the wait. &lt;code&gt;WaitTime&lt;/code&gt; is an integer representing time to wait in milliseconds or the atom &lt;code&gt;infinity&lt;/code&gt; which will cause &lt;code&gt;wait_response/2&lt;/code&gt; to wait for a response until it appears regardless of how long time that is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5a9ccfb857e48896b332926f19499a3bf34466" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive...after&lt;/code&gt;.</source>
          <target state="translated">等待 &lt;code&gt;receive...after&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15e59facfb286b560b3bd7e76028f43e2127a06c" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">等待 &lt;code&gt;receive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3d6ef3cb84dde159db4dc284cfdc308ccef71dd" translate="yes" xml:space="preserve">
          <source>Waiting. This state is currently only identified on Solaris.</source>
          <target state="translated">等待。这种状态目前只在Solaris上识别。</target>
        </trans-unit>
        <trans-unit id="7c806137ff16518173274ba603d62ffafc3bdf63" translate="yes" xml:space="preserve">
          <source>Waits for a reply.</source>
          <target state="translated">等待回复。</target>
        </trans-unit>
        <trans-unit id="bd2ac24407b3f1c35309d00d94c7cf3be1ef6a8a" translate="yes" xml:space="preserve">
          <source>Waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked, it unlocks the mutex passed as argument. When the calling thread is woken, it locks the same mutex before returning. That is, the mutex currently must be locked by the calling thread when calling this function.</source>
          <target state="translated">在条件变量上等待。调用线程被阻塞,直到另一个线程通过信号或广播条件变量来唤醒它。在调用线程被阻塞之前,它解锁作为参数传递的mutex。当调用线程被唤醒时,它在返回之前锁定相同的mutex。也就是说,当调用这个函数时,mutex当前必须被调用线程锁定。</target>
        </trans-unit>
        <trans-unit id="ab9651595cb08f88e44fd940126d1c71dd69f853" translate="yes" xml:space="preserve">
          <source>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">等待数据提交并在每个涉及的节点上记录到磁盘（如果使用磁盘）之后再返回，否则将表现为 &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d95099fabbff08dd069c5c4ee916cb8f9b1a506" translate="yes" xml:space="preserve">
          <source>Wallclock_Time_Since_Last_Call}</source>
          <target state="translated">Wallclock_Time_Since_Last_Call}</target>
        </trans-unit>
        <trans-unit id="c3b288f7da975708a0f5e331c0f162ed064cf7c2" translate="yes" xml:space="preserve">
          <source>Warang_Citi</source>
          <target state="translated">Warang_Citi</target>
        </trans-unit>
        <trans-unit id="73cea05d9ab0a2033c2e880c88d16336c1ad4134" translate="yes" xml:space="preserve">
          <source>Warn about overspecified functions (the specification is strictly less allowing than the success typing).</source>
          <target state="translated">警惕超规格的函数(规格严格小于成功打字的允许)。</target>
        </trans-unit>
        <trans-unit id="09d2b974a5e842f51243b3499495df6bdd13bcaa" translate="yes" xml:space="preserve">
          <source>Warn about underspecified functions (the specification is strictly more allowing than the success typing).</source>
          <target state="translated">警惕欠规范的函数(规范严格来说比成功打字更允许)。</target>
        </trans-unit>
        <trans-unit id="6cccd5dcb30984a83e1ff196e1800d93a16fd24a" translate="yes" xml:space="preserve">
          <source>Warn when the specification is different than the success typing.</source>
          <target state="translated">当规格与成功打字不同时,警告。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="83bd22f6ddfb4c6af6ec49ac28fc7020e55db1cb" translate="yes" xml:space="preserve">
          <source>Warning events were introduced in Erlang/OTP R9C and are enabled by default as from Erlang/OTP 18.0. To retain backwards compatibility with existing user-defined event handlers, the warning events can be tagged as &lt;code&gt;errors&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt; using command-line flag &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt;, thus showing up as &lt;code&gt;ERROR REPORT&lt;/code&gt; or &lt;code&gt;INFO REPORT&lt;/code&gt; in the logs.</source>
          <target state="translated">警告事件是在Erlang / OTP R9C中引入的，默认情况下从Erlang / OTP 18.0开始启用。为了保持与现有用户定义事件处理程序的向后兼容性，可以使用命令行标志 &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt; 将警告事件标记为 &lt;code&gt;errors&lt;/code&gt; 或 &lt;code&gt;info&lt;/code&gt; 。我 w&amp;gt;，因此在日志中显示为 &lt;code&gt;ERROR REPORT&lt;/code&gt; 或 &lt;code&gt;INFO REPORT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c71f2eab8af60b63ce0e407c87968c7af135f73" translate="yes" xml:space="preserve">
          <source>Warning option &lt;code&gt;-Wrace_conditions&lt;/code&gt; has no effect when set in source files.</source>
          <target state="translated">在源文件中设置警告选项 &lt;code&gt;-Wrace_conditions&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="b855954419a97257855c46e228014ea8104ff80a" translate="yes" xml:space="preserve">
          <source>Warning options can be restricted to functions:</source>
          <target state="translated">警告选项可以限制在功能上。</target>
        </trans-unit>
        <trans-unit id="350f98fe7365f5591c6175d100ed10f345354502" translate="yes" xml:space="preserve">
          <source>Warning: you wanted to visit the site www.example.com, but the certificate is for shop.example.com. Accept anyway (yes/no)?&quot;</source>
          <target state="translated">警告:你想访问网站www.example.com,但证书是shop.example.com的。无论如何接受(是/否)?&quot;</target>
        </trans-unit>
        <trans-unit id="4e6fc17d67b22f27c12488bddcfdd561fdbab970" translate="yes" xml:space="preserve">
          <source>Warnings and Restrictions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa481bc1014e68bf8d7481ee0ba5e89fda097c2" translate="yes" xml:space="preserve">
          <source>We add &lt;code&gt;-heart&lt;/code&gt; to &lt;code&gt;bin/start&lt;/code&gt;:</source>
          <target state="translated">我们将 &lt;code&gt;-heart&lt;/code&gt; 添加到 &lt;code&gt;bin/start&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="73b280a7b7aba8731e641abebde7cc0face25615" translate="yes" xml:space="preserve">
          <source>We already have the data as (Unicode) lists and therefore only split the list in runs of a predefined size and put each run in the table at the current position (and forward). Functions &lt;code&gt;split_data/3&lt;/code&gt; and &lt;code&gt;apply_update/2&lt;/code&gt; are implemented below.</source>
          <target state="translated">我们已经将数据作为（Unicode）列表，因此只能将列表拆分为预定义大小的运行，并将每个运行都放在表中的当前位置（向前）。函数 &lt;code&gt;split_data/3&lt;/code&gt; 和 &lt;code&gt;apply_update/2&lt;/code&gt; 在下面实现。</target>
        </trans-unit>
        <trans-unit id="da12a6009775f6352a760fe1d7ed31c170d4b8e7" translate="yes" xml:space="preserve">
          <source>We also need a CommonTest test suite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226f0d44c399be112d6e2c67714235696a1e7cd" translate="yes" xml:space="preserve">
          <source>We also see that the call to &lt;code&gt;file:write/2&lt;/code&gt; that writes 1/4 of the file contents takes very little time in itself. What takes time is to build the data (&lt;code&gt;lists:seq/2&lt;/code&gt; and &lt;code&gt;lists:map/2&lt;/code&gt;).</source>
          <target state="translated">我们还看到对 &lt;code&gt;file:write/2&lt;/code&gt; 的调用（其写入文件内容的1/4）本身花费的时间很少。需要时间来构建数据（ &lt;code&gt;lists:seq/2&lt;/code&gt; 和 &lt;code&gt;lists:map/2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a7655995e200021034a1234263f9bb9fd897f337" translate="yes" xml:space="preserve">
          <source>We also want threads to be able to determine when thread progress has been made relatively fast. That is we need to have some balance between comunication overhead and time to complete the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ee7e4ad5636419e727eed1a3416350054ba7c" translate="yes" xml:space="preserve">
          <source>We always strive to remain as compatible as possible even in the cases where we give no compatibility guarantees.</source>
          <target state="translated">即使在我们不保证兼容性的情况下,我们也会努力保持尽可能的兼容性。</target>
        </trans-unit>
        <trans-unit id="225f863cbc345617cdd927f674aea220d5833e8d" translate="yes" xml:space="preserve">
          <source>We begin by reserving space in the table by atomically incrementing a counter of processes in the table. If our increment brings the counter above the maximum size of the table, the operation fail and a &lt;code&gt;system_limit&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c06b23c2a34df45341a353c1d6915221b4316d" translate="yes" xml:space="preserve">
          <source>We belive that the truth finally has caught with the following, retired myths.</source>
          <target state="translated">我们相信,真相终于抓住了以下,退役的神话。</target>
        </trans-unit>
        <trans-unit id="a21d18a0aa2c147b58a169cb973ed1ce3338cf1f" translate="yes" xml:space="preserve">
          <source>We call a set of ordered sets (x[1], ..., x[n]) an &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) relation&lt;/strong&gt;, and say that the relation is a subset of the Cartesian product X[1] &amp;times; ... &amp;times; X[n], where x[i] is an element of X[i], 1 &amp;lt;= i &amp;lt;= n.</source>
          <target state="translated">我们称一组有序集（x [1]，...，x [n]）为&lt;strong id=&quot;n_ary_relation&quot;&gt;（n元）关系&lt;/strong&gt;，并且说该关系是笛卡尔积X [1]&amp;times;...的子集。 &amp;times;X [n]，其中x [i]是X [i]的元素，1 &amp;lt;= i &amp;lt;= n。</target>
        </trans-unit>
        <trans-unit id="413c823c35b15bc9d9bba19b8e901ed4a84786b5" translate="yes" xml:space="preserve">
          <source>We call disconnect to log out from the database. (This should have been done from Erlang, but just in case.)</source>
          <target state="translated">我们调用disconnect来从数据库中注销。(这应该是在Erlang中完成的,但以防万一。)</target>
        </trans-unit>
        <trans-unit id="522acbf7d3d85ef274cefb977f558982277af2ea" translate="yes" xml:space="preserve">
          <source>We call this fragment &lt;code&gt;execute&lt;/code&gt;. It will handle the three remaining operands (&lt;code&gt;W t d&lt;/code&gt;). There will only be one copy of this fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0e548c81b6e89076547f66f838c75eec0931cf" translate="yes" xml:space="preserve">
          <source>We call this fragment &lt;code&gt;fetch&lt;/code&gt;. This fragment will be duplicated three times, one for each value of the first operand (&lt;code&gt;r&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a622cc685c06ebc1847f597b7b757bf135bf65a2" translate="yes" xml:space="preserve">
          <source>We can also start a distributed system (requires &lt;code&gt;bin/epmd&lt;/code&gt;).</source>
          <target state="translated">我们还可以启动分布式系统（需要 &lt;code&gt;bin/epmd&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d27be01791833f5e7361c562bc0586ab7a53f67b" translate="yes" xml:space="preserve">
          <source>We can in this example hibernate in the &lt;code&gt;{open,_}&lt;/code&gt; state, because what normally occurs in that state is that the state time-out after a while triggers a transition to &lt;code&gt;{locked,_}&lt;/code&gt;:</source>
          <target state="translated">在此示例中，我们可以进入 &lt;code&gt;{open,_}&lt;/code&gt; 状态休眠，因为通常在该状态下发生的是一段时间后状态超时触发向 &lt;code&gt;{locked,_}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="723ac72181a0f65089e1039932052a9e46e076de" translate="yes" xml:space="preserve">
          <source>We can now continue with further analyses, or we can delete the Xref server:</source>
          <target state="translated">现在我们可以继续进行进一步的分析,也可以删除Xref服务器。</target>
        </trans-unit>
        <trans-unit id="2cc179d98b76e6b3d41baf1c227027f8bb4da940" translate="yes" xml:space="preserve">
          <source>We can see that that &lt;code&gt;$NEXT_INSTRUCTION&lt;/code&gt; has been expanded to &lt;code&gt;I+2&lt;/code&gt;. That makes sense since the size of the &lt;code&gt;i_call_f/1&lt;/code&gt; instruction is two words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a68a7d66829ca42ef25d404e41acb97b44c301" translate="yes" xml:space="preserve">
          <source>We can see that the prefetch is no longer done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80d30cce8e804ded34a7689032f878d3a116eea" translate="yes" xml:space="preserve">
          <source>We can then define:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d9647a6d5681d02b8300287887329e1b58baac" translate="yes" xml:space="preserve">
          <source>We check which algoritms are negotiated by the client and the server, and note that the (only) &lt;code&gt;kex&lt;/code&gt; algorithm &lt;code&gt;'curve25519-sha256@libssh.org'&lt;/code&gt; was selected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731dac39a948da6420329e5012364c57947f8871" translate="yes" xml:space="preserve">
          <source>We chose a &quot;semi locked&quot; approach, with one public locked task queue, and a private, lock free, queue like, task data structure. This &quot;semi locked&quot; approach is similar to how the message boxes of processes are managed. The lock is port specific and only used for protection of port tasks, so the run queue lock is now needed in more or less the same way for ports as for processes. This ensures that we wont see an increased lock contention on run queue locks due to this rewrite of the port functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed2f11fd9224dc5918c516e18e8c1fc044f95ee" translate="yes" xml:space="preserve">
          <source>We continue the example above by connecting to a server and modifying the &lt;code&gt;kex&lt;/code&gt; algorithm set. We remove the only one (&lt;code&gt;'ecdh-sha2-nistp384'&lt;/code&gt;) and add &lt;code&gt;'curve25519-sha256@libssh.org'&lt;/code&gt; by appending it to the now empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256ebb1297d3c5168e6d4942a26c829b8f6be203" translate="yes" xml:space="preserve">
          <source>We continue trying to write until the queue is empty or the writing blocks.</source>
          <target state="translated">我们继续尝试写入,直到队列空了或者写入阻塞。</target>
        </trans-unit>
        <trans-unit id="598054eadf14bd6e3fc4f983c0ea4bf5d2acfe0d" translate="yes" xml:space="preserve">
          <source>We could find the size of the closure of the module graph with a loop similar to one used for the function graph, but since the module graph is so much smaller, a more direct method is feasible.</source>
          <target state="translated">我们可以用类似于函数图的循环来求模块图的闭合大小,但由于模块图小得多,所以更直接的方法是可行的。</target>
        </trans-unit>
        <trans-unit id="d13bdb2791f9edb9789c1e21484024176d248d1d" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a &lt;strong&gt;state change&lt;/strong&gt; and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1991f07b9f9058aea6db1e8f77c1b4a56e270edc" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a state change and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="translated">我们可以说这个按钮按得太早了,所以不能被识别为锁定按钮。或者我们可以把锁按钮变成状态的一部分,这样当我们再锁定状态下改变锁按钮时,这个改变就变成了状态的改变,所有推迟的事件都会被重试,因此锁就会立即被锁住!</target>
        </trans-unit>
        <trans-unit id="5a9ed4b8c10518737f16e11ac495badece57b9c4" translate="yes" xml:space="preserve">
          <source>We create the table using:</source>
          <target state="translated">我们用以下方法创建表格。</target>
        </trans-unit>
        <trans-unit id="32473b5c4698fb40d28c5576c29bf1a8447287f7" translate="yes" xml:space="preserve">
          <source>We define the state as &lt;code&gt;{StateName,LockButton}&lt;/code&gt;, where &lt;code&gt;StateName&lt;/code&gt; is as before and &lt;code&gt;LockButton&lt;/code&gt; is the current lock button:</source>
          <target state="translated">我们将状态定义为 &lt;code&gt;{StateName,LockButton}&lt;/code&gt; ，其中 &lt;code&gt;StateName&lt;/code&gt; 和以前一样，而 &lt;code&gt;LockButton&lt;/code&gt; 是当前的锁定按钮：</target>
        </trans-unit>
        <trans-unit id="7e5b4ef345a93f5049df742fe31287578cf4c7e2" translate="yes" xml:space="preserve">
          <source>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing.</source>
          <target state="translated">我们不需要为每个表持有者设置一个子代理。通常情况下,需要子代理来负责通信,但在分布式Erlang中,我们使用普通的消息传递。</target>
        </trans-unit>
        <trans-unit id="3dcce44305924654369f1be725b80d831eab3129" translate="yes" xml:space="preserve">
          <source>We execute a query and encode the result. Encoding is done in another C module, &lt;code&gt;pg_encode.c&lt;/code&gt;, which is also provided as sample code.</source>
          <target state="translated">我们执行查询并对结果进行编码。编码是在另一个C模块 &lt;code&gt;pg_encode.c&lt;/code&gt; 中完成的，该模块也作为示例代码提供。</target>
        </trans-unit>
        <trans-unit id="c0fc2d127a89f720c3128d44e169672e74e15c80" translate="yes" xml:space="preserve">
          <source>We fill the table with randomly chosen data:</source>
          <target state="translated">我们用随机选择的数据填充表格。</target>
        </trans-unit>
        <trans-unit id="3c1b0d2fdb890ab43ab70bb52624aa632e05a8ee" translate="yes" xml:space="preserve">
          <source>We find no particulary long suspend times, so no function seems to have waited in a receive statement. Actually, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contains a receive statement, but in this test program, the message lies in the process receive buffer when the receive statement is entered. We also see that the total suspend time for the test run is small.</source>
          <target state="translated">我们没有特别长的挂起时间，因此似乎没有函数在接收语句中等待。实际上， &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; 包含一条接收语句，但是在此测试程序中，输入接收语句时，消息位于进程接收缓冲区中。我们还看到测试运行的总暂停时间很小。</target>
        </trans-unit>
        <trans-unit id="539abdc8c79a99e16a54fd4c1353932c38835c6d" translate="yes" xml:space="preserve">
          <source>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on.</source>
          <target state="translated">我们得到Mnesia的所有功能,如容错、持久化数据存储、复制等。</target>
        </trans-unit>
        <trans-unit id="162b9af34243f4c75d056a06375ee57f22d03768" translate="yes" xml:space="preserve">
          <source>We handle the requests for retrieving data:</source>
          <target state="translated">我们处理检索数据的请求。</target>
        </trans-unit>
        <trans-unit id="82bb167cd1f1aaced33ce89ec08193896c8c8861" translate="yes" xml:space="preserve">
          <source>We have a structure to store state needed by the driver, in this case we only need to keep the database connection:</source>
          <target state="translated">我们有一个结构来存储驱动所需要的状态,在这种情况下,我们只需要保留数据库连接。</target>
        </trans-unit>
        <trans-unit id="f0f2ae2c27d8d0a5f2644b532540797a414ff961" translate="yes" xml:space="preserve">
          <source>We have included some simple tool(s) for codec measurement (meas), performance tests (mstone1 and mstone2) and message transformation.</source>
          <target state="translated">我们已经包含了一些简单的工具,用于编解码器测量(meas)、性能测试(mstone1和mstone2)和信息转换。</target>
        </trans-unit>
        <trans-unit id="8d35a0217a0c4d25516c55c6b13eeb0ee82ce246" translate="yes" xml:space="preserve">
          <source>We have instrumented our code in order to enable tracing. Running the application with tracing deactivated, causes a negligible performance overhead (an external call to a function which returns an atom). Activation of tracing does not require any recompilation of the code, since we rely on Erlang/OTP's built in support for dynamic trace activation. In our case tracing of calls to a given external function.</source>
          <target state="translated">我们对我们的代码进行了工具化处理,以便启用跟踪功能。在停用跟踪的情况下运行应用程序,会造成可忽略的性能开销(外部调用一个返回原子的函数)。激活跟踪不需要重新编译代码,因为我们依靠的是Erlang/OTP对动态跟踪激活的内置支持。在我们的例子中,跟踪对一个给定外部函数的调用。</target>
        </trans-unit>
        <trans-unit id="19f3224f897b7485ee092aee943fad0f50d468c0" translate="yes" xml:space="preserve">
          <source>We have introduced the term &quot;user&quot; as a generic term for either an MG or an MGC, since most of the functionality we support, is common for both MG's and MGC's. A (local) user may be configured in various ways and it may establish any number of connections to its counterpart, the remote user. Once a connection has been established, the connection is supervised and it may be used for the purpose of sending messages. N.B. according to the standard an MG is connected to at most one MGC, while an MGC may be connected to any number of MG's.</source>
          <target state="translated">我们引入 &quot;用户 &quot;一词作为MG或MGC的通用术语,因为我们支持的大多数功能对MG和MGC都是通用的。一个(本地)用户可以以各种方式进行配置,并且它可以建立任何数量的连接到其对应的远程用户。一旦建立了一个连接,该连接就会受到监督,并可用于发送消息。注:根据标准,一个MG最多连接到一个MGC,而一个MGC可以连接到任何数量的MG。</target>
        </trans-unit>
        <trans-unit id="877518c89585383e3076c104aa3cd7f7e23bc498" translate="yes" xml:space="preserve">
          <source>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</source>
          <target state="translated">我们对我们的Erlang/OTP实现的Megaco/H.248协议栈进行了四次不同的测量,以比较我们不同的编码器/解码器。下表总结了每一项的结果。</target>
        </trans-unit>
        <trans-unit id="e594586e3be21133f5db0b9bde85bb9f42084bb6" translate="yes" xml:space="preserve">
          <source>We have sometimes experienced problems with Oracle's &lt;code&gt;java&lt;/code&gt; running out of memory when running &lt;code&gt;fop&lt;/code&gt;. Increasing the amount of memory available as follows has in our case solved the problem.</source>
          <target state="translated">在运行 &lt;code&gt;fop&lt;/code&gt; 时，有时Oracle的 &lt;code&gt;java&lt;/code&gt; 内存不足会遇到问题。在我们的情况下，按以下方式增加可用内存量已解决了该问题。</target>
        </trans-unit>
        <trans-unit id="bd8061d4d0a1f8978730bf0df09ec0f575e585ee" translate="yes" xml:space="preserve">
          <source>We have used and tested with WSL-1, WSL-2 was not available and may not be prefered when building Erlang/OTP since access to the windows disk is (currently) slower WSL-2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ef581fc03c4350a26dcbbfc87b431aa1e17cc7" translate="yes" xml:space="preserve">
          <source>We implemented a test version using lock free run queues. This implementation did however not perform as good as the version using one lock per run queue. The reason for this was not investigated enough to say why this was. Since the locked version performed better we kept it, at least for now. The lock free version, however, forced us to use other solutions, some of them we kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc0044e17c922875d4350027f6b2f290ff7821f" translate="yes" xml:space="preserve">
          <source>We include &lt;code&gt;FromPid&lt;/code&gt; just in case we want to trace this.</source>
          <target state="translated">我们包括 &lt;code&gt;FromPid&lt;/code&gt; ，以防万一我们要跟踪它。</target>
        </trans-unit>
        <trans-unit id="f19bccb4e164c8777a7def288e8e12ee2b2459b4" translate="yes" xml:space="preserve">
          <source>We increment last identifier value used. In order determine the slot that corresponds to this identifier we call &lt;code&gt;erts_ptab_data2pix()&lt;/code&gt; that maps identifier to slot. We read the content of the slot. If the slot is free we try to write a reservation marker using an atomic compare and swap. If this fails we repeat this step until it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c14d96eb9053e2cc8b3f1d2c457d07c9567687" translate="yes" xml:space="preserve">
          <source>We loop through the requests one at the time, stopping when we either encounter an error or the list is exhausted. The last return value is sent back to the client (it is first returned to the main loop and then sent back by function &lt;code&gt;io_reply&lt;/code&gt;).</source>
          <target state="translated">我们一次遍历一个请求，遇到错误或列表耗尽时停止。最后的返回值发送回客户端（首先返回到主循环，然后由 &lt;code&gt;io_reply&lt;/code&gt; 函数发送回）。</target>
        </trans-unit>
        <trans-unit id="a36c7a61f34ba2a33c8e34b5446fa5e93cb80751" translate="yes" xml:space="preserve">
          <source>We match on the top element and embed the inner parts in an HTML body. Then we extract the string values of all motorcycle brands, sort them and removes duplicates by &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt;. We also process the substructure of the top element and pass it to a function that sorts all motorcycle information by brand according to the task formulation in the beginning of this example.</source>
          <target state="translated">我们在顶部元素上进行匹配，并将内部部分嵌入HTML正文中。然后，我们提取所有摩托车品牌的字符串值，对其进行排序，然后通过 &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt; 删除重复项。我们还处理了顶层元素的子结构，并将其传递给一个函数，该函数根据此示例开始时的任务制定按品牌对所有摩托车信息进行排序。</target>
        </trans-unit>
        <trans-unit id="7fc71c9eb936d94faf74a6949f057f8aa6f51f52" translate="yes" xml:space="preserve">
          <source>We need a property to test the function. In normal way, we create &lt;code&gt;property_test/ct_prop.erl&lt;/code&gt; module in the &lt;code&gt;test&lt;/code&gt; directory in our application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc0e2937cea34ba0f1d5aa2eb64c711b2673f69" translate="yes" xml:space="preserve">
          <source>We need to handle backward compatibility and the &lt;code&gt;file&lt;/code&gt; module (which uses the old requests until backward compatibility with pre-R13 nodes is no longer needed). Notice that the I/O server does not work with a simple &lt;code&gt;file:write/2&lt;/code&gt; if these are not added:</source>
          <target state="translated">我们需要处理向后兼容性和 &lt;code&gt;file&lt;/code&gt; 模块（它将使用旧请求，直到不再需要与R13之前的节点向后兼容为止）。请注意，如果未添加这些 &lt;code&gt;file:write/2&lt;/code&gt; ，则I / O服务器不能与简单的file：write / 2一起使用：</target>
        </trans-unit>
        <trans-unit id="4d6ac95529809d2ef950ae107e48095fe8aabd08" translate="yes" xml:space="preserve">
          <source>We need to handle some requests. First the requests for writing characters:</source>
          <target state="translated">我们需要处理一些请求。首先是写字符的请求。</target>
        </trans-unit>
        <trans-unit id="12600f207204a472f087d90744262b5725d45b4e" translate="yes" xml:space="preserve">
          <source>We need to keep track of all the free segments in order to reuse them for new carrier allocations. One initial idea was to use the same mechanism that is used to keep track of free blocks within MBCs (alloc_util and the different strategies). However, that would not be as straight forward as one can think and can also waste quite a lot of memory as it uses prepended block headers. The granularity of the super carrier is one memory page (usually 4kb). We want to allocate and free entire pages and we don't want to waste an entire page just to hold the block header of the following pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb1a4cf95904afc1e359200da010b92404f8edb" translate="yes" xml:space="preserve">
          <source>We now do some initializations of the process structure that cannot be done before we know the process identifier, and have to be done before we publish the structure in the table. This, for example, includes storing the identifier in the process structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07daf03f4db4caf19e38c7f867ab3cb5a53f055" translate="yes" xml:space="preserve">
          <source>We of course periodically need to move the &lt;code&gt;head.unref_end&lt;/code&gt; closer to the end in order to be able to continue deallocating memory blocks. Since all threads inserting new elements in the linked list will enter the list using the last pointer we can use this knowledge. If we call &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; and wait until we have reached that thread progress we know that no managed threads can refer the elements up to the element pointed to by the last pointer at the time when we called &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;. This since, all managed threads must have left the code implementing this at least once, and they always enters into the list via the last pointer. The &lt;code&gt;tail.next&lt;/code&gt; field contains information about next &lt;code&gt;head.unref_end&lt;/code&gt; pointer and thread progress that needs to be reached before we can move &lt;code&gt;head.unref_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65164610102defaf9d5b21fb95ba5620406fc14d" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;-callback&lt;/code&gt; attribute rather than the &lt;code&gt;behaviour_info()&lt;/code&gt; function. The reason is that the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">我们建议使用 &lt;code&gt;-callback&lt;/code&gt; 属性而不是 &lt;code&gt;behaviour_info()&lt;/code&gt; 函数。原因是工具可以使用额外的类型信息来生成文档或查找差异。</target>
        </trans-unit>
        <trans-unit id="3f93e7d7fa1859286f601226a405040346701e5c" translate="yes" xml:space="preserve">
          <source>We recommend v1.1.1d or later. There are prebuilt avaiable binaries, which you can just download and install, available here: URL: &lt;code&gt;&lt;a href=&quot;http://wiki.openssl.org/index.php/Binaries&quot;&gt;http://wiki.openssl.org/index.php/Binaries&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e39f49e759598de101c5da9790a0b4bd059c21" translate="yes" xml:space="preserve">
          <source>We recommend v3.1.3 or later. Unpack into &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346c9aa8780b8aa277233c8030ef3ce8528b2a4f" translate="yes" xml:space="preserve">
          <source>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;_@Foo@&lt;/code&gt;, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</source>
          <target state="translated">我们称这些为&amp;ldquo;自动元变量&amp;rdquo;。如果名称另外以 &lt;code&gt;@&lt;/code&gt; 结尾，例如 &lt;code&gt;_@Foo@&lt;/code&gt; ，则在构造较大的树时，作为Erlang术语的变量值将自动转换为相应的抽象语法树。例如，在：</target>
        </trans-unit>
        <trans-unit id="06786f57e1bc44f393d7c2e9b4b0714fd0164849" translate="yes" xml:space="preserve">
          <source>We run it as usual, for example with ct_run in the OS shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a9f8a4bc23ba990af592e409f5c51b8ea523ef" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;file:write/2&lt;/code&gt; only calls &lt;code&gt;prim_file:write/2&lt;/code&gt;, but let us refrain from digging into the internals of the kernel application.</source>
          <target state="translated">我们看到 &lt;code&gt;file:write/2&lt;/code&gt; 仅调用 &lt;code&gt;prim_file:write/2&lt;/code&gt; ，但让我们避免深入研究内核应用程序的内部。</target>
        </trans-unit>
        <trans-unit id="1ae6a760c341c75f5fb2da4019fa63a21130812e" translate="yes" xml:space="preserve">
          <source>We see that the algorithm set is changed to the one in the &lt;code&gt;ex2.config&lt;/code&gt;. Since &lt;code&gt;compression&lt;/code&gt; is not specified in the file, the hard-coded default is still used for that entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3b22518344463198707dd795380094d0c8925a" translate="yes" xml:space="preserve">
          <source>We see that the new release version is &lt;code&gt;permanent&lt;/code&gt;, so it would be safe to restart the node.</source>
          <target state="translated">我们看到新发行版本是 &lt;code&gt;permanent&lt;/code&gt; 版本，因此可以安全地重新启动节点。</target>
        </trans-unit>
        <trans-unit id="b50565a62199c6c141d92fc8afb4546283ef2fd4" translate="yes" xml:space="preserve">
          <source>We simply pick out an I/O vector from the queue (which is the whole queue as a &lt;code&gt;SysIOVec&lt;/code&gt;). If the I/O vector is too long (&lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; is defined to 16), the vector length is decreased (line 15), otherwise the &lt;code&gt;writev&lt;/code&gt; call (line 17) fails. Writing is tried and anything written is dequeued (line 27). If the write fails with &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (notice that all sockets are in non-blocking mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_output&lt;/code&gt; routine be called when there is space to write again.</source>
          <target state="translated">我们只需从队列（作为 &lt;code&gt;SysIOVec&lt;/code&gt; 的整个队列）中选择一个I / O向量。如果I / O向量太长（ &lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; 定义为16），则向量长度会减小（第15行），否则 &lt;code&gt;writev&lt;/code&gt; 调用（第17行）会失败。尝试编写，将所有写出列（第27行）。如果写入失败， &lt;code&gt;EWOULDBLOCK&lt;/code&gt; （请注意，所有插座都在非阻塞模式）， &lt;code&gt;driver_select&lt;/code&gt; 被称为使 &lt;code&gt;uds_output&lt;/code&gt; 当有空间写一遍程序中调用。</target>
        </trans-unit>
        <trans-unit id="d0ada7dbfa4e9b0738c600e7e0aaa004c64d9416" translate="yes" xml:space="preserve">
          <source>We specify the filter, we want to view calls that resemble &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt;:</source>
          <target state="translated">我们指定过滤器，我们想查看类似于 &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt; 调用：</target>
        </trans-unit>
        <trans-unit id="1235892250491b3de3e5ff2495a68e9d2682e8e0" translate="yes" xml:space="preserve">
          <source>We start a &lt;strong&gt;simple target system&lt;/strong&gt; as above. The only difference is that also the file &lt;code&gt;releases/RELEASES&lt;/code&gt; is present for code replacement in runtime to work.</source>
          <target state="translated">我们如上所述启动一个&lt;strong&gt;简单的目标系统&lt;/strong&gt;。唯一的区别在于，还存在文件 &lt;code&gt;releases/RELEASES&lt;/code&gt; ，以便在运行时替换代码。</target>
        </trans-unit>
        <trans-unit id="c601e5855e0a64b0a4dc2997f72bc0154a5ac01a" translate="yes" xml:space="preserve">
          <source>We start writing the example Unix domain sockets driver by declaring prototypes and filling in a static &lt;code&gt;ErlDrvEntry&lt;/code&gt; structure:</source>
          <target state="translated">我们通过声明原型并填充静态 &lt;code&gt;ErlDrvEntry&lt;/code&gt; 结构开始编写示例Unix域套接字驱动程序：</target>
        </trans-unit>
        <trans-unit id="0ed0ee62a50934d618226ac2077c2ac131a4a88f" translate="yes" xml:space="preserve">
          <source>We still go to single threaded mode when new code is loaded for a module that is traced, or when loading code when there is a default trace pattern set. That is not impossible to fix, but that requires much closer cooperation between tracing BIFs and the loader BIFs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644c408e343363fe6260f95a6a30cda576bd3ce6" translate="yes" xml:space="preserve">
          <source>We store the &lt;code&gt;creation&lt;/code&gt; serial number in the file. The &lt;code&gt;creation&lt;/code&gt; is a number that is to change between different instances of different Erlang emulators with the same name, so that process identifiers from one emulator do not become valid when sent to a new emulator with the same distribution name. The creation can be from 0 through 3 (two bits) and is stored in every process identifier sent to another node.</source>
          <target state="translated">我们将 &lt;code&gt;creation&lt;/code&gt; 序列号存储在文件中。该 &lt;code&gt;creation&lt;/code&gt; 是一个数字，是将不同的Erlang模拟器具有相同名称的不同实例之间变化，所以从一个进程标识符时相同的分布名称发送到一个新的仿真模拟器不生效。创建的范围可以从0到3（两位），并存储在发送到另一个节点的每个进程标识符中。</target>
        </trans-unit>
        <trans-unit id="63a6ffdb62bb132307bcc5f5fe297a041b9ec3d7" translate="yes" xml:space="preserve">
          <source>We strongly encourage the use of the &lt;code&gt;RowStatus&lt;/code&gt; convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used.</source>
          <target state="translated">我们强烈建议对可以从管理器修改的每个表使用 &lt;code&gt;RowStatus&lt;/code&gt; 约定，即使是对于新设计的SNMPv1 MIB也是如此。在SNMPv1中，每个人都发明了自己的用于模拟表操作的方案，这导致了许多不一致之处。SNMPv2中的约定灵活而强大，并且已经成功测试。如果表是只读的，则不应使用RowStatus列。</target>
        </trans-unit>
        <trans-unit id="508ccb34921947b5beb2005777369f595ad7c8a8" translate="yes" xml:space="preserve">
          <source>We study the state that is needed for the ports. Notice that not all fields are used for all types of ports. Some space could be saved by using unions, but that would clutter the code with multiple indirections, so here is used one struct for all types of ports, for readability:</source>
          <target state="translated">我们研究端口所需要的状态。请注意,并不是所有的字段都用于所有类型的 port。使用联合体可以节省一些空间,但这样做会使代码变得杂乱无章,所以这里使用一个结构来处理所有类型的端口,以方便阅读。</target>
        </trans-unit>
        <trans-unit id="0570780114e9fc609087371872169fccbd297f49" translate="yes" xml:space="preserve">
          <source>We suspect the &lt;code&gt;ets:new/2&lt;/code&gt; call, as we match hard on the return value, but want only the particular &lt;code&gt;new/2&lt;/code&gt; call with &lt;code&gt;toy_table&lt;/code&gt; as first parameter. So we start a default tracer on the node:</source>
          <target state="translated">我们怀疑 &lt;code&gt;ets:new/2&lt;/code&gt; 调用，因为我们很难在返回值上进行匹配，但是只希望特定的 &lt;code&gt;new/2&lt;/code&gt; 调用以 &lt;code&gt;toy_table&lt;/code&gt; 作为第一个参数。因此，我们在节点上启动默认跟踪器：</target>
        </trans-unit>
        <trans-unit id="f5bbffab7f95f81cee247421bd092ab29a87848d" translate="yes" xml:space="preserve">
          <source>We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):</source>
          <target state="translated">我们开启所有进程的调用跟踪,我们要做一个很有限制性的跟踪模式,所以没有必要只对几个进程进行调用跟踪(通常情况下是没有的)。</target>
        </trans-unit>
        <trans-unit id="59f43c3a056dd53d064433399740ce5398c03179" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;dbg:tpl/3&lt;/code&gt; to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing.</source>
          <target state="translated">我们使用 &lt;code&gt;dbg:tpl/3&lt;/code&gt; 来确保捕获本地调用（假设自较小版本以来该模块已经扩展，并且我们不确定原子的插入是否不是在本地完成的）。如有疑问，请始终使用本地呼叫跟踪。</target>
        </trans-unit>
        <trans-unit id="3db459c71765166584b222966eebe056c8bcb451" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;port_control/3&lt;/code&gt; function for all calls into the driver. The result from the driver is returned immediately and converted to terms by calling &lt;code&gt;binary_to_term/1&lt;/code&gt;. (We trust that the terms returned from the driver are well-formed, otherwise the &lt;code&gt;binary_to_term&lt;/code&gt; calls could be contained in a &lt;code&gt;catch&lt;/code&gt;.)</source>
          <target state="translated">我们将 &lt;code&gt;port_control/3&lt;/code&gt; 函数用于对驱动程序的所有调用。驱动程序的结果立即返回，并通过调用 &lt;code&gt;binary_to_term/1&lt;/code&gt; 转换为条件。（我们相信从驱动程序返回的术语格式正确，否则 &lt;code&gt;binary_to_term&lt;/code&gt; 调用可以包含在 &lt;code&gt;catch&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="02fb426878fcef94b8e18d9576286ad65ac4ed4a" translate="yes" xml:space="preserve">
          <source>We use the binary format only to return data to the emulator; input data is a string parameter for &lt;code&gt;connect&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;. The returned data consists of Erlang terms.</source>
          <target state="translated">我们仅使用二进制格式将数据返回给仿真器；输入数据是用于 &lt;code&gt;connect&lt;/code&gt; 和 &lt;code&gt;select&lt;/code&gt; 的字符串参数。返回的数据由Erlang项组成。</target>
        </trans-unit>
        <trans-unit id="014d84a4d3abb1236ee92db9f5f0d5547ff6a186" translate="yes" xml:space="preserve">
          <source>We use the function &lt;code&gt;Rep&lt;/code&gt; to denote the mapping from an Erlang source construct &lt;code&gt;C&lt;/code&gt; to its abstract format representation &lt;code&gt;R&lt;/code&gt;, and write &lt;code&gt;R = Rep(C)&lt;/code&gt;.</source>
          <target state="translated">我们使用函数 &lt;code&gt;Rep&lt;/code&gt; 表示从Erlang源构造 &lt;code&gt;C&lt;/code&gt; 到其抽象格式表示 &lt;code&gt;R&lt;/code&gt; 的映射，并写成 &lt;code&gt;R = Rep(C)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b955b8cc53f04946e7906d8bccd83ad77bc547a4" translate="yes" xml:space="preserve">
          <source>We use the same internal form for both the binary and text encoding. Our internal form of Megaco/H.248 messages is heavily influenced by the internal format used by ASN.1 encoders/decoders:</source>
          <target state="translated">我们对二进制和文本编码都使用相同的内部形式。我们的Megaco/H.248信息的内部格式在很大程度上受到ASN.1编码器/解码器使用的内部格式的影响。</target>
        </trans-unit>
        <trans-unit id="09eafdf76bfe34feacf5ab1510c6a7720bed3f57" translate="yes" xml:space="preserve">
          <source>We use the simplest possible &lt;code&gt;sys.config&lt;/code&gt;, which we store in &lt;code&gt;releases/FIRST&lt;/code&gt;:</source>
          <target state="translated">我们使用最简单的 &lt;code&gt;sys.config&lt;/code&gt; ，将其存储在 &lt;code&gt;releases/FIRST&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="b0d8589e4a15b7a5013c9800a611e86facb44e60" translate="yes" xml:space="preserve">
          <source>We very much welcome user feedback - even wishlists! If you notice anything weird, especially if Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them.</source>
          <target state="translated">我们非常欢迎用户的反馈--甚至是愿望清单! 如果你注意到任何奇怪的事情,特别是当Dialyzer报告任何差异是一个假阳性,请发送一个错误报告,描述症状和如何重现它们。</target>
        </trans-unit>
        <trans-unit id="c5f285e2cc8e54c3430820d9c7f8e8768e8a5b79" translate="yes" xml:space="preserve">
          <source>We want a locking mechanism that gives no race conditions, to be sure if another Erlang node uses the listen socket name we require or if the file is only left there from a previous (crashed) session.</source>
          <target state="translated">我们希望有一个不提供任何竞赛条件的锁定机制,以确定是否有另一个Erlang节点使用了我们所需要的监听套接字名,或者文件是否只是在之前的(崩溃的)会话中留在那里。</target>
        </trans-unit>
        <trans-unit id="b3d62af079f72041cf5e740a82dc4dbd33004d95" translate="yes" xml:space="preserve">
          <source>We want to find the reduction of the closure of the function graph to modules. The direct expression for doing that would be &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt;, but then we would have to represent all of the transitive closure of E in memory. Instead the number of indirectly used modules is found for each analyzed module, and the sum over all modules is calculated.</source>
          <target state="translated">我们想要找到减少功能图对模块的闭合性。这样做的直接表达式是 &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt; ，但随后我们必须表示内存中E的所有传递闭包。而是为每个分析的模块找到间接使用的模块数，并计算所有模块的总和。</target>
        </trans-unit>
        <trans-unit id="70463b6b569fc0648d3d04d1de5cd8aeaea41835" translate="yes" xml:space="preserve">
          <source>We will also need to define a specific instruction and an implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e5e22774ee70e0f2042f44b9bc134daa843dc9" translate="yes" xml:space="preserve">
          <source>We will describe a few of the most useful macros here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cec4b25e7ec82e4a29c249c1772265612c2f98" translate="yes" xml:space="preserve">
          <source>We will first go through the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure which people probably are most familiar with.</source>
          <target state="translated">我们将首先经历人们可能最熟悉的 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 构建过程。</target>
        </trans-unit>
        <trans-unit id="0576d6764bbcae3841fb03ef32241effb70e7bed" translate="yes" xml:space="preserve">
          <source>We will go through each line in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92a721ff1fb03d81cf679fa0c2700795b3ef20" translate="yes" xml:space="preserve">
          <source>We will go through the lines that are new or have changed compared to &lt;code&gt;move_cx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1922b9b72d1fce0784918b07377d42edc5816c5e" translate="yes" xml:space="preserve">
          <source>We will look at the code for each specific instruction in turn. To make the code easier to understand, let's first look at the memory layout for the instruction &lt;code&gt;{move,{atom,id},{x,5}}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff38c2602baf56bc8c3440d3937fb894b7ad10" translate="yes" xml:space="preserve">
          <source>We will not be bug-compatible. A bug fix might introduce incompatible changes. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">我们不会与错误兼容。一个错误修复可能会带来不兼容的变化。这种不兼容可能发生在补丁中。</target>
        </trans-unit>
        <trans-unit id="4a8371df807c1d9828677bbee6ed0833eeb9de70" translate="yes" xml:space="preserve">
          <source>We will now check if the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; on a lower level is applied to a &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; on a higher level. We will do that by enabling the &lt;code&gt;ssh-dss&lt;/code&gt; algorithm that is supported, but not in the default set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad9e6cc5dd978296e9f3155b1fac5bd4e904894" translate="yes" xml:space="preserve">
          <source>We will see more details of this later. If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an &lt;strong&gt;Erlang node&lt;/strong&gt;.</source>
          <target state="translated">我们将在稍后看到更多详细信息。如果要尝试使用分布式Erlang，但是只有一台计算机可以工作，则可以在同一台计算机上启动两个单独的Erlang系统，但可以给它们指定不同的名称。在计算机上运行的每个Erlang系统都称为一个&lt;strong&gt;Erlang节点&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="003f9e7ef78da8c0f188a6f92bd1faf2dec2b304" translate="yes" xml:space="preserve">
          <source>We will start looking at the patterns on the left side of the arrow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9436898fb9eadec20c9220ce4b0c6a8fef0ef4" translate="yes" xml:space="preserve">
          <source>We would have to change the order of the operands so that the two operands that are different are placed first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd397370c00ee4d81771bc1a4690627c9a9c47d" translate="yes" xml:space="preserve">
          <source>We would recommend using 1.0.2d.</source>
          <target state="translated">我们建议使用1.0.2d。</target>
        </trans-unit>
        <trans-unit id="843043fadfaea89e297baed2f38224161728a8fc" translate="yes" xml:space="preserve">
          <source>We write it using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;:</source>
          <target state="translated">我们使用 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 编写它：</target>
        </trans-unit>
        <trans-unit id="2d11ec20af5e84fd81824db4ba0a8cd93159b8e2" translate="yes" xml:space="preserve">
          <source>We've tried up to 1.0, but the latest version should do. Make sure you download the &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt;, not a linux version. You unzip the package on top of your MinGW installation (&lt;code&gt;c:\MinGW&lt;/code&gt;) and that's it.</source>
          <target state="translated">我们已经尝试了1.0版本，但是最新版本应该可以。确保您下载的是 &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt; ，而不是Linux版本。您只需在MinGW安装（ &lt;code&gt;c:\MinGW&lt;/code&gt; ）顶部解压缩软件包即可。</target>
        </trans-unit>
        <trans-unit id="b8eef6e94eb7100a713ed2ea56c1d7018de92907" translate="yes" xml:space="preserve">
          <source>We've used this build procedure for a couple of releases, and it has worked fine for us. Still, there might be all sorts of troubles on different machines and with different setups. We'll try to give hints wherever we've encountered difficulties, but please share your experiences by using the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; mailing list. We cannot, of course, help everyone with all their issues, so please try to solve such issues and submit solutions/workarounds.</source>
          <target state="translated">我们已经将此构建过程用于多个发行版，并且对我们来说运行良好。尽管如此，在不同的机器和不同的设置上可能仍然存在各种麻烦。每当遇到困难时，我们都会尝试提供提示，但是请使用 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; 邮件列表来分享您的经验。当然，我们不能为所有人解决所有问题，因此请尝试解决此类问题并提交解决方案/解决方法。</target>
        </trans-unit>
        <trans-unit id="b36b032611690f561af6ed7868e7f249080a2d29" translate="yes" xml:space="preserve">
          <source>Web server users without server administrative privileges that need to manage authentication of web pages that are local to their user can use the per-directory runtime configurable user-authentication scheme &lt;code&gt;htaccess&lt;/code&gt;. It works as follows:</source>
          <target state="translated">没有服务器管理特权的Web服务器用户需要管理对其用户本地网页的身份验证，可以使用按目录运行时可配置的用户身份验证方案 &lt;code&gt;htaccess&lt;/code&gt; 。其工作方式如下：</target>
        </trans-unit>
        <trans-unit id="3ee3b99c66ed2c1f02ee33b7f98ce7fdcb23b424" translate="yes" xml:space="preserve">
          <source>Welcome to Erlang/OTP, a complete development environment for concurrent programming.</source>
          <target state="translated">欢迎来到Erlang/OTP,一个完整的并发编程的开发环境。</target>
        </trans-unit>
        <trans-unit id="c37fc88b34e83873604a95298f56f654eb5124b8" translate="yes" xml:space="preserve">
          <source>What do these different configurations do and when should we use them? Let's start by going through what happens when one Erlang process sends a message to another. The sending process needs to do a couple of things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a06e19576dea4a7c8ca9f09d25418575cf2e86" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt; io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c886918035c78f6182ee187f960d0ece83d0bb" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，可打印字符是由Erlang VM的启动标志 &lt;code&gt;+pc&lt;/code&gt; 决定的；参见 &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4edfb9d438187e25e8117b3d96348c8b942d6ff3" translate="yes" xml:space="preserve">
          <source>What is captured in this example is the part of the work the shell does while interpreting the command line that occurs between the actual calls to &lt;code&gt;cprof:start()&lt;/code&gt; and &lt;code&gt;cprof:analyse()&lt;/code&gt;.</source>
          <target state="translated">在此示例中捕获的内容是Shell在解释实际对 &lt;code&gt;cprof:start()&lt;/code&gt; 和 &lt;code&gt;cprof:analyse()&lt;/code&gt; 调用之间发生的命令行时所做的工作。</target>
        </trans-unit>
        <trans-unit id="46a5d2a876a396d12b70584eeaf74dfeaa79d06c" translate="yes" xml:space="preserve">
          <source>What is the difference between them, if any? They provide an overlapping definition for resource identifiers and they are not compatible. The &lt;code&gt;uri_string&lt;/code&gt; module implements &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; and the term URI will be used throughout this document. A URI is an identifier, a string of characters that identifies a particular resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8308f9197a4bcfd38df815152af92e5bca4b765b" translate="yes" xml:space="preserve">
          <source>What makes the &lt;code&gt;Mnesia&lt;/code&gt; data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</source>
          <target state="translated">使 &lt;code&gt;Mnesia&lt;/code&gt; 数据模型成为扩展的关系模型的原因是能够在属性字段中存储任意Erlang术语。一个属性值可以例如是一整个OID树，从而导致其他表中的其他术语。这种类型的记录很难在传统的关系DBMS中建模。</target>
        </trans-unit>
        <trans-unit id="ed11d038ec16d30b3bea2a7475ee3a6b9b40a0e1" translate="yes" xml:space="preserve">
          <source>What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e54b84bf8a59386ffce97008e70cfe702e204e" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt; ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405eee64426a95cf4618da03e92872e8805137ae" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="translated">你还能做什么？一个简单的答案是：请参阅《ERTS用户指南》中的 &lt;code&gt;match specifications&lt;/code&gt; 文档。但是，以下是对最有用的&amp;ldquo;内置函数&amp;rdquo;的简要概述，当 &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; 将乐趣转换为匹配规范时，可以使用这些函数。除了匹配规范中允许的功能外，无法调用其他功能。 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 所翻译的乐趣无法执行&amp;ldquo;通常的&amp;rdquo; Erlang代码。不幸的是，这种乐趣完全限于匹配规范的功能，但是与 &lt;code&gt;ets:foldl/foldr&lt;/code&gt; 相比，必须为 &lt;code&gt;ets:select/2&lt;/code&gt; 的执行速度付出代价。</target>
        </trans-unit>
        <trans-unit id="5f64087ee8c6f485b57fb883b43af5c4cc87d95a" translate="yes" xml:space="preserve">
          <source>What options are valid depend both on &lt;code&gt;Level&lt;/code&gt; and on what kind of socket it is (&lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;protocol&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a27731ebf65f31807af372a7113b45b9d6de2d" translate="yes" xml:space="preserve">
          <source>What properties are valid depend both on &lt;code&gt;Level&lt;/code&gt; and on what kind of socket it is (&lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;protocol&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9abe5ff356944e50659de71982880b18848dd6" translate="yes" xml:space="preserve">
          <source>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</source>
          <target state="translated">物理内存的保留意味着什么,很大程度上取决于操作系统,以及它是如何配置的。例如,在Linux上,不同的内存超占设置会极大地改变行为。</target>
        </trans-unit>
        <trans-unit id="587af77c14f789357e51980e72003df91f480665" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;qlc&lt;/code&gt; module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Usually &lt;code&gt;qlc:table/2&lt;/code&gt; is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: &lt;code&gt;mnesia:table/1,2&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt;. For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describes the implementation of a function calling &lt;code&gt;qlc:table/2&lt;/code&gt;.</source>
          <target state="translated">什么是 &lt;code&gt;qlc&lt;/code&gt; 模块主要是增加了列表理解的是，数据可以从QLC表中的小块读取。通过调用 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; 创建QLC表。通常，不会直接从查询中调用 &lt;code&gt;qlc:table/2&lt;/code&gt; ，而是通过某些数据结构的接口函数来调用。 Erlang / OTP包括一些此类功能的示例： &lt;code&gt;mnesia:table/1,2&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt; 。对于给定的数据结构，许多函数可以创建QLC表，但是这些函数的共同点是它们返回由 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; 创建的查询句柄。通常，使用Erlang / OTP提供的QLC表可能就足够了，但对于更高级的用户部分 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 描述了调用 &lt;code&gt;qlc:table/2&lt;/code&gt; 的函数的实现。</target>
        </trans-unit>
        <trans-unit id="e307252350d5f0ef992b3ab620b890f8bd198517" translate="yes" xml:space="preserve">
          <source>What the I/O server sends when there is no data.</source>
          <target state="translated">当没有数据时,I/O服务器发送什么。</target>
        </trans-unit>
        <trans-unit id="1804d21d5ef8f5b8cb1f89c4e94fe07aef9672aa" translate="yes" xml:space="preserve">
          <source>What this means, if anything, is implementation dependent.</source>
          <target state="translated">这意味着什么,如果有的话,取决于实施。</target>
        </trans-unit>
        <trans-unit id="7351aa821dda7989c82c251abb71293dcac3c00b" translate="yes" xml:space="preserve">
          <source>What to log and how</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86e62a665b180d594c01dd61c21371b36d33af5" translate="yes" xml:space="preserve">
          <source>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</source>
          <target state="translated">在这种情况下,你要做的是把你的元变量写在一个语法上有效的位置,并使用提升标记来表示它真正应该适用的地方,如:。</target>
        </trans-unit>
        <trans-unit id="c5c621a34cc77c693f796b9c9a4e0202b514808a" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="translated">测试套件中 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 添加的内容。</target>
        </trans-unit>
        <trans-unit id="24d7dba872f239c3722291e671d97f08fe9ef4ae" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e65ac25edcc6a715cbfb229eba192595c676d46" translate="yes" xml:space="preserve">
          <source>When (*SKIP) has an associated name, its behavior is modified:</source>
          <target state="translated">当(*SKIP)有关联名称时,它的行为就会被修改。</target>
        </trans-unit>
        <trans-unit id="04fe958830198355cc811da35c494d7c1c3c2d18" translate="yes" xml:space="preserve">
          <source>When (finally?) everything is in order with the locale settings, fonts. and the terminal emulator, you have probably found a way to input characters in the script you desire. For testing, the simplest way is to add some keyboard mappings for other languages, usually done with some applet in your desktop environment.</source>
          <target state="translated">当(最后?)一切都按部就班地进行本地化设置、字体和终端仿真器时,你可能已经找到了在你想要的脚本中输入字符的方法。对于测试来说,最简单的方法是为其他语言添加一些键盘映射,通常是通过桌面环境中的一些小程序来完成。</target>
        </trans-unit>
        <trans-unit id="de541ea3fda63c5a944619402b0a682059a1f89d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-0&quot;&gt; logger:get_handler_config/0,1&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:filter_config(Config)&lt;/code&gt;. This function must return the handler configuration where internal data is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0d566142bbb33f59317bb4f642875e3ad38999" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt; logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt; logger:update_handler_config/2,3&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(SetOrUpdate, OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c61293396a0994c6191d7911346e57c38611cf9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; 被调用时，记录器调用 &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt; 。如果此函数返回 &lt;code&gt;{ok,NewConfig1}&lt;/code&gt; ，则Logger会将 &lt;code&gt;NewConfig1&lt;/code&gt; 写入配置数据库。</target>
        </trans-unit>
        <trans-unit id="93e75014a8819db24d123ffe574cf1058af1d7b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Addr&lt;/code&gt; does not contain a port number, the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;Addr&lt;/code&gt; 不包含端口号，则使用 &lt;code&gt;port&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="af3df4cc98d21f4d7157a7f5c03ed4afe7255c29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:cancel_timer()&lt;/code&gt;. otherwise &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;Async&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ：如果 &lt;code&gt;Info&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; 返回 &lt;code&gt;Result&lt;/code&gt; 。否则返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3c3055751c190947148414125cb3febf1e8f6f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a message on the form &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; when the cancellation operation has been performed, otherwise no message is sent.</source>
          <target state="translated">当 &lt;code&gt;Async&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时：如果 &lt;code&gt;Info&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则在执行取消操作后，将格式为 &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; 的消息发送给 &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; 的调用方，否则不发送任何消息。</target>
        </trans-unit>
        <trans-unit id="166a240b6e5cc60a7634b1583a60930de57018f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Common Test&lt;/code&gt; starts, it automatically attempts to compile any suites included in the specified tests. If particular suites are specified, only those suites are compiled. If a particular test object directory is specified (meaning all suites in this directory are to be part of the test), &lt;code&gt;Common Test&lt;/code&gt; runs function &lt;code&gt;make:all/1&lt;/code&gt; in the directory to compile the suites.</source>
          <target state="translated">当 &lt;code&gt;Common Test&lt;/code&gt; 启动时，它会自动尝试编译包括在指定任何测试套件。如果指定了特定套件，则仅编译那些套件。如果指定了特定的测试对象目录（意味着该目录中的所有套件都将成为测试的一部分），则 &lt;code&gt;Common Test&lt;/code&gt; 在目录中运行函数 &lt;code&gt;make:all/1&lt;/code&gt; 来编译套件。</target>
        </trans-unit>
        <trans-unit id="8573ae20e451ce0821967cc87eca07cfcbab6866" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt; mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42507199eef19752873563b14392dfa940c65fc9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">当 &lt;code&gt;Mnesia&lt;/code&gt; 加载许多表时，将使用默认的加载顺序。但是，可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt; 显式更改表的属性 &lt;code&gt;load_order&lt;/code&gt; 来影响加载顺序。默认情况下，所有表的 &lt;code&gt;LoadOrder&lt;/code&gt; 均为 &lt;code&gt;0&lt;/code&gt; ，但可以将其设置为任何整数。首先加载 &lt;code&gt;load_order&lt;/code&gt; 最高的表。更改加载顺序对于需要确保基本表的早期可用性的应用程序特别有用。大型外围设备表应具有较低的加载顺序值，可能小于 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69de3dae19f69610dd34e83bd997df060a7428e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Arguments&lt;/code&gt; are provided, we apply it and do the same with the result as if the data was provided directly.</source>
          <target state="translated">当提供 &lt;code&gt;Module&lt;/code&gt; ， &lt;code&gt;Function&lt;/code&gt; 和 &lt;code&gt;Arguments&lt;/code&gt; 时，我们将其应用并且对结果进行相同的处理，就好像直接提供了数据一样。</target>
        </trans-unit>
        <trans-unit id="c52ee13a4dcb299f5a385cfe15fc42403a860bc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; calls a traced function. The return values of calls are never supplied, only the call and its arguments.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 调用跟踪的函数时。永远不会提供调用的返回值，仅提供调用及其参数。</target>
        </trans-unit>
        <trans-unit id="323d59db6fafd89e5c07401fb7993540b99d690e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits &lt;strong&gt;from&lt;/strong&gt; the specified function because of an exception. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with an &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 由于异常而&lt;strong&gt;从&lt;/strong&gt;指定函数退出时。如果设置了标志 &lt;code&gt;call&lt;/code&gt; ，则发送此跟踪消息，并且该函数具有带有 &lt;code&gt;exception_trace&lt;/code&gt; 操作的匹配规范。</target>
        </trans-unit>
        <trans-unit id="dc3d1426688af7f3815ab8ffb8557afa8cf69def" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits with reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 由于 &lt;code&gt;Reason&lt;/code&gt; 退出时。</target>
        </trans-unit>
        <trans-unit id="6a10c0e2595bc6a45b793e623dbb1d7e74c4840d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">何时安排 &lt;code&gt;Pid&lt;/code&gt; 。该进程正在功能{M，F，Arity}中运行。在极少数情况下，无法确定当前函数，则最后一个元素为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="885b32e12e9f0ba67537b4a0349bf3e528dd7008" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled to run. The process runs in function &lt;code&gt;{M, F, Arity}&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">计划何时运行 &lt;code&gt;Pid&lt;/code&gt; 。该过程在函数 &lt;code&gt;{M, F, Arity}&lt;/code&gt; 。在极少数情况下，无法确定当前函数，则最后一个元素为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2579456f2ac4547aa51c7500a5011980e64fed27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is spawned by process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">当进程 &lt;code&gt;Pid2&lt;/code&gt; 以指定的函数调用作为入口生成 &lt;code&gt;Pid&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="ee6d840360c675d28fb4189ea75bcf500ea96744" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; links to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 链接到进程 &lt;code&gt;Pid2&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="4f0d2e5fb513b27fbae59d57a8659f003a4ecf83" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; opens a new port &lt;code&gt;Port&lt;/code&gt; with the running &lt;code&gt;Driver&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 使用正在运行的 &lt;code&gt;Driver&lt;/code&gt; 打开新端口 &lt;code&gt;Port&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="14ed889ebc9aca15515c2b45ca1a374fd67cf415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; removes the link from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 从进程 &lt;code&gt;Pid2&lt;/code&gt; 中删除链接时。</target>
        </trans-unit>
        <trans-unit id="5751eed2112a0c8b568fa52ffcbeb3e9cb0f2b8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;from&lt;/strong&gt; the specified function. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with a &lt;code&gt;return_trace&lt;/code&gt; or &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; &lt;strong&gt;从&lt;/strong&gt;指定函数返回时。如果设置了标志 &lt;code&gt;call&lt;/code&gt; ，则发送此跟踪消息，并且该函数具有带有 &lt;code&gt;return_trace&lt;/code&gt; 或 &lt;code&gt;exception_trace&lt;/code&gt; 操作的匹配规范。</target>
        </trans-unit>
        <trans-unit id="fcbfdb05819ccf5c6584d296609a8e52d12c64f1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;to&lt;/strong&gt; the specified function. This trace message is sent if both the flags &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; are set, and the function is set to be traced on &lt;strong&gt;local&lt;/strong&gt; function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a &lt;code&gt;call&lt;/code&gt; trace message (that is, the functions match specification matched, and &lt;code&gt;{message, false}&lt;/code&gt; was not an action).</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 返回&lt;strong&gt;到&lt;/strong&gt;指定函数时。如果同时设置了标志 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;return_to&lt;/code&gt; ，并且将函数设置为在&lt;strong&gt;本地&lt;/strong&gt;函数调用上进行跟踪，则发送此跟踪消息。仅当从一串尾部递归函数调用返回时才发送该消息，其中至少一个调用生成了一个 &lt;code&gt;call&lt;/code&gt; 跟踪消息（即，这些函数匹配匹配的规范，并且 &lt;code&gt;{message, false}&lt;/code&gt; 不是动作）。</target>
        </trans-unit>
        <trans-unit id="ba46a646e37ed8b7d35c674ed3b3e32924ba03e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; spawns a new process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">当 &lt;code&gt;Pid&lt;/code&gt; 产生带有指定函数调用作为入口点的新进程 &lt;code&gt;Pid2&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="5cc371b2356f9951c5abbb937169272313d56c71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets linked to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 链接到进程 &lt;code&gt;Pid2&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="972a925137e0ccb08bc5aeffdfecb3782e3bc889" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; registered.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 获得名称 &lt;code&gt;RegName&lt;/code&gt; 时注册。</target>
        </trans-unit>
        <trans-unit id="162e33555c86a661514ef9d4a857ec534b5a22a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; unregistered. This is done automatically when a registered process or port exits.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 获得名称 &lt;code&gt;RegName&lt;/code&gt; 时未注册。当注册的进程或端口退出时，将自动完成此操作。</target>
        </trans-unit>
        <trans-unit id="feb1d708bf63c2940ea863c472a540929d8d0a03" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets unlinked from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 与进程 &lt;code&gt;Pid2&lt;/code&gt; 断开链接时。</target>
        </trans-unit>
        <trans-unit id="96a6470e961b2d5912dd59eb5021ef79f690f562" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; receives message &lt;code&gt;Msg&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is set to time-out, a receive statement can have timed out, or the process received a message with the payload &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 收到消息 &lt;code&gt;Msg&lt;/code&gt; 时。如果 &lt;code&gt;Msg&lt;/code&gt; 设置为超时，则接收语句可能已超时，或者进程接收到带有有效负载 &lt;code&gt;timeout&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="e87cde17521c68e2a936fe17936bf5ceeb2c3d14" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 发送消息 &lt;code&gt;Msg&lt;/code&gt; 来处理 &lt;code&gt;To&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="d61e6201a42785b41b69c2b7a25abb9b7fd4f07c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to the non-existing process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;PidPort&lt;/code&gt; 发送消息 &lt;code&gt;Msg&lt;/code&gt; 到不存在的进程 &lt;code&gt;To&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="15233790daaa8247a54c54b5c9b5074f4bf171a9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; closes with &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Port&lt;/code&gt; 关闭与 &lt;code&gt;Reason&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80787715e672faf25567796cfbe4be1ecff2d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled out. The last command run was &lt;code&gt;Command&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;Command&lt;/code&gt; can contain the same commands as &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">当 &lt;code&gt;Port&lt;/code&gt; 被调度。最后一个命令运行是 &lt;code&gt;Command&lt;/code&gt; 。在极少数情况下，无法确定当前函数，则最后一个元素为 &lt;code&gt;0&lt;/code&gt; 。 &lt;code&gt;Command&lt;/code&gt; 包含相同的命令， &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9ef0bd2183c0bb797164fa66a45ee2bd8c3d2cf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled to run. &lt;code&gt;Command&lt;/code&gt; is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;Port&lt;/code&gt; 计划运行。 &lt;code&gt;Command&lt;/code&gt; 是端口要执行的第一件事，但是它可以在调度之前运行多个命令。在极少数情况下，无法确定当前函数，则最后一个元素为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="763a821ae322d45ebff08f1076aa08fd98dc4152" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;accept&lt;/code&gt; is issued, the values of the listening socket options are inherited. No such application variable is therefore needed for &lt;code&gt;accept&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;accept&lt;/code&gt; 发出的监听套接字选项的值继承。因此，不需要这样的应用程序变量来 &lt;code&gt;accept&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a84fa4a21d8059b923917b5063cf77ca5a084f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/2,3&lt;/code&gt; is used with wrap logs, the returned continuation might not be valid in the next call to &lt;code&gt;chunk()&lt;/code&gt;. This is because the log can wrap and delete the file into which the continuation points. To prevent this, the log can be blocked during the search.</source>
          <target state="translated">当 &lt;code&gt;chunk/2,3&lt;/code&gt; 与包装日志一起使用时，返回的延续可能在下一次对 &lt;code&gt;chunk()&lt;/code&gt; 的调用中无效。这是因为日志可以包装和删除继续指向的文件。为了防止这种情况，可以在搜索过程中阻止日志。</target>
        </trans-unit>
        <trans-unit id="b575a5e86459930acb9d9587352f01c78bb4d138" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 64 kilobyte chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that the end of the file is reached.</source>
          <target state="translated">当 &lt;code&gt;chunk/3&lt;/code&gt; 被调用时， &lt;code&gt;N&lt;/code&gt; 控制了从日志中的每个组块读术语的最大数目。默认为 &lt;code&gt;infinity&lt;/code&gt; ，这意味着将读取64 KB块中包含的所有术语。如果返回少于 &lt;code&gt;N&lt;/code&gt; 个字词，则不一定表示已到达文件末尾。</target>
        </trans-unit>
        <trans-unit id="ea8aa73939a31b631da4d86b608b56e6f570baca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 8K chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that end of file is reached.</source>
          <target state="translated">当 &lt;code&gt;chunk/3&lt;/code&gt; 被调用时， &lt;code&gt;N&lt;/code&gt; 控制了从日志中的每个组块读术语的最大数目。默认为 &lt;code&gt;infinity&lt;/code&gt; ，这意味着将读取8K块中包含的所有术语。如果返回少于 &lt;code&gt;N&lt;/code&gt; 个术语，则不一定意味着已到达文件末尾。</target>
        </trans-unit>
        <trans-unit id="e99ff5779b67a6b782f749fc2ebb582cf983dde5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</source>
          <target state="translated">当 &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; 被调用，异步信号被发送到所有调度网络，使他们试图绑定或解除绑定的要求。</target>
        </trans-unit>
        <trans-unit id="0f7f20feb6d8e86e2be7182c1146591f5b2c10e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;float/1&lt;/code&gt; is used in an expression in a guard, such as '&lt;code&gt;float(A) == 4.0&lt;/code&gt;', it converts a number as described earlier.</source>
          <target state="translated">当在防护的表达式中使用 &lt;code&gt;float/1&lt;/code&gt; 时，例如' &lt;code&gt;float(A) == 4.0&lt;/code&gt; '，它将如前所述转换数字。</target>
        </trans-unit>
        <trans-unit id="71613609aa61c62cf20cbe58dfba008b2ab16c3a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;format_temps&lt;/code&gt; is called the first time, &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; and &lt;code&gt;Rest&lt;/code&gt; is the rest of the list. So the function &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; is called.</source>
          <target state="translated">当 &lt;code&gt;format_temps&lt;/code&gt; 被称为第一时间， &lt;code&gt;City&lt;/code&gt; 得到值 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 和 &lt;code&gt;Rest&lt;/code&gt; 是列表的其余部分。因此调用了函数 &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea5dd9189f31e33453342ece25ebb3fb4b7a42c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;gen_statem&lt;/code&gt; receives a process message it is converted into an event and the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is called with the event as two arguments: type and content. When the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; has processed the event it returns to &lt;code&gt;gen_statem&lt;/code&gt; which does a &lt;strong&gt;state transition&lt;/strong&gt;. If this &lt;strong&gt;state transition&lt;/strong&gt; is to a different state, that is: &lt;code&gt;NextState =/= State&lt;/code&gt;, it is a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb83110e8f27a779d6f37f6cb1a70e2e21776a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;handle_connect/2,3&lt;/code&gt; is triggered by an explicit call to &lt;code&gt;megaco:connect/4,5&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;handle_connect/2,3&lt;/code&gt; 是通过显式调用触发 &lt;code&gt;megaco:connect/4,5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="672bdd7739faf4a0068adc26b9d59100e10bc739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;httpd&lt;/code&gt; is shut down, it tries to execute &lt;code&gt;remove/1&lt;/code&gt; in each Erlang web server callback module. The programmer can use this function to clean up resources created in the store function.</source>
          <target state="translated">关闭 &lt;code&gt;httpd&lt;/code&gt; 时，它将尝试在每个Erlang Web服务器回调模块中执行 &lt;code&gt;remove/1&lt;/code&gt; 。程序员可以使用此功能来清理在存储功能中创建的资源。</target>
        </trans-unit>
        <trans-unit id="953b87367aa11437e3573afbb763a3b56ad3bf87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logger_std_h&lt;/code&gt; logs to a file, it reads the file information of the log file prior to each write operation. This is to make sure the file still exists and has the same inode as when it was opened. This implies some performance loss, but ensures that no log events are lost in the case when the file has been removed or renamed by an external actor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c8eb52d34fbd9a9b37c654c599a9d1639ad3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;make install&lt;/code&gt; has finished, change directory into &lt;code&gt;$DESTDIR&lt;/code&gt;, package the system, move it to the target machine, and unpack it. Note that the installation will only be working on the target machine at the location determined by &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;make install&lt;/code&gt; 完成后，将目录更改为 &lt;code&gt;$DESTDIR&lt;/code&gt; ，打包系统，将其移动到目标计算机，然后解压缩。请注意，安装只能在目标计算机上由 &lt;code&gt;configure&lt;/code&gt; 确定的位置进行。</target>
        </trans-unit>
        <trans-unit id="795f2365565d6c490bd1604318e59071672d2fc1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;save&lt;/code&gt; is specified a new connection will be negotiated and saved for later reuse. The session ID can be fetched with &lt;code&gt;&lt;a href=&quot;#connection_information-2&quot;&gt;connection_information/2&lt;/a&gt;&lt;/code&gt; and used with the client option &lt;code&gt;&lt;a href=&quot;#type-client_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt; The boolean value true specifies that if possible, automatized session reuse will be performed. If a new session is created, and is unique in regard to previous stored sessions, it will be saved for possible later reuse. Since OTP-21.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6458c29bc8527ea3593b744f1b95db5d14bc00a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;schema_location&lt;/code&gt; is set to &lt;code&gt;opt_disc&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; can be used to change the storage type of the schema. This is illustrated as follows:</source>
          <target state="translated">当 &lt;code&gt;schema_location&lt;/code&gt; 设置为 &lt;code&gt;opt_disc&lt;/code&gt; 时，函数 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; 可用于更改架构的存储类型。如下所示：</target>
        </trans-unit>
        <trans-unit id="8f7039593357562dd4f3df83c986379cb1c6cf4e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sys:get_status/1,2&lt;/code&gt; is called, &lt;code&gt;gen_event&lt;/code&gt; ensures that its return value contains &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">当 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 叫， &lt;code&gt;gen_event&lt;/code&gt; 确保其返回值包含 &lt;code&gt;Status&lt;/code&gt; 到位的事件处理程序的状态的术语。</target>
        </trans-unit>
        <trans-unit id="5455489a72db154806b1402161102765e042f513" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_ack_maxcount&lt;/code&gt; number of ack's has been received.</source>
          <target state="translated">当 &lt;code&gt;trans_ack_maxcount&lt;/code&gt; 已收到ack的数量时。</target>
        </trans-unit>
        <trans-unit id="2d6f023a935d787f78f929b26ccb79c057c7e544" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_req_maxcount&lt;/code&gt; number of requests's has been received.</source>
          <target state="translated">当已收到 &lt;code&gt;trans_req_maxcount&lt;/code&gt; 个请求时。</target>
        </trans-unit>
        <trans-unit id="4691b74e02fcb2a43c31be2ce08725b89f8c00a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_timer&lt;/code&gt; expires.</source>
          <target state="translated">当 &lt;code&gt;trans_timer&lt;/code&gt; 到期时。</target>
        </trans-unit>
        <trans-unit id="9f62e8b515ecdd9f175ebeef24a151629f33f401" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, exit signals arriving to a process are converted to &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; messages, which can be received as ordinary messages. If &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the process exits if it receives an exit signal other than &lt;code&gt;normal&lt;/code&gt; and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</source>
          <target state="translated">当 &lt;code&gt;trap_exit&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，到达进程的退出信号将转换为 &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; 消息，可以将其作为普通消息接收。如果 &lt;code&gt;trap_exit&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，则如果它接收到非 &lt;code&gt;normal&lt;/code&gt; 的退出信号，则该过程退出，并且该退出信号被传播到其链接的进程。申请流程通常不诱捕出口。</target>
        </trans-unit>
        <trans-unit id="fb45a25cdcc4004483ae5e0296eb6055f647d85a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, sent multicast packets are looped back to the local sockets.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则发送的多播数据包将循环回到本地套接字。</target>
        </trans-unit>
        <trans-unit id="10db437ea36ac965fd403789d69242cf01a29208" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;{active, true}&lt;/code&gt;, data is delivered on the form &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; or &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;{active, true}&lt;/code&gt; ，数据在以下 &lt;code&gt;port&lt;/code&gt; 上传递： &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; 或 &lt;code&gt;term&lt;/code&gt; ： &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50818e5b2ee1eb06b98eca2c46320af1c49650c8" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;ActualReason&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">当&lt;strong&gt;Reason&lt;/strong&gt;为&lt;strong&gt;{send_failed，...}时&lt;/strong&gt;，表示net_if进程无法发送消息。由于多种原因（例如编码错误），可能会发生这种情况。在这种情况下，&lt;strong&gt;ActualReason&lt;/strong&gt;是实际原因。</target>
        </trans-unit>
        <trans-unit id="9f41f432bb6d6b04eaeac809774055cb313c3684" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;R&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">当&lt;strong&gt;Reason&lt;/strong&gt;为&lt;strong&gt;{send_failed，...}时&lt;/strong&gt;，表示net_if进程无法发送消息。由于多种原因（例如编码错误），可能会发生这种情况。在这种情况下，&lt;strong&gt;R&lt;/strong&gt;是实际原因。</target>
        </trans-unit>
        <trans-unit id="9d855525f98d05d9b1e2a2b3d4a3caa31ede7338" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;scan stop&lt;/strong&gt; marker &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1103&quot;&gt;catches up&lt;/a&gt;&lt;/code&gt; to the &lt;strong&gt;scan start&lt;/strong&gt; marker, the garbage collection is done. At this point we can &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1206&quot;&gt;deallocate&lt;/a&gt;&lt;/code&gt; the entire &lt;strong&gt;from space&lt;/strong&gt; and therefore reclaim the entire young heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aec189a88e9a30ca27fcd657c83b4b7d31fa73" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;var_and_val()&lt;/strong&gt; is &lt;strong&gt;{oid(), value()}&lt;/strong&gt;, the manager makes an educated guess based on the loaded mibs.</source>
          <target state="translated">当&lt;strong&gt;var_and_val（）&lt;/strong&gt;为&lt;strong&gt;{oid（），value（）}时&lt;/strong&gt;，管理器将基于加载的mib进行有根据的猜测。</target>
        </trans-unit>
        <trans-unit id="ccaef80e646aaabd78d92b0630d31df5f39a479a" translate="yes" xml:space="preserve">
          <source>When Cover is stopped, all Cover compiled modules are unloaded.</source>
          <target state="translated">当Cover停止时,所有Cover编译的模块都会被卸载。</target>
        </trans-unit>
        <trans-unit id="ce23e1563e5351f589159eb5b770cd3cbd2e8d8c" translate="yes" xml:space="preserve">
          <source>When Debugger is started in global mode (which is the default, see &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt;), modules added (or deleted) for interpretation are added (or deleted) on all known Erlang nodes.</source>
          <target state="translated">当以全局模式启动Debugger时（这是默认设置，请参见 &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt; ），将在所有已知的Erlang节点上添加（或删除）用于解释的模块。</target>
        </trans-unit>
        <trans-unit id="ab8c9662238adfc3364171ed2abae67b6db526e0" translate="yes" xml:space="preserve">
          <source>When EDNS is enabled (resolver option &lt;code&gt;edns&lt;/code&gt; is set to the EDNS version (that is, &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;false&lt;/code&gt;), resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; sets the limit. If a name server replies with the TC bit set (truncation), indicating that the answer is incomplete, the query is retried to that name server using TCP. Resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; also sets the advertised size for the maximum allowed reply size, if EDNS is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets truncated, forcing a TCP requery.</source>
          <target state="translated">启用EDNS时（解析程序选项 &lt;code&gt;edns&lt;/code&gt; 设置为EDNS版本（即 &lt;code&gt;0&lt;/code&gt; 而不是 &lt;code&gt;false&lt;/code&gt; ），解析程序选项 &lt;code&gt;udp_payload_size&lt;/code&gt; 设置限制。如果名称服务器以TC位设置（截断）答复，则表明答案是如果不完整，查询将使用TCP重试到该名称服务器。解析器选项 &lt;code&gt;udp_payload_size&lt;/code&gt; 还将为允许的最大答复大小设置广告大小，如果启用了EDNS，则名称服务器使用限制512字节。被截断，强制进行TCP重新查询。</target>
        </trans-unit>
        <trans-unit id="360f7568d87827777af3aa56a826957938118e43" translate="yes" xml:space="preserve">
          <source>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</source>
          <target state="translated">当EUnit为了运行测试而遍历测试表示时,新的生成器将不会被调用以产生下一个测试,直到前一个测试被执行。</target>
        </trans-unit>
        <trans-unit id="f08e2448799430bb11532279edecae41a087b4a7" translate="yes" xml:space="preserve">
          <source>When Erlang is started with &lt;code&gt;-oldshell&lt;/code&gt; or &lt;code&gt;-noshell&lt;/code&gt;, the I/O server for &lt;code&gt;standard_io&lt;/code&gt; is by default set to bytewise encoding, while an interactive shell defaults to what the environment variables says.</source>
          <target state="translated">当用 &lt;code&gt;-oldshell&lt;/code&gt; 或 &lt;code&gt;-noshell&lt;/code&gt; 启动Erlang时，默认情况下将 &lt;code&gt;standard_io&lt;/code&gt; 的I / O服务器设置为按字节编码，而交互式shell则默认使用环境变量所说明的内容。</target>
        </trans-unit>
        <trans-unit id="e501fa18494f297571df6ce7eaf406fc86c93dea" translate="yes" xml:space="preserve">
          <source>When Erlang starts up it reads the Kernel variable &lt;code&gt;inetrc&lt;/code&gt;, which, if defined, is to specify the location and name of a user configuration file. Example:</source>
          <target state="translated">当Erlang启动时，它将读取内核变量 &lt;code&gt;inetrc&lt;/code&gt; ，如果定义了该变量，则它将指定用户配置文件的位置和名称。例：</target>
        </trans-unit>
        <trans-unit id="128caf28b58716150fb0bb58c207dbe8dd83fd4e" translate="yes" xml:space="preserve">
          <source>When Erlang was designed, it was assumed that the wall clock time in the system showed a monotonic time moving forward at exactly the same pace as the definition of time. This more or less meant that an atomic clock (or better time source) was expected to be attached to your hardware and that the hardware was then expected to be locked away from any human tinkering forever. While this can be a compelling thought, it is simply never the case.</source>
          <target state="translated">当设计Erlang时,人们假设系统中的挂钟时间显示出一个单调的时间,以与时间定义完全相同的速度向前移动。这或多或少意味着一个原子钟(或更好的时间源)被期望连接到你的硬件上,然后硬件被期望永远锁定在任何人类修饰的地方。虽然这可能是一个令人信服的想法,但这根本不是事实。</target>
        </trans-unit>
        <trans-unit id="50fa1c320969db01352828d7fe383abc4a1895e0" translate="yes" xml:space="preserve">
          <source>When Erlang/OTP is started, the system searches for a file named &lt;code&gt;.erlang&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">启动Erlang / OTP时，系统在用户的主目录中搜索名为 &lt;code&gt;.erlang&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="f3f71d6c7e7a2c0c5ada3244d6eb663b401f9b01" translate="yes" xml:space="preserve">
          <source>When PER is used, there is a significant difference in the encoding scheme between &lt;code&gt;OCTET STRING&lt;/code&gt;s and other strings. The constraints specified for a type are especially important for PER, where they affect the encoding.</source>
          <target state="translated">使用PER时， &lt;code&gt;OCTET STRING&lt;/code&gt; 和其他字符串之间的编码方案存在很大差异。为类型指定的约束对于PER尤其重要，因为它们会影响编码。</target>
        </trans-unit>
        <trans-unit id="13cc1571f4013c1520479bbd9847106a62e42744" translate="yes" xml:space="preserve">
          <source>When SSH tries to log in to a host, the ssh protocol communicates the user name (as a string) and a password. The remote ssh server checks that there is such a user defined and that the provided password is acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b03f5d92803d36900a526928289b233412ad464" translate="yes" xml:space="preserve">
          <source>When SSL/TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="translated">当SSL / TLS根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; 执行证书路径验证时，它还应该执行CRL验证检查。要启用CRL检查，应用程序需要访问CRL。可以通过许多不同的方式来建立CRL数据库。该模块提供了将任意CRL缓存与erlang ssl应用程序集成所需的API的行为。应用程序本身也使用它来提供CRL缓存的简单默认实现。</target>
        </trans-unit>
        <trans-unit id="08b49640b8a294ef0b72bc78a8a9c77ce925f456" translate="yes" xml:space="preserve">
          <source>When TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c5c5eb2f1ebd77389873e38508774785cdb365" translate="yes" xml:space="preserve">
          <source>When a (complex) term is deleted (using &lt;code&gt;&lt;a href=&quot;#erase-1&quot;&gt;erase/1&lt;/a&gt;&lt;/code&gt;) or replaced by another (using &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt;), a global garbage collection is initiated. It works like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27327d683c2a19be0af9413a3ffb06c50231cc3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Addr&lt;/code&gt; is not specified i.e by using only a &lt;code&gt;Domain&lt;/code&gt; atom, the host's name is resolved to find the IP address, and the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">如果未指定 &lt;code&gt;Addr&lt;/code&gt; 即仅使用 &lt;code&gt;Domain&lt;/code&gt; 原子，则解析主机名以找到IP地址，并使用 &lt;code&gt;port&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="2dab5adc2b60fbe4714b50e24055b1753a3e2460" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CHOICE&lt;/code&gt; contains an extension marker and the decoder detects an unknown alternative of the &lt;code&gt;CHOICE&lt;/code&gt;, the value is represented as follows:</source>
          <target state="translated">当 &lt;code&gt;CHOICE&lt;/code&gt; 包含扩展标记并且解码器检测到 &lt;code&gt;CHOICE&lt;/code&gt; 的未知替代项时，该值表示如下：</target>
        </trans-unit>
        <trans-unit id="8d1d4d39dc5b42bbde592ff2e91a12f51026609b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SEQUENCE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt; contains an extension marker and extension components as the following, the type can get more components in newer versions of the ASN.1 spec:</source>
          <target state="translated">当 &lt;code&gt;SEQUENCE&lt;/code&gt; 或 &lt;code&gt;SET&lt;/code&gt; 包含如下扩展标记和扩展组件时，该类型可以在ASN.1规范的较新版本中获得更多组件：</target>
        </trans-unit>
        <trans-unit id="6259eac0d0652866c8be2d5774deb52d326c9816" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered, a &lt;code&gt;'DOWN'&lt;/code&gt; message is sent that has the following pattern:</source>
          <target state="translated">当一个 &lt;code&gt;process&lt;/code&gt; 或 &lt;code&gt;port&lt;/code&gt; 监视器被触发时，一 &lt;code&gt;'DOWN'&lt;/code&gt; 发送消息具有以下图案：</target>
        </trans-unit>
        <trans-unit id="dabb982d5bde66066a06ee6a787d40663b30219a" translate="yes" xml:space="preserve">
          <source>When a NETCONF server receives a &lt;code&gt;close-session&lt;/code&gt; request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a &lt;code&gt;close-session&lt;/code&gt; request are ignored.</source>
          <target state="translated">NETCONF服务器收到 &lt;code&gt;close-session&lt;/code&gt; 请求时，将正常关闭会话。服务器释放与该会话关联的所有锁和资源，并优雅地关闭所有关联的连接。在 &lt;code&gt;close-session&lt;/code&gt; 请求之后收到的任何NETCONF请求都将被忽略。</target>
        </trans-unit>
        <trans-unit id="6aef919ab5c9d7ca0a1f781798e898aede6e2d15" translate="yes" xml:space="preserve">
          <source>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. &lt;code&gt;erl_nif.h&lt;/code&gt; defines the following:</source>
          <target state="translated">构建NIF库后，有关NIF API版本的信息将编译到该库中。加载NIF库后，运行时系统将验证该库是否为兼容版本。 &lt;code&gt;erl_nif.h&lt;/code&gt; 定义以下内容：</target>
        </trans-unit>
        <trans-unit id="d3817362b42209950451aa710a170de1764e4ae2" translate="yes" xml:space="preserve">
          <source>When a TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618a279b6e67c1feb5bfb9caf244cc07fcd0fd4b" translate="yes" xml:space="preserve">
          <source>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after</source>
          <target state="translated">当重复捕获子模式时,捕获的值是与最后一次迭代相匹配的子串。例如,在</target>
        </trans-unit>
        <trans-unit id="8960db8cbc60fbad0889c97d7dc8dbc2ed095e75" translate="yes" xml:space="preserve">
          <source>When a carrier becomes empty, it will be deallocated. Carrier deallocation is always done by the owner that allocated the carrier. By doing this, the underlying functionality of allocating and deallocating carriers can remain simple and doesn't have to bother about multiple threads. In a NUMA system we will also not mix carriers originating from multiple NUMA nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f68f94834caf1f15745e0db7a8ee40b6d20cae" translate="yes" xml:space="preserve">
          <source>When a carrier is being removed from a pool, we mark it with a thread progress value that needs to be reached before we are allowed to modify the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; fields. That is, until we reach this thread progress we are not allowed to insert the carrier into the pool again, and we are not allowed to deallocate the carrier. This ensures that threads inspecting the pool always will be able to traverse the pool and reach valid elements. Once we have reached the thread progress value that the carrier was tagged with, we know that no threads may have references to it via the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b986ca062e5cbe2bd3af1261b097a64c49e1e7a8" translate="yes" xml:space="preserve">
          <source>When a carrier is deallocated a free memory segment will be created inside the corresponding area, unless the carrier was at the very top (in &lt;code&gt;sa&lt;/code&gt;) or bottom (in &lt;code&gt;sua&lt;/code&gt;) in which case the area will just shrink down or up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080131fee2275102365afd60d1617478b9f8e7d4" translate="yes" xml:space="preserve">
          <source>When a carrier is empty, i.e. contains only one large free block, it is deallocated. Since multi-block carriers can contain both allocated blocks and free blocks at the same time, an allocator instance might be stuck with a large amount of poorly utilized carriers if the memory load decreases. After a peak in memory usage it is expected that not all memory can be returned since the blocks still allocated are likely to be dispersed over multiple carriers. Such poorly utilized carriers can usually be reused if the memory load increases again. However, since each scheduler thread manages its own set of allocator instances, and memory load is not necessarily correlated to CPU load, we might get into a situation where there are lots of poorly utilized multi-block carriers on some allocator instances while we need to allocate new multi-block carriers on other allocator instances. In scenarios like this, the demand for multi-block carriers in the system might increase at the same time as the actual memory demand in the system has decreased which is both unwanted and quite unexpected for the end user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65b284abe74e6a02c174667276a95aa7be67345" translate="yes" xml:space="preserve">
          <source>When a client checks a server certificate there are a number of checks available like checks that the certificate is not revoked, not forged or not out-of-date.</source>
          <target state="translated">当客户端检查服务器证书时,有很多检查可供选择,比如检查证书是否被撤销、是否伪造或是否过期。</target>
        </trans-unit>
        <trans-unit id="3aadc5d6a9fff7e5e64260bfe5a84b55671b941b" translate="yes" xml:space="preserve">
          <source>When a combining transaction writes with &quot;dirty_reads&quot;, that is, the functions &lt;code&gt;dirty_match_object&lt;/code&gt;, &lt;code&gt;dirty_read&lt;/code&gt;, &lt;code&gt;dirty_index_read&lt;/code&gt;, &lt;code&gt;dirty_select&lt;/code&gt;, and so on.</source>
          <target state="translated">当合并事务使用&amp;ldquo; dirty_reads&amp;rdquo;写入时，即函数 &lt;code&gt;dirty_match_object&lt;/code&gt; ， &lt;code&gt;dirty_read&lt;/code&gt; ， &lt;code&gt;dirty_index_read&lt;/code&gt; ， &lt;code&gt;dirty_select&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="1a2b39b4ebe51a72b88123d3bad51bb926bc1540" translate="yes" xml:space="preserve">
          <source>When a complete sequence of valid events has been received, the result is returned as a list of letters.</source>
          <target state="translated">当收到一个完整的有效事件序列时,结果将以字母列表的形式返回。</target>
        </trans-unit>
        <trans-unit id="3ab3080f29934aab21a3904dcbbbf54ca9667260" translate="yes" xml:space="preserve">
          <source>When a configuration function fails (that is, terminates unexpectedly), the test cases depending on the configuration function are skipped automatically by &lt;code&gt;Common Test&lt;/code&gt;. The status of the test cases is then &quot;auto-skipped&quot;. Test cases are also &quot;auto-skipped&quot; by &lt;code&gt;Common Test&lt;/code&gt; if the required configuration data is unavailable at runtime.</source>
          <target state="translated">当配置功能失败（即意外终止）时， &lt;code&gt;Common Test&lt;/code&gt; 会自动跳过取决于配置功能的测试用例。然后，测试用例的状态为&amp;ldquo;自动跳过&amp;rdquo;。如果所需的配置数据在运行时不可用， &lt;code&gt;Common Test&lt;/code&gt; 也将&amp;ldquo;自动跳过&amp;rdquo; 测试用例。</target>
        </trans-unit>
        <trans-unit id="a5b5a638207ad9c6b58bc05153489fdb31694f0d" translate="yes" xml:space="preserve">
          <source>When a configuration variable name is used as reference to the data specifying the connection, the handle returned as a result of opening the connection must be used in all subsequent calls (also for closing the connection). Repeated calls to the open function with the same variable name as reference results in multiple connections being opened. This can be useful, for example, if a test case needs to open multiple connections to the same server on the target node (using the same configuration data for each connection).</source>
          <target state="translated">当一个配置变量名被用作指定连接的数据的引用时,打开连接后返回的句柄必须用于所有后续调用(也用于关闭连接)。用相同的变量名作为引用重复调用open函数会导致多个连接被打开。例如,如果一个测试用例需要打开多个连接到目标节点上的同一台服务器(为每个连接使用相同的配置数据),这可能是有用的。</target>
        </trans-unit>
        <trans-unit id="e5c050aa3f173823d46ef7ab459ceb273e450e96" translate="yes" xml:space="preserve">
          <source>When a connection is accepted, a new context for the accepted connection should be created and &lt;code&gt;*ctx&lt;/code&gt; should be updated to point to the new context for the accepted connection. When called &lt;code&gt;addr&lt;/code&gt; points to an uninitialized address structure of lenght &lt;code&gt;*len&lt;/code&gt;. Uppon return this callback should have updated this structure with information about the client address. &lt;code&gt;*len&lt;/code&gt; should be updated to reflect the size of &lt;code&gt;*addr&lt;/code&gt; updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40f1ad1022ce7c7ff4a72defc83b1ece3312d0f" translate="yes" xml:space="preserve">
          <source>When a correct code has been given, the door is unlocked and the following tuple is returned from &lt;code&gt;locked/2&lt;/code&gt;:</source>
          <target state="translated">输入正确的密码后，门将被解锁，并且从 &lt;code&gt;locked/2&lt;/code&gt; 返回以下元组：</target>
        </trans-unit>
        <trans-unit id="6c237674f28de05213f857e3fa04838ee21db142" translate="yes" xml:space="preserve">
          <source>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</source>
          <target state="translated">当一个目录被添加到代码路径和整个代码路径被(重新)设置时,代码服务器会决定应用程序中哪些子目录要从存档中读取,哪些子目录要作为普通文件读取。如果之后添加或删除了目录,如果代码路径没有更新(可能是更新到与之前相同的路径,以触发目录解析更新),文件访问可能会失败。</target>
        </trans-unit>
        <trans-unit id="08512ee349a9c8aac50037692c41425ea5af4861" translate="yes" xml:space="preserve">
          <source>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none, a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items starts from there. If the format is &lt;code&gt;internal&lt;/code&gt; and the existing file is not recognized as an internally formatted log, a tuple &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; is returned.</source>
          <target state="translated">当以读写模式打开磁盘日志时，将检查所有现有的日志文件。如果没有，则创建一个新的空日志，否则将在最后一个记录的项目之后的位置打开现有文件，并从此处开始记录项目。如果格式是 &lt;code&gt;internal&lt;/code&gt; 格式，并且现有文件未被识别为内部格式的日志，则返回元组 &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd89c709c241e9c3808c6d9ef3bbf0c663231656" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_RESP&lt;/code&gt;.</source>
          <target state="translated">当分布式节点启动时，它将自己注册到EPMD中。以下所述的消息 &lt;code&gt;ALIVE2_REQ&lt;/code&gt; 从节点发送到EPMD。EPMD的响应为 &lt;code&gt;ALIVE2_RESP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e19066774d0292834ea4eb6c62d86023ec350ebc" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; (or &lt;code&gt;ALIVE2_RESP&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a52fed0cfcde5066a985fe2bdb039481aa8004a" translate="yes" xml:space="preserve">
          <source>When a driver creates a monitor for a process, a &lt;code&gt;ErlDrvMonitor&lt;/code&gt; is filled in. This is an opaque data type that can be assigned to, but not compared without using the supplied compare function (that is, it behaves like a struct).</source>
          <target state="translated">当驱动程序为进程创建监视器时，将填充 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 。这是一种不透明的数据类型，可以将其分配给该数据类型，但如果不使用提供的比较功能则不能对其进行比较（即，其行为类似于结构）。</target>
        </trans-unit>
        <trans-unit id="7d91cc2fa6325a0dec9adb1ac103e1c55c09f52b" translate="yes" xml:space="preserve">
          <source>When a driver is loaded it is executed in the context of the emulator, shares the same memory and the same thread. This means that all operations in the driver must be non-blocking, and that any crash in the driver brings the whole emulator down. In short, be careful.</source>
          <target state="translated">当一个驱动程序被加载时,它是在模拟器的上下文中执行的,共享相同的内存和相同的线程。这意味着驱动中的所有操作都必须是非阻塞的,驱动中的任何崩溃都会使整个模拟器瘫痪。总之,要小心。</target>
        </trans-unit>
        <trans-unit id="23ef058276dd33859a9cf8494fcadec228e0e9ee" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for input. This callback is called when the emulator detects input on a file descriptor that the driver has marked for monitoring by using the interface &lt;code&gt;driver_select&lt;/code&gt;. The mechanism of driver select makes it possible to read non-blocking from file descriptors by calling &lt;code&gt;driver_select&lt;/code&gt; when reading is needed, and then do the reading in this callback (when reading is possible). The typical scenario is that &lt;code&gt;driver_select&lt;/code&gt; is called when an Erlang process orders a read operation, and that this routine sends the answer when data is available on the file descriptor.</source>
          <target state="translated">当信号指示输入文件描述符时。当模拟器使用接口 &lt;code&gt;driver_select&lt;/code&gt; 接口检测到驱动程序已标记要监视的文件描述符上的输入时，将调用此回调。通过驱动程序选择机制，可以在需要读取时通过调用 &lt;code&gt;driver_select&lt;/code&gt; 来读取文件描述符中的非阻塞信息，然后在此回调中进行读取（如果可能的话）。典型的情况是，当Erlang进程命令进行读取操作时，将调用 &lt;code&gt;driver_select&lt;/code&gt; ，并且当文件描述符上的数据可用时，此例程将发送答案。</target>
        </trans-unit>
        <trans-unit id="a679df0f77926839147106039935be1d682ca28a" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for output. This callback is called in a similar way as the previous, but when writing to a file descriptor is possible. The usual scenario is that Erlang orders writing on a file descriptor and that the driver calls &lt;code&gt;driver_select&lt;/code&gt;. When the descriptor is ready for output, this callback is called and the driver can try to send the output. Queuing can be involved in such operations, and there are convenient queue routines available to the driver writer to use.</source>
          <target state="translated">当发出信号以输出文件描述符时。该回调的调用方式与以前类似，但是在写入文件描述符时是可行的。通常的情况是Erlang命令在文件描述符上进行写操作，并且驱动程序调用 &lt;code&gt;driver_select&lt;/code&gt; 。当描述符准备输出时，将调用此回调，并且驱动程序可以尝试发送输出。排队可能涉及此类操作，并且驱动程序编写者可以使用方便的队列例程。</target>
        </trans-unit>
        <trans-unit id="cff5a25a671ee65d3e016e0e72ebcef87ec1e190" translate="yes" xml:space="preserve">
          <source>When a file is saved the name in the &lt;code&gt;-module().&lt;/code&gt; line is checked against the file name. Should they mismatch Emacs can change the module specifier so that it matches the file name. By default, the user is asked before the change is performed.</source>
          <target state="translated">保存文件后，将名称保存在 &lt;code&gt;-module().&lt;/code&gt; 根据文件名检查行。如果它们不匹配，Emacs可以更改模块说明符，使其与文件名匹配。默认情况下，在执行更改之前会询问用户。</target>
        </trans-unit>
        <trans-unit id="3f363e70739be22c64648901764e5ee5e3346b81" translate="yes" xml:space="preserve">
          <source>When a filter includes the &lt;code&gt;no&lt;/code&gt; atom, it excludes the reports that match that filter.</source>
          <target state="translated">当过滤器包含 &lt;code&gt;no&lt;/code&gt; 原子时，它将排除与该过滤器匹配的报告。</target>
        </trans-unit>
        <trans-unit id="e330f04c70993b25abdd0ad93b28b509d5140f2d" translate="yes" xml:space="preserve">
          <source>When a foreign allocator instance abandons a carrier back into the pool, it will also pass it back to its &lt;strong&gt;owner&lt;/strong&gt; using the delayed dealloc queue. When doing this it will set the HOMECOMING bit flag to mark it as &quot;enqueued&quot;. The owner will later clear the HOMECOMING bit when the carrier is dequeued. This mechanism prevents a carrier from being enqueued again before it has been dequeued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b080dca26694157c4bd883a5fe6d59a076fa4f" translate="yes" xml:space="preserve">
          <source>When a function &lt;code&gt;m:f/N&lt;/code&gt; is called, first the code for the function is located. If the function cannot be found, an &lt;code&gt;undef&lt;/code&gt; runtime error occurs. Notice that the function must be exported to be visible outside the module it is defined in.</source>
          <target state="translated">当调用函数 &lt;code&gt;m:f/N&lt;/code&gt; 时，首先找到该函数的代码。如果找不到该函数，则会发生 &lt;code&gt;undef&lt;/code&gt; 运行时错误。请注意，必须导出该函数以使其在定义该模块的模块之外可见。</target>
        </trans-unit>
        <trans-unit id="74208e09de14be7d14103a45ed652bc9fc053707" translate="yes" xml:space="preserve">
          <source>When a function defined elsewhere is used as a fun, it can be referred to as &lt;code&gt;Function/Arity&lt;/code&gt; (remember that &lt;code&gt;Arity&lt;/code&gt; = number of arguments). So in the &lt;code&gt;map&lt;/code&gt;-call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; is written. As shown, &lt;code&gt;convert_list_to_c&lt;/code&gt; becomes much shorter and easier to understand.</source>
          <target state="translated">当在别处定义的函数用作乐趣时，可以将其称为&amp;ldquo; &lt;code&gt;Function/Arity&lt;/code&gt; （请记住 &lt;code&gt;Arity&lt;/code&gt; =参数数量）。因此，在 &lt;code&gt;map&lt;/code&gt; -call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; 被写入。如图所示， &lt;code&gt;convert_list_to_c&lt;/code&gt; 变得更短，更容易理解。</target>
        </trans-unit>
        <trans-unit id="74001e8b9e330c78c97c92b41f6d0fc8532d215e" translate="yes" xml:space="preserve">
          <source>When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option &lt;code&gt;export_all&lt;/code&gt; was given) or if not all calls to the function are inlined.</source>
          <target state="translated">内联函数时，如果原始函数被导出（通过显式导出或给出了 &lt;code&gt;export_all&lt;/code&gt; 选项），或者如果未内联对函数的所有调用，则保留原始函数。</target>
        </trans-unit>
        <trans-unit id="f80601e5580fc09c93533fc9ff760c5048491df1" translate="yes" xml:space="preserve">
          <source>When a functional module has been changed, for example, if a new function has been added or a bug has been corrected, simple code replacement is sufficient, for example:</source>
          <target state="translated">当一个功能模块发生变化时,比如增加了新的功能,或者修正了BUG,简单的代码替换即可,比如。</target>
        </trans-unit>
        <trans-unit id="177c42f544b61e4f56d8eebb388d0ad5082dd374" translate="yes" xml:space="preserve">
          <source>When a grammar rule is used by the parser to parse (part of) the input string as a grammatical phrase, the associated code is evaluated, and the value of the last expression becomes the value of the parsed phrase. This value may be used by the parser later to build structures that are values of higher phrases of which the current phrase is a part. The values initially associated with terminal category phrases, i.e. input tokens, are the token tuples themselves.</source>
          <target state="translated">当语法规则被解析器用来解析输入字符串的(部分)语法短语时,相关的代码会被评估,最后一个表达式的值成为解析后短语的值。这个值以后可以被解析器用来建立结构,这些结构是当前短语是其一部分的上级短语的值。最初与终端类别短语(即输入标记)相关联的值是标记元组本身。</target>
        </trans-unit>
        <trans-unit id="b974112391a6bf5f0b5186bac330512807e3d96c" translate="yes" xml:space="preserve">
          <source>When a group of subtrees (as e.g., the argument list of an &lt;code&gt;application&lt;/code&gt; node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by &lt;code&gt;Node&lt;/code&gt; even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if &lt;code&gt;Tree&lt;/code&gt; represents a list of integers &quot;&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;&quot;, the result of &lt;code&gt;limit(Tree, 5)&lt;/code&gt; will represent &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt;.</source>
          <target state="translated">当一组子树（例如， &lt;code&gt;application&lt;/code&gt; 节点的参数列表）处于指定的深度，并且该组中有两个或更多子树时，即使它们是叶节点，它们也将被 &lt;code&gt;Node&lt;/code&gt; 集体替换。超过指定深度的子树组的大小将受到限制，就好像该组中的每个后续树都比前一个树深一级。例如，如果 &lt;code&gt;Tree&lt;/code&gt; 表示整数列表 &lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt; &amp;ldquo;， &lt;code&gt;limit(Tree, 5)&lt;/code&gt; 将表示 &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="546a7cd5ad3598834756b341e22241b28b75ab4c" translate="yes" xml:space="preserve">
          <source>When a halt log has reached its maximum size, all attempts to log more items are rejected. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which for halt implies that there is no maximum size.</source>
          <target state="translated">当暂停日志达到最大大小时，将拒绝所有尝试记录更多项目的尝试。默认设置为 &lt;code&gt;infinity&lt;/code&gt; ，如果暂停，则表示没有最大大小。</target>
        </trans-unit>
        <trans-unit id="c1c98f68dda1e070c7b87a7615f91fa26ae95480" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0173ad86ffa8dc5a72f7880331dbb41cadacb3d5" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="translated">添加处理程序时，例如通过调用 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt; ，Logger首先调用 &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt; 。如果此函数返回 &lt;code&gt;{ok,Config1}&lt;/code&gt; ，则Logger将 &lt;code&gt;Config1&lt;/code&gt; 写入配置数据库，然后 &lt;code&gt;logger:add_handler/3&lt;/code&gt; 调用返回。此后，将安装处理程序，并且必须准备好接收对 &lt;code&gt;HModule:log/2&lt;/code&gt; 的调用的日志事件。</target>
        </trans-unit>
        <trans-unit id="0b3fa26b8c4473c5e6353f135f20edbe40b9dc4c" translate="yes" xml:space="preserve">
          <source>When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.</source>
          <target state="translated">当行尾被定义为单个字符时,dot从不匹配该字符。当使用双字符序列CRLF时,如果CR后面紧跟LF,则点不匹配CR,否则它匹配所有字符(包括孤立的CR和LF)。当识别出任何Unicode行尾时,点不匹配CR、LF或任何其他行尾字符。</target>
        </trans-unit>
        <trans-unit id="c40d296ef828ecaf94ab88122caa6be54ba75b8f" translate="yes" xml:space="preserve">
          <source>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; is specified as &lt;code&gt;Pattern&lt;/code&gt;, this means either &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</source>
          <target state="translated">指定二进制列表时，它表示要搜索的一组备用二进制。例如，如果将 &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; 指定为 &lt;code&gt;Pattern&lt;/code&gt; ，则表示 &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt; &amp;ldquo;。一组可选项；当仅指定一个二进制文件时，该组中只有一个元素。</target>
        </trans-unit>
        <trans-unit id="02499167e2c00f5483adfce488f74d0d03997387" translate="yes" xml:space="preserve">
          <source>When a log event is issued on a process which has its group leader on a remote node, Logger automatically forwards the log event to the group leader's node. To achieve this, it first sends the log event as an Erlang message from the original client process to the proxy on the local node, and the proxy in turn forwards the event to the proxy on the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e35511e71a7b0fd611ce8579dd128d7b017ba30" translate="yes" xml:space="preserve">
          <source>When a log file is opened (for appending or created), a time stamp is written to the file. If nothing has been written to the log files for 15 minutes, a record is inserted that says that we are still alive.</source>
          <target state="translated">当一个日志文件被打开(用于追加或创建)时,一个时间戳会被写入文件。如果15分钟内没有向日志文件写入任何内容,就会插入一条记录,说明我们还活着。</target>
        </trans-unit>
        <trans-unit id="06e4937e775c2f940892fdab2739edda1362aa4d" translate="yes" xml:space="preserve">
          <source>When a log macro is used, Logger also inserts location information:</source>
          <target state="translated">当使用日志宏时,Logger也会插入位置信息。</target>
        </trans-unit>
        <trans-unit id="aad0f82e057ba4854abcfc52c2eb835c19bd6591" translate="yes" xml:space="preserve">
          <source>When a managed object is referenced in an SNMP operation, the associated &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user.</source>
          <target state="translated">在SNMP操作中引用托管对象时，将调用关联的 &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; 。该函数将应用于某些标准参数（例如，操作类型）和用户提供的其他参数。</target>
        </trans-unit>
        <trans-unit id="1bea9285e0f879b126068ba7917e2a2ade25429d" translate="yes" xml:space="preserve">
          <source>When a manager makes a request to the agent, the following illustrates the situation:</source>
          <target state="translated">当经理向代理商提出请求时,如下图所示。</target>
        </trans-unit>
        <trans-unit id="092784e3d7c652eb428c18ea5b4a28b1c8500ff7" translate="yes" xml:space="preserve">
          <source>When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for &lt;code&gt;pcre_exec()&lt;/code&gt;&quot; in the &lt;code&gt;pcreapi&lt;/code&gt; documentation. In the following example of &lt;code&gt;pcretest&lt;/code&gt; output, the /K modifier requests the retrieval and outputting of (*MARK) data:</source>
          <target state="translated">匹配成功后，匹配路径上最后遇到的（* MARK：NAME），（* PRUNE：NAME）或（* THEN：NAME）的名称将传递回调用方，如&amp;ldquo;额外的数据 &lt;code&gt;pcreapi&lt;/code&gt; 文档中的pcre_exec &lt;code&gt;pcre_exec()&lt;/code&gt; 。在以下 &lt;code&gt;pcretest&lt;/code&gt; 输出示例中，/ K修饰符请求检索和输出（* MARK）数据：</target>
        </trans-unit>
        <trans-unit id="b9ff74687968e879951bb5da792862457fd61b73" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message &lt;code&gt;emsg.msg&lt;/code&gt; and &lt;code&gt;emsg.to&lt;/code&gt; or &lt;code&gt;emsg.from&lt;/code&gt;, depending on the type of message received.</source>
          <target state="translated">收到消息后，呼叫者有责任根据接收到的消息 &lt;code&gt;emsg.msg&lt;/code&gt; 释放接收到的消息emsg.msg和 &lt;code&gt;emsg.to&lt;/code&gt; 或 &lt;code&gt;emsg.from&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40d636d4574d28e3506b270ee7f22e76179c5d66" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed264eb2a6ed34dada4086d909002ae020169ab" translate="yes" xml:space="preserve">
          <source>When a message is received</source>
          <target state="translated">当收到信息时</target>
        </trans-unit>
        <trans-unit id="8503be402b4e5542f8b3e1bb21c05d662a4228ff" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process on another Erlang node, it is first encoded to the Erlang External Format before being sent through a TCP/IP socket. The receiving Erlang node decodes the message and distributes it to the correct process.</source>
          <target state="translated">当一个消息被发送到另一个Erlang节点上的进程时,在通过TCP/IP套接字发送之前,它首先被编码为Erlang外部格式。接收的Erlang节点会对消息进行解码,并将其分发到正确的进程中。</target>
        </trans-unit>
        <trans-unit id="551c8d852b503a0a48471c3cded481149fff350c" translate="yes" xml:space="preserve">
          <source>When a module is Cover compiled, it is also loaded using the normal code loading mechanism of Erlang. This means that if a Cover compiled module is re-loaded during a Cover session, for example using &lt;code&gt;c(Module)&lt;/code&gt;, it will no longer be Cover compiled.</source>
          <target state="translated">当一个模块被Cover编译时，它也使用Erlang的常规代码加载机制加载。这意味着，如果在Cover会话期间重新加载Cover编译模块，例如使用 &lt;code&gt;c(Module)&lt;/code&gt; ，则将不再对其进行Cover编译。</target>
        </trans-unit>
        <trans-unit id="072f598e1ef5d76264967426b11622ee9dff185e" translate="yes" xml:space="preserve">
          <source>When a module is to be updated, the release handler finds which processes that are &lt;strong&gt;using&lt;/strong&gt; the module by traversing the supervision tree of each running application and checking all the child specifications:</source>
          <target state="translated">当要更新模块时，发布处理程序通过遍历每个正在运行的应用程序的监视树并检查所有子规范&lt;strong&gt;来&lt;/strong&gt;查找正在&lt;strong&gt;使用&lt;/strong&gt;该模块的进程。</target>
        </trans-unit>
        <trans-unit id="9033ba75ed69bf751fa6e5b051720381187f258c" translate="yes" xml:space="preserve">
          <source>When a new OTP release is released it will have an OTP version on the form &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; where the major OTP version number equals the release number. The major version number is increased one step since the last major version. All other OTP versions with the same major OTP version number are patches on that OTP release.</source>
          <target state="translated">发布新的OTP版本时，它将具有格式为 &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; 的OTP版本，其中主要的OTP版本号等于发行版本号。自上一个主要版本以来，主要版本号增加了一步。具有相同主要OTP版本号的所有其他OTP版本都是该OTP版本上的补丁。</target>
        </trans-unit>
        <trans-unit id="cbbb4bde17a561149622c0549faa70bd0cd996df" translate="yes" xml:space="preserve">
          <source>When a new fun is defined in the shell, the value of the fun is printed as &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">当在外壳程序中定义了新的 &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt; 的值将显示为Fun＃&amp;lt;erl_eval&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="1a3c0fc498149078e34911c14f7a085c035bd806" translate="yes" xml:space="preserve">
          <source>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</source>
          <target state="translated">当安装新版本的版本时,会自动更新所有加载的应用程序的应用程序规格。</target>
        </trans-unit>
        <trans-unit id="1659bff51ef846577db0a731a65e27f0a6975ea2" translate="yes" xml:space="preserve">
          <source>When a node gets overloaded, it is not possible to issue &lt;code&gt;ttb:p/2&lt;/code&gt; or any command from the &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; family, as it would lead to inconsistent tracing state (different trace specifications on different nodes).</source>
          <target state="translated">当节点过载时，将无法发出 &lt;code&gt;ttb:p/2&lt;/code&gt; 或 &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; 系列的任何命令，因为这会导致跟踪状态不一致（不同节点上的跟踪规范不同）。</target>
        </trans-unit>
        <trans-unit id="9107c7e3a2ab54b42fe2aa4f90dbf2f0ef91d069" translate="yes" xml:space="preserve">
          <source>When a node tries to connect to another node, the magic cookies are compared. If they do not match, the connected node rejects the connection.</source>
          <target state="translated">当一个节点试图连接到另一个节点时,会比较魔法饼干。如果它们不匹配,连接的节点就会拒绝连接。</target>
        </trans-unit>
        <trans-unit id="91dc7db1911778980d1a145028f56ea061e34c24" translate="yes" xml:space="preserve">
          <source>When a parenthesized subpattern is quantified with a minimum repeat count that is &amp;gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.</source>
          <target state="translated">当使用最小重复计数&amp;gt; 1或最大值受限来量化带括号的子模式时，与最小或最大大小成比例的编译模式需要更多内存。</target>
        </trans-unit>
        <trans-unit id="17163b128ce2d3940abc9e287d9eb3065dfe4943" translate="yes" xml:space="preserve">
          <source>When a part in the version number increases, all less significant parts are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">当版本号中的一部分增加时，所有不重要的部分都将设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="414ecb7481a0e4a00ed77662f92beb6946aca44b" translate="yes" xml:space="preserve">
          <source>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern</source>
          <target state="translated">当一个模式在一个子模式里面包含了一个无限重复,而这个子模式本身又可以无限次重复的时候,使用原子组是避免一些失败的匹配需要很长时间的唯一方法。该模式</target>
        </trans-unit>
        <trans-unit id="ca6c00c70d6d587bfac21cf87c7afe2ad1eacd1f" translate="yes" xml:space="preserve">
          <source>When a pending message is received, and the &lt;code&gt;long_request_timer&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; &quot;on its final leg&quot;, the timer will be restarted, and, if &lt;code&gt;long_request_resend = true&lt;/code&gt;, the request will be re-sent.</source>
          <target state="translated">当收到待处理的消息，并且 &lt;code&gt;long_request_timer&lt;/code&gt; 是&lt;strong&gt;不&lt;/strong&gt; &amp;ldquo;在其最终的腿&amp;rdquo;时，定时器将被重新启动，并且，如果 &lt;code&gt;long_request_resend = true&lt;/code&gt; ，则该请求将被重新发送。</target>
        </trans-unit>
        <trans-unit id="f75f183f6a0a339836141c5520bd7b12114dfb3c" translate="yes" xml:space="preserve">
          <source>When a pending message is received, the timer is cancelled and the &lt;code&gt;long_request_timer&lt;/code&gt; is started instead (see below). No resends will be performed from this point (since we now know that the other side has received the request).</source>
          <target state="translated">接收到待处理消息时，将取消计时器并启动 &lt;code&gt;long_request_timer&lt;/code&gt; （请参见下文）。从那时起，将不会执行任何重新发送操作（因为我们现在知道另一方已收到请求）。</target>
        </trans-unit>
        <trans-unit id="caca1f590c83f0cbc730079b288c0a340c8795e2" translate="yes" xml:space="preserve">
          <source>When a pending transaction is sent.</source>
          <target state="translated">发出待办事项时。</target>
        </trans-unit>
        <trans-unit id="9309b1e58646bc0004532eb714a09afd5a498a84" translate="yes" xml:space="preserve">
          <source>When a port is closed, either by an Erlang process or by the driver calling one of the &lt;code&gt;driver_failure_XXX&lt;/code&gt; routines. This routine is to clean up everything connected to one particular port. When other callbacks call a &lt;code&gt;driver_failure_XXX&lt;/code&gt; routine, this routine is immediately called. The callback routine issuing the error can make no more use of the data structures for the port, as this routine surely has freed all associated data and closed all file descriptors. If the queue utility available to driver writer is used, this routine is however &lt;strong&gt;not&lt;/strong&gt; called until the queue is empty.</source>
          <target state="translated">当端口关闭时，可以通过Erlang进程或驱动程序调用 &lt;code&gt;driver_failure_XXX&lt;/code&gt; 例程之一来关闭。此例程是清理连接到一个特定端口的所有内容。当其他回调调用 &lt;code&gt;driver_failure_XXX&lt;/code&gt; 例程时，将立即调用此例程。发出该错误的回调例程无法再使用该端口的数据结构，因为此例程肯定已释放了所有关联的数据并关闭了所有文件描述符。如果使用了可供驱动程序编写器使用的队列实用程序，则在队列为空之前&lt;strong&gt;不会&lt;/strong&gt;调用此例程。</target>
        </trans-unit>
        <trans-unit id="cab97407457bdcec73d321074e9305a6e73487c1" translate="yes" xml:space="preserve">
          <source>When a port to the driver is opened (by a &lt;code&gt;open_port&lt;/code&gt; call from Erlang). This routine is to set up internal data structures and return an opaque data entity of the type &lt;code&gt;ErlDrvData&lt;/code&gt;, which is a data type large enough to hold a pointer. The pointer returned by this function is the first argument to all other callbacks concerning this particular port. It is usually called the port handle. The emulator only stores the handle and does never try to interpret it, why it can be virtually anything (anything not larger than a pointer that is) and can point to anything if it is a pointer. Usually this pointer refers to a structure holding information about the particular port, as it does in the example.</source>
          <target state="translated">打开驱动程序的端口时（通过来自Erlang 的 &lt;code&gt;open_port&lt;/code&gt; 调用）。该例程用于建立内部数据结构，并返回类型 &lt;code&gt;ErlDrvData&lt;/code&gt; 的不透明数据实体，该数据实体的大小足以容纳指针。此函数返回的指针是有关此特定端口的所有其他回调的第一个参数。通常称为端口句柄。仿真器仅存储该句柄，并且从不尝试解释它，为什么它实际上可以是任何东西（任何不大于指针的东西），并且如果它是指针，则可以指向任何东西。通常，该指针引用的是保存有关特定端口信息的结构，如示例中所示。</target>
        </trans-unit>
        <trans-unit id="cdb990fabcbc7a603b9ecf0828ba52dca55f301b" translate="yes" xml:space="preserve">
          <source>When a process has become runnable, for example due to reception of a message, we need to determine which run queue to enqueue it in. Previously this at least involved locking the run queue that the process currently was assigned to while holding the status lock on the process. Depending on load we sometimes also had to acquire a lock on another run queue in order to be able to determine if it should be migrated to that run queue or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcdaeb5fb7f860c3cd40b383288f0699c60e450" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt; max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c6008e1040993823cc1153b9087a328f65c269" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="translated">当进程被 &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt; 杀死时，它会在垃圾回收完成之前被杀死，因此不会发送大堆消息。</target>
        </trans-unit>
        <trans-unit id="54c7049ba92415c934270df93ecc40c6ff49a6de" translate="yes" xml:space="preserve">
          <source>When a process is trapping exits, it does not terminate when an exit signal is received. Instead, the signal is transformed into a message &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt;, which is put into the mailbox of the process, just like a regular message.</source>
          <target state="translated">当一个进程正在捕获退出时，它在收到退出信号时不会终止。而是将信号转换为消息 &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt; ，将其像常规消息一样放入进程的邮箱中。</target>
        </trans-unit>
        <trans-unit id="f894aeebc67996f11b9c7ed1100aea86a6d270d1" translate="yes" xml:space="preserve">
          <source>When a process reaches a breakpoint, only that process is stopped. Other processes are not affected.</source>
          <target state="translated">当一个进程达到断点时,只有该进程被停止。其他进程不受影响。</target>
        </trans-unit>
        <trans-unit id="f5fe92890350a386281d849d2308c2fdf32b6229" translate="yes" xml:space="preserve">
          <source>When a process terminates, it always terminates with an &lt;strong&gt;exit reason&lt;/strong&gt;. The reason can be any term.</source>
          <target state="translated">进程终止时，总是以&lt;strong&gt;退出原因&lt;/strong&gt;终止。原因可以是任何术语。</target>
        </trans-unit>
        <trans-unit id="653aa417b590e598fcc2e1e4dbaa971f684c769a" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt; Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33255f3d61f1a754c180593962f65ef23e96913" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="translated">流程终止时，它会以&lt;strong&gt;退出原因&lt;/strong&gt;终止，如 &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt; 。该退出原因在&lt;strong&gt;退出信号中&lt;/strong&gt;发出给所有链接的进程。</target>
        </trans-unit>
        <trans-unit id="1c16084eb81edfdc05085ad57d93b734d5862e39" translate="yes" xml:space="preserve">
          <source>When a process terminates, we mark the process as terminated in the process structure, the counter of number of processes in the table is decreased, and the reference to the process structure is removed by writing a &lt;code&gt;NULL&lt;/code&gt; pointer into the corresponding slot. The scheduler thread performing this then schedule a thread progress later job which will do the final cleanup and deallocate the process structure. The thread progress functionality will make sure that this job will not execute until it is certain that all managed threads have dropped all references to the process structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ecf00c74cada65672d3aca9158bdc88f9b65" translate="yes" xml:space="preserve">
          <source>When a process that is started using &lt;code&gt;proc_lib&lt;/code&gt; terminates abnormally (that is, with another exit reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;), a &lt;strong&gt;crash report&lt;/strong&gt; is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">当使用 &lt;code&gt;proc_lib&lt;/code&gt; 启动的进程异常终止时（也就是说，退出原因不是 &lt;code&gt;normal&lt;/code&gt; ， &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;{shutdown,Term}&lt;/code&gt; ），则会生成&lt;strong&gt;崩溃报告&lt;/strong&gt;，该&lt;strong&gt;报告&lt;/strong&gt;将由Kernel设置的默认记录程序处理程序写入终端。 。有关在Erlang / OTP 21.0之前如何记录崩溃报告的详细信息，请参阅《 SASL用户指南》中的&amp;ldquo; &lt;code&gt;SASL Error Logging&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="620e45b56f249c1dbe8f129dc957582dac227989" translate="yes" xml:space="preserve">
          <source>When a program runs in the service context, it must handle the control events that are sent to every program in the system when the interactive user logs off. This is done in different ways for programs running in the console subsystem and programs running as window applications. An application running in the console subsystem (normal for port programs) uses the win32 function &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; to register a control handler that returns &lt;code&gt;true&lt;/code&gt; in answer to the &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; events. Other applications only forward &lt;code&gt;WM_ENDSESSION&lt;/code&gt; and &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; to the default window procedure.</source>
          <target state="translated">当程序在服务上下文中运行时，它必须处理在交互式用户注销时发送到系统中每个程序的控制事件。对于在控制台子系统中运行的程序和作为窗口应用程序运行的程序，可以通过不同的方式来完成此操作。在控制台子系统中运行的应用程序（对于端口程序正常）是使用win32函数 &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; 来注册一个控制处理程序，该处理程序在对 &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; 和 &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; 事件的回答中返回 &lt;code&gt;true&lt;/code&gt; 。其他应用程序仅将 &lt;code&gt;WM_ENDSESSION&lt;/code&gt; 和 &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; 转发到默认的窗口过程。</target>
        </trans-unit>
        <trans-unit id="19ffb1b5dfb2cc8d3c94f0461fc310cb105f6b53" translate="yes" xml:space="preserve">
          <source>When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte.</source>
          <target state="translated">当重启时,定时器和字节计数器都会重新启动。默认为一小时和一GByte。</target>
        </trans-unit>
        <trans-unit id="160df15be10c112ef08e1b12460eb364b392a9a7" translate="yes" xml:space="preserve">
          <source>When a reply &lt;code&gt;Reply&lt;/code&gt; is received from the &lt;code&gt;gen_server&lt;/code&gt; process at a node &lt;code&gt;Node&lt;/code&gt;, &lt;code&gt;{Node,Reply}&lt;/code&gt; is added to &lt;code&gt;Replies&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">当在节点 &lt;code&gt;Node&lt;/code&gt; 上从 &lt;code&gt;gen_server&lt;/code&gt; 进程收到回复 &lt;code&gt;Reply&lt;/code&gt; 时，将 &lt;code&gt;{Node,Reply}&lt;/code&gt; 添加到 &lt;code&gt;Replies&lt;/code&gt; 中。 &lt;code&gt;Reply&lt;/code&gt; 在的返回值定义 &lt;code&gt;Module:handle_call/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3612568b6d1bd1adf395a8924394d4f1cda79d" translate="yes" xml:space="preserve">
          <source>When a reply transaction is sent.</source>
          <target state="translated">当发送回复交易时。</target>
        </trans-unit>
        <trans-unit id="6b9676d76432236d4be5a23bf4ca85a4c81230e6" translate="yes" xml:space="preserve">
          <source>When a request is received, some info related to the reply is store internally (e.g. the binary of the reply). This info will live until either an ack is received or this timer expires. For instance, if the same request is received again (e.g. a request with the same transaction id), the (stored) reply will be (re-) sent automatically by megaco.</source>
          <target state="translated">当收到请求时,一些与回复相关的信息会被存储在内部(例如回复的二进制)。这些信息会一直存在,直到收到ACK或者这个定时器过期。例如,如果再次收到相同的请求(例如,一个具有相同事务ID的请求),(存储的)回复将由megaco自动(重新)发送。</target>
        </trans-unit>
        <trans-unit id="b6b06f9b88824f92a821ddd40390c63201a38782" translate="yes" xml:space="preserve">
          <source>When a request is sent using the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; function, a proxy process is started to handle all replies. When the reply has been received and delivered to the user, the proxy process continue to exist for as long as this option specifies. Any received messages, is passed on to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; 函数发送请求时，将启动代理进程来处理所有答复。收到答复并将其发送给用户后，只要此选项指定，代理进程就继续存在。任何收到的消息都会通过 &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; 回调函数传递给用户。</target>
        </trans-unit>
        <trans-unit id="c88f71ef842c681d045f4cae79da80397386486a" translate="yes" xml:space="preserve">
          <source>When a run-time error occurs, that is an exception of class &lt;code&gt;error&lt;/code&gt;. The exit reason is a tuple &lt;code&gt;{Reason,Stack}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is a term indicating the type of error:</source>
          <target state="translated">当发生运行时错误时，这是​​class &lt;code&gt;error&lt;/code&gt; 的例外。退出原因是元组 &lt;code&gt;{Reason,Stack}&lt;/code&gt; ，其中 &lt;code&gt;Reason&lt;/code&gt; 是指示错误类型的术语：</target>
        </trans-unit>
        <trans-unit id="25b12f8bd1c57b6ce9840c0a7b9fe58cbedb898d" translate="yes" xml:space="preserve">
          <source>When a run-time error or generated error occurs in Erlang, execution for the process that evaluated the erroneous expression is stopped. This is referred to as a &lt;strong&gt;failure&lt;/strong&gt;, that execution or evaluation &lt;strong&gt;fails&lt;/strong&gt;, or that the process &lt;strong&gt;fails&lt;/strong&gt;, &lt;strong&gt;terminates&lt;/strong&gt;, or &lt;strong&gt;exits&lt;/strong&gt;. Notice that a process can terminate/exit for other reasons than a failure.</source>
          <target state="translated">当在Erlang中发生运行时错误或生成的错误时，将停止执行评估错误表达式的过程。这被称为&lt;strong&gt;失败&lt;/strong&gt;，执行或评估&lt;strong&gt;失败&lt;/strong&gt;，或进程&lt;strong&gt;失败&lt;/strong&gt;，&lt;strong&gt;终止&lt;/strong&gt;或&lt;strong&gt;退出&lt;/strong&gt;。请注意，进程可能因失败以外的其他原因终止/退出。</target>
        </trans-unit>
        <trans-unit id="fc42ebfd4ba19de1bfcb638ee30764a1aea0ba3e" translate="yes" xml:space="preserve">
          <source>When a send event and corresponding receive event do not both correspond to ordinary Erlang messages, the &lt;code&gt;Message&lt;/code&gt; part of the trace messages may not be identical. This since all information not necessarily are available when generating the trace messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6222adda532a7ba95811b3f47ed6b592bce7369e" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details), transitions to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode, the controlling process is notified by a message of the following form:</source>
          <target state="translated">当处于 &lt;code&gt;{active, N}&lt;/code&gt; 模式的套接字（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; ）转换为被动（ &lt;code&gt;{active, false}&lt;/code&gt; ）模式时，将通过以下形式的消息来通知控制过程：</target>
        </trans-unit>
        <trans-unit id="32c8173f4ed70b1d0dd242e1d68441ff570b2c43" translate="yes" xml:space="preserve">
          <source>When a socket is created (with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), it has no address assigned to it. &lt;code&gt;bind&lt;/code&gt; assigns the address specified by the &lt;code&gt;Addr&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d80a95245c078756343c02b99f486003551e30" translate="yes" xml:space="preserve">
          <source>When a specific instruction has a &lt;code&gt;d&lt;/code&gt; operand, early during execution of the instruction, a pointer will be initialized to point to the X or Y register in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad380e3a94ebd517a8a93bc527d1a2a8c42ac9d" translate="yes" xml:space="preserve">
          <source>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</source>
          <target state="translated">当获得一个粘性写锁时,所有节点都会被告知哪个节点被锁定。然后,来自同一节点的粘性锁请求作为本地操作执行,不与其他节点进行任何通信。即使事务结束后,粘性锁也会在节点上停留。详情请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="f8a9afc8539f723b3d906fa063814442e45d9210" translate="yes" xml:space="preserve">
          <source>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</source>
          <target state="translated">当一个表被SNMP排序时,修改的费用比平时要高,为O(logN)。同时,也会使用更多的内存。</target>
        </trans-unit>
        <trans-unit id="e32c49ff2c55c4db480cbc70d03e1794493e4e31" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed even if keys are removed during the traversal. The keys for objects inserted or deleted during a traversal may or may not be returned by &lt;code&gt;next/2&lt;/code&gt; depending on the ordering of keys within the table and if the key exists at the time &lt;code&gt;next/2&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09de174e5f27981b5d536ae7d587e5f775467043" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed, and each object in the table is returned only once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal &lt;strong&gt;can&lt;/strong&gt; be returned by &lt;code&gt;next/2&lt;/code&gt; (it depends on the internal ordering of the keys).</source>
          <target state="translated">修复表后，可以确保成功执行一系列的 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 调用，即使在遍历过程中删除或插入了对象，该表中的每个对象也仅返回一次。遍历期间插入的新对象的键&lt;strong&gt;可以&lt;/strong&gt;由 &lt;code&gt;next/2&lt;/code&gt; 返回（取决于键的内部顺序）。</target>
        </trans-unit>
        <trans-unit id="f25502d9a8f67791267ea14f5c70c734251d290a" translate="yes" xml:space="preserve">
          <source>When a target name is used for referencing the configuration data (that specifies the connection to be opened), the same name can be used as connection identity in all subsequent calls related to the connection (also for closing it). Only one open connection per target name is possible. If you attempt to open a new connection using a name already associated with an open connection, &lt;code&gt;Common Test&lt;/code&gt; returns the already existing handle so the previously opened connection is used. This feature makes it possible to call the function for opening a particular connection whenever useful. An action like this does not necessarily open any new connections unless it is required (which could be the case if, for example, the previous connection has been closed unexpectedly by the server). Using named connections also removes the need to pass handle references around in the suite for these connections.</source>
          <target state="translated">当使用目标名称引用配置数据（指定要打开的连接）时，可以在与该连接有关的所有后续调用中使用相同的名称作为连接标识（也用于关闭该连接）。每个目标名称只能有一个打开的连接。如果尝试使用已经与打开的连接关联的名称打开新连接，请执行&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 返回已经存在的句柄，以便使用以前打开的连接。此功能可以在需要时调用用于打开特定连接的函数。除非需要，否则此类操作不一定会打开任何新连接（例如，如果以前的连接已被服务器意外关闭，则可能是这种情况）。使用命名连接还消除了在套件中为这些连接传递句柄引用的需要。</target>
        </trans-unit>
        <trans-unit id="8b832ad499cefe25ddc82f36d870e896057644d6" translate="yes" xml:space="preserve">
          <source>When a term is passed as the initial process arguments in the &lt;code&gt;spawn&lt;/code&gt; call</source>
          <target state="translated">在 &lt;code&gt;spawn&lt;/code&gt; 调用中将术语作为初始过程参数传递时</target>
        </trans-unit>
        <trans-unit id="6e389307b8d59483ef3d7e87b6dfe90a060b042c" translate="yes" xml:space="preserve">
          <source>When a term is sent to another process</source>
          <target state="translated">当一个术语被发送到另一个进程时</target>
        </trans-unit>
        <trans-unit id="b733aebb93dce74a8914341750d479f7d8a549ed" translate="yes" xml:space="preserve">
          <source>When a term is stored in an Ets table</source>
          <target state="translated">当一个术语被存储在Ets表中时</target>
        </trans-unit>
        <trans-unit id="0c7ebdcd78a12cc7bd8bd97eb29bacb32f39549b" translate="yes" xml:space="preserve">
          <source>When a test case group is repeated, the configuration functions &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; are also always called with each repetition.</source>
          <target state="translated">当重复一个测试用例组时，每次重复也总是调用配置函数 &lt;code&gt;init_per_group/2&lt;/code&gt; 和 &lt;code&gt;end_per_group/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be9bace113be2bd43525f396f001fb603a47ce4" translate="yes" xml:space="preserve">
          <source>When a test case group is specified, the resulting test executes function &lt;code&gt;init_per_group&lt;/code&gt;, followed by all test cases and subgroups (including their configuration functions), and finally function &lt;code&gt;end_per_group&lt;/code&gt;. Also, if particular test cases in a group are specified, &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt;, for the group in question, are called. If a group defined (in &lt;code&gt;Suite:group/0&lt;/code&gt;) as a subgroup of another group, is specified (or if particular test cases of a subgroup are), &lt;code&gt;Common Test&lt;/code&gt; calls the configuration functions for the top-level groups and for the subgroup in question (making it possible to pass configuration data all the way from &lt;code&gt;init_per_suite&lt;/code&gt; down to the test cases in the subgroup).</source>
          <target state="translated">指定测试用例组后，结果测试将执行函数 &lt;code&gt;init_per_group&lt;/code&gt; ，然后执行所有测试用例和子组（包括其配置函数），最后执行函数 &lt;code&gt;end_per_group&lt;/code&gt; 。另外，如果指定了组中的特定 &lt;code&gt;init_per_group&lt;/code&gt; ， &lt;code&gt;end_per_group&lt;/code&gt; 针对所讨论的组调用init_per_group和end_per_group。如果指定了一个组（在 &lt;code&gt;Suite:group/0&lt;/code&gt; 中定义为另一个组的子组）（或者如果子组的特定测试用例被指定），则 &lt;code&gt;Common Test&lt;/code&gt; 会为顶级组和该子组中的子组调用配置功能问题（是否有可能从 &lt;code&gt;init_per_suite&lt;/code&gt; 一直传递配置数据 直到子组中的测试用例）。</target>
        </trans-unit>
        <trans-unit id="7eab1460f1347d0c73cb3c3a8b4439b39091de4a" translate="yes" xml:space="preserve">
          <source>When a test case is skipped, it is noted as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log.</source>
          <target state="translated">跳过测试用例时，在HTML日志中将其标记为&amp;ldquo; &lt;code&gt;SKIPPED&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="40f7d1ac6c7251f44715ccdcb8e5eca59fd62f4e" translate="yes" xml:space="preserve">
          <source>When a thread calls &lt;code&gt;my_val = erts_thr_progress_later()&lt;/code&gt; and waits for &lt;code&gt;erts_thr_progress_has_reached(my_val)&lt;/code&gt; to return a non zero value it knows that thread progress has been made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a076c9a80ae846b71f117a3d44b9cb45870c233b" translate="yes" xml:space="preserve">
          <source>When a time-out is started any running time-out of the same type; &lt;code&gt;state_timeout&lt;/code&gt;, &lt;code&gt;{timeout, Name}&lt;/code&gt; or &lt;code&gt;timeout&lt;/code&gt;, is cancelled, that is, the time-out is restarted with the new time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7277815e7b5fc7d7307a8ad2c9b5d0b7fee5390" translate="yes" xml:space="preserve">
          <source>When a timer expires. The driver can set timers with the function &lt;code&gt;driver_set_timer&lt;/code&gt;. When such timers expire, a specific callback function is called. No timers are used in the example.</source>
          <target state="translated">计时器到期时。驱动程序可以使用功能 &lt;code&gt;driver_set_timer&lt;/code&gt; 设置计时器。当此类计时器到期时，将调用特定的回调函数。在示例中不使用计时器。</target>
        </trans-unit>
        <trans-unit id="01248c84705afaa8d22118ccef5dc76865736320" translate="yes" xml:space="preserve">
          <source>When a transaction acknowledgement is received it is possible that user has decided not to bother about the acknowledgement. But in case the return value from UserMod:handle_trans_request/3 indicates that the acknowledgement is important the following callback function will be invoked:</source>
          <target state="translated">当接收到交易确认时,有可能用户已经决定不去理会这个确认。但如果UserMod:handle_trans_request/3的返回值表明确认是重要的,则会调用以下回调函数。</target>
        </trans-unit>
        <trans-unit id="163b7a94b619edcfd4f6cd93b3333d250e24a1fb" translate="yes" xml:space="preserve">
          <source>When a user (MG/MGC) is distributed over several nodes, it is required that the node hosting the connection already has activated the connection and that it is in the &quot;normal&quot; state. The RemoteMid must be a real Megaco MID and not a preliminary_mid.</source>
          <target state="translated">当一个用户(MG/MGC)分布在多个节点上时,要求承载连接的节点已经激活了连接,并且处于 &quot;正常 &quot;状态。RemoteMid必须是一个真正的Megaco MID,而不是一个初步的_mid。</target>
        </trans-unit>
        <trans-unit id="19eb5cc222fe8477b606be0ecb93b47faec2127d" translate="yes" xml:space="preserve">
          <source>When a valid request reaches &lt;code&gt;httpd&lt;/code&gt;, it calls &lt;code&gt;do/1&lt;/code&gt; in each module, defined by the configuration option of &lt;code&gt;Module&lt;/code&gt;. The function can generate data for other modules or a response that can be sent back to the client.</source>
          <target state="translated">当有效请求到达 &lt;code&gt;httpd&lt;/code&gt; 时，它将在每个模块（由 &lt;code&gt;Module&lt;/code&gt; 的配置选项定义）中调用 &lt;code&gt;do/1&lt;/code&gt; 。该功能可以生成其他模块的数据或可以发送回客户端的响应。</target>
        </trans-unit>
        <trans-unit id="988284baf01c48f0333363a5420ee041f8e80f73" translate="yes" xml:space="preserve">
          <source>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; instead. It can be used for records of type &lt;code&gt;RecordName&lt;/code&gt;.</source>
          <target state="translated">当访问记录中的单个属性时，没有必要甚至不建议将任何属性名称硬编码为原子。使用构造 &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; 代替。它可以用于 &lt;code&gt;RecordName&lt;/code&gt; 类型的记录。</target>
        </trans-unit>
        <trans-unit id="5a069a06056d1779ba3b73665e6912fd948d0893" translate="yes" xml:space="preserve">
          <source>When adding or removing an application, no &lt;code&gt;.appup&lt;/code&gt; file is needed. When generating &lt;code&gt;relup&lt;/code&gt;, the &lt;code&gt;.rel&lt;/code&gt; files are compared and the &lt;code&gt;add_application&lt;/code&gt; and &lt;code&gt;remove_application&lt;/code&gt; instructions are added automatically.</source>
          <target state="translated">添加或删除应用程序时，不需要 &lt;code&gt;.appup&lt;/code&gt; 文件。生成 &lt;code&gt;relup&lt;/code&gt; 时，将比较 &lt;code&gt;.rel&lt;/code&gt; 文件并自动添加 &lt;code&gt;add_application&lt;/code&gt; 和 &lt;code&gt;remove_application&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="d7dcf974a69ad2af0b183e9640143a16ca26c965" translate="yes" xml:space="preserve">
          <source>When adding processes or ports, a window with trace options is displayed. The chosen options are set for the selected processes/ports. To change the options, right-click the process or port and select &lt;strong&gt;Edit process options&lt;/strong&gt;. To remove a process or port from the list, right-click and select &lt;strong&gt;Remove process&lt;/strong&gt; or &lt;strong&gt;Remove port&lt;/strong&gt;, respectively.</source>
          <target state="translated">添加进程或端口时，将显示一个带有跟踪选项的窗口。为选定的进程/端口设置选定的选项。要更改选项，请右键单击进程或端口，然后选择&lt;strong&gt;编辑进程选项&lt;/strong&gt;。要从列表中&lt;strong&gt;删除进程&lt;/strong&gt;或&lt;strong&gt;端口&lt;/strong&gt;，请右键单击并分别选择&lt;strong&gt;Remove process&lt;/strong&gt;或&lt;strong&gt;Remove port&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8ed50d489e165b74cf018acee993218839df9d7b" translate="yes" xml:space="preserve">
          <source>When all involved (mandatory) nodes have been started, the distributed application can be started by calling &lt;code&gt;application:start(Application)&lt;/code&gt; at &lt;strong&gt;all of these nodes.&lt;/strong&gt;</source>
          <target state="translated">启动所有涉及的（强制性）节点后，可以通过在&lt;strong&gt;所有这些节点上&lt;/strong&gt;调用 &lt;code&gt;application:start(Application)&lt;/code&gt; 来启动分布式应用程序&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd73cca48ba2b286c66fc15f791c382c884ddbc5" translate="yes" xml:space="preserve">
          <source>When all nodes are operational, &lt;code&gt;myapp&lt;/code&gt; can be started. This is achieved by calling &lt;code&gt;application:start(myapp)&lt;/code&gt; at all three nodes. It is then started at &lt;code&gt;cp1&lt;/code&gt;, as shown in the following figure:</source>
          <target state="translated">当所有节点都运行时，可以启动 &lt;code&gt;myapp&lt;/code&gt; 。这是通过在所有三个节点上调用 &lt;code&gt;application:start(myapp)&lt;/code&gt; 来实现的。然后从 &lt;code&gt;cp1&lt;/code&gt; 开始，如下图所示：</target>
        </trans-unit>
        <trans-unit id="efd0a7b9eacf13a1791c55c3dbd5596c2928ca10" translate="yes" xml:space="preserve">
          <source>When all objects of the table have been matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">当表的所有对象都匹配后，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa1c6e68ed8acc251646eddfa314228262bb5f3b" translate="yes" xml:space="preserve">
          <source>When all table objects are matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">当所有表对象都匹配时，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63d12a87e8eebf1261797e6037583c36c38618e3" translate="yes" xml:space="preserve">
          <source>When allocating a new MBC we first search after a free segment in &lt;code&gt;sa&lt;/code&gt;, then try to raise &lt;code&gt;sa.top&lt;/code&gt;, and then as a fallback try to search after a free segment in &lt;code&gt;sua&lt;/code&gt;. When an MBC is allocated in &lt;code&gt;sua&lt;/code&gt;, a larger segment is allocated which is then trimmed to obtain the right alignment. Allocation search for an SBC is done in reverse order. When an SBC is allocated in &lt;code&gt;sa&lt;/code&gt;, the size is aligned up to super aligned size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c62a1cbadf2c2b8976473d30ec9850b0e30154" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;escript&lt;/code&gt; file contains an archive, there are no restrictions on the name of the &lt;code&gt;escript&lt;/code&gt; and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) &lt;code&gt;ebin&lt;/code&gt; directories in the embedded archive are added to the code path. See &lt;code&gt;erts:escript(1)&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;escript&lt;/code&gt; 文件包含存档时，对 &lt;code&gt;escript&lt;/code&gt; 的名称没有任何限制，并且可以在嵌入式存档中存储多少个应用程序也没有限制。Single Beam文件也可以位于归档文件的顶层。启动时，嵌入式归档文件中的顶层目录和嵌入式归档文件中的所有（第二级） &lt;code&gt;ebin&lt;/code&gt; 目录都添加到代码路径中。参见 &lt;code&gt;erts:escript(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9936eae6e93ab6d5c78b6480d03e1af10ab7148" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;usm_entry()&lt;/code&gt; tuple (or a list of such tuples) is returned, this data is then added to the &lt;code&gt;usmUserTable&lt;/code&gt; by the (master-) agent.</source>
          <target state="translated">当 &lt;code&gt;usm_entry()&lt;/code&gt; 元组（或此类元组的列表）时，该数据然后由（master-）代理添加到 &lt;code&gt;usmUserTable&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0b976e99904fcceb1196e74093f891273ad96adf" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled with option &lt;code&gt;ber&lt;/code&gt;, the &lt;code&gt;asn1rt_nif&lt;/code&gt; module and the NIF library in &lt;code&gt;asn1/priv_dir&lt;/code&gt; are needed at runtime.</source>
          <target state="translated">使用选项 &lt;code&gt;ber&lt;/code&gt; 编译ASN.1规范时，需要在运行时使用 &lt;code&gt;asn1/priv_dir&lt;/code&gt; 中的 &lt;code&gt;asn1rt_nif&lt;/code&gt; 模块和NIF库。</target>
        </trans-unit>
        <trans-unit id="5c483462464501bc7953de399a743714b5061e30" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled, all defined types of type &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SEQUENCE&lt;/code&gt; result in a corresponding record in the generated &lt;code&gt;.hrl&lt;/code&gt; file. This is because the values for &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;SEQUENCE&lt;/code&gt; are represented as records by default.</source>
          <target state="translated">编译ASN.1规范时， &lt;code&gt;SET&lt;/code&gt; 或 &lt;code&gt;SEQUENCE&lt;/code&gt; 类型的所有已定义类型都会在生成的 &lt;code&gt;.hrl&lt;/code&gt; 文件中产生相应的记录。这是因为默认情况下 &lt;code&gt;SET&lt;/code&gt; 和 &lt;code&gt;SEQUENCE&lt;/code&gt; 的值表示为记录。</target>
        </trans-unit>
        <trans-unit id="31932f1867f6d60bbc033269d0dec3fc07011233" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c8df5e2566ccd5d9fbe4734d8fd9d613779aa" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="translated">当Erlang进程调用 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 时，它是驱动程序的同步接口。控制界面用于设置驱动程序选项，更改端口状态等。该接口在示例中使用很多。</target>
        </trans-unit>
        <trans-unit id="2b618715bb8bb03bc07feda65b3a85bb43cb72de" translate="yes" xml:space="preserve">
          <source>When an Erlang process sends data to the port. The data arrives as a buffer of bytes, the interpretation is not defined, but is up to the implementor. This callback returns nothing to the caller, answers are sent to the caller as messages (using a routine called &lt;code&gt;driver_output&lt;/code&gt; available to all drivers). There is also a way to talk in a synchronous way to drivers, described below. There can be an additional callback function for handling data that is fragmented (sent in a deep io-list). That interface gets the data in a form suitable for Unix &lt;code&gt;writev&lt;/code&gt; rather than in a single buffer. There is no need for a distribution driver to implement such a callback, so we will not.</source>
          <target state="translated">当Erlang进程将数据发送到端口时。数据作为字节缓冲区到达，解释没有定义，但取决于实现者。该回调不向调用者返回任何内容，应答作为消息发送给调用者（使用所有驱动程序都可以使用的名为 &lt;code&gt;driver_output&lt;/code&gt; 的例程）。还有一种以同步方式与驱动程序对话的方法，如下所述。可以有一个附加的回调函数来处理零碎的数据（在深io-list中发送）。该接口以适合Unix &lt;code&gt;writev&lt;/code&gt; 的形式获取数据，而不是在单个缓冲区中。不需要分发驱动程序来实现这样的回调，因此我们不需要。</target>
        </trans-unit>
        <trans-unit id="fcd682219ed27952353a789f2a95e93eae1b95ef" translate="yes" xml:space="preserve">
          <source>When an Erlang runtime system is started, a number of processes are started as part of the Kernel application. One of these processes is the &lt;strong&gt;application controller&lt;/strong&gt; process, registered as &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">启动Erlang运行时系统时，作为内核应用程序的一部分，将启动许多进程。这些进程之一是注册为 &lt;code&gt;application_controller&lt;/code&gt; 的&lt;strong&gt;应用程序控制器&lt;/strong&gt;进程。</target>
        </trans-unit>
        <trans-unit id="1f6e9cd273f9f4e055a8524b92a57509f35b9cee" translate="yes" xml:space="preserve">
          <source>When an I/O server receives an &lt;code&gt;io_request&lt;/code&gt; tuple, it acts upon the &lt;code&gt;Request&lt;/code&gt; part and eventually sends an &lt;code&gt;io_reply&lt;/code&gt; tuple with the corresponding &lt;code&gt;Reply&lt;/code&gt; part.</source>
          <target state="translated">当I / O服务器接收到 &lt;code&gt;io_request&lt;/code&gt; 元组时，它将作用于 &lt;code&gt;Request&lt;/code&gt; 部分，并最终发送带有相应的 &lt;code&gt;Reply&lt;/code&gt; 部分的 &lt;code&gt;io_reply&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="c97830caeadaae0c71c4a6641f2b72ee5a3a4441" translate="yes" xml:space="preserve">
          <source>When an MIB is compiled, the compiler detects if several managed objects use the same &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. If that is the case, it issues an error message. However, the compiler cannot detect Oid conflicts between different MIBs. These kinds of conflicts generate an error at load time. To avoid this, the following function can be used to do consistency checking between MIBs:</source>
          <target state="translated">编译MIB时，编译器将检测多个托管对象是否使用相同的 &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; 。如果是这种情况，它将发出错误消息。但是，编译器无法检测到不同MIB之间的Oid冲突。这些冲突在加载时会产生错误。为了避免这种情况，可以使用以下函数在MIB之间进行一致性检查：</target>
        </trans-unit>
        <trans-unit id="db011fd2eddc67aaa683180ce280cb84fa7377af" translate="yes" xml:space="preserve">
          <source>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</source>
          <target state="translated">当TLS/DTLS套接字处于活动模式(默认)时,套接字的数据会以消息的形式传递给套接字的所有者。</target>
        </trans-unit>
        <trans-unit id="996325d55085b77e5910030169e95fa9280c37bb" translate="yes" xml:space="preserve">
          <source>When an accept sequence has been completed the acceptor process is expected to continue accepting further requests.</source>
          <target state="translated">当一个接受序列完成后,接受者过程将继续接受进一步的请求。</target>
        </trans-unit>
        <trans-unit id="75461cd7ae2ccbf7a584f95a468ce12ee8f87375" translate="yes" xml:space="preserve">
          <source>When an allocator instance needs more carrier space, it inspects the pool. If no carrier could be fetched from the pool, it will allocate a new carrier. Regardless of where the allocator instance gets the carrier from, it just links in the carrier into its data structure of free blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709fa60f17ba558cd057f2a6b62757eac692ee54" translate="yes" xml:space="preserve">
          <source>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</source>
          <target state="translated">当一个应用程序在多个节点上执行,并希望在远程进程被生成或向远程进程发送消息之前,确保在远程节点上执行更新。</target>
        </trans-unit>
        <trans-unit id="6c28abc5b0d379d3a8ba44dbcc2c9763e0be3b27" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on other nodes.</source>
          <target state="translated">当应用程序执行频繁或大量更新时，其他节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 可能会过载。</target>
        </trans-unit>
        <trans-unit id="a47a8128b591f9e03e1d7bb3a8b71505f2177f47" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on the nodes.</source>
          <target state="translated">当应用程序执行频繁或大量更新时，可能会使节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 过载。</target>
        </trans-unit>
        <trans-unit id="8091d18c34c7568e437ad61e1779d1db887806b5" translate="yes" xml:space="preserve">
          <source>When an event handler terminates abnormally, &lt;code&gt;gen_event&lt;/code&gt; logs &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">当事件处理程序异常终止时， &lt;code&gt;gen_event&lt;/code&gt; 记录 &lt;code&gt;Status&lt;/code&gt; 来代替事件处理程序的状态项。</target>
        </trans-unit>
        <trans-unit id="3b856ad79c467961efb9c09f4c8c68ce2f0ae4ff" translate="yes" xml:space="preserve">
          <source>When an event manager is stopped, it gives each of the installed event handlers the chance to clean up by calling &lt;code&gt;terminate/2&lt;/code&gt;, the same way as when deleting a handler.</source>
          <target state="translated">停止事件管理器后，它会通过调用 &lt;code&gt;terminate/2&lt;/code&gt; 来为每个已安装的事件处理程序提供清除的机会，这与删除处理程序时相同。</target>
        </trans-unit>
        <trans-unit id="a2f914353111b5a9e0f8ff47f4ec0a5a28de2e0a" translate="yes" xml:space="preserve">
          <source>When an executing port runs out of work to execute in the private task data structure, it moves the public task queue into the private task data structure while holding the lock. Once tasks has been moved to the private data structure no lock protects them. This way the port can continue working on tasks in the private data structure without having to fight for the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecb64233649623988df5a15e4320b8e35507f15" translate="yes" xml:space="preserve">
          <source>When an installed release is made permanent, the system process &lt;code&gt;init&lt;/code&gt; is set to point out the new &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">当已安装的发行版成为永久发行版时，系统进程 &lt;code&gt;init&lt;/code&gt; 设置为指出新的 &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00873013d7a25ee81fef530c37b0fd219bde2fd" translate="yes" xml:space="preserve">
          <source>When an integer-value is specified, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process never goes into hibernation.</source>
          <target state="translated">当指定整数值时， &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; 将在指定的非活动毫秒数后进入休眠状态，从而减少其内存占用量。如果指定了 &lt;code&gt;undefined&lt;/code&gt; （这是默认设置），则该过程永远不会进入休眠状态。</target>
        </trans-unit>
        <trans-unit id="bc796970d718582f543a7db2afb490e94eada2a5" translate="yes" xml:space="preserve">
          <source>When an unmanaged thread increment the &lt;code&gt;current&lt;/code&gt; counter it will not prevent the next increment of the global counter, but instead the increment after that. This is sufficient since the global counter needs to be incremented two times before thread progress has been made. It is also desirable not to prevent the first increment, since the likelihood increases that the delay is withdrawn before any increment of the global counter is delayed. That is, the operation will cause as little disruption as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd630c54a2a673edbcdeb121843359b4c127f6e0" translate="yes" xml:space="preserve">
          <source>When analysing code coverage, the result for &lt;code&gt;m1&lt;/code&gt; can be seen in the cover log in the &lt;code&gt;s1&lt;/code&gt; test result.</source>
          <target state="translated">分析代码覆盖率时，可以在 &lt;code&gt;s1&lt;/code&gt; 测试结果的覆盖日志中看到 &lt;code&gt;m1&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="89c824ef18f1155e6eb73bb5f1e6f145e288eb6a" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the &lt;code&gt;include_dir&lt;/code&gt; to Dialyzer. (**)</source>
          <target state="translated">从源进行分析时，将 &lt;code&gt;include_dir&lt;/code&gt; 传递给Dialyzer。（**）</target>
        </trans-unit>
        <trans-unit id="6d86eb0ccd83bcc9cd8e9fc364281c878af586ee" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the define to Dialyzer. (**)</source>
          <target state="translated">从源头分析时,将定义传递给Dialyzer。(**)</target>
        </trans-unit>
        <trans-unit id="ac42477caf4c3ea1c573d88619291bc09d0583f2" translate="yes" xml:space="preserve">
          <source>When analyzing from source, you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the &lt;code&gt;erlc&lt;/code&gt; flags &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-D&lt;/code&gt;). This can be done either by starting Dialyzer with these flags from the command line as in:</source>
          <target state="translated">从源进行分析时，您可能必须向Dialyzer提供包含目录和宏定义的列表（就像使用 &lt;code&gt;erlc&lt;/code&gt; 标志 &lt;code&gt;-I&lt;/code&gt; 和 &lt;code&gt;-D&lt;/code&gt; 一样）。可以通过在命令行中使用以下标志启动Dialyzer来完成此操作：</target>
        </trans-unit>
        <trans-unit id="658b2374a8aacc4b9e6927fe3e6096361c317c2b" translate="yes" xml:space="preserve">
          <source>When analyzing the result file from the profiling activity, look for functions that are called many times and have a long &quot;own&quot; execution time (time excluding calls to other functions). Functions that are called a lot of times can also be interesting, as even small things can add up to quite a bit if repeated often. Also ask yourself what you can do to reduce this time. The following are appropriate types of questions to ask yourself:</source>
          <target state="translated">在分析剖析活动的结果文件时,要寻找那些被多次调用且 &quot;自己 &quot;执行时间较长的函数(时间不包括对其他函数的调用)。被调用次数多的函数也很有意思,因为即使是小事,如果经常重复,也会增加不少时间。同时也要问自己如何才能减少这个时间。以下是适合问自己的问题类型。</target>
        </trans-unit>
        <trans-unit id="806459f8533827481672dc572cf1bf7921931e0f" translate="yes" xml:space="preserve">
          <source>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</source>
          <target state="translated">当对二进制进行如下追加时,只有最近一次追加操作返回的二进制才支持进一步的廉价追加操作。</target>
        </trans-unit>
        <trans-unit id="a512d102468fee77b47b8323833438033b394ad0" translate="yes" xml:space="preserve">
          <source>When atoms or other terms that fit in one machine word are deleted, no global GC is needed. Therefore, persistent terms that have atoms as their values can be updated more frequently, but note that updating such persistent terms is still much more expensive than reading them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228cd4e5a8bc6e5b7fee2e6123af719e572f533e" translate="yes" xml:space="preserve">
          <source>When building in a Git working directory you also have to have a GNU &lt;code&gt;autoconf&lt;/code&gt; of at least version 2.59 on your system, because you need to generate the &lt;code&gt;configure&lt;/code&gt; scripts before you can start building.</source>
          <target state="translated">在Git工作目录中进行构建时，您还必须在系统上至少具有2.59版本的GNU &lt;code&gt;autoconf&lt;/code&gt; ，因为在开始构建之前，需要生成 &lt;code&gt;configure&lt;/code&gt; 脚本。</target>
        </trans-unit>
        <trans-unit id="eaf8c1d8b7925ac8c617463eca8b72a76f666d34" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-21.0 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">构建文档时，您需要在 &lt;code&gt;$PATH&lt;/code&gt; 使用完整的Erlang / OTP-21.0系统。</target>
        </trans-unit>
        <trans-unit id="c0cffe21bf826ba6055606784d159ee73a759d5c" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-23.2 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23b671fd08513b7a0eaff9f50d4ae1fef0eb3dc" translate="yes" xml:space="preserve">
          <source>When called &lt;code&gt;addr&lt;/code&gt; points to an address structure of lenght &lt;code&gt;len&lt;/code&gt; containing information on where to connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fe5c4adb0aba58b536194f949a24424424eac9" translate="yes" xml:space="preserve">
          <source>When called &lt;code&gt;buf&lt;/code&gt; points to a buffer of length &lt;code&gt;*len&lt;/code&gt; containing the data to write on the socket. On success, this callback should set &lt;code&gt;*len&lt;/code&gt; to the amount of bytes successfully written on the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90530c4b0ae5b8364ccb16ac3ef25111d36b377f" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">当调用参数 &lt;code&gt;read&lt;/code&gt; ，功能 &lt;code&gt;InitFun&lt;/code&gt; 假设返回 &lt;code&gt;end_of_input&lt;/code&gt; 时，有没有更多的投入，或 &lt;code&gt;{Objects, Fun}&lt;/code&gt; ，其中 &lt;code&gt;Objects&lt;/code&gt; 是对象的列表和 &lt;code&gt;Fun&lt;/code&gt; 是一种新的输入功能。其他任何值 &lt;code&gt;Value&lt;/code&gt; 将作为错误 &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; 。每个输入函数仅被调用一次，如果发生错误，将使用参数 &lt;code&gt;close&lt;/code&gt; 调用最后一个函数，忽略其答复。</target>
        </trans-unit>
        <trans-unit id="07cb85581936567b82cbd8ae581b4c6171786cd2" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, the function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occur, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">当调用参数 &lt;code&gt;read&lt;/code&gt; ，功能 &lt;code&gt;InitFun&lt;/code&gt; 假定回报 &lt;code&gt;end_of_input&lt;/code&gt; 时，有没有更多的投入，或 &lt;code&gt;{Objects, Fun}&lt;/code&gt; ，其中 &lt;code&gt;Objects&lt;/code&gt; 是对象的列表和 &lt;code&gt;Fun&lt;/code&gt; 是一种新的输入功能。其他任何值 &lt;code&gt;Value&lt;/code&gt; 将作为错误 &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; 。每个输入函数仅被调用一次，如果发生错误，将使用参数 &lt;code&gt;close&lt;/code&gt; 调用最后一个函数，忽略其答复。</target>
        </trans-unit>
        <trans-unit id="364ba2a27b870da0b99015d17a3a2b5626ba1eeb" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;undefined&lt;/code&gt;, all system performance monitoring settings are cleared.</source>
          <target state="translated">当使用参数 &lt;code&gt;undefined&lt;/code&gt; 调用时，将清除所有系统性能监视设置。</target>
        </trans-unit>
        <trans-unit id="b44f8219d85b31453de272e6169e5dfa4f9585c9" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;qlc:q/1,2&lt;/code&gt; from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. This is also true when expressions are evaluated by &lt;code&gt;file:eval/1,2&lt;/code&gt; or in the debugger.</source>
          <target state="translated">从Erlang Shell 调用 &lt;code&gt;qlc:q/1,2&lt;/code&gt; 时，将自动调用解析转换。发生这种情况时，不会编译替代QLC的功能，而是由 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; 进行评估。当通过 &lt;code&gt;file:eval/1,2&lt;/code&gt; 或在调试器中对表达式求值时，也是如此。</target>
        </trans-unit>
        <trans-unit id="0142d7dfddbd655a17b503f022ba1db92cd0ecd9" translate="yes" xml:space="preserve">
          <source>When calling BIFs that accept deep lists, such as &lt;code&gt;list_to_binary/1&lt;/code&gt; or &lt;code&gt;iolist_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">调用接受深列表的 &lt;code&gt;list_to_binary/1&lt;/code&gt; ，例如list_to_binary / 1或 &lt;code&gt;iolist_to_binary/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="814de6a52bbcc04dc1b80c48dfb06eef572da2a6" translate="yes" xml:space="preserve">
          <source>When calling a function, the return address is first stored in &lt;code&gt;E[0]&lt;/code&gt; (using the &lt;code&gt;$SAVE_CONTINUATION_POINTER()&lt;/code&gt; macro), and then control is transferred to the callee. Here is the generated code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c494144b9a22a3f981a6afcba77050a11fcf18" translate="yes" xml:space="preserve">
          <source>When calling this function, &lt;code&gt;iovec&lt;/code&gt; should contain a pointer to &lt;code&gt;NULL&lt;/code&gt; or a ErlNifIOVec structure that should be used if possible. e.g.</source>
          <target state="translated">调用此函数时， &lt;code&gt;iovec&lt;/code&gt; 应包含一个指向 &lt;code&gt;NULL&lt;/code&gt; 的指针或一个ErlNifIOVec结构（如果可能），应使用该结构。例如</target>
        </trans-unit>
        <trans-unit id="865c3803d266e89c17825224f1f9b63a82983678" translate="yes" xml:space="preserve">
          <source>When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless &lt;code&gt;[aeiou]&lt;/code&gt; matches &quot;A&quot; and &quot;a&quot;, and a caseless &lt;code&gt;[^aeiou]&lt;/code&gt; does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &amp;lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &amp;gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support.</source>
          <target state="translated">设置无大小写匹配时，类中的任何字母均代表其大写和小写形式。例如，一个无外壳的 &lt;code&gt;[aeiou]&lt;/code&gt; 匹配&amp;ldquo; A&amp;rdquo;和&amp;ldquo; a&amp;rdquo;，一个无外壳的 &lt;code&gt;[^aeiou]&lt;/code&gt; 不匹配&amp;ldquo; A&amp;rdquo;，但是一个有外壳的版本会匹配。在UTF模式下，PCRE始终了解值小于256的字符的大小写概念，因此始终可以进行无大小写匹配。对于具有较高值的​​字符，仅当使用Unicode属性支持编译PCRE时，才支持大小写概念。如果要在字符&amp;gt; =的UTF模式下使用无大小写的匹配，请确保已使用Unicode属性支持和UTF支持来编译PCRE。</target>
        </trans-unit>
        <trans-unit id="1fa07acc11a720ed656be365e748b1e786d781a3" translate="yes" xml:space="preserve">
          <source>When caseless matching is specified (option &lt;code&gt;caseless&lt;/code&gt;), letters are matched independently of case.</source>
          <target state="translated">如果指定了不区分大小写的匹配（选项 &lt;code&gt;caseless&lt;/code&gt; ），则字母的匹配与大小写无关。</target>
        </trans-unit>
        <trans-unit id="37ae8050f70165954f23ba0ebf3fbda68196592f" translate="yes" xml:space="preserve">
          <source>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</source>
          <target state="translated">当改变这个标志时,消息将被移动。当这个函数调用返回时,这项工作已经开始但还没有完成。</target>
        </trans-unit>
        <trans-unit id="1c283832835fc69a63d88192d48cfa2b0fe0ad55" translate="yes" xml:space="preserve">
          <source>When changing to state &lt;code&gt;open&lt;/code&gt;, the collected buttons are reset, the lock unlocked, and a state timer for 10 s is started.</source>
          <target state="translated">当更改为 &lt;code&gt;open&lt;/code&gt; 时，将重置收集的按钮，解锁锁，并启动10秒钟的状态计时器。</target>
        </trans-unit>
        <trans-unit id="44d2f7b0ec39f0b334cd93ff69fd7523f8653774" translate="yes" xml:space="preserve">
          <source>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of &lt;code&gt;=:=&lt;/code&gt; or &lt;code&gt;=/=&lt;/code&gt;. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</source>
          <target state="translated">将整数与浮点数进行比较时，除非运算符为 &lt;code&gt;=:=&lt;/code&gt; 或 &lt;code&gt;=/=&lt;/code&gt; 之一，否则精度较低的项将转换为另一项的类型。浮点数比整数更精确，直到浮点数的所有有效数字都在小数点的左侧为止。当浮点数大于/小于+/- 9007199254740992.0时，就会发生这种情况。转换策略根据浮点数的大小而改变，因为否则比较大的浮点数和整数将失去其可传递性。</target>
        </trans-unit>
        <trans-unit id="057fdbcf9c89dcfcef51fc5e8e497f10a792cf05" translate="yes" xml:space="preserve">
          <source>When comparing external sets, operator &lt;code&gt;==/2&lt;/code&gt; is used.</source>
          <target state="translated">比较外部集时，使用运算符 &lt;code&gt;==/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fc0d77de42806fcc3f093559352b14f83658b4e" translate="yes" xml:space="preserve">
          <source>When comparing two version numbers that have an order, one compare each part as ordinary integers from the most significant part to less significant parts. The order is defined by the first parts of the same significance that differ. An OTP version with a larger version includes all changes that are part of a smaller OTP version. The same goes for application versions.</source>
          <target state="translated">当比较两个有顺序的版本号时,将每个部分作为普通整数,从最重要的部分到不太重要的部分进行比较。顺序是由相同意义的第一部分不同的部分来定义的。一个大版本的OTP版本包括了小版本OTP的所有变化。应用版本也是如此。</target>
        </trans-unit>
        <trans-unit id="652b52bac7a7e326263b30fa8ceb237c7bcb235a" translate="yes" xml:space="preserve">
          <source>When comparing with a locked approach, at least one heavy weight memory barrier will be issued when locking the lock on most, if not all, hardware architectures (including x86/x86_64), and often some kind of light weight memory barrier will be issued when unlocking the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7045558361dff4148b294c98385164fc4d95e222" translate="yes" xml:space="preserve">
          <source>When compilation is involved, exception &lt;code&gt;badarg&lt;/code&gt; is thrown if a compilation error occurs. Call &lt;code&gt;compile/2&lt;/code&gt; to get information about the location of the error in the regular expression.</source>
          <target state="translated">涉及编译时，如果发生编译错误，则会引发异常 &lt;code&gt;badarg&lt;/code&gt; 。调用 &lt;code&gt;compile/2&lt;/code&gt; 以获取有关正则表达式中错误位置的信息。</target>
        </trans-unit>
        <trans-unit id="70f94aaa056c45f783cd020ccfb0c871d028ac6c" translate="yes" xml:space="preserve">
          <source>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</source>
          <target state="translated">当连接被破坏时(由megaco:disconnect/2显式地破坏或当它的控制进程死亡时),一个用户回调函数被调用,以允许用户重新建立连接。保留的消息、重发计时器等内部状态不受此影响。当然,在连接中断的时候,少数重发会失败,但自动重发算法并不会为此而烦恼,如果超时时间设置得足够长,最终当连接启动并运行时,消息就会被送达。用户可以选择显式调用megaco:cancel/2来取消一个连接的所有消息。</target>
        </trans-unit>
        <trans-unit id="eee80008193ca8beab002b82928ea575e05d44fd" translate="yes" xml:space="preserve">
          <source>When constructing a segment of a &lt;code&gt;utf&lt;/code&gt; type, &lt;code&gt;Value&lt;/code&gt; must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;Value&lt;/code&gt; is outside the allowed ranges. The size of the resulting binary segment depends on the type or &lt;code&gt;Value&lt;/code&gt;, or both:</source>
          <target state="translated">构造 &lt;code&gt;utf&lt;/code&gt; 类型的段时， &lt;code&gt;Value&lt;/code&gt; 必须是0..16＃D7FF或16＃E000 .... 16＃10FFFF范围内的整数。如果 &lt;code&gt;Value&lt;/code&gt; 超出允许范围，则构造将失败并出现 &lt;code&gt;badarg&lt;/code&gt; 异常。生成的二进制段的大小取决于类型或 &lt;code&gt;Value&lt;/code&gt; ，或两者都取决于：</target>
        </trans-unit>
        <trans-unit id="2dfba87ba5340bf590a9719ae92123f1780ed535" translate="yes" xml:space="preserve">
          <source>When constructing binaries, &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; can be any Erlang expression. However, for syntactical reasons, both &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</source>
          <target state="translated">构造二进制文件时， &lt;code&gt;Value&lt;/code&gt; 和 &lt;code&gt;Size&lt;/code&gt; 可以是任何Erlang表达式。但是，出于语法原因，如果表达式包含的内容不止单个文字或变量，则必须在括号中同时包含&amp;ldquo; &lt;code&gt;Value&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Size&lt;/code&gt; 。以下给出了编译器语法错误：</target>
        </trans-unit>
        <trans-unit id="a4d4be88f085f6842045d6bb85ffd60f1c5e2495" translate="yes" xml:space="preserve">
          <source>When constructing binaries, if the size &lt;code&gt;N&lt;/code&gt; of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the &lt;code&gt;N&lt;/code&gt; least significant bits are put into the binary.</source>
          <target state="translated">在构造二进制文件时，如果整数段的大小 &lt;code&gt;N&lt;/code&gt; 太小而无法包含给定的整数，则将整数的最高有效位静默丢弃，并且仅将 &lt;code&gt;N&lt;/code&gt; 个最低有效位放入二进制文件中。</target>
        </trans-unit>
        <trans-unit id="ed7c4511bca13fde6765438ddbde809cac5d3478" translate="yes" xml:space="preserve">
          <source>When constructing, a literal string can be given followed by one of the UTF types, for example: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; which is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">构造时，可以给出文字字符串，然后是UTF类型之一，例如： &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; ，它是 &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt; 语法糖&amp;gt;&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="14ed84f016fc083dab3c16b2cd6e8fe5dee14cdb" translate="yes" xml:space="preserve">
          <source>When creating a record to be used in a select/match operation, you want most of the fields to have the value &quot;_&quot;. The easiest and fastest way to do that is as follows:</source>
          <target state="translated">当创建一条记录用于选择/匹配操作时,你希望大部分字段的值为&quot;_&quot;。最简单快捷的方法如下。</target>
        </trans-unit>
        <trans-unit id="0be878ceb74375986a99208578a50205223bc154" translate="yes" xml:space="preserve">
          <source>When creating a system using Erlang/OTP, the simplest way is to install Erlang/OTP somewhere, install the application-specific code somewhere else, and then start the Erlang runtime system, making sure the code path includes the application-specific code.</source>
          <target state="translated">在使用Erlang/OTP创建系统时,最简单的方法是在某处安装Erlang/OTP,在其他地方安装特定应用的代码,然后启动Erlang运行时系统,确保代码路径包含特定应用的代码。</target>
        </trans-unit>
        <trans-unit id="f9a48110445b8b431b0a819b4efed940d95979f9" translate="yes" xml:space="preserve">
          <source>When creating test suites, it is strongly recommended to not create dependencies between test cases, that is, letting test cases depend on the result of previous test cases. There are various reasons for this, such as, the following:</source>
          <target state="translated">在创建测试套件时,强烈建议不要在测试用例之间建立依赖关系,即让测试用例依赖于之前测试用例的结果。原因有很多,比如,以下几点。</target>
        </trans-unit>
        <trans-unit id="26cf28e2e1bf20fe1af4eb848b0d0a7d334f0f8b" translate="yes" xml:space="preserve">
          <source>When debugging a process with the functions of this module, the process generates &lt;strong&gt;system_events&lt;/strong&gt;, which are then treated in the debug function. For example, &lt;code&gt;trace&lt;/code&gt; formats the system events to the terminal.</source>
          <target state="translated">使用此模块的功能调试进程时，该进程会生成&lt;strong&gt;system_events&lt;/strong&gt;，然后在debug函数中对其进行处理。例如， &lt;code&gt;trace&lt;/code&gt; 将系统事件格式化为终端。</target>
        </trans-unit>
        <trans-unit id="f636b27b7770791a083db3563a557efb2923ba0e" translate="yes" xml:space="preserve">
          <source>When decoding &lt;code&gt;property_group()&lt;/code&gt; or &lt;code&gt;property_groups()&lt;/code&gt;, those property parameter constructs that cannot be decoded (either because of decode error or because they are unknown), will be returned as a two-tuple. The first element of which will be the (undecoded) property parameter and the other the actual reason. This means that the caller of this function has to expect not only sdp-records, but also this two-tuple construct.</source>
          <target state="translated">解码 &lt;code&gt;property_group()&lt;/code&gt; 或 &lt;code&gt;property_groups()&lt;/code&gt; 时，那些无法解码的属性参数构造（由于解码错误或因为它们未知）将作为两个元组返回。其第一个元素将是（未编码）属性参数，另一个是实际原因。这意味着此函数的调用者不仅必须期望sdp记录，而且还必须期望这个二元组构造。</target>
        </trans-unit>
        <trans-unit id="17f3e727c9b04040e7e330882d55b9758d892ab6" translate="yes" xml:space="preserve">
          <source>When decoding a type that uses an extensible set constraint, it is always possible that the value in field &lt;code&gt;UNIQUE&lt;/code&gt; is unknown (that is, the type has been encoded with a later version of the ASN.1 specification). The unencoded data is then returned wrapped in a tuple as follows:</source>
          <target state="translated">解码使用可扩展集约束的类型时，始终有可能字段 &lt;code&gt;UNIQUE&lt;/code&gt; 中的值是未知的（也就是说，该类型已使用ASN.1规范的更高版本进行编码）。然后将未编码的数据包装成元组返回，如下所示：</target>
        </trans-unit>
        <trans-unit id="15c1a9e3a07dbc42bbebe73b1a8cb57a2a65f591" translate="yes" xml:space="preserve">
          <source>When decoding binaries from untrusted sources, consider using &lt;code&gt;binary_to_term/2&lt;/code&gt; to prevent Denial of Service attacks.</source>
          <target state="translated">从不受信任的来源解码二进制文件时，请考虑使用 &lt;code&gt;binary_to_term/2&lt;/code&gt; 来防止&amp;ldquo;拒绝服务&amp;rdquo;攻击。</target>
        </trans-unit>
        <trans-unit id="d0e0e586b31755d07f5d7b42305304a2d4527232" translate="yes" xml:space="preserve">
          <source>When decoding, optional fields will be omitted from the map:</source>
          <target state="translated">解码时,地图中的可选字段将被省略。</target>
        </trans-unit>
        <trans-unit id="e2aad35acaab6959e7cb6145c3615cfd817ae41a" translate="yes" xml:space="preserve">
          <source>When describing a set of functions (that is, a module, a part of a module, or an application), executing in a process and wanting to use a ddll-driver, we use the term &lt;strong&gt;user&lt;/strong&gt;. A process can have many users (different modules needing the same driver) and many processes running the same code, making up many &lt;strong&gt;users&lt;/strong&gt; of a driver.</source>
          <target state="translated">当描述一组功能（即模块，模块的一部分或应用程序），在进程中执行并希望使用ddll驱动程序时，我们使用术语&lt;strong&gt;user&lt;/strong&gt;。一个进程可以有许多用户（不同的模块需要相同的驱动程序）和许多运行同一代码的进程，从而构成一个驱动程序的许多&lt;strong&gt;用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="37ad55aab42043a1210e11879b193d589f2174c4" translate="yes" xml:space="preserve">
          <source>When determining which run queue to choose we need to read the fixed balancing information that we moved out of the run queues. This information is global, read only between load balancing operations, but will be changed during a load balancing. We do not want to introduce a global lock that needs to be acquired when accessing this information. A reader optimized rwlock could avoid some of the overhead since the data is most frequently read, but it would unavoidably cause disruption during load balancing, since this information is very frequently read. The likelihood of a large disruption due to this also increase as number of schedulers grows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d599e465efb7551b80d5232a1bfe503d0d783500" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="translated">使用Erlang / OTP进行开发时，通常会从交互式shell（请参见&lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Erlang入门&lt;/a&gt;）中测试程序，在其中可以调用各个函数。还有许多工具可用，例如图形&lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;调试器&lt;/a&gt;和用于查看系统信息，ets和mnesia表等的&lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;观察者工具&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="421fcf6b7523386346f2d7d3a8c1e4d4d970c3ce" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-5.0/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.9.5/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf2dfb99c11e0b6eebdf245aebada381fb9ab39" translate="yes" xml:space="preserve">
          <source>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option &lt;code&gt;local&lt;/code&gt; and global tracing with option &lt;code&gt;global&lt;/code&gt; (or no option), and so on.</source>
          <target state="translated">禁用跟踪时，该选项必须与功能上设置的跟踪类型匹配。也就是说，必须使用选项 &lt;code&gt;local&lt;/code&gt; 和global跟踪（选项为 &lt;code&gt;global&lt;/code&gt; （或不使用选项））禁用本地跟踪，依此类推。</target>
        </trans-unit>
        <trans-unit id="8e262a7b92cfd57af3c5fc673b211db44e0d61d2" translate="yes" xml:space="preserve">
          <source>When doing &lt;code&gt;make install&lt;/code&gt; and the default installation prefix is used, relative symbolic links will be created from &lt;code&gt;/usr/local/bin&lt;/code&gt; to all public Erlang/OTP executables in &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt;. The installation phase will try to create relative symbolic links as long as &lt;code&gt;--bindir&lt;/code&gt; and the Erlang bin directory, located under &lt;code&gt;--libdir&lt;/code&gt;, both have &lt;code&gt;--exec-prefix&lt;/code&gt; as prefix. Where &lt;code&gt;--exec-prefix&lt;/code&gt; defaults to &lt;code&gt;--prefix&lt;/code&gt;. &lt;code&gt;--prefix&lt;/code&gt;, &lt;code&gt;--exec-prefix&lt;/code&gt;, &lt;code&gt;--bindir&lt;/code&gt;, and &lt;code&gt;--libdir&lt;/code&gt; are all arguments that can be passed to &lt;code&gt;configure&lt;/code&gt;. One can force relative, or absolute links by passing &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; as arguments to &lt;code&gt;make&lt;/code&gt; during the install phase. Note that such a request might cause a failure if the request cannot be satisfied.</source>
          <target state="translated">在进行 &lt;code&gt;make install&lt;/code&gt; 并使用默认的安装前缀时，将从 &lt;code&gt;/usr/local/bin&lt;/code&gt; 创建到 &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt; 中所有公共Erlang / OTP可执行文件的相对符号链接。只要 &lt;code&gt;--bindir&lt;/code&gt; 和位于 &lt;code&gt;--libdir&lt;/code&gt; 下的Erlang bin目录都以 &lt;code&gt;--exec-prefix&lt;/code&gt; 作为前缀，安装阶段将尝试创建相对的符号链接。其中 &lt;code&gt;--exec-prefix&lt;/code&gt; 默认为 &lt;code&gt;--prefix&lt;/code&gt; 。 &lt;code&gt;--prefix&lt;/code&gt; ， &lt;code&gt;--exec-prefix&lt;/code&gt; &lt;code&gt;--bindir&lt;/code&gt; -prefix，-- bindir和 &lt;code&gt;--libdir&lt;/code&gt; 都是可以传递给 &lt;code&gt;configure&lt;/code&gt; 。一个可以强制通过传递相对的，或绝对链接 &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; 作为参数来 &lt;code&gt;make&lt;/code&gt; 在安装阶段。请注意，如果无法满足该请求，则可能会导致失败。</target>
        </trans-unit>
        <trans-unit id="a2786f78387349e137e785c359068f69a038e2e9" translate="yes" xml:space="preserve">
          <source>When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file.</source>
          <target state="translated">转储表时,关于表的一些信息会转储到转储开始时的表头。这些信息包含有关表类型、名称、保护、大小、版本以及是否是命名表的数据。它还包含关于向文件添加哪些扩展信息的说明,这些信息可以是文件中对象的数量,也可以是文件中头和记录的MD5和。</target>
        </trans-unit>
        <trans-unit id="8bb8dc80e08844ad0426660bafbab7a03b0891ac" translate="yes" xml:space="preserve">
          <source>When editing normal text in text mode you can let Emacs reformat the text by the &lt;code&gt;fill-paragraph&lt;/code&gt; command. This command will not work for comments since it will treat the comment characters as words.</source>
          <target state="translated">在文本模式下编辑普通文本时，可以让Emacs通过 &lt;code&gt;fill-paragraph&lt;/code&gt; 命令重新格式化文本。此命令不适用于注释，因为它将注释字符视为单词。</target>
        </trans-unit>
        <trans-unit id="a631e39dc1cabb5e02c4412996c54930451ee0dc" translate="yes" xml:space="preserve">
          <source>When elements are continuously inserted by threads not owning the allocator instance, the thread owning the allocator instance will be able to work more or less undisturbed by other threads at the head end of the list. At the tail end large amounts of simultaneous inserts may cause contention, but we reduce such contention by spreading inserts of new elements near the end instead of requiring all new elements to be inserted at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385563ac3b6af3039b39f79f5505ddf536cbbbf9" translate="yes" xml:space="preserve">
          <source>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a &lt;code&gt;badarg&lt;/code&gt; error.</source>
          <target state="translated">启用后，它将阻止解码可用于攻击Erlang系统的数据。如果接收到不安全的数据，解码将失败，并出现 &lt;code&gt;badarg&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="7e911575fa07d922476972d70c313e02f9b293dc" translate="yes" xml:space="preserve">
          <source>When enabling an &lt;code&gt;Item&lt;/code&gt; that represents a group of processes, the &lt;code&gt;Item&lt;/code&gt; is enabled on all nodes added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">当使能的 &lt;code&gt;Item&lt;/code&gt; 表示一组的过程中， &lt;code&gt;Item&lt;/code&gt; 与所添加的所有节点上使能 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="961f18823d723f8de73592aaed24463820242f21" translate="yes" xml:space="preserve">
          <source>When encoding action requests for one transaction, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When encoding action requests for several transactions, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">对一个事务的动作请求进行编码时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;action_reqs()&lt;/code&gt; 。对多个事务的操作请求进行编码时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;[action_reqs()]&lt;/code&gt; 。列表的每个元素都是一个事务的一部分。</target>
        </trans-unit>
        <trans-unit id="c3e08a1905a5b3e0dc65abec6d55dd6312a7226f" translate="yes" xml:space="preserve">
          <source>When evaluating a digit map, a state machine waits for timeouts and letters reported by megaco:report_digit_event/2. The length of the various timeouts are defined in the digit_map_value() record.</source>
          <target state="translated">当评估一个数字图时,状态机会等待由megaco:report_digit_event/2报告的超时和信。各种超时的长度在digit_map_value()记录中定义。</target>
        </trans-unit>
        <trans-unit id="bd3c6596324fcf3c283be7c0b3555d1b46a28bd6" translate="yes" xml:space="preserve">
          <source>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</source>
          <target state="translated">在评估一个表达式时,优先级最高的运算符会被首先评估。具有相同优先级的运算符根据其关联性进行评估。</target>
        </trans-unit>
        <trans-unit id="1250bb19a7c4cde6aa87a09dc8b61c235001dd61" translate="yes" xml:space="preserve">
          <source>When executing in an emulator thread, it is &lt;strong&gt;very important&lt;/strong&gt; that you unlock &lt;strong&gt;all&lt;/strong&gt; locks you have locked before letting the thread out of your control; otherwise you are &lt;strong&gt;very likely&lt;/strong&gt; to deadlock the whole emulator.</source>
          <target state="translated">在仿真器线程中执行时，在使线程脱离控件之前，先解锁&lt;strong&gt;所有&lt;/strong&gt;已锁定的锁，这一点&lt;strong&gt;非常重要&lt;/strong&gt;。否则，您&lt;strong&gt;很有可能&lt;/strong&gt;使整个模拟器陷入僵局。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d063e02c2be3b7faac0250e13934a29e88d4cb4" translate="yes" xml:space="preserve">
          <source>When executing the &lt;code&gt;etop&lt;/code&gt; script, configuration parameters can be specified as command-line options, for example, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt;. The following configuration parameters exist for the tool:</source>
          <target state="translated">执行 &lt;code&gt;etop&lt;/code&gt; 脚本时，可以将配置参数指定为命令行选项，例如 &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt; 。该工具存在以下配置参数：</target>
        </trans-unit>
        <trans-unit id="9eb714d64a16860edb9466fdec5e16164e92007d" translate="yes" xml:space="preserve">
          <source>When executing within a CTH, all timetraps are shut off. So if your CTH never returns, the entire test run is stalled.</source>
          <target state="translated">当在CTH内执行时,所有的时间跟踪都会被关闭。因此,如果您的CTH再也没有返回,整个测试运行就会停滞。</target>
        </trans-unit>
        <trans-unit id="da9d0d440af4853f4323fd874ba74d7e15beec93" translate="yes" xml:space="preserve">
          <source>When expanding macros, &lt;strong&gt;beam_makeops&lt;/strong&gt; wraps the expansion in a &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; wrapper unless &lt;strong&gt;beam_makeops&lt;/strong&gt; can clearly see that no wrapper is needed. In this case, the wrapper is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407f5e1130fa4448aafc45d4cd243aed3adf7a96" translate="yes" xml:space="preserve">
          <source>When failing, all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">失败时，所有三个函数都将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为以下之一：</target>
        </trans-unit>
        <trans-unit id="400a4d66676f58ccbe4f8fa4a7575a4ce987604e" translate="yes" xml:space="preserve">
          <source>When fetching a carrier from the pool, employment may change and further deallocations in the carrier will be redirected to the new employer using the delayed dealloc functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b47ee65ea9b082b925d4c051f321ad5844fe95" translate="yes" xml:space="preserve">
          <source>When fragments are added or deleted, &lt;code&gt;Mnesia&lt;/code&gt; automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field &lt;code&gt;Attr&lt;/code&gt; is used. This feature makes it possible to colocate records automatically in different tables to the same node. &lt;code&gt;foreign_key&lt;/code&gt; defaults to &lt;code&gt;undefined&lt;/code&gt;. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</source>
          <target state="translated">添加或删除片段时， &lt;code&gt;Mnesia&lt;/code&gt; 会自动将操作传播到所有具有引用此表的外键的片段表。而不是使用记录键来确定要访问哪个片段，而是使用字段 &lt;code&gt;Attr&lt;/code&gt; 的值。此功能使将不同表中的记录自动并置到同一节点成为可能。 &lt;code&gt;foreign_key&lt;/code&gt; 默认为 &lt;code&gt;undefined&lt;/code&gt; 。但是，如果外键设置为其他值，则它将导致其他碎片属性的默认值与外表的实际碎片属性的值相同。</target>
        </trans-unit>
        <trans-unit id="fd8c83393a4a4d4f9084b92af713908505d82502" translate="yes" xml:space="preserve">
          <source>When garbage collecting a heap (young or old) all literals are left in place and not copied. To figure out if a term should be copied or not when doing a garbage collection the following pseudo code is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f980f252538f0da8f8c81fee6306212deb2e4" translate="yes" xml:space="preserve">
          <source>When generating the &lt;code&gt;relup&lt;/code&gt; file, &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures that there is only one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and that it is the last instruction in the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">生成 &lt;code&gt;relup&lt;/code&gt; 文件时， &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 确保只有一个 &lt;code&gt;restart_emulator&lt;/code&gt; 指令，并且它是 &lt;code&gt;relup&lt;/code&gt; 文件中的最后一条指令。</target>
        </trans-unit>
        <trans-unit id="80c099bc81dcbffa43792d0bf735abab5b902a73" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;code&gt;ssh&lt;/code&gt; subsystem for daemons, use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Replaces ssh_daemon_channel) instead.</source>
          <target state="translated">为守护程序实现 &lt;code&gt;ssh&lt;/code&gt; 子系统时，请使用 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; （代替ssh_daemon_channel）。</target>
        </trans-unit>
        <trans-unit id="f6478258292a96422b7f4fde5f2a8507d5b2f75a" translate="yes" xml:space="preserve">
          <source>When implementing a client subsystem handler, use &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">在实现客户 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; 系统处理程序时，请改用-behaviour（ssh_client_channel）。</target>
        </trans-unit>
        <trans-unit id="9c88931238cddc153c190e4becfbe016ac63c629" translate="yes" xml:space="preserve">
          <source>When implementing this there are a couple of important properties that we either need, or want to preserve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0817fdff736a7fb006dde9156f2e254a826ee1a2" translate="yes" xml:space="preserve">
          <source>When importing MIBs, ensure that the imported MIBs as well as the importing MIB are compiled using the same version of the SNMP-compiler.</source>
          <target state="translated">导入MIB时,请确保导入的MIB和导入的MIB使用相同版本的SNMP-编译器进行编译。</target>
        </trans-unit>
        <trans-unit id="f3533c679bf3bb0ac2f26fbc98c32fe5665f503a" translate="yes" xml:space="preserve">
          <source>When information is received. This is typically when a received message is matched out in a receive expression, but also when information is received in other ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d86af8d65c195f9b07f8aefb0aff8be5ef9554d" translate="yes" xml:space="preserve">
          <source>When inputting data using sql_query/[2,3] the values will always be in string format as they are part of an SQL-query. Example:</source>
          <target state="translated">当使用sql_query/[2,3]输入数据时,由于这些值是SQL查询的一部分,所以总是以字符串格式输入。例如:当使用sql_query/[2,3]输入数据时,由于是SQL查询的一部分,所以数据总是以字符串格式输入。</target>
        </trans-unit>
        <trans-unit id="e9d487ff83b4df8e77a1b3e23e8b5d610747cfbb" translate="yes" xml:space="preserve">
          <source>When inserting a new element we search for a place to insert the element by only following &lt;code&gt;next&lt;/code&gt; pointers, and we always begin by skipping the first element encountered. When trying to fetch an element we do the same thing, but instead only follow &lt;code&gt;prev&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7655025ad787fb06a2ece92051383c668f2e0772" translate="yes" xml:space="preserve">
          <source>When inserting an element one will try to write a pointer to the new element in the next pointer of the element pointed to by the last pointer. This is done using an atomic compare and swap that expects the next pointer to be &lt;code&gt;NULL&lt;/code&gt;. If this succeeds the thread performing this operation moves the last pointer to point to the newly inserted element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a61084660618420bf57899c1e143bbdfd319d4" translate="yes" xml:space="preserve">
          <source>When installing a release, the application specifications are automatically updated before evaluating the &lt;code&gt;relup&lt;/code&gt; script. Thus, no instructions are needed in the &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">安装发行版时，在评估 &lt;code&gt;relup&lt;/code&gt; 脚本之前，将自动更新应用程序规范。因此， &lt;code&gt;.appup&lt;/code&gt; 文件中不需要任何指令：</target>
        </trans-unit>
        <trans-unit id="ab36faf918b13f9650566e7cda312d53b2b058cb" translate="yes" xml:space="preserve">
          <source>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</source>
          <target state="translated">启用仿真器的仪器化后,仿真器会使用更多的内存,运行速度更慢。</target>
        </trans-unit>
        <trans-unit id="613cb49badd27e8334ffae06e691a346b0c3156f" translate="yes" xml:space="preserve">
          <source>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given the following:</source>
          <target state="translated">当解释一个过程的数据时,知道匿名函数对象(funs)被赋予以下内容是很有帮助的。</target>
        </trans-unit>
        <trans-unit id="a7a1e6f2364e14a4f8731ff03ef081c6c153b8e5" translate="yes" xml:space="preserve">
          <source>When it comes to pure encode/decode performance, it turns out that:</source>
          <target state="translated">当谈到纯编码/解码性能时,事实证明。</target>
        </trans-unit>
        <trans-unit id="fdb9a1b728613db78be0dae343529296127017c3" translate="yes" xml:space="preserve">
          <source>When it is guaranteed that all trace messages are delivered to the tracer up to the point that &lt;code&gt;Tracee&lt;/code&gt; reached at the time of the call to &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;, then a &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; message is sent to the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</source>
          <target state="translated">当保证了所有跟踪消息被传递到示踪剂到如此地步， &lt;code&gt;Tracee&lt;/code&gt; 在调用的时间达到 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; ，则 &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; 消息被发送到的呼叫者 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6efe9163e0ae5672fec51b923b5f0a3fddf22450" translate="yes" xml:space="preserve">
          <source>When libraries and escripts are expanded, the names of their contained applications will be displayed. Double click on an application name to launch an application window.</source>
          <target state="translated">当库和脚本被展开时,其包含的应用程序的名称将被显示。双击应用程序名称,启动应用程序窗口。</target>
        </trans-unit>
        <trans-unit id="8ec607efa45c31ad1357f20a7d66c6c141bb9cf2" translate="yes" xml:space="preserve">
          <source>When linking:</source>
          <target state="translated">链接时。</target>
        </trans-unit>
        <trans-unit id="b2385c5f14aa595da46fbd07c32eb8cdc1c9ac6f" translate="yes" xml:space="preserve">
          <source>When list of processes is passed as &lt;code&gt;PidOrPids&lt;/code&gt;, function returns &lt;code&gt;not_joined&lt;/code&gt; only when all processes of the list are not joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08f2f18c94939c7eb816f59b144c9e39119701b" translate="yes" xml:space="preserve">
          <source>When loading, function &lt;code&gt;load/2&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; when any instance of the driver is present. Thus, if a driver is waiting to get unloaded (because of open ports), it simply changes state to no longer need unloading.</source>
          <target state="translated">加载时，如果存在任何驱动程序实例，则函数 &lt;code&gt;load/2&lt;/code&gt; 将返回 &lt;code&gt;ok&lt;/code&gt; 。因此，如果驱动程序正等待卸载（由于打开的端口），它只会将状态更改为不再需要卸载。</target>
        </trans-unit>
        <trans-unit id="24765533bb74fe1f717eba248fca4a267e2412ee" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt; erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fab8b9afb79981ea75c2c9f545c0487fc0a213" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt;erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="translated">在正在运行的系统中查看内存使用情况时，最基本的信息获取方法是 &lt;code&gt;erlang:memory()&lt;/code&gt; 。它返回系统的当前内存使用情况。 &lt;code&gt;instrument(3)&lt;/code&gt; 可用于更详细地了解使用内存的位置。</target>
        </trans-unit>
        <trans-unit id="48de25c51d5ee0ecfba79d1f31f96c3371dd4574" translate="yes" xml:space="preserve">
          <source>When looking at this very simple solution with very little overhead you might wonder why we didn't implement it this way from the beginning. It all boils down to the read operation of the pointer. We need some way to know that it is safe to access the memory pointed to. One way of doing this is to place a reference counter in the process structure. Increment of the reference counter at lookup needs to be done atomically with the lookup. A lock can typically provide this service for us, which was the approach we previously used. Another approach could be to co-locate the reference counter with the pointer in the table. The major problem with this approach is the modifications of the reference counter. This since these modification would have to be communicated between all involved processor cause contention on the cache line containing the reference counter. The new lookup approach above is possible since we can use the &quot;thread progress&quot; functionality in order to determine when it is safe to deallocate the process structure. We'll get back to this when describing deletion in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc0303546ea4a5cee3b6a223eb3288b9d2ea037" translate="yes" xml:space="preserve">
          <source>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</source>
          <target state="translated">当宏在表达式中展开时,宏调用会被宏值所取代,而不需要任何形式的引号或括号。</target>
        </trans-unit>
        <trans-unit id="6e14461d99df8d7f5bd6dbaee93c610c2ce18da3" translate="yes" xml:space="preserve">
          <source>When many types (or another ASN.1 entity) only differ in some minor cases, but the structure of the types is similar, only one general type can be defined and the differences can be supplied through parameters.</source>
          <target state="translated">当许多类型(或另一个ASN.1实体)只在一些小的情况下有差异,但类型的结构是相似的,只能定义一个通用类型,差异可以通过参数提供。</target>
        </trans-unit>
        <trans-unit id="e3e3f53fcfe03af37581eeb29d3a1f8a21d06868" translate="yes" xml:space="preserve">
          <source>When matched against a term, both &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</source>
          <target state="translated">当与术语匹配时， &lt;code&gt;Pattern1&lt;/code&gt; 和 &lt;code&gt;Pattern2&lt;/code&gt; 均与术语匹配。该功能背后的想法是避免术语的重构。</target>
        </trans-unit>
        <trans-unit id="70ef1970aabf29043b85da367698cefcc4f383ae" translate="yes" xml:space="preserve">
          <source>When matching &lt;code&gt;Value&lt;/code&gt;, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</source>
          <target state="translated">匹配 &lt;code&gt;Value&lt;/code&gt; 时，value必须是变量或整数，或者是浮点文字。不允许使用表达式。</target>
        </trans-unit>
        <trans-unit id="919226a6786be88542935b4ae72b62f44ea75480" translate="yes" xml:space="preserve">
          <source>When matching strings, the following is a valid pattern:</source>
          <target state="translated">匹配字符串时,以下是有效的模式。</target>
        </trans-unit>
        <trans-unit id="d1c82c501be92ba824ae89344ef75c4d9af9bf67" translate="yes" xml:space="preserve">
          <source>When megaco fails to send the reply (see &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;), for whatever reason.</source>
          <target state="translated">无论出于何种原因，当megaco无法发送答复时（请参阅 &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="acae380ca138d49866a8d2225bb9fdf2866a8ef8" translate="yes" xml:space="preserve">
          <source>When messages are &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header.</source>
          <target state="translated">当消息 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; 并且使用 &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; ，在分发头后面的术语中会省略包含版本号（131）的第一个字节。这是因为版本号由分发标头中的版本号暗示。</target>
        </trans-unit>
        <trans-unit id="787e404397583f253bb775c283cf222bacb2db6c" translate="yes" xml:space="preserve">
          <source>When monitoring is requested, and a corresponding &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt; would be returned, the function instead returns a tuple &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; and the process then gets a monitor message later, when the driver gets loaded. The monitor message to expect is described in the function description of &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当请求监视时，并且将返回相应的 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 或 &lt;code&gt;{ok, pending_process}&lt;/code&gt; ，该函数将返回一个元组 &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; ，然后，当驱动程序被加载。在 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; 的功能描述中描述了期望的监视消息。</target>
        </trans-unit>
        <trans-unit id="efb7c3fa2502fdd9d0754635086f8f9899582889" translate="yes" xml:space="preserve">
          <source>When multiple test specification files are specified at startup (either with &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; or &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; either executes one test run per specification file, or joins the files and performs all tests within one single test run. The first behavior is the default one. The latter requires that start flag/option &lt;code&gt;join_specs&lt;/code&gt; is provided, for example, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt;.</source>
          <target state="translated">在启动时指定了多个测试规范文件时（使用 &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; 或 &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt; ））， &lt;code&gt;Common Test&lt;/code&gt; 将执行一次测试运行每个规范文件，或将文件加入并在一次测试运行中执行所有测试。第一个行为是默认行为。后者要求提供启动标志/选项 &lt;code&gt;join_specs&lt;/code&gt; ，例如， &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86c9c01ac51912ffee582ab560019f3600e62f5e" translate="yes" xml:space="preserve">
          <source>When multiple threads access the same data structure you often need to know when all threads have completed their accesses. For example, in order to know when it is safe to deallocate the data structure. One simple way to accomplish this is to reference count all accesses to the data structure. The problem with this approach is that the cache line where the reference counter is located needs to be communicated between all involved processors. Such communication can become extremely expensive and will scale poorly if the reference counter is frequently accessed. That is, we want to use some other approach of keeping track of threads than reference counting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4d379ce1acc3e58649f3f6e5610dec08b734cc" translate="yes" xml:space="preserve">
          <source>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function &lt;code&gt;Resolve&lt;/code&gt; is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</source>
          <target state="translated">将新节点添加到网络后，它们会被告知已经存在的全局注册名称。还向网络通知新连接的节点中的所有全局名称。如果发现任何名称冲突，则调用 &lt;code&gt;Resolve&lt;/code&gt; 函数。其目的是确定哪个pid是正确的。如果函数崩溃，或者返回除pid之一之外的任何其他内容，则该名称未注册。每个名称冲突都会调用一次此函数。</target>
        </trans-unit>
        <trans-unit id="78f8bd0d1896a4dff8f44b290b2a56e3f9fcb215" translate="yes" xml:space="preserve">
          <source>When one node wants to connect to another node it starts with a &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</source>
          <target state="translated">当一个节点要连接到另一节点时，它会向该节点所在主机上的EPMD 发出 &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; 请求，以获取该节点侦听的分发端口。</target>
        </trans-unit>
        <trans-unit id="733930eec7fc5b747c5c2817c8d2e79c6f4e243c" translate="yes" xml:space="preserve">
          <source>When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.</source>
          <target state="translated">当这些选项中的一个变化发生在顶层(即不在子模式括号内)时,该变化适用于后面模式的其余部分。</target>
        </trans-unit>
        <trans-unit id="b86cd46910a6aa214f7f42e5ee8633b337f649a0" translate="yes" xml:space="preserve">
          <source>When opening an existing wrap log, it is not necessary to supply a value for option &lt;code&gt;Size&lt;/code&gt;, but any supplied value must equal the current log size, otherwise the tuple &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; is returned.</source>
          <target state="translated">打开现有的包装日志时，不必为Option &lt;code&gt;Size&lt;/code&gt; 提供值，但是任何提供的值都必须等于当前日志大小，否则将返回元组 &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c7edf9e74339539f6cc3b3080ee90687bd35019" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;global&lt;/code&gt; is speciified, the &lt;code&gt;capture&lt;/code&gt; specification affects each match separately, so that:</source>
          <target state="translated">指定选项 &lt;code&gt;global&lt;/code&gt; 时， &lt;code&gt;capture&lt;/code&gt; 规范分别影响每个匹配，因此：</target>
        </trans-unit>
        <trans-unit id="35779093faa3e10fba6141595e13648b564ea182" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;unicode&lt;/code&gt; is specified, the regular expression is to be specified as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise as any valid &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">当指定选项 &lt;code&gt;unicode&lt;/code&gt; 时，正则表达式将被指定为有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; ，否则将被指定为任何有效的 &lt;code&gt;iodata()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55a165a455c0fbb6c5fe22fe047dc9f316e166c5" translate="yes" xml:space="preserve">
          <source>When ordered to shut down, the &lt;code&gt;gen_statem&lt;/code&gt; then calls callback function &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt;.</source>
          <target state="translated">当命令关闭时， &lt;code&gt;gen_statem&lt;/code&gt; 然后调用回调函数Terminate &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6c0af6f0c64d162765f0e344a6e84e0addaa2a2" translate="yes" xml:space="preserve">
          <source>When packaging code using &lt;code&gt;systools&lt;/code&gt;, the code for each application is placed in a separate directory, &lt;code&gt;lib/Application-Vsn&lt;/code&gt;, where &lt;code&gt;Vsn&lt;/code&gt; is the version number.</source>
          <target state="translated">使用 &lt;code&gt;systools&lt;/code&gt; 打包代码时，每个应用程序的代码都放在单独的目录 &lt;code&gt;lib/Application-Vsn&lt;/code&gt; 中，其中 &lt;code&gt;Vsn&lt;/code&gt; 是版本号。</target>
        </trans-unit>
        <trans-unit id="9753680bda30c348a14a4334e6baee4da1b60e94" translate="yes" xml:space="preserve">
          <source>When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails.</source>
          <target state="translated">当解析一个未知方案的URI时(即在方案默认值中找不到的方案),必须提供一个端口号,否则解析失败。</target>
        </trans-unit>
        <trans-unit id="710f52128840cdac154a523eb3c58c2968f8b895" translate="yes" xml:space="preserve">
          <source>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally.</source>
          <target state="translated">当MIB的部分内容实现后,您可以重新编译它,并通过使用默认函数继续进行。通过这种方法,可以逐步开发SNMP代理。</target>
        </trans-unit>
        <trans-unit id="e91864f69e3643249c414a5ca6b0b38fdf0614ca" translate="yes" xml:space="preserve">
          <source>When performance is of highest priority and you are interested in a limited part of the ASN.1 encoded message before deciding what to do with the rest of it, an option is to decode only this small part. The situation can be a server that has to decide the addressee of a message. The addressee can be interested in the entire message, but the server can be a bottleneck that you want to spare any unnecessary load.</source>
          <target state="translated">当性能是最高优先级,并且你对ASN.1编码消息的有限部分感兴趣,然后再决定如何处理它的其余部分时,一个选择是只对这一小部分进行解码。这种情况可以是一个服务器必须决定一个消息的收件人。收件人可以对整个消息感兴趣,但服务器可以是一个瓶颈,你要免除任何不必要的负载。</target>
        </trans-unit>
        <trans-unit id="00f8fec10d66dd9849d5606b35c3bae4eb0e24b0" translate="yes" xml:space="preserve">
          <source>When performing a GC, this is the max number of cache entries that will be deleted from the cache.</source>
          <target state="translated">当执行GC时,这是将从缓存中删除的最大缓存条目数。</target>
        </trans-unit>
        <trans-unit id="41cd934c42ca149b995fdeb861721924fd54af23" translate="yes" xml:space="preserve">
          <source>When performing lookups in the table we do not need to bother about the locking at all, but when modifying the table we read lock the rwlock protecting the table which allows for multiple writers during normal operation. When the BIF that iterates over the table need access to the table it write locks the rwlock and reads content of the table. The BIF do not read the whole table in one go but instead read small chunks at time only write locking while reading. The actual implementation of the BIFs is out of the scope of this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12910634b83422602cdf82ac5e1d4a0b08ca569" translate="yes" xml:space="preserve">
          <source>When positioning in a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, caution must be taken to set the position on a correct character boundary. For details, see &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;latin1&lt;/code&gt; 以外的其他 &lt;code&gt;encoding&lt;/code&gt; 定位文件时，必须注意将位置设置在正确的字符边界上。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7dd480431060a65f68203a547b3153b86e9f6c0" translate="yes" xml:space="preserve">
          <source>When printing variable names, they must have the form of proper Core Erlang variables and function names. E.g., a name represented by an integer such as &lt;code&gt;42&lt;/code&gt; could be formatted as &quot;&lt;code&gt;_42&lt;/code&gt;&quot;, an atom &lt;code&gt;'Xxx'&lt;/code&gt; simply as &quot;&lt;code&gt;Xxx&lt;/code&gt;&quot;, and an atom &lt;code&gt;foo&lt;/code&gt; as &quot;&lt;code&gt;_foo&lt;/code&gt;&quot;. However, one must assure that any two valid distinct names are never mapped to the same strings. Tuples such as &lt;code&gt;{foo, 2}&lt;/code&gt; representing function names can simply by formatted as &quot;&lt;code&gt;'foo'/2&lt;/code&gt;&quot;, with no risk of conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edc83622335984eb1eafacb2b7c60d225676ad9" translate="yes" xml:space="preserve">
          <source>When reading and writing to Unicode-aware entities, like a file opened for Unicode translation, you probably want to format text strings using the functions in the &lt;code&gt;io&lt;/code&gt; module or the &lt;code&gt;io_lib&lt;/code&gt; module. For backward compatibility reasons, these functions do not accept any list as a string, but require a special &lt;strong&gt;translation modifier&lt;/strong&gt; when working with Unicode texts. The modifier is &lt;code&gt;t&lt;/code&gt;. When applied to control character &lt;code&gt;s&lt;/code&gt; in a formatting string, it accepts all Unicode code points and expects binaries to be in UTF-8:</source>
          <target state="translated">在读写支持Unicode的实体（例如为Unicode转换打开的文件）时，您可能希望使用 &lt;code&gt;io&lt;/code&gt; 模块或 &lt;code&gt;io_lib&lt;/code&gt; 模块中的函数来格式化文本字符串。出于向后兼容的原因，这些函数不接受任何列表作为字符串，但是在处理Unicode文本时需要特殊的&lt;strong&gt;转换修饰符&lt;/strong&gt;。修饰符是 &lt;code&gt;t&lt;/code&gt; 。当应用于格式字符串中的控制字符 &lt;code&gt;s&lt;/code&gt; 时，它接受所有Unicode代码点，并期望二进制文件采用UTF-8：</target>
        </trans-unit>
        <trans-unit id="3c0dca0646e1e96c639e0ef95ed64c16af0abe48" translate="yes" xml:space="preserve">
          <source>When receiving a log event, either from the emulator or from a remote node, the proxy calls the Logger API to log the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c1dd8823b82718c750f6e4752dce919973fd1c" translate="yes" xml:space="preserve">
          <source>When receiving data from untrusted sources, use option &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt;.</source>
          <target state="translated">从不受信任的来源接收数据时，请使用选项 &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caaa8dcd0a5b73778282496efd8b85cdbc96febe" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler clears the latest received alarm with id &lt;code&gt;AlarmId&lt;/code&gt;.</source>
          <target state="translated">收到此事件时，默认的简单处理程序清除ID为 &lt;code&gt;AlarmId&lt;/code&gt; 的最新收到的警报。</target>
        </trans-unit>
        <trans-unit id="9e62ca61b001221600279b3875635215766f5030" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler stores the alarm. &lt;code&gt;AlarmId&lt;/code&gt; identifies the alarm and is used when the alarm is cleared.</source>
          <target state="translated">收到此事件时，默认的简单处理程序将存储警报。 &lt;code&gt;AlarmId&lt;/code&gt; 标识警报，并在清除警报时使用。</target>
        </trans-unit>
        <trans-unit id="cab9fe9e9b48ff6bfb268655c0f4e10837898a9b" translate="yes" xml:space="preserve">
          <source>When recompiling with &lt;code&gt;gcc&lt;/code&gt;, use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; to get better warnings. Try to find a similar flag if you use another compiler.</source>
          <target state="translated">使用 &lt;code&gt;gcc&lt;/code&gt; 重新编译时，请使用标志 &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; 以获得更好的警告。如果使用其他编译器，请尝试查找类似的标志。</target>
        </trans-unit>
        <trans-unit id="5fa55ded95f5c996f7f21886e99692b06c59dfaf" translate="yes" xml:space="preserve">
          <source>When recursing and building a list, it is important to ensure that you attach the new elements to the beginning of the list. In this way, you will build &lt;strong&gt;one&lt;/strong&gt; list, not hundreds or thousands of copies of the growing result list.</source>
          <target state="translated">递归并构建列表时，确保将新元素附加到列表的开头很重要。这样，您将建立&lt;strong&gt;一个&lt;/strong&gt;列表，而不是成百上千的增长结果列表副本。</target>
        </trans-unit>
        <trans-unit id="d8bab5f0a38ad7351ef92518566a8a66e14c70a0" translate="yes" xml:space="preserve">
          <source>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</source>
          <target state="translated">当激活或停用受限的shell模式时,节点上启动的新作业分别以受限或正常模式运行。</target>
        </trans-unit>
        <trans-unit id="5c2049b6ccaf60623aba58c7816db28baba978c3" translate="yes" xml:space="preserve">
          <source>When run as above (this will take some time), the measurement process is done as follows:</source>
          <target state="translated">当按上述方法运行时(这将需要一些时间),测量过程如下。</target>
        </trans-unit>
        <trans-unit id="bcae0656877ffa6ebb4290ed9f508d93d062de30" translate="yes" xml:space="preserve">
          <source>When run on Linux, &lt;code&gt;cpu_sup&lt;/code&gt; assumes that the &lt;code&gt;/proc&lt;/code&gt; file system is present and accessible by &lt;code&gt;cpu_sup&lt;/code&gt;. If it is not, &lt;code&gt;cpu_sup&lt;/code&gt; will terminate.</source>
          <target state="translated">在Linux上运行时， &lt;code&gt;cpu_sup&lt;/code&gt; 假定存在 &lt;code&gt;/proc&lt;/code&gt; 文件系统，并且可由 &lt;code&gt;cpu_sup&lt;/code&gt; 访问。如果不是，则 &lt;code&gt;cpu_sup&lt;/code&gt; 将终止。</target>
        </trans-unit>
        <trans-unit id="4cf54f8998c8d68cc207a24a295ffc4553d6eff1" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;high&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; are selected for execution. Notice however that this does &lt;strong&gt;not&lt;/strong&gt; mean that no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; can run when processes are running on priority &lt;code&gt;high&lt;/code&gt;. When using multiple schedulers, more processes can be running in parallel than processes on priority &lt;code&gt;high&lt;/code&gt;. That is, a &lt;code&gt;low&lt;/code&gt; and a &lt;code&gt;high&lt;/code&gt; priority process can execute at the same time.</source>
          <target state="translated">当存在优先级 &lt;code&gt;high&lt;/code&gt; 可运行进程时，不会选择优先级 &lt;code&gt;low&lt;/code&gt; 或 &lt;code&gt;normal&lt;/code&gt; 进程来执行。但是请注意，这也&lt;strong&gt;并不&lt;/strong&gt;意味着就没有优先处理 &lt;code&gt;low&lt;/code&gt; 或 &lt;code&gt;normal&lt;/code&gt; 可以运行在进程优先级运行 &lt;code&gt;high&lt;/code&gt; 。当使用多个调度程序时，与优先级 &lt;code&gt;high&lt;/code&gt; 进程相比，可以并行运行更多的进程。即， &lt;code&gt;low&lt;/code&gt; 优先级进程和 &lt;code&gt;high&lt;/code&gt; 优先级进程可以同时执行。</target>
        </trans-unit>
        <trans-unit id="bac375c5ce5278df5f7742eba36c446680185abe" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;max&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;high&lt;/code&gt; are selected for execution. As with priority &lt;code&gt;high&lt;/code&gt;, processes on lower priorities can execute in parallel with processes on priority &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">当存在优先级为 &lt;code&gt;max&lt;/code&gt; 的可运行进程时，不会选择优先级为 &lt;code&gt;low&lt;/code&gt; ， &lt;code&gt;normal&lt;/code&gt; 或 &lt;code&gt;high&lt;/code&gt; 的进程来执行。与优先级 &lt;code&gt;high&lt;/code&gt; ，就较低优先级的进程可以并行与优先级进程执行 &lt;code&gt;max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="680e4c2820f1533afc4212ad58a52897fa7b6ea9" translate="yes" xml:space="preserve">
          <source>When running SMP erlang on a multi-core machine the &quot;throughput&quot; is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner.</source>
          <target state="translated">当在多核机器上运行SMP erlang时,&quot;吞吐量 &quot;会明显提高。mstone1测试是一个极端的测试,但它显示了使用reentrant flex-scanner的好处。</target>
        </trans-unit>
        <trans-unit id="bb8603cea37568d4ea95955c8c7cd5ad79e8fceb" translate="yes" xml:space="preserve">
          <source>When running a distributed system with two or more participating nodes, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, &lt;code&gt;mnesia:start()&lt;/code&gt; can also be used either from the Erlang shell or another program.</source>
          <target state="translated">当运行具有两个或更多参与节点的分布式系统时，必须在每个参与节点上执行函数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 。在嵌入式环境中，这通常是启动脚本的一部分。在测试环境或交互式环境中，也可以从Erlang Shell或其他程序中使用 &lt;code&gt;mnesia:start()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65e9a6705c8969bac7cd69e2170ef9d9d0ac1c6a" translate="yes" xml:space="preserve">
          <source>When running in &lt;code&gt;utf8&lt;/code&gt; mode, functions &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; never return raw filenames. To return all filenames including raw filenames, use functions &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;utf8&lt;/code&gt; 模式下运行时，函数 &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; 从不返回原始文件名。要返回所有文件名，包括原始文件名，请使用函数 &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfdc638646c31aefd08c7b469c60f917c3f883df" translate="yes" xml:space="preserve">
          <source>When running on OSs lacking support for monotonic time, &lt;code&gt;heart&lt;/code&gt; is susceptible to system clock adjustments of more than &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds. When this happens, &lt;code&gt;heart&lt;/code&gt; times out and tries to reboot the system. This can occur, for example, if the system clock is adjusted automatically by use of the Network Time Protocol (NTP).</source>
          <target state="translated">在缺乏单调时间支持的操作系统上运行时， &lt;code&gt;heart&lt;/code&gt; 很容易受到超过 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 秒的系统时钟调整的影响。发生这种情况时， &lt;code&gt;heart&lt;/code&gt; 会超时并尝试重新引导系统。例如，如果通过使用网络时间协议（NTP）自动调整系统时钟，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="5ecb6729e649e0c2e3875d3412d7df6f9ff2fc1b" translate="yes" xml:space="preserve">
          <source>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</source>
          <target state="translated">在 Windows 上运行时,当生成 port 程序时,会抑制创建新的控制台窗口 (这个选项对其他平台没有影响)。(这个选项对其他平台没有影响。)</target>
        </trans-unit>
        <trans-unit id="309f93ce0de6e0564170b1380609d0ba9cb4ea04" translate="yes" xml:space="preserve">
          <source>When running some simple benchmarks where contention only occur due to I/O signals contending with signals from one single process we got a speedup of 5-15%. When multiple processes send signals to one single port the improvements can be much larger, but the scenario with one process contending with I/O is the most common one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd983c16ed2802c7407abf4ca24b358fab081cd5" translate="yes" xml:space="preserve">
          <source>When running the chameneosredux benchmark, schedulers frequently run out of work trying to steal work from each other. That is, either succeeding in migrating, or trying to migrate processes which is a scenario which we wanted to optimize. By the introduction of these improvements, we got a speedup of 25-35% when running this benchmark on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fef19bf4ae7d5149805c66d2c79ab1ccaa7133" translate="yes" xml:space="preserve">
          <source>When running the ehb benchmark, large amount of messages are passed around between schedulers. All message passing will in some way or the other cause memory allocation and deallocation. Since messages are passed between different schedulers we will get contention on the allocator instances where messages were allocated. By the introduction of the delayed dealloc feature, we got a speedup of between 25-45%, depending on configuration of the benchmark, when running on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63711eb9fd97d3b4dc00231599c84305bd3a055a" translate="yes" xml:space="preserve">
          <source>When schedulers need to read this information, they read the pointer to currently used information using an atomic read operation, and then issue a data dependency read barrier, which on most architectures is a no-op. That is, it is very little overhead getting access to this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b602ea12cff6b347850ec520a992d2e4051e4a" translate="yes" xml:space="preserve">
          <source>When selecting data from a table, all data types are returned from the database to the ODBC driver as an ODBC data type. The tables below shows the mapping between those data types and what is returned by the Erlang API.</source>
          <target state="translated">当从表中选择数据时,所有的数据类型都会以ODBC数据类型的形式从数据库返回给ODBC驱动程序。下表显示了这些数据类型与Erlang API返回的数据类型之间的映射。</target>
        </trans-unit>
        <trans-unit id="5028404a77ebb05ae66aa4cdb0300c35b354c2d2" translate="yes" xml:space="preserve">
          <source>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</source>
          <target state="translated">当向 port 发送数据时。端口能够理解深层列表,因此没有理由在发送列表到端口之前将其扁平化。</target>
        </trans-unit>
        <trans-unit id="f6655794aac8234bda9f3cc8627542cf28e39cd7" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;user_reply()&lt;/code&gt;). When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;[user_reply()]&lt;/code&gt;). Each element of the list is part of one transaction.</source>
          <target state="translated">在消息中发送一个事务时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;action_reqs()&lt;/code&gt; （ &lt;code&gt;UserReply&lt;/code&gt; 将为 &lt;code&gt;user_reply()&lt;/code&gt; ）。在消息中发送多个事务时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;[action_reqs()]&lt;/code&gt; （ &lt;code&gt;UserReply&lt;/code&gt; 将为 &lt;code&gt;[user_reply()]&lt;/code&gt; ）。列表的每个元素都是一个事务的一部分。</target>
        </trans-unit>
        <trans-unit id="342bdd47df4ec30e4e5a4ebaa64afc70c7b8eea1" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">在消息中发送一个事务时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;action_reqs()&lt;/code&gt; 。在消息中发送多个事务时， &lt;code&gt;Actions&lt;/code&gt; 应为 &lt;code&gt;[action_reqs()]&lt;/code&gt; 。列表的每个元素都是一个事务的一部分。</target>
        </trans-unit>
        <trans-unit id="9e875fa8988ecf27835b249f9b398d7327be21c9" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt; logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b19f5e353d16bcbf308a2928e10b271ad77a7b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt;logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，运行时系统通过 &lt;code&gt;logger&lt;/code&gt; 记录错误事件，其中包含达到最大堆大小时有关进程的详细信息。每次达到限制时，都会发送一个日志事件。</target>
        </trans-unit>
        <trans-unit id="a7a9f29c7c04f56d28d9864f8634905c97f0d23f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system sends an untrappable exit signal with reason &lt;code&gt;kill&lt;/code&gt; to the process if the maximum heap size is reached. The garbage collection that triggered the &lt;code&gt;kill&lt;/code&gt; is not completed, instead the process exits as soon as possible. When set to &lt;code&gt;false&lt;/code&gt;, no exit signal is sent to the process, instead it continues executing.</source>
          <target state="translated">如果设置为 &lt;code&gt;true&lt;/code&gt; ，则在达到最大堆大小时，运行时系统会向进程发送不可中断的退出信号，其原因是 &lt;code&gt;kill&lt;/code&gt; 。垃圾收集触发 &lt;code&gt;kill&lt;/code&gt; 没有完成，而不是在进程退出尽快。当设置为 &lt;code&gt;false&lt;/code&gt; 时，没有退出信号发送到该进程，而是继续执行。</target>
        </trans-unit>
        <trans-unit id="1535dfcd1ada0e5df2bfdd93f8582a8fb9db2211" translate="yes" xml:space="preserve">
          <source>When set, informs the peer to use &lt;code&gt;{IP, Port}&lt;/code&gt; as the primary address of the local endpoint for the association specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">设置后，通知对等方使用 &lt;code&gt;{IP, Port}&lt;/code&gt; 作为 &lt;code&gt;assoc_id&lt;/code&gt; 指定的关联的本地端点的主地址。</target>
        </trans-unit>
        <trans-unit id="a09fa3690c8e86bcc1ad44fbac6fe4381cfc8c36" translate="yes" xml:space="preserve">
          <source>When set, requests that the local endpoint uses the value specified by &lt;code&gt;adaptation_ind&lt;/code&gt; as the Adaptation Indication parameter for establishing new associations. For details, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">设置时，本地端点使用由指定的值请求 &lt;code&gt;adaptation_ind&lt;/code&gt; 作为建立新的关联适应指示参数。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35268e3a52547204a88309f957a19dbdd29a75e6" translate="yes" xml:space="preserve">
          <source>When setting up a trace, the following features can also be activated:</source>
          <target state="translated">设置跟踪时,还可以激活以下功能。</target>
        </trans-unit>
        <trans-unit id="bc86d8be157ab5b84c3a61f949941d9549419fe9" translate="yes" xml:space="preserve">
          <source>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then &lt;code&gt;trans_req_maxsize&lt;/code&gt;, in which case the stored transactions are sent first in a separate message and the reply in another message.</source>
          <target state="translated">当要发送某些内容时，所有内容都打包成一条消息，除非触发器是一个应答事务，并且应答的增加大小且所有请求都大于 &lt;code&gt;trans_req_maxsize&lt;/code&gt; ，在这种情况下，存储的事务首先在单独的消息中发送然后在另一封邮件中回复。</target>
        </trans-unit>
        <trans-unit id="5c6669a85ba52eabed1bcac71536c7df178c1e61" translate="yes" xml:space="preserve">
          <source>When sorting or merging files, only the first of a sequence of terms that compare equal (&lt;code&gt;==&lt;/code&gt;) is output if this option is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在对文件进行排序或合并时，如果此选项设置为 &lt;code&gt;true&lt;/code&gt; ,则仅输出比较相等（ &lt;code&gt;==&lt;/code&gt; ）的术语序列中的第一个。默认为 &lt;code&gt;false&lt;/code&gt; ，这意味着输出所有比较相等的项。在检查文件的排序时，如果此选项设置为 &lt;code&gt;true&lt;/code&gt; ，则将检查没有一对连续的术语比较相等。</target>
        </trans-unit>
        <trans-unit id="eeaa657839317430e892985c6edb0950f60958c4" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;Level&lt;/code&gt; as an integer, and therefor using &quot;native mode&quot;, it is *currently* up to the caller to know how to encode the &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e0970cdbf2a1a1d933db58200b846160d61b1a" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;Level&lt;/code&gt; as an integer, and therefor using &quot;native mode&quot;, it is *currently* up to the caller to know how to interpret the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d9a5c9e89c06fc7a1af4210b3e4aef4fd2191a" translate="yes" xml:space="preserve">
          <source>When specifying an atom constraint, the atom is written as it would be in the C source code. That is, it needs an &lt;code&gt;am_&lt;/code&gt; prefix, and it must be listed in &lt;code&gt;atom.names&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c34b332981b8e474e02ef63bcc500fd0757ef2" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.</source>
          <target state="translated">当启动 &lt;code&gt;stand_alone&lt;/code&gt; 时,只能使用pid。</target>
        </trans-unit>
        <trans-unit id="b66f134384d3cc9012959c5c579272f12c941335" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can used.</source>
          <target state="translated">当启动 &lt;code&gt;stand_alone&lt;/code&gt; 时,只能使用pid。</target>
        </trans-unit>
        <trans-unit id="a9910d3d66f8237ea301a1cc0a52c4d81c8b1682" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt;.</source>
          <target state="translated">启动 &lt;code&gt;stand_alone&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="a4ce6035e3ae59d7f18987449985901fd92e494f" translate="yes" xml:space="preserve">
          <source>When started, the node waits for all nodes specified by &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; and &lt;code&gt;sync_nodes_optional&lt;/code&gt; to come up. When all nodes are up, or when all mandatory nodes are up and the time specified by &lt;code&gt;sync_nodes_timeout&lt;/code&gt; has elapsed, all applications start. If not all mandatory nodes are up, the node terminates.</source>
          <target state="translated">启动后，该节点等待 &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; 和 &lt;code&gt;sync_nodes_optional&lt;/code&gt; 指定的所有节点出现。当所有节点都已启动，或者所有必需节点都已启动并且经过 &lt;code&gt;sync_nodes_timeout&lt;/code&gt; 指定的时间时，所有应用程序都将启动。如果不是所有必需节点都启动，则该节点终止。</target>
        </trans-unit>
        <trans-unit id="4f35884d86e4f1c2ac96377ac4d8d3d8958cc289" translate="yes" xml:space="preserve">
          <source>When started, the supervisor does not start any child processes. Instead, all child processes are added dynamically by calling:</source>
          <target state="translated">当启动时,监督程序不会启动任何子进程。相反,所有子进程都是通过调用动态添加的。</target>
        </trans-unit>
        <trans-unit id="af782a2bcb2a4b2a362bed6616a129bcc6a72b52" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;Mnesia&lt;/code&gt;, a &lt;code&gt;.LOG&lt;/code&gt; file called &lt;code&gt;LATEST.LOG&lt;/code&gt; is created and placed in the database directory. This file is used by &lt;code&gt;Mnesia&lt;/code&gt; to log disc-based transactions. This includes all transactions that write at least one record in a table that is of storage type &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;disc_only_copies&lt;/code&gt;. The file also includes all operations that manipulate the schema itself, such as creating new tables. The log format can vary with different implementations of &lt;code&gt;Mnesia&lt;/code&gt;. The &lt;code&gt;Mnesia&lt;/code&gt; log is currently implemented in the standard library module &lt;code&gt;disk_log&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">启动 &lt;code&gt;Mnesia&lt;/code&gt; 时，将创建一个名为 &lt;code&gt;LATEST.LOG&lt;/code&gt; 的 &lt;code&gt;.LOG&lt;/code&gt; 文件并将其放置在数据库目录中。 &lt;code&gt;Mnesia&lt;/code&gt; 使用此文件记录基于磁盘的事务。这包括所有在表中至少写入一条记录的存储类型 &lt;code&gt;disc_copies&lt;/code&gt; 或 &lt;code&gt;disc_only_copies&lt;/code&gt; 的事务。该文件还包括操纵模式本身的所有操作，例如创建新表。日志格式可能会因 &lt;code&gt;Mnesia&lt;/code&gt; 的不同实现而异。在 &lt;code&gt;Mnesia&lt;/code&gt; 的日志在标准库模块目前实施 &lt;code&gt;disk_log&lt;/code&gt; 的 &lt;code&gt;Kernel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbcc2618bb75c573fc25f8a846a8fe36e4ed8763" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;prim_app&lt;/code&gt; as defined above, the application controller calls the following callback functions before &lt;code&gt;application:start(prim_app)&lt;/code&gt; returns a value:</source>
          <target state="translated">如上定义启动 &lt;code&gt;prim_app&lt;/code&gt; 时，应用程序控制器会在 &lt;code&gt;application:start(prim_app)&lt;/code&gt; 返回值之前调用以下回调函数：</target>
        </trans-unit>
        <trans-unit id="4cd4f1a6e7e43123fc3118e6461ff8abe900204f" translate="yes" xml:space="preserve">
          <source>When starting Erlang in embedded mode, it is assumed that exactly one system configuration file is used, named &lt;code&gt;sys.config&lt;/code&gt;. This file is to be located in &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the Erlang/OTP root installation directory and &lt;code&gt;Vsn&lt;/code&gt; is the release version.</source>
          <target state="translated">在嵌入式模式下启动Erlang时，假定只使用了一个名为 &lt;code&gt;sys.config&lt;/code&gt; 的系统配置文件。该文件位于 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; ，其中 &lt;code&gt;$ROOT&lt;/code&gt; 是Erlang / OTP根安装目录，而 &lt;code&gt;Vsn&lt;/code&gt; 是发行版本。</target>
        </trans-unit>
        <trans-unit id="b5ddbb5d78d831c78a317496e7e2a2d2c40076a3" translate="yes" xml:space="preserve">
          <source>When starting Erlang/OTP using the boot script, all applications from the &lt;code&gt;.rel&lt;/code&gt; file are automatically loaded and started:</source>
          <target state="translated">使用启动脚本启动Erlang / OTP时， &lt;code&gt;.rel&lt;/code&gt; 文件中的所有应用程序都会自动加载并启动：</target>
        </trans-unit>
        <trans-unit id="b604ec38ae2b79479f9ec0cb1378442b00d5b576" translate="yes" xml:space="preserve">
          <source>When starting a primary application with included applications, the primary application is started the normal way, that is:</source>
          <target state="translated">当启动包含应用程序的主应用程序时,主应用程序的启动方式是正常的,即。</target>
        </trans-unit>
        <trans-unit id="ed0f727403d7e975b13ca3d05489c37f1a495f5a" translate="yes" xml:space="preserve">
          <source>When starting an Erlang node, the default behaviour is that all log events on level &lt;code&gt;notice&lt;/code&gt; or more severe, are logged to the terminal via the default handler. To also log info events, you can either change the primary log level to &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">当启动一个Erlang节点，默认行为是对所有级别的日志事件 &lt;code&gt;notice&lt;/code&gt; 或更严重的，是通过默认的处理程序记录到终端。要同时记录信息事件，可以将主日志级别更改为 &lt;code&gt;info&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d267d7fc52461e3316cc2f612f2db868d98e7a72" translate="yes" xml:space="preserve">
          <source>When starting external programs on Solaris, the system call &lt;code&gt;vfork&lt;/code&gt; is used in preference to &lt;code&gt;fork&lt;/code&gt; for performance reasons, although it has a history of being less robust. If there are problems using &lt;code&gt;vfork&lt;/code&gt;, setting environment variable &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; to any value causes &lt;code&gt;fork&lt;/code&gt; to be used instead.</source>
          <target state="translated">在Solaris上启动外部程序时，出于性能方面的考虑，优先使用系统调用 &lt;code&gt;vfork&lt;/code&gt; 进行 &lt;code&gt;fork&lt;/code&gt; ，尽管它的运行可靠性较差。如果使用 &lt;code&gt;vfork&lt;/code&gt; 出现问题， &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; 环境变量ERL_NO_VFORK设置为任何值都会导致使用 &lt;code&gt;fork&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6eba2c0286e1f80a8b6d2f783a23106deb0b2394" translate="yes" xml:space="preserve">
          <source>When starting snmpa_local_db it always tries to open an existing database. If &lt;code&gt;false&lt;/code&gt;, and some errors occur, a new database is created instead. If &lt;code&gt;true&lt;/code&gt;, an existing file will be repaired. If &lt;code&gt;force&lt;/code&gt;, the table will be repaired even if it was properly closed.</source>
          <target state="translated">启动snmpa_local_db时，它将始终尝试打开现有数据库。如果为 &lt;code&gt;false&lt;/code&gt; ，并且发生某些错误，则会创建一个新数据库。如果为 &lt;code&gt;true&lt;/code&gt; ，将修复现有文件。如果使用 &lt;code&gt;force&lt;/code&gt; ，即使桌子已正确关闭，也将对其进行维修。</target>
        </trans-unit>
        <trans-unit id="c1c86792af0c1fc90a287c8a9c5bae64d2165932" translate="yes" xml:space="preserve">
          <source>When starting the &lt;code&gt;Inets&lt;/code&gt; application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request.</source>
          <target state="translated">启动 &lt;code&gt;Inets&lt;/code&gt; 应用程序时，将启动默认配置文件的管理器进程。此API中未明确使用配置文件的功能将访问默认配置文件。配置文件跟踪代理选项，Cookie和可应用于多个请求的其他选项。</target>
        </trans-unit>
        <trans-unit id="cd05c53bfd126defe810f3a187a5cf1551a34b96" translate="yes" xml:space="preserve">
          <source>When starting the flex scanner a port to the linked in driver is created. This port has to be owned by a process. This process must not die. If it does the port will also terminate. Therefor:</source>
          <target state="translated">当启动flex扫描仪时,会创建一个连接到驱动的端口。这个端口必须由一个进程拥有。该进程不得死亡。如果该进程死亡,则端口也将终止。因此。</target>
        </trans-unit>
        <trans-unit id="6d9ab8ee43c8cd162c696fc7f8c9882054157b9c" translate="yes" xml:space="preserve">
          <source>When starting this release, three things must be specified:</source>
          <target state="translated">启动这个版本时,必须指定三件事。</target>
        </trans-unit>
        <trans-unit id="b5e8349f617cc19cb94845c2b5a433d10397c346" translate="yes" xml:space="preserve">
          <source>When starting with Unicode, one often stumbles over some common issues. This section describes some methods of dealing with Unicode data.</source>
          <target state="translated">在开始使用Unicode时,经常会被一些常见的问题绊倒。本节介绍一些处理Unicode数据的方法。</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">停止时,应用程序仍在加载。</target>
        </trans-unit>
        <trans-unit id="6bcf5a7b78ff49a4689ff94e30fd3cc2e19a3b3d" translate="yes" xml:space="preserve">
          <source>When streaming to the calling processes using option &lt;code&gt;{self, once}&lt;/code&gt;, the first message has an extra element, that is, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt;. This is the process id to be used as an argument to &lt;code&gt;httpc:stream_next/1&lt;/code&gt; to trigger the next message to be sent to the calling process.</source>
          <target state="translated">当使用选项 &lt;code&gt;{self, once}&lt;/code&gt; 流式传输到调用进程时，第一条消息具有一个额外的元素，即 &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt; 。这是进程ID，用作 &lt;code&gt;httpc:stream_next/1&lt;/code&gt; 的参数，以触​​发下一条消息发送给调用进程。</target>
        </trans-unit>
        <trans-unit id="715fec6e13a0abfe20ee555a6324b0802bfff927" translate="yes" xml:space="preserve">
          <source>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</source>
          <target state="translated">当字符串或二进制对象存储在注册表中时,必须遵循一些简单的准则。</target>
        </trans-unit>
        <trans-unit id="9879a39d7048a88467f14f974e9672e4f402cb5c" translate="yes" xml:space="preserve">
          <source>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</source>
          <target state="translated">从本地磁盘强行加载表时,会丢失本地节点宕机而远程复制体活着时对复制表执行的所有操作。这可能导致数据库变得不一致。</target>
        </trans-unit>
        <trans-unit id="bc9c626bcd30b7f8ecf9ddc823a493152c649dd7" translate="yes" xml:space="preserve">
          <source>When tests start, &lt;code&gt;Common Test&lt;/code&gt; Master displays information to console about the involved nodes. &lt;code&gt;Common Test&lt;/code&gt; Master also reports when tests finish, successfully or unsuccessfully. If connection is lost to a node, the test on that node is considered finished. &lt;code&gt;Common Test&lt;/code&gt; Master does not attempt to re-establish contact with the failing node.</source>
          <target state="translated">当测试开始时， &lt;code&gt;Common Test&lt;/code&gt; Master将显示有关所涉及节点的信息以进行控制台。 &lt;code&gt;Common Test&lt;/code&gt; Master还报告测试成功或失败的时间。如果失去与某个节点的连接，则认为该节点上的测试已完成。 &lt;code&gt;Common Test&lt;/code&gt; Master不会尝试与发生故障的节点重新建立联系。</target>
        </trans-unit>
        <trans-unit id="3a6b1d7b2952e82ddb54a9aed1dcf8f6fa4d10a5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e15e615fec1bfe62b38c3373f94e44765c1055" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="translated">当 &lt;code&gt;'CHANGE'&lt;/code&gt; 已收到消息你保证不会恢复老的时候打电话时偏移 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; 。请注意，在收到 &lt;code&gt;'CHANGE'&lt;/code&gt; 消息之前，您可以在调用 &lt;code&gt;erlang:time_offset()&lt;/code&gt; 时观察时间偏移的变化。</target>
        </trans-unit>
        <trans-unit id="45f99df5f87ec987bc32aa4d5b3c9a0f98e87177" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the &lt;strong&gt;state callback&lt;/strong&gt; name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389c67d197284147820c964a147bf25f89168f89" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the state callback name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;handle_event_function&lt;/code&gt; 时，状态可以是任何术语，并且状态回调名称为 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; 。这使您可以根据需要轻松地根据状态或事件进行分支。请注意在哪种状态下处理哪些事件，以免您意外地将事件永远推迟，以免造成无限繁忙循环。</target>
        </trans-unit>
        <trans-unit id="99984eee00cd2e7cfb5f8bd18b13829e21931a35" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the &lt;strong&gt;state callback&lt;/strong&gt; name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c771ceccfcda3b957b4a4bb8455365fc3a48832" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the state callback name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;state_functions&lt;/code&gt; 时，状态必须是原子，并且用作状态回调名称；参见 &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;gen_statem&lt;/code&gt; 引擎根据状态名称分支时，这会将特定状态的所有代码共存于一个函数中。请注意，在此模式下，回调函数 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 会使状态名称 &lt;code&gt;terminate&lt;/code&gt; 不可用。</target>
        </trans-unit>
        <trans-unit id="7bd23a20d36b333c46d925b8fd401de86fe841dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">当 &lt;code&gt;Addr&lt;/code&gt; 值不包含端口号时，将使用 &lt;code&gt;intAgentUDPPort&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="cfc2f3efdf3b11daa32eb0ee2af5782916973648" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Key&lt;/code&gt; is a single &lt;code&gt;Item&lt;/code&gt;, the result is a single &lt;code&gt;InfoTuple&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a451ad7b9fddbd477a4eb701e170b27602528366" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserData,Data})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22814bccf02caaf2232de9c743157f0b7348ee14" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt;.</source>
          <target state="translated">例如，当 &lt;code&gt;erl_tar&lt;/code&gt; 核心想要写入一段 &lt;code&gt;Data&lt;/code&gt; ，它将调用 &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b84a2f0be01530772a20ac645af7f54b604dbf79" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fprof&lt;/code&gt; server is stopped the collected raw profile data is lost.</source>
          <target state="translated">当 &lt;code&gt;fprof&lt;/code&gt; 服务器停止时，收集的原始配置文件数据将丢失。</target>
        </trans-unit>
        <trans-unit id="280e6fc91e95ee5c827fb2cc1667b778ccb86d7b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; during every &lt;strong&gt;state change&lt;/strong&gt;. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37d26017c607226a4f422562f10e0bd5f4835e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="translated">当 &lt;code&gt;gen_statem&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; 运行时 &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; 只要状态发生变化，这些函数也将使用参数（enter，OldState等）进行调用。在这种情况下，也有对一些限制 &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 可能返回： &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; 因为是不允许的&lt;strong&gt;状态进入的呼叫&lt;/strong&gt;是不是一个事件，所以没有事件推迟，并 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; 是不允许的，因为使用&lt;strong&gt;状态回车调用&lt;/strong&gt;不应影响事件的消费和产生方式。您也可能无法更改此呼叫的状态。如果您返回 &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; 与 &lt;code&gt;NextState =/= State&lt;/code&gt; 的 &lt;code&gt;gen_statem&lt;/code&gt; 崩溃。请注意，实际上它被允许使用 &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; 尽管这没有什么意义，因为您将立即使用新的&lt;strong&gt;状态回车&lt;/strong&gt;再次&lt;strong&gt;调用enter调用&lt;/strong&gt;，这使得这只是一种怪异的循环方式，并且还有更好的方法在Erlang中循环。如果您不更新 &lt;code&gt;NewData&lt;/code&gt; 并具有某些循环终止条件，或者使用 &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; 或 &lt;code&gt;repeat_state_and_data&lt;/code&gt; ,则将导致无限循环！建议您使用 &lt;code&gt;{keep_state,...}&lt;/code&gt; ， &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; 或 &lt;code&gt;keep_state_and_data&lt;/code&gt; ,因为无论如何都无法从&lt;strong&gt;状态回车&lt;/strong&gt;更改状态。</target>
        </trans-unit>
        <trans-unit id="88a1846d28e7d4cd1692423afe0396a4f961fecf" translate="yes" xml:space="preserve">
          <source>When the Cover analysis is ready, Cover is stopped and all Cover compiled modules are &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt;. The code for &lt;code&gt;channel&lt;/code&gt; is now loaded as usual from a &lt;code&gt;.beam&lt;/code&gt; file in the current path.</source>
          <target state="translated">当Coverage分析准备就绪时，Cover停止并且所有Cover编译的模块都被 &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt; 。现在可以照常从当前路径中的 &lt;code&gt;.beam&lt;/code&gt; 文件加载 &lt;code&gt;channel&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="5e678693029d9376dee27d1a3e9cecfc3eb0694b" translate="yes" xml:space="preserve">
          <source>When the Erlang function &lt;code&gt;t/1&lt;/code&gt; was applied to an Xref server loaded with the current version of OTP, the returned value was close to 84 (percent). This means that the number of indirectly used modules is approximately six times greater when using the module graph. So the answer to the above stated question is that it is definitely worth while using the function graph for this particular analysis. Finally, note that in the presence of unresolved calls, the graphs may be incomplete, which means that there may be indirectly used modules that do not show up.</source>
          <target state="translated">当将Erlang函数 &lt;code&gt;t/1&lt;/code&gt; 应用于加载有当前版本OTP的Xref服务器时，返回值接近84（百分比）。这意味着使用模块图时，间接使用的模块数大约是原来的六倍。因此，上述问题的答案是，在使用函数图进行此特定分析时，绝对值得。最后，请注意，在存在未解决的调用的情况下，图形可能不完整，这意味着可能存在未使用的间接使用的模块。</target>
        </trans-unit>
        <trans-unit id="ef14100f6973eec9a2da0c5aac1b652a8be07c43" translate="yes" xml:space="preserve">
          <source>When the Erlang mode is correctly installed, it is automatically activated when a file ending in &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; is opened in Emacs.</source>
          <target state="translated">正确安装Erlang模式后，在Emacs中打开以 &lt;code&gt;.erl&lt;/code&gt; 或 &lt;code&gt;.hrl&lt;/code&gt; 结尾的文件时，它将自动激活。</target>
        </trans-unit>
        <trans-unit id="064005753816c68987f62de4089ac63432bbee7f" translate="yes" xml:space="preserve">
          <source>When the Erlang runtime system is automatically started from the &lt;code&gt;S75otp.system&lt;/code&gt; script, the &lt;code&gt;TERM&lt;/code&gt; environment variable must be set. The following is a minimal setting:</source>
          <target state="translated">从 &lt;code&gt;S75otp.system&lt;/code&gt; 脚本自动启动Erlang运行时系统时，必须设置 &lt;code&gt;TERM&lt;/code&gt; 环境变量。以下是最小设置：</target>
        </trans-unit>
        <trans-unit id="e452b2fde57d622fa0997d4cb19e28e4a65d9107" translate="yes" xml:space="preserve">
          <source>When the MGC receives its first message, the Service Change Request, the Megaco application will automatically establish the connection by using the MG MID found in the message header as remote mid.</source>
          <target state="translated">当MGC收到第一个消息,即 &quot;服务变更请求 &quot;时,Megaco应用程序将使用消息头中的MGID作为远程mid自动建立连接。</target>
        </trans-unit>
        <trans-unit id="0bc1904c9d30ade44fccd694ce928f2cb4a5ad23" translate="yes" xml:space="preserve">
          <source>When the MIB definition work is finished, there are two major issues left.</source>
          <target state="translated">当MIB定义工作完成后,还剩下两个主要问题。</target>
        </trans-unit>
        <trans-unit id="8e36ed72ceac42895c73ec727502a81f2596dcdf" translate="yes" xml:space="preserve">
          <source>When the SASL application is started, it adds a Logger handler that formats and writes these reports, as specified in the &lt;code&gt;configuration parameters for SASL&lt;/code&gt;.</source>
          <target state="translated">启动SASL应用程序后，它会添加一个Logger处理程序，以格式化和写入这些报告，如 &lt;code&gt;configuration parameters for SASL&lt;/code&gt; 的配置参数中所指定。</target>
        </trans-unit>
        <trans-unit id="3b73a5fb29f56921e69c0ac4a2cd6ca545f386dd" translate="yes" xml:space="preserve">
          <source>When the SNMP manager has crashed, the dependent client application has to wait for the SNMP manager to be restarted before it can &lt;strong&gt;reconnect&lt;/strong&gt;.</source>
          <target state="translated">SNMP管理器崩溃后，从属客户端应用程序必须等待SNMP管理器重新启动才能&lt;strong&gt;重新连接&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a13e96b0328435d455e574296b3ea29ea96cf675" translate="yes" xml:space="preserve">
          <source>When the agent receives a request, it keeps the request ID for one second after the response is sent. If the agent receives another request with the same request ID during this time, from the same IP address and UDP port, that request will be discarded. This mechanism has nothing to do with the function &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt;.</source>
          <target state="translated">代理收到请求后，在发送响应后，它将请求ID保留一秒钟。如果代理在此期间从相同的IP地址和UDP端口接收到另一个具有相同请求ID的请求，则该请求将被丢弃。该机制与 &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; 函数无关。</target>
        </trans-unit>
        <trans-unit id="c76ffb17b2706d88d3e12e2091f84905c555d5ff" translate="yes" xml:space="preserve">
          <source>When the agent receives the same get-request as above, a call will be made to &lt;code&gt;generic_access(get,&lt;/code&gt;'&lt;code&gt;IPADR')&lt;/code&gt;.</source>
          <target state="translated">当代理接收到与上述相同的get-request时，将对 &lt;code&gt;generic_access(get,&lt;/code&gt; ' &lt;code&gt;IPADR')&lt;/code&gt; 进行调用。</target>
        </trans-unit>
        <trans-unit id="e30c9dfb86cccb490ec9efbc09dc8bd03f78db74" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt; ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93278d10a2e49a183a4771ee8ba18b8f11a4c78" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="translated">异步操作完成后，将 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; 驱动程序入口函数。如果驱动程序条目中的 &lt;code&gt;ready_async&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，则调用 &lt;code&gt;async_free&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="6e4fc871235561b9de4001b6afe210bb33b42832" translate="yes" xml:space="preserve">
          <source>When the atom cache is setup correctly the control message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fda767b9fff4af850e8e6b34bac5b879c78132" translate="yes" xml:space="preserve">
          <source>When the choice of directories in the code path is &lt;code&gt;strict&lt;/code&gt;, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; is explicitly added to the code path, the code server does not load files from &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">当代码路径中的目录选择 &lt;code&gt;strict&lt;/code&gt; ，最终在代码路径中的目录就是所述目录。这意味着，例如，如果目录 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; 已明确添加到代码路径，则代码服务器不会从 &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; 加载文件。/mnesia-4.4.7/ebin。</target>
        </trans-unit>
        <trans-unit id="595027e4761ef02fd4bdabf68a245651bb72bd11" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt; ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85eceed499c5d35cfe880d316d8beaf6cbb94efc" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当另一端运行的命令终止时，可以发送以下消息以返回命令的退出状态。零 &lt;code&gt;exit_status&lt;/code&gt; 通常表示命令成功终止。调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt; 会发送此事件。</target>
        </trans-unit>
        <trans-unit id="cb875869619254295ad4372b7bde936078bc212a" translate="yes" xml:space="preserve">
          <source>When the compile server is enabled, &lt;code&gt;erlc&lt;/code&gt; will automatically use the server if it is started and start the server if has not already started. The server will terminate itself when it has been idle for some number of seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d64a299ff94a9ee47249f94cefcc624dd35a6f" translate="yes" xml:space="preserve">
          <source>When the compiler encounters the module attribute &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; in a module &lt;code&gt;Mod&lt;/code&gt;, it calls &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; and compares the result with the set of functions actually exported from &lt;code&gt;Mod&lt;/code&gt;, and issues a warning if any callback function is missing.</source>
          <target state="translated">当编译器遇到模块属性 &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; 在 &lt;code&gt;Mod&lt;/code&gt; 模块中，它调用 &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; 并将结果与​​实际从 &lt;code&gt;Mod&lt;/code&gt; 导出的函数集进行比较，并在缺少任何回调函数时发出警告。</target>
        </trans-unit>
        <trans-unit id="844a9525ff66b482554dce5aa81432bba7df925d" translate="yes" xml:space="preserve">
          <source>When the data has passed through an Ets table, &lt;code&gt;erts_debug:size/1&lt;/code&gt; and &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; return the same value. Sharing has been lost.</source>
          <target state="translated">当数据通过Ets表时， &lt;code&gt;erts_debug:size/1&lt;/code&gt; 和 &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; 返回相同的值。共享已丢失。</target>
        </trans-unit>
        <trans-unit id="0180fd29af0af06f5eb68c4a08485d210bd536c3" translate="yes" xml:space="preserve">
          <source>When the data is returned, we deallocate our data.</source>
          <target state="translated">当数据返回时,我们会对我们的数据进行deallocate。</target>
        </trans-unit>
        <trans-unit id="b841886acb544968ed7c8d220277846a17d2018c" translate="yes" xml:space="preserve">
          <source>When the driver has passed the &lt;code&gt;driver_entry&lt;/code&gt; over to the emulator, the driver is &lt;strong&gt;not&lt;/strong&gt; allowed to modify the &lt;code&gt;driver_entry&lt;/code&gt;.</source>
          <target state="translated">当驾驶员已通过 &lt;code&gt;driver_entry&lt;/code&gt; 到模拟器，司机&lt;strong&gt;没有&lt;/strong&gt;允许修改 &lt;code&gt;driver_entry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff1b7d404a057ddcb6ce2d59d8b2bdb057597c3d" translate="yes" xml:space="preserve">
          <source>When the driver is implemented, one would preferably write an Erlang interface for the driver to be able to test the functionality of the driver separately. This interface can then be used by the distribution module, which will cover the details of the protocol from the &lt;code&gt;net_kernel&lt;/code&gt;.</source>
          <target state="translated">当实现驱动程序时，最好为驱动程序编写一个Erlang接口，以便能够分别测试驱动程序的功能。然后，分发模块可以使用此接口，分发模块将覆盖 &lt;code&gt;net_kernel&lt;/code&gt; 中协议的详细信息。</target>
        </trans-unit>
        <trans-unit id="4f7f8ef65dc76d982cfe0dc69232e4e5827bba12" translate="yes" xml:space="preserve">
          <source>When the driver is loaded. This callback must have a special name and inform the emulator of what callbacks are to be used by returning a pointer to a &lt;code&gt;ErlDrvEntry&lt;/code&gt; struct, which is to be properly filled in (see below).</source>
          <target state="translated">驱动程序加载时。此回调必须具有特殊名称，并通过返回指向 &lt;code&gt;ErlDrvEntry&lt;/code&gt; 结构的指针来告知仿真器要使用的回调，该指针将被正确填充（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="68f883c088fbc777f98b15d9733f9e21c9a4e592" translate="yes" xml:space="preserve">
          <source>When the emulator is run with instrumentation, the &lt;code&gt;system&lt;/code&gt; value is more accurate, but memory directly allocated for &lt;code&gt;malloc&lt;/code&gt; (and friends) is still not part of the &lt;code&gt;system&lt;/code&gt; value. Direct calls to &lt;code&gt;malloc&lt;/code&gt; are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</source>
          <target state="translated">当仿真器与工具一起运行时， &lt;code&gt;system&lt;/code&gt; 值更加准确，但是直接分配给 &lt;code&gt;malloc&lt;/code&gt; （和好友）的内存仍然不是 &lt;code&gt;system&lt;/code&gt; 值的一部分。对 &lt;code&gt;malloc&lt;/code&gt; 的直接调用只能从特定于OS的运行时库中完成，也可以从用户实现的Erlang驱动程序中完成，这些驱动程序不使用驱动程序接口中的内存分配功能。</target>
        </trans-unit>
        <trans-unit id="77fa82a9f2b1030c7423dea145244305c2d9ec50" translate="yes" xml:space="preserve">
          <source>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</source>
          <target state="translated">当到达二进制结束,第二个子句匹配时,匹配上下文将被简单地丢弃(在下一次垃圾收集中删除,因为不再有任何引用)。</target>
        </trans-unit>
        <trans-unit id="6749f7e62fded072722b2a6ba9f855671542a797" translate="yes" xml:space="preserve">
          <source>When the external process connected to the port exits, a message of the form &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; is sent to the connected process, where &lt;code&gt;Status&lt;/code&gt; is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</source>
          <target state="translated">当连接到端口的外部进程退出时， &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; 连接的进程发送{Port，{exit_status，Status}}形式的消息，其中 &lt;code&gt;Status&lt;/code&gt; 是外部进程的退出状态。如果程序在Unix上中止，则使用与Shell相同的约定（即128+信号）。</target>
        </trans-unit>
        <trans-unit id="df6072405416eb31c392fea08909d3e8e4bb8601" translate="yes" xml:space="preserve">
          <source>When the first SMP support was implemented, the table still was kept more or less the same way, but protected by two types of locks. One lock that protected the whole table against modifications and an array of locks protecting different parts of the table. The exact locking strategy previously used isn't interesting. What is interesting is that it suffered from heavy lock contention especially when lots of modifications was being made, but also when only performing lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4264b7112b0cfbe36495f0cf35a65dd07c402f" translate="yes" xml:space="preserve">
          <source>When the function &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; cannot be used, &lt;code&gt;Mnesia&lt;/code&gt; provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</source>
          <target state="translated">当无法使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;Mnesia&lt;/code&gt; 将为程序员提供多个函数，用于根据模式匹配记录。以下是最有用的：</target>
        </trans-unit>
        <trans-unit id="0a19808ffaca3fd048abe14ac1422112fae7f8be" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt;, one can get information about when the driver is &lt;strong&gt;actually&lt;/strong&gt; loaded by using option &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt;.</source>
          <target state="translated">当函数返回 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 或 &lt;code&gt;{ok, pending_process}&lt;/code&gt; ，可以使用选项 &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt; 获取有关何时&lt;strong&gt;实际&lt;/strong&gt;加载驱动程序的信息。</target>
        </trans-unit>
        <trans-unit id="f1ba8ad7fadddd0bcf392a93e44763cd846c6e5a" translate="yes" xml:space="preserve">
          <source>When the indexed set is a set of subsets of a set X, we call x a &lt;strong id=&quot;family&quot;&gt;family of subsets&lt;/strong&gt; of X.</source>
          <target state="translated">当索引集是一组X的子集时，我们称xa 为X &lt;strong id=&quot;family&quot;&gt;的子集族&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b2e8e9476aa05c51f4eed310e674f5ac07849f6f" translate="yes" xml:space="preserve">
          <source>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</source>
          <target state="translated">当初始消息到达时,传输服务将其转发到协议引擎,协议引擎自动建立连接,并调用UserMod:handle_connect/2,然后再调用UserMod:handle_trans_request/3与服务变更请求,像这样。</target>
        </trans-unit>
        <trans-unit id="0b479e3b528c8dff428a540e36a91f070ee36f40" translate="yes" xml:space="preserve">
          <source>When the instrumentation function for the distributed table is called, the request should be forwarded to the table coordinator. The coordinator finds the requested information among the table holders and then returns the answer to the instrumentation function. The SNMP toolkit contains no support for coordination of tables since this must be independent of the implementation.</source>
          <target state="translated">调用分布式表的仪表函数时,应将请求转给表协调器。协调器在表持有者中找到所请求的信息,然后将答案返回给仪表函数。SNMP工具包中不包含对表协调的支持,因为这必须独立于实现。</target>
        </trans-unit>
        <trans-unit id="ed66203a9ff8a8d98b96888faa38dea3f3883c7b" translate="yes" xml:space="preserve">
          <source>When the leader threads is about to increment the global thread progress counter it verifies that the &lt;code&gt;waiting&lt;/code&gt; counter is zero before doing so. If not zero, the leader isn't allowed to increment the global counter, and needs to wait before it can do this. When it is zero, it swaps the &lt;code&gt;waiting&lt;/code&gt; and &lt;code&gt;current&lt;/code&gt; counters before increasing the global counter. From now on the new &lt;code&gt;waiting&lt;/code&gt; counter will decrease, so that it eventually will reach zero, making it possible to increment the global counter the next time. If we only used one reference counter it would potentially be held above zero for ever by different unmanaged threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdd5b69553712e53dab4940441e84bad5a0b9c4" translate="yes" xml:space="preserve">
          <source>When the loader has found a match and replaced the matched instructions, it will match the new instructions against the transformation rules. Because of that, we can define the rule for a &lt;code&gt;move3/6&lt;/code&gt; instruction as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9cfdd647592377ae23a5bc7ddcc96274b2c1de" translate="yes" xml:space="preserve">
          <source>When the loader translates a generic instruction a specific instruction, it will choose the most specific instruction that will fit the types. Consider the following two instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4612fb76d339a555d7ce395426dfd7559ca7e3" translate="yes" xml:space="preserve">
          <source>When the logs are full, &lt;code&gt;run_erl&lt;/code&gt; deletes and reuses the oldest log file.</source>
          <target state="translated">当日志已满时， &lt;code&gt;run_erl&lt;/code&gt; 删除并重新使用最早的日志文件。</target>
        </trans-unit>
        <trans-unit id="981906d024a846c5ad60dd39439e2525942f2a29" translate="yes" xml:space="preserve">
          <source>When the message queue grows larger than this threshold, the handler switches to a mode in which it drops all new events that senders want to log. Dropping an event in this mode means that the call to the log function never results in a message being sent to the handler, but the function returns without taking any action. The handler keeps logging the events that are already in its message queue, and when the length of the message queue is reduced to a level below the threshold, synchronous or asynchronous mode is resumed. Notice that when the handler activates or deactivates drop mode, information about it is printed in the log.</source>
          <target state="translated">当消息队列大于这个阈值时,处理程序就会切换到一种模式,在这种模式下,处理程序会丢弃所有发送者想要记录的新事件。在这种模式下丢弃一个事件意味着对日志函数的调用永远不会导致消息被发送到处理程序,而是函数返回而不采取任何行动。处理程序继续记录已经在其消息队列中的事件,当消息队列的长度减少到低于阈值的水平时,同步或异步模式就会恢复。注意,当处理程序激活或停用投递模式时,相关信息会打印在日志中。</target>
        </trans-unit>
        <trans-unit id="377865ca162dc01a005c1cf33711bbbcf3cf6d3a" translate="yes" xml:space="preserve">
          <source>When the modifier &lt;code&gt;l&lt;/code&gt; is specified, no detection of printable character lists takes place, for example:</source>
          <target state="translated">指定修饰符 &lt;code&gt;l&lt;/code&gt; 时，不会检测可打印字符列表，例如：</target>
        </trans-unit>
        <trans-unit id="28bc31ee472c6a6f71d309884c8eb89c306960b4" translate="yes" xml:space="preserve">
          <source>When the monitor is triggered a &lt;code&gt;'CHANGE'&lt;/code&gt; message is sent to the monitoring process. A &lt;code&gt;'CHANGE'&lt;/code&gt; message has the following pattern:</source>
          <target state="translated">触发监视器后， &lt;code&gt;'CHANGE'&lt;/code&gt; 消息将发送到监视过程。阿 &lt;code&gt;'CHANGE'&lt;/code&gt; 消息具有以下模式：</target>
        </trans-unit>
        <trans-unit id="3d47c0ec76e9a52aa79d01cf4b6274b0076998f6" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the limit, each scheduler has its own group. When the number of schedulers is larger than the groups limit, schedulers share groups. Shared groups degrade the performance for updating counters while many reader groups degrade the performance for reading counters. So, the limit is a tradeoff between performance for update operations and performance for read operations. Each group consumes 64 bytes in each counter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6576c399613f943fdf757c4457a0db8dddece67" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the reader groups limit, each scheduler has its own reader group. When the number of schedulers is larger than the reader groups limit, schedulers share reader groups. Shared reader groups degrade read lock and read unlock performance while many reader groups degrade write lock performance. So, the limit is a tradeoff between performance for read operations and performance for write operations. Each reader group consumes 64 byte in each read/write lock.</source>
          <target state="translated">当调度器的数量小于或等于读者组限制时,每个调度器有自己的读者组。当调度器的数量大于读者组限制时,调度器共享读者组。共享读者组会降低读锁和读解锁性能,而很多读者组会降低写锁性能。所以,这个限制是读操作的性能和写操作的性能之间的权衡。每个读者组在每次读/写锁中消耗64个字节。</target>
        </trans-unit>
        <trans-unit id="36226219dde60c8da7ee7e2f3ead5fe94e62e1f9" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;maps&lt;/code&gt; is given, no &lt;code&gt;.hrl&lt;/code&gt; files will be generated. The rest of this section describes the behavior of the compiler when &lt;code&gt;maps&lt;/code&gt; is not used.</source>
          <target state="translated">给出选项 &lt;code&gt;maps&lt;/code&gt; ，将不会生成 &lt;code&gt;.hrl&lt;/code&gt; 文件。本节的其余部分描述了不使用 &lt;code&gt;maps&lt;/code&gt; 时编译器的行为。</target>
        </trans-unit>
        <trans-unit id="a3aa9d256c6870da7786d0742b3407e51201c5bd" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a21311cf0fcf49981af7057a09551734c3f7b1" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="translated">当选项 &lt;code&gt;verify&lt;/code&gt; 设置为 &lt;code&gt;verify_peer&lt;/code&gt; 时，除了通常的x509路径验证检查之外，还将执行检查 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 。如果检查失败，则会将错误{bad_cert，hostname_check_failed}传播到路径验证 &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; ，在这里可以使用 &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API 的所有功能进行自定义检查。当选项 &lt;code&gt;server_name_indication&lt;/code&gt; 提供，其值（DNS名称）将被用作 &lt;code&gt;ReferenceID&lt;/code&gt; 到 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 。如果未提供 &lt;code&gt;server_name_indication&lt;/code&gt; 选项，则 &lt;code&gt;Host&lt;/code&gt; 参数将用作服务器名称指示扩展名。该 &lt;code&gt;Host&lt;/code&gt; 的参数也将被用于 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 检查，如果 &lt;code&gt;Host&lt;/code&gt; 参数是 &lt;code&gt;inet:ip_address()&lt;/code&gt; 的 &lt;code&gt;ReferenceID&lt;/code&gt; 用于检查将是 &lt;code&gt;{ip, Host}&lt;/code&gt; 否则 &lt;code&gt;dns_id&lt;/code&gt; 将与回退到假定 &lt;code&gt;ip&lt;/code&gt; 如果失败。</target>
        </trans-unit>
        <trans-unit id="a93a77e10e8decc9a9a5af353d5ffa646066813a" translate="yes" xml:space="preserve">
          <source>When the port has been opened, the driver can be called. In the &lt;code&gt;pg_sync&lt;/code&gt; example, we do not have any data from the port, only the return value from the &lt;code&gt;port_control&lt;/code&gt;.</source>
          <target state="translated">打开端口后，可以调用驱动程序。在 &lt;code&gt;pg_sync&lt;/code&gt; 示例中，我们没有来自端口的任何数据，只有 &lt;code&gt;port_control&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="fc2960ec142372aacf524e3c02cb29b3deda53c6" translate="yes" xml:space="preserve">
          <source>When the port is in &lt;code&gt;data&lt;/code&gt; mode, all data is sent to Erlang in a format that suits the distribution. In fact, the raw data will never reach any Erlang process, but will be translated/interpreted by the emulator itself and then delivered in the correct format to the correct processes. In the current emulator version, received data is to be tagged with a single byte of 100. That is what the macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; is defined to. The tagging of data in the distribution can be changed in the future.</source>
          <target state="translated">当端口处于 &lt;code&gt;data&lt;/code&gt; 模式时，所有数据都以适合分发的格式发送到Erlang。实际上，原始数据将永远不会到达任何Erlang进程，而是将由仿真器本身进行翻译/解释，然后以正确的格式传递给正确的进程。在当前的仿真器版本中，接收到的数据将用单个字节100进行标记。这就是宏 &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; 的定义。分发中的数据标签将来可以更改。</target>
        </trans-unit>
        <trans-unit id="14aeddf1e34ec4456d4c5825309b75866f73f2c8" translate="yes" xml:space="preserve">
          <source>When the ports internal output queue size becomes larger than or equal to &lt;code&gt;High&lt;/code&gt; bytes, it enters the busy state. When it becomes less than &lt;code&gt;Low&lt;/code&gt; bytes it leaves the busy state. When the port is in the busy state, processes sending commands to it will be suspended until the port leaves the busy state. Commands are in this context either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59898e3066f19ccd1cc5fc312adea30ee33171ba" translate="yes" xml:space="preserve">
          <source>When the ports message queue size becomes larger than or equal to &lt;code&gt;High&lt;/code&gt; bytes it enters the busy state. When it becomes less than &lt;code&gt;Low&lt;/code&gt; bytes it leaves the busy state. When the port message queue is in the busy state, processes sending commands to it will be suspended until the port message queue leaves the busy state. Commands are in this context either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a5fc45c74e8bc2edca91ff415618981adda324" translate="yes" xml:space="preserve">
          <source>When the protocol is available to Erlang through a driver and an Erlang interface module, a distribution module can be written. The distribution module is a module with well-defined callbacks, much like a &lt;code&gt;gen_server&lt;/code&gt; (there is no compiler support for checking the callbacks, though). This module implements:</source>
          <target state="translated">当协议通过驱动程序和Erlang接口模块可用于Erlang时，可以编写分发模块。分发模块是具有明确定义的回调的模块，非常类似于 &lt;code&gt;gen_server&lt;/code&gt; （尽管编译器不支持检查回调）。该模块实现：</target>
        </trans-unit>
        <trans-unit id="be29dce95eec97a67e2087b38e94bd51a5e3dde0" translate="yes" xml:space="preserve">
          <source>When the queue contains data, the driver does not close until the queue is empty.</source>
          <target state="translated">当队列包含数据时,驱动程序不会关闭,直到队列清空。</target>
        </trans-unit>
        <trans-unit id="21ba1599707f578e6da25bafa5c66c03f204937f" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the &lt;code&gt;heart&lt;/code&gt; program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</source>
          <target state="translated">当发布处理程序遇到指令时，它首先生成一个临时启动文件，该文件将启动仿真器和核心应用程序的新版本以及所有其他应用程序的旧版本。然后，它通过调用 &lt;code&gt;init:reboot()&lt;/code&gt; 来关闭当前仿真器，请参阅内核中的 &lt;code&gt;init(3)&lt;/code&gt; 手册页。使用临时启动文件，所有进程都会正常终止，并且由 &lt;code&gt;heart&lt;/code&gt; 程序重新启动系统。重新引导后，将执行其余的relup指令。这是作为临时启动脚本的一部分完成的。</target>
        </trans-unit>
        <trans-unit id="cee98f8753d15dee1e12f17349a48be34b074873" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it shuts down the emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the &lt;code&gt;heart&lt;/code&gt; program using the new release version. No more upgrade instruction is executed after the restart.</source>
          <target state="translated">当释放处理程序遇到指令时，它通过调用 &lt;code&gt;init:reboot()&lt;/code&gt; 来关闭仿真器，请参见内核中的 &lt;code&gt;init(3)&lt;/code&gt; 手册页。所有进程都会正常终止，然后可以使用新的发行版本由 &lt;code&gt;heart&lt;/code&gt; 程序重新启动系统。重新启动后不再执行任何升级指令。</target>
        </trans-unit>
        <trans-unit id="a250d269026a9e3f5fca66518f55dd84f05c8c5d" translate="yes" xml:space="preserve">
          <source>When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_cast(Request, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{noreply,State1}&lt;/code&gt;. &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">收到请求后， &lt;code&gt;gen_server&lt;/code&gt; 调用 &lt;code&gt;handle_cast(Request, State)&lt;/code&gt; ，该方法将返回一个元组 &lt;code&gt;{noreply,State1}&lt;/code&gt; 。 &lt;code&gt;State1&lt;/code&gt; 是 &lt;code&gt;gen_server&lt;/code&gt; 的状态的新值。</target>
        </trans-unit>
        <trans-unit id="8d57c2ee62a9879fde2097882cf19d4663d2b600" translate="yes" xml:space="preserve">
          <source>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns &lt;code&gt;true&lt;/code&gt; to let the shell go ahead with the evaluation, or &lt;code&gt;false&lt;/code&gt; to abort it. There are two possible callback functions for the user to implement:</source>
          <target state="translated">当受限制的外壳程序计算表达式并遇到函数调用或运算符应用程序时，它将调用回调函数（带有有关所讨论函数调用的信息）。该回调函数返回 &lt;code&gt;true&lt;/code&gt; ,以使外壳程序继续进行评估；返回 &lt;code&gt;false&lt;/code&gt; ,以中止评估。有两种可能的回调函数供用户实现：</target>
        </trans-unit>
        <trans-unit id="c54c402919b78665c1c8f198f292bab9fc59cd16" translate="yes" xml:space="preserve">
          <source>When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type.</source>
          <target state="translated">当服务器被要求提供一个无法由MIME类型设置确定的文档类型时,服务器会使用这个默认类型。</target>
        </trans-unit>
        <trans-unit id="bb82b8ca8c5a5957509c8e72df7e62feb33df317" translate="yes" xml:space="preserve">
          <source>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a &lt;code&gt;job&lt;/code&gt;. Only the current job, which is said to be &lt;code&gt;connected&lt;/code&gt;, can perform operations with standard I/O. All other jobs, which are said to be &lt;code&gt;detached&lt;/code&gt;, are &lt;code&gt;blocked&lt;/code&gt; if they attempt to use standard I/O.</source>
          <target state="translated">Shell启动时，它将启动一个评估程序。该过程及其产生的任何本地过程都称为 &lt;code&gt;job&lt;/code&gt; 。只有当前的作业（据说已 &lt;code&gt;connected&lt;/code&gt; ）才能使用标准I / O执行操作。所有其他的工作，这是说要 &lt;code&gt;detached&lt;/code&gt; ，被 &lt;code&gt;blocked&lt;/code&gt; ，如果他们试图使用标准I / O。</target>
        </trans-unit>
        <trans-unit id="3c74035ba1de254b56bab74be22512784e14aa0a" translate="yes" xml:space="preserve">
          <source>When the size of all received requests exceeds &lt;code&gt;trans_req_maxsize&lt;/code&gt;.</source>
          <target state="translated">当所有接收到的请求的大小超过 &lt;code&gt;trans_req_maxsize&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="bf7ff81cd7bcbcf93265972ba220ec58a44a2621" translate="yes" xml:space="preserve">
          <source>When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt; is called as:</source>
          <target state="translated">当发生指定事件时，函数 &lt;code&gt;Function&lt;/code&gt; 称为：</target>
        </trans-unit>
        <trans-unit id="a9b740db20f360e56cbaf192b02a625103f61f81" translate="yes" xml:space="preserve">
          <source>When the supervisor terminates, then the next higher-level supervisor takes some action. It either restarts the terminated supervisor or terminates itself.</source>
          <target state="translated">当主管终止时,那么下一个更高级别的主管就会采取一些行动。它要么重新启动被终止的主管,要么自己终止。</target>
        </trans-unit>
        <trans-unit id="4bf56603de100efc3ae31dee0fc9c437fdd57542" translate="yes" xml:space="preserve">
          <source>When the thread progress functionality had been introduced, we could remove the code implementing the &quot;confirm deletion&quot; jobs, and then just schedule a thread progress later operation which deallocates the structure. Besides simplifying the code a lot, we got an increase of more than 10% of the number of transactions per second handled on a mnesia tpcb benchmark executing on a quad core machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f021b23bfe2cd55d1b599da584871e714016f843" translate="yes" xml:space="preserve">
          <source>When the timer finally expires, a &quot;megaco segments not received&quot; (459) error message is sent to the other side and the user is notified with a &lt;code&gt;segment timeout&lt;/code&gt;&lt;code&gt;UserReply&lt;/code&gt; in either the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function or the return value of the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">当定时器期满最后，一个&amp;ldquo;MEGACO段未接收&amp;rdquo;（459）的错误消息被发送到另一侧，并且用户与通知 &lt;code&gt;segment timeout&lt;/code&gt; &lt;code&gt;UserReply&lt;/code&gt; 无论是在 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 回调函数或返回值 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="10342b65ac706e0b7d9b742b8194ae1261e8bece" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf973279da0cedc632ba88c183b69c62e648346" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">当计时器达到 &lt;code&gt;0&lt;/code&gt; 并到期时，将调用驱动程序进入功能 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a9f3b6a59efe7a46474fcba7bb50d20a40f5897" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the request is resent and the timer is restarted.</source>
          <target state="translated">当定时器达到中间过期时,重新发送请求并重新启动定时器。</target>
        </trans-unit>
        <trans-unit id="fd4e877095aa4be1ada9827ad7529e4bc18e2c51" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer is restarted.</source>
          <target state="translated">当定时器达到中间过期时,重新启动定时器。</target>
        </trans-unit>
        <trans-unit id="157d3bfb09cfc45ece6b6d5a8c11a2c6035409d0" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer restarted.</source>
          <target state="translated">当定时器达到中间过期时,定时器重新启动。</target>
        </trans-unit>
        <trans-unit id="e2702c4a29cb7ffd2d62635fddc60ffda837b937" translate="yes" xml:space="preserve">
          <source>When the timer reaches the final expire, either the function &lt;code&gt;megaco:call&lt;/code&gt; will return with &lt;code&gt;{error, timeout}&lt;/code&gt; or the callback function &lt;code&gt;handle_trans_reply&lt;/code&gt; will be called with &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (if &lt;code&gt;megaco:cast&lt;/code&gt; was used).</source>
          <target state="translated">当计时器达到最后期限时，函数 &lt;code&gt;megaco:call&lt;/code&gt; 将返回 &lt;code&gt;{error, timeout}&lt;/code&gt; 或回调函数 &lt;code&gt;handle_trans_reply&lt;/code&gt; 将被 &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; 调用（如果使用了megaco &lt;code&gt;megaco:cast&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5d489b1aa41c1da0731c58c4d8333c65b8fb249f" translate="yes" xml:space="preserve">
          <source>When the tracing is completed, stop the tracer with &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; and format the trace log with &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (if there is anything to format).</source>
          <target state="translated">跟踪完成后，请使用 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; 停止跟踪程序，并使用 &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; 格式化跟踪日志（如果有任何要格式化的内容）。</target>
        </trans-unit>
        <trans-unit id="c36338011eef64525211dd65889fb16a9937ec35" translate="yes" xml:space="preserve">
          <source>When the transaction sender receives a request which is already &quot;in storage&quot; (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the &lt;code&gt;trans_timer&lt;/code&gt; and the &lt;code&gt;request_timer&lt;/code&gt; is not properly chosen.</source>
          <target state="translated">当交易发送方收到已经&amp;ldquo;正在存储&amp;rdquo;的请求（由交易ID指示）时，将其视为重新发送，并发送所有存储的内容。如果未正确选择 &lt;code&gt;trans_timer&lt;/code&gt; 和 &lt;code&gt;request_timer&lt;/code&gt; 的值，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="7862d7ec18f93027c83a7039d6cf2d951465703f" translate="yes" xml:space="preserve">
          <source>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</source>
          <target state="translated">当用户在其回调函数中处理了一个交易请求后,Megaco应用程序组装一个交易回复,使用选定的编码模块进行编码,并通过调用回调函数将消息发送回来。</target>
        </trans-unit>
        <trans-unit id="17fcbf724175dd6197cb33c7a80fb993e93fef84" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop, or for backwards compatibility, an Apache-like configuration file. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="translated">在应用程序启动时启动Web服务器时，将从配置文件中获取属性，该配置文件可以包含常规的Erlang属性列表，即 &lt;code&gt;[{Option, Value}]&lt;/code&gt; ，其中 &lt;code&gt;Option = property()&lt;/code&gt; 和 &lt;code&gt;Value = term()&lt;/code&gt; ，后跟句号，或者为了向后兼容，是一个类似Apache的配置文件。如果Web服务器在运行时动态启动，则仍然可以指定文件，但也可以指定完整的属性列表。</target>
        </trans-unit>
        <trans-unit id="0f19d5cdc9a0560a6838aca779192793025acf9d" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8385f08e883f730c6d6877fd915bdc9c53f2091" translate="yes" xml:space="preserve">
          <source>When the whole driver is unloaded. Every resource allocated by the driver is to be freed.</source>
          <target state="translated">当整个驱动程序被卸载后。驱动程序分配的每一个资源都要被释放。</target>
        </trans-unit>
        <trans-unit id="1864bbfe1bb4da0ed39ef620a0d58a044889dcf3" translate="yes" xml:space="preserve">
          <source>When the window (terminal) size changes on the client side, it &lt;strong&gt;can&lt;/strong&gt; send a message to the server side to inform it of the new dimensions. No API function generates this event.</source>
          <target state="translated">当客户端上的窗口（终端）大小更改时，它&lt;strong&gt;可以&lt;/strong&gt;向服务器端发送消息以通知其新尺寸。没有API函数生成此事件。</target>
        </trans-unit>
        <trans-unit id="6ae6cb0d1aeff4baecd961c38c7a0d0343bce682" translate="yes" xml:space="preserve">
          <source>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating &lt;code&gt;Expr&lt;/code&gt;) if all filters are true or an empty list otherwise.</source>
          <target state="translated">当没有生成器或位字符串生成器时，如果所有过滤器均为true ，则列表推导将返回带有一个元素的列表（评估 &lt;code&gt;Expr&lt;/code&gt; 的结果），否则返回空列表。</target>
        </trans-unit>
        <trans-unit id="68c8a10137c4675b33b04fc152e8dd169fb08630" translate="yes" xml:space="preserve">
          <source>When there are no more objects in the table, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">当表中没有更多对象时，将返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="745f9cd3851e711d348b63ccc23a8f52273edfe7" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, &lt;code&gt;qlc&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">当键位置只有简单的限制时， &lt;code&gt;qlc&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; 查找键。如果不可能，则遍历整个表。选项 &lt;code&gt;traverse&lt;/code&gt; 确定如何完成此操作：</target>
        </trans-unit>
        <trans-unit id="a97d09e0174e7ebcd752be249e317734288c7fe5" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, QLC uses &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">当键位置仅有简单限制时，QLC使用 &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; 查找键。如果不可能，则遍历整个表。选项 &lt;code&gt;traverse&lt;/code&gt; 确定如何完成此操作：</target>
        </trans-unit>
        <trans-unit id="1432344868741e2698e6a9b96d60c2837b98772c" translate="yes" xml:space="preserve">
          <source>When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).</source>
          <target state="translated">如果没有混淆的风险，则可以使用集合所代表的集合来标识集合的元素。例如，如果U是使用S1和S2作为参数调用 &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; 的结果，则称U为S1和S2的联合。更精确的表述是Set（U）是Set（S1）和Set（S2）的并集。</target>
        </trans-unit>
        <trans-unit id="3340db1e6247a69837f2ad75c699140be306fabf" translate="yes" xml:space="preserve">
          <source>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</source>
          <target state="translated">当这个参数被删除时,在仿真器启动时将确定最终要使用的CPU拓扑结构。</target>
        </trans-unit>
        <trans-unit id="2478ca4237a9acca28df2597c10ba062104b18b0" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt; erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b43ec86ba8c916251f60d0bb263cce04f4688f6" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="translated">指定此标志后，链接的驱动程序必须使用 &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt; 手动确认端口已成功启动。这允许实现 &lt;code&gt;badarg&lt;/code&gt; 在完成一些初始的异步初始化之后，使用badarg使 &lt;code&gt;erlang:open_port&lt;/code&gt; 退出。</target>
        </trans-unit>
        <trans-unit id="a6c9e4e469cc7c78f5cf4d1f7fdc335fb16bb6a9" translate="yes" xml:space="preserve">
          <source>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function &lt;code&gt;raise/2&lt;/code&gt; without interfering with each other.</source>
          <target state="translated">当此功能在事务中执行时，在不同节点上运行的多个进程可以同时执行功能 &lt;code&gt;raise/2&lt;/code&gt; ,而不会互相干扰。</target>
        </trans-unit>
        <trans-unit id="25a15353480dd77dab8bbc5928bb6f70d413dc62" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt; start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5be18c956ae3c742f6fbc74a81c84e27f37de5" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="translated">调用此函数时，将返回启动 &lt;code&gt;erlang:open_port&lt;/code&gt; 调用，就好像刚刚调用了 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; 函数一样。仅当在链接的驱动程序上设置了标志 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; 时，才可以使用它。</target>
        </trans-unit>
        <trans-unit id="9f1d28b41ff3a8afa6eef2cd6d49d478529957d0" translate="yes" xml:space="preserve">
          <source>When this function is called with a list of certificate options; it generates a configuration with just one node certificate where &lt;code&gt;cacerts&lt;/code&gt; contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles.</source>
          <target state="translated">当使用证书选项列表调用此函数时；它生成仅带有一个节点证书的配置，其中 &lt;code&gt;cacerts&lt;/code&gt; 包含应提供给对等方的根证书和中间证书。在这种情况下，必须对所有对等方使用相同的根证书。例如，这在Erlang分布式群集中很有用，在该群集中，朝向另一个节点的任何节点都取决于谁与谁连接，充当服务器或客户端。生成的证书包含主题altname，客户端证书中不需要该主题altname，但是会使证书对两个角色都有用。</target>
        </trans-unit>
        <trans-unit id="08efe32cecc8061ee565bbd96c13cef9c271f062" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0dc82b5ddcdc81bd48ff82e4659150dc801ef9" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="translated">当使用包含客户端和服务器链规范的映射调用此函数时；它会生成客户端和服务器证书链，其中为服务器返回的 &lt;code&gt;cacerts&lt;/code&gt; 包含服务器应信任的根证书，以及服务器应提供给连接客户端的中间证书。服务器应信任的根证书是用作客户端证书链根的证书。反之亦然，适用于为客户返回的 &lt;code&gt;cacerts&lt;/code&gt; 。根证书可以使用 &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; 预先生成，也可以使用指定的选项生成；它是（它们）生成的。</target>
        </trans-unit>
        <trans-unit id="ef9a4bfdea86e7e0384f0eb8ca04b745e4df80d6" translate="yes" xml:space="preserve">
          <source>When this function is called, &lt;code&gt;*value_size&lt;/code&gt; is to contain the size of the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">调用此函数时， &lt;code&gt;*value_size&lt;/code&gt; 将包含 &lt;code&gt;value&lt;/code&gt; 缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="4f0658a8caa71ae8ec3af2aaa874893698a63c04" translate="yes" xml:space="preserve">
          <source>When this function is executed inside a transaction-context, it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在事务上下文中执行此函数时，它将返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcdfcd8239bab330841cc445bcf6b51860555e6e" translate="yes" xml:space="preserve">
          <source>When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.</source>
          <target state="translated">触发时,通过模式的前一条路径搜索具有相同名称的最近(*MARK)。如果找到了一个,&quot;bumpalong &quot;前进到对应于该(*MARK)的主题位置,而不是遇到(*SKIP)的位置。如果没有找到具有匹配名称的(*MARK),则忽略(*SKIP)。</target>
        </trans-unit>
        <trans-unit id="d7db68b788b90d41b1ce4140671c7e956cf1dfc1" translate="yes" xml:space="preserve">
          <source>When this mapping is used, insertion and deletion in the original Mnesia table is slower, with a factor O(log n). The read access is not affected.</source>
          <target state="translated">当使用这种映射时,原Mnesia表中的插入和删除速度较慢,系数为O(log n)。读取访问不受影响。</target>
        </trans-unit>
        <trans-unit id="c4aed8d8cd7303661b0a5b4d380d742f046b6a10" translate="yes" xml:space="preserve">
          <source>When this option is enabled the counters for the table size and memory consumption are distributed over several cache lines and the scheduling threads are mapped to one of those cache lines. The &lt;code&gt;erl&lt;/code&gt; option &lt;code&gt;+dcg&lt;/code&gt; can be used to control the number of cache lines that the counters are distributed over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb494176e860d606fcf89bbbcaf477ac48b4e483" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;false&lt;/code&gt;, which is default, an RST received from the TCP peer is treated as a normal close (as though an FIN was sent). A caller to &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; gets &lt;code&gt;{error, closed}&lt;/code&gt;. In active mode, the controlling process receives a &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; message, indicating that the peer has closed the connection.</source>
          <target state="translated">当此选项设置为 &lt;code&gt;false&lt;/code&gt; 时（默认情况下），将从TCP对等方接收到的RST视为正常关闭（就像已发送FIN一样）。 &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; 的调用者获得 &lt;code&gt;{error, closed}&lt;/code&gt; 。在活动模式下，控制进程收到 &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; 消息，指示对等方已关闭连接。</target>
        </trans-unit>
        <trans-unit id="cbf5b5ed25d2d89a0cbf4701083cbe10925b03a5" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;true&lt;/code&gt;, the table is optimized for frequent concurrent calls to operations that modify the tables size and/or its memory consumption (e.g., &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#delete-2&quot;&gt;delete/2&lt;/a&gt;&lt;/code&gt;). The drawback is that calls to &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt; as the second argument can get much slower when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7f5c99c2ce601b738e1cbcc7fe8e59a1211a42" translate="yes" xml:space="preserve">
          <source>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option &lt;code&gt;/m&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?m)&lt;/code&gt; option setting. If there are no newlines in a subject string, or no occurrences of &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a pattern, setting &lt;code&gt;multiline&lt;/code&gt; has no effect.</source>
          <target state="translated">指定此选项后，&amp;ldquo;行首&amp;rdquo;和&amp;ldquo;行尾&amp;rdquo;结构分别与主题字符串中的内部换行符紧接或紧接，也恰好位于开头和结尾。这等效于Perl选项 &lt;code&gt;/m&lt;/code&gt; ,并且可以通过 &lt;code&gt;(?m)&lt;/code&gt; 选项设置在模式内进行更改。如果主题字符串中没有换行符，或者模式中没有出现 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; ，则设置 &lt;code&gt;multiline&lt;/code&gt; 行符无效。</target>
        </trans-unit>
        <trans-unit id="675f8d886654247d43dbcd4fe8a49b4d5b32073b" translate="yes" xml:space="preserve">
          <source>When this option is used, the result of &lt;code&gt;write/2&lt;/code&gt; calls can prematurely be reported as successful, and if a write error occurs, the error is reported as the result of the next file operation, which is not executed.</source>
          <target state="translated">使用此选项时， &lt;code&gt;write/2&lt;/code&gt; 调用的结果可能会过早报告为成功，并且如果发生写错误，则该错误将报告为下一个文件操作（不执行）的结果。</target>
        </trans-unit>
        <trans-unit id="79ca6f02ce20af0f54bdfcd5b4887c4b78fe59ff" translate="yes" xml:space="preserve">
          <source>When those instructions are loaded, the loader rewrites them to specific instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc30def2e6a5147d2d890feeb73645cc382d513" translate="yes" xml:space="preserve">
          <source>When time-out occurs, &lt;code&gt;Common Test&lt;/code&gt; never aborts the ongoing test case, as this can leave the SUT in an undefined, and possibly bad, state. Instead &lt;code&gt;Common Test&lt;/code&gt;, by default, finishes the current test run before stopping. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified, &lt;code&gt;Common Test&lt;/code&gt; stops when the current test job is finished. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified with &lt;code&gt;skip_rest&lt;/code&gt;, &lt;code&gt;Common Test&lt;/code&gt; only completes the current test case and skips the remaining tests in the test job.</source>
          <target state="translated">发生超时时， &lt;code&gt;Common Test&lt;/code&gt; 永远不会中止正在进行的测试用例，因为这可能会使SUT处于未定义的状态，甚至可能是错误的状态。相反， &lt;code&gt;Common Test&lt;/code&gt; 默认情况下会在停止之前完成当前测试运行。如果指定了标志 &lt;code&gt;force_stop&lt;/code&gt; ，则当前测试作业完成后， &lt;code&gt;Common Test&lt;/code&gt; 停止。如果标志 &lt;code&gt;force_stop&lt;/code&gt; 与指定 &lt;code&gt;skip_rest&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 只完成当前的测试用例，并跳过在测试工作中剩余的测试。</target>
        </trans-unit>
        <trans-unit id="3b02470ac02b8a82a85b03a86594d121edb6f2f0" translate="yes" xml:space="preserve">
          <source>When to Use Mnesia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7496cb290358c83d75813f93e436cc9aa7801dbd" translate="yes" xml:space="preserve">
          <source>When to use a Sub-agent</source>
          <target state="translated">何时使用子代理</target>
        </trans-unit>
        <trans-unit id="25981ff4244a1ee87a90be438c90aa93aa36e1ed" translate="yes" xml:space="preserve">
          <source>When trace flag &lt;code&gt;call&lt;/code&gt; is set on a process, function calls are traced on that process if a trace pattern is set for the called function.</source>
          <target state="translated">在进程上设置跟踪标志 &lt;code&gt;call&lt;/code&gt; 时，如果为被调用函数设置了跟踪模式，则在该进程上跟踪函数调用。</target>
        </trans-unit>
        <trans-unit id="c8613cbf9cc57a98765708cdc22f9ed8559f964a" translate="yes" xml:space="preserve">
          <source>When trace output is desired, &lt;code&gt;debug&lt;/code&gt; is to be defined when the module &lt;code&gt;m&lt;/code&gt; is compiled:</source>
          <target state="translated">当需要跟踪输出时，将在编译模块 &lt;code&gt;m&lt;/code&gt; 时定义 &lt;code&gt;debug&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="256e90d704880ae674edcafcdfe9548c1c7249cd" translate="yes" xml:space="preserve">
          <source>When tracing a system of Mnesia applications it is useful to be able to interleave Mnesia own events with application-related events that give information about the application context.</source>
          <target state="translated">当追踪Mnesia应用系统时,能够将Mnesia自己的事件与应用相关的事件交错在一起,提供应用上下文的信息是很有用的。</target>
        </trans-unit>
        <trans-unit id="e113da41d29c2c3638afdbda456737663befd306" translate="yes" xml:space="preserve">
          <source>When tracing diskless nodes, &lt;code&gt;ttb&lt;/code&gt; must be started from an external &quot;trace control node&quot; with disk access, and &lt;code&gt;Client&lt;/code&gt; must be &lt;code&gt;{local, File}&lt;/code&gt;. All trace information is then sent to the trace control node where it is written to file.</source>
          <target state="translated">跟踪无盘节点时，必须从具有磁盘访问权限的外部&amp;ldquo;跟踪控制节点&amp;rdquo;启动 &lt;code&gt;ttb&lt;/code&gt; ，并且 &lt;code&gt;Client&lt;/code&gt; 必须是 &lt;code&gt;{local, File}&lt;/code&gt; 。然后，所有跟踪信息都发送到跟踪控制节点，并在其中写入文件。</target>
        </trans-unit>
        <trans-unit id="6193e77c0b9e8850c79e56437a7ff2bfa89554ed" translate="yes" xml:space="preserve">
          <source>When tracing function calls on a group leader process (an IO process), there is risk of causing a deadlock. This will happen if a group leader process generates a trace message and the tracer process, by calling the trace handler function, sends an IO request to the same group leader. The problem can only occur if the trace handler prints to tty using an &lt;code&gt;io&lt;/code&gt; function such as &lt;code&gt;format/2&lt;/code&gt;. Note that when &lt;code&gt;dbg:p(all,call)&lt;/code&gt; is called, IO processes are also traced. Here's an example:</source>
          <target state="translated">当跟踪功能调用组负责人进程（IO进程）时，存在造成死锁的风险。如果组长进程生成跟踪消息，并且跟踪程序进程通过调用跟踪处理程序功能将IO请求发送到同一组长，则会发生这种情况。仅当跟踪处理程序使用 &lt;code&gt;io&lt;/code&gt; 函数（例如 &lt;code&gt;format/2&lt;/code&gt; )打印到tty时，才会出现此问题。请注意，在 &lt;code&gt;dbg:p(all,call)&lt;/code&gt; ，还将跟踪IO进程。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="466360c3c9707d034db5517f5ba6f1db58ddb4ed" translate="yes" xml:space="preserve">
          <source>When tracing live systems, always take special care to not overload a node with too heavy tracing. &lt;code&gt;ttb&lt;/code&gt; provides option &lt;code&gt;overload&lt;/code&gt; to address this problem.</source>
          <target state="translated">跟踪活动系统时，请始终格外小心，以免因跟踪过多而使节点过载。 &lt;code&gt;ttb&lt;/code&gt; 提供选项 &lt;code&gt;overload&lt;/code&gt; 来解决此问题。</target>
        </trans-unit>
        <trans-unit id="1d713a6d3abef0dc19e9fef42b12e8d6a635ed21" translate="yes" xml:space="preserve">
          <source>When tracing there is no return value to produce, the match specification either matches or does not. The effect when the expression matches is a trace message rather than a returned term. The &lt;code&gt;ActionTerm&lt;/code&gt;s are executed as in an imperative language, that is, for their side effects. Functions with side effects are also allowed when tracing.</source>
          <target state="translated">跟踪时，没有要产生的返回值，匹配说明匹配或不匹配。表达式匹配时的效果是跟踪消息，而不是返回的术语。该 &lt;code&gt;ActionTerm&lt;/code&gt; s的在命令式语言，那就是，对于其副作用执行。跟踪时还允许具有副作用的功能。</target>
        </trans-unit>
        <trans-unit id="58e093b3869faaa26b1860581c9f3af042ac8ce5" translate="yes" xml:space="preserve">
          <source>When tracing to shell or &lt;code&gt;{local,File}&lt;/code&gt;, an ip trace driver is used internally. The ip trace driver has a queue of maximum &lt;code&gt;QueueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced, the queue size might be exceeded and messages are dropped. This parameter is optional, and is only useful if many &lt;code&gt;{drop,N}&lt;/code&gt; trace messages are received by the trace handler. It has no meaning if shell or &lt;code&gt;{local,File}&lt;/code&gt; is not used. See &lt;code&gt;dbg:trace_port/2&lt;/code&gt; for more information about the ip trace driver.</source>
          <target state="translated">跟踪到shell或 &lt;code&gt;{local,File}&lt;/code&gt; 时，将在内部使用ip跟踪驱动程序。 ip跟踪驱动程序具有最大 &lt;code&gt;QueueSize&lt;/code&gt; 消息等待发送的队列。如果驱动程序无法像生成消息一样快地传递消息，则可能会超出队列大小，并且消息将被丢弃。此参数是可选的，并且仅在跟踪处理程序收到许多 &lt;code&gt;{drop,N}&lt;/code&gt; 跟踪消息时才有用。如果不使用shell或 &lt;code&gt;{local,File}&lt;/code&gt; 则没有意义。有关ip跟踪驱动程序的更多信息，请参见 &lt;code&gt;dbg:trace_port/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="093fdd62c1610e46d6f27c6de1ab5ef2750cca76" translate="yes" xml:space="preserve">
          <source>When traversing the contents of &lt;code&gt;sys.config&lt;/code&gt; and a filename is encountered, its contents are read and merged with the result so far. When an application configuration tuple &lt;code&gt;{Application, Env}&lt;/code&gt; is found, it is merged with the result so far. Merging means that new parameters are added and existing parameter values overwritten.</source>
          <target state="translated">遍历 &lt;code&gt;sys.config&lt;/code&gt; 的内容并遇到文件名时，将读取其内容并将其与到目前为止的结果合并。找到应用程序配置元组 &lt;code&gt;{Application, Env}&lt;/code&gt; ，它将与到目前为止的结果合并。合并意味着添加新参数，并覆盖现有参数值。</target>
        </trans-unit>
        <trans-unit id="5c1a00c1646659dc3c25c531f96cba51c37aa323" translate="yes" xml:space="preserve">
          <source>When unregister the subagent using an &lt;code&gt;oid()&lt;/code&gt;, the &lt;code&gt;pid()&lt;/code&gt; of the process handling the sub-tree is also returned.</source>
          <target state="translated">使用 &lt;code&gt;oid()&lt;/code&gt; 取消注册子代理时，还将返回处理子树的进程的 &lt;code&gt;pid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="799f766e20f87f2dca4b1fd3e86f764dcd6d6a7e" translate="yes" xml:space="preserve">
          <source>When upgrading the emulator from a version older than OTP R15, an attempt is made to load new application beam code into the old emulator. Sometimes the new beam format cannot be read by the old emulator, so the code loading fails and the complete upgrade is terminated. To overcome this problem, the new application code is to be compiled with the old emulator. For more information about emulator upgrade from pre OTP R15 versions, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">从OTP R15之前的版本升级仿真器时，会尝试将新的应用程序波束代码加载到旧的仿真器中。有时，旧的仿真器无法读取新的波束格式，因此代码加载失败，并终止了完整的升级。为了克服这个问题，新的应用程序代码将与旧的仿真器一起编译。有关从OTP R15之前的版本升级仿真器的更多信息，请参见 &lt;code&gt;Design Principles&lt;/code&gt; &lt;strong&gt;系统文档&lt;/strong&gt;》中的&amp;ldquo; 设计原理&lt;strong&gt;&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d17b5ae381bac399583f6528ad1df0f425329627" translate="yes" xml:space="preserve">
          <source>When used together with a &lt;code&gt; Tracer Module&lt;/code&gt;, any message sent in the trace callback is guaranteed to have reached its recipient before the &lt;code&gt;trace_delivered&lt;/code&gt; message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c936186cbb39bacc2e228da8dc8dbbfc6f98893" translate="yes" xml:space="preserve">
          <source>When used together with a &lt;code&gt;Tracer Module&lt;/code&gt;, any message sent in the trace callback is guaranteed to have reached its recipient before the &lt;code&gt;trace_delivered&lt;/code&gt; message is sent.</source>
          <target state="translated">与 &lt;code&gt;Tracer Module&lt;/code&gt; 一起使用时，保证在trace回调中发送的任何消息在发送 &lt;code&gt;trace_delivered&lt;/code&gt; 消息之前已到达其收件人。</target>
        </trans-unit>
        <trans-unit id="79aeb596bfcda207847ddb49137293b64e87d84d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see Section &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the keys &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;vsn&lt;/code&gt;, &lt;code&gt;modules&lt;/code&gt;, &lt;code&gt;registered&lt;/code&gt;, and &lt;code&gt;applications&lt;/code&gt; are also to be specified:</source>
          <target state="translated">当使用 &lt;code&gt;systools&lt;/code&gt; 时，还应指定用于打包代码的Erlang / OTP工具（请参见&amp;ldquo; &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ），键 &lt;code&gt;description&lt;/code&gt; ， &lt;code&gt;vsn&lt;/code&gt; ， &lt;code&gt;modules&lt;/code&gt; ， &lt;code&gt;registered&lt;/code&gt; 和 &lt;code&gt;applications&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="aa09303e43191324a1721cf4208f1cd806ff1214" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;ttb&lt;/code&gt;, do not use module &lt;code&gt;dbg&lt;/code&gt; in application Runtime_Tools in parallel.</source>
          <target state="translated">使用 &lt;code&gt;ttb&lt;/code&gt; 时，请勿在应用程序Runtime_Tools中并行使用模块 &lt;code&gt;dbg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dced03c330435f63fc32590f93a202225ef052df" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;{active, once}&lt;/code&gt; or &lt;code&gt;{active, N}&lt;/code&gt;, the socket changes behavior automatically when data is received. This can be confusing in combination with connection-oriented sockets (that is, &lt;code&gt;gen_tcp&lt;/code&gt;), as a socket with &lt;code&gt;{active, false}&lt;/code&gt; behavior reports closing differently than a socket with &lt;code&gt;{active, true}&lt;/code&gt; behavior. To simplify programming, a socket where the peer closed, and this is detected while in &lt;code&gt;{active, false}&lt;/code&gt; mode, still generates message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; when set to &lt;code&gt;{active, once}&lt;/code&gt;, &lt;code&gt;{active, true}&lt;/code&gt;, or &lt;code&gt;{active, N}&lt;/code&gt; mode. It is therefore safe to assume that message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt;, possibly followed by socket port termination (depending on option &lt;code&gt;exit_on_close&lt;/code&gt;) eventually appears when a socket changes back and forth between &lt;code&gt;{active, true}&lt;/code&gt; and &lt;code&gt;{active, false}&lt;/code&gt; mode. However, &lt;strong&gt;when&lt;/strong&gt; peer closing is detected it is all up to the underlying TCP/IP stack and protocol.</source>
          <target state="translated">使用 &lt;code&gt;{active, once}&lt;/code&gt; 或 &lt;code&gt;{active, N}&lt;/code&gt; ，套接字在接收到数据时会自动更改行为。与面向连接的套接字（即 &lt;code&gt;gen_tcp&lt;/code&gt; ）结合使用时，这可能会造成混淆，因为具有 &lt;code&gt;{active, false}&lt;/code&gt; 行为的套接字报告的关闭方式不同于具有 &lt;code&gt;{active, true}&lt;/code&gt; 行为的套接字。为了简化编程，设置为 &lt;code&gt;{active, once}&lt;/code&gt; ， &lt;code&gt;{active, true}&lt;/code&gt; 或 &lt;code&gt;{active, N}&lt;/code&gt; }的套接字在对等体关闭的套接字在 &lt;code&gt;{active, false}&lt;/code&gt; 模式下被检测到时，仍会生成消息 &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; ，N}模式。因此可以安全地假设该消息 &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; 当套接字在 &lt;code&gt;{active, true}&lt;/code&gt; 和 &lt;code&gt;{active, false}&lt;/code&gt; 模式之间来回切换时，最终会出现{tcp_closed，Socket}，然后可能出现套接字端口终止（取决于选项 &lt;code&gt;exit_on_close&lt;/code&gt; ）。但是，&lt;strong&gt;当&lt;/strong&gt;检测到对等关闭时，完全取决于基础的TCP / IP堆栈和协议。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2fcb6b502d0fb8883fe722b0fb211f708e76b4ea" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, output the raw analysis results (Erlang terms) instead of the formatted result. The raw format is easier to post-process (for example, to filter warnings or to output HTML pages).</source>
          <target state="translated">当从命令行使用Dialyzer时,输出原始分析结果(Erlang术语)而不是格式化的结果。原始格式更容易进行后处理(例如,过滤警告或输出HTML页面)。</target>
        </trans-unit>
        <trans-unit id="895bf807f2bce58c7df0a72cbf3fb93cefba69cf" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, send the analysis results to the specified outfile rather than to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">从命令行使用Dialyzer时，将分析结果发送到指定的 &lt;code&gt;stdout&lt;/code&gt; 文件，而不是发送到stdout。</target>
        </trans-unit>
        <trans-unit id="da094abac8d6ebe76a11e697f4e1c5d8c383f3e5" translate="yes" xml:space="preserve">
          <source>When using Eprof, expect a slowdown in program execution.</source>
          <target state="translated">当使用Eprof时,预计程序执行速度会变慢。</target>
        </trans-unit>
        <trans-unit id="8ac2072110b05033591debd298147443f0f01fa0" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt;, the module must be loaded before the match specification is executed. If it is not loaded, the match fails.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt; ，必须在执行匹配规范之前加载该模块。如果未加载，则匹配失败。</target>
        </trans-unit>
        <trans-unit id="82031895868366a3e224c3ba1db5a77162e4744a" translate="yes" xml:space="preserve">
          <source>When using a cover specification in the testing of an OTP application itself, there is a special incl_app directive that includes the applications modules for the cover compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061184d8334715a1b4b165eee90f4c38b81216b" translate="yes" xml:space="preserve">
          <source>When using binary encoding, the structure of the termination id's needs to be specified.</source>
          <target state="translated">当使用二进制编码时,需要指定终止id的结构。</target>
        </trans-unit>
        <trans-unit id="2deedd12939c511eb728d0649b35683b342623a7" translate="yes" xml:space="preserve">
          <source>When using explicit session reuse, it is up to the client to make sure that the session being reused is for the correct server and has been verified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cb8889170e86b20dbe5a37d8a1c94a4de731e5" translate="yes" xml:space="preserve">
          <source>When using long node names, the code is slightly different as shown in the following example:</source>
          <target state="translated">当使用长节点名时,代码略有不同,如下例所示。</target>
        </trans-unit>
        <trans-unit id="f2766f8a1c9c5b824a82d01d204ba0da23305f93" translate="yes" xml:space="preserve">
          <source>When using one of the specialized decodes, exclusive or selective decode, instructions must be given in a configuration file. Option &lt;code&gt;asn1config&lt;/code&gt; enables specialized decodes and takes the configuration file in concern. The configuration file has the same name as the ASN.1 specification, but with extension &lt;code&gt;.asn1config&lt;/code&gt;.</source>
          <target state="translated">使用专用解码，专用解码或选择性解码之一时，必须在配置文件中给出指令。选项 &lt;code&gt;asn1config&lt;/code&gt; 启用专用解码，并考虑配置文件。配置文件的名称与ASN.1规范相同，但扩展名为 &lt;code&gt;.asn1config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db0b593e72759555e6318e54e37fd3dd78c4b583" translate="yes" xml:space="preserve">
          <source>When using text encoding(s), there is actually two different configs controlling what software to use:</source>
          <target state="translated">当使用文本编码时,实际上有两种不同的配置来控制使用什么软件。</target>
        </trans-unit>
        <trans-unit id="af478005c5fd2f7e42461532e879633e9b4ea1f1" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;aoffcaobf&lt;/code&gt; or &lt;code&gt;aoff&lt;/code&gt; strategies compared to &lt;code&gt;gf&lt;/code&gt; or &lt;code&gt;bf&lt;/code&gt;, we loose some performance since we get more modifications in the data structure of free blocks. This performance penalty is however reduced using the &lt;code&gt;aoffcbf&lt;/code&gt; strategy. A trade off between memory consumption and performance is however inevitable, and it is up to the user to decide what is most important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b22551cdbafd14a01ac76572f423a143928c5aa" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;load/unload&lt;/code&gt; interfaces, the driver is not unloaded until the &lt;strong&gt;last port&lt;/strong&gt; using the driver is closed. Function &lt;code&gt;unload/1&lt;/code&gt; can return immediately, as the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have no interrest in when the unloading occurs. The driver is unloaded when no one needs it any longer.</source>
          <target state="translated">使用 &lt;code&gt;load/unload&lt;/code&gt; 接口时，直到关闭使用驱动程序的&lt;strong&gt;最后一个端口后，&lt;/strong&gt;才会卸载驱动程序。函数 &lt;code&gt;unload/1&lt;/code&gt; 可以立即返回，因为 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 在进行卸载时不会中断。当没有人需要驱动程序时，将其卸载。</target>
        </trans-unit>
        <trans-unit id="3ebfa3ee9cf60736bbe38ab4cca43cd168ab98e8" translate="yes" xml:space="preserve">
          <source>When using the default configuration, the data to pass over a connection needs to be delivered as is to the node on the receiving end in the &lt;strong&gt;exact same order&lt;/strong&gt;, with no loss of data what so ever, as sent from the sending node.</source>
          <target state="translated">使用默认配置时，通过连接传递的数据需要按照&lt;strong&gt;完全相同的顺序按&lt;/strong&gt;原样传递到接收端的节点，而不会像从发送节点发送的那样丢失任何数据。</target>
        </trans-unit>
        <trans-unit id="0c053c5fc182ecd19f8594a98a6d280896669e6b" translate="yes" xml:space="preserve">
          <source>When using the internal format for logs, use functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt;. These functions log one or more Erlang terms. By prefixing each of the functions with a &lt;code&gt;b&lt;/code&gt; (for &quot;binary&quot;), we get the corresponding &lt;code&gt;blog()&lt;/code&gt; functions for the external format. These functions log one or more chunks of bytes. For example, to log the string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in ASCII format, you can use &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt;, or &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt;. The two alternatives are equally efficient.</source>
          <target state="translated">将内部格式用于日志时，请使用函数 &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt; 。这些函数记录一个或多个Erlang术语。通过为每个函数添加 &lt;code&gt;b&lt;/code&gt; 前缀（&amp;ldquo;二进制&amp;rdquo;），我们获得了对应于外部格式的 &lt;code&gt;blog()&lt;/code&gt; 函数。这些函数记录一个或多个字节块。例如，要以ASCII格式记录字符串 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; ，可以使用 &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt; 或 &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt; 。这两种选择同样有效。</target>
        </trans-unit>
        <trans-unit id="c6d8f8b78cb976ae93a575ca1c85babf22c1877d" translate="yes" xml:space="preserve">
          <source>When using the state object from this function the &lt;code&gt;rand&lt;/code&gt; functions using it may raise exception &lt;code&gt;error:low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a43444e4a47c6747c01683f8434e4d77e198b9" translate="yes" xml:space="preserve">
          <source>When using the state object from this function the &lt;code&gt;rand&lt;/code&gt; functions using it may throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">当使用此函数的状态对象时，使用随机函数的 &lt;code&gt;rand&lt;/code&gt; 函数可能会抛出异常 &lt;code&gt;low_entropy&lt;/code&gt; ，以防随机生成器由于缺乏安全的&amp;ldquo;随机性&amp;rdquo;而失败。</target>
        </trans-unit>
        <trans-unit id="f9cf555c8604c8a038c91aab86896c66a21405ac" translate="yes" xml:space="preserve">
          <source>When using version 3, then (at least one) &lt;strong&gt;usm user&lt;/strong&gt; has to be registered.</source>
          <target state="translated">使用版本3时，必须注册（至少一个）&lt;strong&gt;usm用户&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1bccd3c3f97050ab7f7ff6c15e170f7f244907e0" translate="yes" xml:space="preserve">
          <source>When we insert a new element in the table we do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38121095ce4330813b7271ee6f5a6273d4823735" translate="yes" xml:space="preserve">
          <source>When we search our &lt;code&gt;pooled_tree&lt;/code&gt; and find a carrier that is no longer in the pool, we remove that carrier from &lt;code&gt;pooled_tree&lt;/code&gt; and mark it as TRAITOR, as it is now employed by a foreign allocator. We will not find any carriers in &lt;code&gt;pooled_tree&lt;/code&gt; that are marked as BUSY by other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7bdbbb710766593c75e9261e59e0df0f24c88d" translate="yes" xml:space="preserve">
          <source>When white-box testing an Erlang application, it is useful to be able to measure the code coverage of the test. &lt;code&gt;Common Test&lt;/code&gt; provides simple access to the OTP Cover tool for this purpose. &lt;code&gt;Common Test&lt;/code&gt; handles all necessary communication with the Cover tool (starting, compiling, analysing, and so on). The &lt;code&gt;Common Test&lt;/code&gt; user only needs to specify the extent of the code coverage analysis.</source>
          <target state="translated">在对Erlang应用程序进行白盒测试时，能够衡量测试的代码覆盖范围很有用。 &lt;code&gt;Common Test&lt;/code&gt; 为此提供了对OTP Cover工具的简单访问。 &lt;code&gt;Common Test&lt;/code&gt; 使用Cover工具处理所有必要的通信（启动，编译，分析等）。在 &lt;code&gt;Common Test&lt;/code&gt; 用户只需要指定代码覆盖分析的程度。</target>
        </trans-unit>
        <trans-unit id="9f214ea79f2660a8546905638532084bd1af76b3" translate="yes" xml:space="preserve">
          <source>When working with binaries, you can get the horrible &quot;double UTF-8 encoding&quot;, where strange characters are encoded in your binaries or files. In other words, you can get a UTF-8 encoded binary that for the second time is encoded as UTF-8. A common situation is where you read a file, byte by byte, but the content is already UTF-8. If you then convert the bytes to UTF-8, using, for example, the &lt;code&gt;unicode&lt;/code&gt; module, or by writing to a file opened with option &lt;code&gt;{encoding,utf8}&lt;/code&gt;, you have each &lt;strong&gt;byte&lt;/strong&gt; in the input file encoded as UTF-8, not each character of the original text (one character can have been encoded in many bytes). There is no real remedy for this other than to be sure of which data is encoded in which format, and never convert UTF-8 data (possibly read byte by byte from a file) into UTF-8 again.</source>
          <target state="translated">使用二进制文件时，您会得到可怕的&amp;ldquo;双重UTF-8编码&amp;rdquo;，其中二进制文件或文件中编码有奇怪的字符。换句话说，您可以获得一个UTF-8编码的二进制，第二次被编码为UTF-8。常见的情况是您逐字节读取文件，但是内容已经是UTF-8。如果随后使用 &lt;code&gt;unicode&lt;/code&gt; 模块将字节转换为UTF-8，或者通过写入使用选项 &lt;code&gt;{encoding,utf8}&lt;/code&gt; 打开的文件，则每个&lt;strong&gt;字节&lt;/strong&gt;在以UTF-8编码的输入文件中，不是原始文本的每个字符（一个字符可以被编码为多个字节）。除了确保将哪种数据以哪种格式编码外，没有任何真正的补救方法，并且永远不要再将UTF-8数据（可能从文件中逐字节读取）再次转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="18992adf85d2ee51008faf55cc74f4f07c241bef" translate="yes" xml:space="preserve">
          <source>When would we want to turn off the prefetch in practice?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aa37a649829db83e3c9dedf652e7985f8d65bf" translate="yes" xml:space="preserve">
          <source>When writing a driver in C++, the driver entry is to be of &lt;code&gt;&quot;C&quot;&lt;/code&gt; linkage. One way to do this is to put the following line somewhere before the driver entry:</source>
          <target state="translated">用C ++编写驱动程序时，该驱动程序条目应为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 链接。一种方法是将以下行放在驱动程序入口之前：</target>
        </trans-unit>
        <trans-unit id="0855b2f59cc7fd85a55a378f3ac199542a22335d" translate="yes" xml:space="preserve">
          <source>When writing a driver to make a communications protocol available to Erlang, one should know just about everything worth knowing about that particular protocol. All operation must be non-blocking and all possible situations are to be accounted for in the driver. A non-stable driver will affect and/or crash the whole Erlang runtime system.</source>
          <target state="translated">当编写一个驱动来使Erlang可以使用一个通信协议时,应该了解关于那个特定协议的所有值得了解的东西。所有的操作都必须是非阻塞的,所有可能的情况都要在驱动程序中考虑到。一个不稳定的驱动程序将影响和/或使整个Erlang运行时系统崩溃。</target>
        </trans-unit>
        <trans-unit id="a72c2f5d7c0d4febcd9848b5e2d40ba7cee9b091" translate="yes" xml:space="preserve">
          <source>When writing data it's generally more efficient to write a list of binaries rather than a list of integers. It is not needed to flatten a deep list before writing. On Unix hosts, scatter output, which writes a set of buffers in one operation, is used when possible. In this way &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; writes the contents of the binaries without copying the data at all, except for perhaps deep down in the operating system kernel.</source>
          <target state="translated">写数据时，通常写二进制列表而不是整数列表更为有效。无需在写之前拼合深列表。在Unix主机上，尽可能使用分散输出，该分散输出在一个操作中写入一组缓冲区。通过这种方式， &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; 写入二进制文件的内容，而根本不会复制数据，除非深入操作系统内核。</target>
        </trans-unit>
        <trans-unit id="3b93d4af25f4cfa6e840871298ee7870c462c231" translate="yes" xml:space="preserve">
          <source>When writing new event handlers for the alarm handler, the following events must be handled:</source>
          <target state="translated">为报警处理程序编写新的事件处理程序时,必须处理以下事件。</target>
        </trans-unit>
        <trans-unit id="373413f347fd7c204258c00e02a894b57247817b" translate="yes" xml:space="preserve">
          <source>When writing recursive functions, it is preferable to make them tail-recursive so that they can execute in constant memory space:</source>
          <target state="translated">在编写递归函数时,最好使其尾部递归,这样可以在恒定的内存空间中执行。</target>
        </trans-unit>
        <trans-unit id="aa2d5599c173fb1e0df9df6db989c552f2a87193" translate="yes" xml:space="preserve">
          <source>When writing tests, the programmer may discover dependencies (in order to get the tests to run) that ought not to be there, and which need to be abstracted away to get a cleaner design. This helps eliminate bad dependencies before they spread throughout the code.</source>
          <target state="translated">在编写测试时,程序员可能会发现一些本不该存在的依赖关系(为了让测试运行),这些依赖关系需要被抽象掉,以获得更简洁的设计。这有助于在坏的依赖性扩散到整个代码之前就消除它们。</target>
        </trans-unit>
        <trans-unit id="3af0ab66421941647abf2fd21f2bc78b64c5b301" translate="yes" xml:space="preserve">
          <source>When you are finished with a registry, close it to remove all the objects and free the memory back to the system:</source>
          <target state="translated">当你处理完一个注册表后,关闭它,删除所有对象,将内存释放回系统。</target>
        </trans-unit>
        <trans-unit id="81517dd740949b1006611dd1f8a8b5246c788490" translate="yes" xml:space="preserve">
          <source>When you do application:start(odbc) the only thing that happens is that a supervisor process is started. For each call to the API function connect/2 a process is spawned and added as a child to the Erlang ODBC supervisor. The supervisors only tasks are to provide error-log reports, if a child process should die abnormally, and the possibility to do a code change. Only the client process has the knowledge to decide if this connection managing process should be restarted.</source>
          <target state="translated">当你执行application:start(odbc)时,唯一发生的事情就是一个监督者进程被启动。每调用一次API函数connect/2,就会生成一个进程,并将其作为子进程添加到Erlang ODBC监督器中。监督者的唯一任务是提供错误日志报告,如果一个子进程异常死亡,以及可以进行代码修改。只有客户端进程才有知识来决定是否应该重新启动这个连接管理进程。</target>
        </trans-unit>
        <trans-unit id="7400e1e45c6bbbe2f2d319b38f4bbb29db5b56b8" translate="yes" xml:space="preserve">
          <source>When you have covered all scenarios, call &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; in order to create a configuration. The configuration is written to a file that you have chosen. This configuration file can later be read by an Erlang runtime-system at startup. Pass the command line argument &lt;code&gt;-args_file FileName&lt;/code&gt; to the &lt;code&gt;erl(1)&lt;/code&gt; command.</source>
          <target state="translated">涵盖所有场景后，请调用 &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; 来创建配置。该配置将写入您选择的文件。此配置文件以后可以在启动时由Erlang运行时系统读取。将命令行参数 &lt;code&gt;-args_file FileName&lt;/code&gt; 传递给 &lt;code&gt;erl(1)&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="2d53da3f7d650259d1f729b92236227077a1d6a9" translate="yes" xml:space="preserve">
          <source>When you have made a new version of a release, a release package can be created with this new version and transferred to the target environment.</source>
          <target state="translated">当你做了一个新版本的发布,可以用这个新版本创建一个发布包,并转移到目标环境。</target>
        </trans-unit>
        <trans-unit id="aefe043fafd90a506fefaff1bdc21fce94c6f9bc" translate="yes" xml:space="preserve">
          <source>When you have written code implementing some specific functionality you might want to make the code into an &lt;strong&gt;application&lt;/strong&gt;, that is, a component that can be started and stopped as a unit, and which can also be reused in other systems.</source>
          <target state="translated">当您编写实现某些特定功能的代码时，您可能希望将代码放入&lt;strong&gt;应用程序中&lt;/strong&gt;，即可以作为一个单元启动和停止的组件，并且还可以在其他系统中重用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
