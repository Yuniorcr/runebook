<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="35c6e799b94495d942c887de378767b8bf60fab5" translate="yes" xml:space="preserve">
          <source>Call Statistics</source>
          <target state="translated">呼叫统计</target>
        </trans-unit>
        <trans-unit id="39312e806d3f1ec58faae16ac790feff4beeac35" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">调用首先执行工作块的NIF，然后调用 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 函数来安排另一个NIF调用以执行下一个块。然后，以这种方式安排的最终通话可以返回总体结果。</target>
        </trans-unit>
        <trans-unit id="4517bf0f809aaf1e241952932bd6d071e97a1670" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">调用首先执行工作块的NIF，然后调用 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 函数来安排另一个NIF调用以执行下一个块。然后，以这种方式安排的最终通话可以返回总体结果。</target>
        </trans-unit>
        <trans-unit id="9e64aca1cbd78581418480040f30e164b840d03b" translate="yes" xml:space="preserve">
          <source>Call back function to accumulate contents of entity.</source>
          <target state="translated">回调函数,累计实体的内容。</target>
        </trans-unit>
        <trans-unit id="25cbcf90fa280c9778e7621dfdd70289b3357c4e" translate="yes" xml:space="preserve">
          <source>Call back function to decide what to do if the scanner runs into EOF before the document is complete.</source>
          <target state="translated">调用回调函数,以决定在扫描仪完成文档之前进入 EOF 时该如何处理。</target>
        </trans-unit>
        <trans-unit id="305e72ce9d0178fb37627379b7066e3998f1aaff" translate="yes" xml:space="preserve">
          <source>Call back function to fetch an external resource.</source>
          <target state="translated">回调函数来获取外部资源。</target>
        </trans-unit>
        <trans-unit id="f1d17c05f561817d9262782ed4703874ffa16a47" translate="yes" xml:space="preserve">
          <source>Call back function to handle scanner events.</source>
          <target state="translated">回调功能,处理扫描仪事件。</target>
        </trans-unit>
        <trans-unit id="967a892c17aad400146f3cd8a0b41cd0e008b98d" translate="yes" xml:space="preserve">
          <source>Call back function to process the document entities once identified.</source>
          <target state="translated">回调函数,以处理识别后的文档实体。</target>
        </trans-unit>
        <trans-unit id="e43990d9029a1b5faffe47cfb2a73c40d38948b7" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.</source>
          <target state="translated">与其他形式的跟踪相比,呼叫计数跟踪是非常轻量级的,因为不需要生成跟踪消息。一些测量表明,性能下降了10%左右。</target>
        </trans-unit>
        <trans-unit id="1d9d8ff2abc216537369a4f6c51252cf41bb671a" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradations in the vicinity of 10 percent.</source>
          <target state="translated">与其他形式的跟踪相比,呼叫计数跟踪是非常轻量级的,因为不需要生成跟踪消息。一些测量表明,性能下降了10%左右。</target>
        </trans-unit>
        <trans-unit id="9ed8c88acf1e0b8225e507d6c8cef5617c61d6b6" translate="yes" xml:space="preserve">
          <source>Call these iteration functions on nodes that contain a replica of the table. Each call to the function &lt;code&gt;Fun&lt;/code&gt; access the table and if the table resides on another node it generates much unnecessary network traffic.</source>
          <target state="translated">在包含表副本的节点上调用这些迭代函数。每次对 &lt;code&gt;Fun&lt;/code&gt; 函数的调用都会访问该表，如果该表位于另一个节点上，则会产生很多不必要的网络流量。</target>
        </trans-unit>
        <trans-unit id="2a5f2658aeaf93347d628cb22d1c27eae9164e5d" translate="yes" xml:space="preserve">
          <source>Call this function in order to cancel a previous asynchronous call to, e.g. &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数以取消先前的异步调用，例如 &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a83b9ff602a28ae97d4ee0c90eb3fa1240e7fa" translate="yes" xml:space="preserve">
          <source>Call this function to stop cover test on nodes previously added with &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt;. Results on the remote node are transferred to the &lt;code&gt;Common Test&lt;/code&gt; node.</source>
          <target state="translated">调用此函数可停止对先前添加了 &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt; 的节点进行覆盖测试。远程节点上的结果将传输到&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 节点。</target>
        </trans-unit>
        <trans-unit id="37045b168b3bc333ac8bca52ef56747d12a1101f" translate="yes" xml:space="preserve">
          <source>Call this function when profiling has been stopped to display the results per process, that is:</source>
          <target state="translated">当剖析停止后,调用此函数显示每个进程的结果,即。</target>
        </trans-unit>
        <trans-unit id="c7eed74fd1bbb46205f4a5686245f8e5040d0026" translate="yes" xml:space="preserve">
          <source>Call tracing with &lt;code&gt;global&lt;/code&gt; option only affects external function calls. This was earlier handled by inserting a special trace instruction in export entries without the use of breakpoints. With the new non-blocking tracing we want to avoid special handling for global tracing and make use of the staging and atomic switching within the breakpoint mechanism. The solution was to create the same type of breakpoint structure for a global call trace. The difference to local tracing is that we insert the &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction (with its pointer at offset -4) in the export entry rather than in the code.</source>
          <target state="translated">具有 &lt;code&gt;global&lt;/code&gt; 选项的调用跟踪仅影响外部函数调用。这是通过在导出条目中插入特殊的跟踪指令而不使用断点来解决的。使用新的非阻塞跟踪，我们希望避免对全局跟踪进行特殊处理，并在断点机制中利用分段和原子切换。解决方案是为全局调用跟踪创建相同类型的断点结构。与本地跟踪的区别在于，我们在导出条目而不是代码中插入了 &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; 指令（其指针位于偏移量-4处）。</target>
        </trans-unit>
        <trans-unit id="eea8e2a2479f703038c465d2c2ffcd082e88cb6f" translate="yes" xml:space="preserve">
          <source>Callback = atom()</source>
          <target state="translated">Callback=atom()</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">回调功能</target>
        </trans-unit>
        <trans-unit id="ad8da05d8ad38ed7c0c50c2aa6868aeca72727cb" translate="yes" xml:space="preserve">
          <source>Callback Module</source>
          <target state="translated">回调模块</target>
        </trans-unit>
        <trans-unit id="61dfb922d9f46c947d009d0fb95ea292779f3dc7" translate="yes" xml:space="preserve">
          <source>Callback for &lt;code&gt;ct_telnet.erl&lt;/code&gt;.</source>
          <target state="translated">回调 &lt;code&gt;ct_telnet.erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e45c8484398e4aeac5267b27d0e1fb6f862e303" translate="yes" xml:space="preserve">
          <source>Callback function &lt;code&gt;TraverseFun&lt;/code&gt; is used for traversing the table. It is to return a list of objects terminated by either &lt;code&gt;[]&lt;/code&gt; or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary &lt;code&gt;TraverseFun&lt;/code&gt;s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling &lt;code&gt;qlc:table/2&lt;/code&gt; and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, &lt;code&gt;TraverseFun&lt;/code&gt; is called with a match specification returning every object.</source>
          <target state="translated">回调函数 &lt;code&gt;TraverseFun&lt;/code&gt; 用于遍历表。它返回一个以 &lt;code&gt;[]&lt;/code&gt; 或空值结尾的对象列表，以用于遍历表中尚未遍历的对象。任何其他返回值都将立即作为查询评估值返回。一元 &lt;code&gt;TraverseFun&lt;/code&gt; 将接受匹配规范作为参数。匹配规范是由解析转换通过分析调用 &lt;code&gt;qlc:table/2&lt;/code&gt; 的生成器的模式并使用模式中引入的变量进行过滤而创建的。如果解析转换找不到与模式和过滤器等效的匹配规范，则使用匹配规范返回所有对象的方式调用 &lt;code&gt;TraverseFun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04f9a377a5245adf1c0c727ef509b19ea04d764a" translate="yes" xml:space="preserve">
          <source>Callback functions</source>
          <target state="translated">回调功能</target>
        </trans-unit>
        <trans-unit id="37556ac19058ca5c17bab63cd838a12f2880d206" translate="yes" xml:space="preserve">
          <source>Callback functions that are optional for the user of the behaviour to implement are specified by use of the &lt;code&gt;-optional_callbacks&lt;/code&gt; attribute:</source>
          <target state="translated">通过使用 &lt;code&gt;-optional_callbacks&lt;/code&gt; 属性来指定对于要实现该行为的用户而言可选的回调函数：</target>
        </trans-unit>
        <trans-unit id="a04bb6692677302b06dcc4155d24ffed7a1d8b90" translate="yes" xml:space="preserve">
          <source>Callback invoked prior to terminating the transport process of a transport connection having watchdog state &lt;code&gt;OKAY&lt;/code&gt;. Applied to &lt;code&gt;application|service|transport&lt;/code&gt; and the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; in question: &lt;code&gt;application&lt;/code&gt; indicates that the diameter application is being stopped, &lt;code&gt;service&lt;/code&gt; that the service in question is being stopped by &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;transport&lt;/code&gt; that the transport in question is being removed by &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在终止具有看门狗状态 &lt;code&gt;OKAY&lt;/code&gt; 的传输连接的传输过程之前调用的回调。施加到 &lt;code&gt;application|service|transport&lt;/code&gt; 和 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; 中的问题： &lt;code&gt;application&lt;/code&gt; 表明直径应用程序被停止， &lt;code&gt;service&lt;/code&gt; 所讨论的服务正被停止 &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;transport&lt;/code&gt; ，所述输送有问题的将由 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 删除。</target>
        </trans-unit>
        <trans-unit id="66eade566a1aabb00b9616d9f85c98561a92d0e8" translate="yes" xml:space="preserve">
          <source>Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;#diameter_caps{}&lt;/code&gt; record of the connection.</source>
          <target state="translated">在能力交换期间，在收到CER / CEA时调用回调，以询问是否应接受连接。应用于连接的 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 和 &lt;code&gt;#diameter_caps{}&lt;/code&gt; 记录。</target>
        </trans-unit>
        <trans-unit id="8170a9b43176c43c83ab38fea10e4e72c195d1f2" translate="yes" xml:space="preserve">
          <source>Callback module for &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 的回调模块，用于连接到UNIX主机上的Telnet服务器。</target>
        </trans-unit>
        <trans-unit id="723d576b61f4090ef99d45ef635768456422a654" translate="yes" xml:space="preserve">
          <source>Callback module for ct_telnet, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">ct_telnet的回调模块,用于连接到UNIX主机上的Telnet服务器。</target>
        </trans-unit>
        <trans-unit id="c6227e8f008e1e3653b7695696953858c51a783a" translate="yes" xml:space="preserve">
          <source>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the &lt;code&gt;tftp_logger&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt;. The default module is &lt;code&gt;tftp_logger&lt;/code&gt;.</source>
          <target state="translated">回调模块，用于自定义记录错误，警告和信息消息。回调模块必须实现 &lt;code&gt;tftp_logger&lt;/code&gt; 行为，请参阅 &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt; 。默认模块是 &lt;code&gt;tftp_logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac834d27797dbad127ce8fd6d8a2319b5f46c402" translate="yes" xml:space="preserve">
          <source>Callback module for users of the Megaco application</source>
          <target state="translated">为Megaco应用程序用户提供回调模块。</target>
        </trans-unit>
        <trans-unit id="b474f7579efe489c47dcf78d665d0cd713f942e9" translate="yes" xml:space="preserve">
          <source>Callback module for using an SSH agent instead of the default ssh_file callback.</source>
          <target state="translated">用于使用SSH代理的回调模块,而不是默认的ssh_file回调。</target>
        </trans-unit>
        <trans-unit id="55798c61abfa41a7a5297d6740d1e64b1d565485" translate="yes" xml:space="preserve">
          <source>Callback module in which messages of the Diameter application are handled. See &lt;code&gt;diameter_app(3)&lt;/code&gt; for the required interface and semantics.</source>
          <target state="translated">处理Diameter应用程序消息的回调模块。有关所需的接口和语义，请参见 &lt;code&gt;diameter_app(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b07b4a00700ebf2a1936cd09849d3229f8cea9e" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt; gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt; gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt; gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; ， &lt;code&gt;gen_statem&lt;/code&gt; 和 &lt;code&gt;gen_event&lt;/code&gt; 的回调模块还可以通过导出函数 &lt;code&gt;format_status/2&lt;/code&gt; 来更改 &lt;code&gt;Misc&lt;/code&gt; 的值，该函数提供模块特定的信息。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt; gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt; gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt; gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63edefe6aafdd040e89d039ff830e8a61ffa1b95" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; ， &lt;code&gt;gen_statem&lt;/code&gt; 和 &lt;code&gt;gen_event&lt;/code&gt; 的回调模块还可以通过导出函数 &lt;code&gt;format_status/2&lt;/code&gt; 来更改 &lt;code&gt;Misc&lt;/code&gt; 的值，该函数提供模块特定的信息。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a42e9b08e0786b523d53e7aaa69806b6b4c7c7b" translate="yes" xml:space="preserve">
          <source>Callback timeouts</source>
          <target state="translated">回调超时</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="5393b6e7c5c51638adb55313f4e4ecf06a0243fc" translate="yes" xml:space="preserve">
          <source>Callbacks functions for a &lt;code&gt;&lt;a href=&quot;#ussi&quot;&gt;&lt;i&gt;User Supplied Socket Implementation&lt;/i&gt;&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks_fields&quot;&gt;Documentation of each field&lt;/a&gt;&lt;/code&gt; can be found in the</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ussi&quot;&gt;&lt;i&gt;User Supplied Socket Implementation&lt;/i&gt;&lt;/a&gt;&lt;/code&gt; 回调函数。 &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks_fields&quot;&gt;Documentation of each field&lt;/a&gt;&lt;/code&gt; 可以在</target>
        </trans-unit>
        <trans-unit id="0388e8bb7b30f62d43703b0a0c0a90fc579a8ead" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt; erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">在异步调用完成后调用。异步调用从 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt; erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; 开始。此函数是从Erlang仿真器线程中调用的，而异步函数则在某些线程中调用（如果启用了多线程）。</target>
        </trans-unit>
        <trans-unit id="1424d68bc26afe36f6e438d92e2344fe5359e183" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">在异步调用完成后调用。异步调用从 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; 开始。此函数是从Erlang仿真器线程中调用的，而异步函数则在某些线程中调用（如果启用了多线程）。</target>
        </trans-unit>
        <trans-unit id="308f76c161337017286f205aef3ab09cb6ea041d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the master-agent for primary processing.</source>
          <target state="translated">在基本消息处理(MPD)完成后,但在pdu交给主代理进行初级处理之前调用。</target>
        </trans-unit>
        <trans-unit id="a313d3073d9eea56873be11a826fd840a7e0d86d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the server for primary processing.</source>
          <target state="translated">在基本消息处理(MPD)完成后,但在pdu被移交给服务器进行初级处理之前调用。</target>
        </trans-unit>
        <trans-unit id="ff191d8e8919401c02df5d752c7753bbfc148a86" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt; erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">在驾驶员计时器达到 &lt;code&gt;0&lt;/code&gt; 后的任何时间调用。计时器由 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt; erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; 激活。驱动程序之间不存在优先级或顺序，因此，如果多个驱动程序同时超时，则首先呼叫任何一个。</target>
        </trans-unit>
        <trans-unit id="e5fe3aacb675f5586e55ac426e9e29a0553867e0" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">在驾驶员计时器达到 &lt;code&gt;0&lt;/code&gt; 后的任何时间调用。计时器通过 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; 激活。驱动程序之间不存在优先级或顺序，因此，如果多个驱动程序同时超时，则首先呼叫任何一个。</target>
        </trans-unit>
        <trans-unit id="81eabbdc5601ceaa0bccb714043c53b451726d6f" translate="yes" xml:space="preserve">
          <source>Called at the reception of a message (before &lt;strong&gt;any&lt;/strong&gt; processing has been done).</source>
          <target state="translated">在收到消息时调用（在完成&lt;strong&gt;任何&lt;/strong&gt;处理之前）。</target>
        </trans-unit>
        <trans-unit id="bf59df7706e69db3cc159c1ee57e97f02070c14b" translate="yes" xml:space="preserve">
          <source>Called before the basic message processing (MPD) is done, when a pdu has been received from the master-agent.</source>
          <target state="translated">在基本消息处理(MPD)完成之前,当从主代理接收到pdu时调用。</target>
        </trans-unit>
        <trans-unit id="67cc06ab5c5cdaf22f4e18059ff7135bed75b26e" translate="yes" xml:space="preserve">
          <source>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; as part of its return value.</source>
          <target state="translated">在未注册乐趣之前调用。在这里可以进行任何清理。返回值并不重要，但会作为返回值的一部分传递回 &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; 的调用方。</target>
        </trans-unit>
        <trans-unit id="60cc53ceda191e4c7c43073a2ca95d2429376ca7" translate="yes" xml:space="preserve">
          <source>Called before the sending of a message (after &lt;strong&gt;all&lt;/strong&gt; processing has been done).</source>
          <target state="translated">在发送消息之前（在完成&lt;strong&gt;所有&lt;/strong&gt;处理之后）调用。</target>
        </trans-unit>
        <trans-unit id="411e859542f736dac045f8721e0a466752068640" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Host&lt;/code&gt; defaults to the localhost. Returns the names and associated port numbers of the Erlang nodes that &lt;code&gt;epmd&lt;/code&gt; registered at the specified host. Returns &lt;code&gt;{error, address}&lt;/code&gt; if &lt;code&gt;epmd&lt;/code&gt; is not operational.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;Host&lt;/code&gt; 默认为本地主机。返回 &lt;code&gt;epmd&lt;/code&gt; 在指定主机上注册的Erlang节点的名称和相关的端口号。如果 &lt;code&gt;epmd&lt;/code&gt; 无法运行 &lt;code&gt;{error, address}&lt;/code&gt; 则返回{错误，地址}。</target>
        </trans-unit>
        <trans-unit id="754186ab8b7082c0674d04f3bdaf7fcddc1ab3a3" translate="yes" xml:space="preserve">
          <source>Called by the &lt;code&gt;erl_ddll&lt;/code&gt; driver when the driver is unloaded. (It is only called in dynamic drivers.)</source>
          <target state="translated">卸载驱动程序时，由 &lt;code&gt;erl_ddll&lt;/code&gt; 驱动程序调用。（仅在动态驱动程序中调用。）</target>
        </trans-unit>
        <trans-unit id="655d271abcfd7d76d286a17dda2d7657206096c8" translate="yes" xml:space="preserve">
          <source>Called by the distribution module to get which port the local node should listen to when accepting new distribution requests.</source>
          <target state="translated">由分发模块调用,获取本地节点在接受新的分发请求时应该监听哪个端口。</target>
        </trans-unit>
        <trans-unit id="e0f458d70c750018b87e9944e64a8528f08c2ec7" translate="yes" xml:space="preserve">
          <source>Called by the distribution module to resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address of a remote node.</source>
          <target state="translated">由分发模块调用，以将 &lt;code&gt;Host&lt;/code&gt; 解析为远程节点的IP地址。</target>
        </trans-unit>
        <trans-unit id="650a5975977f531507f62d29a2ce95a7a1cfb83f" translate="yes" xml:space="preserve">
          <source>Called by the distribution module. Resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address.</source>
          <target state="translated">由分发模块调用。将 &lt;code&gt;Host&lt;/code&gt; 解析为IP地址。</target>
        </trans-unit>
        <trans-unit id="85b869badf1456352f06af55e42a19b0066bf142" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt; erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">在由 &lt;code&gt; erl_ddll:load_driver/2&lt;/code&gt; 加载驱动程序后直接调用（实际上是在将驱动程序添加到驱动程序列表时）。驱动程序将返回 &lt;code&gt;0&lt;/code&gt; ，或者，如果驱动程序无法初始化，则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e67ee5139f5c3d24c6add77615125e4e640a01" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">在由 &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 加载驱动程序之后直接调用（实际上是在将驱动程序添加到驱动程序列表时）。驱动程序将返回 &lt;code&gt;0&lt;/code&gt; ，或者，如果驱动程序无法初始化，则返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987000d4d4006dd9dc12f7c300ae64273a69aeb6" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">当进程继续执行时（例如，在挂起之后），从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="98e9ec7ab4eccd3e4ae575952428dd16c1ea3ec0" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">当进程要执行代码更改时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。内部数据结构更改时，将使用代码更改。此函数将参数 &lt;code&gt;Misc&lt;/code&gt; 转换为新的数据结构。 &lt;code&gt;OldVsn&lt;/code&gt; 是 &lt;code&gt;Module&lt;/code&gt; 的旧版本的属性&lt;strong&gt;vsn&lt;/strong&gt;。如果没有定义这样的属性，则发送 &lt;code&gt;undefined&lt;/code&gt; 的原子。</target>
        </trans-unit>
        <trans-unit id="419bfc7b5724ea2b2f35b364df0a94b7fb0dc40f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当进程要替换其当前状态时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;NState&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="bfa9e2f41a9f72c39043fd4f54a03f6d2aa7c6c5" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当过程返回一个反映其当前状态的术语时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="9a05f5f13a8adcd5f39e22e499b3c5e09ab8f8ff" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">当进程终止时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。例如，当进程挂起并且其父订单关闭时，将调用此函数。它使该过程有机会进行清理。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="262d7b78c6487d8a39946866f1d11a39d5496a09" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">当进程继续执行时（例如，在挂起之后）从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="73172cc1a7cb2d69c85f4a96da6765b4101ba755" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">当进程要执行代码更改时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。内部数据结构更改时，将使用代码更改。此函数将参数 &lt;code&gt;Misc&lt;/code&gt; 转换为新的数据结构。 &lt;code&gt;OldVsn&lt;/code&gt; 是 &lt;code&gt;Module&lt;/code&gt; 的旧版本的属性&lt;strong&gt;vsn&lt;/strong&gt;。如果 &lt;code&gt;undefined&lt;/code&gt; 此类属性，则发送未定义的原子。</target>
        </trans-unit>
        <trans-unit id="594143f9a65ae1c6fe10c4f338068b8a9f905601" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当进程要替换其当前状态时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;NState&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="d9b3e834b715a254168526e411e95a8a48713b20" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当过程返回一个反映其当前状态的术语时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。 &lt;code&gt;State&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="e4c98925793456e56a2d33122eb6a311fa293f3d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">当进程终止时，从 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 调用。例如，当流程挂起且其父订单关闭时，将调用此函数。它使该过程有机会进行清理。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="7d565039ea45d2e2d8bf629df70695d8e577068a" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="c6ebf9fbba1927e0169999540aede92ba5d2b9d7" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="239af18064c670c227882eb2c0195d0784143a68" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt; erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 调用。它的工作原理与 &lt;code&gt;control&lt;/code&gt; 回调类似，但是使用外部术语格式进行输入和输出。</target>
        </trans-unit>
        <trans-unit id="ee779128abb96dcaaa77c4845eb5b58fcbdf4ab2" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 调用。它的工作原理与 &lt;code&gt;control&lt;/code&gt; 回调类似，但是使用外部术语格式进行输入和输出。</target>
        </trans-unit>
        <trans-unit id="647803d0d0c160b1b32fafd3407a185b78e69a6c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="9a7a6da0d32374d704f66fa64639e5942279833d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#send-2&quot;&gt; erlang:send/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;erlang#send-2&quot;&gt; erlang:send/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="eda5333bad3b8e6536c6e400a545bf0c68561f86" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;erlang:open_port/2&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="52c95806576ffd5c6e9bda3738995849c83e6d48" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_call/3&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;erlang:port_call/3&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="37967ef10d51ab9623c55cce347e8ac82ffaa69f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_control/3&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;erlang:port_control/3&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="76a9c293f08a9964ffe8949415ea15fcd479022c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:send/2&lt;/code&gt; and &lt;code&gt;erlang:port_command/2&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;erlang:send/2&lt;/code&gt; 和 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="5b7712d2af65521477e16f6013575117d34b96c0" translate="yes" xml:space="preserve">
          <source>Called in order to close the &lt;code&gt;Listen&lt;/code&gt; handle that originally was passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">调用此命令是为了关闭最初从 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 回调传递的 &lt;code&gt;Listen&lt;/code&gt; 句柄。</target>
        </trans-unit>
        <trans-unit id="ed0e2e44fa4e2d7ed6caea388ba567c2aadfb380" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt; erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">在可以安全关闭事件对象的情况下，代表 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt; erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="470a1c0ce98f90a6c63285d61ce7082f47f6706f" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">在安全关闭事件对象时，代表 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="23ff0ae2399ea44f77132823a27ee56494ae7347" translate="yes" xml:space="preserve">
          <source>Called to instruct the manager that this agent shall be handled. This function is used when the user knows in advance which agents the manager shall handle. Note that there is an alternate way to do the same thing: Add the agent to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">打电话通知经理应处理此代理人。当用户预先知道经理应处理哪些代理时，将使用此功能。请注意，还有另一种方法可以执行相同的操作：将代理添加到管理器配置文件（请参阅 &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c4e12b2b87e916464a480eeba6c90e011990c07" translate="yes" xml:space="preserve">
          <source>Called when a driver event (specified in parameter &lt;code&gt;event&lt;/code&gt;) is signaled. This is used to help asynchronous drivers &quot;wake up&quot; when something occurs.</source>
          <target state="translated">当发出驱动程序事件（在参数 &lt;code&gt;event&lt;/code&gt; 中指定）时调用。这用于帮助异步驱动程序在发生某些情况时&amp;ldquo;唤醒&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b36813d53908741b8362c286580e5e8b637ec710" translate="yes" xml:space="preserve">
          <source>Called when a locally started handshake has completed successfully.</source>
          <target state="translated">当本地启动的握手成功完成时调用。</target>
        </trans-unit>
        <trans-unit id="8574d5472a3027867d3ec87879fb27cdaab45a80" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt; erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt; erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">当监视的进程退出时调用。所述 &lt;code&gt;drv_data&lt;/code&gt; 是与其中的过程被监控端口相关联的数据（使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt; erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;monitor&lt;/code&gt; 对应于 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 结构填充创建监视器时英寸 驱动程序接口函数 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt; erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; 可用于检索退出进程的进程ID作为 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5f6a024fd8f77a2ea9867d6adcf09937e5b321e" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">当监视的进程退出时调用。所述 &lt;code&gt;drv_data&lt;/code&gt; 是与其中的过程被监控端口相关联的数据（使用 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;monitor&lt;/code&gt; 对应于 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 结构填充创建监视器时英寸接口功能的驱动 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; 可用于检索退出过程作为一个的进程ID &lt;code&gt;ErlDrvTermData&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67e2aa0c472d7e1f331918d874d82a46a103385" translate="yes" xml:space="preserve">
          <source>Called when a port is closed.</source>
          <target state="translated">当端口被关闭时调用。</target>
        </trans-unit>
        <trans-unit id="af5703e1882d09239d1d042a60353e00eb2d7742" translate="yes" xml:space="preserve">
          <source>Called when a remotely started handshake has completed successfully.</source>
          <target state="translated">当远程启动的握手成功完成时调用。</target>
        </trans-unit>
        <trans-unit id="260ba11c56b3301de010c7bb46f13a8d01000aa0" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当Erlang进程已将数据发送到端口时调用。数据由 &lt;code&gt;buf&lt;/code&gt; 指向，为 &lt;code&gt;len&lt;/code&gt; 个字节。数据通过 &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; 发送到端口！{self（），{command，Data}}或使用 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 。根据打开端口的方式，它可以是整数列表 &lt;code&gt;0...255&lt;/code&gt; 或二进制文件。请参阅 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt; erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f79f35f10e231c1c5d46754dcc831f0124571c5" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当Erlang进程已将数据发送到端口时调用。数据由 &lt;code&gt;buf&lt;/code&gt; 指向，为 &lt;code&gt;len&lt;/code&gt; 个字节。数据通过端口发送到 &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; 或使用 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 。根据打开端口的方式，它可以是整数列表 &lt;code&gt;0...255&lt;/code&gt; 或二进制文件。请参阅 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fefd076009119dd92492aabc22699c37cd1acfde" translate="yes" xml:space="preserve">
          <source>Called when document has been completely parsed.</source>
          <target state="translated">当文档被完全解析后调用。</target>
        </trans-unit>
        <trans-unit id="d9d5c990ed44bfe60f747ede5eb6362b963aa6ee" translate="yes" xml:space="preserve">
          <source>Called when it is possible to write to a socket.</source>
          <target state="translated">当可以向socket写入时调用。</target>
        </trans-unit>
        <trans-unit id="dc2fc86f42c4e06dc8824ff7ab20959ce4ee0279" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">实例化驱动程序时，在调用 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 时调用。驱动程序将返回一个&amp;gt; = 0的数字或一个指针，或者，如果无法启动该驱动程序，则将返回以下三个错误代码之一：</target>
        </trans-unit>
        <trans-unit id="ea08619d53f9130eaa9e346bb5fa5aec56010fde" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">实例化驱动程序时，在调用 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 时调用。驱动程序将返回&amp;gt; = 0的数字或指针，或者，如果无法启动该驱动程序，则将返回以下三个错误代码之一：</target>
        </trans-unit>
        <trans-unit id="c7878482ce6f10c4027034352ce73f5aaa4ce9cf" translate="yes" xml:space="preserve">
          <source>Called when the driver is unloaded. A distribution driver will never be unloaded, but we include this for completeness. To be able to clean up after oneself is always a good thing.</source>
          <target state="translated">当驱动程序被卸载时调用。一个分布式驱动程序永远不会被卸载,但为了完整性,我们加入了这个功能。能够清理好自己的工作总是一件好事。</target>
        </trans-unit>
        <trans-unit id="e9777a1b7d37a6943bc53bf03a6d0e91d50d751f" translate="yes" xml:space="preserve">
          <source>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; is returned, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; is registered instead of &lt;code&gt;CryptoKeyFun&lt;/code&gt;. If &lt;code&gt;{error, Term}&lt;/code&gt; is returned, the registration is aborted and &lt;code&gt;crypto_key_fun/1&lt;/code&gt; also returns &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">在保存趣味的过程中，在注册趣味时调用。在这里，加密密钥fun可以执行任何必要的初始化。如果 &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; 返回， &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; 被注册，而不是 &lt;code&gt;CryptoKeyFun&lt;/code&gt; 。如果返回 &lt;code&gt;{error, Term}&lt;/code&gt; ，则注册中止， &lt;code&gt;crypto_key_fun/1&lt;/code&gt; 也返回 &lt;code&gt;{error, Term}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98ad7a8527ae38bbbd2d4e06002457415af632b3" translate="yes" xml:space="preserve">
          <source>Called when the key is needed for module &lt;code&gt;Module&lt;/code&gt; in the file named &lt;code&gt;Filename&lt;/code&gt;. &lt;code&gt;Mode&lt;/code&gt; is the type of crypto algorithm; currently, the only possible value is &lt;code&gt;des3_cbc&lt;/code&gt;. The call is to fail (raise an exception) if no key is available.</source>
          <target state="translated">当名为 &lt;code&gt;Filename&lt;/code&gt; 的文件中的模块 &lt;code&gt;Module&lt;/code&gt; 需要密钥时调用。 &lt;code&gt;Mode&lt;/code&gt; 是加密算法的类型；当前，唯一可能的值是 &lt;code&gt;des3_cbc&lt;/code&gt; 。如果没有可用的密钥，则呼叫将失败（引发异常）。</target>
        </trans-unit>
        <trans-unit id="0dcbf03fb42831c6723cb1715f47765453867f67" translate="yes" xml:space="preserve">
          <source>Called when the port is about to be closed, and there is data in the driver queue that must be flushed before 'stop' can be called.</source>
          <target state="translated">当端口即将关闭,并且在调用'stop'之前必须刷新驱动队列中的数据时,会被调用。</target>
        </trans-unit>
        <trans-unit id="4c1f621a84111ea117dcad5ab2dda0907aba7d59" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt; erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">当端口关闭时使用 &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt; erlang:port_close/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 调用。{self（），关闭}。请注意，终止端口所有者进程也会关闭该端口。如果 &lt;code&gt;drv_data&lt;/code&gt; 是指向在 &lt;code&gt;start&lt;/code&gt; 中分配的内存的指针，则 &lt;code&gt;stop&lt;/code&gt; 是取消分配该内存的位置。</target>
        </trans-unit>
        <trans-unit id="8919d79f584bde48131fa0a13624f5f0b5dd1e5e" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">当端口关闭时使用 &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 调用。{self（），关闭}。请注意，终止端口所有者进程也会关闭端口。如果 &lt;code&gt;drv_data&lt;/code&gt; 是指向 &lt;code&gt;start&lt;/code&gt; 中分配的内存的指针，则 &lt;code&gt;stop&lt;/code&gt; 是取消分配该内存的位置。</target>
        </trans-unit>
        <trans-unit id="bce5d5b2decf756f58e8642c565207befb9d1e4c" translate="yes" xml:space="preserve">
          <source>Called when there is something to read from a socket.</source>
          <target state="translated">当有东西要从插座中读取时调用。</target>
        </trans-unit>
        <trans-unit id="af3ef6e1f6da39c57e0246dc6e4aad3b06e17a5b" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">每当端口被写入时调用。如果为 &lt;code&gt;NULL&lt;/code&gt; ，则调用 &lt;code&gt;output&lt;/code&gt; 函数。此函数比 &lt;code&gt;output&lt;/code&gt; 更快，因为它直接使用 &lt;code&gt;ErlIOVec&lt;/code&gt; ，而无需复制数据。该端口将处于二进制模式，请参见 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb06eda8927a232da24c20e732e3e2949f2b101f" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">每当端口被写入时调用。如果为 &lt;code&gt;NULL&lt;/code&gt; ，则调用 &lt;code&gt;output&lt;/code&gt; 函数。此函数比 &lt;code&gt;output&lt;/code&gt; 更快，因为它直接使用 &lt;code&gt;ErlIOVec&lt;/code&gt; ，不需要复制数据。端口将处于二进制模式，请参见 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="156f735aabd8995d92638174e190f108bd8cf6cb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt; erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">使用字符串参数调用 &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt; erlang:halt/1&lt;/a&gt;&lt;/code&gt; 仍会产生故障转储。在Unix系统上，向仿真器进程发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 信号也会强制执行故障转储。</target>
        </trans-unit>
        <trans-unit id="8c4da0ebceae11eff6b7919b2ddd46f27587b04d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">使用字符串参数调用 &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; 仍会产生故障转储。在Unix系统上，向仿真器进程发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 信号也会强制执行故障转储。</target>
        </trans-unit>
        <trans-unit id="655a22092d77d88145d5c50ca50e242cddc91b3d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; is equivalent to the following, but more efficient:</source>
          <target state="translated">调用 &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; 等效于以下内容，但效率更高：</target>
        </trans-unit>
        <trans-unit id="754ff095185e90c1599a6e196b476c1470159daf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erlang:system_time()&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt; erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8abf86e315d47dada23e450fdd1a6d2f9ae320c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erlang:system_time()&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d46cab9ce133f988a0314784232f1c7f5a5b51d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b083a75a2460c0a8048c36cd9fefa43e466519e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac8161866033e5fba00c9f967a358dd87e252b77" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;merl:print(Call)&lt;/code&gt; will then print the following code:</source>
          <target state="translated">然后调用 &lt;code&gt;merl:print(Call)&lt;/code&gt; 将打印以下代码：</target>
        </trans-unit>
        <trans-unit id="2cedca3701bb5e353b3d951a1078a1fe4f284c28" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;os:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;erlang:convert_time_unit&lt;/code&gt;(&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;os:system_time(Unit)&lt;/code&gt; 等效于 &lt;code&gt;erlang:convert_time_unit&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afeabfe36eaf236b85f9317a022e3a32b2c67b0d" translate="yes" xml:space="preserve">
          <source>Calling and applying a fun does not involve any hash-table lookup. A fun contains an (indirect) pointer to the function that implements the fun.</source>
          <target state="translated">调用和应用fun不涉及任何哈希表查找。一个fun包含一个指向实现该fun的函数的(间接)指针。</target>
        </trans-unit>
        <trans-unit id="90124b2b5c5e8b577f502d3a36088e606891a366" translate="yes" xml:space="preserve">
          <source>Calling or applying a fun (&lt;code&gt;Fun()&lt;/code&gt;, &lt;code&gt;apply(Fun, [])&lt;/code&gt;) is about &lt;strong&gt;three times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">调用或应用fun（ &lt;code&gt;Fun()&lt;/code&gt; ， &lt;code&gt;apply(Fun, [])&lt;/code&gt; ）的成本大约是调用本地函数的&lt;strong&gt;三倍&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1bdcae36deade4d4d3da84b2d5104437391e84c5" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt; erlang:system_monitor(MonitorPid, Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; 作为参数调用该函数与调用 &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt; erlang:system_monitor(MonitorPid, Options)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4977f905b190f9bbe202e2e85576e00836e9734e" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; 作为参数调用该函数与调用 &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4b42cc7ad99418c1a03de8a69add23747a547065" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing all the integer()'s and string()'s provided, as well as any user tag set in the current process.</source>
          <target state="translated">调用该函数将触发dyntrace NIF模块中的 &quot;用户 &quot;跟踪探针user_trace_i4s4,发送包含所有提供的整数()和字符串()的跟踪消息,以及当前进程中设置的任何用户标签。</target>
        </trans-unit>
        <trans-unit id="444f79602e491b38e25cb8c13003f56f8345ff63" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer or string parameter in the first integer/string field.</source>
          <target state="translated">调用该函数将触发dyntrace NIF模块中的 &quot;用户 &quot;跟踪探针user_trace_i4s4,发送一条包含用户标签和第一个整数/字符串字段中的整数或字符串参数的跟踪消息。</target>
        </trans-unit>
        <trans-unit id="ca84bd13b57ed20dc137036dea97bc867dd9acff" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters, as in &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数将触发dyntrace NIF模块中的&amp;ldquo;用户&amp;rdquo;跟踪探针user_trace_i4s4，发送包含用户标签和integer（）或string（）参数作为相应类型的第一个字段的跟踪消息。应该将integer（）参数放在任何string（）参数之前，如 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 所示。</target>
        </trans-unit>
        <trans-unit id="3d6504b8ed29fe9b52bfa13411a0abbd154f8e3e" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters. I.e. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; is ok, as is &lt;code&gt;p(1,1)&lt;/code&gt; and &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt;, but not &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt;.</source>
          <target state="translated">调用此函数将触发dyntrace NIF模块中的&amp;ldquo;用户&amp;rdquo;跟踪探测器user_trace_i4s4，发送包含用户标签和integer（）或string（）参数作为相应类型的第一个字段的跟踪消息。integer（）参数应放在任何string（）参数之前。即 &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; 可以， &lt;code&gt;p(1,1)&lt;/code&gt; 和 &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt; ，但 &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba80ef3622f6d7266790c78fbbdd6b4544d6f3ea" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message only containing the user tag and zeroes/empty strings in all other fields.</source>
          <target state="translated">调用该函数将触发dyntrace NIF模块中的 &quot;用户 &quot;跟踪探针user_trace_i4s4,发送一个只包含用户标签的跟踪消息,其他字段均为零/空字符串。</target>
        </trans-unit>
        <trans-unit id="fc31c095d153129fc853cf06c728a75bf3b46c60" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; with the same arguments and filters the result, so &lt;code&gt;Opts&lt;/code&gt; is described for those functions.</source>
          <target state="translated">使用相同的参数调用 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; 并过滤结果，因此针对这些函数介绍了 &lt;code&gt;Opts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64e4f69ad9125f63ba8df8f7d7d250f3cecda4ae" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">对每个 &lt;code&gt;K&lt;/code&gt; 调用 &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; 以任意顺序在 &lt;code&gt;MapOrIter&lt;/code&gt; 中值 &lt;code&gt;V&lt;/code&gt; 关联。 &lt;code&gt;fun F/3&lt;/code&gt; 函数fun必须返回一个新的累加器，该累加器将传递到下一个后续调用。该函数返回累加器的最终值。如果映射为空，则返回初始累加器值 &lt;code&gt;Init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c22c12363a38985d309e6b7686e339831be7ae7" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(Key, Value, AccIn)&lt;/code&gt; for every &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">以任意顺序为 &lt;code&gt;MapOrIter&lt;/code&gt; 中的每个 &lt;code&gt;Key&lt;/code&gt; 到值 &lt;code&gt;Value&lt;/code&gt; 关联调用 &lt;code&gt;F(Key, Value, AccIn)&lt;/code&gt; 。 &lt;code&gt;fun F/3&lt;/code&gt; 函数fun必须返回一个新的累加器，该累加器将传递到下一个后续调用。该函数返回累加器的最终值。如果映射为空，则返回初始累加器值 &lt;code&gt;Init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4295c8a20ece7cf06d43d6ebf25e275c406c6e5f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; for each element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt;. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</source>
          <target state="translated">呼叫 &lt;code&gt;Fun(Elem)&lt;/code&gt; 每个元素 &lt;code&gt;Elem&lt;/code&gt; 在 &lt;code&gt;List&lt;/code&gt; 。此函数用于其副作用，并且将评估顺序定义为与列表中元素的顺序相同。</target>
        </trans-unit>
        <trans-unit id="63f2bd2bc7b570ff8e3f588bc3a35e7f39bb021c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; on successive elements &lt;code&gt;Elem&lt;/code&gt; of &lt;code&gt;List1&lt;/code&gt;. &lt;code&gt;Fun/1&lt;/code&gt; must return either a Boolean or a tuple &lt;code&gt;{true, Value}&lt;/code&gt;. The function returns the list of elements for which &lt;code&gt;Fun&lt;/code&gt; returns a new value, where a value of &lt;code&gt;true&lt;/code&gt; is synonymous with &lt;code&gt;{true, Elem}&lt;/code&gt;.</source>
          <target state="translated">呼叫 &lt;code&gt;Fun(Elem)&lt;/code&gt; 上连续元素 &lt;code&gt;Elem&lt;/code&gt; 的 &lt;code&gt;List1&lt;/code&gt; 。 &lt;code&gt;Fun/1&lt;/code&gt; 必须返回布尔值或元组 &lt;code&gt;{true, Value}&lt;/code&gt; 。该函数返回 &lt;code&gt;Fun&lt;/code&gt; 为其返回新值的元素列表，其中 &lt;code&gt;true&lt;/code&gt; 值与 &lt;code&gt;{true, Elem}&lt;/code&gt; 同义。</target>
        </trans-unit>
        <trans-unit id="50d89c32ea4d0c6ee1b26f9c66ad9e11c8879726" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">通话 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 上连续元素 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;List&lt;/code&gt; ，从 &lt;code&gt;AccIn == Acc0&lt;/code&gt; 。 &lt;code&gt;Fun/2&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递到下一个调用。该函数返回累加器的最终值。如果列表为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d14f785e84c0e45ac023a87056c299dcc94c604" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements of the cache, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the cache is empty.</source>
          <target state="translated">从 &lt;code&gt;AccIn == Acc0&lt;/code&gt; 开始，对缓存的连续元素调用 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 。 &lt;code&gt;Fun/2&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递到下一个调用。该函数返回累加器的最终值。如果缓存为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d85b7bf8f7b8acf4c9a5d164bbe2b412bc74ce98" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; on successive files in the &lt;code&gt;Archive&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;AccIn == Acc0&lt;/code&gt; 开始，对 &lt;code&gt;Archive&lt;/code&gt; 连续文件调用 &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecb1b12376680c06a8dcd6a14c87f88b97c0f362" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict1&lt;/code&gt; tvo return a new value for each key.</source>
          <target state="translated">在连续的键上调用 &lt;code&gt;Fun&lt;/code&gt; ，并且 &lt;code&gt;Orddict1&lt;/code&gt; tvo的值将为每个键返回一个新值。</target>
        </trans-unit>
        <trans-unit id="41cc957320ee93c3d6a8d2c0cf887c390c051f0c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">对 &lt;code&gt;Orddict&lt;/code&gt; 的连续键和值以及附加参数 &lt;code&gt;Acc&lt;/code&gt; （累加器的缩写）一起调用 &lt;code&gt;Fun&lt;/code&gt; 。 &lt;code&gt;Fun&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递到下一个调用。如果列表为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db2c15c0e80df0b70d2a4c08c9328f07d292a334" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict1&lt;/code&gt; to return a new value for each key. The evaluation order is undefined.</source>
          <target state="translated">对连续键和字典 &lt;code&gt;Dict1&lt;/code&gt; 的值调用 &lt;code&gt;Fun&lt;/code&gt; ，以为每个键返回一个新值。评估顺序未定义。</target>
        </trans-unit>
        <trans-unit id="51e98c878f8461c82b19b807000534c1ee895d35" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the dictionary is empty. The evaluation order is undefined.</source>
          <target state="translated">对字典 &lt;code&gt;Dict&lt;/code&gt; 的连续键和值以及附加参数 &lt;code&gt;Acc&lt;/code&gt; （累加器的缩写）一起调用 &lt;code&gt;Fun&lt;/code&gt; 。 &lt;code&gt;Fun&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递到下一个调用。如果字典为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。评估顺序未定义。</target>
        </trans-unit>
        <trans-unit id="1e38b9bc9aa02fa070ce4650030edfd32a81b7dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive answers to the query handle together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The query handle and the function are evaluated in the calling process. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if there are no answers to the query handle.</source>
          <target state="translated">在查询句柄的连续答案上调用 &lt;code&gt;Function&lt;/code&gt; 以及一个额外的参数 &lt;code&gt;AccIn&lt;/code&gt; 。查询句柄和函数在调用过程中进行评估。 &lt;code&gt;Function&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递到下一个调用。如果查询句柄没有答案，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="411261c708a55893631cad145cf652a3f25bc6dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive elements of table &lt;code&gt;Name&lt;/code&gt; together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The table elements are traversed in unspecified order. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the table is empty.</source>
          <target state="translated">在表 &lt;code&gt;Name&lt;/code&gt; 的连续元素上调用 &lt;code&gt;Function&lt;/code&gt; 以及一个额外的参数 &lt;code&gt;AccIn&lt;/code&gt; 。表元素以未指定的顺序遍历。 &lt;code&gt;Function&lt;/code&gt; 必须返回一个新的累加器，该累加器将传递给下一个调用。如果表为空，则返回 &lt;code&gt;Acc0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4d0f89deb9513a8ea8d66e61b19ec50cb6a197f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; surrounded by &lt;code&gt;trace([start, ...])&lt;/code&gt; and &lt;code&gt;trace(stop)&lt;/code&gt;.</source>
          <target state="translated">调用被 &lt;code&gt;trace([start, ...])&lt;/code&gt; 和 &lt;code&gt;trace(stop)&lt;/code&gt; 包围的 &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c8e905cfa5d08f37d1d656135714c1381b168281" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt;, where &lt;code&gt;AccessMod&lt;/code&gt; is the default access callback module obtained by &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt;. &lt;code&gt;Args&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">调用 &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt; ，其中 &lt;code&gt;AccessMod&lt;/code&gt; 是 &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt; 获得的默认访问回调模块。 &lt;code&gt;Args&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; （空列表）。</target>
        </trans-unit>
        <trans-unit id="7ba5ad987837e04f29a6e17ab4165c3bf8a13ef5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffcbed2136c4dbb9cb540ca3e3bb945d48a84489" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd2ad960a91e2c7b84aad8b8cab2b4af89af1d4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1619836284281d3b4ace7f8138860d37a317d20" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7eff8e0d0f21895a3712d8b82ab68aad9ff93c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b968f64643fdd3ef4196ca7f2353074d34a25592" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc9bba8191f80d74baf71dc1c6ce5482c73891a5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="672698b739738396e1aaa279f1425416fa4ed4d3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt;.</source>
          <target state="translated">呼叫 &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f15de5c4989490ba445d84120b63ae4fef3a10da" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a49f85d237c7a52c5025bd7a45bcefecee838aed" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1e1b27f2b3d32c30f1a9af2546f7ff28be30d84" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; ，其中 &lt;code&gt;Args&lt;/code&gt; 为 &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adefbd4d29b6f99f9c5284fcea99a93af40e2354" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}]&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; ，其中 &lt;code&gt;Args&lt;/code&gt; 为 &lt;code&gt;[{scope, global}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6371048f46424da76665133d09722d29e17eb95d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="506bd136b0f38c6b5c4e9aba7994479cbf8607c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4768e4194eaa19668e98e8297432714da38f80fe" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt; 。请注意，如果事务成功（原子），则将返回 &lt;code&gt;Fun&lt;/code&gt; 的结果，否则该函数将由于中止原因而退出。</target>
        </trans-unit>
        <trans-unit id="f4238a5e661c7a2d85c9a77b9854e4b9f7ca29a9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt; 。请注意，如果事务成功（原子），则将返回 &lt;code&gt;Fun&lt;/code&gt; 的结果，否则该函数将由于中止原因而退出。</target>
        </trans-unit>
        <trans-unit id="4bef8126b535186f1c6f440c4f89eb4f6b6acd97" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt;, where &lt;code&gt;RecName&lt;/code&gt; is &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt; ，其中 &lt;code&gt;RecName&lt;/code&gt; 为 &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f8dac520c4ed465440262ceedf36f6b5ee392b4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;names(Host)&lt;/code&gt; for all hosts that are specified in the Erlang host file &lt;code&gt;.hosts.erlang&lt;/code&gt;, collects the replies, and then evaluates &lt;code&gt;ping(Node)&lt;/code&gt; on all those nodes. Returns the list of all nodes that are successfully pinged.</source>
          <target state="translated">调用Erlang主机文件 &lt;code&gt;.hosts.erlang&lt;/code&gt; 中指定的所有主机的 &lt;code&gt;names(Host)&lt;/code&gt; ，收集答复，然后在所有这些节点上评估 &lt;code&gt;ping(Node)&lt;/code&gt; 。返回已成功ping通的所有节点的列表。</target>
        </trans-unit>
        <trans-unit id="6f89caf1a58d70de4bc1545d4d2c63f722e1134d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt;. If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows:</source>
          <target state="translated">调用 &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt; 。如果要从命令行启动节点并设置许多伪服务器，则可以按以下方式启动Erlang运行时系统：</target>
        </trans-unit>
        <trans-unit id="2fd282143317f0c95d38258aa5488afaefacb19b" translate="yes" xml:space="preserve">
          <source>Calls a fun, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments.</source>
          <target state="translated">调用一个有趣的方法，将 &lt;code&gt;Args&lt;/code&gt; 中的元素作为参数传递。</target>
        </trans-unit>
        <trans-unit id="bc1df90caee2a0f744537886d1a4a5d884e3a1f0" translate="yes" xml:space="preserve">
          <source>Calls between functions are either  &lt;strong id=&quot;local_call&quot;&gt;local calls&lt;/strong&gt; like &lt;code&gt;f()&lt;/code&gt;, or  &lt;strong id=&quot;external_call&quot;&gt;external calls&lt;/strong&gt; like &lt;code&gt;m:f()&lt;/code&gt;.  &lt;strong id=&quot;module_data&quot;&gt;Module data&lt;/strong&gt;, which are extracted from BEAM files, include local functions, exported functions, local calls and external calls. By default, calls to built-in functions (BIF) are ignored, but if the option &lt;code&gt;builtins&lt;/code&gt;, accepted by some of this module's functions, is set to &lt;code&gt;true&lt;/code&gt;, calls to BIFs are included as well. It is the analyzing OTP version that decides what functions are BIFs. Functional objects are assumed to be called where they are created (and nowhere else).  &lt;strong id=&quot;unresolved_call&quot;&gt;Unresolved calls&lt;/strong&gt; are calls to &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; with variable module, variable function, or variable arguments. Examples are &lt;code&gt;M:F(a)&lt;/code&gt;, &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt;, and &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt;. Unresolved calls are represented by calls where variable modules have been replaced with the atom &lt;code&gt;'$M_EXPR'&lt;/code&gt;, variable functions have been replaced with the atom &lt;code&gt;'$F_EXPR'&lt;/code&gt;, and variable number of arguments have been replaced with the number &lt;code&gt;-1&lt;/code&gt;. The above mentioned examples are represented by calls to &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt;, &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt;, and &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt;. The unresolved calls are a subset of the external calls.</source>
          <target state="translated">函数之间的调用要么是 &lt;strong id=&quot;local_call&quot;&gt;本地调用（&lt;/strong&gt;例如 &lt;code&gt;f()&lt;/code&gt; )，要么是 &lt;strong id=&quot;external_call&quot;&gt;外部调用（&lt;/strong&gt;例如 &lt;code&gt;m:f()&lt;/code&gt; )。 从BEAM文件中提取的&lt;strong id=&quot;module_data&quot;&gt;模块数据&lt;/strong&gt;包括本地功能，导出的功能，本地调用和外部调用。默认情况下，对内置函数（BIF）的调用将被忽略，但是如果该模块的某些功能接受的 &lt;code&gt;builtins&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则也将包括对BIF的调用。决定什么功能是BIF的是分析OTP版本。假定在创建函数的位置（而不是其他位置）调用功能对象。 &lt;strong id=&quot;unresolved_call&quot;&gt;未解决的呼叫&lt;/strong&gt;是要 &lt;code&gt;apply&lt;/code&gt; 呼叫或 &lt;code&gt;spawn&lt;/code&gt; 带有可变模块，可变函数或可变参数的代码。示例是 &lt;code&gt;M:F(a)&lt;/code&gt; ， &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt; 和 &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt; 。未解决的调用由以下调用表示：将变量模块替换为原子 &lt;code&gt;'$M_EXPR'&lt;/code&gt; ，将变量函数替换为原子 &lt;code&gt;'$F_EXPR'&lt;/code&gt; ，并将变量数量的参数替换为数字 &lt;code&gt;-1&lt;/code&gt; 的调用表示。上面提到的示例由对 &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt; ， &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt; 和 &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt; 。未解决的呼叫是外部呼叫的子集。</target>
        </trans-unit>
        <trans-unit id="e175a0645ad31688c1ad90ebe51d1f98332790c8" translate="yes" xml:space="preserve">
          <source>Calls between modules, applications and releases are also directed graphs. The  &lt;strong id=&quot;type&quot;&gt;types&lt;/strong&gt; of the vertices and edges of these graphs are (ranging from the most special to the most general): &lt;code&gt;Fun&lt;/code&gt; for functions; &lt;code&gt;Mod&lt;/code&gt; for modules; &lt;code&gt;App&lt;/code&gt; for applications; and &lt;code&gt;Rel&lt;/code&gt; for releases. The following paragraphs will describe the different constructs of the language used for selecting and analyzing parts of the graphs, beginning with the  &lt;strong id=&quot;constants&quot;&gt;constants&lt;/strong&gt;:</source>
          <target state="translated">模块，应用程序和发行版之间的调用也是有向图。这些图的顶点和边的 &lt;strong id=&quot;type&quot;&gt;类型&lt;/strong&gt;是（从最特殊到最一般）：功能 &lt;code&gt;Fun&lt;/code&gt; ； &lt;code&gt;Mod&lt;/code&gt; 模块 &lt;code&gt;App&lt;/code&gt; 程式；和 &lt;code&gt;Rel&lt;/code&gt; 发布。以下各段将从&lt;strong id=&quot;constants&quot;&gt;常量&lt;/strong&gt;开始，描述用于选择和分析图形各部分的语言的不同结构 ：</target>
        </trans-unit>
        <trans-unit id="be43177e95bbd471940bc32f6f4691d58dabae5d" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1ab266a520f0fa15f418f121757a95a2f87b8a3" translate="yes" xml:space="preserve">
          <source>Calls quickcheck and returns the result in a form suitable for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">调用quickcheck并以适用于 &lt;code&gt;Common Test&lt;/code&gt; 的形式返回结果。</target>
        </trans-unit>
        <trans-unit id="8c7c891f9853016ddc130d88be49b034108f4922" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. It is performed in almost the same context as &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the &lt;code&gt;Fun&lt;/code&gt; returns. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">在不受事务保护的上下文中调用 &lt;code&gt;Fun&lt;/code&gt; 。在 &lt;code&gt;Fun&lt;/code&gt; 中执行的Mnesia函数调用被映射到相应的脏函数。它在与 &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt; 几乎相同的上下文中执行。不同之处在于操作是同步执行的。在 &lt;code&gt;Fun&lt;/code&gt; 返回之前，调用方等待对所有活动副本执行更新。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 和《用户指南》。</target>
        </trans-unit>
        <trans-unit id="7f3ec8be69b09a2c810b010167a3f606775918ce" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal &lt;code&gt;mnesia:dirty_*&lt;/code&gt; operations, the operations are performed semi-asynchronously. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">在不受事务保护的上下文中调用 &lt;code&gt;Fun&lt;/code&gt; 。在 &lt;code&gt;Fun&lt;/code&gt; 中执行的Mnesia函数调用被映射到相应的脏函数。这仍然涉及日志记录，复制和订阅，但是不涉及锁定，本地事务存储或提交协议。检查点保留程序和索引已更新，但它们被更新为脏文件。对于普通的 &lt;code&gt;mnesia:dirty_*&lt;/code&gt; 操作，这些操作是半异步执行的。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 和《用户指南》。</target>
        </trans-unit>
        <trans-unit id="d819d67bdd8cdeb2caeeb18f61988b23312e64a2" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a raw context that is not protected by a transaction. The Mnesia function call is performed in the &lt;code&gt;Fun&lt;/code&gt; and performed directly on the local ETS tables on the assumption that the local storage type is &lt;code&gt;ram_copies&lt;/code&gt; and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to &lt;code&gt;disc_copies&lt;/code&gt; tables if all operations are read only. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">在不受事务保护的原始上下文中调用 &lt;code&gt;Fun&lt;/code&gt; 。Mnesia函数调用是在 &lt;code&gt;Fun&lt;/code&gt; 中执行的，并假定本地存储类型为 &lt;code&gt;ram_copies&lt;/code&gt; 并且未将表复制到其他节点，因此直接在本地ETS表上执行。不会触发订阅，也不会更新检查点，但这非常快。如果所有操作都是只读的，则此函数也可以应用于 &lt;code&gt;disc_copies&lt;/code&gt; 表。有关详细信息，请参见 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 和《用户指南》。</target>
        </trans-unit>
        <trans-unit id="a8a784dd04ba58d02965f17a28a416dac496f4c6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecca9949a5635aaf8c27410eea7636e30e459fb0" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="949e11ed9c4c541b273d5f803d7f14e93decf845" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a8c4bc10158fea84b8bc4d0f51afdb0e35c5827" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cddc0b283837cd9cf6bfc5ffbfc0d1ab69ceebc5" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55f266ac7f0a7fd8339f6a382397f015c2d00cb9" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a04316f127b21a90e451cb0328b531e879c5c8a6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6619bcc0446814c6bc36959f774872812e839577" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">调用函数 &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt; ，其中 &lt;code&gt;Tab&lt;/code&gt; 是 &lt;code&gt;element(1, Record)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="802a6c538e37a7050a99435e4b91321de49b481f" translate="yes" xml:space="preserve">
          <source>Calls the selected tool's function for running the &lt;code&gt;Property&lt;/code&gt;. It is usually and by historical reasons called quickcheck, and that is why that name is used in this module (&lt;code&gt;ct_property_test&lt;/code&gt;).</source>
          <target state="translated">调用所选工具的函数以运行 &lt;code&gt;Property&lt;/code&gt; 。通常，由于历史原因，它称为quickcheck，这就是为什么在此模块（ &lt;code&gt;ct_property_test&lt;/code&gt; ）中使用该名称的原因。</target>
        </trans-unit>
        <trans-unit id="7b9dce33ce75c3e0cd20ec5b024a2864ee93e989" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;free()&lt;/code&gt; function.</source>
          <target state="translated">调用标准的 &lt;code&gt;free()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="b90d8d44b261c3e05c2a69f75c7d0d01e3b518f9" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;malloc()&lt;/code&gt; function.</source>
          <target state="translated">调用标准的 &lt;code&gt;malloc()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="61d6494376d82c6585e92497eb43814699b60b7e" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt; error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt; error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt; logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt; error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt; error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; 以及相应的警告和信息消息功能均作为对 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt; logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; 的调用转发给Logger 。</target>
        </trans-unit>
        <trans-unit id="3f325b7e41b1fdb81e7bc7cb001482dfdf57640d" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; 以及相应的警告和信息消息功能均作为对 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; 的调用转发给Logger 。</target>
        </trans-unit>
        <trans-unit id="681ce3661a9a40c6caccc2250ea6929229c7aac3" translate="yes" xml:space="preserve">
          <source>Calls to functions defined by evaluating fun expressions &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; are also hidden from non-local function handlers.</source>
          <target state="translated">通过评估有趣的表达式 &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; 定义的函数的调用也将从非本地函数处理程序中隐藏。</target>
        </trans-unit>
        <trans-unit id="a78c70fc8985fb6668305436210f739782826d6b" translate="yes" xml:space="preserve">
          <source>Calls to local or external functions (&lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;m:foo()&lt;/code&gt;) are the fastest calls.</source>
          <target state="translated">调用本地或外部函数（ &lt;code&gt;foo()&lt;/code&gt; ， &lt;code&gt;m:foo()&lt;/code&gt; ）是最快的调用。</target>
        </trans-unit>
        <trans-unit id="c1368b924e595a7f64353a1c8704cd02aa9b58af" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in table &lt;code&gt;Type Test BIFs&lt;/code&gt;</source>
          <target state="translated">调用表 &lt;code&gt;Type Test BIFs&lt;/code&gt; 指定的BIF</target>
        </trans-unit>
        <trans-unit id="c476a11e38143a5ca54c749f0467a4a34a7b9e99" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in tables &lt;strong&gt;Type Test BIFs&lt;/strong&gt; and &lt;strong&gt;Other BIFs Allowed in Guard Expressions&lt;/strong&gt;</source>
          <target state="translated">调用表中指定的BIF&lt;strong&gt;类型测试BIF&lt;/strong&gt;和&lt;strong&gt;Guard表达式中允许的其他BIF&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5e2dbf1a74a301e38682ebfa666c1939e25bd23" translate="yes" xml:space="preserve">
          <source>Can another internal data representation be used to make things more efficient?</source>
          <target state="translated">能否用另一种内部数据表示方法来提高工作效率?</target>
        </trans-unit>
        <trans-unit id="ce2b0460aad57730836f17162000a27e6d1988d5" translate="yes" xml:space="preserve">
          <source>Can any redundant tests be removed?</source>
          <target state="translated">能否删除多余的测试?</target>
        </trans-unit>
        <trans-unit id="14d70599293b8e413ef952c38a0440843056f84c" translate="yes" xml:space="preserve">
          <source>Can any test be run less often if the order of tests is changed?</source>
          <target state="translated">如果改变测试的顺序,任何测试都可以减少运行次数吗?</target>
        </trans-unit>
        <trans-unit id="1dbbd23b5878e1a733c169db6ec8393bc170cde2" translate="yes" xml:space="preserve">
          <source>Can be a back reference, or another way of writing a tab</source>
          <target state="translated">可以是回溯引用,也可以是另一种写法的标签。</target>
        </trans-unit>
        <trans-unit id="9ff3af864aead7cd729fa897ed19cd40dd3bea5a" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise the character with octal code 113</source>
          <target state="translated">可作回参,否则为带八进制码113的字符。</target>
        </trans-unit>
        <trans-unit id="ca748588186d1a7e973cd887d71235755974030e" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise value 255 (decimal)</source>
          <target state="translated">可以作为后备参考,否则为255(十进制)。</target>
        </trans-unit>
        <trans-unit id="7d7475380f4be07d179c7231bb2dd90fbd5279b2" translate="yes" xml:space="preserve">
          <source>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">可由进程调用以从本地主机上的EPMD中注销指定的节点。但是，这通常是不允许的，除非EPMD以标志 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 启动，但通常不会。</target>
        </trans-unit>
        <trans-unit id="f44b4080b46d42a3270b0b18ff48ce34cd9d5ec2" translate="yes" xml:space="preserve">
          <source>Can be implemented as:</source>
          <target state="translated">可实施为:</target>
        </trans-unit>
        <trans-unit id="435b9419e03f7e525befa539fe46b7b2779ce303" translate="yes" xml:space="preserve">
          <source>Can be one of the following:</source>
          <target state="translated">可以是下列之一:</target>
        </trans-unit>
        <trans-unit id="18e0b766363b36ea716659f6503b3ddde9e7ec85" translate="yes" xml:space="preserve">
          <source>Can be removed in a future release of the halfword emulator.</source>
          <target state="translated">可以在未来发布的半字模拟器中删除。</target>
        </trans-unit>
        <trans-unit id="a329dd98b578890314d90cd00ae46894da7e6ba8" translate="yes" xml:space="preserve">
          <source>Can be set to &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It controls how each directory in the code path is to be interpreted:</source>
          <target state="translated">可以设置为 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;relaxed&lt;/code&gt; 。它控制如何解释代码路径中的每个目录：</target>
        </trans-unit>
        <trans-unit id="61d2fdff92dff8eebb470df37755eb8b633955c3" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; daemon listens only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified).</source>
          <target state="translated">可以设置为IP地址的逗号分隔列表，在这种情况下， &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 守护程序仅侦听指定的地址和回送地址（如果未指定，则隐式添加到列表中）。</target>
        </trans-unit>
        <trans-unit id="1d6e47517b6960079a15e323f8e14b95671cfd59" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;epmd&lt;/code&gt; daemon will listen only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified). The default behavior is to listen on all available IP addresses.</source>
          <target state="translated">可以设置为IP地址的逗号分隔列表，在这种情况下， &lt;code&gt;epmd&lt;/code&gt; 守护程序将仅侦听指定的地址和回送地址（如果未指定则隐式添加到列表中）。默认行为是侦听所有可用的IP地址。</target>
        </trans-unit>
        <trans-unit id="32027351ef478fb666878cfb7ea809e9ec8104be" translate="yes" xml:space="preserve">
          <source>Can be used as a name resolving function for &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以用作 &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt; 的名称解析功能。</target>
        </trans-unit>
        <trans-unit id="a41238ba1ffe4cd44c8669bf5362c16badbd6e66" translate="yes" xml:space="preserve">
          <source>Can be used by a process that initiates a debug structure from a list of options. The values of argument &lt;code&gt;Opt&lt;/code&gt; are the same as for the corresponding functions.</source>
          <target state="translated">可以由从选项列表中启动调试结构的进程使用。参数 &lt;code&gt;Opt&lt;/code&gt; 的值与相应函数的值相同。</target>
        </trans-unit>
        <trans-unit id="e44e4550227750d3133233de3b9ab784df8d5876" translate="yes" xml:space="preserve">
          <source>Can be used if interactive performance is not to be affected by the emulator process.</source>
          <target state="translated">如果交互性能不受仿真器进程影响,可以使用。</target>
        </trans-unit>
        <trans-unit id="4554428a28a365553523e827200f0a4801491275" translate="yes" xml:space="preserve">
          <source>Can be used if the size of the trace logs must be limited. Default values are &lt;code&gt;Size=128*1024&lt;/code&gt; and &lt;code&gt;Count=8&lt;/code&gt;.</source>
          <target state="translated">如果必须限制跟踪日志的大小，则可以使用。默认值为 &lt;code&gt;Size=128*1024&lt;/code&gt; 和 &lt;code&gt;Count=8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52514699bbc5fce906ba4874a907b457ea6b2ad1" translate="yes" xml:space="preserve">
          <source>Can be used if two Erlang nodes are to reside on one dedicated system and one is to have precedence over the other.</source>
          <target state="translated">如果两个Erlang节点驻扎在一个专用系统上,并且其中一个节点要优先于另一个节点,可以使用。</target>
        </trans-unit>
        <trans-unit id="1cfd6096580c6f0fc105f7dae283a846f824ac79" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</source>
          <target state="translated">可以用来确定底层OpenSSL库支持哪些加密算法。</target>
        </trans-unit>
        <trans-unit id="a809d60db9759dca31c0adaa3ee892b7d609a6ef" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library</source>
          <target state="translated">可以用来确定底层libcrypto库支持哪些加密算法。</target>
        </trans-unit>
        <trans-unit id="8ac2e838e28c4e79b7b0173c19b32b3299e09f77" translate="yes" xml:space="preserve">
          <source>Can be used to determine which named elliptic curves are supported.</source>
          <target state="translated">可以用来确定支持哪些命名的椭圆曲线。</target>
        </trans-unit>
        <trans-unit id="0139eb1de3d0a9614c9b210a184d4b0320912f6e" translate="yes" xml:space="preserve">
          <source>Can be used to make the client act as an &lt;code&gt;HTTP/1.0&lt;/code&gt; or &lt;code&gt;HTTP/0.9&lt;/code&gt; client. By default this is an &lt;code&gt;HTTP/1.1&lt;/code&gt; client. When using &lt;code&gt;HTTP/1.0&lt;/code&gt; persistent connections are not used.</source>
          <target state="translated">可用于使客户端充当 &lt;code&gt;HTTP/1.0&lt;/code&gt; 或 &lt;code&gt;HTTP/0.9&lt;/code&gt; 客户端。默认情况下，这是一个 &lt;code&gt;HTTP/1.1&lt;/code&gt; 客户端。使用 &lt;code&gt;HTTP/1.0&lt;/code&gt; 时，不使用持久连接。</target>
        </trans-unit>
        <trans-unit id="e9de6dfb4b293a374f8bbe2fd001451aff895674" translate="yes" xml:space="preserve">
          <source>Can be used to retrieve information about the C-node. These values are initially set with &lt;code&gt;ei_connect_init()&lt;/code&gt; or &lt;code&gt;ei_connect_xinit()&lt;/code&gt;.</source>
          <target state="translated">可用于检索有关C节点的信息。这些值最初是使用 &lt;code&gt;ei_connect_init()&lt;/code&gt; 或 &lt;code&gt;ei_connect_xinit()&lt;/code&gt; 设置的。</target>
        </trans-unit>
        <trans-unit id="b6b6b3b3a5a2150a389c6b25e1e84aa23960992c" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with a server called &lt;code&gt;Name&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. It is assumed that the server receives messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and replies using &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt;. This function makes such a server call and ensures that the entire call is packed into an atomic transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.</source>
          <target state="translated">与节点 &lt;code&gt;Node&lt;/code&gt; 上名为 &lt;code&gt;Name&lt;/code&gt; 的服务器交互时可以使用。假定服务器接收 &lt;code&gt;{From, Msg}&lt;/code&gt; 格式的消息，并使用 &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt; 回复。 {ReplyWrapper，节点，回复}。此函数进行这样的服务器调用，并确保将整个调用打包到原子事务中，该事务成功或失败。除非服务器本身挂起，否则它永远不会挂起。</target>
        </trans-unit>
        <trans-unit id="bb8693797500f3627529857787e0f8552cc7d7b2" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with servers called &lt;code&gt;Name&lt;/code&gt; on the specified nodes. It is assumed that the servers receive messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and reply using &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the node where the server is located. The function returns &lt;code&gt;{Replies, BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of all &lt;code&gt;Reply&lt;/code&gt; values, and &lt;code&gt;BadNodes&lt;/code&gt; is one of the following:</source>
          <target state="translated">与指定节点上名为 &lt;code&gt;Name&lt;/code&gt; 的服务器交互时可以使用。假定服务器接收 &lt;code&gt;{From, Msg}&lt;/code&gt; 格式的消息并使用 &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt; 回复。 {Name，Node，Reply}，其中 &lt;code&gt;Node&lt;/code&gt; 是服务器所在节点的名称。该函数返回 &lt;code&gt;{Replies, BadNodes}&lt;/code&gt; ，其中 &lt;code&gt;Replies&lt;/code&gt; 是所有 &lt;code&gt;Reply&lt;/code&gt; 值的列表，而 &lt;code&gt;BadNodes&lt;/code&gt; 是下列值之一：</target>
        </trans-unit>
        <trans-unit id="413a11e06a5cc3367aeaca579508da6cce5c360b" translate="yes" xml:space="preserve">
          <source>Can be used with &lt;code&gt;chunk/2,3&lt;/code&gt; and &lt;code&gt;bchunk/2,3&lt;/code&gt; to search through an internally formatted wrap log. It takes as argument a continuation as returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;, and steps forward (or backward) &lt;code&gt;Step&lt;/code&gt; files in the wrap log. The continuation returned, points to the first log item in the new current file.</source>
          <target state="translated">可以与 &lt;code&gt;chunk/2,3&lt;/code&gt; 和 &lt;code&gt;bchunk/2,3&lt;/code&gt; 一起使用，以搜索内部格式化的包装日志。它以 &lt;code&gt;chunk/2,3&lt;/code&gt; ， &lt;code&gt;bchunk/2,3&lt;/code&gt; 或 &lt;code&gt;chunk_step/3&lt;/code&gt; 返回的延续作为参数，并在包装日志中前进（或后退） &lt;code&gt;Step&lt;/code&gt; 文件。返回的继续，指向新的当前文件中的第一个日志项。</target>
        </trans-unit>
        <trans-unit id="54b689659783bb6b4ac1454db70e48394a638a38" translate="yes" xml:space="preserve">
          <source>Can contain the port number &lt;code&gt;epmd&lt;/code&gt; will use. The default port will work fine in most cases. A different port can be specified to allow several instances of &lt;code&gt;epmd&lt;/code&gt;, representing independent clusters of nodes, to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">可以包含 &lt;code&gt;epmd&lt;/code&gt; 将使用的端口号。在大多数情况下，默认端口都可以正常工作。可以指定不同的端口，以允许代表独立节点群集的 &lt;code&gt;epmd&lt;/code&gt; 的多个实例在同一主机上共存。群集中的所有节点必须使用相同的 &lt;code&gt;epmd&lt;/code&gt; 端口号。</target>
        </trans-unit>
        <trans-unit id="d1d4e8ff3c787597c2cdf851d9445ac7a46d3eec" translate="yes" xml:space="preserve">
          <source>Can contain the port number to use when communicating with &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. The default port works fine in most cases. A different port can be specified to allow nodes of independent clusters to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">可以包含与 &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 通信时使用的端口号。在大多数情况下，默认端口都可以正常工作。可以指定不同的端口，以允许独立群集的节点共存于同一主机上。群集中的所有节点必须使用相同的 &lt;code&gt;epmd&lt;/code&gt; 端口号。</target>
        </trans-unit>
        <trans-unit id="763e2024cfbffcaa35312ea836b3ce5e41e09735" translate="yes" xml:space="preserve">
          <source>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</source>
          <target state="translated">可以是传入调用NIF的原件,也可以是调用NIF创建的值。</target>
        </trans-unit>
        <trans-unit id="1762b945a07d7a0928b055cdfb86c61f5e180a18" translate="yes" xml:space="preserve">
          <source>Can enable trace on all functions or only exported functions on chosen modules.</source>
          <target state="translated">可以对所有函数进行跟踪,或者只对所选模块的导出函数进行跟踪。</target>
        </trans-unit>
        <trans-unit id="a6d98498dcb02bc77d5362ec71948bf4dcb80403" translate="yes" xml:space="preserve">
          <source>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</source>
          <target state="translated">只有在底层操作系统的时区信息配置正确的情况下,才可用于检查本地时间。</target>
        </trans-unit>
        <trans-unit id="3b665cc5f87b4b96a8b89bb4858d5c6ded666e00" translate="yes" xml:space="preserve">
          <source>Can only be used with TLS/DTLS connections; &lt;code&gt;{error, undefined}&lt;/code&gt; is returned for SSLv3 connections.</source>
          <target state="translated">只能与TLS / DTLS连接一起使用；对于SSLv3连接，返回 &lt;code&gt;{error, undefined}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="0ce7f9b48109071ca45af63e2c7f4cded74fe895" translate="yes" xml:space="preserve">
          <source>Cancel a previous asynchronous request.</source>
          <target state="translated">取消之前的异步请求。</target>
        </trans-unit>
        <trans-unit id="8c0d517ae93b9275421781af37452eec4bb2fa47" translate="yes" xml:space="preserve">
          <source>Cancel a previous request to be notified of SNMP manager start.</source>
          <target state="translated">取消之前通知SNMP管理器启动的请求。</target>
        </trans-unit>
        <trans-unit id="a9a0f30cfff3cf2f7919e74d440e32f436d7292c" translate="yes" xml:space="preserve">
          <source>Cancel all outstanding messages for this connection</source>
          <target state="translated">取消该连接的所有待处理信息</target>
        </trans-unit>
        <trans-unit id="5aba33ae4d23c8305d0ff9ae3f760f6d7bc6c018" translate="yes" xml:space="preserve">
          <source>Cancel an asynchronous request.</source>
          <target state="translated">取消异步请求。</target>
        </trans-unit>
        <trans-unit id="2e83179d769a2b44650615f9d44ca78b37a04604" translate="yes" xml:space="preserve">
          <source>Cancel the handshake with a fatal &lt;code&gt;USER_CANCELED&lt;/code&gt; alert.</source>
          <target state="translated">使用致命的 &lt;code&gt;USER_CANCELED&lt;/code&gt; 警报取消握手。</target>
        </trans-unit>
        <trans-unit id="512e48b731dfabfc2f052978658a8655b252b710" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier with &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;obj&lt;/code&gt; is a pointer to the resource holding the monitor and &lt;code&gt;*mon&lt;/code&gt; identifies the monitor.</source>
          <target state="translated">取消先前使用 &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt; 创建的监视器。参数 &lt;code&gt;obj&lt;/code&gt; 是指向持有监视器的资源的指针，并且 &lt;code&gt;*mon&lt;/code&gt; 标识监视器。</target>
        </trans-unit>
        <trans-unit id="5e51a49231000a90b74f84cb0f1813b99bdab3f4" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier with &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. Argument &lt;code&gt;obj&lt;/code&gt; is a pointer to the resource holding the monitor and &lt;code&gt;*mon&lt;/code&gt; identifies the monitor.</source>
          <target state="translated">取消先前使用 &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 创建的监视器。参数 &lt;code&gt;obj&lt;/code&gt; 是指向持有监视器的资源的指针， &lt;code&gt;*mon&lt;/code&gt; 标识监视器。</target>
        </trans-unit>
        <trans-unit id="96cae339d2d57bc5c2386eed4ecb967d6f0a23af" translate="yes" xml:space="preserve">
          <source>Cancels a monitor created earlier.</source>
          <target state="translated">取消之前创建的显示器。</target>
        </trans-unit>
        <trans-unit id="1f0665372f0c058f76dc85627e4390cc9a27b91a" translate="yes" xml:space="preserve">
          <source>Cancels a previously requested time-out. &lt;code&gt;TRef&lt;/code&gt; is a unique timer reference returned by the related timer function.</source>
          <target state="translated">取消先前请求的超时。 &lt;code&gt;TRef&lt;/code&gt; 是相关计时器函数返回的唯一计时器参考。</target>
        </trans-unit>
        <trans-unit id="be2d617334028ba42207577f2c0c4db3092e85de" translate="yes" xml:space="preserve">
          <source>Cancels a timer set with &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt; driver_set_timer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消使用 &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt; driver_set_timer&lt;/a&gt;&lt;/code&gt; 设置的计时器。</target>
        </trans-unit>
        <trans-unit id="2dfd6843c1a8e9b558c9edbe4d27191bbd822b29" translate="yes" xml:space="preserve">
          <source>Cancels a timer set with &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt;driver_set_timer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消使用 &lt;code&gt;&lt;a href=&quot;#driver_set_timer&quot;&gt;driver_set_timer&lt;/a&gt;&lt;/code&gt; 设置的计时器。</target>
        </trans-unit>
        <trans-unit id="b17a85c7c341fb9ad575021c84d0507b60def106" translate="yes" xml:space="preserve">
          <source>Cancels a timer that has been created by &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt; erlang:start_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;TimerRef&lt;/code&gt; identifies the timer, and was returned by the BIF that created the timer.</source>
          <target state="translated">取消由 &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt; erlang:start_timer&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt; 创建的计时器。 &lt;code&gt;TimerRef&lt;/code&gt; 标识计时器，并由创建计时器的BIF返回。</target>
        </trans-unit>
        <trans-unit id="f1c27441b4577bb7df82953733b9a8895adaaf42" translate="yes" xml:space="preserve">
          <source>Cancels a timer that has been created by &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;TimerRef&lt;/code&gt; identifies the timer, and was returned by the BIF that created the timer.</source>
          <target state="translated">取消由 &lt;code&gt;&lt;a href=&quot;#start_timer-4&quot;&gt;erlang:start_timer&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#send_after-4&quot;&gt;erlang:send_after&lt;/a&gt;&lt;/code&gt; 创建的计时器。 &lt;code&gt;TimerRef&lt;/code&gt; 标识计时器，并由创建计时器的BIF返回。</target>
        </trans-unit>
        <trans-unit id="0df1541c96a30a0731a1c3888c1e2faced1631ac" translate="yes" xml:space="preserve">
          <source>Cancels a timer. The same as calling &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt; erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消计时器。与调用 &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt; erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="515e3b82893f87b97d2f6951c20fe359a4a9690f" translate="yes" xml:space="preserve">
          <source>Cancels a timer. The same as calling &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt;erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消计时器。与调用 &lt;code&gt;&lt;a href=&quot;#cancel_timer-2&quot;&gt;erlang:cancel_timer(TimerRef, [])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df65de63f9858575da41cfa50c0a1015308635d0" translate="yes" xml:space="preserve">
          <source>Cancels an asynchronous HTTP request. Notice that this does not guarantee that the request response is not delivered. Because it is asynchronous, the request can already have been completed when the cancellation arrives.</source>
          <target state="translated">取消一个异步的HTTP请求。注意,这并不能保证请求响应不被传递。因为它是异步的,当取消到达时,请求可能已经完成了。</target>
        </trans-unit>
        <trans-unit id="b541e4bb9b743ccb5ae258df54a4b47b94078144" translate="yes" xml:space="preserve">
          <source>Cancels any active timetrap and pauses the execution of the current test case until the user calls function &lt;code&gt;continue/0&lt;/code&gt;. The user can then interact with the Erlang node running the tests, for example, for debugging purposes or for manually executing a part of the test case. If a parallel group is executing, &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; is to be called instead.</source>
          <target state="translated">取消任何活动的时间陷阱并暂停当前测试用例的执行，直到用户调用函数Continue &lt;code&gt;continue/0&lt;/code&gt; 为止。然后，用户可以与运行测试的Erlang节点进行交互，例如，用于调试目的或用于手动执行部分测试用例。如果正在执行并行组，则将调用 &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef0062b553bef5e57661343010bd1663e123fb3c" translate="yes" xml:space="preserve">
          <source>Cannot find a script for upgrading/downgrading between &lt;code&gt;CurrentVsn&lt;/code&gt; and &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">找不到用于在 &lt;code&gt;CurrentVsn&lt;/code&gt; 和 &lt;code&gt;Vsn&lt;/code&gt; 之间进行升级/降级的脚本。</target>
        </trans-unit>
        <trans-unit id="59c2c275dbff28468b338a2a1d74abfdb2ab249d" translate="yes" xml:space="preserve">
          <source>Capabilities Exchange</source>
          <target state="translated">能力交流</target>
        </trans-unit>
        <trans-unit id="6f815b9cd6720fa896907fcc11d7b3e052d3034d" translate="yes" xml:space="preserve">
          <source>Capabilities exchange has failed. &lt;code&gt;Reason&lt;/code&gt; can have one of the following types.</source>
          <target state="translated">能力交换失败。 &lt;code&gt;Reason&lt;/code&gt; 可以具有以下类型之一。</target>
        </trans-unit>
        <trans-unit id="650fc093260c1b58ae5fd02c80725cb6220c8159" translate="yes" xml:space="preserve">
          <source>Capabilities-Exchange-Answer</source>
          <target state="translated">Capabilities-Exchange-Answer</target>
        </trans-unit>
        <trans-unit id="acf14eeece446c5904b65bad9ec3f274e5e6164c" translate="yes" xml:space="preserve">
          <source>Capabilities-Exchange-Request</source>
          <target state="translated">Capabilities-Exchange-Request</target>
        </trans-unit>
        <trans-unit id="b2b40c5778d35eb5bdc2d77add606c0d6436b77d" translate="yes" xml:space="preserve">
          <source>Capability options are ignored by connect/1-3 and only_open/1-2, which don't result in an outgoing hello message.</source>
          <target state="translated">能力选项被connect/1-3和only_open/1-2忽略,这两个选项不会导致发出hello消息。</target>
        </trans-unit>
        <trans-unit id="7409a4b0f3b37f1008c113fb6e626f5103a444b1" translate="yes" xml:space="preserve">
          <source>Capitalized &lt;strong&gt;Diameter&lt;/strong&gt; refers to the protocol, lowercase &lt;strong&gt;diameter&lt;/strong&gt; to the Erlang application.</source>
          <target state="translated">大写&lt;strong&gt;直径&lt;/strong&gt;指的是协议，小写&lt;strong&gt;直径&lt;/strong&gt;指的是Erlang应用程序。</target>
        </trans-unit>
        <trans-unit id="6454a649d8a2356d9dddbd06143083fa5db5fee7" translate="yes" xml:space="preserve">
          <source>Captures all log events that would normally be printed by the default logger handler, and prints them to the current test case log. If an event cannot be associated with a test case, it is printed in the &lt;code&gt;Common Test&lt;/code&gt; framework log. This happens for test cases running in parallel and events occuring in-between test cases.</source>
          <target state="translated">捕获通常由默认记录器处理程序打印的所有日志事件，并将它们打印到当前测试用例日志中。如果事件不能与测试用例相关联，则将其打印在&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 框架&amp;rdquo;日志中。对于并行运行的测试用例，以及在测试用例之间发生的事件，会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="3faea7a0af305bcea0e8fcf9cf99c51068a261b7" translate="yes" xml:space="preserve">
          <source>Captures all log events that would normally be printed by the default logger handler, and prints them to the current test case log. If an event cannot be associated with a test case, it is printed in the &lt;code&gt;Common Test&lt;/code&gt; framework log. This happens for test cases running in parallel and events occuring in-between test cases. You can configure the level of &lt;code&gt;SASL&lt;/code&gt; reports using the normal SASL mechanisms.</source>
          <target state="translated">捕获所有通常由默认记录器处理程序打印的日志事件，并将其打印到当前测试用例日志中。如果事件无法与测试用例关联，则将其打印在&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 框架&amp;rdquo;日志中。对于并行运行的测试用例，以及在测试用例之间发生的事件，会发生这种情况。您可以使用常规SASL机制配置 &lt;code&gt;SASL&lt;/code&gt; 报告的级别。</target>
        </trans-unit>
        <trans-unit id="46bfe99abf367a44ddc81f52e9b2dd6714cf8a38" translate="yes" xml:space="preserve">
          <source>Captures all test results and outputs them as surefire XML into a file. The created file is by default called &lt;code&gt;junit_report.xml&lt;/code&gt;. The file name can be changed by setting option &lt;code&gt;path&lt;/code&gt; for this hook, for example:</source>
          <target state="translated">捕获所有测试结果并将其作为surefire XML输出到文件中。默认情况下，创建的文件名为 &lt;code&gt;junit_report.xml&lt;/code&gt; 。可以通过设置此挂钩的选项 &lt;code&gt;path&lt;/code&gt; 来更改文件名，例如：</target>
        </trans-unit>
        <trans-unit id="d07225edcafc11a68f3d5eb9b90023be29cd700a" translate="yes" xml:space="preserve">
          <source>Carefully prevent translating the &lt;code&gt;Raw Trace Data&lt;/code&gt; twice</source>
          <target state="translated">小心防止两次转换 &lt;code&gt;Raw Trace Data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">回程车</target>
        </trans-unit>
        <trans-unit id="6816a4bcee325f605828c9a0983b400ec2b0b807" translate="yes" xml:space="preserve">
          <source>Carriage return (CR)</source>
          <target state="translated">回程车(CR)</target>
        </trans-unit>
        <trans-unit id="4788a491bde10053f4b29b72d3ab33319a6fa543" translate="yes" xml:space="preserve">
          <source>Carriage return (hex 0D)</source>
          <target state="translated">回车(十六进制0D)</target>
        </trans-unit>
        <trans-unit id="730f6dc38b735a30bd3b01925e8207103f8f081e" translate="yes" xml:space="preserve">
          <source>Carriage return.</source>
          <target state="translated">马车返回。</target>
        </trans-unit>
        <trans-unit id="ac86d2f38a97ba396ecc606e85913560b9394190" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;binary_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;binary_alloc&lt;/code&gt; 关联的载波池。</target>
        </trans-unit>
        <trans-unit id="136d8537250d31ffae733f8d73dfb88d027c7ac9" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;driver_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;driver_alloc&lt;/code&gt; 关联的运营商池。</target>
        </trans-unit>
        <trans-unit id="b657ca0fde8e2f710828753eb201ccdcd5d06860" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;eheap_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;eheap_alloc&lt;/code&gt; 关联的运营商池。</target>
        </trans-unit>
        <trans-unit id="af7e183f95d0d26975c1437f27c82e38a4d870eb" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;ets_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;ets_alloc&lt;/code&gt; 关联的运营商池。</target>
        </trans-unit>
        <trans-unit id="a0c2c6f39532ac6a69f54b45c1eed8e7d02ee768" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;fix_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;fix_alloc&lt;/code&gt; 关联的运营商池。</target>
        </trans-unit>
        <trans-unit id="5472ccb63504cc29da8f79c43e9078ef65d5ea61" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;ll_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;ll_alloc&lt;/code&gt; 关联的载波池。</target>
        </trans-unit>
        <trans-unit id="01b7000fafc3012b828e16b84f71bfa568e1ae3c" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;sl_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;sl_alloc&lt;/code&gt; 关联的载波池。</target>
        </trans-unit>
        <trans-unit id="ceb54b6df2e43a144c15799ad5adbf3de30533a4" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with &lt;code&gt;std_alloc&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;std_alloc&lt;/code&gt; 关联的载波池。</target>
        </trans-unit>
        <trans-unit id="c7aab2373100333dca607e632e879d37cb0f2d2f" translate="yes" xml:space="preserve">
          <source>Carrier pool associated with the system as a whole.</source>
          <target state="translated">与整个系统相关的载体库。</target>
        </trans-unit>
        <trans-unit id="dc8d706f8d246ecbcbc193deb6d5f3e407c9522d" translate="yes" xml:space="preserve">
          <source>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from an allocator instance of the same allocator type. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; used. Only the strategies &lt;code&gt;aoff&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;, &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;ageffcaoff&lt;/code&gt;m, &lt;code&gt;ageffcbf&lt;/code&gt; and &lt;code&gt;ageffcaobf&lt;/code&gt; support abandoned carriers.</source>
          <target state="translated">当分配器实例中的内存利用率低于使用的利用率值时，将放弃载波。一旦放弃了承运人，便不会在其中进行新的分配。当分配器实例获得增加的多块载波需求时，它首先尝试从相同分配器类型的分配器实例中获取废弃的载波。如果无法获取任何废弃的承运人，它将创建一个新的空承运人。取回废弃的承运人后，它将充当普通承运人。此功能对使用的 &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; 有特殊要求。仅策略 &lt;code&gt;aoff&lt;/code&gt; ， &lt;code&gt;aoffcbf&lt;/code&gt; ， &lt;code&gt;aoffcaobf&lt;/code&gt; ， &lt;code&gt;ageffcaoff&lt;/code&gt; m， &lt;code&gt;ageffcbf&lt;/code&gt; 和 &lt;code&gt;ageffcaobf&lt;/code&gt; 支持废弃的载体。</target>
        </trans-unit>
        <trans-unit id="caef8d032299864b49e02c5e2220052e5b8ad212" translate="yes" xml:space="preserve">
          <source>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from another allocator instance. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; used. Only the strategies &lt;code&gt;aoff&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;, &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;ageffcaoff&lt;/code&gt;m, &lt;code&gt;ageffcbf&lt;/code&gt; and &lt;code&gt;ageffcaobf&lt;/code&gt; support abandoned carriers.</source>
          <target state="translated">当分配器实例中的内存利用率低于所使用的利用率值时，将放弃载波。一旦放弃了承运人，便不会在其中进行新的分配。当分配器实例获得增加的多块载波需求时，它首先尝试从另一个分配器实例获取废弃的载波。如果无法获取任何废弃的承运人，它将创建一个新的空承运人。取回废弃的承运人后，它将作为普通承运人使用。此功能对使用的 &lt;code&gt;&lt;a href=&quot;#M_as&quot;&gt;allocation strategy&lt;/a&gt;&lt;/code&gt; 有特殊要求。仅策略 &lt;code&gt;aoff&lt;/code&gt; ， &lt;code&gt;aoffcbf&lt;/code&gt; ， &lt;code&gt;aoffcaobf&lt;/code&gt; ， &lt;code&gt;ageffcaoff&lt;/code&gt; m， &lt;code&gt;ageffcbf&lt;/code&gt; 和 &lt;code&gt;ageffcaobf&lt;/code&gt; 支持废弃的运营商。</target>
        </trans-unit>
        <trans-unit id="248440260111abecc898e4704059b3f4b5c930ae" translate="yes" xml:space="preserve">
          <source>Case-related information is sent to the minor log file.</source>
          <target state="translated">与案件有关的信息会被发送到次要日志文件中。</target>
        </trans-unit>
        <trans-unit id="553cb7afb2839db8e29aca4e968f3b1d24ea5656" translate="yes" xml:space="preserve">
          <source>Categories in a CSS file installed with flag &lt;code&gt;-stylesheet&lt;/code&gt; are on a global test level in the sense that they can be used in any suite that is part of the test run.</source>
          <target state="translated">带有标志 &lt;code&gt;-stylesheet&lt;/code&gt; 的CSS文件中的类别处于全局测试级别，可以在测试运行的任何套件中使用它们。</target>
        </trans-unit>
        <trans-unit id="1fd68e15271b50917550f2816bf00e0a52193319" translate="yes" xml:space="preserve">
          <source>Caucasian_Albanian</source>
          <target state="translated">Caucasian_Albanian</target>
        </trans-unit>
        <trans-unit id="e2d6fad43a0498df568c18e20abea6e5fa09545f" translate="yes" xml:space="preserve">
          <source>Cause &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; to return &lt;code&gt;ok&lt;/code&gt; as soon as the request in question has been encoded, instead of waiting for and returning the result from a subsequent &lt;code&gt;handle_answer/4&lt;/code&gt; or &lt;code&gt;handle_error/4&lt;/code&gt; callback.</source>
          <target state="translated">引起问题的请求被编码后，立即使 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;ok&lt;/code&gt; ，而不是等待并从后续的 &lt;code&gt;handle_answer/4&lt;/code&gt; 或handle_error &lt;code&gt;handle_error/4&lt;/code&gt; 回调返回结果。</target>
        </trans-unit>
        <trans-unit id="570360f716edc9b6804b7e0a9d5afd7c16e0085a" translate="yes" xml:space="preserve">
          <source>Causes a &lt;code&gt;return_from&lt;/code&gt; trace message to be sent upon return from the current function. Takes no arguments, returns &lt;code&gt;true&lt;/code&gt; and can only be used in the &lt;code&gt;MatchBody&lt;/code&gt; part when tracing. If the process trace flag &lt;code&gt;silent&lt;/code&gt; is active, the &lt;code&gt;return_from&lt;/code&gt; trace message is inhibited.</source>
          <target state="translated">导致从当前函数返回时发送 &lt;code&gt;return_from&lt;/code&gt; 跟踪消息。不带参数，返回 &lt;code&gt;true&lt;/code&gt; ，并且只能在跟踪时在 &lt;code&gt;MatchBody&lt;/code&gt; 部分中使用。如果进程跟踪标志 &lt;code&gt;silent&lt;/code&gt; 是活动的，则禁止 &lt;code&gt;return_from&lt;/code&gt; 跟踪消息。</target>
        </trans-unit>
        <trans-unit id="0f83a449788035c5daddd3c7cc544bc89f92b0e1" translate="yes" xml:space="preserve">
          <source>Causes all functions in the module to be exported.</source>
          <target state="translated">导致模块中的所有函数被导出。</target>
        </trans-unit>
        <trans-unit id="fe332b700f28356ff8a5f78d81f00f95837a3633" translate="yes" xml:space="preserve">
          <source>Causes all functions whose names match &lt;code&gt;..._test()&lt;/code&gt; or &lt;code&gt;..._test_()&lt;/code&gt; to be automatically exported from the module (unless testing is turned off, or the &lt;code&gt;EUNIT_NOAUTO&lt;/code&gt; macro is defined)</source>
          <target state="translated">使名称与 &lt;code&gt;..._test()&lt;/code&gt; 或 &lt;code&gt;..._test_()&lt;/code&gt; 匹配的所有函数自动从模块中导出（除非关闭测试或定义了 &lt;code&gt;EUNIT_NOAUTO&lt;/code&gt; 宏）</target>
        </trans-unit>
        <trans-unit id="cbf5a345cd73ab13c594b9386ee0ccc9585d1458" translate="yes" xml:space="preserve">
          <source>Causes an incoming CER to be answered with the specified Result-Code.</source>
          <target state="translated">使收到的CER用指定的Result-Code回复。</target>
        </trans-unit>
        <trans-unit id="bfdce3d3f20fa4bdb35120d035e253a72f1f27ab" translate="yes" xml:space="preserve">
          <source>Causes an incoming CER to be discarded without CEA being sent.</source>
          <target state="translated">导致在没有发送CEA的情况下丢弃收到的CER。</target>
        </trans-unit>
        <trans-unit id="1c84a25f88cef95a969186ffd086cc21cc0bdce3" translate="yes" xml:space="preserve">
          <source>Causes errors to be printed as they occur. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">导致出现错误时将其打印出来。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8faf1fc25487a79ecf11509cc8431e2ab3c9529c" translate="yes" xml:space="preserve">
          <source>Causes errors/warnings to be printed as they occur.</source>
          <target state="translated">导致错误/警告在发生时被打印出来。</target>
        </trans-unit>
        <trans-unit id="77b4c47a390eff838ecbf5032f6fac69686fec82" translate="yes" xml:space="preserve">
          <source>Causes more verbose information from the compiler describing what it is doing.</source>
          <target state="translated">导致编译器提供更多的信息来描述它正在做什么。</target>
        </trans-unit>
        <trans-unit id="00e83a1aaa3324cf8e746707d300d67e05f61a48" translate="yes" xml:space="preserve">
          <source>Causes more verbose information from the compiler, describing what it is doing.</source>
          <target state="translated">引起编译器更多的啰嗦信息,描述它正在做什么。</target>
        </trans-unit>
        <trans-unit id="0147f8a181b5f581485dbe15e687595d798e64d1" translate="yes" xml:space="preserve">
          <source>Causes parsing of the dictionary to terminate: any remaining content is ignored.</source>
          <target state="translated">导致字典解析终止:任何剩余的内容被忽略。</target>
        </trans-unit>
        <trans-unit id="d9b63b06428fd02872f1b766f95c730b7cc03fb1" translate="yes" xml:space="preserve">
          <source>Causes the UserMod:handle_disconnect/2 callback function to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">导致UserMod:handle_disconnect/2回调函数被调用。关于回调参数的更多信息,请参见megaco_user模块。</target>
        </trans-unit>
        <trans-unit id="19040404a924124b084f13439cbc9fccbe3088f6" translate="yes" xml:space="preserve">
          <source>Causes the analysis to be appended to the destination file. This option is only allowed with the &lt;code&gt;{dest, Destfile}&lt;/code&gt; option.</source>
          <target state="translated">使分析附加到目标文件。此选项仅与 &lt;code&gt;{dest, Destfile}&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="b817b5ff6a5ae6d79528aae932bd44bb7e51b112" translate="yes" xml:space="preserve">
          <source>Causes the macro to behave as if it had never been defined.</source>
          <target state="translated">导致宏的行为就像它从未被定义过一样。</target>
        </trans-unit>
        <trans-unit id="de3d942d1cb015f65f7810221dee3bf9248a3179" translate="yes" xml:space="preserve">
          <source>Causes the parse transformation function &lt;code&gt;Module:parse_transform/2&lt;/code&gt; to be applied to the parsed code before the code is checked for errors.</source>
          <target state="translated">使解析转换函数 &lt;code&gt;Module:parse_transform/2&lt;/code&gt; 在检查错误之前将其应用于解析后的代码。</target>
        </trans-unit>
        <trans-unit id="9b957bc52c303103671e3fd8a1393097cbb4ac1b" translate="yes" xml:space="preserve">
          <source>Causes the trace text dump to be appended to the destination file. This option is only allowed with the &lt;code&gt;{dump, Dumpfile}&lt;/code&gt; option.</source>
          <target state="translated">使跟踪文本转储附加到目标文件。此选项仅与 &lt;code&gt;{dump, Dumpfile}&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="897e3b8b3636eede78c888d979db2f52548fa5c1" translate="yes" xml:space="preserve">
          <source>Causes warnings to be emitted for malformed format strings as arguments to &lt;code&gt;io:format&lt;/code&gt; and similar functions.</source>
          <target state="translated">导致针对格式错误的格式字符串发出警告，作为 &lt;code&gt;io:format&lt;/code&gt; 和类似函数的参数。</target>
        </trans-unit>
        <trans-unit id="468df461393d6efb98c52bfe23ce339db17eda3e" translate="yes" xml:space="preserve">
          <source>Causes warnings to be printed as they occur. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">使警告在发生时被打印。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0264d4e983281d4906c3269105e1222b5bb44053" translate="yes" xml:space="preserve">
          <source>Causes warnings to be treated as errors.</source>
          <target state="translated">使得警告被当作错误处理。</target>
        </trans-unit>
        <trans-unit id="3d0409736faa64f257591577d0f14d0f47ce2247" translate="yes" xml:space="preserve">
          <source>Causes warnings to be treated as errors. This option is supported since R13B04.</source>
          <target state="translated">使得警告被当作错误处理。自R13B04起支持该选项。</target>
        </trans-unit>
        <trans-unit id="f259ea23d772c19d8bca466e8d68aee439724a78" translate="yes" xml:space="preserve">
          <source>Caveats: It is possible that in some intricate uses of macros, the automatic addition or removal of parentheses around uses or arguments could cause the resulting program to be rejected by the compiler; however, we have found no such case in existing code. Programs defining strange macros can usually not be read by this program, and in those cases, no changes will be made.</source>
          <target state="translated">注意事项。在某些复杂的宏使用中,自动添加或删除使用或参数周围的括号可能会导致编译器拒绝接受所产生的程序;然而,我们在现有代码中没有发现这种情况。定义了奇怪的宏的程序通常不能被本程序读取,在这些情况下,不会进行任何修改。</target>
        </trans-unit>
        <trans-unit id="cd09cc5afdfaee26581cf1607b738318f0a04c65" translate="yes" xml:space="preserve">
          <source>Certain number ranges are unused in the Unicode standard and certain ranges are even deemed invalid. The most notable invalid range is 16#D800-16#DFFF, as the UTF-16 encoding does not allow for encoding of these numbers. This is possibly because the UTF-16 encoding standard, from the beginning, was expected to be able to hold all Unicode characters in one 16-bit entity, but was then extended, leaving a hole in the Unicode range to handle backward compatibility.</source>
          <target state="translated">在Unicode标准中,某些数字范围未被使用,某些范围甚至被认为是无效的。最显著的无效范围是16#D800-16#DFFF,因为UTF-16编码不允许对这些数字进行编码。这可能是因为UTF-16编码标准,从一开始就希望能够在一个16位实体中容纳所有的Unicode字符,但后来经过扩展,在Unicode范围内留下了一个漏洞,以处理后向兼容性。</target>
        </trans-unit>
        <trans-unit id="5d3c10b1e796e5a14360b76e7498544801074c9d" translate="yes" xml:space="preserve">
          <source>Certain rules are assigned precedence: each rule gets its precedence from the last terminal symbol mentioned in the right hand side of the rule. It is also possible to declare precedence for non-terminals, &quot;one level up&quot;. This is practical when an operator is overloaded (see also example 3 below).</source>
          <target state="translated">某些规则被分配了优先权:每条规则从规则右侧提到的最后一个终端符号开始获得优先权。也可以声明非终端符号的优先权,&quot;向上一级&quot;。当一个运算符超载时,这很实用(也可参见下面的例子3)。</target>
        </trans-unit>
        <trans-unit id="3180f1c1f32b65006b85da77cea65d80026bae04" translate="yes" xml:space="preserve">
          <source>Certain test cases can be skipped, for example, if you know beforehand that a specific test case fails. The reason can be functionality that is not yet implemented, a bug that is known but not yet fixed, or some functionality that does not work or is not applicable on a specific platform.</source>
          <target state="translated">某些测试用例可以跳过,例如,如果你事先知道某个测试用例失败了。原因可能是尚未实现的功能、已知但尚未修复的bug,或者是某些功能在特定平台上无法使用或不适用。</target>
        </trans-unit>
        <trans-unit id="999e5e7507ba94a1d7631bcf4c10334915590194" translate="yes" xml:space="preserve">
          <source>Certificate has been revoked.</source>
          <target state="translated">证书已被吊销。</target>
        </trans-unit>
        <trans-unit id="0b6eec6ad7c2348607b9e4b41754fcd255f1c17a" translate="yes" xml:space="preserve">
          <source>Certificate is no longer valid as its expiration date has passed.</source>
          <target state="translated">证书已过有效期,不再有效。</target>
        </trans-unit>
        <trans-unit id="69417444a01d0d453bf4da2f0da7701629e5a93c" translate="yes" xml:space="preserve">
          <source>Certificate issuer name does not match the name of the issuer certificate in the chain.</source>
          <target state="translated">证书签发人名称与链中的签发人证书名称不一致。</target>
        </trans-unit>
        <trans-unit id="8ab1754189014a0bc3712d551c0d0331beb34096" translate="yes" xml:space="preserve">
          <source>Certificate key is used in an invalid way according to the key-usage extension.</source>
          <target state="translated">根据密钥使用扩展,证书密钥的使用方式无效。</target>
        </trans-unit>
        <trans-unit id="680c591d0862d9b1063d06f96b583acb5de4ebd3" translate="yes" xml:space="preserve">
          <source>Certificate was not signed by its issuer certificate in the chain.</source>
          <target state="translated">证书在链中没有由其签发人证书签署。</target>
        </trans-unit>
        <trans-unit id="a9bc03e07fc3770d504d681b695e6fed1e572534" translate="yes" xml:space="preserve">
          <source>Certificate, required to have the basic constraints extension, does not have a basic constraints extension.</source>
          <target state="translated">证书,要求有基本约束扩展,没有基本约束扩展。</target>
        </trans-unit>
        <trans-unit id="59b70cee319b6c2654812c5bf036b5f85bf580e7" translate="yes" xml:space="preserve">
          <source>Certificates and encrypted keys</source>
          <target state="translated">证书和加密钥匙</target>
        </trans-unit>
        <trans-unit id="cb6957d832f13c5b979dae257330fa5af06b6aa5" translate="yes" xml:space="preserve">
          <source>Certificates are issued by Certification Authorities (CAs) only. A handful of top CAs in the world issue root certificates. You can examine several of these certificates by clicking through the menus of your web browser.</source>
          <target state="translated">证书只由认证机构(CA)颁发。世界上只有少数几家顶级CA颁发根证书。你可以通过点击网页浏览器的菜单来检查其中的几个证书。</target>
        </trans-unit>
        <trans-unit id="3ce54cf97f873be5bebccb8e6c1d864f3b0db087" translate="yes" xml:space="preserve">
          <source>Certificates can be decoded as usual:</source>
          <target state="translated">证书可以照常解码。</target>
        </trans-unit>
        <trans-unit id="92db73edd7e65422b778bdc23c60b96a0a395ba3" translate="yes" xml:space="preserve">
          <source>Certificates using weak (md5) digests may also cause problems in TLS. Although TLS 1.2 has an extension for specifying which type of signatures are accepted, and in FIPS mode the ssl application will use it properly, most TLS implementations ignore this extension and simply send whatever certificates they were configured with.</source>
          <target state="translated">使用弱(md5)摘要的证书也可能在TLS中引起问题。虽然TLS 1.2有一个扩展,可以指定接受哪种类型的签名,在FIPS模式下,ssl应用程序将正确使用它,但大多数TLS实现忽略了这个扩展,只是发送他们配置的任何证书。</target>
        </trans-unit>
        <trans-unit id="003f0acfc90ac4e6ff2e70f00b581c216de026fc" translate="yes" xml:space="preserve">
          <source>Certificates: RSA and ECDSA keys</source>
          <target state="translated">证书。RSA和ECDSA钥匙</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="7286ab5f88d6d6d36d7cd5f44676cfc60c5f9003" translate="yes" xml:space="preserve">
          <source>Change active trace pattern globally on all trace nodes.</source>
          <target state="translated">全局改变所有跟踪节点的活动跟踪模式。</target>
        </trans-unit>
        <trans-unit id="3dd3f919f82791c255901c8a00754ab8bbb9e876" translate="yes" xml:space="preserve">
          <source>Change configuration parameter &lt;code&gt;lines&lt;/code&gt; with text-based presentation. Before the change, 10 lines are presented as follows:</source>
          <target state="translated">使用基于文本的演示文稿更改配置参数 &lt;code&gt;lines&lt;/code&gt; 。更改之前，有10行显示如下：</target>
        </trans-unit>
        <trans-unit id="c48fe199607ed82477a3bc92a81b82652b6351b0" translate="yes" xml:space="preserve">
          <source>Change directory into the top directory of the Erlang/OTP source tree.</source>
          <target state="translated">将目录改为Erlang/OTP源代码树的顶级目录。</target>
        </trans-unit>
        <trans-unit id="c23d69ee8e32cac337611be5b332231d09c49939" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; for the running server. This can be done during any &lt;strong&gt;state transition&lt;/strong&gt;, whether it is a &lt;strong&gt;state change&lt;/strong&gt; or not, but it can</source>
          <target state="translated">更改正在运行的服务器的 &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 。可以在任何&lt;strong&gt;状态转换&lt;/strong&gt;过程中完成此操作，无论它是否为&lt;strong&gt;状态更改&lt;/strong&gt;，但都可以 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d924e009393c56b1a8ab6dc037cbebf547a8a1" translate="yes" xml:space="preserve">
          <source>Change the array size. If &lt;code&gt;Size&lt;/code&gt; is not a non-negative integer, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;. If the specified array has fixed size, also the resulting array has fixed size.</source>
          <target state="translated">更改数组大小。如果 &lt;code&gt;Size&lt;/code&gt; 不是一个非负整数，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。如果指定的数组具有固定大小，则生成的数组也具有固定大小。</target>
        </trans-unit>
        <trans-unit id="e7a199ef9b5d9d2c5eb0397d8b3600da554f2bdd" translate="yes" xml:space="preserve">
          <source>Change the mib server cache &lt;code&gt;age&lt;/code&gt; property.</source>
          <target state="translated">改变MIB服务器缓存 &lt;code&gt;age&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c9751694da7f73924c4340976c6c033e21cb85c3" translate="yes" xml:space="preserve">
          <source>Change the mib server cache &lt;code&gt;gclimit&lt;/code&gt; property.</source>
          <target state="translated">更改mib服务器缓存 &lt;code&gt;gclimit&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="e084ea3f5824de0afa0039d0b4e556968aed9ea5" translate="yes" xml:space="preserve">
          <source>Change the pid of the note-store process. This is used when the server re-starts the note_store (e.g. after a crach).</source>
          <target state="translated">更改note-store进程的pid。这是在服务器重新启动note_store时使用的(例如,在一次故障后)。</target>
        </trans-unit>
        <trans-unit id="f662c37eeb5824eb8f0f0ddeca89cbddc590f1f1" translate="yes" xml:space="preserve">
          <source>Change the table variable of last identifier used. Since multiple writes might occur at the same time this value may already have been changed by to an identifier larger that the one we got. In this case we can continue; otherwise, we need to change it to the identifier we got.</source>
          <target state="translated">改变最后使用的标识符的表变量。由于在同一时间可能会发生多次写入,这个值可能已经被改成了一个大于我们得到的标识符的值。在这种情况下,我们可以继续;否则,我们需要将其改为我们得到的标识符。</target>
        </trans-unit>
        <trans-unit id="341bfe617120dadefc9fcb3d22fe992700ca08f9" translate="yes" xml:space="preserve">
          <source>Change the verbosity of a running network interface process.</source>
          <target state="translated">改变正在运行的网络接口进程的语气。</target>
        </trans-unit>
        <trans-unit id="02a9b0ba8593dbfae3c339a44c3092bcba3b8671" translate="yes" xml:space="preserve">
          <source>Change the verbosity of the network interface process.</source>
          <target state="translated">改变网络接口流程的啰嗦。</target>
        </trans-unit>
        <trans-unit id="ff6b6a8f375eca0b9e425530fea55372fbd3365c" translate="yes" xml:space="preserve">
          <source>Changes configuration for a TFTP daemon, server, or client process.</source>
          <target state="translated">更改TFTP守护进程、服务器或客户端进程的配置。</target>
        </trans-unit>
        <trans-unit id="f16ea5025d3ec69b9225203c8d7c9acd2b6b84ea" translate="yes" xml:space="preserve">
          <source>Changes configuration for all TFTP daemon processes.</source>
          <target state="translated">更改所有TFTP守护进程的配置。</target>
        </trans-unit>
        <trans-unit id="b32da3ba11eaa3c316e57b6c769c2daab761c896" translate="yes" xml:space="preserve">
          <source>Changes configuration for all TFTP server processes.</source>
          <target state="translated">更改所有TFTP服务器进程的配置。</target>
        </trans-unit>
        <trans-unit id="8482f68d74594da4f2fd3456f32fb4a41a18bd39" translate="yes" xml:space="preserve">
          <source>Changes directory on remote host.</source>
          <target state="translated">更改远程主机上的目录。</target>
        </trans-unit>
        <trans-unit id="d281ca109e76e6981bff271db8f62dc625be8e9c" translate="yes" xml:space="preserve">
          <source>Changes file information. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;FileInfo&lt;/code&gt; is a record &lt;code&gt;file_info&lt;/code&gt;, defined in the Kernel include file &lt;code&gt;file.hrl&lt;/code&gt;. Include the following directive in the module from which the function is called:</source>
          <target state="translated">更改文件信息。如果成功，则返回 &lt;code&gt;ok&lt;/code&gt; ，否则返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。 &lt;code&gt;FileInfo&lt;/code&gt; 是一个记录 &lt;code&gt;file_info&lt;/code&gt; ，在内核包含文件 &lt;code&gt;file.hrl&lt;/code&gt; 中定义。在调用该函数的模块中包含以下指令：</target>
        </trans-unit>
        <trans-unit id="c8cf0fa0868a33f5588f4a5b5170d1fcd8206179" translate="yes" xml:space="preserve">
          <source>Changes from RFC 3588</source>
          <target state="translated">RFC 3588的变化</target>
        </trans-unit>
        <trans-unit id="2185d4fc37add3289e7fc270b3db893f925e8611" translate="yes" xml:space="preserve">
          <source>Changes group of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件组。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03a9c85cc9b1feb4f5518bdc78b94b4ea466deb3" translate="yes" xml:space="preserve">
          <source>Changes owner and group of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件的所有者和组。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405ee5678303f5e16347afc4ce653405b2bad93d" translate="yes" xml:space="preserve">
          <source>Changes owner of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件的所有者。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="073a53e6a3aecdc3f5cd1a10f6cb02b7c344399c" translate="yes" xml:space="preserve">
          <source>Changes permissions of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件的权限。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbd474b5d467916b0bc9e853a88f7bd55bc3b1dd" translate="yes" xml:space="preserve">
          <source>Changes the array size to that reported by &lt;code&gt;&lt;a href=&quot;#sparse_size-1&quot;&gt;sparse_size/1&lt;/a&gt;&lt;/code&gt;. If the specified array has fixed size, also the resulting array has fixed size.</source>
          <target state="translated">将数组大小更改为 &lt;code&gt;&lt;a href=&quot;#sparse_size-1&quot;&gt;sparse_size/1&lt;/a&gt;&lt;/code&gt; 报告的大小。如果指定的数组具有固定大小，则生成的数组也具有固定大小。</target>
        </trans-unit>
        <trans-unit id="42e8e1bf8b6b458b020c58f0d7cf5e61ace38032" translate="yes" xml:space="preserve">
          <source>Changes the callback module to &lt;code&gt;NewModule&lt;/code&gt; which will be used when calling all subsequent &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将回调模块更改为 &lt;code&gt;NewModule&lt;/code&gt; ，将在调用所有后续 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16b1291ef2ad9b4aec43c99d7e1e7cba0334731f" translate="yes" xml:space="preserve">
          <source>Changes the configuration parameters of the tool during runtime. Allowed parameters are &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;accumulate&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;.</source>
          <target state="translated">在运行时更改工具的配置参数。允许的参数是 &lt;code&gt;lines&lt;/code&gt; ， &lt;code&gt;interval&lt;/code&gt; ， &lt;code&gt;accumulate&lt;/code&gt; 和 &lt;code&gt;sort&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23248a37a3d67f459527886d08feb41c5630ae58" translate="yes" xml:space="preserve">
          <source>Changes the controlling process of &lt;code&gt;Z&lt;/code&gt; to &lt;code&gt;Pid&lt;/code&gt;, which must be a local process.</source>
          <target state="translated">将 &lt;code&gt;Z&lt;/code&gt; 的控制过程更改为 &lt;code&gt;Pid&lt;/code&gt; ，该过程必须是本地过程。</target>
        </trans-unit>
        <trans-unit id="b2bcd01e499841b88e35ebb5e2f95e2bb587e363" translate="yes" xml:space="preserve">
          <source>Changes the current key to another key. Works like &lt;code&gt;cd&lt;/code&gt;. The key can be specified as a relative path or as an absolute path, starting with &lt;code&gt;\.&lt;/code&gt;</source>
          <target state="translated">将当前密钥更改为另一个密钥。像 &lt;code&gt;cd&lt;/code&gt; 一样工作。键可以指定为相对路径或绝对路径，以 &lt;code&gt;\.&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="81dc09e780693aae3b8c40d802b20f2d68ebb91f" translate="yes" xml:space="preserve">
          <source>Changes the engine id for a target in the &lt;code&gt;snmpTargetAddrTable&lt;/code&gt;. If notifications are sent as Inform requests to a target, its engine id must be set.</source>
          <target state="translated">在 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 中更改目标的引擎ID 。如果将通知作为Inform请求发送给目标，则必须设置其引擎ID。</target>
        </trans-unit>
        <trans-unit id="82f302677f18eacd93a3f042d9f2ce8910208cf5" translate="yes" xml:space="preserve">
          <source>Changes the file transfer type.</source>
          <target state="translated">更改文件传输类型。</target>
        </trans-unit>
        <trans-unit id="3c0a7cde930b2e8e077e329dea2a405f76520b4a" translate="yes" xml:space="preserve">
          <source>Changes the internal debug level of Mnesia. For details, see &lt;code&gt;&lt;a href=&quot;#configuration_parameters&quot;&gt;Section Configuration Parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改Mnesia的内部调试级别。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#configuration_parameters&quot;&gt;Section Configuration Parameters&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27ead72514dc8602f8f4d4399518e861eb941dcb" translate="yes" xml:space="preserve">
          <source>Changes the log size of the Audit Trail Log. The application must be configured to use the audit trail log function. Please refer to disk_log(3) in Kernel Reference Manual for a description of how to change the log size.</source>
          <target state="translated">更改审计跟踪日志的日志大小。应用程序必须被配置为使用审计跟踪日志功能,请参考《内核参考手册》中的disk_log(3)来描述如何改变日志大小。请参考《内核参考手册》中的disk_log(3),了解如何改变日志大小。</target>
        </trans-unit>
        <trans-unit id="edf0f52ab6ef854a099ffb48ffcc61abe0679fbd" translate="yes" xml:space="preserve">
          <source>Changes the minimum binary virtual heap size for the calling process.</source>
          <target state="translated">改变调用进程的最小二进制虚拟堆大小。</target>
        </trans-unit>
        <trans-unit id="cd62e646ddb7759d296c1116e9d9b99ab0d39a03" translate="yes" xml:space="preserve">
          <source>Changes the minimum heap size for the calling process.</source>
          <target state="translated">改变调用过程的最小堆大小。</target>
        </trans-unit>
        <trans-unit id="02d140eecd4ba1c23ab94e5ac346ef7891994f87" translate="yes" xml:space="preserve">
          <source>Changes the modification and access times of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件的修改和访问时间。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17bbc9dee276ef0c87d8c99c66cd5c924b4de477" translate="yes" xml:space="preserve">
          <source>Changes the modification and last access times of a file. See &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件的修改时间和最后访问时间。参见 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67cc7746cb125f758137fcc8fa2dcf5873b3c571" translate="yes" xml:space="preserve">
          <source>Changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">将发出的规则的名称更改为 &lt;code&gt;Target&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="193917ddeda5009fd378d28653931edd2c5181f2" translate="yes" xml:space="preserve">
          <source>Changes the permission for &lt;code&gt;Application&lt;/code&gt; to run at the current node. The application must be loaded using &lt;code&gt;load/1,2&lt;/code&gt; for the function to have effect.</source>
          <target state="translated">更改 &lt;code&gt;Application&lt;/code&gt; 在当前节点上运行的权限。为了使该功能生效，必须使用 &lt;code&gt;load/1,2&lt;/code&gt; 加载该应用程序。</target>
        </trans-unit>
        <trans-unit id="d8bf655f410bfe8330e2a69ecdd33a05eb4542f2" translate="yes" xml:space="preserve">
          <source>Changes the request limit.</source>
          <target state="translated">更改请求限制。</target>
        </trans-unit>
        <trans-unit id="19a54b6d38821902fb1eacf32e853750b8478776" translate="yes" xml:space="preserve">
          <source>Changes the return value to &lt;code&gt;{Term, Used}&lt;/code&gt; where &lt;code&gt;Used&lt;/code&gt; is the number of bytes actually read from &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">将返回值更改为 &lt;code&gt;{Term, Used}&lt;/code&gt; ，其中 &lt;code&gt;Used&lt;/code&gt; 是从 &lt;code&gt;Binary&lt;/code&gt; 实际读取的字节数。</target>
        </trans-unit>
        <trans-unit id="8da18ff00c71fe469f9ac5c3e80397ef5102bcce" translate="yes" xml:space="preserve">
          <source>Changes the run-time Audit Trail log type.</source>
          <target state="translated">更改运行时审计跟踪日志类型。</target>
        </trans-unit>
        <trans-unit id="fa6a33e3a50eb4e8a5a042f9d67e51582d656e1d" translate="yes" xml:space="preserve">
          <source>Changes the size of a binary &lt;code&gt;bin&lt;/code&gt;. The source binary can be read-only, in which case it is left untouched and a mutable copy is allocated and assigned to &lt;code&gt;*bin&lt;/code&gt;.</source>
          <target state="translated">更改二进制 &lt;code&gt;bin&lt;/code&gt; 的大小。源二进制文件可以是只读的，在这种情况下，它保持不变，并且将可变副本分配并分配给 &lt;code&gt;*bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec2c109c81bf34df1be6bcc026fe60d99cef5d65" translate="yes" xml:space="preserve">
          <source>Changes the size of a registry.</source>
          <target state="translated">改变注册表的大小。</target>
        </trans-unit>
        <trans-unit id="fc6e6d129d793f579ed4c60aaaa171440d20a874" translate="yes" xml:space="preserve">
          <source>Changes the size of an open log. For a halt log, the size can always be increased, but it cannot be decreased to something less than the current file size.</source>
          <target state="translated">更改已打开的日志的大小,对于停止日志,可以随时增加其大小,但不能减少到小于当前文件的大小。对于停止日志,可以随时增加其大小,但不能减少到小于当前文件大小。</target>
        </trans-unit>
        <trans-unit id="f82528ca1f8c8d719ac1700782b4a886e8ae597b" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for disk space utilization.</source>
          <target state="translated">改变磁盘空间利用的阈值,给定为浮动值。</target>
        </trans-unit>
        <trans-unit id="498a56145635b463f4ddad568ba393252e6c5530" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for process memory allocation.</source>
          <target state="translated">改变进程内存分配的阈值,给定为浮点数。</target>
        </trans-unit>
        <trans-unit id="d712fca6e04f8ba9e0d7ee48d15c49c58e523a70" translate="yes" xml:space="preserve">
          <source>Changes the threshold, given as a float, for system memory allocation.</source>
          <target state="translated">改变系统内存分配的阈值,给定为浮点数。</target>
        </trans-unit>
        <trans-unit id="d9d3dfce0dcea93c7310c068f8122230c707b3b0" translate="yes" xml:space="preserve">
          <source>Changes the time interval, given in minutes, for the periodic disk space check.</source>
          <target state="translated">更改定期磁盘空间检查的时间间隔,以分钟为单位。</target>
        </trans-unit>
        <trans-unit id="fb5aaf2a5afc4687e64062ff6b8607ab256e62d0" translate="yes" xml:space="preserve">
          <source>Changes the time interval, given in minutes, for the periodic memory check.</source>
          <target state="translated">改变定期检查内存的时间间隔,以分钟为单位。</target>
        </trans-unit>
        <trans-unit id="f7648c6c0af0fc343ab1c979f02974a75f2a5ba0" translate="yes" xml:space="preserve">
          <source>Changes the timeout value, given in seconds, for memory checks.</source>
          <target state="translated">更改内存检查的超时值,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="fa3f83c43cceb3bbc4bbcac9c93e8ca54d05df5d" translate="yes" xml:space="preserve">
          <source>Changes the value of option &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;head_func&lt;/code&gt; for an owner of a disk log.</source>
          <target state="translated">更改磁盘日志所有者的选项 &lt;code&gt;head&lt;/code&gt; 或 &lt;code&gt;head_func&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="c3716e44ad0eada2a249938e42128b73f10a2e61" translate="yes" xml:space="preserve">
          <source>Changes the value of option &lt;code&gt;notify&lt;/code&gt; for an owner of a disk log.</source>
          <target state="translated">更改选项的值 &lt;code&gt;notify&lt;/code&gt; 的磁盘记录的所有者。</target>
        </trans-unit>
        <trans-unit id="4ca015ff8fe3a6b3251a2977c4f3b1787fb7732a" translate="yes" xml:space="preserve">
          <source>Changes the working directory at the remote server to &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">将远程服务器上的工作目录更改为 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b86e20a82126b1241541a7af991aecce7c5f5203" translate="yes" xml:space="preserve">
          <source>Changes the working directory to &lt;code&gt;Dir&lt;/code&gt; for the local client.</source>
          <target state="translated">将本地客户端的工作目录更改为 &lt;code&gt;Dir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146996eed1440f5e90b1b4de2e12e077b5250c53" translate="yes" xml:space="preserve">
          <source>Changes working directory to &lt;code&gt;Dir&lt;/code&gt;, which can be a relative name, and then prints the name of the new working directory.</source>
          <target state="translated">将工作目录更改为 &lt;code&gt;Dir&lt;/code&gt; ，它可以是相对名称，然后打印新工作目录的名称。</target>
        </trans-unit>
        <trans-unit id="b7c76b46af51ccf8d7f82302ce30470e158c167b" translate="yes" xml:space="preserve">
          <source>Changing Child Specifications</source>
          <target state="translated">更改儿童规格</target>
        </trans-unit>
        <trans-unit id="a8a338fd17450383f174fd97f7c474118d4b1671" translate="yes" xml:space="preserve">
          <source>Changing Permissions for Reboot</source>
          <target state="translated">更改重启的权限</target>
        </trans-unit>
        <trans-unit id="563a2787ce4f962782f878a83da7b186e82a5ab6" translate="yes" xml:space="preserve">
          <source>Changing Properties</source>
          <target state="translated">改变属性</target>
        </trans-unit>
        <trans-unit id="c4ae19e16c08b52e2d4b044865ab21e4ec8819f8" translate="yes" xml:space="preserve">
          <source>Changing a zip archive is not supported. To add or remove a file from an archive, the whole archive must be recreated.</source>
          <target state="translated">不支持更改 zip 存档。要从存档中添加或删除文件,必须重新创建整个存档。</target>
        </trans-unit>
        <trans-unit id="266e726d9d7185cbcaf36e4f24317e4e232beefc" translate="yes" xml:space="preserve">
          <source>Changing an application configuration by updating the &lt;code&gt;env&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file is an instance of changing an application specification, see the previous section.</source>
          <target state="translated">通过更新 &lt;code&gt;.app&lt;/code&gt; 文件中的 &lt;code&gt;env&lt;/code&gt; 键来更改应用程序配置是更改应用程序规范的一个实例，请参见上一节。</target>
        </trans-unit>
        <trans-unit id="312f68bb8dd2023932d8d7051ef64e029badbae2" translate="yes" xml:space="preserve">
          <source>Changing code for a program written in another programming language than Erlang, for example, a port program, is application-dependent and OTP provides no special support for it.</source>
          <target state="translated">改变用Erlang以外的其他编程语言编写的程序的代码,例如移植程序,是依赖于应用的,OTP没有提供特别的支持。</target>
        </trans-unit>
        <trans-unit id="e1a45efbe4b876cddaf41c842c638f7af4dac4f7" translate="yes" xml:space="preserve">
          <source>Changing code in running systems.</source>
          <target state="translated">改变运行系统中的代码。</target>
        </trans-unit>
        <trans-unit id="89bc28f50275938cf54774b906a072619b7b5f17" translate="yes" xml:space="preserve">
          <source>Changing inbound binary and percent-encoding of URIs</source>
          <target state="translated">改变URI的入站二进制和百分比编码。</target>
        </trans-unit>
        <trans-unit id="0069b33f35595350f463876e0dc7cd74bd7efb23" translate="yes" xml:space="preserve">
          <source>Changing permission for reboot</source>
          <target state="translated">更改重启权限</target>
        </trans-unit>
        <trans-unit id="f26661251195e16b4f64b3465e31c5c61fc4f591" translate="yes" xml:space="preserve">
          <source>Changing the &lt;code&gt;Modules&lt;/code&gt; field of the child specification can affect the release handling process itself, as this field is used to identify which processes are affected when doing a synchronized code replacement.</source>
          <target state="translated">更改子规范的&amp;ldquo; &lt;code&gt;Modules&lt;/code&gt; 字段可能会影响版本处理过程本身，因为此字段用于标识在执行同步代码替换时受影响的进程。</target>
        </trans-unit>
        <trans-unit id="2102ea37ff2bfb3fffd7cfdd154c334ce7f36524" translate="yes" xml:space="preserve">
          <source>Changing the callback module</source>
          <target state="translated">更改回调模块</target>
        </trans-unit>
        <trans-unit id="004667a156f84352e632a54416d314f1fab8c554" translate="yes" xml:space="preserve">
          <source>Changing the callback module does not affect the &lt;strong&gt;state transition&lt;/strong&gt; in any way, it only changes which module that handles the events. Be aware that all relevant callback functions in &lt;code&gt;NewModule&lt;/code&gt; such as the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;NewModule:code_change/4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Module:format_status-2&quot;&gt; NewModule:format_status/2 &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt; NewModule:terminate/3 &lt;/a&gt;&lt;/code&gt; must be able to handle the state and data from the old module.</source>
          <target state="translated">更改回调模块不会以任何方式影响&lt;strong&gt;状态转换&lt;/strong&gt;，而只会更改处理事件的模块。请注意， &lt;code&gt;NewModule&lt;/code&gt; 中的所有相关回调函数，例如 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;NewModule:code_change/4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:format_status-2&quot;&gt; NewModule:format_status/2 &lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt; NewModule:terminate/3 &lt;/a&gt;&lt;/code&gt; ,都必须能够处理旧模块中的状态和数据。</target>
        </trans-unit>
        <trans-unit id="4d50c67fe4288961fc50484941baf88059761148" translate="yes" xml:space="preserve">
          <source>Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.</source>
          <target state="translated">改变数值会使连接不那么安全。除非你清楚地知道自己在做什么,否则不要改变。如果你不了解这些值,那么你就不应该改变它们。</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="0d3ea4e72253a3df4980efbacc5b0334f751af27" translate="yes" xml:space="preserve">
          <source>Channels come in the following three flavors:</source>
          <target state="translated">渠道有以下三种口味。</target>
        </trans-unit>
        <trans-unit id="c7c394b0a636c8b1d30cc5034081e1f766db234d" translate="yes" xml:space="preserve">
          <source>Channels implemented with the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior do not normally need to call this function as flow control is handled by the behavior. The behavior adjusts the window every time the callback &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt; handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; returns after processing channel data.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为实现的通道通常不需要调用此函数，因为此行为处理了流控制。在处理通道数据后，每次回调 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt; handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 返回时，此行为都会调整窗口。</target>
        </trans-unit>
        <trans-unit id="b08ff67d0c406c6c0b9f34b81df7ae485e892c7b" translate="yes" xml:space="preserve">
          <source>Channels implemented with the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior do not normally need to call this function as flow control is handled by the behavior. The behavior adjusts the window every time the callback &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; returns after processing channel data.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为实现的通道通常不需要调用此函数，因为此行为处理了流控制。在处理通道数据后，每次回调 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 返回时，此行为都会调整窗口。</target>
        </trans-unit>
        <trans-unit id="a048c40435a29a09ca42526de00adf2b52f9c645" translate="yes" xml:space="preserve">
          <source>Channels implementing a shell and command execution on the server side are to handle the following messages that can be sent by client- channel processes.</source>
          <target state="translated">在服务器端实现shell和命令执行的通道要处理以下可以由客户端-通道进程发送的消息。</target>
        </trans-unit>
        <trans-unit id="699ab27900d549007002c44489fb26aaaf5d735a" translate="yes" xml:space="preserve">
          <source>Chapter 10: &quot;Definition of Agent Net if&quot; is a reference chapter, which describes the Agent Net if function in detail.</source>
          <target state="translated">第十章:&quot;Agent Net if的定义 &quot;是参考章节,详细介绍了Agent Net if的功能。</target>
        </trans-unit>
        <trans-unit id="d34e1f73f52205aaa9e4a31eb68adc37cfabffb5" translate="yes" xml:space="preserve">
          <source>Chapter 11: &quot;Definition of Manager Net if&quot; is a reference chapter, which describes the Manager Net if function in detail.</source>
          <target state="translated">第11章:&quot;经理网if的定义 &quot;是参考章节,详细介绍了经理网if功能。</target>
        </trans-unit>
        <trans-unit id="87eb31c5080d6da36ceb543fef1eea0ccd9ee696" translate="yes" xml:space="preserve">
          <source>Chapter 12: &quot;Advanced Agent Topics&quot; describes sub-agents, agent semantics, audit trail logging, and the consideration of distributed tables.</source>
          <target state="translated">第12章:&quot;高级代理主题 &quot;描述了子代理、代理语义、审计跟踪记录以及对分布式表的考虑。</target>
        </trans-unit>
        <trans-unit id="fab3d91f87ac4c249e13bd0f9eaddaf278f8cb46" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Architecture&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">第2章:&quot;架构 &quot;介绍了应用程序的架构和典型用法。</target>
        </trans-unit>
        <trans-unit id="4dec362af8eb375be39ac35a314af9fde73a60c2" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Functional Description&quot; describes the features and operation of the SNMP development toolkit. It includes topics on Sub-agents and MIB loading, Internal MIBs, and Traps.</source>
          <target state="translated">第2章:&quot;功能描述 &quot;描述了SNMP开发工具包的功能和操作,包括子代理和MIB加载、内部MIB和Traps等主题。它包括子代理和MIB加载、内部MIB和陷阱等主题。</target>
        </trans-unit>
        <trans-unit id="12470b53b219dfdab4f5572fb7579b7c8e09036a" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Tutorial&quot; provides a walk-through of the various parts of the application. The tutorial is based on &lt;code&gt;Jayson Vantuyl's&lt;/code&gt; article &lt;code&gt;http://souja.net/2009/04/making-sense-of-erlangs-event-tracer.html&lt;/code&gt;.</source>
          <target state="translated">第2章：&amp;ldquo;教程&amp;rdquo;提供了该应用程序各个部分的逐步介绍。本教程基于 &lt;code&gt;Jayson Vantuyl's&lt;/code&gt; 文章 &lt;code&gt;http://souja.net/2009/04/making-sense-of-erlangs-event-tracer.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12fbe7a83897c503b79e7a85d14c7998722230ed" translate="yes" xml:space="preserve">
          <source>Chapter 2: &quot;Usage&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">第2章:&quot;使用 &quot;描述了应用程序的架构和典型用法。</target>
        </trans-unit>
        <trans-unit id="f6750cafe062f4ffdbda997dc97d248a13107163" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Description&quot; describes the architecture and typical usage of the application.</source>
          <target state="translated">第3章:&quot;描述 &quot;描述了应用程序的架构和典型用法。</target>
        </trans-unit>
        <trans-unit id="7071f2577cd1de4aee0fdf89922409a7b2f03ef6" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Examples&quot; gives some usage examples</source>
          <target state="translated">第3章:&quot;实例 &quot;给出了一些使用实例。</target>
        </trans-unit>
        <trans-unit id="a799b757db57e54879af9f691a80d5a9a20be410" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;Internal form and its encodings&quot; describes the internal form of Megaco/H.248 messages and its various encodings.</source>
          <target state="translated">第3章:&quot;内部形式及其编码 &quot;介绍了Megaco/H.248电文的内部形式及其各种编码。</target>
        </trans-unit>
        <trans-unit id="6320c85576ee31d5c4d265a2793966bf19bacd19" translate="yes" xml:space="preserve">
          <source>Chapter 3: &quot;The MIB Compiler&quot; describes the features and the operation of the MIB compiler.</source>
          <target state="translated">第3章:&quot;MIB编译器 &quot;介绍了MIB编译器的功能和操作。</target>
        </trans-unit>
        <trans-unit id="54e610bf40a1883eb20d03a8c18d591dc86edf67" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Advanced examples&quot; gives some usage examples</source>
          <target state="translated">第4章:&quot;高级实例 &quot;给出了一些使用实例</target>
        </trans-unit>
        <trans-unit id="25697c71de4f60fa3bac0727ea27496419a038db" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Running the application&quot; describes how to start and configure the application. Topics on how to debug the application are also included.</source>
          <target state="translated">第4章:&quot;运行应用程序 &quot;介绍了如何启动和配置应用程序。还包括如何调试应用程序的主题。</target>
        </trans-unit>
        <trans-unit id="338e15bef9d6416cdf17b7925f4f2e350826208d" translate="yes" xml:space="preserve">
          <source>Chapter 4: &quot;Transport mechanisms&quot; describes how different mechanisms can be used to transport the Megaco/H.248 messages.</source>
          <target state="translated">第4章:&quot;传输机制 &quot;描述了如何使用不同的机制来传输Megaco/H.248信息。</target>
        </trans-unit>
        <trans-unit id="597f072185d84ad8cc17379cf8e56394d84907cb" translate="yes" xml:space="preserve">
          <source>Chapter 5: &quot;Debugging&quot; describes tracing and debugging.</source>
          <target state="translated">第5章:&quot;调试 &quot;介绍了跟踪和调试。</target>
        </trans-unit>
        <trans-unit id="e7479821f3441c9357b1ca00c1e36bbd27cf97aa" translate="yes" xml:space="preserve">
          <source>Chapter 5: &quot;Definition of Agent Configuration Files&quot; is a reference chapter, which contains more detailed information about the agent configuration files.</source>
          <target state="translated">第5章:&quot;代理配置文件的定义 &quot;是参考章节,其中包含了更详细的代理配置文件信息。</target>
        </trans-unit>
        <trans-unit id="22020ea76e2aac433ecfad203219d4675b24e48f" translate="yes" xml:space="preserve">
          <source>Chapter 6: &quot;Definition of Manager Configuration Files&quot; is a reference chapter, which contains more detailed information about the manager configuration files.</source>
          <target state="translated">第6章:&quot;管理器配置文件的定义 &quot;是参考章节,其中包含了更多关于管理器配置文件的详细信息。</target>
        </trans-unit>
        <trans-unit id="6cbf0856c33c9ecb975047c82a028295d945630c" translate="yes" xml:space="preserve">
          <source>Chapter 7: &quot;Agent Implementation Example&quot; describes how an MIB can be implemented with the SNMP Development Toolkit. Implementation examples are included.</source>
          <target state="translated">第7章:&quot;代理实施例 &quot;介绍了如何使用SNMP开发工具包实现MIB。其中包括实施示例。</target>
        </trans-unit>
        <trans-unit id="076f34961e0e1c7d0516f0f540ffe3d6973fc2a2" translate="yes" xml:space="preserve">
          <source>Chapter 8: &quot;Instrumentation Functions&quot; describes how instrumentation functions should be defined in Erlang for the different operations.</source>
          <target state="translated">第8章:&quot;仪表函数 &quot;介绍了在Erlang中应该如何为不同的操作定义仪表函数。</target>
        </trans-unit>
        <trans-unit id="3d0f1ca136eed306def0b8a62ab682c35309444f" translate="yes" xml:space="preserve">
          <source>Chapter 9: &quot;Definition of Instrumentation Functions&quot; is a reference chapter which contains more detailed information about the instrumentation functions.</source>
          <target state="translated">第9章:&quot;仪表功能的定义 &quot;是参考章节,其中包含了更详细的仪表功能信息。</target>
        </trans-unit>
        <trans-unit id="d53a53309918b4def88f4690959360fcb2d765d6" translate="yes" xml:space="preserve">
          <source>Character &lt;code&gt;*&lt;/code&gt; is an optional return suppression character. It provides a method to specify a field that is to be omitted.</source>
          <target state="translated">字符 &lt;code&gt;*&lt;/code&gt; 是可选的返回抑制字符。它提供了一种指定要忽略的字段的方法。</target>
        </trans-unit>
        <trans-unit id="10dc4e431a177556e53df60369a9fb871c823ce1" translate="yes" xml:space="preserve">
          <source>Character &lt;code&gt;~&lt;/code&gt; is written.</source>
          <target state="translated">字符 &lt;code&gt;~&lt;/code&gt; 被写入。</target>
        </trans-unit>
        <trans-unit id="d4b7b30647ed82c58a1589c60ae3f8434718542a" translate="yes" xml:space="preserve">
          <source>Character class, which matches any of the characters &lt;code&gt;abc...&lt;/code&gt;. Character ranges are specified by a pair of characters separated by a &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">字符类，与任何字符 &lt;code&gt;abc...&lt;/code&gt; 匹配。字符范围由用 &lt;code&gt;-&lt;/code&gt; 分隔的一对字符指定。</target>
        </trans-unit>
        <trans-unit id="f62e465bcd7cce1acdf714047daba90806ba8a22" translate="yes" xml:space="preserve">
          <source>Character codes 0-127</source>
          <target state="translated">字符代码0-127</target>
        </trans-unit>
        <trans-unit id="f3958ab5088befd2a44054cf1546542615ec1ba3" translate="yes" xml:space="preserve">
          <source>Character data can be combined from many sources, sometimes available in a mix of strings and binaries. Erlang has for long had the concept of &lt;code&gt;iodata&lt;/code&gt; or &lt;code&gt;iolist&lt;/code&gt;s, where binaries and lists can be combined to represent a sequence of bytes. In the same way, the Unicode-aware modules often allow for combinations of binaries and lists, where the binaries have characters encoded in UTF-8 and the lists contain such binaries or numbers representing Unicode code points:</source>
          <target state="translated">字符数据可以从许多来源进行组合，有时可以混合使用字符串和二进制文件。Erlang拥有 &lt;code&gt;iodata&lt;/code&gt; 或 &lt;code&gt;iolist&lt;/code&gt; 的概念由来已久，其中二进制文件和列表可以组合起来表示字节序列。以相同的方式，支持Unicode的模块通常允许二进制文件和列表的组合，其中二进制文件具有以UTF-8编码的字符，并且列表包含表示Unicode代码点的此类二进制文件或数字：</target>
        </trans-unit>
        <trans-unit id="0b4a9d35669803e9f5dc2e6f444b82b65bbd17f0" translate="yes" xml:space="preserve">
          <source>Character with hex code hh</source>
          <target state="translated">带有十六进制代码的字符hh</target>
        </trans-unit>
        <trans-unit id="a5cfa12fd688cc50f0a4a2e82bc4a14c913cc7d9" translate="yes" xml:space="preserve">
          <source>Character with hex code hhh..</source>
          <target state="translated">字符的十六进制代码hhh...</target>
        </trans-unit>
        <trans-unit id="dbfc09d76b2751348746f5d0f726fbdddf63e42d" translate="yes" xml:space="preserve">
          <source>Character with hexadecimal representation XY</source>
          <target state="translated">十六进制表示的字符 XY</target>
        </trans-unit>
        <trans-unit id="9fb138816ff7cd1b28dff9249e50ecaf7aafc8d8" translate="yes" xml:space="preserve">
          <source>Character with hexadecimal representation; X... is one or more hexadecimal characters</source>
          <target state="translated">用十六进制表示的字符;X......是一个或多个十六进制字符。</target>
        </trans-unit>
        <trans-unit id="85b6e08c1a055049545eb425b3ef82c285b56bad" translate="yes" xml:space="preserve">
          <source>Character with octal code 0dd</source>
          <target state="translated">带有八进制代码的字符 0dd</target>
        </trans-unit>
        <trans-unit id="8c531bc02f5a4557270d589919d8d9d1c33dd84a" translate="yes" xml:space="preserve">
          <source>Character with octal code ddd, or back reference</source>
          <target state="translated">带八进制代码ddd的字符,或回文参考。</target>
        </trans-unit>
        <trans-unit id="49c6c585b475f6a53492340855982d63e7868324" translate="yes" xml:space="preserve">
          <source>Character with octal representation XYZ, YZ or Z</source>
          <target state="translated">八进制表示的字符XYZ、YZ或Z。</target>
        </trans-unit>
        <trans-unit id="4d8bbe4ae1dec6f4b66388f0e7417e43a5ee9841" translate="yes" xml:space="preserve">
          <source>Characters are translated to and from UTF-8 encoding before they are written to or read from the file. A file opened in this way can be readable using function &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, as long as no data stored on the file lies beyond the ISO Latin-1 range (0..255), but failure occurs if the data contains Unicode code points beyond that range. The file is best read with the functions in the Unicode aware module &lt;code&gt;io(3)&lt;/code&gt;.</source>
          <target state="translated">在将字符写入文件或从文件读取文件之前，先将字符与UTF-8编码进行转换。只要没有存储在文件中的数据超出ISO Latin-1范围（0..255），就可以使用函数 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 读取以这种方式打开的文件，但是如果数据包含的Unicode代码点超出此范围，则失败这个范围。最好使用Unicode感知模块 &lt;code&gt;io(3)&lt;/code&gt; 中的函数读取该文件。</target>
        </trans-unit>
        <trans-unit id="9f41db94f3c3858526bf2d9c0e2c82c748eb1ddb" translate="yes" xml:space="preserve">
          <source>Characters in &lt;code&gt;Target&lt;/code&gt; special to make(1) are quoted.</source>
          <target state="translated">&lt;code&gt;Target&lt;/code&gt; 特殊于make（1）的字符被引用。</target>
        </trans-unit>
        <trans-unit id="aa1179541f8808f873db5c57ac0dd4861f2fed75" translate="yes" xml:space="preserve">
          <source>Characters in an atom</source>
          <target state="translated">原子中的字符</target>
        </trans-unit>
        <trans-unit id="483e7ec90fc725ea406b056294f684edfa8f5f09" translate="yes" xml:space="preserve">
          <source>Characters that are specified using octal or hexadecimal numbers are limited to certain values, as follows:</source>
          <target state="translated">使用八进制或十六进制数字指定的字符被限制在一定的数值内,如下所示:</target>
        </trans-unit>
        <trans-unit id="3b349ab83608db909f06144931bf465a076a5d43" translate="yes" xml:space="preserve">
          <source>Characters that can indicate line breaks are never treated in any special way when matching character classes, whatever line-ending sequence is in use, and whatever setting of options &lt;code&gt;PCRE_DOTALL&lt;/code&gt; and &lt;code&gt;PCRE_MULTILINE&lt;/code&gt; is used. A class such as [^a] always matches one of these characters.</source>
          <target state="translated">匹配字符类，使用任何换行顺序以及使用选项 &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 和 &lt;code&gt;PCRE_MULTILINE&lt;/code&gt; 的任何设置时，绝不会以任何特殊方式对待可以指示换行符的字符。诸如[^ a]之类的类始终与这些字符之一匹配。</target>
        </trans-unit>
        <trans-unit id="2d1edf9c232be69d7a016a8a3ba2ae3e44f4f6a1" translate="yes" xml:space="preserve">
          <source>Characters whose value is less than 256 can be defined by either of the two syntaxes for \x. There is no difference in the way they are handled. For example, \xdc is exactly the same as \x{dc}.</source>
          <target state="translated">值小于256的字符可以用两种语法中的任何一种来定义\x。它们的处理方式没有区别。例如,\xdc与\x{dc}完全相同。</target>
        </trans-unit>
        <trans-unit id="2b130fd7c648fe09d9088ac10a3fa6dfa01ba612" translate="yes" xml:space="preserve">
          <source>Check if a message is a response to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process using &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;RequestId&lt;/code&gt; should be the value returned from the previously made &lt;code&gt;erpc:send_request()&lt;/code&gt; call, and the corresponding response should not already have been received and handled to completion by &lt;code&gt;erpc:check_response()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt;erpc:wait_response()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Message&lt;/code&gt; is the message to check.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt; 检查消息是否是对呼叫过程先前发出的 &lt;code&gt;call&lt;/code&gt; 请求的响应。 &lt;code&gt;RequestId&lt;/code&gt; 应该是从先前进行的 &lt;code&gt;erpc:send_request()&lt;/code&gt; 调用返回的值，并且相应的响应应该尚未由 &lt;code&gt;erpc:check_response()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#wait_response-2&quot;&gt;erpc:wait_response()&lt;/a&gt;&lt;/code&gt; 接收并处理到完成。。 &lt;code&gt;Message&lt;/code&gt; 是要检查的消息。</target>
        </trans-unit>
        <trans-unit id="636269b21ec64e1b4c57781fd483b1f6eb014ef4" translate="yes" xml:space="preserve">
          <source>Check that you got the correct wx-config</source>
          <target state="translated">检查你得到的wx-config是否正确。</target>
        </trans-unit>
        <trans-unit id="abcea80cce60fbe20f77494ee80ffc9af8a04be8" translate="yes" xml:space="preserve">
          <source>Check the PLT for consistency and rebuild it if it is not up-to-date.</source>
          <target state="translated">检查PLT的一致性,如果它不是最新的,就重建它。</target>
        </trans-unit>
        <trans-unit id="268c1187a5d1ae2b90f5cdc9f4cb275c9ad70ab4" translate="yes" xml:space="preserve">
          <source>Check the releases again:</source>
          <target state="translated">再检查一下发布。</target>
        </trans-unit>
        <trans-unit id="906cba3b4a7b65d13acff94d584d482a4041b4f6" translate="yes" xml:space="preserve">
          <source>Check the result codes from &lt;code&gt;ei_decode_-calls&lt;/code&gt;.</source>
          <target state="translated">检查 &lt;code&gt;ei_decode_-calls&lt;/code&gt; 的结果代码。</target>
        </trans-unit>
        <trans-unit id="a3006d5fda96585cbeb13605068585873b6a87f1" translate="yes" xml:space="preserve">
          <source>Check to see if an Erlang process is alive:</source>
          <target state="translated">检查Erlang进程是否还活着。</target>
        </trans-unit>
        <trans-unit id="20402d173d20fdbc8de1eb922d8ebb7baecddece" translate="yes" xml:space="preserve">
          <source>Check what data types the database assigned for the columns. Hopefully this is not a surprise, some times it can be! These are the data types that you should use if you want to do a parameterized query.</source>
          <target state="translated">检查数据库为列分配的数据类型是什么。希望这不是一个惊喜,有些时候可能是! 如果你想进行参数化查询,应该使用这些数据类型。</target>
        </trans-unit>
        <trans-unit id="35d0ee1ea7a80bd1369cdd8deff771169f1ff621" translate="yes" xml:space="preserve">
          <source>Check which releases there are in the system:</source>
          <target state="translated">检查系统中有哪些版本。</target>
        </trans-unit>
        <trans-unit id="a2b3a59adb81ffe32d8631c171b886f3d460360a" translate="yes" xml:space="preserve">
          <source>Checkpoints</source>
          <target state="translated">Checkpoints</target>
        </trans-unit>
        <trans-unit id="e87ce1926feddf058db26307093e491ce24b9536" translate="yes" xml:space="preserve">
          <source>Checkpoints are activated with the function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is a list of the following tuples:</source>
          <target state="translated">通过功能 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; 激活检查点，其中 &lt;code&gt;Args&lt;/code&gt; 是以下元组的列表：</target>
        </trans-unit>
        <trans-unit id="9f802420bf755ebc628b011ddcdcefbea605aaca" translate="yes" xml:space="preserve">
          <source>Checkpoints can be explicitly deactivated with the function &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate_checkpoint(Name)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint. This function returns &lt;code&gt;ok&lt;/code&gt; if successful or &lt;code&gt;{error, Reason}&lt;/code&gt; if there is an error. All tables in a checkpoint must be attached to at least one checkpoint retainer. The checkpoint is automatically deactivated by &lt;code&gt;Mnesia&lt;/code&gt;, when any table lacks a checkpoint retainer. This can occur when a node goes down or when a replica is deleted. Use arguments &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (described in the following list) to control the degree of checkpoint retainer redundancy.</source>
          <target state="translated">可以使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#deactivate_checkpoint-1&quot;&gt;mnesia:deactivate_checkpoint(Name)&lt;/a&gt;&lt;/code&gt; 显式停用检查点，其中 &lt;code&gt;Name&lt;/code&gt; 是活动检查点的名称。如果成功 &lt;code&gt;{error, Reason}&lt;/code&gt; 则此函数返回 &lt;code&gt;ok&lt;/code&gt; ,否则返回{error，Reason}。检查点中的所有表都必须附加到至少一个检查点保持器上。当任何表缺少检查点保留器时， &lt;code&gt;Mnesia&lt;/code&gt; 会自动停用该检查点。当节点关闭或删除副本时，可能会发生这种情况。使用参数 &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; （在下面的列表中描述）来控制检查点保持器冗余度。</target>
        </trans-unit>
        <trans-unit id="bd05a7f92b1f124795301d9f37652056ff883754" translate="yes" xml:space="preserve">
          <source>Checks all the forms in a module for errors. It returns:</source>
          <target state="translated">检查一个模块中的所有表格是否有错误。它返回:</target>
        </trans-unit>
        <trans-unit id="a856949551133f4d621c8f983c0ff72dd04c2c2b" translate="yes" xml:space="preserve">
          <source>Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1.</source>
          <target state="translated">检查文件是否已排序。如果一个文件没有排序,则返回第一个失序元素。文件中的第一个词的位置是1。</target>
        </trans-unit>
        <trans-unit id="7ba4b1e2a4ab295c5008b5d16d7d26b47a038a4b" translate="yes" xml:space="preserve">
          <source>Checks for a UTF Byte Order Mark (BOM) in the beginning of a binary. If the supplied binary &lt;code&gt;Bin&lt;/code&gt; begins with a valid BOM for either UTF-8, UTF-16, or UTF-32, the function returns the encoding identified along with the BOM length in bytes.</source>
          <target state="translated">检查二进制文件开头的UTF字节顺序标记（BOM）。如果提供的二进制 &lt;code&gt;Bin&lt;/code&gt; 开头为UTF-8，UTF-16或UTF-32的有效BOM，则该函数返回标识的编码以及BOM长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="510ec36114ebdc62e86252016e95f26f6d7a1f20" translate="yes" xml:space="preserve">
          <source>Checks for multiple usage of object identifiers and traps between MIBs.</source>
          <target state="translated">检查MIB之间对象标识符的多重使用和陷阱。</target>
        </trans-unit>
        <trans-unit id="747232dc3b591c50580e517e7cc803fb9e025a85" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;DateAndTime&lt;/code&gt; is a correct DateAndTime value, as specified in RFC2579. This function can be used in instrumentation functions to validate a DateAndTime value.</source>
          <target state="translated">检查 &lt;code&gt;DateAndTime&lt;/code&gt; 是否为RFC2579中指定的正确的DateAndTime值。可以在检测功能中使用此函数来验证DateAndTime值。</target>
        </trans-unit>
        <trans-unit id="95a79a074380e965f210f3b0d26fcbfdb4da8239" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;IssuerCert&lt;/code&gt; issued &lt;code&gt;Cert&lt;/code&gt;.</source>
          <target state="translated">检查 &lt;code&gt;IssuerCert&lt;/code&gt; 是否发行了 &lt;code&gt;Cert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2772e2a03c6bc7bbd4020bdc175792271c77180e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;Module&lt;/code&gt; is loaded. If it is, &lt;code&gt;{file, Loaded}&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">检查是否已加载 &lt;code&gt;Module&lt;/code&gt; 。如果是，则返回 &lt;code&gt;{file, Loaded}&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5818a0956c65d40a8ff10edf8906b485fbeb4030" translate="yes" xml:space="preserve">
          <source>Checks if a certificate is a fixed Diffie-Hellman certificate.</source>
          <target state="translated">检查证书是否是固定的Diffie-Hellman证书。</target>
        </trans-unit>
        <trans-unit id="8386578fed134d83c251c55e8ce2a02a7ef77dfe" translate="yes" xml:space="preserve">
          <source>Checks if a certificate is self-signed.</source>
          <target state="translated">检查证书是否为自签。</target>
        </trans-unit>
        <trans-unit id="605d073b25cd13abdaa22621a8c142cdd64e0fde" translate="yes" xml:space="preserve">
          <source>Checks if a host key is trusted.</source>
          <target state="translated">检查主机密钥是否可信。</target>
        </trans-unit>
        <trans-unit id="d711ffc10e42ab11346653fdef9d9261168fbde9" translate="yes" xml:space="preserve">
          <source>Checks if a module can be interpreted. The module can be specified by its module name &lt;code&gt;Module&lt;/code&gt; or its source filename &lt;code&gt;File&lt;/code&gt;. If specified by a module name, the module is searched for in the code path.</source>
          <target state="translated">检查模块是否可以解释。可以通过模块名称 &lt;code&gt;Module&lt;/code&gt; 或源文件名 &lt;code&gt;File&lt;/code&gt; 来指定模块。如果由模块名称指定，则在代码路径中搜索该模块。</target>
        </trans-unit>
        <trans-unit id="6f37d2fd8311965e33637b99d11518d610b4fb8e" translate="yes" xml:space="preserve">
          <source>Checks if a port is a flex scanner port or not (useful when if a port exits).</source>
          <target state="translated">检查一个端口是否是柔性扫描器端口(在端口退出时有用)。</target>
        </trans-unit>
        <trans-unit id="272d82259d08ece025286e406b6b11b2f72fae79" translate="yes" xml:space="preserve">
          <source>Checks if a row in a table exists.</source>
          <target state="translated">检查表中的某一行是否存在。</target>
        </trans-unit>
        <trans-unit id="0ce83f3264ff58bca6cc35dfd8e19ea482e8523e" translate="yes" xml:space="preserve">
          <source>Checks if a table exists.</source>
          <target state="translated">检查表是否存在。</target>
        </trans-unit>
        <trans-unit id="d18309113b1c9a8ffcfd3bdb7df082f48addf70f" translate="yes" xml:space="preserve">
          <source>Checks if a term is a valid compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. The compiled match specification is an opaque datatype that &lt;strong&gt;cannot&lt;/strong&gt; be sent between Erlang nodes or be stored on disk. Any attempt to create an external representation of a compiled match specification results in an empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">检查术语是否为有效的已编译 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 。编译后的匹配规范是不透明的数据类型，&lt;strong&gt;不能&lt;/strong&gt;在Erlang节点之间发送或存储在磁盘上。任何试图创建已编译的匹配规范的外部表示的尝试都将导致一个空的二进制（ &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dc25eb5f990617d8a0bd7a27e851e73ad3bc8008" translate="yes" xml:space="preserve">
          <source>Checks if a term represent a valid compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. A compiled match specifications is only valid on the Erlang node where it was compiled by calling &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">检查术语是否表示有效的已编译 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 。编译的匹配规范仅在通过调用 &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt; 进行编译的Erlang节点上有效。</target>
        </trans-unit>
        <trans-unit id="49fe5d38c23822c89b1d14265222013e7aa623f5" translate="yes" xml:space="preserve">
          <source>Checks if the array has fixed size. Returns &lt;code&gt;true&lt;/code&gt; if the array is fixed, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">检查数组是否具有固定大小。如果数组是固定的，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6528fc754f99e98b06bda36322e569db3f8f1fc0" translate="yes" xml:space="preserve">
          <source>Checks if the node local process identified by &lt;code&gt;Pid&lt;/code&gt; executes old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">检查由 &lt;code&gt;Pid&lt;/code&gt; 标识的节点本地进程是否执行 &lt;code&gt;Module&lt;/code&gt; 的旧代码。</target>
        </trans-unit>
        <trans-unit id="71e47cd564a205cb1bf9ca547a2026f1c46fec4f" translate="yes" xml:space="preserve">
          <source>Checks if the required configuration is available and gives it a name. The semantics for &lt;code&gt;Required&lt;/code&gt; is the same as in &lt;code&gt;&lt;a href=&quot;#require-1&quot;&gt;ct:require/1&lt;/a&gt;&lt;/code&gt; except that a list of &lt;code&gt;SubKey&lt;/code&gt;s cannot be specified.</source>
          <target state="translated">检查所需的配置是否可用并为其命名。 &lt;code&gt;Required&lt;/code&gt; 的语义与 &lt;code&gt;&lt;a href=&quot;#require-1&quot;&gt;ct:require/1&lt;/a&gt;&lt;/code&gt; 中的相同，不同之处在于无法指定 &lt;code&gt;SubKey&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="428578d9af241c74e1a7a32730a10d5366082c85" translate="yes" xml:space="preserve">
          <source>Checks if the required configuration is available. Arbitrarily deep tuples can be specified as &lt;code&gt;Required&lt;/code&gt;. Only the last element of the tuple can be a list of &lt;code&gt;SubKey&lt;/code&gt;s.</source>
          <target state="translated">检查所需的配置是否可用。可以将深元组指定为 &lt;code&gt;Required&lt;/code&gt; 。只有元组的最后一个元素可以是 &lt;code&gt;SubKey&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="ec238f5cb03703ee0f12bade417608420f9de09c" translate="yes" xml:space="preserve">
          <source>Checks if the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release can be installed. The release must not have status &lt;code&gt;current&lt;/code&gt;. Issues warnings if &lt;code&gt;relup&lt;/code&gt; file or &lt;code&gt;sys.config&lt;/code&gt; is not present. If &lt;code&gt;relup&lt;/code&gt; file is present, its contents are checked and &lt;code&gt;{error,Reason}&lt;/code&gt; is returned if an error is found. Also checks that all required applications are present and that all new code can be loaded; &lt;code&gt;{error,Reason}&lt;/code&gt; is returned if an error is found.</source>
          <target state="translated">检查是否可以安装发行版的指定版本 &lt;code&gt;Vsn&lt;/code&gt; 。发行版不得具有 &lt;code&gt;current&lt;/code&gt; 状态。如果不存在 &lt;code&gt;relup&lt;/code&gt; 文件或 &lt;code&gt;sys.config&lt;/code&gt; ,则发出警告。如果存在 &lt;code&gt;relup&lt;/code&gt; 文件，则检查其内容 &lt;code&gt;{error,Reason}&lt;/code&gt; 如果发现错误，则返回{error，Reason}。还检查是否存在所有必需的应用程序，以及是否可以加载所有新代码；如果发现 &lt;code&gt;{error,Reason}&lt;/code&gt; 则返回{error，Reason}。</target>
        </trans-unit>
        <trans-unit id="479a9580343413c1f22bd06f4593b79fb04b0a75" translate="yes" xml:space="preserve">
          <source>Checks if the specified year is a leap year.</source>
          <target state="translated">确认指定的年份是否为闰年。</target>
        </trans-unit>
        <trans-unit id="078e47111a5ec4795ece814100ad93da9a091cfb" translate="yes" xml:space="preserve">
          <source>Checks if the user key is authorized.</source>
          <target state="translated">检查用户密钥是否被授权。</target>
        </trans-unit>
        <trans-unit id="ff7d8e386c89192aae77ae12e3d1fd328088412c" translate="yes" xml:space="preserve">
          <source>Checks the validity of the configuration options before saving them in the internal database. This function can also have a side effect, that is, setup of necessary extra resources implied by the configuration option. It can also resolve possible dependencies among configuration options by changing the value of the option. This function only needs clauses for the options implemented by this particular callback module.</source>
          <target state="translated">在将配置选项保存到内部数据库之前,检查它们的有效性。这个功能也有一个副作用,即设置配置选项所隐含的必要的额外资源。它还可以通过改变选项的值来解决配置选项之间可能的依赖关系。这个函数只需要为这个特定的回调模块所实现的选项设置条款。</target>
        </trans-unit>
        <trans-unit id="f318de51ea171b0f11fe8ffcba324d6cb2f56901" translate="yes" xml:space="preserve">
          <source>Checks whether the given distribution point matches the Issuing Distribution Point of the CRL, as described in RFC 5280. If the CRL doesn't have an Issuing Distribution Point extension, the distribution point always matches.</source>
          <target state="translated">检查给定的分发点是否与CRL的发行分发点匹配,如RFC 5280所述。如果CRL没有发行分发点扩展,则分发点总是匹配的。</target>
        </trans-unit>
        <trans-unit id="6927568c692c1534ead0f5a190223a7149662ac5" translate="yes" xml:space="preserve">
          <source>Cherokee</source>
          <target state="translated">Cherokee</target>
        </trans-unit>
        <trans-unit id="135e7ebc010b592ec029e827d5bc3670e96d3552" translate="yes" xml:space="preserve">
          <source>Child processes added using &lt;code&gt;start_child/2&lt;/code&gt; behave in the same way as the other child processes, with the an important exception: if a supervisor dies and is recreated, then all child processes that were dynamically added to the supervisor are lost.</source>
          <target state="translated">使用 &lt;code&gt;start_child/2&lt;/code&gt; 添加的子流程与其他子流程的行为方式相同，但有一个重要的例外：如果主管死亡并重新创建，则所有动态添加到该主管的子流程都会丢失。</target>
        </trans-unit>
        <trans-unit id="d31165313a669b6455ea6e9ad085bc20f3afad95" translate="yes" xml:space="preserve">
          <source>Child processes can be added or deleted, but this is not handled automatically. Instructions must be given by in the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">可以添加或删除子进程，但这不会自动处理。说明必须在 &lt;code&gt;.appup&lt;/code&gt; 文件中给出。</target>
        </trans-unit>
        <trans-unit id="6ab10a3f0f32c3f2675ecf809a38ba27ac8a5f1a" translate="yes" xml:space="preserve">
          <source>Choice of encoding rules. If omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">选择编码规则。如果省略，则 &lt;code&gt;ber&lt;/code&gt; 为默认值。</target>
        </trans-unit>
        <trans-unit id="7f3ea2b24209a266dcef3e5a9bb60cc369d1de87" translate="yes" xml:space="preserve">
          <source>Choose TLS or DTLS protocol for the transport layer security. Defaults to &lt;code&gt;tls&lt;/code&gt; Introduced in OTP 20, DTLS support is considered experimental in this release. Other transports than UDP are not yet supported.</source>
          <target state="translated">选择TLS或DTLS协议以提高传输层的安全性。默认值为 &lt;code&gt;tls&lt;/code&gt; 在OTP 20中引入，DTLS支持在此版本中被视为试验性的。目前尚不支持UDP以外的其他传输方式。</target>
        </trans-unit>
        <trans-unit id="c31c4041fea7dcf570fd6e4cf1e2c962d365bbbf" translate="yes" xml:space="preserve">
          <source>Choose TLS or DTLS protocol for the transport layer security. Defaults to &lt;code&gt;tls&lt;/code&gt;. For DTLS other transports than UDP are not yet supported.</source>
          <target state="translated">选择TLS或DTLS协议以提高传输层的安全性。默认为 &lt;code&gt;tls&lt;/code&gt; 。对于DTLS，尚不支持UDP以外的其他传输方式。</target>
        </trans-unit>
        <trans-unit id="25f5d4d9f2caa81d094ad75fec450f1a06c95420" translate="yes" xml:space="preserve">
          <source>Choose to handle only the desired ones.</source>
          <target state="translated">选择只处理需要的。</target>
        </trans-unit>
        <trans-unit id="46b52861d4608446563acf9a958bc3592901aff0" translate="yes" xml:space="preserve">
          <source>Choosing the Applications or Modules</source>
          <target state="translated">选择应用或模块</target>
        </trans-unit>
        <trans-unit id="ee581d45d9fc1d0520325bee52149114d648b385" translate="yes" xml:space="preserve">
          <source>Chunk continuation returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;chunk/2,3&lt;/code&gt; ， &lt;code&gt;bchunk/2,3&lt;/code&gt; 或 &lt;code&gt;chunk_step/3&lt;/code&gt; 返回的块连续。</target>
        </trans-unit>
        <trans-unit id="e4ba655b15f106275903bcb76ff0e9f9a248da7f" translate="yes" xml:space="preserve">
          <source>Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks are referenced by names (atoms) rather than identifiers (strings). The recognized names and the corresponding identifiers are as follows:</source>
          <target state="translated">分块数据可以以二进制或复合项的形式返回。当数据块以名称(原子)而不是标识符(字符串)为参照时,将返回复合项。认可的名称和相应的标识符如下。</target>
        </trans-unit>
        <trans-unit id="6764e5053e3fe95b1f7c11980b37b710d2758df5" translate="yes" xml:space="preserve">
          <source>Cipher and Mode</source>
          <target state="translated">密码和模式</target>
        </trans-unit>
        <trans-unit id="30642178bcc449614b9f83d55814b1527c22a7a9" translate="yes" xml:space="preserve">
          <source>CipherText</source>
          <target state="translated">CipherText</target>
        </trans-unit>
        <trans-unit id="bc7425233d01ba6a7be602ba1752667ca73eae3a" translate="yes" xml:space="preserve">
          <source>Ciphers known by the CRYPTO application when using the &lt;code&gt;new API&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;new API&lt;/code&gt; 时，CRYPTO应用程序已知的密码。</target>
        </trans-unit>
        <trans-unit id="3c0c4fa76aea2937a0998c363ea02686cbd6a9ee" translate="yes" xml:space="preserve">
          <source>Ciphers known by the CRYPTO application when using the &lt;code&gt;old API&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;old API&lt;/code&gt; 时，CRYPTO应用程序已知的密码。</target>
        </trans-unit>
        <trans-unit id="c823bc9e6919d1a6ec1ee621618d405b63ae02b7" translate="yes" xml:space="preserve">
          <source>Ciphers with AEAD - cipher_aead()</source>
          <target state="translated">带有AEAD的密码-cipher_aead()</target>
        </trans-unit>
        <trans-unit id="52e903786f3aa5e38839b6ced188e00a2978392f" translate="yes" xml:space="preserve">
          <source>Ciphers with an IV - cipher_iv()</source>
          <target state="translated">带IV的密码-cipher_iv()</target>
        </trans-unit>
        <trans-unit id="edf572b5e6cd15e9e8481efe4e07ee81f9831714" translate="yes" xml:space="preserve">
          <source>Ciphers without an IV - cipher_no_iv()</source>
          <target state="translated">无IV的密码-cipher_no_iv()</target>
        </trans-unit>
        <trans-unit id="6f21a899bfeb7fda2cfbbe7b1fc7403ccdab3ded" translate="yes" xml:space="preserve">
          <source>Ciphers, new API</source>
          <target state="translated">密码,新的API</target>
        </trans-unit>
        <trans-unit id="8c8c272e11f799bb1c36704a8bd1038391e72fd2" translate="yes" xml:space="preserve">
          <source>Ciphers, old API</source>
          <target state="translated">密码,旧API</target>
        </trans-unit>
        <trans-unit id="fa89c2516f6a5145ca57d8e994ab91799551cef7" translate="yes" xml:space="preserve">
          <source>Ciphers: all cipher suites are supported</source>
          <target state="translated">密码:支持所有的密码套件。</target>
        </trans-unit>
        <trans-unit id="6ff9b96266db1f3dd7beca013ae70083f5bd259c" translate="yes" xml:space="preserve">
          <source>Circular logs wrap too quickly so that important data is overwritten.</source>
          <target state="translated">循环日志包裹过快,使重要数据被覆盖。</target>
        </trans-unit>
        <trans-unit id="d12a819b1aae084ceb5aef6add0b54bb3383e602" translate="yes" xml:space="preserve">
          <source>Circumflex (only at the start)</source>
          <target state="translated">弯腰(只在开始时</target>
        </trans-unit>
        <trans-unit id="581342987169d6671fc5bf0cc93afadd1b835b06" translate="yes" xml:space="preserve">
          <source>Circumflex needs not to be the first character of the pattern if some alternatives are involved, but it is to be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern to be anchored.)</source>
          <target state="translated">如果涉及到一些备选方案,circumflex不需要成为模式的第一个字符,但如果模式要匹配该分支,它要成为每个备选方案中出现的第一个东西。如果所有可能的替代词都以绕口令开始,也就是说,如果模式被限制为只在主题的开始处匹配,那么它被称为 &quot;锚定 &quot;模式。(还有其他结构可以导致模式被锚定)。</target>
        </trans-unit>
        <trans-unit id="c55dd6a054b7094ae3dc1abafba45b8010c44542" translate="yes" xml:space="preserve">
          <source>Circumstances That Force Copying</source>
          <target state="translated">迫使复制的情况</target>
        </trans-unit>
        <trans-unit id="9d200e05d2a156deec0beba2b22e83cff255bcb3" translate="yes" xml:space="preserve">
          <source>Claim an intermediate CA in the chain as trusted. TLS then performs &lt;code&gt;public_key:pkix_path_validation/3&lt;/code&gt; with the selected CA as trusted anchor and the rest of the chain.</source>
          <target state="translated">将链中的中间CA声明为受信任。然后，TLS 使用选定的CA作为受信任的锚以及链的其余部分执行 &lt;code&gt;public_key:pkix_path_validation/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39de48c8fa760feda5802b521d8bf939316bf4c2" translate="yes" xml:space="preserve">
          <source>Class AVP</source>
          <target state="translated">AVP级</target>
        </trans-unit>
        <trans-unit id="6eacfebc1c0925b3f9fb95e3de34cdc474ca5242" translate="yes" xml:space="preserve">
          <source>Clean start of lttng in a bash shell.</source>
          <target state="translated">在bash shell中干净的开始lttng。</target>
        </trans-unit>
        <trans-unit id="9a4a1562053eb1e1218a691a6c953f8f4062d055" translate="yes" xml:space="preserve">
          <source>Clear the event table.</source>
          <target state="translated">清除事件表。</target>
        </trans-unit>
        <trans-unit id="cf79802203160fb2e047023927c66043f0069869" translate="yes" xml:space="preserve">
          <source>Clear the hosts table.</source>
          <target state="translated">清理主机表。</target>
        </trans-unit>
        <trans-unit id="9bff2b01c2e7f297768e7e1de9b32b6dece5d32c" translate="yes" xml:space="preserve">
          <source>Clear the internal counters. Same as &lt;code&gt;lcnt:clear(Node)&lt;/code&gt;.</source>
          <target state="translated">清除内部计数器。与 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2b2367a410d59fa17678db3463ba5a821481dc69" translate="yes" xml:space="preserve">
          <source>Clear the list of recorded nameservers (primary and secondary).</source>
          <target state="translated">清除已记录的名称服务器列表(主要和次要)。</target>
        </trans-unit>
        <trans-unit id="369fb44362e0de877ecb493ee42cb0dc0bd0e79c" translate="yes" xml:space="preserve">
          <source>Clear the list of search domains.</source>
          <target state="translated">清除搜索域列表。</target>
        </trans-unit>
        <trans-unit id="5780206257275a6d0e675772efcba6937710072a" translate="yes" xml:space="preserve">
          <source>Clearly the time-outs are for implementing fault tolerance, not to keep hard real-time promises. The &lt;code&gt;_tmo&lt;/code&gt; functions are for detecting non-responsive peers and to avoid blocking on socket operations.</source>
          <target state="translated">显然，超时是为了实现容错能力，而不是为了遵守严格的实时承诺。的 &lt;code&gt;_tmo&lt;/code&gt; 功能是用于检测非响应同行和避免阻塞插座操作。</target>
        </trans-unit>
        <trans-unit id="b8b55894a3a573e9c169f2784eaa3824d8dc1f41" translate="yes" xml:space="preserve">
          <source>Clearly, &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; could be implemented with the &lt;code&gt;get_until&lt;/code&gt; request (and indeed they were originally), but demands for efficiency have made these additions necessary.</source>
          <target state="translated">显然， &lt;code&gt;get_chars&lt;/code&gt; 和 &lt;code&gt;get_line&lt;/code&gt; 可以与 &lt;code&gt;get_until&lt;/code&gt; 请求一起实现（实际上它们是最初的请求），但是对效率的要求使得这些增加成为必要。</target>
        </trans-unit>
        <trans-unit id="104ddb5596b2b3c6bb809b4e7942686129ee7afb" translate="yes" xml:space="preserve">
          <source>Clearly, the second &lt;code&gt;io:format/2&lt;/code&gt; gives undesired output, as the UTF-8 binary is not in &lt;code&gt;latin1&lt;/code&gt;. For backward compatibility, the non-prefixed control character &lt;code&gt;s&lt;/code&gt; expects bytewise-encoded ISO Latin-1 characters in binaries and lists containing only code points &amp;lt; 256.</source>
          <target state="translated">显然，第二个 &lt;code&gt;io:format/2&lt;/code&gt; 给出了不希望的输出，因为UTF-8二进制文件不在 &lt;code&gt;latin1&lt;/code&gt; 中。为了向后兼容，非前缀控制字符 &lt;code&gt;s&lt;/code&gt; 在二进制文件和仅包含&amp;lt;256个代码点的列表中期望按字节编码的ISO Latin-1字符。</target>
        </trans-unit>
        <trans-unit id="ac68fc3d2a1c66a24efacfe356996e3f36da43ed" translate="yes" xml:space="preserve">
          <source>Clearly, the text is badly formatted. Instead of formatting this paragraph line by line, let's try &lt;code&gt;erlang-fill-paragraph&lt;/code&gt; by pressing &lt;strong&gt;&lt;code&gt;M-q&lt;/code&gt;&lt;/strong&gt;. The result is:</source>
          <target state="translated">显然，文本格式错误。与其逐行格式化该段落， &lt;code&gt;erlang-fill-paragraph&lt;/code&gt; 按&lt;strong&gt; &lt;code&gt;M-q&lt;/code&gt; &lt;/strong&gt;尝试erlang-fill-paragraph。结果是：</target>
        </trans-unit>
        <trans-unit id="86f0101226f5f81bb0f27692ae9b01618069c017" translate="yes" xml:space="preserve">
          <source>Clears a node from the list of traced nodes. Subsequent calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; will not consider that node, but tracing already activated on the node will continue to be in effect.</source>
          <target state="translated">从跟踪的节点列表中清除一个节点。随后对 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 的调用将不考虑该节点，但是已经在该节点上激活的跟踪将继续有效。</target>
        </trans-unit>
        <trans-unit id="0b13ce8b44b6644dd7e70d2aa9ea4a770cfcfe42" translate="yes" xml:space="preserve">
          <source>Clears all flags.</source>
          <target state="translated">清除所有标志。</target>
        </trans-unit>
        <trans-unit id="467456a156c8089790f8fcb07286226580f312c2" translate="yes" xml:space="preserve">
          <source>Clears all tracing from the node and starts a new &lt;code&gt;fprof&lt;/code&gt; trace. Either option &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; must be specified, but not both.</source>
          <target state="translated">清除节点中的所有跟踪并开始新的 &lt;code&gt;fprof&lt;/code&gt; 跟踪。必须指定 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;stop&lt;/code&gt; 选项，但不能两者都指定。</target>
        </trans-unit>
        <trans-unit id="2442f3d1d0666c552ddd200f6f80efa37ba1d36f" translate="yes" xml:space="preserve">
          <source>Clears information about processes executing interpreted code by removing all information about terminated processes.</source>
          <target state="translated">通过删除所有关于终止进程的信息,清除执行解释代码的进程信息。</target>
        </trans-unit>
        <trans-unit id="19ca408ce500ce988f93c1127be6072ab57dbf07" translate="yes" xml:space="preserve">
          <source>Clears the associated comments of &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">清除 &lt;code&gt;Node&lt;/code&gt; 的关联注释。</target>
        </trans-unit>
        <trans-unit id="ca93ac6b0dd536d4e5f2ea8448f979122bed328d" translate="yes" xml:space="preserve">
          <source>Clears the freelist, where blocks are placed when they are released by &lt;code&gt;erl_free_term()&lt;/code&gt; and &lt;code&gt;erl_free_compound()&lt;/code&gt;.</source>
          <target state="translated">清除 &lt;code&gt;erl_free_term()&lt;/code&gt; ，这些 &lt;code&gt;erl_free_compound()&lt;/code&gt; 由erl_free_term（）和erl_free_compound（）释放时放置。</target>
        </trans-unit>
        <trans-unit id="bf95008d3bf29f6ae931c4a1447def2c26138965" translate="yes" xml:space="preserve">
          <source>Clears the internal lock statistics from the runtime system. This does not clear the data on the server only on runtime system. All counters for static locks are zeroed, all dynamic locks currently alive are zeroed and all saved locks now destroyed are removed. It also resets the duration timer.</source>
          <target state="translated">清除运行时系统中的内部锁统计数据。这并不是只清除服务器上的数据,而是清除运行时系统上的数据。所有静态锁的计数器都归零,所有当前有效的动态锁都归零,所有现在被销毁的保存锁都被移除。它还会重置持续时间计时器。</target>
        </trans-unit>
        <trans-unit id="f984b760bad5d198926e4961e47fdf78889ec801" translate="yes" xml:space="preserve">
          <source>Clears the lock counters and then setups the instrumentation to save all destroyed locks. After setup the function is called, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments. When the function returns the statistics are immediately collected to the server. After the collection the instrumentation is returned to its previous behavior. The result of the applied function is returned.</source>
          <target state="translated">清除锁计数器，然后设置检测以保存所有销毁的锁。设置后，将调用该函数，并将 &lt;code&gt;Args&lt;/code&gt; 中的元素作为参数传递。当函数返回时，统计信息将立即收集到服务器。收集之后，仪器将恢复其先前的行为。返回所应用函数的结果。</target>
        </trans-unit>
        <trans-unit id="37dcdd456e3c2b69c6b0d8ce4b98fc1d4210c009" translate="yes" xml:space="preserve">
          <source>Clears the temporary boot command. If the system terminates, the normal &lt;code&gt;HEART_COMMAND&lt;/code&gt; is used to reboot.</source>
          <target state="translated">清除临时启动命令。如果系统终止，则使用正常的 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 重启。</target>
        </trans-unit>
        <trans-unit id="2577cb3633fef5aad5a84c896c2c6f81b1bca437" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on global function calls.</source>
          <target state="translated">清除全局函数调用的跟踪模式。</target>
        </trans-unit>
        <trans-unit id="11b01ab35fecb88a64d47127f48dfdab0c530753" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on local and global function calls.</source>
          <target state="translated">清除本地和全局函数调用的跟踪模式。</target>
        </trans-unit>
        <trans-unit id="5e9e55a4beacaabaa7e4c5fc4cd8ca1cff7f3d79" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on local function calls.</source>
          <target state="translated">清除本地函数调用的跟踪模式。</target>
        </trans-unit>
        <trans-unit id="d6d6ba23a63720746cd129c4ddd78a9ce8b9db70" translate="yes" xml:space="preserve">
          <source>Clears trace patterns on messages.</source>
          <target state="translated">清除信息的跟踪模式。</target>
        </trans-unit>
        <trans-unit id="0fec5dd690b7876869007fa4dc8e05b88546abf4" translate="yes" xml:space="preserve">
          <source>Click button &lt;strong&gt;Start Trace&lt;/strong&gt; to start the trace. By default, trace output is written to a new window. Tracing is stopped when the window is closed, or when clicking button &lt;strong&gt;Stop Trace&lt;/strong&gt;. Trace output can be changed with menu &lt;strong&gt;Options &amp;gt; Output&lt;/strong&gt;. The trace settings, including match specifications, can be saved to, or loaded from, a file.</source>
          <target state="translated">单击&lt;strong&gt;开始跟踪&lt;/strong&gt;按钮以开始跟踪。默认情况下，跟踪输出将写入新窗口。关闭窗口或单击&amp;ldquo; &lt;strong&gt;停止跟踪&amp;rdquo;&lt;/strong&gt;按钮时，跟踪将停止。跟踪输出可通过菜单&lt;strong&gt;选项&amp;gt;输出&lt;/strong&gt;更改。跟踪设置（包括匹配规范）可以保存到文件或从文件加载。</target>
        </trans-unit>
        <trans-unit id="dcef5f474ab1f60b5d9bc1fcf7ce96b36faec402" translate="yes" xml:space="preserve">
          <source>Click on a name tag to display its page.</source>
          <target state="translated">点击名称标签,显示其页面。</target>
        </trans-unit>
        <trans-unit id="04d51c8f44c15e0a1e9cd8d40fce6f0329fdae6b" translate="yes" xml:space="preserve">
          <source>Clicking a line highlights it and selects it to be the target of the breakpoint functions available from the &lt;strong&gt;Break&lt;/strong&gt; menu. To set a line breakpoint on a line, double-click it. To remove the breakpoint, double-click the line with an existing breakpoint.</source>
          <target state="translated">单击一行将其突出显示，并选择它作为&amp;ldquo; &lt;strong&gt;中断&amp;rdquo;&lt;/strong&gt;菜单中可用的断点功能的目标。要在一条线上设置断点，请双击它。要删除断点，请双击具有现有断点的行。</target>
        </trans-unit>
        <trans-unit id="b3d312baec2796712d75d4a4d40d52f7bba6028b" translate="yes" xml:space="preserve">
          <source>Client Options</source>
          <target state="translated">客户端选项</target>
        </trans-unit>
        <trans-unit id="28e22fe3dde53ce03b40861a4b22d205384bde66" translate="yes" xml:space="preserve">
          <source>Clients</source>
          <target state="translated">Clients</target>
        </trans-unit>
        <trans-unit id="5d0bb5fe7a5e961e5880f93d711f0e38dc532408" translate="yes" xml:space="preserve">
          <source>Clients are started with &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4&lt;/a&gt;&lt;/code&gt;. They open an encrypted connection on top of TCP/IP. In that encrypted connection one or more channels could be opened with &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">客户端以 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/4&lt;/a&gt;&lt;/code&gt; 启动。他们在TCP / IP上打开一个加密的连接。在该加密连接中，可以使用 &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; 打开一个或多个通道。</target>
        </trans-unit>
        <trans-unit id="ca3bc6fb91b02b317e470f58c63c4f0940df8f0d" translate="yes" xml:space="preserve">
          <source>Clients can request to reuse a session established by a previous full handshake between that client and server by sending the id of the session in the initial handshake message. The server may or may not agree to reuse it. If agreed the server will send back the id and if not it will send a new id. The ssl application has several options for handling session reuse.</source>
          <target state="translated">客户端可以通过在初始握手消息中发送会话的id来请求重用该客户端和服务器之间之前的完全握手建立的会话。服务器可能同意也可能不同意重用。如果同意,服务器将发回该id,如果不同意,将发送一个新的id。ssl应用程序有几个选项来处理会话重用。</target>
        </trans-unit>
        <trans-unit id="0ec0af9b01d531f2c1e91f2576ecad57b1002807" translate="yes" xml:space="preserve">
          <source>Clients uses all files stored in the &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; directory.</source>
          <target state="translated">客户端使用存储在 &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; 目录中的所有文件。</target>
        </trans-unit>
        <trans-unit id="c9afbd6ca86ca26af0ee4601de8d33e0e3db301d" translate="yes" xml:space="preserve">
          <source>Close punctuation</source>
          <target state="translated">关闭标点符号</target>
        </trans-unit>
        <trans-unit id="c24bd6354c11beadb396720d375c93335e15a7ec" translate="yes" xml:space="preserve">
          <source>Close the mib-storage table.</source>
          <target state="translated">关闭mib存储表。</target>
        </trans-unit>
        <trans-unit id="592b9786d83b25c310e25098ffbb1c8d8d35ce68" translate="yes" xml:space="preserve">
          <source>Close the mib-storage.</source>
          <target state="translated">关闭mib存储。</target>
        </trans-unit>
        <trans-unit id="dc569b6b856c7427e167157a74113626f12814c7" translate="yes" xml:space="preserve">
          <source>Close the socket identified by &lt;code&gt;ctx&lt;/code&gt; and destroy the context.</source>
          <target state="translated">关闭由 &lt;code&gt;ctx&lt;/code&gt; 标识的套接字并销毁上下文。</target>
        </trans-unit>
        <trans-unit id="a01bd159b8f373e3abf9028301a1b651c7e12f62" translate="yes" xml:space="preserve">
          <source>Closes a TCP socket.</source>
          <target state="translated">关闭一个TCP套接字。</target>
        </trans-unit>
        <trans-unit id="e937c538908fd420cad6e2a18d22a1ccd28c5e7d" translate="yes" xml:space="preserve">
          <source>Closes a TLS/DTLS connection.</source>
          <target state="translated">关闭TLS/DTLS连接。</target>
        </trans-unit>
        <trans-unit id="9496f4074e8f35d723149747305a4b83e6a2e080" translate="yes" xml:space="preserve">
          <source>Closes a UDP socket.</source>
          <target state="translated">关闭一个UDP套接字。</target>
        </trans-unit>
        <trans-unit id="c3012268c89638e549e91dc1baa96b886e28b2a0" translate="yes" xml:space="preserve">
          <source>Closes a connection to a database. This will also terminate all processes that may have been spawned when the connection was opened. This call will always succeed. If the connection can not be disconnected gracefully it will be brutally killed. However you may receive an error message as result if you try to disconnect a connection started by another process.</source>
          <target state="translated">关闭与数据库的连接。这也将终止所有在打开连接时可能产生的进程。这个调用总是会成功的。如果连接不能被优雅地断开,它将被残忍地杀死。但是,如果你试图断开一个由其他进程启动的连接,你可能会收到一条错误信息。</target>
        </trans-unit>
        <trans-unit id="68bbaec5e74f6047f0e5abcbc8a727621d01ec20" translate="yes" xml:space="preserve">
          <source>Closes a connection to a database. This will also terminate all processes that may have been spawned when the connection was opened. This call will always succeed. If the connection cannot be disconnected gracefully it will be brutally killed. However you may receive an error message as result if you try to disconnect a connection started by another process.</source>
          <target state="translated">关闭与数据库的连接。这也将终止所有在打开连接时可能产生的进程。这个调用总是会成功的。如果连接不能被优雅地断开,它将被残忍地杀死。然而,如果你试图断开由其他进程启动的连接,你可能会收到一条错误信息。</target>
        </trans-unit>
        <trans-unit id="fedaf7e7f755777e61b444ad3388a8908bb68e49" translate="yes" xml:space="preserve">
          <source>Closes a handle to an open file or directory on the server.</source>
          <target state="translated">关闭服务器上一个打开的文件或目录的句柄。</target>
        </trans-unit>
        <trans-unit id="215485c4befae922eb5a5d5935fd733652b4ce47" translate="yes" xml:space="preserve">
          <source>Closes a local or distributed disk log properly. An internally formatted log must be closed before the Erlang system is stopped. Otherwise, the log is regarded as unclosed and the automatic repair procedure is activated next time the log is opened.</source>
          <target state="translated">正确关闭本地或分布式磁盘日志。内部格式化的日志必须在 Erlang 系统停止之前关闭。否则,日志将被视为未关闭,下次打开日志时将启动自动修复程序。</target>
        </trans-unit>
        <trans-unit id="29e73ff6b566a953cef38a1f7457365c29503626" translate="yes" xml:space="preserve">
          <source>Closes a log file properly.</source>
          <target state="translated">正确关闭日志文件。</target>
        </trans-unit>
        <trans-unit id="07fc420ec95adbf7d0f9265d705ee3ece3f06902" translate="yes" xml:space="preserve">
          <source>Closes a previously opened connection or listen socket.</source>
          <target state="translated">关闭之前打开的连接或监听套接字。</target>
        </trans-unit>
        <trans-unit id="e4fe071a7ae3117ab43dd5cebfb15042d7d75064" translate="yes" xml:space="preserve">
          <source>Closes a socket in one or two directions.</source>
          <target state="translated">在一个或两个方向上关闭一个插座。</target>
        </trans-unit>
        <trans-unit id="34f9bfce04a30dbf2d2a5d3ff2b9de4343426661" translate="yes" xml:space="preserve">
          <source>Closes a socket of any type.</source>
          <target state="translated">关闭任何类型的插座。</target>
        </trans-unit>
        <trans-unit id="07d2d8b051eae4fe9f47eb82e8322135c86a9d13" translate="yes" xml:space="preserve">
          <source>Closes a table. Only processes that have opened a table are allowed to close it.</source>
          <target state="translated">关闭表格。只有打开过表格的进程才可以关闭表格。</target>
        </trans-unit>
        <trans-unit id="58e1063100c7c97dfae0ff35da3735d6d25aaa8a" translate="yes" xml:space="preserve">
          <source>Closes a tar file opened by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">关闭由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 打开的tar文件。</target>
        </trans-unit>
        <trans-unit id="f90b891ab0b807043fe4d07d621237e76f50a2a8" translate="yes" xml:space="preserve">
          <source>Closes a zip archive, previously opened with &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt;. All resources are closed, and the handle is not to be used after closing.</source>
          <target state="translated">关闭以前使用 &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; 打开的zip存档。所有资源均已关闭，并且关闭后将不使用该句柄。</target>
        </trans-unit>
        <trans-unit id="225c79c841a7ef2d9c14cfd8b6c0560b734eccdf" translate="yes" xml:space="preserve">
          <source>Closes an SSH connection.</source>
          <target state="translated">关闭SSH连接。</target>
        </trans-unit>
        <trans-unit id="45417a381f59258abc297027e3e6dd25f02cd21d" translate="yes" xml:space="preserve">
          <source>Closes an SSH session channel.</source>
          <target state="translated">关闭SSH会话通道。</target>
        </trans-unit>
        <trans-unit id="e5e229797e97b628c04b38a55fb8e68b7a123f74" translate="yes" xml:space="preserve">
          <source>Closes an SSH/SFTP connection.</source>
          <target state="translated">关闭SSH/SFTP连接。</target>
        </trans-unit>
        <trans-unit id="fb37d2a48e4ea7de8281d62da1148d80ddf77a3c" translate="yes" xml:space="preserve">
          <source>Closes an TLS/DTLS connection.</source>
          <target state="translated">关闭TLS/DTLS连接。</target>
        </trans-unit>
        <trans-unit id="6e2c93e1cd8faf1313158041890dec046b7c45af" translate="yes" xml:space="preserve">
          <source>Closes an open connection to an Erlang node.</source>
          <target state="translated">关闭与Erlang节点的开放连接。</target>
        </trans-unit>
        <trans-unit id="93f51f1e052bdccb2b5819a8e385ea79a02eae4e" translate="yes" xml:space="preserve">
          <source>Closes an open port. Roughly the same as &lt;code&gt;Port ! {self(), close}&lt;/code&gt; except for the error behavior (see below), being synchronous, and that the port does &lt;strong&gt;not&lt;/strong&gt; reply with &lt;code&gt;{Port, closed}&lt;/code&gt;. Any process can close a port with &lt;code&gt;port_close/1&lt;/code&gt;, not only the port owner (the connected process). If the calling process is linked to the port identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_close/1&lt;/code&gt; returns.</source>
          <target state="translated">关闭打开的端口。与 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 大致相同！ {自（），靠近}除了错误行为（见下文），是同步的，并且该端口也&lt;strong&gt;不会&lt;/strong&gt;与回复 &lt;code&gt;{Port, closed}&lt;/code&gt; 。任何进程都可以使用 &lt;code&gt;port_close/1&lt;/code&gt; 关闭端口，而不仅是端口所有者（连接的进程）。如果调用过程链接到由 &lt;code&gt;Port&lt;/code&gt; 标识的端口，则可以保证在 &lt;code&gt;port_close/1&lt;/code&gt; 返回之前传递该端口的退出信号。</target>
        </trans-unit>
        <trans-unit id="b00fa3ba7559016fbe2ca5768febc2df9174ce3f" translate="yes" xml:space="preserve">
          <source>Closes or downgrades a TLS connection. In the latter case the transport connection will be handed over to the &lt;code&gt;NewController&lt;/code&gt; process after receiving the TLS close alert from the peer. The returned transport socket will have the following options set: &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</source>
          <target state="translated">关闭或降级TLS连接。在后一种情况下，传输连接将在收到来自对等方的TLS关闭警报后移交给 &lt;code&gt;NewController&lt;/code&gt; 进程。返回的传输套接字将设置以下选项： &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e9d4bec3e73259bf8d39d5cd28968440d21e59d" translate="yes" xml:space="preserve">
          <source>Closes or downgrades an TLS connection. In the latter case the transport connection will be handed over to the &lt;code&gt;NewController&lt;/code&gt; process after receiving the TLS close alert from the peer. The returned transport socket will have the following options set: &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</source>
          <target state="translated">关闭或降级TLS连接。在后一种情况下，传输连接将在收到来自对等方的TLS关闭警报后移交给 &lt;code&gt;NewController&lt;/code&gt; 进程。返回的传输套接字将设置以下选项： &lt;code&gt;[{active, false}, {packet, 0}, {mode, binary}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751e30fd02da6e32788d4a5c145fde188cf46230" translate="yes" xml:space="preserve">
          <source>Closes the FTP connection.</source>
          <target state="translated">关闭FTP连接。</target>
        </trans-unit>
        <trans-unit id="18d541512ada7266d080309162b7730417e656c5" translate="yes" xml:space="preserve">
          <source>Closes the Telnet connection and stops the process managing it.</source>
          <target state="translated">关闭Telnet连接并停止管理该连接的进程。</target>
        </trans-unit>
        <trans-unit id="1d8aa591e076329a5cff023401fe06aa6fea372b" translate="yes" xml:space="preserve">
          <source>Closes the access.</source>
          <target state="translated">关闭通道。</target>
        </trans-unit>
        <trans-unit id="61217cd859d4e901638e1c1975335762abb86efd" translate="yes" xml:space="preserve">
          <source>Closes the current log file. Returns &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error, module_not_found}&lt;/code&gt;.</source>
          <target state="translated">关闭当前的日志文件。返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error, module_not_found}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec24623729c70fb6bea95b4e625a0da9a7e8c998" translate="yes" xml:space="preserve">
          <source>Closes the file referenced by &lt;code&gt;IoDevice&lt;/code&gt;. It mostly returns &lt;code&gt;ok&lt;/code&gt;, except for some severe errors such as out of memory.</source>
          <target state="translated">关闭 &lt;code&gt;IoDevice&lt;/code&gt; 引用的文件。除一些严重错误（例如内存不足）外，它通常返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="684f684454d3e1635a242373232771bb9dda7424" translate="yes" xml:space="preserve">
          <source>Closes the given SSH connection.</source>
          <target state="translated">关闭给定的SSH连接。</target>
        </trans-unit>
        <trans-unit id="27c0419dbdad16fe1e643dacd2401a129f7bd772" translate="yes" xml:space="preserve">
          <source>Closes the log file. The output from the RB tool is directed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">关闭日志文件。RB工具的输出定向到 &lt;code&gt;standard_io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="504626654a412e4798e7dd4e7f5ea514b7c55cf7" translate="yes" xml:space="preserve">
          <source>Closes the port.</source>
          <target state="translated">关闭端口。</target>
        </trans-unit>
        <trans-unit id="b69157f4131c8138ac5adf29a5ca6f8c9971773d" translate="yes" xml:space="preserve">
          <source>Closes the port. Unless the port is already closed, the port replies with &lt;code&gt;{Port,closed}&lt;/code&gt; when all buffers have been flushed and the port really closes.</source>
          <target state="translated">关闭端口。除非端口已关闭，否则在刷新所有缓冲区并且端口真正关闭后，该端口将以 &lt;code&gt;{Port,closed}&lt;/code&gt; 答复。</target>
        </trans-unit>
        <trans-unit id="ec9e12048014ec45278b599d7514a7f58d812a5d" translate="yes" xml:space="preserve">
          <source>Closes the preprocessing of a file.</source>
          <target state="translated">关闭文件的预处理。</target>
        </trans-unit>
        <trans-unit id="269356b8822c1fff23690ce723ac4f1ed4460bf8" translate="yes" xml:space="preserve">
          <source>Closes the registry. After that, the &lt;code&gt;RegHandle&lt;/code&gt; cannot be used.</source>
          <target state="translated">关闭注册表。此后，将无法使用 &lt;code&gt;RegHandle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f12faa3ebf225ccbe7cdef983e0e76eeecdf113" translate="yes" xml:space="preserve">
          <source>Closes the socket and all associations on it. The unsent data is flushed as in &lt;code&gt;&lt;a href=&quot;#eof-2&quot;&gt;eof/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;close/1&lt;/code&gt; call is blocking or otherwise depending of the value of the &lt;code&gt;&lt;a href=&quot;inet#option-linger&quot;&gt;linger&lt;/a&gt;&lt;/code&gt; socket &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;option&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;close&lt;/code&gt; does not linger or linger time-out expires, the call returns and the data is flushed in the background.</source>
          <target state="translated">关闭套接字及其上的所有关联。如 &lt;code&gt;&lt;a href=&quot;#eof-2&quot;&gt;eof/2&lt;/a&gt;&lt;/code&gt; 一样刷新未发送的数据。在 &lt;code&gt;close/1&lt;/code&gt; 呼叫被阻塞或以其他方式取决于的值的 &lt;code&gt;&lt;a href=&quot;inet#option-linger&quot;&gt;linger&lt;/a&gt;&lt;/code&gt; 插座 &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;option&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;close&lt;/code&gt; 没有持续或持续超时，则调用返回，并且数据在后台刷新。</target>
        </trans-unit>
        <trans-unit id="d088ba46947a0a90bc08a101b18b61eb57bcdcb7" translate="yes" xml:space="preserve">
          <source>Closes the socket.</source>
          <target state="translated">关闭插座。</target>
        </trans-unit>
        <trans-unit id="7bffc0467918675e50dec5df0e6816862c61c4aa" translate="yes" xml:space="preserve">
          <source>Closes the stream referenced by &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">关闭 &lt;code&gt;Z&lt;/code&gt; 引用的流。</target>
        </trans-unit>
        <trans-unit id="99973cebcb8af97213e10f909e8acc88b7dd1ef1" translate="yes" xml:space="preserve">
          <source>Closes this window and detach from the process.</source>
          <target state="translated">关闭此窗口,并从进程中脱离出来。</target>
        </trans-unit>
        <trans-unit id="34a868e0a12f0bd3b0076e904023cd21157c12b0" translate="yes" xml:space="preserve">
          <source>Closing a Channel (RFC 4254, section 5.3)</source>
          <target state="translated">关闭通道(RFC 4254,5.3节)。</target>
        </trans-unit>
        <trans-unit id="dfd86873672c10f114caa15b02aa5a859162a796" translate="yes" xml:space="preserve">
          <source>ClosureOp ::= &lt;code&gt;closure&lt;/code&gt;</source>
          <target state="translated">ClosureOp :: = &lt;code&gt;closure&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e90a0d75842a148bf39ca837cd5f740d36c1a9b" translate="yes" xml:space="preserve">
          <source>Cmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4493.txt&quot;&gt;The AES-CMAC Algorithm (RFC 4493)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Cmac函数-AES &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4493.txt&quot;&gt;The AES-CMAC Algorithm (RFC 4493)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49cdd0ecba2f4a1cf6ab5d194ad0b2feeb7627e0" translate="yes" xml:space="preserve">
          <source>Co-located callback code for each state, for all &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; &lt;strong&gt;Event Types&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; (such as &lt;strong&gt;call&lt;/strong&gt;, &lt;strong&gt;cast&lt;/strong&gt; and &lt;strong&gt;info&lt;/strong&gt;)</source>
          <target state="translated">每个状态，所有 &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; &lt;strong&gt;Event Types&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; （例如&lt;strong&gt;call&lt;/strong&gt;，&lt;strong&gt;cast&lt;/strong&gt;和&lt;strong&gt;info&lt;/strong&gt;）的同位置回调代码 &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3401a3d9fe92078f97d8cfcd69cd94295181a349" translate="yes" xml:space="preserve">
          <source>Co-located callback code for each state, regardless of &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Type&lt;/a&gt;&lt;/code&gt; (such as &lt;strong&gt;call&lt;/strong&gt;, &lt;strong&gt;cast&lt;/strong&gt; and &lt;strong&gt;info&lt;/strong&gt;)</source>
          <target state="translated">每个状态的共址回调代码，无论 &lt;code&gt;&lt;a href=&quot;#Event%20Types&quot;&gt;Event Type&lt;/a&gt;&lt;/code&gt; 如何（例如&lt;strong&gt;call&lt;/strong&gt;，&lt;strong&gt;cast&lt;/strong&gt;和&lt;strong&gt;info&lt;/strong&gt;）</target>
        </trans-unit>
        <trans-unit id="dce76c393d27cb2285a888bed5709e098f9c85a0" translate="yes" xml:space="preserve">
          <source>Co-located state code</source>
          <target state="translated">共用国家代码</target>
        </trans-unit>
        <trans-unit id="071b4a868a8b79b6bd06d47e2377e594598062a5" translate="yes" xml:space="preserve">
          <source>Coalescing of free blocks are always performed immediately. Boundary tags (headers and footers) in free blocks are used, which makes the time complexity for coalescing constant.</source>
          <target state="translated">自由块的聚合总是立即执行。在自由块中使用边界标签(页眉和页脚),这使得聚合的时间复杂度不变。</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="f82863ada61185750ed2535d5af42aa575352c0d" translate="yes" xml:space="preserve">
          <source>Code Path</source>
          <target state="translated">代码路径</target>
        </trans-unit>
        <trans-unit id="2cbcb8d71aaf189c59401ae6220a8fde81d304a8" translate="yes" xml:space="preserve">
          <source>Code changes that seem small can cause a deadlock, as unforeseen consequences can occur. The use of &lt;code&gt;input&lt;/code&gt; is dangerous in this type of code.</source>
          <target state="translated">看起来很小的代码更改可能会导致死锁，因为可能发生无法预料的后果。在这种类型的代码中，使用 &lt;code&gt;input&lt;/code&gt; 是危险的。</target>
        </trans-unit>
        <trans-unit id="f6f0001667925b51aaa144c8555cdf56ab04f2c1" translate="yes" xml:space="preserve">
          <source>Code executing only in the final phase does not have to be able to cope with the time warp.</source>
          <target state="translated">只在最后阶段执行的代码不必能应付时空穿梭。</target>
        </trans-unit>
        <trans-unit id="7da5ff52f9c2e858ddeba30acb14c98399f10834" translate="yes" xml:space="preserve">
          <source>Code generation directives</source>
          <target state="translated">代码生成指令</target>
        </trans-unit>
        <trans-unit id="7517d2173bc408241c9c961ca6ed13ae1bf3cf95" translate="yes" xml:space="preserve">
          <source>Code like the following will also be optimized:</source>
          <target state="translated">像下面这样的代码也会被优化。</target>
        </trans-unit>
        <trans-unit id="a42f74f1f02a3aa3006bb5a047e88b03e340b66f" translate="yes" xml:space="preserve">
          <source>Code loading</source>
          <target state="translated">代码加载</target>
        </trans-unit>
        <trans-unit id="e6e4cfb9758510abbc95d1476acfff025d1aadab" translate="yes" xml:space="preserve">
          <source>Code loading mode.</source>
          <target state="translated">代码加载模式。</target>
        </trans-unit>
        <trans-unit id="8ac67b9a438c843103e19b5b4579252c71ad56fe" translate="yes" xml:space="preserve">
          <source>Code loading works almost as usual, except that interpreted modules are also stored in a database and debugged processes use only this stored code. Reinterpreting an interpreted module results in the new version being stored as well, but does not affect existing processes executing an older version of the code. This means that the code replacement mechanism of Erlang does not work for debugged processes.</source>
          <target state="translated">代码加载的工作原理几乎和往常一样,只是解释的模块也存储在数据库中,调试的进程只使用这个存储的代码。重新解释一个解释模块的结果是新的版本也会被存储,但不会影响现有进程执行旧版本的代码。这意味着,Erlang的代码替换机制对被调试的进程不起作用。</target>
        </trans-unit>
        <trans-unit id="56c19e16bac5b16970cd9ff83784b17afefb33d0" translate="yes" xml:space="preserve">
          <source>Code point 16#FEFF is used for Byte Order Marks (BOMs) and use of that character is not encouraged in other contexts. It is valid though, as the character &quot;ZWNBS&quot; (Zero Width Non Breaking Space). BOMs are used to identify encodings and byte order for programs where such parameters are not known in advance. BOMs are more seldom used than expected, but can become more widely spread as they provide the means for programs to make educated guesses about the Unicode format of a certain file.</source>
          <target state="translated">代码点16#FEFF用于字节序号(BOM),不鼓励在其他情况下使用该字符。但它作为字符 &quot;ZWNBS&quot;(零宽度非分隔空间)是有效的。BOMs用于识别编码和字节顺序,用于事先不知道这些参数的程序。BOM的使用比预期的要少,但可以变得更加广泛,因为它们为程序提供了对某个文件的Unicode格式进行有根据的猜测的方法。</target>
        </trans-unit>
        <trans-unit id="63c15bd60bea5d826d7523a85dc068734b1a1ba4" translate="yes" xml:space="preserve">
          <source>Code such as these examples is inherently non-portable, even different versions of the same OS on the same platform can respond differently to this kind of option manipulation. Use with care.</source>
          <target state="translated">像这些例子的代码本身就不可移植,即使是同一平台上同一操作系统的不同版本也会对这种选项操作做出不同的反应。请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="5f527646d672b093be1a4098fc6814606d464bbd" translate="yes" xml:space="preserve">
          <source>Code that is the current latest version of the modules.</source>
          <target state="translated">是当前最新版本的模块的代码。</target>
        </trans-unit>
        <trans-unit id="70f90dd78e0b0fb23852ab6b2688deed73f5c02c" translate="yes" xml:space="preserve">
          <source>Code that manipulates the same data records can be run concurrently without the different processes interfering with each other.</source>
          <target state="translated">操作相同数据记录的代码可以并发运行,不同的进程之间不会相互干扰。</target>
        </trans-unit>
        <trans-unit id="8ee529db22d08c438f2f9211e70f671de376615a" translate="yes" xml:space="preserve">
          <source>Code using the same layout is easy to read and maintain.</source>
          <target state="translated">使用相同布局的代码易于阅读和维护。</target>
        </trans-unit>
        <trans-unit id="aaa79e3d7390f36f2c6656fca85bff5690139844" translate="yes" xml:space="preserve">
          <source>Code where there exists a newer version in the system, but the old version is not yet purged.</source>
          <target state="translated">系统中存在较新版本,但旧版本尚未清除的代码。</target>
        </trans-unit>
        <trans-unit id="dda1e35cb5eaf5544e935767c1b869708c6466c8" translate="yes" xml:space="preserve">
          <source>Code written without using behaviours can be more efficient, but the increased efficiency is at the expense of generality. The ability to manage all applications in the system in a consistent manner is important.</source>
          <target state="translated">在不使用行为的情况下编写的代码可以提高效率,但效率的提高是以牺牲通用性为代价的。以一致的方式管理系统中的所有应用程序的能力很重要。</target>
        </trans-unit>
        <trans-unit id="aabf94dda285f7b2ce559c0a81d2821b9125e926" translate="yes" xml:space="preserve">
          <source>Collect digit map letters according to the digit map.</source>
          <target state="translated">根据数字地图收集数字地图字母。</target>
        </trans-unit>
        <trans-unit id="d5c4376d706e0e0926ed6b917a93992a5fa5fd3f" translate="yes" xml:space="preserve">
          <source>Collect trace events and provide a backing storage appropriate for iteration</source>
          <target state="translated">收集跟踪事件,并提供适合迭代的备份存储。</target>
        </trans-unit>
        <trans-unit id="e33d648c88485b5e3445ec85a48ee3a200918fb7" translate="yes" xml:space="preserve">
          <source>Collector menu:</source>
          <target state="translated">收藏家菜单。</target>
        </trans-unit>
        <trans-unit id="2cc767ef47379b0118564589be24769b7d52f979" translate="yes" xml:space="preserve">
          <source>Collects and analyses the call counters presently in the node for either module &lt;code&gt;Mod&lt;/code&gt;, or for all modules (except &lt;code&gt;cprof&lt;/code&gt; itself), and returns:</source>
          <target state="translated">收集并分析节点中当前针对模块 &lt;code&gt;Mod&lt;/code&gt; 或所有模块（ &lt;code&gt;cprof&lt;/code&gt; 本身除外）的调用计数器，并返回：</target>
        </trans-unit>
        <trans-unit id="5b532be13bb4823dedcb40365e8ab9adfcc43c5f" translate="yes" xml:space="preserve">
          <source>Collects call counters and computes the result.</source>
          <target state="translated">收集呼叫计数器并计算结果。</target>
        </trans-unit>
        <trans-unit id="2d339d9851615bae000afcd6bc3156d0c65cf55a" translate="yes" xml:space="preserve">
          <source>Collects lock statistics from the runtime system. The function starts a server if it is not already started. It then populates the server with lock statistics. If the server held any lock statistics data before the collect then that data is lost.</source>
          <target state="translated">收集运行时系统中的锁统计数据。如果服务器尚未启动,则该函数启动服务器。然后用锁统计数据填充服务器。如果服务器在收集之前有任何锁统计数据,那么这些数据将丢失。</target>
        </trans-unit>
        <trans-unit id="114d6372609006dd470fd4948b225b11b9aee096" translate="yes" xml:space="preserve">
          <source>Collects several segments of data, referenced by &lt;code&gt;ev&lt;/code&gt;, by copying them in order to the buffer &lt;code&gt;buf&lt;/code&gt;, of the size &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">通过将大小为 &lt;code&gt;len&lt;/code&gt; 的数据段复制到缓冲区 &lt;code&gt;buf&lt;/code&gt; 中，来收集 &lt;code&gt;ev&lt;/code&gt; 引用的几段数据。</target>
        </trans-unit>
        <trans-unit id="bdf0b5bed937c19a708d35d32ebd309882131285" translate="yes" xml:space="preserve">
          <source>Column &lt;strong&gt;Memory&lt;/strong&gt; shows the 'Memory' field that was added to crashdumps in Erlang/OTP R16B01. This is the total amount of memory used by the process. For crashdumps from earlier releases, this column shows the 'Stack+heap' field. The value is always in bytes.</source>
          <target state="translated">&lt;strong&gt;内存&lt;/strong&gt;列显示在Erlang / OTP R16B01中添加到崩溃转储中的&amp;ldquo;内存&amp;rdquo;字段。这是该进程使用的内存总量。对于早期版本的崩溃转储，此列显示&amp;ldquo;堆栈+堆&amp;rdquo;字段。该值始终以字节为单位。</target>
        </trans-unit>
        <trans-unit id="f89976c8c47c9f7de7e2ac197cd3c1add9759dd2" translate="yes" xml:space="preserve">
          <source>Column sorting orders.</source>
          <target state="translated">栏目排序顺序。</target>
        </trans-unit>
        <trans-unit id="bbcaf86c57cd6bdf869b7c67b5080193d82b8647" translate="yes" xml:space="preserve">
          <source>Combine the statistics from different instances of a lock class.</source>
          <target state="translated">将一个锁类的不同实例的统计数据结合起来。</target>
        </trans-unit>
        <trans-unit id="17fcaa24e071e5e36935cbcb3562866374761c3a" translate="yes" xml:space="preserve">
          <source>Combined instructions</source>
          <target state="translated">合并指示</target>
        </trans-unit>
        <trans-unit id="7dfd2d72e4720e2879330fef4226ea30d546b398" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;read/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time.</source>
          <target state="translated">在一个操作中组合 &lt;code&gt;position/2&lt;/code&gt; 和 &lt;code&gt;read/2&lt;/code&gt; ，这比一次调用它们更有效。</target>
        </trans-unit>
        <trans-unit id="dc20251782236128d549d6ebb0e54869f51ae3db" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;read/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. If &lt;code&gt;IoDevice&lt;/code&gt; is opened in &lt;code&gt;raw&lt;/code&gt; mode, some restrictions apply:</source>
          <target state="translated">在一个操作中组合 &lt;code&gt;position/2&lt;/code&gt; 和 &lt;code&gt;read/2&lt;/code&gt; ，这比一次调用它们更有效。如果以 &lt;code&gt;raw&lt;/code&gt; 模式打开 &lt;code&gt;IoDevice&lt;/code&gt; ，则存在一些限制：</target>
        </trans-unit>
        <trans-unit id="4267bca1f40191888eec6c3429c09752efc2d66c" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;write/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time.</source>
          <target state="translated">在一个操作中组合 &lt;code&gt;position/2&lt;/code&gt; 和 &lt;code&gt;write/2&lt;/code&gt; ，这比一次调用它们更有效。</target>
        </trans-unit>
        <trans-unit id="4fca0bb2dc4fbd4f474148dae6a3d233006a85be" translate="yes" xml:space="preserve">
          <source>Combines &lt;code&gt;position/2&lt;/code&gt; and &lt;code&gt;write/2&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. If &lt;code&gt;IoDevice&lt;/code&gt; has been opened in &lt;code&gt;raw&lt;/code&gt; mode, some restrictions apply:</source>
          <target state="translated">在一个操作中组合 &lt;code&gt;position/2&lt;/code&gt; 和 &lt;code&gt;write/2&lt;/code&gt; ，这比一次调用它们更有效。如果已以 &lt;code&gt;raw&lt;/code&gt; 模式打开 &lt;code&gt;IoDevice&lt;/code&gt; ,则存在一些限制：</target>
        </trans-unit>
        <trans-unit id="60a59ba0758293ba79d03e3211f6ab8c3cf7a44b" translate="yes" xml:space="preserve">
          <source>Combines map and fold in a single operation. This is similar to &lt;code&gt;map/2&lt;/code&gt;, but also propagates an extra value from each application of the &lt;code&gt;Function&lt;/code&gt; to the next, while doing a post-order traversal of the tree like &lt;code&gt;fold/3&lt;/code&gt;. The value &lt;code&gt;Start&lt;/code&gt; is passed to the first function application, and the final result is the result of the last application.</source>
          <target state="translated">在单个操作中组合地图和折叠。这类似于 &lt;code&gt;map/2&lt;/code&gt; ，但同时将 &lt;code&gt;Function&lt;/code&gt; 每个应用程序传播一个额外的值到下一个应用程序，同时像 &lt;code&gt;fold/3&lt;/code&gt; 一样对树进行后顺序遍历。值 &lt;code&gt;Start&lt;/code&gt; 传递给第一个函数应用程序，最终结果是最后一个应用程序的结果。</target>
        </trans-unit>
        <trans-unit id="b3df522de4ef77bd85fda7b30fd4231f0b29e129" translate="yes" xml:space="preserve">
          <source>Combines the elements of three lists of equal length into one list. For each triple &lt;code&gt;X, Y, Z&lt;/code&gt; of list elements from the three lists, the element in the result list is &lt;code&gt;Combine(X, Y, Z)&lt;/code&gt;.</source>
          <target state="translated">将三个等长列表的元素合并为一个列表。对于三个列表中列表元素的每个三元组 &lt;code&gt;X, Y, Z&lt;/code&gt; ，结果列表中的元素为 &lt;code&gt;Combine(X, Y, Z)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b63fcc6cc8116ab8ae92cf34ec638f3a76d35764" translate="yes" xml:space="preserve">
          <source>Combines the elements of two lists of equal length into one list. For each pair &lt;code&gt;X, Y&lt;/code&gt; of list elements from the two lists, the element in the result list is &lt;code&gt;Combine(X, Y)&lt;/code&gt;.</source>
          <target state="translated">将两个等长列表的元素合并为一个列表。对于两个列表中列表元素的每对 &lt;code&gt;X, Y&lt;/code&gt; ，结果列表中的元素为 &lt;code&gt;Combine(X, Y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df39e33c36c20503114fdd2e4361dfbd8a144da1" translate="yes" xml:space="preserve">
          <source>Combines the operations of &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; into one pass.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 的操作合并为一遍。</target>
        </trans-unit>
        <trans-unit id="9eb3883b2969f22a840c76b882086f1400662f06" translate="yes" xml:space="preserve">
          <source>Combines the operations of &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#foldr-3&quot;&gt;foldr/3&lt;/a&gt;&lt;/code&gt; into one pass.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;map/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#foldr-3&quot;&gt;foldr/3&lt;/a&gt;&lt;/code&gt; 的操作合并为一遍。</target>
        </trans-unit>
        <trans-unit id="001f12c2f7fc722059d0ee491fe8c8b28186a093" translate="yes" xml:space="preserve">
          <source>Combines two Adler-32 checksums into one. For two binaries or iolists, &lt;code&gt;Data1&lt;/code&gt; and &lt;code&gt;Data2&lt;/code&gt; with sizes of &lt;code&gt;Size1&lt;/code&gt; and &lt;code&gt;Size2&lt;/code&gt;, with Adler-32 checksums &lt;code&gt;Adler1&lt;/code&gt; and &lt;code&gt;Adler2&lt;/code&gt;.</source>
          <target state="translated">将两个Adler-32校验和合并为一个。两个二进制文件或iolists， &lt;code&gt;Data1&lt;/code&gt; 和 &lt;code&gt;Data2&lt;/code&gt; 与大小 &lt;code&gt;Size1&lt;/code&gt; 和 &lt;code&gt;Size2&lt;/code&gt; ，与阿德勒-32校验 &lt;code&gt;Adler1&lt;/code&gt; 和 &lt;code&gt;Adler2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08c1251d5cd30a4c857ece6865b552f1070674cf" translate="yes" xml:space="preserve">
          <source>Combines two CRC checksums into one. For two binaries or iolists, &lt;code&gt;Data1&lt;/code&gt; and &lt;code&gt;Data2&lt;/code&gt; with sizes of &lt;code&gt;Size1&lt;/code&gt; and &lt;code&gt;Size2&lt;/code&gt;, with CRC checksums &lt;code&gt;CRC1&lt;/code&gt; and &lt;code&gt;CRC2&lt;/code&gt;.</source>
          <target state="translated">将两个CRC校验和合并为一个。对于双二进制或iolists， &lt;code&gt;Data1&lt;/code&gt; 和 &lt;code&gt;Data2&lt;/code&gt; 用的大小 &lt;code&gt;Size1&lt;/code&gt; 和 &lt;code&gt;Size2&lt;/code&gt; ，与CRC校验和 &lt;code&gt;CRC1&lt;/code&gt; 和 &lt;code&gt;CRC2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1746126ff205a59844a881a51b112a8b53e83b98" translate="yes" xml:space="preserve">
          <source>Combines two previously computed adler32 checksums. This computation requires the size of the data object for the second checksum to be known.</source>
          <target state="translated">合并之前计算的两个adler32校验和。这个计算需要知道第二个校验和的数据对象的大小。</target>
        </trans-unit>
        <trans-unit id="b5a84d5edd7f748866e54345659773ed891e4ac9" translate="yes" xml:space="preserve">
          <source>Combines two previously computed crc32 checksums. This computation requires the size of the data object for the second checksum to be known.</source>
          <target state="translated">合并之前计算的两个crc32校验和。这个计算需要知道第二个校验和的数据对象的大小。</target>
        </trans-unit>
        <trans-unit id="7c547b4f5559e9e848f6e074436dd454e9700281" translate="yes" xml:space="preserve">
          <source>Combining maps and filters enables writing of very succinct code. For example, to define a set difference function &lt;code&gt;diff(L1, L2)&lt;/code&gt; to be the difference between the lists &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt;, the code can be written as follows:</source>
          <target state="translated">结合使用地图和过滤器可以编写非常简洁的代码。例如，要将定义差异函数 &lt;code&gt;diff(L1, L2)&lt;/code&gt; 定义为列表 &lt;code&gt;L1&lt;/code&gt; 和 &lt;code&gt;L2&lt;/code&gt; 之间的差异，可以将代码编写如下：</target>
        </trans-unit>
        <trans-unit id="dbd234d5db623301ed626dbc5f5a4befa82d3bdc" translate="yes" xml:space="preserve">
          <source>Comma-separated string that determines which authentication methods that the client shall support and in which order they are tried. Defaults to &lt;code&gt;&quot;publickey,keyboard-interactive,password&quot;&lt;/code&gt;</source>
          <target state="translated">逗号分隔的字符串，用于确定客户端应支持的身份验证方法以及尝试使用的身份验证方法。默认为 &lt;code&gt;&quot;publickey,keyboard-interactive,password&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8901895fb1b1d4c4ea2fec368c25176bf73e2f7e" translate="yes" xml:space="preserve">
          <source>Command</source>
          <target state="translated">Command</target>
        </trans-unit>
        <trans-unit id="342da5a2f1813920c1bbfc4e852eea12f5063e4a" translate="yes" xml:space="preserve">
          <source>Command 1 sets variable &lt;code&gt;Str&lt;/code&gt; to string &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;.</source>
          <target state="translated">命令1将变量 &lt;code&gt;Str&lt;/code&gt; 设置为字符串 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd9251dc262d6cfde540ad0cd5c6d370876df98b" translate="yes" xml:space="preserve">
          <source>Command 10 prints the current value of &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">命令10打印 &lt;code&gt;L&lt;/code&gt; 的当前值。</target>
        </trans-unit>
        <trans-unit id="549199ae9bb6e901fc9258b242e067c754071753" translate="yes" xml:space="preserve">
          <source>Command 11 tries to match &lt;code&gt;{P, Q, R}&lt;/code&gt; against &lt;code&gt;Descriptor&lt;/code&gt;, which is &lt;code&gt;{4, abc}&lt;/code&gt;. The match fails and none of the new variables become bound. The printout starting with &quot;&lt;code&gt;** exception error:&lt;/code&gt;&quot; is not the value of the expression (the expression had no value because its evaluation failed), but a warning printed by the system to inform the user that an error has occurred. The values of the other variables (&lt;code&gt;L&lt;/code&gt;, &lt;code&gt;Str&lt;/code&gt;, and so on) are unchanged.</source>
          <target state="translated">命令11尝试匹配 &lt;code&gt;{P, Q, R}&lt;/code&gt; 对 &lt;code&gt;Descriptor&lt;/code&gt; ，其是 &lt;code&gt;{4, abc}&lt;/code&gt; 。匹配失败，没有新变量绑定。以&amp;ldquo; &lt;code&gt;** exception error:&lt;/code&gt; &amp;rdquo; 开头的打印输出不是表达式的值（该表达式没有值，因为其评估失败），而是系统打印的警告，通知用户发生了错误。其他变量（ &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;Str&lt;/code&gt; 等）的值保持不变。</target>
        </trans-unit>
        <trans-unit id="691b9bcaa6996c92d90bae097639c4314d240f78" translate="yes" xml:space="preserve">
          <source>Command 16 clears all bindings.</source>
          <target state="translated">命令16清除所有绑定。</target>
        </trans-unit>
        <trans-unit id="05c70d2234df4548b33a38e52389722995c34012" translate="yes" xml:space="preserve">
          <source>Command 19 evaluates &lt;code&gt;test1:demo(1)&lt;/code&gt;. The evaluation succeeds and the changes made in the process dictionary become visible to the shell. The new value of dictionary item &lt;code&gt;aa&lt;/code&gt; can be seen in command 20.</source>
          <target state="translated">命令19计算 &lt;code&gt;test1:demo(1)&lt;/code&gt; 。评估成功，并且过程字典中所做的更改对外壳可见。词典项目 &lt;code&gt;aa&lt;/code&gt; 的新值可以在命令20中看到。</target>
        </trans-unit>
        <trans-unit id="571320cb8183e22d95e0984d3435eed120eb8182" translate="yes" xml:space="preserve">
          <source>Command 2 sets &lt;code&gt;L&lt;/code&gt; to the length of string &lt;code&gt;Str&lt;/code&gt;.</source>
          <target state="translated">命令2将 &lt;code&gt;L&lt;/code&gt; 设置为字符串 &lt;code&gt;Str&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="b305cf69a5307579ebf549236a1a79deee898174" translate="yes" xml:space="preserve">
          <source>Command 3 builds the tuple &lt;code&gt;Descriptor&lt;/code&gt;, evaluating the BIF &lt;code&gt;list_to_atom/1 &lt;/code&gt;.</source>
          <target state="translated">命令3构建元组 &lt;code&gt;Descriptor&lt;/code&gt; ，评估BIF &lt;code&gt;list_to_atom/1 &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a5da20736f5aa69db276e3a85c9eb3bf4a9c347" translate="yes" xml:space="preserve">
          <source>Command 3 builds the tuple &lt;code&gt;Descriptor&lt;/code&gt;, evaluating the BIF &lt;code&gt;list_to_atom/1&lt;/code&gt;.</source>
          <target state="translated">命令3构建元组 &lt;code&gt;Descriptor&lt;/code&gt; ，评估BIF &lt;code&gt;list_to_atom/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51d00e3abf06e503663d94b19230b0cc26a72c2f" translate="yes" xml:space="preserve">
          <source>Command 33 prints the definition of the record named &lt;code&gt;rec&lt;/code&gt;.</source>
          <target state="translated">命令33打印名为 &lt;code&gt;rec&lt;/code&gt; 的记录的定义。</target>
        </trans-unit>
        <trans-unit id="45bc49c790b43237868293d2dd2e2edd61652121" translate="yes" xml:space="preserve">
          <source>Command 34 tries to create a &lt;code&gt;rec&lt;/code&gt; record, but fails as function &lt;code&gt;val/0&lt;/code&gt; is undefined.</source>
          <target state="translated">命令34尝试创建一个 &lt;code&gt;rec&lt;/code&gt; 记录，但是由于未定义函数 &lt;code&gt;val/0&lt;/code&gt; 而失败。</target>
        </trans-unit>
        <trans-unit id="72dcc67df9bbfa51a0492808644209d31bbd7f2f" translate="yes" xml:space="preserve">
          <source>Command 35 shows the workaround: explicitly assign values to record fields that cannot otherwise be initialized.</source>
          <target state="translated">命令35显示了变通的方法:显式地给本来不能初始化的记录字段赋值。</target>
        </trans-unit>
        <trans-unit id="fa2515e3e9587434ad52b14ccfc30883e7022dde" translate="yes" xml:space="preserve">
          <source>Command 36 prints the newly created record using record definitions maintained by the shell.</source>
          <target state="translated">命令36使用shell维护的记录定义打印新创建的记录。</target>
        </trans-unit>
        <trans-unit id="9154fd77dee8fff9e9758b70c934a42fa72f2fda" translate="yes" xml:space="preserve">
          <source>Command 37 defines a record directly in the shell. The definition replaces the one read from file &lt;code&gt;ex.beam&lt;/code&gt;.</source>
          <target state="translated">命令37直接在外壳中定义一条记录。该定义将替换从文件 &lt;code&gt;ex.beam&lt;/code&gt; 中读取的内容。</target>
        </trans-unit>
        <trans-unit id="1f8eb1cd9b3187f9b754c49fd8314986efc7792e" translate="yes" xml:space="preserve">
          <source>Command 38 creates a record using the new definition, and prints the result.</source>
          <target state="translated">命令38使用新定义创建一条记录,并打印结果。</target>
        </trans-unit>
        <trans-unit id="505fd82812bb30eb7dc21bc2b04f27b3d82e3401" translate="yes" xml:space="preserve">
          <source>Command 39 and 40 show that record definitions are updated as side effects. The evaluation of the command fails, but the definition of &lt;code&gt;rec&lt;/code&gt; has been carried out.</source>
          <target state="translated">命令39和40显示记录定义已更新为副作用。该命令的评估失败，但是已执行 &lt;code&gt;rec&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="c942ae59ce728287fe12cdbf8492f720f289065f" translate="yes" xml:space="preserve">
          <source>Command 4 prints the value of variable &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">命令4打印变量 &lt;code&gt;L&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e7d5c11f36c6ad9e416101362d83e867e199c699" translate="yes" xml:space="preserve">
          <source>Command 41 evaluates &lt;code&gt;test1:loop(0)&lt;/code&gt;, which puts the system into an infinite loop. At this point the user types &lt;code&gt;^G&lt;/code&gt; (Control G), which suspends output from the current process, which is stuck in a loop, and activates &lt;code&gt;JCL&lt;/code&gt; mode. In &lt;code&gt;JCL&lt;/code&gt; mode the user can start and stop jobs.</source>
          <target state="translated">命令41计算 &lt;code&gt;test1:loop(0)&lt;/code&gt; ，这会将系统置于无限循环中。此时，用户键入 &lt;code&gt;^G&lt;/code&gt; （控件G），这将暂停当前进程的输出，该进程陷入循环，并激活 &lt;code&gt;JCL&lt;/code&gt; 模式。在 &lt;code&gt;JCL&lt;/code&gt; 模式下，用户可以启动和停止作业。</target>
        </trans-unit>
        <trans-unit id="027e48c60bf06fa02b13ef5f87c61d9d7dbea65c" translate="yes" xml:space="preserve">
          <source>Command 42 creates an ETS table.</source>
          <target state="translated">命令42创建一个ETS表。</target>
        </trans-unit>
        <trans-unit id="bb7e5f60b5a386b27383613df99699547215a065" translate="yes" xml:space="preserve">
          <source>Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The exception kills the evaluator process.</source>
          <target state="translated">命令43试图将一个元组插入到ETS表中,但第一个参数(表)不见了。异常情况下,评价器进程停止。</target>
        </trans-unit>
        <trans-unit id="13e1680dee0b31442dfcf7d8dd715d5303935741" translate="yes" xml:space="preserve">
          <source>Command 44 corrects the mistake, but the ETS table has been destroyed as it was owned by the killed evaluator process.</source>
          <target state="translated">命令44纠正了错误,但ETS表已经被销毁,因为它是被杀死的评价器进程所拥有的。</target>
        </trans-unit>
        <trans-unit id="249b0132245dd6a948f325230d14fb2abcebf877" translate="yes" xml:space="preserve">
          <source>Command 46 sets the exception handling of the evaluator process to &lt;code&gt;true&lt;/code&gt;. The exception handling can also be set when starting Erlang by &lt;code&gt;erl -stdlib shell_catch_exception true&lt;/code&gt;.</source>
          <target state="translated">命令46将评估程序的异常处理设置为 &lt;code&gt;true&lt;/code&gt; 。在启动Erlang时，也可以通过 &lt;code&gt;erl -stdlib shell_catch_exception true&lt;/code&gt; 设置异常处理。</target>
        </trans-unit>
        <trans-unit id="0109c9c2951329001d2c921ef35da35fce643d09" translate="yes" xml:space="preserve">
          <source>Command 48 makes the same mistake as in command 43, but this time the evaluator process lives on. The single star at the beginning of the printout signals that the exception has been caught.</source>
          <target state="translated">命令48犯了与命令43相同的错误,但这次评估器进程继续运行。打印输出开头的单星标志着异常已经被捕获。</target>
        </trans-unit>
        <trans-unit id="89ddd1b26e2c81d79a061e40a387cb68327ed7e7" translate="yes" xml:space="preserve">
          <source>Command 49 successfully inserts the tuple into the ETS table.</source>
          <target state="translated">命令49成功地将元组插入到ETS表中。</target>
        </trans-unit>
        <trans-unit id="21e9b8de7612160c8ff6fb2d218d6871c257d22f" translate="yes" xml:space="preserve">
          <source>Command 5 evaluates the internal shell command &lt;code&gt;b()&lt;/code&gt;, which is an abbreviation of &quot;bindings&quot;. This prints the current shell variables and their bindings. &lt;code&gt;ok&lt;/code&gt; at the end is the return value of function &lt;code&gt;b()&lt;/code&gt;.</source>
          <target state="translated">命令5计算内部shell命令 &lt;code&gt;b()&lt;/code&gt; ，它是&amp;ldquo; bindings&amp;rdquo;的缩写。这将打印当前的shell变量及其绑定。 &lt;code&gt;ok&lt;/code&gt; 是函数 &lt;code&gt;b()&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="b87908b907dbfdaf4cc2680aaedac60ec072bdb0" translate="yes" xml:space="preserve">
          <source>Command 50 inserts another tuple into the ETS table. This time the first argument is the table identifier itself. The shell can parse commands with pids (&lt;code&gt;&amp;lt;0.60.0&amp;gt;&lt;/code&gt;), ports (&lt;code&gt;#Port&amp;lt;0.536&amp;gt;&lt;/code&gt;), references (&lt;code&gt;#Ref&amp;lt;0.1662103692.2407792644.214210&amp;gt;&lt;/code&gt;), and external functions (&lt;code&gt;#Fun&amp;lt;a.b.1&amp;gt;&lt;/code&gt;), but the command fails unless the corresponding pid, port, reference, or function can be created in the running system.</source>
          <target state="translated">命令50将另一个元组插入ETS表。这次，第一个参数是表标识符本身。Shell可以使用pid（ &lt;code&gt;&amp;lt;0.60.0&amp;gt;&lt;/code&gt; ），端口（ &lt;code&gt;#Port&amp;lt;0.536&amp;gt;&lt;/code&gt; ），引用（ &lt;code&gt;#Ref&amp;lt;0.1662103692.2407792644.214210&amp;gt;&lt;/code&gt; ）和外部函数（ &lt;code&gt;#Fun&amp;lt;a.b.1&amp;gt;&lt;/code&gt; ）解析命令，但是命令失败除非可以在运行的系统中创建相应的pid，端口，引用或函数。</target>
        </trans-unit>
        <trans-unit id="ef6bff45f7d38fc1ad0f06951a1076b939b05b98" translate="yes" xml:space="preserve">
          <source>Command 51 exits the Erlang runtime system.</source>
          <target state="translated">命令51退出Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="4a47187be4d245fbaca39a02661c9beb2fb74371" translate="yes" xml:space="preserve">
          <source>Command 6 evaluates the internal shell command &lt;code&gt;f(L)&lt;/code&gt; (abbreviation of &quot;forget&quot;). The value of variable &lt;code&gt;L&lt;/code&gt; is removed.</source>
          <target state="translated">命令6计算内部外壳程序命令 &lt;code&gt;f(L)&lt;/code&gt; （&amp;ldquo; forget&amp;rdquo;的缩写）。变量 &lt;code&gt;L&lt;/code&gt; 的值被删除。</target>
        </trans-unit>
        <trans-unit id="e30b7179ba181a3b5c6b762ceede630731c07eb2" translate="yes" xml:space="preserve">
          <source>Command 7 prints the new bindings.</source>
          <target state="translated">命令7打印新的绑定。</target>
        </trans-unit>
        <trans-unit id="5eb872b4d589d1c1c6adf7d4262edec9d05d3813" translate="yes" xml:space="preserve">
          <source>Command 8 has no effect, as &lt;code&gt;L&lt;/code&gt; has no value.</source>
          <target state="translated">命令8没有效果，因为 &lt;code&gt;L&lt;/code&gt; 没有值。</target>
        </trans-unit>
        <trans-unit id="da435e51bb957a0dcba4d9de8dece9444557cd34" translate="yes" xml:space="preserve">
          <source>Command 9 performs a pattern matching operation on &lt;code&gt;Descriptor&lt;/code&gt;, binding a new value to &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">命令9点进行上的图案匹配操作 &lt;code&gt;Descriptor&lt;/code&gt; ，结合一个新值 &lt;code&gt;L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4da205fa9e33785888d3b45cf6c93fdfda35424f" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;epmd -stop&lt;/code&gt; (and the corresponding messages to &lt;code&gt;epmd&lt;/code&gt;, as can be specified using &lt;code&gt;erl_interface:ei(3)&lt;/code&gt;) is normally always ignored. This because it can cause a strange situation where two nodes of the same name can be alive at the same time. A node unregisters itself by only closing the connection to &lt;code&gt;epmd&lt;/code&gt;, which is why command &lt;code&gt;stop&lt;/code&gt; was only intended for use in debugging situations.</source>
          <target state="translated">通常总是忽略命令 &lt;code&gt;epmd -stop&lt;/code&gt; （以及到 &lt;code&gt;epmd&lt;/code&gt; 的相应消息，可以使用 &lt;code&gt;erl_interface:ei(3)&lt;/code&gt; 进行指定）。这是因为这可能导致奇怪的情况，其中两个相同名称的节点可以同时处于活动状态。节点仅通过关闭与 &lt;code&gt;epmd&lt;/code&gt; 的连接来注销自身，这就是为什么命令 &lt;code&gt;stop&lt;/code&gt; 仅用于调试情况的原因。</target>
        </trans-unit>
        <trans-unit id="810d0b44379ad61dcf659535b75db6d8cc44230a" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;erl -boot Name&lt;/code&gt; starts the system with a boot file called &lt;code&gt;Name.boot&lt;/code&gt;, which is generated from the &lt;code&gt;Name.script&lt;/code&gt; file, using &lt;code&gt;&lt;a href=&quot;systools#script2boot-1&quot;&gt;systools:script2boot/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">命令 &lt;code&gt;erl -boot Name&lt;/code&gt; 使用名为 &lt;code&gt;Name.boot&lt;/code&gt; 的引导文件启动系统，该引导文件是使用 &lt;code&gt;&lt;a href=&quot;systools#script2boot-1&quot;&gt;systools:script2boot/1&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;Name.script&lt;/code&gt; 文件生成的。</target>
        </trans-unit>
        <trans-unit id="39de423c03daee2f71651de9ffea305f36be9120" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;ttb:tracer(dbg)&lt;/code&gt; is a shortcut for the pure &lt;code&gt;dbg&lt;/code&gt; mode (&lt;code&gt;{shell, only}&lt;/code&gt;).</source>
          <target state="translated">命令 &lt;code&gt;ttb:tracer(dbg)&lt;/code&gt; 是纯 &lt;code&gt;dbg&lt;/code&gt; 模式（ &lt;code&gt;{shell, only}&lt;/code&gt; ）的快捷方式。</target>
        </trans-unit>
        <trans-unit id="c555f15dcf6bb7adaf5f9b063efb4b7e7e6e2ea1" translate="yes" xml:space="preserve">
          <source>Command Code Format Specification</source>
          <target state="translated">命令码格式规范</target>
        </trans-unit>
        <trans-unit id="41fea0af8135b09c720af76c92576ba1ce8cab06" translate="yes" xml:space="preserve">
          <source>Command Codes</source>
          <target state="translated">命令代码</target>
        </trans-unit>
        <trans-unit id="44cece384081cdaf653289bf8b1abbd517cb270c" translate="yes" xml:space="preserve">
          <source>Command Flags</source>
          <target state="translated">命令标志</target>
        </trans-unit>
        <trans-unit id="fcf4ea77789a76f9d1ec8ed42f1e7a3d9fea92e5" translate="yes" xml:space="preserve">
          <source>Command Summary</source>
          <target state="translated">命令摘要</target>
        </trans-unit>
        <trans-unit id="f4262805dee42a91c3420fb0de8038f14ed1851c" translate="yes" xml:space="preserve">
          <source>Command interface</source>
          <target state="translated">命令界面</target>
        </trans-unit>
        <trans-unit id="0ba4d2337dce485f24bbc063f5690cdcfc4ac079" translate="yes" xml:space="preserve">
          <source>Command interface module.</source>
          <target state="translated">命令接口模块。</target>
        </trans-unit>
        <trans-unit id="e659d2d4c58b502e091a664b53727f4cb778e670" translate="yes" xml:space="preserve">
          <source>Command timeout (time to wait for a command to return) = 10 seconds</source>
          <target state="translated">命令超时(等待命令返回的时间)=10秒。</target>
        </trans-unit>
        <trans-unit id="3e767b383c6d82a7de3a36422b75eb6ce8c0967f" translate="yes" xml:space="preserve">
          <source>Command-Line Flags</source>
          <target state="translated">命令行标志</target>
        </trans-unit>
        <trans-unit id="b276b756560f04ce3d0917009cdbe122769b89ec" translate="yes" xml:space="preserve">
          <source>Command-line arguments &lt;code&gt;-App Par Val&lt;/code&gt;</source>
          <target state="translated">命令行参数 &lt;code&gt;-App Par Val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c738a0bbafd852c8a585fb1f2ac29479f5b2dc37" translate="yes" xml:space="preserve">
          <source>Command-line arguments are read from the file &lt;code&gt;FileName&lt;/code&gt;. The arguments read from the file replace flag '&lt;code&gt;-args_file FileName&lt;/code&gt;' on the resulting command line.</source>
          <target state="translated">从文件 &lt;code&gt;FileName&lt;/code&gt; 中读取命令行参数。从文件替换标志' &lt;code&gt;-args_file FileName&lt;/code&gt; ' 读取的参数在结果命令行上。</target>
        </trans-unit>
        <trans-unit id="0815c6d95bf87f31b25e345653bfa997429b0e96" translate="yes" xml:space="preserve">
          <source>Command-line flag &lt;code&gt;-code_path_choice Choice&lt;/code&gt; also affects how module &lt;code&gt;init&lt;/code&gt; interprets the &lt;code&gt;boot script&lt;/code&gt;. The interpretation of the explicit code paths in the &lt;code&gt;boot script&lt;/code&gt; can be &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It is particularly useful to set the flag to &lt;code&gt;relaxed&lt;/code&gt; when elaborating with code loading from archives without editing the &lt;code&gt;boot script&lt;/code&gt;. The default is &lt;code&gt;relaxed&lt;/code&gt;. See &lt;code&gt;erts:init(3)&lt;/code&gt;.</source>
          <target state="translated">命令行标志 &lt;code&gt;-code_path_choice Choice&lt;/code&gt; 也会影响模块 &lt;code&gt;init&lt;/code&gt; 如何解释 &lt;code&gt;boot script&lt;/code&gt; 。明确的代码路径中的解释 &lt;code&gt;boot script&lt;/code&gt; 可以 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;relaxed&lt;/code&gt; 。在详细说明从归档文件加载代码而无需编辑 &lt;code&gt;boot script&lt;/code&gt; 时，将标志设置为 &lt;code&gt;relaxed&lt;/code&gt; 特别有用。默认为 &lt;code&gt;relaxed&lt;/code&gt; 。参见 &lt;code&gt;erts:init(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e6b935146c98f3aa1d4c9b71666cb047822e2b6" translate="yes" xml:space="preserve">
          <source>Command-line flag &lt;code&gt;-loader Loader&lt;/code&gt; can be used to choose the method used by &lt;code&gt;erl_prim_loader&lt;/code&gt;. Two &lt;code&gt;Loader&lt;/code&gt; methods are supported by the Erlang runtime system: &lt;code&gt;efile&lt;/code&gt; and &lt;code&gt;inet&lt;/code&gt;.</source>
          <target state="translated">命令行标志 &lt;code&gt;-loader Loader&lt;/code&gt; 可以用来选择所使用的方法 &lt;code&gt;erl_prim_loader&lt;/code&gt; 。Erlang运行时系统支持两种 &lt;code&gt;Loader&lt;/code&gt; 方法： &lt;code&gt;efile&lt;/code&gt; 和 &lt;code&gt;inet&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ab3f6695abd2d1efac509f3805ab65802f6cd0" translate="yes" xml:space="preserve">
          <source>Commands 12 and 13 show that &lt;code&gt;P&lt;/code&gt; is unbound because the previous command failed, and that &lt;code&gt;Descriptor&lt;/code&gt; has not changed.</source>
          <target state="translated">命令12和13显示 &lt;code&gt;P&lt;/code&gt; 未绑定，因为前一条命令失败，并且 &lt;code&gt;Descriptor&lt;/code&gt; 未更改。</target>
        </trans-unit>
        <trans-unit id="0808717ab8537267fc0acf980e9bc7e73f8a3115" translate="yes" xml:space="preserve">
          <source>Commands 14 and 15 show a correct match where &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are bound.</source>
          <target state="translated">命令14和15显示正确的匹配，其中 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 绑定在一起。</target>
        </trans-unit>
        <trans-unit id="ba40d80207918719cb767da4bd28be6e2206b511" translate="yes" xml:space="preserve">
          <source>Commands 17 and 18 set and inspect the value of item &lt;code&gt;aa&lt;/code&gt; in the process dictionary.</source>
          <target state="translated">命令17和18设置并检查过程词典中项 &lt;code&gt;aa&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="294bcd96ab5ae5465ab190eddd23f0db5bdd9eb1" translate="yes" xml:space="preserve">
          <source>Commands 21 and 22 change the value of dictionary item &lt;code&gt;aa&lt;/code&gt; to &lt;code&gt;hello&lt;/code&gt; and call &lt;code&gt;test1:demo(2)&lt;/code&gt;. Evaluation fails and the changes made to the dictionary in &lt;code&gt;test1:demo(2)&lt;/code&gt;, before the error occurred, are discarded.</source>
          <target state="translated">命令21和22将字典项 &lt;code&gt;aa&lt;/code&gt; 的值更改为 &lt;code&gt;hello&lt;/code&gt; 并调用 &lt;code&gt;test1:demo(2)&lt;/code&gt; 。评估失败，并且错误发生之前对 &lt;code&gt;test1:demo(2)&lt;/code&gt; 中的字典所做的更改将被丢弃。</target>
        </trans-unit>
        <trans-unit id="92740ec7f4a6db2c5a8fde98073bc5eafb9b184e" translate="yes" xml:space="preserve">
          <source>Commands 23 and 24 show that &lt;code&gt;Z&lt;/code&gt; was not bound and that dictionary item &lt;code&gt;aa&lt;/code&gt; has retained its original value.</source>
          <target state="translated">命令23和24显示 &lt;code&gt;Z&lt;/code&gt; 未绑定，并且字典项 &lt;code&gt;aa&lt;/code&gt; 保留了其原始值。</target>
        </trans-unit>
        <trans-unit id="b56b527b4c21ea0ffd3d260fc661f80779b628fe" translate="yes" xml:space="preserve">
          <source>Commands 25, 26, and 27 show the effect of evaluating &lt;code&gt;test1:demo(1)&lt;/code&gt; in the background. In this case, the expression is evaluated in a newly spawned process. Any changes made in the process dictionary are local to the newly spawned process and therefore not visible to the shell.</source>
          <target state="translated">命令25、26和27显示了在后台评估 &lt;code&gt;test1:demo(1)&lt;/code&gt; 的效果。在这种情况下，将在新生成的过程中对表达式求值。在流程字典中所做的任何更改对于新产生的流程而言是本地的，因此对于Shell不可见。</target>
        </trans-unit>
        <trans-unit id="fbb8fbc989037cd45a07764908684c0276b72d77" translate="yes" xml:space="preserve">
          <source>Commands 28, 29 and 30 use the history facilities of the shell. Command 29 re-evaluates command 28. Command 30 uses the value (result) of command 28. In the cases of a pure function (a function with no side effects), the result is the same. For a function with side effects, the result can be different.</source>
          <target state="translated">命令28、29和30使用shell的历史记录功能。命令29重新评估命令28。命令30使用命令28的值(结果)。在纯函数(没有副作用的函数)的情况下,结果是一样的。对于一个有副作用的函数,其结果可能不同。</target>
        </trans-unit>
        <trans-unit id="6bd98506526970354b254ba19f4b457ffe78c8b5" translate="yes" xml:space="preserve">
          <source>Commands 31 and 32 compile file &lt;code&gt;ex.erl&lt;/code&gt; and read the record definitions in &lt;code&gt;ex.beam&lt;/code&gt;. If the compiler did not output any record definitions on the BEAM file, &lt;code&gt;rr(ex)&lt;/code&gt; tries to read record definitions from the source file instead.</source>
          <target state="translated">命令31和32的编译文件 &lt;code&gt;ex.erl&lt;/code&gt; 并阅读记录定义 &lt;code&gt;ex.beam&lt;/code&gt; 。如果编译器未在BEAM文件上输出任何记录定义，则 &lt;code&gt;rr(ex)&lt;/code&gt; 尝试改为从源文件读取记录定义。</target>
        </trans-unit>
        <trans-unit id="22230fce6738635959fe1cc4ea2c847698c33886" translate="yes" xml:space="preserve">
          <source>Commands are defined as CCF specifications in dictionary files.</source>
          <target state="translated">命令在字典文件中被定义为CCF规范。</target>
        </trans-unit>
        <trans-unit id="56e84290b5e3388fcdfc58e1d2baa8a6fd8e4461" translate="yes" xml:space="preserve">
          <source>Comments are embedded in the following example:</source>
          <target state="translated">下面的例子中嵌入了评论。</target>
        </trans-unit>
        <trans-unit id="8ef3de97bdba18fc781a05004ec85c394079388d" translate="yes" xml:space="preserve">
          <source>Comments can be included in a dictionary file using semicolon: characters from a semicolon to end of line are ignored.</source>
          <target state="translated">注释可以使用分号包含在字典文件中:从分号到行末的字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="26288d5796241c87a8f3348937c33f8c190beec7" translate="yes" xml:space="preserve">
          <source>Comments can be placed anywhere in a module except within strings and quoted atoms. A comment begins with the character &quot;%&quot;, continues up to, but does not include the next end-of-line, and has no effect. Notice that the terminating end-of-line has the effect of white space.</source>
          <target state="translated">除了字符串和引号原子之外,注释可以放在模块中的任何地方。注释以字符&quot;%&quot;开始,一直到但不包括下一行结束,并且没有效果。请注意,行尾有留白的效果。</target>
        </trans-unit>
        <trans-unit id="5d789847a2caf02c727ca7174b8c42d0924876dc" translate="yes" xml:space="preserve">
          <source>Comments for individual files are not supported when creating zip archives. The zip archive comment for the whole zip archive is supported.</source>
          <target state="translated">创建压缩包时,不支持对单个文件的注释。支持对整个压缩包的注释。</target>
        </trans-unit>
        <trans-unit id="8b3a62c8e579699ba00397d2c80ef8144243fbdd" translate="yes" xml:space="preserve">
          <source>Comments on the code:</source>
          <target state="translated">对守则的评论。</target>
        </trans-unit>
        <trans-unit id="da35acebd529266c273972c7b3c68d5c1a9be9ff" translate="yes" xml:space="preserve">
          <source>Commit all staged breadpoints by switching &lt;code&gt;erts_active_bp_index&lt;/code&gt;.</source>
          <target state="translated">通过切换 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 提交所有暂存的面包点。</target>
        </trans-unit>
        <trans-unit id="b35af8f67f1302434542fab82b17be91dbc51450" translate="yes" xml:space="preserve">
          <source>Commit the breadpoint by switching &lt;code&gt;erts_active_bp_index&lt;/code&gt;.</source>
          <target state="translated">通过切换 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 来提交面包点。</target>
        </trans-unit>
        <trans-unit id="17bde591b45f1956739cdae90f230bf60f533d89" translate="yes" xml:space="preserve">
          <source>Commits or rollbacks a transaction. Needed on connections where automatic commit is turned off.</source>
          <target state="translated">提交或回滚一个事务。需要在关闭了自动提交的连接上使用。</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="241df9920cfb933c5f225205b64b534fff5b5501" translate="yes" xml:space="preserve">
          <source>Common Data Types</source>
          <target state="translated">常见数据类型</target>
        </trans-unit>
        <trans-unit id="41d21606dcebe663d602a1344de2a8fca02f49a9" translate="yes" xml:space="preserve">
          <source>Common Derived AVP Data Formats</source>
          <target state="translated">常见的衍生AVP数据格式</target>
        </trans-unit>
        <trans-unit id="0b5334f1456ad098a790e7f352286314bbed47a2" translate="yes" xml:space="preserve">
          <source>Common Gateway Interface (CGI)</source>
          <target state="translated">通用网关接口(CGI)</target>
        </trans-unit>
        <trans-unit id="db485912bf25572661767ebba87897fc877dcd95" translate="yes" xml:space="preserve">
          <source>Common Gateway Interface (CGI) scripts can be written in any programming language. CGI scripts are standardized and supported by most web servers. The drawback with CGI scripts is that they are resource-intensive because of their design. CGI requires the server to fork a new OS process for each executable it needs to start.</source>
          <target state="translated">通用网关接口(CGI)脚本可以用任何编程语言编写。CGI脚本是标准化的,大多数网络服务器都支持。CGI脚本的缺点是,由于其设计,它们是资源密集型的。CGI要求服务器为每一个需要启动的可执行文件分叉一个新的操作系统进程。</target>
        </trans-unit>
        <trans-unit id="19ab22d81ec0ae9cb58d33a88861ce6ef1708b24" translate="yes" xml:space="preserve">
          <source>Common Logfile Format (with or without disk_log(3) support)</source>
          <target state="translated">常见的日志文件格式(支持或不支持disk_log(3))。</target>
        </trans-unit>
        <trans-unit id="4ce20004c1f29ec0692407ac2b38ca6bf8d31367" translate="yes" xml:space="preserve">
          <source>Common Records and ASN.1 Types</source>
          <target state="translated">常见记录和ASN.1类型</target>
        </trans-unit>
        <trans-unit id="6308629ddea5ddb4f6206238004dacdb96f8740d" translate="yes" xml:space="preserve">
          <source>Common Test framework code coverage support module.</source>
          <target state="translated">通用测试框架代码覆盖支持模块。</target>
        </trans-unit>
        <trans-unit id="1e2caf325721b603d0dd5b17a62280a7ef4be10c" translate="yes" xml:space="preserve">
          <source>Common Test framework functions for starting and stopping nodes for Large-Scale Testing.</source>
          <target state="translated">常见的测试框架功能,用于启动和停止大规模测试的节点。</target>
        </trans-unit>
        <trans-unit id="30f1b95bb6a879de9c40633f0536016402c329c6" translate="yes" xml:space="preserve">
          <source>Common Test prints the text from &lt;code&gt;ct:log/3,4,5&lt;/code&gt; or &lt;code&gt;ct:pal/3,4,5&lt;/code&gt; inside a &lt;code&gt;pre&lt;/code&gt; element nested under the named &lt;code&gt;div&lt;/code&gt; element. Since the &lt;code&gt;pre&lt;/code&gt; selector has a predefined CSS rule (in file &lt;code&gt;ct_default.css&lt;/code&gt;) for the attributes &lt;code&gt;color&lt;/code&gt;, &lt;code&gt;font-family&lt;/code&gt; and &lt;code&gt;font-size&lt;/code&gt;, if a user wants to change any of the predefined attribute settings, a new rule for &lt;code&gt;pre&lt;/code&gt; must be added to the user stylesheet. Example:</source>
          <target state="translated">Common Test在嵌套在命名 &lt;code&gt;div&lt;/code&gt; 元素下的 &lt;code&gt;pre&lt;/code&gt; 元素内打印 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 或 &lt;code&gt;ct:pal/3,4,5&lt;/code&gt; 中的文本。由于 &lt;code&gt;pre&lt;/code&gt; 选择器具有针对属性 &lt;code&gt;color&lt;/code&gt; ， &lt;code&gt;font-family&lt;/code&gt; 和 &lt;code&gt;font-size&lt;/code&gt; 的预定义CSS规则（在文件 &lt;code&gt;ct_default.css&lt;/code&gt; 中），如果用户要更改任何预定义的属性设置，则必须为 &lt;code&gt;pre&lt;/code&gt; 添加新规则到用户样式表。例：</target>
        </trans-unit>
        <trans-unit id="c04acbea30ab701b6c1687bc2c2baef0bc8d8ac3" translate="yes" xml:space="preserve">
          <source>Common Test specific layer on Erlang/OTP rpc.</source>
          <target state="translated">Erlang/OTP rpc上常见的测试专用层。</target>
        </trans-unit>
        <trans-unit id="6200c508ceec372ce5e6d3dd908d4e9056a88ece" translate="yes" xml:space="preserve">
          <source>Common Test specific layer on top of Telnet client ct_telnet_client.erl</source>
          <target state="translated">Telnet客户端之上的普通测试专用层ct_telnet_client.err。</target>
        </trans-unit>
        <trans-unit id="795765c3a6937dd14e3f9e84bbc1516b51d98f84" translate="yes" xml:space="preserve">
          <source>Common Test user interface module for the SNMP application.</source>
          <target state="translated">SNMP应用的通用测试用户界面模块。</target>
        </trans-unit>
        <trans-unit id="c915caf0b5cf6faff380a7f8100663b681679e13" translate="yes" xml:space="preserve">
          <source>Common Test will escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in printouts to the log file made with &lt;code&gt;ct:pal/4&lt;/code&gt; and &lt;code&gt;io:format/2&lt;/code&gt;. In order to print strings with HTML tags to the log, use the &lt;code&gt;ct:log/3,4,5&lt;/code&gt; function. The character escaping feature is per default disabled for &lt;code&gt;ct:log/3,4,5&lt;/code&gt; but can be enabled with the &lt;code&gt;esc_chars&lt;/code&gt; option in the &lt;code&gt;Opts&lt;/code&gt; list, see &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt; ct:log/3,4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Common Test将在打印输出中将特殊的HTML字符（&amp;lt;，&amp;gt;和＆）转义到由 &lt;code&gt;ct:pal/4&lt;/code&gt; 和 &lt;code&gt;io:format/2&lt;/code&gt; 制成的日志文件中。为了将带有HTML标记的字符串打印到日志，请使用 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 函数。该字符转义功能是默认每对禁用 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; ，但可以与启用 &lt;code&gt;esc_chars&lt;/code&gt; 在选项 &lt;code&gt;Opts&lt;/code&gt; 列表，请参阅 &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt; ct:log/3,4,5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4750bbba9bfe2efefedd87368239bf3b9742e5f4" translate="yes" xml:space="preserve">
          <source>Common Test will escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in printouts to the log file made with &lt;code&gt;ct:pal/4&lt;/code&gt; and &lt;code&gt;io:format/2&lt;/code&gt;. In order to print strings with HTML tags to the log, use the &lt;code&gt;ct:log/3,4,5&lt;/code&gt; function. The character escaping feature is per default disabled for &lt;code&gt;ct:log/3,4,5&lt;/code&gt; but can be enabled with the &lt;code&gt;esc_chars&lt;/code&gt; option in the &lt;code&gt;Opts&lt;/code&gt; list, see &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt;ct:log/3,4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Common Test将在打印输出中将特殊的HTML字符（&amp;lt;，&amp;gt;和＆）转义到由 &lt;code&gt;ct:pal/4&lt;/code&gt; 和 &lt;code&gt;io:format/2&lt;/code&gt; 制成的日志文件中。为了将带有HTML标记的字符串打印到日志，请使用 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; 函数。该字符转义功能是默认每对禁用 &lt;code&gt;ct:log/3,4,5&lt;/code&gt; ，但可以与启用 &lt;code&gt;esc_chars&lt;/code&gt; 在选项 &lt;code&gt;Opts&lt;/code&gt; 列表，请参阅 &lt;code&gt;&lt;a href=&quot;ct#log-5&quot;&gt;ct:log/3,4,5&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acedb2a295655cedf03a6d64f7a4770f00468a7c" translate="yes" xml:space="preserve">
          <source>Common Test will not escape special HTML characters (&amp;lt;, &amp;gt; and &amp;amp;) in the text printed with this function, unless the &lt;code&gt;esc_chars&lt;/code&gt; option is used.</source>
          <target state="translated">除非使用 &lt;code&gt;esc_chars&lt;/code&gt; 选项，否则Common Test将不会在使用此功能打印的文本中转义特殊的HTML字符（&amp;lt;，&amp;gt;和＆）。</target>
        </trans-unit>
        <trans-unit id="dadf2071e7b21987ca0708b9d6985520d78f3217" translate="yes" xml:space="preserve">
          <source>Common config types:</source>
          <target state="translated">常见的配置类型。</target>
        </trans-unit>
        <trans-unit id="ac09f939510f1230449f2487860d2c31044efcc5" translate="yes" xml:space="preserve">
          <source>Common data types</source>
          <target state="translated">常见数据类型</target>
        </trans-unit>
        <trans-unit id="d94691a074c7593f911e3dc52f3f8f13032dc40a" translate="yes" xml:space="preserve">
          <source>Common non-standard Erlang data types used to describe the record fields in the following sections and which are not defined in the Public Key &lt;code&gt;&lt;a href=&quot;public_key&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; follows here:</source>
          <target state="translated">以下是用于描述以下各节中记录字段的常见非标准Erlang数据类型，并且未在《公共密钥 &lt;code&gt;&lt;a href=&quot;public_key&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 定义：</target>
        </trans-unit>
        <trans-unit id="8c0f63b574b67c6705b08577c533549ceb705554" translate="yes" xml:space="preserve">
          <source>Communicate with distributed Erlang.</source>
          <target state="translated">与分布式Erlang沟通。</target>
        </trans-unit>
        <trans-unit id="bd72983883a714962b7215d3a3f5aee15e422d63" translate="yes" xml:space="preserve">
          <source>Communicates with a running port mapper daemon.</source>
          <target state="translated">与正在运行的端口映射程序守护进程进行通信。</target>
        </trans-unit>
        <trans-unit id="70cdbfe70a51bbd63ce1591394b2d32e526d83f8" translate="yes" xml:space="preserve">
          <source>Communicating with the running &lt;code&gt;epmd&lt;/code&gt; daemon by the &lt;code&gt;epmd&lt;/code&gt; program is done primarily for debugging purposes.</source>
          <target state="translated">与正在运行的通信 &lt;code&gt;epmd&lt;/code&gt; 由守护 &lt;code&gt;epmd&lt;/code&gt; 程序调试目的主要完成。</target>
        </trans-unit>
        <trans-unit id="62b1109168a638234d95928543c75a350159ad8e" translate="yes" xml:space="preserve">
          <source>Communication between C nodes and Erlang processes</source>
          <target state="translated">C节点和Erlang进程之间的通信</target>
        </trans-unit>
        <trans-unit id="210328a62ba74dfc81e096c28bc1dd2f82995f3e" translate="yes" xml:space="preserve">
          <source>Communication in Erlang is conceptually performed using asynchronous signaling. All different executing entities, such as processes and ports, communicate through asynchronous signals. The most commonly used signal is a message. Other common signals are exit, link, unlink, monitor, and demonitor signals.</source>
          <target state="translated">Erlang中的通信在概念上是使用异步信号进行的。所有不同的执行实体,如进程和端口,都通过异步信号进行通信。最常用的信号是消息。其他常见的信号有退出、链接、解除链接、监控和demonitor信号。</target>
        </trans-unit>
        <trans-unit id="4183b090fb1af0688c00077a895de35dc21295ae" translate="yes" xml:space="preserve">
          <source>Communication utility functions to be used by the Erlang web server API programmer.</source>
          <target state="translated">Erlang web服务器API程序员要使用的通信实用功能。</target>
        </trans-unit>
        <trans-unit id="80afd53213b9e40ec5102490cac90c9e596e23ff" translate="yes" xml:space="preserve">
          <source>Communication with sockets</source>
          <target state="translated">与插座的通信</target>
        </trans-unit>
        <trans-unit id="82de2dfc6db5d20f900f698ba6e19de7560c30d1" translate="yes" xml:space="preserve">
          <source>Compare the severity of two log levels. Returns &lt;code&gt;gt&lt;/code&gt; if &lt;code&gt;Level1&lt;/code&gt; is more severe than &lt;code&gt;Level2&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; if &lt;code&gt;Level1&lt;/code&gt; is less severe, and &lt;code&gt;eq&lt;/code&gt; if the levels are equal.</source>
          <target state="translated">比较两个日志级别的严重性。如果 &lt;code&gt;Level1&lt;/code&gt; 比 &lt;code&gt;Level2&lt;/code&gt; 更严重，则返回 &lt;code&gt;gt&lt;/code&gt; ;如果Level1较不严重，则返回 &lt;code&gt;lt&lt;/code&gt; ;如果 &lt;code&gt;Level1&lt;/code&gt; 相等，则返回 &lt;code&gt;eq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4829635ff8b264cec3be490a754062e423a0438" translate="yes" xml:space="preserve">
          <source>Compare two port identifiers. The comparison is done the same way as Erlang does.</source>
          <target state="translated">比较两个端口标识符。比较的方式与 Erlang 相同。</target>
        </trans-unit>
        <trans-unit id="dc33d4612f53d09e85f3f59e9a2fb150d86afb5d" translate="yes" xml:space="preserve">
          <source>Compare two process identifiers. The comparison is done the same way as Erlang does.</source>
          <target state="translated">比较两个进程标识符。比较的方式和Erlang一样。</target>
        </trans-unit>
        <trans-unit id="62e9bf54b39e624437b799beda0e7a99d2c76831" translate="yes" xml:space="preserve">
          <source>Compare two references. The comparison is done the same way as Erlang does.</source>
          <target state="translated">比较两个引用。比较的方式和Erlang一样。</target>
        </trans-unit>
        <trans-unit id="151c5d07514ac40bad0d13f9b26b2443190972b1" translate="yes" xml:space="preserve">
          <source>Compared to other SNMP agent packages, there is a significant difference in this way of using sub-agents. Other packages normally use sub-agents to load and unload MIBs in run-time. In Erlang, it is easy to load code in run-time and it is possible to load an MIB into an existing sub-agent. It is not necessary to create a new process for handling a new MIB.</source>
          <target state="translated">与其他SNMP代理包相比,这种使用子代理的方式有很大的不同。其他包通常使用子代理在运行时加载和卸载MIB。在Erlang中,在运行时加载代码很方便,可以将MIB加载到现有的子代理中。没有必要为处理一个新的MIB而创建一个新的进程。</target>
        </trans-unit>
        <trans-unit id="0c52ead5590f8067968c45ad847b25a4d463504b" translate="yes" xml:space="preserve">
          <source>Compared to the C program in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port, the &lt;code&gt;while&lt;/code&gt;-loop must be rewritten. Messages coming from the port is on the Erlang external term format. They must be converted into an &lt;code&gt;ETERM&lt;/code&gt; struct, which is a C struct similar to an Erlang term. The result of calling &lt;code&gt;foo()&lt;/code&gt; or &lt;code&gt;bar()&lt;/code&gt; must be converted to the Erlang external term format before being sent back to the port. But before calling any other Erl_Interface function, the memory handling must be initiated:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 中的C程序相比，仅使用普通端口，必须重写 &lt;code&gt;while&lt;/code&gt; -loop。来自端口的消息采用Erlang外部术语格式。必须将它们转换为 &lt;code&gt;ETERM&lt;/code&gt; 结构，这是类似于Erlang术语的C结构。调用 &lt;code&gt;foo()&lt;/code&gt; 或 &lt;code&gt;bar()&lt;/code&gt; 的结果必须先转换为Erlang外部术语格式，然后再发送回端口。但是在调用任何其他Erl_Interface函数之前，必须启动内存处理：</target>
        </trans-unit>
        <trans-unit id="c178437fef0499e44fe458af65742e21d4b116d4" translate="yes" xml:space="preserve">
          <source>Compares the BEAM files in two directories as &lt;code&gt;&lt;a href=&quot;#cmp_dirs-2&quot;&gt;cmp_dirs/2&lt;/a&gt;&lt;/code&gt;, but the names of files that exist in only one directory or are different are presented on standard output.</source>
          <target state="translated">将两个目录中的BEAM文件比较为 &lt;code&gt;&lt;a href=&quot;#cmp_dirs-2&quot;&gt;cmp_dirs/2&lt;/a&gt;&lt;/code&gt; ，但是仅存在于一个目录中或不同的文件名会显示在标准输出中。</target>
        </trans-unit>
        <trans-unit id="d98bf1bf3f126212e19565bfe2441f8eca0296a5" translate="yes" xml:space="preserve">
          <source>Compares the BEAM files in two directories. Only files with extension &lt;code&gt;&quot;.beam&quot;&lt;/code&gt; are compared. BEAM files that exist only in directory &lt;code&gt;Dir1&lt;/code&gt; (&lt;code&gt;Dir2&lt;/code&gt;) are returned in &lt;code&gt;Only1&lt;/code&gt; (&lt;code&gt;Only2&lt;/code&gt;). BEAM files that exist in both directories but are considered different by &lt;code&gt;cmp/2&lt;/code&gt; are returned as pairs {&lt;code&gt;Filename1&lt;/code&gt;, &lt;code&gt;Filename2&lt;/code&gt;}, where &lt;code&gt;Filename1&lt;/code&gt; (&lt;code&gt;Filename2&lt;/code&gt;) exists in directory &lt;code&gt;Dir1&lt;/code&gt; (&lt;code&gt;Dir2&lt;/code&gt;).</source>
          <target state="translated">比较两个目录中的BEAM文件。仅对扩展名为 &lt;code&gt;&quot;.beam&quot;&lt;/code&gt; 文件进行比较。仅在目录 &lt;code&gt;Dir1&lt;/code&gt; （ &lt;code&gt;Dir2&lt;/code&gt; ）中存在的BEAM文件在 &lt;code&gt;Only1&lt;/code&gt; （ &lt;code&gt;Only2&lt;/code&gt; ）中返回。两个目录中都存在但被 &lt;code&gt;cmp/2&lt;/code&gt; 认为不同的BEAM文件以成对{ &lt;code&gt;Filename1&lt;/code&gt; ， &lt;code&gt;Filename2&lt;/code&gt; }返回，其中 &lt;code&gt;Filename1&lt;/code&gt; （ &lt;code&gt;Filename2&lt;/code&gt; ）存在于目录 &lt;code&gt;Dir1&lt;/code&gt; （ &lt;code&gt;Dir2&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="553a5eb717c257ef16ac7d4161ee3822b465e3e7" translate="yes" xml:space="preserve">
          <source>Compares the contents of two BEAM files. If the module names are the same, and all chunks except for chunk &lt;code&gt;&quot;CInf&quot;&lt;/code&gt; (the chunk containing the compilation information that is returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;) have the same contents in both files, &lt;code&gt;ok&lt;/code&gt; is returned. Otherwise an error message is returned.</source>
          <target state="translated">比较两个BEAM文件的内容。如果模块名称相同，并且除块 &lt;code&gt;&quot;CInf&quot;&lt;/code&gt; （包含 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 返回的编译信息的块）以外的所有块在两个文件中的内容均相同，则返回 &lt;code&gt;ok&lt;/code&gt; 。否则，将返回错误消息。</target>
        </trans-unit>
        <trans-unit id="1371fc9819183da776aa8b206d27ecaadad51181" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt;s. Can also be used to imply some artificial order on monitors, for whatever reason.</source>
          <target state="translated">比较两个 &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; 。无论出于何种原因，也可以用来暗示监视器上的某些人为命令。</target>
        </trans-unit>
        <trans-unit id="7422cbed4d976bf1196e3065965309b4656fcd35" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid &lt;/a&gt;&lt;/code&gt;s according to term order.</source>
          <target state="translated">根据术语顺序比较两个 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5229791f8671e196d2b82edc4c7e2f917dd47d48" translate="yes" xml:space="preserve">
          <source>Compares two &lt;code&gt;ErlDrvMonitor&lt;/code&gt;s. Can also be used to imply some artificial order on monitors, for whatever reason.</source>
          <target state="translated">比较两个 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 。无论出于何种原因，也可以用来暗示监视器上的某些人为命令。</target>
        </trans-unit>
        <trans-unit id="00c8883b1a2eb607b39cecd8cab305675f55c676" translate="yes" xml:space="preserve">
          <source>Compares two encoded terms.</source>
          <target state="translated">对两个编码术语进行比较。</target>
        </trans-unit>
        <trans-unit id="4db48e071567d5840fbc4f9ce1403c03ce1085eb" translate="yes" xml:space="preserve">
          <source>Compares two thread identifiers, &lt;code&gt;tid1&lt;/code&gt; and &lt;code&gt;tid2&lt;/code&gt;, for equality.</source>
          <target state="translated">比较两个线程标识符 &lt;code&gt;tid1&lt;/code&gt; 和 &lt;code&gt;tid2&lt;/code&gt; 是否相等。</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="a8a612a1cee1a099e60c55bb976d9e9c6e46b755" translate="yes" xml:space="preserve">
          <source>Compatible between releases.</source>
          <target state="translated">不同版本之间兼容。</target>
        </trans-unit>
        <trans-unit id="7a3e29c10f00281440509daef8170e445e3cdb30" translate="yes" xml:space="preserve">
          <source>Compatible flow control. Ports have for a very long time had the possibility to use the busy port functionality when implementing flow control. One may argue that this functionality fits very bad with the conceptually completely asynchronous signaling, but the functionality has been there for ages and is expected to be there. When a port sets itself into a busy state, &lt;code&gt;command&lt;/code&gt; signals should not be delivered, and senders of such signals should suspend until the port sets itself in a not busy state.</source>
          <target state="translated">兼容的流量控制。在实现流控制时，端口很长时间以来就有可能使用繁忙的端口功能。有人可能会争辩说，此功能与概念上完全异步的信号非常不匹配，但是该功能已经存在了很长时间了，并且有望在那里存在。当端口将自己设置为繁忙状态时，不应传递 &lt;code&gt;command&lt;/code&gt; 信号，并且此类信号的发送方应暂停运行，直到端口将自己设置为不繁忙状态为止。</target>
        </trans-unit>
        <trans-unit id="bc2ecfdad25dfb789330b4fb6ce1f190fa4a6009" translate="yes" xml:space="preserve">
          <source>Compilation information (options) for the current code. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">当前代码的编译信息(选项)。这个字段在Crashdump Viewer工具查看时被解码。</target>
        </trans-unit>
        <trans-unit id="a25315637952f3b953fbd470f3a3c029d30dbf7d" translate="yes" xml:space="preserve">
          <source>Compilation information (options) for the old code, if any. This field is decoded when looked at by the Crashdump Viewer tool.</source>
          <target state="translated">旧代码的编译信息(选项),如果有的话。这个字段在Crashdump Viewer工具查看时被解码。</target>
        </trans-unit>
        <trans-unit id="d203fe989b06cd0b7f625aaf8b091fd82d85ba33" translate="yes" xml:space="preserve">
          <source>Compilation of Latin-1 Encoded Erlang Files</source>
          <target state="translated">编译Latin-1编码的Erlang文件。</target>
        </trans-unit>
        <trans-unit id="c2f3e610efaad31893ca9eea02ebda3f70c91261" translate="yes" xml:space="preserve">
          <source>Compile</source>
          <target state="translated">Compile</target>
        </trans-unit>
        <trans-unit id="f42e39dc3bb6eb7ec13af5ff3a369d976c404115" translate="yes" xml:space="preserve">
          <source>Compile a single dictionary file to Erlang source. Valid options are as follows.</source>
          <target state="translated">将单个字典文件编译成Erlang源代码。有效的选项如下。</target>
        </trans-unit>
        <trans-unit id="5dd3dcb33be1e0a1c396852da6964c746cfd4a25" translate="yes" xml:space="preserve">
          <source>Compile a single dictionary file. The input &lt;code&gt;File&lt;/code&gt; can be either a path or a literal dictionary, the occurrence of newline (ascii NL) or carriage return (ascii CR) identifying the latter. &lt;code&gt;Opt&lt;/code&gt; determines the format of the results and whether they are written to file or returned, and can have the following types.</source>
          <target state="translated">编译一个字典文件。输入 &lt;code&gt;File&lt;/code&gt; 可以是路径或文字字典，换行符（ascii NL）或回车符（ascii CR）的出现可以标识后者。 &lt;code&gt;Opt&lt;/code&gt; 决定结果的格式以及结果是写入文件还是返回，并且可以具有以下类型。</target>
        </trans-unit>
        <trans-unit id="ea40bcb5b571a74df14353da32099a206afadd67" translate="yes" xml:space="preserve">
          <source>Compile a syntax tree or list of syntax trees representing a module and load the resulting module into memory.</source>
          <target state="translated">编译一个代表模块的语法树或语法树列表,并将生成的模块加载到内存中。</target>
        </trans-unit>
        <trans-unit id="d9cce07b3061f732b7e01783d96813c2407e1405" translate="yes" xml:space="preserve">
          <source>Compile a syntax tree or list of syntax trees representing a module into a binary BEAM object.</source>
          <target state="translated">将代表模块的语法树或语法树列表编译成二进制BEAM对象。</target>
        </trans-unit>
        <trans-unit id="a375aba3b710980768146495139b7af7d643a217" translate="yes" xml:space="preserve">
          <source>Compile and test can look as follows (on Linux):</source>
          <target state="translated">编译和测试可以如下所示(在Linux上)。</target>
        </trans-unit>
        <trans-unit id="efeb9236240ba18a33a232714ad55f1346882865" translate="yes" xml:space="preserve">
          <source>Compile and test:</source>
          <target state="translated">编制和测试。</target>
        </trans-unit>
        <trans-unit id="009e13386fb7dcb403518ae79beff433bc904f14" translate="yes" xml:space="preserve">
          <source>Compile the file:</source>
          <target state="translated">编译文件。</target>
        </trans-unit>
        <trans-unit id="aac1b086ee049c8040c4f4f36d211fd3ac0e1a0c" translate="yes" xml:space="preserve">
          <source>Compile-Time Functions</source>
          <target state="translated">编译时函数</target>
        </trans-unit>
        <trans-unit id="95ffe53acbea5b747afd3e7842a4f96dca8af0d9" translate="yes" xml:space="preserve">
          <source>Compile-time errors</source>
          <target state="translated">编译时错误</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="0cb4d20a7b6c25fd2b85e979b6e35af9c0c13cf6" translate="yes" xml:space="preserve">
          <source>Compiled HiPE code can be loaded on the exact same build of ERTS that was used when compiling the code. It might however work on other builds, the emulator verifies checksums in order to determine if it can load the code or not. Note that HiPE has some limitations. For more information see the documentation of the &lt;code&gt;HiPE&lt;/code&gt; application.</source>
          <target state="translated">可以将已编译的HiPE代码加载到与编译代码时所使用的ERTS完全相同的内部版本中。但是，它可能会在其他版本上运行，模拟器会验证校验和以确定是否可以加载代码。请注意，HiPE有一些限制。有关更多信息，请参见 &lt;code&gt;HiPE&lt;/code&gt; 应用程序的文档。</target>
        </trans-unit>
        <trans-unit id="af4e4bc880ca00160a867f75ea5f3ae2220aada2" translate="yes" xml:space="preserve">
          <source>Compiled code can be loaded on at least two subsequent releases.</source>
          <target state="translated">编译后的代码至少可以在后续的两个版本中加载。</target>
        </trans-unit>
        <trans-unit id="341a20e237ff5c4b89204a3d4d8c8af5f8aa63bb" translate="yes" xml:space="preserve">
          <source>Compiler</source>
          <target state="translated">Compiler</target>
        </trans-unit>
        <trans-unit id="d95945f4aa5cbbd91cada4bcabf68e0085672573" translate="yes" xml:space="preserve">
          <source>Compiler -- GNU C Compiler, &lt;code&gt;gcc&lt;/code&gt; or the C compiler frontend for LLVM, &lt;code&gt;clang&lt;/code&gt;.</source>
          <target state="translated">编译器-GNU C编译器 &lt;code&gt;gcc&lt;/code&gt; 或LLVM &lt;code&gt;clang&lt;/code&gt; 的C编译器前端。</target>
        </trans-unit>
        <trans-unit id="af2c88bc48b05cd87b47590ea9db1fa862bf9e68" translate="yes" xml:space="preserve">
          <source>Compiler options. &lt;code&gt;Options&lt;/code&gt; is a single option or a list of options. This attribute is added to the option list when compiling the module. See the &lt;code&gt; compile(3)&lt;/code&gt; manual page in Compiler.</source>
          <target state="translated">编译器选项。 &lt;code&gt;Options&lt;/code&gt; 是单个选项或选项列表。编译模块时，此属性将添加到选项列表中。请参见 &lt;code&gt; compile(3)&lt;/code&gt; 器中的compile（3）手册页。</target>
        </trans-unit>
        <trans-unit id="1fd7d8f9a4971282aa3f0cede9ec0a2e34e9a6cd" translate="yes" xml:space="preserve">
          <source>Compiler options. &lt;code&gt;Options&lt;/code&gt; is a single option or a list of options. This attribute is added to the option list when compiling the module. See the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler.</source>
          <target state="translated">编译器选项。 &lt;code&gt;Options&lt;/code&gt; 是单个选项或选项列表。编译模块时，此属性将添加到选项列表中。请参见 &lt;code&gt;compile(3)&lt;/code&gt; 器中的compile（3）手册页。</target>
        </trans-unit>
        <trans-unit id="a97122f5c3385cf8819c76cad4ef6fc4b08ceea9" translate="yes" xml:space="preserve">
          <source>Compiles a list of files by calling &lt;code&gt;compile:file(File, [report_errors, report_warnings])&lt;/code&gt; for each &lt;code&gt;File&lt;/code&gt; in &lt;code&gt;Files&lt;/code&gt;.</source>
          <target state="translated">通过调用编译文件的列表 &lt;code&gt;compile:file(File, [report_errors, report_warnings])&lt;/code&gt; 每个 &lt;code&gt;File&lt;/code&gt; 的 &lt;code&gt;Files&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2047a2918cfe55f2b26d89d11edcfd3cd059df3" translate="yes" xml:space="preserve">
          <source>Compiles a module for Cover analysis. The module is given by its module name &lt;code&gt;Module&lt;/code&gt; or by its file name &lt;code&gt;File&lt;/code&gt;. The &lt;code&gt;.erl&lt;/code&gt; extension may be omitted. If the module is located in another directory, the path has to be specified.</source>
          <target state="translated">编译用于封面分析的模块。该模块以其模块名称 &lt;code&gt;Module&lt;/code&gt; 或文件名 &lt;code&gt;File&lt;/code&gt; 给出。所述 &lt;code&gt;.erl&lt;/code&gt; 扩展可以被省略。如果模块位于另一个目录中，则必须指定路径。</target>
        </trans-unit>
        <trans-unit id="d0d35e2cea0ebf58ea7da0c0e5ae037788aeac63" translate="yes" xml:space="preserve">
          <source>Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用下面描述的语法将正则表达式编译为内部格式，以供稍后用作 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="b4b4b69ed812b4e7ab7f1e6412e22181177a9748" translate="yes" xml:space="preserve">
          <source>Compiles a trace into raw profile data held by the &lt;code&gt;fprof&lt;/code&gt; server.</source>
          <target state="translated">将跟踪编译为 &lt;code&gt;fprof&lt;/code&gt; 服务器保存的原始配置文件数据。</target>
        </trans-unit>
        <trans-unit id="496d11b730a6b29cbd65fce7dff2e32330c8cd8d" translate="yes" xml:space="preserve">
          <source>Compiles all modules (&lt;code&gt;.beam&lt;/code&gt; files) in a directory &lt;code&gt;Dir&lt;/code&gt; for Cover analysis the same way as &lt;code&gt;compile_beam/1&lt;/code&gt; and returns a list with the return values.</source>
          <target state="translated">与 &lt;code&gt;compile_beam/1&lt;/code&gt; 一样，编译目录 &lt;code&gt;Dir&lt;/code&gt; 中的所有模块（ &lt;code&gt;.beam&lt;/code&gt; 文件）以进行Cover分析，并返回包含返回值的列表。</target>
        </trans-unit>
        <trans-unit id="c5f842551ac6a97b456ee17b4a34923a2c160458" translate="yes" xml:space="preserve">
          <source>Compiles all modules (&lt;code&gt;.erl&lt;/code&gt; files) in a directory &lt;code&gt;Dir&lt;/code&gt; for Cover analysis the same way as &lt;code&gt;compile_module/1,2&lt;/code&gt; and returns a list with the return values.</source>
          <target state="translated">以与 &lt;code&gt;compile_module/1,2&lt;/code&gt; 相同的方式编译目录 &lt;code&gt;Dir&lt;/code&gt; 中的所有模块（ &lt;code&gt;.erl&lt;/code&gt; 文件）以进行Cover分析，并返回包含返回值的列表。</target>
        </trans-unit>
        <trans-unit id="309f0ca1eb953e1fbbdcae7b61062e795ffa7fa7" translate="yes" xml:space="preserve">
          <source>Compiles and then loads the code for a file on all nodes. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;. Compilation is equivalent to:</source>
          <target state="translated">编译然后在所有节点上加载文件的代码。 &lt;code&gt;Options&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 。编译等效于：</target>
        </trans-unit>
        <trans-unit id="221e138541a5626106fb43c92947e2167555dd13" translate="yes" xml:space="preserve">
          <source>Compiles and then purges and loads the code for a module. &lt;code&gt;Module&lt;/code&gt; can be either a module name or a source file path, with or without &lt;code&gt;.erl&lt;/code&gt; extension. &lt;code&gt;Options&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">编译然后清除并加载模块的代码。 &lt;code&gt;Module&lt;/code&gt; 可以是模块名称或源文件路径，带有或不带有 &lt;code&gt;.erl&lt;/code&gt; 扩展名。 &lt;code&gt;Options&lt;/code&gt; 默认为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b52f93d9afc3e00c08182aa65070b9ab7d1d8892" translate="yes" xml:space="preserve">
          <source>Compiles one or more files. The files must include the extension, for example, &lt;code&gt;.erl&lt;/code&gt; for Erlang source code, or &lt;code&gt;.yrl&lt;/code&gt; for Yecc source code. &lt;code&gt;Erlc&lt;/code&gt; uses the extension to invoke the correct compiler.</source>
          <target state="translated">编译一个或多个文件。文件必须包括扩展名，例如， &lt;code&gt;.erl&lt;/code&gt; Erlang的源代码，或 &lt;code&gt;.yrl&lt;/code&gt; 为Yecc源代码。 &lt;code&gt;Erlc&lt;/code&gt; 使用扩展名来调用正确的编译器。</target>
        </trans-unit>
        <trans-unit id="34fed5154618994778a93f6748ba20015380e577" translate="yes" xml:space="preserve">
          <source>Compiles the &lt;code&gt;ASN.1&lt;/code&gt; module &lt;code&gt;Asn1module&lt;/code&gt; and generates an Erlang module &lt;code&gt;Asn1module.erl&lt;/code&gt; with encode and decode functions for the types defined in &lt;code&gt;Asn1module&lt;/code&gt;. For each ASN.1 value defined in the module, an Erlang function that returns the value in Erlang representation is generated.</source>
          <target state="translated">编译 &lt;code&gt;ASN.1&lt;/code&gt; 模块 &lt;code&gt;Asn1module&lt;/code&gt; 并产生一个Erlang模块 &lt;code&gt;Asn1module.erl&lt;/code&gt; 具有用于在定义的类型编码和解码功能 &lt;code&gt;Asn1module&lt;/code&gt; 。对于模块中定义的每个ASN.1值，都会生成一个以Erlang表示形式返回值的Erlang函数。</target>
        </trans-unit>
        <trans-unit id="9bedf3a45a5ce0a8899ba240ac388512ac570574" translate="yes" xml:space="preserve">
          <source>Compiles the code in the file &lt;code&gt;File&lt;/code&gt;, which is an Erlang source code file without the &lt;code&gt;.erl&lt;/code&gt; extension. &lt;code&gt;Options&lt;/code&gt; determine the behavior of the compiler.</source>
          <target state="translated">编译文件 &lt;code&gt;File&lt;/code&gt; 中的代码，该文件是不带 &lt;code&gt;.erl&lt;/code&gt; 扩展名的Erlang源代码文件。 &lt;code&gt;Options&lt;/code&gt; 确定编译器的行为。</target>
        </trans-unit>
        <trans-unit id="b15b4a0ca80870d899887848b2b561183d48d68e" translate="yes" xml:space="preserve">
          <source>Compiles the escript regardless of the value of the mode attribute.</source>
          <target state="translated">无论模式属性的值如何,都可以编译escript。</target>
        </trans-unit>
        <trans-unit id="69570f1327b6c981b9e63bb2091b8f905c42561a" translate="yes" xml:space="preserve">
          <source>Compiles the escript using flag &lt;code&gt;+native&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;+native&lt;/code&gt; 标志编译escript 。</target>
        </trans-unit>
        <trans-unit id="eac85df8f89173db1370c40338429031ded73b0b" translate="yes" xml:space="preserve">
          <source>Compiles the files with property tests in the subdirectory &lt;code&gt;property_test&lt;/code&gt;</source>
          <target state="translated">使用子目录 &lt;code&gt;property_test&lt;/code&gt; 中的属性测试编译文件</target>
        </trans-unit>
        <trans-unit id="e841c656ad6e0af5f7245e7bfda8da0570795473" translate="yes" xml:space="preserve">
          <source>Compiles the specified MIB file &lt;code&gt;&amp;lt;File&amp;gt;.mib&lt;/code&gt;. The compiled file &lt;code&gt;BinFileName&lt;/code&gt; is called &lt;code&gt;&amp;lt;File&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="translated">编译指定的MIB文件 &lt;code&gt;&amp;lt;File&amp;gt;.mib&lt;/code&gt; 。编译后的文件 &lt;code&gt;BinFileName&lt;/code&gt; 称为 &lt;code&gt;&amp;lt;File&amp;gt;.bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dbd42cde4e636dbd5d9f39210c69452d50ba1ef" translate="yes" xml:space="preserve">
          <source>Compiles the specified modules and then terminates (with non-zero exit code if the compilation of some file did not succeed). Implies &lt;code&gt;-noinput&lt;/code&gt;.</source>
          <target state="translated">编译指定的模块，然后终止（如果某些文件的编译未成功，则退出代码为非零）。表示 &lt;code&gt;-noinput&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f1604d887e21632c6157fb43c6ea0b3900d23f" translate="yes" xml:space="preserve">
          <source>Compiles using the SMP emulator. This is mainly useful for compiling native code, which must be compiled with the same runtime system that it is to be run on.</source>
          <target state="translated">使用SMP模拟器编译。这主要是对编译本地代码有用,因为本地代码必须在相同的运行时系统中编译。</target>
        </trans-unit>
        <trans-unit id="e47fc7a0773cbda86f40b163702495db6f23084c" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;GUI.asn&lt;/code&gt; including the configuration file is done as follows:</source>
          <target state="translated">包括配置文件在内的 &lt;code&gt;GUI.asn&lt;/code&gt; 的编译如下：</target>
        </trans-unit>
        <trans-unit id="a3590c7d935d1337384ebe30d0a63b8449a7f0a4" translate="yes" xml:space="preserve">
          <source>Compiling the code:</source>
          <target state="translated">编译代码。</target>
        </trans-unit>
        <trans-unit id="c5d3843d2d607e7b8047f8ec33a050336d9069e4" translate="yes" xml:space="preserve">
          <source>Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.</source>
          <target state="translated">在匹配前编译正则表达式是有用的,如果同一表达式要在程序的生命周期内用于针对多个对象的匹配。编译一次,执行多次,比每次要匹配时都要编译的效率高得多。</target>
        </trans-unit>
        <trans-unit id="39f435fa5106d5274aa216c6cabba9fe1af576c6" translate="yes" xml:space="preserve">
          <source>Compiling this code to beam assembly (&lt;code&gt;erlc -S&lt;/code&gt;) shows exactly what is happening.</source>
          <target state="translated">将此代码编译为梁装配体（ &lt;code&gt;erlc -S&lt;/code&gt; ）可以准确显示正在发生的事情。</target>
        </trans-unit>
        <trans-unit id="fc4c343469cc1bbf3a31e4474cfc268fdaa2a44f" translate="yes" xml:space="preserve">
          <source>Compiling this gives the following diagnostic:</source>
          <target state="translated">编译后得到以下诊断结果。</target>
        </trans-unit>
        <trans-unit id="3930914f8b99e680a55bb03e16d8af9eb69ff2ea" translate="yes" xml:space="preserve">
          <source>Compiling your code for use with &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">编译代码以与 &lt;code&gt;Erl_Interface&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="2ee8aa4143f8abfd86b424e473e8462be5d52390" translate="yes" xml:space="preserve">
          <source>Complex objects</source>
          <target state="translated">复杂物体</target>
        </trans-unit>
        <trans-unit id="06e63f260804216a398baf6f2e442df9c9a6cef2" translate="yes" xml:space="preserve">
          <source>Complexity Note</source>
          <target state="translated">复杂度说明</target>
        </trans-unit>
        <trans-unit id="9fb27df4e27c00aa8eb364ebe6cbe8b7f432000e" translate="yes" xml:space="preserve">
          <source>Complicated non-real-time queries mainly for operation and maintenance</source>
          <target state="translated">主要用于运维的复杂的非实时查询</target>
        </trans-unit>
        <trans-unit id="ce8d8f8862e358aa8505e89d95cb74cadb849673" translate="yes" xml:space="preserve">
          <source>Complicated or circular dependencies can make it difficult or even impossible to decide in which order things must be done without risking runtime errors during an upgrade or downgrade. Dependencies can be:</source>
          <target state="translated">复杂的或循环的依赖关系会使我们难以甚至无法决定在升级或降级过程中必须按什么顺序做事情,而不会有运行时错误的风险。依赖关系可以是:</target>
        </trans-unit>
        <trans-unit id="59fca003467aad58f9b2b7e565b2ce3c84cd8c99" translate="yes" xml:space="preserve">
          <source>Composes a form-urlencoded &lt;code&gt;QueryString&lt;/code&gt; based on a &lt;code&gt;QueryList&lt;/code&gt;, a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; specification and in section 4.10.22.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; specification for non-UTF-8 encodings.</source>
          <target state="translated">根据 &lt;code&gt;QueryList&lt;/code&gt; 组成一个表单编码的 &lt;code&gt;QueryString&lt;/code&gt; ，这是非百分比编码的键值对的列表。在非UTF-8编码的 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; 规范的第4.10.21.6节和在 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; 规范的第4.10.22.6 节中定义了Form-urlencoding 。</target>
        </trans-unit>
        <trans-unit id="c1c2faea65f93de909779259387dfd62954a59b1" translate="yes" xml:space="preserve">
          <source>Composing form-urlencoded query strings from a list of key-value pairs</source>
          <target state="translated">从键值对的列表中组成表单urlencoded查询字符串。</target>
        </trans-unit>
        <trans-unit id="c0f6771c0b4ff62b75c5e9a377f7512f8a2eb0a7" translate="yes" xml:space="preserve">
          <source>Composite terms can be constructed in the &lt;code&gt;Result&lt;/code&gt; part either by simply writing a list, so that the following code:</source>
          <target state="translated">可以通过简单地编写一个列表，在 &lt;code&gt;Result&lt;/code&gt; 部分中构造复合词，以便以下代码：</target>
        </trans-unit>
        <trans-unit id="1fe0eda1d9e3db81360d76b01700f1fc22578fac" translate="yes" xml:space="preserve">
          <source>Compress a megaco component. The erlang dist encoder makes no assumption on the how or even if the component is compressed.</source>
          <target state="translated">压缩一个 megaco 组件。erlang dist编码器不会假设如何压缩组件,甚至不会假设组件是否被压缩。</target>
        </trans-unit>
        <trans-unit id="9a0fa988cf443cd1d375271986427ec83de3c3de" translate="yes" xml:space="preserve">
          <source>Compresses as much data as possible, and stops when the input buffer becomes empty. It can introduce some output latency (reading input without producing any output) except when forced to flush.</source>
          <target state="translated">尽可能多的压缩数据,当输入缓冲区变空时停止。它可能会带来一些输出延迟(读取输入而不产生任何输出),除非被迫刷新。</target>
        </trans-unit>
        <trans-unit id="ca1de065e72e8ca9af3242c8e400cc65d7c65430" translate="yes" xml:space="preserve">
          <source>Compresses data with gz headers and checksum.</source>
          <target state="translated">用gz头和校验和压缩数据。</target>
        </trans-unit>
        <trans-unit id="5c0f619cd36dba9bac61586e413cccabc45aa3bd" translate="yes" xml:space="preserve">
          <source>Compresses data with zlib headers and checksum.</source>
          <target state="translated">用zlib头和校验压缩数据。</target>
        </trans-unit>
        <trans-unit id="f32171029d67c841b304fa7802dd10659367b936" translate="yes" xml:space="preserve">
          <source>Compresses data without zlib headers and checksum.</source>
          <target state="translated">压缩数据时不需要zlib头和校验。</target>
        </trans-unit>
        <trans-unit id="3dd49034da5c932029f1472e527e8712ce79873f" translate="yes" xml:space="preserve">
          <source>Compression is not supported.</source>
          <target state="translated">不支持压缩。</target>
        </trans-unit>
        <trans-unit id="db573c49060217e5ae7cad606cbcc07e7a832439" translate="yes" xml:space="preserve">
          <source>Compression level to use:</source>
          <target state="translated">要使用的压缩级别。</target>
        </trans-unit>
        <trans-unit id="e004f4ec54c1bdeeaf01ade20386a509b0f50f4b" translate="yes" xml:space="preserve">
          <source>Compression method to use, currently the only supported method is &lt;code&gt;deflated&lt;/code&gt;.</source>
          <target state="translated">要使用的压缩方法，目前唯一支持的方法是 &lt;code&gt;deflated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6150f090d8e22866c8af7ff2aba307952a5dde62" translate="yes" xml:space="preserve">
          <source>Computers in general</source>
          <target state="translated">计算机</target>
        </trans-unit>
        <trans-unit id="8617e2409a9b5d81fedafe4823179428b5db9db3" translate="yes" xml:space="preserve">
          <source>Computes a CMAC of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">使用 &lt;code&gt;Key&lt;/code&gt; 作为身份验证密钥，从 &lt;code&gt;Data&lt;/code&gt; 计算 &lt;code&gt;Type&lt;/code&gt; 类型的CMAC 。</target>
        </trans-unit>
        <trans-unit id="5ef091378f6011f32b08cfa86037d11d3811847d" translate="yes" xml:space="preserve">
          <source>Computes a HMAC of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">使用 &lt;code&gt;Key&lt;/code&gt; 作为认证密钥，从 &lt;code&gt;Data&lt;/code&gt; 计算 &lt;code&gt;Type&lt;/code&gt; 类型的HMAC 。</target>
        </trans-unit>
        <trans-unit id="57b5d4d63f3cc072fe01656f61d82df0a950c2ad" translate="yes" xml:space="preserve">
          <source>Computes a MAC (Message Authentication Code) as &lt;code&gt;&lt;a href=&quot;#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; but &lt;code&gt;MacLength&lt;/code&gt; will limit the size of the resultant &lt;code&gt;Mac&lt;/code&gt; to at most &lt;code&gt;MacLength&lt;/code&gt; bytes. Note that if &lt;code&gt;MacLength&lt;/code&gt; is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead.</source>
          <target state="translated">将MAC（消息身份验证代码）计算为 &lt;code&gt;&lt;a href=&quot;#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; ,但 &lt;code&gt;MacLength&lt;/code&gt; 会将生成的 &lt;code&gt;Mac&lt;/code&gt; 的大小限制为最多 &lt;code&gt;MacLength&lt;/code&gt; 字节。请注意，如果 &lt;code&gt;MacLength&lt;/code&gt; 大于从基础哈希返回的实际字节数，则返回的哈希将具有较短的长度。</target>
        </trans-unit>
        <trans-unit id="b42e2ec67691e90be353f3e69f72f115d660a04c" translate="yes" xml:space="preserve">
          <source>Computes a MAC (Message Authentication Code) of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;Data&lt;/code&gt; 计算类型 &lt;code&gt;Type&lt;/code&gt; 的MAC（消息认证代码）。</target>
        </trans-unit>
        <trans-unit id="53549f7a7603013142bc34dff7ebedfb36946cc7" translate="yes" xml:space="preserve">
          <source>Computes a POLY1305 message authentication code (&lt;code&gt;Mac&lt;/code&gt;) from &lt;code&gt;Data&lt;/code&gt; using &lt;code&gt;Key&lt;/code&gt; as the authentication key.</source>
          <target state="translated">使用 &lt;code&gt;Key&lt;/code&gt; 作为验证密钥从 &lt;code&gt;Data&lt;/code&gt; 计算POLY1305消息验证代码（ &lt;code&gt;Mac&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e7c1891feac89cb6aa9a784a894b9b7b9608ba45" translate="yes" xml:space="preserve">
          <source>Computes a layout for a document and returns the corresponding text. See &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; for further information. Throws &lt;code&gt;no_layout&lt;/code&gt; if no layout could be selected.</source>
          <target state="translated">计算文档的布局并返回相应的文本。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 。如果无法选择任何布局，则抛出 &lt;code&gt;no_layout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4a91015bc370126d2bc5a10fd6fba142f0c14d1" translate="yes" xml:space="preserve">
          <source>Computes a message digest of type &lt;code&gt;Type&lt;/code&gt; from &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;Data&lt;/code&gt; 计算类型 &lt;code&gt;Type&lt;/code&gt; 的消息摘要。</target>
        </trans-unit>
        <trans-unit id="cf90dde8a0d4f759f93b97dc9e424324bb51d514" translate="yes" xml:space="preserve">
          <source>Computes an MD5 message digest from &lt;code&gt;Data&lt;/code&gt;, where the length of the digest is 128 bits (16 bytes). &lt;code&gt;Data&lt;/code&gt; is a binary or a list of small integers and binaries.</source>
          <target state="translated">从 &lt;code&gt;Data&lt;/code&gt; 计算MD5消息摘要，摘要的长度为128位（16字节）。 &lt;code&gt;Data&lt;/code&gt; 是二进制或小整数和二进制列表。</target>
        </trans-unit>
        <trans-unit id="c22b3bee40e516d5a07e21c574ff4a1f0971eb34" translate="yes" xml:space="preserve">
          <source>Computes and returns the adler32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">计算并返回adler32的 &lt;code&gt;Data&lt;/code&gt; 校验和。</target>
        </trans-unit>
        <trans-unit id="a2abd766c0d5933f47abe70569d16c6d23d728d1" translate="yes" xml:space="preserve">
          <source>Computes and returns the crc32 (IEEE 802.3 style) checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">计算并返回 &lt;code&gt;Data&lt;/code&gt; 的crc32（IEEE 802.3样式）校验和。</target>
        </trans-unit>
        <trans-unit id="5bc8ee5e263121b926d2d7cc593061f196c30372" translate="yes" xml:space="preserve">
          <source>Computes shared secret.</source>
          <target state="translated">计算共享秘密。</target>
        </trans-unit>
        <trans-unit id="acb13ad633fa39b9539693d88f8804c8d59f95c0" translate="yes" xml:space="preserve">
          <source>Computes the date and time from the specified number of gregorian seconds.</source>
          <target state="translated">根据指定的公历秒数计算日期和时间。</target>
        </trans-unit>
        <trans-unit id="1a60d1d8512d9b43f58c2fa78c69c36bd98988a7" translate="yes" xml:space="preserve">
          <source>Computes the date from the specified number of gregorian days.</source>
          <target state="translated">从指定的格里高利日数计算日期。</target>
        </trans-unit>
        <trans-unit id="6fd928a5422a42545d3f8009960a129cf04f4b60" translate="yes" xml:space="preserve">
          <source>Computes the day of the week from the specified &lt;code&gt;Year&lt;/code&gt;, &lt;code&gt;Month&lt;/code&gt;, and &lt;code&gt;Day&lt;/code&gt;. Returns the day of the week as &lt;code&gt;1&lt;/code&gt;: Monday, &lt;code&gt;2&lt;/code&gt;: Tuesday, and so on.</source>
          <target state="translated">从指定的 &lt;code&gt;Year&lt;/code&gt; ， &lt;code&gt;Month&lt;/code&gt; 和 &lt;code&gt;Day&lt;/code&gt; 计算星期几。将星期几返回为 &lt;code&gt;1&lt;/code&gt; ：星期一， &lt;code&gt;2&lt;/code&gt; ：星期二，依此类推。</target>
        </trans-unit>
        <trans-unit id="6bb723f7731befec282ae7ca53f445d61b40a18f" translate="yes" xml:space="preserve">
          <source>Computes the function &lt;code&gt;N^P mod M&lt;/code&gt;.</source>
          <target state="translated">计算功能 &lt;code&gt;N^P mod M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99dc499279c70ed65d6985615f527cb1c6eca26f" translate="yes" xml:space="preserve">
          <source>Computes the number of days in a month.</source>
          <target state="translated">计算一个月的天数。</target>
        </trans-unit>
        <trans-unit id="1fa973e390e7f2a427dcdf5a3027ba7dbec27578" translate="yes" xml:space="preserve">
          <source>Computes the number of gregorian days starting with year 0 and ending at the specified date.</source>
          <target state="translated">计算从0年开始到指定日期结束的格里高利日数。</target>
        </trans-unit>
        <trans-unit id="460e100ab696f364fd9d5ba6fb8d34bc03d60b0c" translate="yes" xml:space="preserve">
          <source>Computes the number of gregorian seconds starting with year 0 and ending at the specified date and time.</source>
          <target state="translated">计算从0年开始到指定日期和时间结束的公历秒数。</target>
        </trans-unit>
        <trans-unit id="c47a52a2c77fbf69039f5e7a1c102eeafa864720" translate="yes" xml:space="preserve">
          <source>Computes the shared secret from the private key and the other party's public key. See also &lt;code&gt;public_key:compute_key/2&lt;/code&gt;</source>
          <target state="translated">根据私钥和另一方的公钥计算共享机密。另请参见 &lt;code&gt;public_key:compute_key/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19647b47d421a4ceb33442c666abcffa1275beb1" translate="yes" xml:space="preserve">
          <source>Computes the time from the specified number of seconds. &lt;code&gt;Seconds&lt;/code&gt; must be less than the number of seconds per day (86400).</source>
          <target state="translated">根据指定的秒数计算时间。 &lt;code&gt;Seconds&lt;/code&gt; 必须小于每天的秒数（86400）。</target>
        </trans-unit>
        <trans-unit id="72e55071de1b7db1194725444c44c89aad5472b9" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;code&gt;String1&lt;/code&gt; and &lt;code&gt;String2&lt;/code&gt; to form a new string &lt;code&gt;String3&lt;/code&gt;, which is returned.</source>
          <target state="translated">串接 &lt;code&gt;String1&lt;/code&gt; 和 &lt;code&gt;String2&lt;/code&gt; 的，形成一个新的字符串 &lt;code&gt;String3&lt;/code&gt; ，这是返回。</target>
        </trans-unit>
        <trans-unit id="c2fd259e1eeb55c9d34cb9be26a6c2f75fe45818" translate="yes" xml:space="preserve">
          <source>Concatenates all text nodes within the tree.</source>
          <target state="translated">将树中的所有文本节点连接起来。</target>
        </trans-unit>
        <trans-unit id="9abfe77881130796df1a67c0daaf938195db3463" translate="yes" xml:space="preserve">
          <source>Concatenates documents horizontally. Returns a document representing the concatenation of the documents &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; such that the last character of &lt;code&gt;D1&lt;/code&gt; is horizontally adjacent to the first character of &lt;code&gt;D2&lt;/code&gt;, in all possible layouts. (Note: any indentation of &lt;code&gt;D2&lt;/code&gt; is lost.)</source>
          <target state="translated">水平合并文件。在所有可能的布局中，返回表示文档 &lt;code&gt;D1&lt;/code&gt; 和 &lt;code&gt;D2&lt;/code&gt; 串联的文档，以使 &lt;code&gt;D1&lt;/code&gt; 的最后一个字符在水平方向上与 &lt;code&gt;D2&lt;/code&gt; 的第一个字符相邻。（注意： &lt;code&gt;D2&lt;/code&gt; 的任何缩进都会丢失。）</target>
        </trans-unit>
        <trans-unit id="04e1c1fcf3ff57f50627e79ee514ef9c378133db" translate="yes" xml:space="preserve">
          <source>Concatenates documents vertically. Returns a document representing the concatenation of the documents &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; such that the first line of &lt;code&gt;D2&lt;/code&gt; follows directly below the last line of &lt;code&gt;D1&lt;/code&gt;, and the first character of &lt;code&gt;D2&lt;/code&gt; is in the same horizontal column as the first character of &lt;code&gt;D1&lt;/code&gt;, in all possible layouts.</source>
          <target state="translated">垂直连接文档。返回表示文件的级联的文件 &lt;code&gt;D1&lt;/code&gt; 和 &lt;code&gt;D2&lt;/code&gt; ，使得第一线 &lt;code&gt;D2&lt;/code&gt; 如下直接的最后一行下面 &lt;code&gt;D1&lt;/code&gt; ，和的第一个字符 &lt;code&gt;D2&lt;/code&gt; 是在同一水平列的第一个字符 &lt;code&gt;D1&lt;/code&gt; ，在其所有可能布局。</target>
        </trans-unit>
        <trans-unit id="d15df121840905ed24abf69eb1607851f11fd815" translate="yes" xml:space="preserve">
          <source>Concatenates the text representation of the elements of &lt;code&gt;Things&lt;/code&gt;. The elements of &lt;code&gt;Things&lt;/code&gt; can be atoms, integers, floats, or strings.</source>
          <target state="translated">连接 &lt;code&gt;Things&lt;/code&gt; 元素的文本表示。 &lt;code&gt;Things&lt;/code&gt; 的元素可以是原子，整数，浮点数或字符串。</target>
        </trans-unit>
        <trans-unit id="0fbd67c45b9474556de6e975213929d8a6a47459" translate="yes" xml:space="preserve">
          <source>Concatenates two Erlang terms, prepending &lt;code&gt;head&lt;/code&gt; onto &lt;code&gt;tail&lt;/code&gt; and thereby creating a &lt;code&gt;cons&lt;/code&gt; cell. To make a proper list, &lt;code&gt;tail&lt;/code&gt; is always to be a list or an empty list. Notice that &lt;code&gt;NULL&lt;/code&gt; is not a valid list.</source>
          <target state="translated">连接两个Erlang项，将 &lt;code&gt;head&lt;/code&gt; 放在 &lt;code&gt;tail&lt;/code&gt; ，从而创建一个 &lt;code&gt;cons&lt;/code&gt; 单元。为了列出正确的列表， &lt;code&gt;tail&lt;/code&gt; 始终是列表或空列表。请注意， &lt;code&gt;NULL&lt;/code&gt; 不是有效列表。</target>
        </trans-unit>
        <trans-unit id="2c186b6b1deba8a770e9e1695542ea581f1d331a" translate="yes" xml:space="preserve">
          <source>Concatenation. It matches &lt;code&gt;r1&lt;/code&gt; and then &lt;code&gt;r2&lt;/code&gt;.</source>
          <target state="translated">级联。它先匹配 &lt;code&gt;r1&lt;/code&gt; ，然后匹配 &lt;code&gt;r2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="4666ff1177aa06dcf2e2acf53d84de400036ddc9" translate="yes" xml:space="preserve">
          <source>Conceptually, a random real number &lt;code&gt;R&lt;/code&gt; is generated from the interval &lt;code&gt;0 =&amp;lt; R &amp;lt; 1&lt;/code&gt; and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned.</source>
          <target state="translated">从概念上讲，从区间 &lt;code&gt;0 =&amp;lt; R &amp;lt; 1&lt;/code&gt; 生成随机实数 &lt;code&gt;R&lt;/code&gt; ，然后返回IEEE 754双精度格式中最接近的四舍五入归一化数。</target>
        </trans-unit>
        <trans-unit id="d59061815936968cd27ee5eeaae408a473490a5f" translate="yes" xml:space="preserve">
          <source>Conceptually, call tracing works as follows. Inside the Erlang virtual machine, a set of processes and a set of functions are to be traced. If a traced process calls a traced function, the trace action is taken. Otherwise, nothing happens.</source>
          <target state="translated">从概念上讲,调用跟踪的工作原理如下。在Erlang虚拟机内部,要跟踪一组进程和一组函数。如果一个被跟踪的进程调用了一个被跟踪的函数,就会进行跟踪操作。否则,什么都不会发生。</target>
        </trans-unit>
        <trans-unit id="3c999b08d7c22c76e1e6dc0faa05064eba3a0394" translate="yes" xml:space="preserve">
          <source>Conceptually, the SSH protocol can be partitioned into four layers:</source>
          <target state="translated">从概念上讲,SSH协议可以分为四层。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="74b54106acc00f9f724fe295423167276db3a6a8" translate="yes" xml:space="preserve">
          <source>Conclusion: Avoid values 8 and -8 unless you know your zlib version supports them.</source>
          <target state="translated">结论:除非你知道你的zlib版本支持这些值,否则避免使用8和-8。避免使用8和-8,除非你知道你的zlib版本支持它们。</target>
        </trans-unit>
        <trans-unit id="bca39e22d6b36f574329075fd07dd2629638ff2f" translate="yes" xml:space="preserve">
          <source>Concurrent Programming in Erlang, 2nd Edition (1996), Prentice-Hall, ISBN 0-13-508301-X.</source>
          <target state="translated">Erlang中的并发编程,第2版(1996年),Prentice-Hall,ISBN 0-13-508301-X。</target>
        </trans-unit>
        <trans-unit id="f6aff0ecefa8fcdacfbed141ac66c352f04cf650" translate="yes" xml:space="preserve">
          <source>Concurrent processes in &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 中的并发过程</target>
        </trans-unit>
        <trans-unit id="c5814c8062d15de57203bd84567426b16df3f497" translate="yes" xml:space="preserve">
          <source>Condition variable. Used when threads must wait for a specific condition to appear before continuing execution. Condition variables must be used with associated mutexes.</source>
          <target state="translated">条件变量。当线程必须等待特定条件出现后才能继续执行时使用。条件变量必须与关联的mutexes一起使用。</target>
        </trans-unit>
        <trans-unit id="3030b91f9ac5c385e0e5ba58d0f9e9743296576f" translate="yes" xml:space="preserve">
          <source>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct</source>
          <target state="translated">ConditionExpression ::=ExprMatchVariable |{GuardFunction }。|{GuardFunction,ConditionExpression,...}| 术语结构</target>
        </trans-unit>
        <trans-unit id="bbdc9c98e3ac79ef6aaff8d954cf32028d6e4917" translate="yes" xml:space="preserve">
          <source>Conditional Breakpoints</source>
          <target state="translated">条件性断点</target>
        </trans-unit>
        <trans-unit id="290e0b23c3082ece19e13061650a81ca4e400aba" translate="yes" xml:space="preserve">
          <source>Conditional compilation directives</source>
          <target state="translated">有条件的编译指令</target>
        </trans-unit>
        <trans-unit id="e659f221c6e3ec580224ba7c1c7b2ad09c848aac" translate="yes" xml:space="preserve">
          <source>Config is a list of {Item, Value} tuples. See megaco:user_info/2 about which items and values that are valid.</source>
          <target state="translated">Config是一个{Item,Value}元组的列表。关于哪些项目和值是有效的,请参见 megaco:user_info/2。</target>
        </trans-unit>
        <trans-unit id="6aa237b9ad391aadf182df8ed22f8e2958d1b069" translate="yes" xml:space="preserve">
          <source>Configurable degree of fault tolerance (by replication)</source>
          <target state="translated">可配置的容错程度(通过复制)。</target>
        </trans-unit>
        <trans-unit id="646e69fcaff68aa4bd99d792ff12c1ed636760b8" translate="yes" xml:space="preserve">
          <source>Configuration API functions</source>
          <target state="translated">配置API功能</target>
        </trans-unit>
        <trans-unit id="8d87e87971a9b480182707da39f6dc7de52524b0" translate="yes" xml:space="preserve">
          <source>Configuration Parameters</source>
          <target state="translated">配置参数</target>
        </trans-unit>
        <trans-unit id="57b4835664f870ac8b56a60f7a98cea5878873e7" translate="yes" xml:space="preserve">
          <source>Configuration data for the formatter. See &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; for an example of a formatter implementation.</source>
          <target state="translated">格式化程序的配置数据。有关格式化程序实现的示例，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fe8143de2bd407b7318a9b914132afaf723fced" translate="yes" xml:space="preserve">
          <source>Configuration data for the formatter. See &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; for an example of a formatter implementation.</source>
          <target state="translated">格式化程序的配置数据。有关格式化程序实现的示例，请参见 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="657e7546b354cf171eeba078e0a7f96bcfb3d842" translate="yes" xml:space="preserve">
          <source>Configuration data may be included in configuration files that is located in the configuration directory. The name of this directory is given in the &lt;code&gt;config_dir&lt;/code&gt; configuration parameter. These files are read at start-up.</source>
          <target state="translated">配置数据可以包含在配置目录中的配置文件中。该目录的名称在 &lt;code&gt;config_dir&lt;/code&gt; 配置参数中给出。这些文件是在启动时读取的。</target>
        </trans-unit>
        <trans-unit id="1df26c4218fb3cc15e90c12f33ffed59b35b1ae8" translate="yes" xml:space="preserve">
          <source>Configuration data values in the CTH can be read by calling &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1,2,3&lt;/a&gt;&lt;/code&gt; (as explained in section &lt;code&gt;&lt;a href=&quot;config_file_chapter#require_config_data&quot;&gt;Requiring and Reading Configuration Data&lt;/a&gt;&lt;/code&gt;). The configuration variables in question must, as always, first have been required by a suite-, group-, or test case information function, or by function &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1/2&lt;/a&gt;&lt;/code&gt;. The latter can also be used in CT hook functions.</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;ct:get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 来读取CTH中的配置数据值（如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;config_file_chapter#require_config_data&quot;&gt;Requiring and Reading Configuration Data&lt;/a&gt;&lt;/code&gt; ）。与往常一样，必须首先通过套件，组或测试用例信息功能或函数 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1/2&lt;/a&gt;&lt;/code&gt; 来使用所讨论的配置变量。后者也可以用于CT挂钩功能。</target>
        </trans-unit>
        <trans-unit id="acdba8395423767de730ee1b75436df3a0ebc87e" translate="yes" xml:space="preserve">
          <source>Configuration file</source>
          <target state="translated">配置文件</target>
        </trans-unit>
        <trans-unit id="856e8e09448b31c0b19cccc7d2f429463a65a741" translate="yes" xml:space="preserve">
          <source>Configuration file.</source>
          <target state="translated">配置文件。</target>
        </trans-unit>
        <trans-unit id="cac911d99944c8d8de85519d3c8353adfa4909ed" translate="yes" xml:space="preserve">
          <source>Configuration files containing sensitive data can be encrypted if they must be stored in open and shared directories.</source>
          <target state="translated">如果必须将包含敏感数据的配置文件存储在开放和共享的目录中,可以对其进行加密。</target>
        </trans-unit>
        <trans-unit id="983f322fab3effb7b0bc8474c3b652c0529b254b" translate="yes" xml:space="preserve">
          <source>Configuration function for a group, executed after the last test case. (Optional)</source>
          <target state="translated">组的配置功能,在最后一个测试案例后执行。(可选)</target>
        </trans-unit>
        <trans-unit id="4837fc4e4200eba9faee7e5d7a160f74631dd940" translate="yes" xml:space="preserve">
          <source>Configuration function for a group, executed before the first test case. (Optional)</source>
          <target state="translated">组的配置功能,在第一个测试用例之前执行。(可选)</target>
        </trans-unit>
        <trans-unit id="0446d4a5ed9002889e3fcbdb5be7abd84be2a99c" translate="yes" xml:space="preserve">
          <source>Configuration function for a testcase, executed after each test case. (Optional)</source>
          <target state="translated">测试用例的配置功能,在每个测试用例后执行。(可选)</target>
        </trans-unit>
        <trans-unit id="bd3c7dde0d6b835f389712e4b422204622e6bba3" translate="yes" xml:space="preserve">
          <source>Configuration function for a testcase, executed before each test case. (Optional)</source>
          <target state="translated">测试用例的配置功能,在每个测试用例之前执行。(可选)</target>
        </trans-unit>
        <trans-unit id="54eab7708a8f9ac8e547396221ceb06e955d8621" translate="yes" xml:space="preserve">
          <source>Configuration parameter &lt;code&gt;-mnesia dump_log_update_in_place &amp;lt;bool&amp;gt;&lt;/code&gt; controls the safety level of the function &lt;code&gt;&lt;a href=&quot;mnesia#dump_log-0&quot;&gt;mnesia:dump_log()&lt;/a&gt;&lt;/code&gt; By default, &lt;code&gt;Mnesia&lt;/code&gt; dumps the transaction log directly into the &lt;code&gt;DAT&lt;/code&gt; files. If a power failure occurs during the dump, this can cause the randomly accessed &lt;code&gt;DAT&lt;/code&gt; files to become corrupt. If the parameter is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; copies the &lt;code&gt;DAT&lt;/code&gt; files and target the dump to the new temporary files. If the dump is successful, the temporary files are renamed to their normal &lt;code&gt;DAT&lt;/code&gt; suffixes. The possibility for unrecoverable inconsistencies in the data files becomes much smaller with this strategy. However, the actual dumping of the transaction log becomes considerably slower. The system designer must decide whether speed or safety is the higher priority.</source>
          <target state="translated">配置参数 &lt;code&gt;-mnesia dump_log_update_in_place &amp;lt;bool&amp;gt;&lt;/code&gt; 控制函数 &lt;code&gt;&lt;a href=&quot;mnesia#dump_log-0&quot;&gt;mnesia:dump_log()&lt;/a&gt;&lt;/code&gt; 的安全级别缺省情况下， &lt;code&gt;Mnesia&lt;/code&gt; 将事务日志直接转储到 &lt;code&gt;DAT&lt;/code&gt; 文件中。如果在转储期间发生电源故障，这可能会导致随机访问的 &lt;code&gt;DAT&lt;/code&gt; 文件损坏。如果参数设置为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;Mnesia&lt;/code&gt; 将复制 &lt;code&gt;DAT&lt;/code&gt; 文件并将转储定位到新的临时文件。如果转储成功，则将临时文件重命名为其正常的 &lt;code&gt;DAT&lt;/code&gt; 后缀。使用这种策略，数据文件中不可恢复的不一致的可能性变得很小。但是，事务日志的实际转储变得相当慢。系统设计者必须决定速度或安全性是更高的优先级。</target>
        </trans-unit>
        <trans-unit id="dbd4d4d025501c16c7f2ccb2570c2099b823b966" translate="yes" xml:space="preserve">
          <source>Configuration parameter values in the configuration file override the values in the application resource files (see &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;). The values in the configuration file can be overridden by command-line flags (see &lt;code&gt;erts:erl(1)&lt;/code&gt;).</source>
          <target state="translated">配置文件中的配置参数值将覆盖应用程序资源文件中的值（请参阅 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; ）。可以使用命令行标志来覆盖配置文件中的值（请参阅 &lt;code&gt;erts:erl(1)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="152137ca072ede4f7367cf2d0089190cd0e9f36f" translate="yes" xml:space="preserve">
          <source>Configuration parameters used by the application. The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;. The values in the application resource file can be overridden by values in a configuration file (see &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt;) or by command-line flags (see &lt;code&gt;erts:erl(1)&lt;/code&gt;).</source>
          <target state="translated">应用程序使用的配置参数。通过调用 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 检索配置参数的值。应用程序资源文件中的值可以被配置文件中的值（请参见 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; ）或命令行标志（请参见 &lt;code&gt;erts:erl(1)&lt;/code&gt; ）覆盖。</target>
        </trans-unit>
        <trans-unit id="f167a5ff05614d588913f2a3ea7b803864f94594" translate="yes" xml:space="preserve">
          <source>Configuration problems - Everything from that the database was not set up right to that the c-program that should be run through the erlang port was not compiled for your platform.</source>
          <target state="translated">配置问题-从数据库没有正确设置,到应该通过 erlang port 运行的 c 程序没有为你的平台编译。</target>
        </trans-unit>
        <trans-unit id="adfc00d45d90320f98d4a8966dd99b612af98936" translate="yes" xml:space="preserve">
          <source>Configuration terms can be combined with &lt;code&gt;ct_run&lt;/code&gt; start flags or &lt;code&gt;ct:run_test/1&lt;/code&gt; options. The result is, for some flags/options and terms, that the values are merged (for example, configuration files, include directories, verbosity levels, and silent connections) and for others that the start flags/options override the test specification terms (for example, log directory, label, style sheet, and auto-compilation).</source>
          <target state="translated">配置术语可以与 &lt;code&gt;ct_run&lt;/code&gt; 开始标志或 &lt;code&gt;ct:run_test/1&lt;/code&gt; 选项结合使用。对于某些标志/选项和术语，结果是值被合并（例如，配置文件，包含目录，详细级别和静默连接），而对于其他标志/选项，则开始标志/选项将覆盖测试规范术语（对于例如日志目录，标签，样式表和自动编译）。</target>
        </trans-unit>
        <trans-unit id="111aadb1527fab0c3a3d9158364fe8fbe059dd4b" translate="yes" xml:space="preserve">
          <source>Configuration that alters the behaviour of the watchdog state machine. On key &lt;code&gt;okay&lt;/code&gt;, the non-negative number of answered DWR messages before transitioning from REOPEN to OKAY. On key &lt;code&gt;suspect&lt;/code&gt;, the number of watchdog timeouts before transitioning from OKAY to SUSPECT when DWR is unanswered, or 0 to not make the transition.</source>
          <target state="translated">更改看门狗状态机行为的配置。在键 &lt;code&gt;okay&lt;/code&gt; 上，从REOPEN转换为OKAY之前，已应答DWR消息的非负数。对于主要 &lt;code&gt;suspect&lt;/code&gt; ，当未应答DWR时，从OKAY过渡到SUSPECT之前的看门狗超时数，或者为0表示不进行过渡。</target>
        </trans-unit>
        <trans-unit id="88225db23aed8095cba3daadea46a8efc09bcf97" translate="yes" xml:space="preserve">
          <source>Configuration tool for erts_alloc</source>
          <target state="translated">erts_alloc的配置工具</target>
        </trans-unit>
        <trans-unit id="a5fa127b18e20d9b955af8441e526ef00d776b55" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang with LTTng support:</source>
          <target state="translated">配置和构建支持LTTng的Erlang。</target>
        </trans-unit>
        <trans-unit id="6b190ce5efd5aa3a5159cbfc60014c630270e8e5" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang with SystemTap support:</source>
          <target state="translated">配置和构建支持SystemTap的Erlang。</target>
        </trans-unit>
        <trans-unit id="5d4f8831764e8303911e86ac723330a29d408566" translate="yes" xml:space="preserve">
          <source>Configure and build Erlang/OTP with FIPS support:</source>
          <target state="translated">配置并构建支持FIPS的Erlang/OTP。</target>
        </trans-unit>
        <trans-unit id="b69539c636b739dc3d9c18ef898b44516eab0391" translate="yes" xml:space="preserve">
          <source>Configure and build all applications in OTP:</source>
          <target state="translated">在OTP中配置和构建所有应用程序。</target>
        </trans-unit>
        <trans-unit id="8b2484c0c315deeb2ad1807b28fd424c7f06c488" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (on Mavericks - 10.9):</source>
          <target state="translated">配置并构建wxWidgets(在Mavericks-10.9上)。</target>
        </trans-unit>
        <trans-unit id="39d69829cac4583c026b7dac06cd342838c15fea" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (shared library on linux):</source>
          <target state="translated">配置并构建wxWidgets(linux上的共享库)。</target>
        </trans-unit>
        <trans-unit id="67a1257909b72f3008c5378fbca12636e7276e2e" translate="yes" xml:space="preserve">
          <source>Configure and build wxWidgets (static library on linux):</source>
          <target state="translated">配置并构建wxWidgets(linux上的静态库)。</target>
        </trans-unit>
        <trans-unit id="c38bfc21b593ce7dfdec5fb0054e7673a03afdbf" translate="yes" xml:space="preserve">
          <source>Configure how wide the target documentation should be rendered. By default &lt;code&gt;shell_docs&lt;/code&gt; used the value returned by &lt;code&gt;&lt;a href=&quot;io#columns-0&quot;&gt;io:columns()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配置应呈现目标文档的宽度。默认情况下， &lt;code&gt;shell_docs&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;io#columns-0&quot;&gt;io:columns()&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="45882985975ef9fac87f192f6e545cf51766f699" translate="yes" xml:space="preserve">
          <source>Configure the &lt;code&gt;server_node()&lt;/code&gt; function.</source>
          <target state="translated">配置 &lt;code&gt;server_node()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="bce9428e6d9edc0287bc7c097cb864aea994b4a1" translate="yes" xml:space="preserve">
          <source>Configure the application (agent).</source>
          <target state="translated">配置应用程序(代理)。</target>
        </trans-unit>
        <trans-unit id="51a6fc0c6fbca524ff962159da3f3049edca0826" translate="yes" xml:space="preserve">
          <source>Configure the application (manager).</source>
          <target state="translated">配置应用程序(管理器)。</target>
        </trans-unit>
        <trans-unit id="e46814ef7294ecaf5dc1092fc3316c476f79636e" translate="yes" xml:space="preserve">
          <source>Configure the encoding that should be used by the renderer for graphical details such as bullet-points. By default &lt;code&gt;shell_docs&lt;/code&gt; uses the value returned by &lt;code&gt;&lt;a href=&quot;io#getopts-0&quot;&gt;io:getopts()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">配置渲染器应用于图形详细信息（例如，项目符号点）的编码。默认情况下， &lt;code&gt;shell_docs&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;io#getopts-0&quot;&gt;io:getopts()&lt;/a&gt;&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="cd4cfa952c7cb1b3fb9049874d99e02d7fd694ce" translate="yes" xml:space="preserve">
          <source>Configure whether &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt; ansi escape codes&lt;/a&gt;&lt;/code&gt; should be used to render graphical details such as bold and underscore. By default &lt;code&gt;shell_docs&lt;/code&gt; will try to determine if the receiving shell supports ansi escape codes. It is possible to override the automated check by setting the kernel configuration parameter &lt;code&gt;shell_docs_ansi&lt;/code&gt; to a &lt;code&gt;boolean()&lt;/code&gt; value.</source>
          <target state="translated">配置是否应使用 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code&quot;&gt; ansi escape codes&lt;/a&gt;&lt;/code&gt; 来呈现图形细节，例如粗体和下划线。默认情况下， &lt;code&gt;shell_docs&lt;/code&gt; 将尝试确定接收外壳是否支持ansi转义码。通过将内核配置参数 &lt;code&gt;shell_docs_ansi&lt;/code&gt; 设置为 &lt;code&gt;boolean()&lt;/code&gt; 值，可以覆盖自动检查。</target>
        </trans-unit>
        <trans-unit id="d9998129edb861a2783fd9f2d983f3b8f9c04883" translate="yes" xml:space="preserve">
          <source>Configures a TLS 1.3 connection for keylogging</source>
          <target state="translated">配置TLS 1.3连接以进行密钥记录。</target>
        </trans-unit>
        <trans-unit id="27054e2972268be83aba680767c39676d6755bb8" translate="yes" xml:space="preserve">
          <source>Configures all allocators as they were configured in respective Erlang/OTP release. These will eventually be removed.</source>
          <target state="translated">配置所有分配器,就像在各自的 Erlang/OTP 版本中配置的那样。这些分配器最终会被移除。</target>
        </trans-unit>
        <trans-unit id="e1fa096044e69ac6a707fff4851145fb0bf622ec" translate="yes" xml:space="preserve">
          <source>Configures the maximum amount of bytes that can be sent on a TLS 1.3 connection before an automatic key update is performed.</source>
          <target state="translated">配置在执行自动密钥更新之前,TLS 1.3连接上可以发送的最大字节数。</target>
        </trans-unit>
        <trans-unit id="493e81d559f9007329e29af0dfb0f57e7a4f1093" translate="yes" xml:space="preserve">
          <source>Configures the middlebox compatibility mode on a TLS 1.3 connection.</source>
          <target state="translated">在TLS 1.3连接上配置中间盒兼容模式。</target>
        </trans-unit>
        <trans-unit id="caaf0a0801b3a7b065a2bc9b4de4bf8d0218db05" translate="yes" xml:space="preserve">
          <source>Configures the module responsible to communicate to &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. Defaults to &lt;code&gt;erl_epmd&lt;/code&gt;.</source>
          <target state="translated">配置负责与 &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 通信的模块。默认为 &lt;code&gt;erl_epmd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd503813fc0045da6207273af5b0357c11782f4a" translate="yes" xml:space="preserve">
          <source>Configures the port used by erl_epmd to listen for connection and connect to other nodes. See &lt;code&gt;erl_epmd&lt;/code&gt; for more details. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">配置erl_epmd用于侦听连接并连接到其他节点的端口。有关更多详细信息，请参见 &lt;code&gt;erl_epmd&lt;/code&gt; 。默认为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86997217852f7599e58f2424f86945f3b956ee02" translate="yes" xml:space="preserve">
          <source>Configures the server's built-in anti replay feature based on Bloom filters.</source>
          <target state="translated">配置服务器内置的基于Bloom过滤器的反重播功能。</target>
        </trans-unit>
        <trans-unit id="c9e5587526bf34e0c44a725edb0ac01a0dbf94bc" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionality. Allowed values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;manual&lt;/code&gt; and &lt;code&gt;auto&lt;/code&gt;. If it is set to &lt;code&gt;manual&lt;/code&gt; the client will send the ticket information to user process in a 3-tuple:</source>
          <target state="translated">配置会话票证功能。允许的值被 &lt;code&gt;disabled&lt;/code&gt; ， &lt;code&gt;manual&lt;/code&gt; 和 &lt;code&gt;auto&lt;/code&gt; 。如果将其设置为 &lt;code&gt;manual&lt;/code&gt; 则客户端将以三元组的形式将票证信息发送给用户进程：</target>
        </trans-unit>
        <trans-unit id="0d71c8eadc43b0d0c1aac71b43d64a1624014b9d" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionality. Allowed values are &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;stateful&lt;/code&gt; and &lt;code&gt;stateless&lt;/code&gt;.</source>
          <target state="translated">配置会话票证功能。允许的值被 &lt;code&gt;disabled&lt;/code&gt; ， &lt;code&gt;stateful&lt;/code&gt; 和 &lt;code&gt;stateless&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a467e0f743057863caa3e159aa6a46f3dd678d5e" translate="yes" xml:space="preserve">
          <source>Configures the session ticket functionalty in TLS 1.3 client and server.</source>
          <target state="translated">在TLS 1.3客户端和服务器中配置会话票据功能。</target>
        </trans-unit>
        <trans-unit id="dff79d039481de88c5036e525e09e7da9c1ef7c7" translate="yes" xml:space="preserve">
          <source>Configures the session tickets to be used for session resumption. It is a mandatory option in &lt;code&gt;manual&lt;/code&gt; mode (&lt;code&gt;session_tickets = manual&lt;/code&gt;).</source>
          <target state="translated">配置用于会话恢复的会话票证。在 &lt;code&gt;manual&lt;/code&gt; 模式下，它是必选选项（ &lt;code&gt;session_tickets = manual&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c76054bf57b43f642c168e37a0c4892b7f72916d" translate="yes" xml:space="preserve">
          <source>Configuring Automatic Start at Boot</source>
          <target state="translated">配置启动时自动启动</target>
        </trans-unit>
        <trans-unit id="6ba44bc8ee2b71bde340df435bd441a9952d9f23" translate="yes" xml:space="preserve">
          <source>Configuring automatic start at boot</source>
          <target state="translated">配置启动时的自动启动</target>
        </trans-unit>
        <trans-unit id="f49a4931e1853a0fe4fa0602792023cbc59353be" translate="yes" xml:space="preserve">
          <source>Configuring the server</source>
          <target state="translated">配置服务器</target>
        </trans-unit>
        <trans-unit id="f5c913b04ded8b2ffe36ec199b0399bc4e16854e" translate="yes" xml:space="preserve">
          <source>Configuring the server's (daemon's) command execution</source>
          <target state="translated">配置服务器(守护进程)的命令执行方式</target>
        </trans-unit>
        <trans-unit id="503bfa6b8b4cecf020c1a30e6445166dec1a4440" translate="yes" xml:space="preserve">
          <source>Conflicting lock requests are automatically queued if there is no risk of a deadlock. Otherwise the transaction must be terminated and executed again. Mnesia does this automatically as long as the upper limit of the maximum &lt;code&gt;retries&lt;/code&gt; is not reached. For details, see &lt;code&gt;mnesia:transaction/3&lt;/code&gt;.</source>
          <target state="translated">如果没有死锁的风险，冲突的锁定请求将自动排队。否则，交易必须终止并再次执行。只要未达到最大 &lt;code&gt;retries&lt;/code&gt; 上限，Mnesia就会自动执行此操作。有关详细信息，请参见 &lt;code&gt;mnesia:transaction/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2080b07c9b432005750511e775ff7af7fc0ee76b" translate="yes" xml:space="preserve">
          <source>Connect the socket identified by &lt;code&gt;ctx&lt;/code&gt; to the address identified by &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;ctx&lt;/code&gt; 标识的套接字连接到 &lt;code&gt;addr&lt;/code&gt; 标识的地址。</target>
        </trans-unit>
        <trans-unit id="cfb84c7d5e0e6a9a5fc9a1a633d1fff5ce509970" translate="yes" xml:space="preserve">
          <source>Connect to a suspended shell</source>
          <target state="translated">连接到悬挂的外壳</target>
        </trans-unit>
        <trans-unit id="a8a7191deb9b3f0244a3453f396383743b739a70" translate="yes" xml:space="preserve">
          <source>Connect to the database</source>
          <target state="translated">连接到数据库</target>
        </trans-unit>
        <trans-unit id="dfb47972cff0f154a2285644e3f0befc8c5e2893" translate="yes" xml:space="preserve">
          <source>Connect/session options can be specified in a configuration file with entries like the following.</source>
          <target state="translated">连接/会话选项可以在配置文件中指定,条目如下。</target>
        </trans-unit>
        <trans-unit id="68c228838ef934f7196305d997754e8802035987" translate="yes" xml:space="preserve">
          <source>ConnectToHost, ConnectToPort) -&amp;gt;</source>
          <target state="translated">ConnectToHost, ConnectToPort) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2437d145ba906224318478ddfa7f5cf7b3436b38" translate="yes" xml:space="preserve">
          <source>ConnectToHost, ConnectToPort, Timeout) -&amp;gt;</source>
          <target state="translated">ConnectToHost，ConnectToPort，超时）-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2b22ea7c73a23c792930a01a0f5400a135abcc5" translate="yes" xml:space="preserve">
          <source>Connected (4)</source>
          <target state="translated">已连接 (4)</target>
        </trans-unit>
        <trans-unit id="36a66c74a711b5012f4f766353ddd52a449b5a5e" translate="yes" xml:space="preserve">
          <source>Connected nodes</source>
          <target state="translated">连接的节点</target>
        </trans-unit>
        <trans-unit id="2ca30b01eb101978f596dfb4c83992a57c6fb882" translate="yes" xml:space="preserve">
          <source>Connecting a client to the server</source>
          <target state="translated">将客户端连接到服务器</target>
        </trans-unit>
        <trans-unit id="1ed330faf0978f7019e3726be2b5f99e046a3f4c" translate="yes" xml:space="preserve">
          <source>Connecting to a distributed Erlang node</source>
          <target state="translated">连接到分布式Erlang节点</target>
        </trans-unit>
        <trans-unit id="1f32eba569c9805c42f3eab7b2d07fbd5c071012" translate="yes" xml:space="preserve">
          <source>Connecting to other nodes</source>
          <target state="translated">连接到其他节点</target>
        </trans-unit>
        <trans-unit id="e3a4dd291e41bb38e1db11e5af64f5a26ce5f00c" translate="yes" xml:space="preserve">
          <source>Connection Protocol</source>
          <target state="translated">连接协议</target>
        </trans-unit>
        <trans-unit id="4fd62a8d97ad5549bbf8348232d0d6b0c35c3395" translate="yes" xml:space="preserve">
          <source>Connection handle</source>
          <target state="translated">连接手柄</target>
        </trans-unit>
        <trans-unit id="2a819b372c3b2a49974a53da0826f1bc5ad2d2c2" translate="yes" xml:space="preserve">
          <source>Connection info - Information regarding connections. Read/Write.</source>
          <target state="translated">连接信息-有关连接的信息。读/写。</target>
        </trans-unit>
        <trans-unit id="acc13ac478b7f7a6df5cb010281833816acda090" translate="yes" xml:space="preserve">
          <source>Connection termination - If a connection is terminated in an abnormal way, or if you try to use a connection that you have already terminated in a normal way by calling disconnect/1, the return value will be&lt;code&gt;{error, connection_closed}&lt;/code&gt;. A connection could end abnormally because of an programming error in the Erlang ODBC application, but also if the ODBC driver crashes.</source>
          <target state="translated">连接终止-如果连接以异常方式终止，或者如果您尝试通过调用connect / 1来使用已经以正常方式终止的连接，则返回值为 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 。由于Erlang ODBC应用程序中的编程错误，连接也可能异常终止，但是如果ODBC驱动程序崩溃，连接也可能异常结束。</target>
        </trans-unit>
        <trans-unit id="f630d306abbe920d5aff2c2e026867de87df60cb" translate="yes" xml:space="preserve">
          <source>Connection time-out time, used during the initial request, when the client is &lt;strong&gt;connecting&lt;/strong&gt; to the server.</source>
          <target state="translated">客户端&lt;strong&gt;连接&lt;/strong&gt;到服务器时，在初始请求期间使用的连接超时时间。</target>
        </trans-unit>
        <trans-unit id="db6dfee0a523a63827ad3c6d672bff28e305c559" translate="yes" xml:space="preserve">
          <source>Connection time-out.</source>
          <target state="translated">连接超时。</target>
        </trans-unit>
        <trans-unit id="84f24a79f02b5f5432cf025209afa84534522b4e" translate="yes" xml:space="preserve">
          <source>Connection timeout (time to wait for connection) = 10 seconds</source>
          <target state="translated">连接超时(等待连接的时间)=10秒</target>
        </trans-unit>
        <trans-unit id="3e9db74206291fe256a5fc7ef954e969d3ba0113" translate="yes" xml:space="preserve">
          <source>Connection to the remote server is prematurely closed.</source>
          <target state="translated">过早关闭与远程服务器的连接。</target>
        </trans-unit>
        <trans-unit id="9c0cd0e7b81e317003b4ab011ba52828e5f13f08" translate="yes" xml:space="preserve">
          <source>Connection type. To be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">连接类型。传递给 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e82eede979765f65e15123d56fb52f12de95d73" translate="yes" xml:space="preserve">
          <source>Connection-less socket communication (UDP) consists of an initiator socket at a certain host with a certain port number and a connector socket sending data to it.</source>
          <target state="translated">无连接套接字通信(UDP)由某台主机上具有一定端口号的发起者套接字和向其发送数据的连接器套接字组成。</target>
        </trans-unit>
        <trans-unit id="8923bf50fe66824eb73b05f930aafcd92a3498db" translate="yes" xml:space="preserve">
          <source>Connections are by default transitive. If a node A connects to node B, and node B has a connection to node C, then node A also tries to connect to node C. This feature can be turned off by using the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt;, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">默认情况下，连接是可传递的。如果节点A连接到节点B，并且节点B连接到节点C，则节点A也尝试连接到节点C。可以通过使用命令行标志 &lt;code&gt;-connect_all false&lt;/code&gt; 来关闭此功能，请参见 &lt;code&gt;erl(1)&lt;/code&gt; ERTS中的手册页。</target>
        </trans-unit>
        <trans-unit id="df7a96b9d1ab852162c55262ef869436a1f43920" translate="yes" xml:space="preserve">
          <source>Connections are realized by configuring transport. Sessions are the responsibility of the user.</source>
          <target state="translated">连接是通过配置传输来实现的。会话由用户负责。</target>
        </trans-unit>
        <trans-unit id="3ac050aca2ac7a4aec63a1a71d8f09959bd07582" translate="yes" xml:space="preserve">
          <source>Connections may either be established by an explicit call to megaco:connect/4 or implicitly at the first invocation of megaco:receive_message/3.</source>
          <target state="translated">连接可以通过对megaco:connect/4的显式调用建立,也可以在第一次调用megaco:receive_message/3时隐式建立。</target>
        </trans-unit>
        <trans-unit id="69b63834c530ccc921274b1f6732ad102c4bd9dd" translate="yes" xml:space="preserve">
          <source>Connections must be opened as follows:</source>
          <target state="translated">必须按以下方式打开连接。</target>
        </trans-unit>
        <trans-unit id="72980df161edb38af837eab92658c3a3e6caba2a" translate="yes" xml:space="preserve">
          <source>Connections vs. Sessions</source>
          <target state="translated">连接与会话</target>
        </trans-unit>
        <trans-unit id="6db35336552131a827a4b1a45bea2ad8b7cf5dce" translate="yes" xml:space="preserve">
          <source>Connector punctuation</source>
          <target state="translated">连接器的标点符号</target>
        </trans-unit>
        <trans-unit id="f7170a28f440536cf3718ba7465f311ddd5a8f4f" translate="yes" xml:space="preserve">
          <source>Connects to a server on TCP port &lt;code&gt;Port&lt;/code&gt; on the host with IP address &lt;code&gt;Address&lt;/code&gt;. Argument &lt;code&gt;Address&lt;/code&gt; can be a hostname or an IP address.</source>
          <target state="translated">连接到IP地址为 &lt;code&gt;Address&lt;/code&gt; 的主机的TCP端口 &lt;code&gt;Port&lt;/code&gt; 上的服务器。参数 &lt;code&gt;Address&lt;/code&gt; 可以是主机名或IP地址。</target>
        </trans-unit>
        <trans-unit id="dd4d77ecb9ea0beb70c140dfe5e069727cc27239" translate="yes" xml:space="preserve">
          <source>Connects to an SSH server at &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; (defaults to 22) and starts an interactive shell on that remote host.</source>
          <target state="translated">在 &lt;code&gt;Host&lt;/code&gt; 和 &lt;code&gt;Port&lt;/code&gt; （默认为22）上连接到SSH服务器，并在该远程主机上启动交互式Shell。</target>
        </trans-unit>
        <trans-unit id="3901b0235178a62a083958cef9aa253e7ded5f4e" translate="yes" xml:space="preserve">
          <source>Connects to an SSH server at the &lt;code&gt;Host&lt;/code&gt; on &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Port&lt;/code&gt; 上的 &lt;code&gt;Host&lt;/code&gt; 上连接到SSH服务器。</target>
        </trans-unit>
        <trans-unit id="d8b7cd7e1ddd732f728c53cb316632742f51fdb5" translate="yes" xml:space="preserve">
          <source>Connects to job number &lt;code&gt;&amp;lt;nn&amp;gt;&lt;/code&gt; or the current job. The standard shell is resumed. Operations that use standard I/O by the current job are interleaved with user inputs to the shell.</source>
          <target state="translated">连接到作业号 &lt;code&gt;&amp;lt;nn&amp;gt;&lt;/code&gt; 或当前作业。恢复标准外壳程序。当前作业使用标准I / O的操作与用户对Shell的输入交错在一起。</target>
        </trans-unit>
        <trans-unit id="a90f171af7aaadbc8a2111970a10fc3906a1623c" translate="yes" xml:space="preserve">
          <source>Connects to the socket named &amp;lt;socket name&amp;gt;.</source>
          <target state="translated">连接到名为&amp;lt;socket name&amp;gt;的套接字。</target>
        </trans-unit>
        <trans-unit id="12c4c6846d065c87773544d3b07ce317d854f9c3" translate="yes" xml:space="preserve">
          <source>Consider a &quot;pure&quot; &lt;code&gt;ets:select/2&lt;/code&gt; call that does what &lt;code&gt;ets:foldr&lt;/code&gt; does:</source>
          <target state="translated">考虑一个&amp;ldquo;纯&amp;rdquo; &lt;code&gt;ets:select/2&lt;/code&gt; 调用，它执行 &lt;code&gt;ets:foldr&lt;/code&gt; 的作用：</target>
        </trans-unit>
        <trans-unit id="efde5834872be2ae75b153813fdd7ce1668940f2" translate="yes" xml:space="preserve">
          <source>Consider a &lt;code&gt;code_length/0&lt;/code&gt; function that returns the length of the correct code. We dispatch all events that are not state-specific to the common function &lt;code&gt;handle_common/3&lt;/code&gt;:</source>
          <target state="translated">考虑一个 &lt;code&gt;code_length/0&lt;/code&gt; 函数，该函数返回正确代码的长度。我们将所有非特定于状态的事件分配给通用函数 &lt;code&gt;handle_common/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4b8e15fd9a0bd525abf05ad20a9f77d24e2e9bec" translate="yes" xml:space="preserve">
          <source>Consider a Linux machine where option &lt;code&gt;TCP_INFO&lt;/code&gt; can be used to collect TCP statistics for a socket. Assume you are interested in field &lt;code&gt;tcpi_sacked&lt;/code&gt; of &lt;code&gt;struct tcp_info&lt;/code&gt; filled in when asking for &lt;code&gt;TCP_INFO&lt;/code&gt;. To be able to access this information, you need to know the following:</source>
          <target state="translated">考虑一个Linux计算机，其中可以使用选项 &lt;code&gt;TCP_INFO&lt;/code&gt; 来收集套接字的TCP统计信息。假设你有兴趣的领域 &lt;code&gt;tcpi_sacked&lt;/code&gt; 的 &lt;code&gt;struct tcp_info&lt;/code&gt; 充满询问时 &lt;code&gt;TCP_INFO&lt;/code&gt; 。为了能够访问此信息，您需要了解以下内容：</target>
        </trans-unit>
        <trans-unit id="8d96d58366d35570e4b5a61813232b9e498b1343" translate="yes" xml:space="preserve">
          <source>Consider a directory containing a file named &quot;bj&amp;ouml;rn&quot; in ISO Latin-1, while the Erlang VM is operating in Unicode filename mode (and therefore expects UTF-8 file naming). The ISO Latin-1 name is not valid UTF-8 and one can be tempted to think that automatic conversion in, for example, &lt;code&gt;file:list_dir/1&lt;/code&gt; is a good idea. But what would happen if we later tried to open the file and have the name as a Unicode list (magically converted from the ISO Latin-1 filename)? The VM converts the filename to UTF-8, as this is the encoding expected. Effectively this means trying to open the file named &amp;lt;&amp;lt;&quot;bj&amp;ouml;rn&quot;/utf8&amp;gt;&amp;gt;. This file does not exist, and even if it existed it would not be the same file as the one that was listed. We could even create two files named &quot;bj&amp;ouml;rn&quot;, one named in UTF-8 encoding and one not. If &lt;code&gt;file:list_dir/1&lt;/code&gt; would automatically convert the ISO Latin-1 filename to a list, we would get two identical filenames as the result. To avoid this, we must differentiate between filenames that are properly encoded according to the Unicode file naming convention (that is, UTF-8) and filenames that are invalid under the encoding. By the common function &lt;code&gt;file:list_dir/1&lt;/code&gt;, the wrongly encoded filenames are ignored in Unicode filename translation mode, but by function &lt;code&gt;file:list_dir_all/1&lt;/code&gt; the filenames with invalid encoding are returned as &quot;raw&quot; filenames, that is, as binaries.</source>
          <target state="translated">考虑一个目录，其中包含一个在ISO Latin-1中名为&amp;ldquo;bj&amp;ouml;rn&amp;rdquo;的文件，而Erlang VM在Unicode文件名模式下运行（因此需要使用UTF-8文件命名）。 ISO Latin-1名称不是有效的UTF-8，因此可以尝试认为在 &lt;code&gt;file:list_dir/1&lt;/code&gt; 中进行自动转换是个好主意。但是，如果我们以后尝试打开文件并将其名称作为Unicode列表（从ISO Latin-1文件名神奇地转换），会发生什么情况？ VM将文件名转换为UTF-8，因为这是预期的编码。实际上，这意味着尝试打开名为&amp;lt;&amp;lt;&amp;ldquo;bj&amp;ouml;rn&amp;rdquo; / utf8 &amp;gt;&amp;gt;的文件。该文件不存在，即使存在，也不会与列出的文件相同。我们甚至可以创建两个名为&amp;ldquo;bj&amp;ouml;rn&amp;rdquo;的文件，一种以UTF-8编码命名，另一种则没有。如果 &lt;code&gt;file:list_dir/1&lt;/code&gt; 会自动将ISO Latin-1文件名转换为列表，结果将得到两个相同的文件名。为避免这种情况，我们必须区分根据Unicode文件命名约定正确编码的文件名（即UTF-8）和根据编码无效的文件名。通过通用函数 &lt;code&gt;file:list_dir/1&lt;/code&gt; ，在Unicode文件名转换模式下将忽略编码错误的文件名，但是通过函数 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; 将无效编码的文件名作为&amp;ldquo;原始&amp;rdquo;文件名（即二进制文件）返回。</target>
        </trans-unit>
        <trans-unit id="85ff3c7e5e58dcfda30947417cbf03dc221285f7" translate="yes" xml:space="preserve">
          <source>Consider a function that adds a subscriber to a telephony system:</source>
          <target state="translated">考虑一个向电话系统添加用户的函数。</target>
        </trans-unit>
        <trans-unit id="d67d867e1a2c0d3f72d5fed36d8199068542319f" translate="yes" xml:space="preserve">
          <source>Consider a process that receives data from a client process to be forwarded to a server on the network. The process is connected to the server through TCP/IP and does not get any acknowledge for each message it sends, but has to rely on the send time-out option to detect that the other end is unresponsive. Option &lt;code&gt;send_timeout&lt;/code&gt; can be used when connecting:</source>
          <target state="translated">考虑一个从客户端进程接收数据并转发到网络上服务器的进程。该进程通过TCP / IP连接到服务器，并且对于发送的每条消息都不会获得任何确认，但是必须依靠send time-out选项来检测另一端没有响应。连接时可以使用选项 &lt;code&gt;send_timeout&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9e2691c6fb672c519517e1290458846e6ef5963a" translate="yes" xml:space="preserve">
          <source>Consider a simple table of employees:</source>
          <target state="translated">考虑一个简单的员工表。</target>
        </trans-unit>
        <trans-unit id="f4c75d1817bfaec0e89222a276e69880bbb048f7" translate="yes" xml:space="preserve">
          <source>Consider how &lt;code&gt;Reversed_List&lt;/code&gt; is built. It starts as [], then successively the heads are taken off of the list to be reversed and added to the the &lt;code&gt;Reversed_List&lt;/code&gt;, as shown in the following:</source>
          <target state="translated">考虑一下 &lt;code&gt;Reversed_List&lt;/code&gt; 的构建方式。它以[]开头，然后从列表中将要删除的头依次反转并添加到 &lt;code&gt;Reversed_List&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="6ab7f6a1bb41fb01d5cd20aaa578826fc00067f9" translate="yes" xml:space="preserve">
          <source>Consider that you have a module that handles the abstract data type &lt;code&gt;Person&lt;/code&gt;. You export the interface function &lt;code&gt;print_person/1&lt;/code&gt;, which uses the internal functions &lt;code&gt;print_name/1&lt;/code&gt;, &lt;code&gt;print_age/1&lt;/code&gt;, and &lt;code&gt;print_occupation/1&lt;/code&gt;.</source>
          <target state="translated">考虑您有一个处理抽象数据类型 &lt;code&gt;Person&lt;/code&gt; 的模块。您导出接口函数 &lt;code&gt;print_person/1&lt;/code&gt; ，该接口函数使用内部函数 &lt;code&gt;print_name/1&lt;/code&gt; ， &lt;code&gt;print_age/1&lt;/code&gt; 和 &lt;code&gt;print_occupation/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e832f8403c198de61e833e7a480735f4053e43ff" translate="yes" xml:space="preserve">
          <source>Consider the example in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analysing Results, now extended with node information and intended to be executed by &lt;code&gt;Common Test&lt;/code&gt; Master:</source>
          <target state="translated">请考虑&amp;ldquo; 运行测试和分析结果&amp;rdquo; 部分的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分中的示例，该示例现已扩展了节点信息，并打算由 &lt;code&gt;Common Test&lt;/code&gt; Master 执行：</target>
        </trans-unit>
        <trans-unit id="39f2b57b5281a62ac0370db4ff59b10198d6ae26" translate="yes" xml:space="preserve">
          <source>Consider the following pattern, which contains non-significant whitespace to make it more readable (assume option &lt;code&gt;extended&lt;/code&gt;) and to divide it into three parts for ease of discussion:</source>
          <target state="translated">考虑以下模式，该模式包含不重要的空格以使其更具可读性（假定options &lt;code&gt;extended&lt;/code&gt; ）并将其分为三部分以便于讨论：</target>
        </trans-unit>
        <trans-unit id="46bc9d71b555a5f11b94b4eeb5c560673be71af6" translate="yes" xml:space="preserve">
          <source>Consider the following schema for a table of company employees. Each employee is identified by department number and name. The other table column stores the telephone number:</source>
          <target state="translated">考虑以下公司员工表的模式。每个员工由部门号和姓名来标识。表的另一列存储了电话号码。</target>
        </trans-unit>
        <trans-unit id="cb55da6206ee40073782daa342fe492d6d61166c" translate="yes" xml:space="preserve">
          <source>Consider the function &lt;code&gt;fact&lt;/code&gt;:</source>
          <target state="translated">考虑函数 &lt;code&gt;fact&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef174d60bac701fec9e09c290d0d3b90c3cf6f8c" translate="yes" xml:space="preserve">
          <source>Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth.</source>
          <target state="translated">考虑在括号中匹配一个字符串的问题,允许无限的嵌套括号。在不使用递归的情况下,最好的办法是使用一个模式,匹配到某个固定的嵌套深度。不可能处理任意的嵌套深度。</target>
        </trans-unit>
        <trans-unit id="270cf4c7cb812d80c2aeafefcba021db14b5c9b0" translate="yes" xml:space="preserve">
          <source>Consider the same regular expression, but with the subpattern explicitly named 'FOO':</source>
          <target state="translated">考虑同样的正则表达式,但子模式明确命名为 &quot;FOO&quot;。</target>
        </trans-unit>
        <trans-unit id="11609cf73bda34f9c32c6a76c718328a0992ccb9" translate="yes" xml:space="preserve">
          <source>Consider, for example, a server application under test. The following functionality is to be tested:</source>
          <target state="translated">例如,考虑一个被测试的服务器应用程序。需要测试的功能如下:</target>
        </trans-unit>
        <trans-unit id="d91f897bb6a72091261f7b531a2eb9e3cb354e53" translate="yes" xml:space="preserve">
          <source>Consider, for example, the pattern \d+foo when applied to the following subject line:</source>
          <target state="translated">例如,当应用于以下主题行时,请考虑模式 &quot;d/d+foo&quot;。</target>
        </trans-unit>
        <trans-unit id="fad23a16477e328da2bd8980efb7502b447bd6f6" translate="yes" xml:space="preserve">
          <source>Considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">将缺失的头文件视为生成的文件,并将其添加到依赖关系中。</target>
        </trans-unit>
        <trans-unit id="0ea7b95eab5fbd65070ee5e58e3789c399ad441a" translate="yes" xml:space="preserve">
          <source>Consistency</source>
          <target state="translated">Consistency</target>
        </trans-unit>
        <trans-unit id="2416d42d8d26094930f52fe782ef8c3d55df4f05" translate="yes" xml:space="preserve">
          <source>Consistency checking between MIBs</source>
          <target state="translated">MIB之间的一致性检查</target>
        </trans-unit>
        <trans-unit id="e0b3cee1e82b80ed946d9b0b76f2ee5162f5b5c9" translate="yes" xml:space="preserve">
          <source>Const ::= AtomConst | FunSpec | MFA</source>
          <target state="translated">Const ::=AtomConst | FunSpec | MFA</target>
        </trans-unit>
        <trans-unit id="5cfb1e6566be91ced8a40ddff4da8a615174e201" translate="yes" xml:space="preserve">
          <source>Constant ::= Call | Const</source>
          <target state="translated">Constant ::=Call | Const</target>
        </trans-unit>
        <trans-unit id="1bafe97bb00638010937d06443d9bc18d9b3329f" translate="yes" xml:space="preserve">
          <source>Constant ::= {&lt;code&gt;const&lt;/code&gt;, term()}</source>
          <target state="translated">常量:: = { &lt;code&gt;const&lt;/code&gt; ，term（）}</target>
        </trans-unit>
        <trans-unit id="221ceea8aad6c96db9f85e13a30e3778298ff5d5" translate="yes" xml:space="preserve">
          <source>Constant Erlang terms (also called &lt;strong&gt;literals&lt;/strong&gt;) are kept in constant pools; each loaded module has its own pool. The following function does not build the tuple every time it is called (only to have it discarded the next time the garbage collector was run), but the tuple is located in the module's constant pool:</source>
          <target state="translated">常量Erlang术语（也称为&lt;strong&gt;文字&lt;/strong&gt;）保存在常量池中；每个加载的模块都有其自己的池。以下函数不会在每次调用时生成元组（只是在下次运行垃圾收集器时将其丢弃），但是元组位于模块的常量池中：</target>
        </trans-unit>
        <trans-unit id="18f2cafbf9301a8d594f4c411a820d1a97052f9d" translate="yes" xml:space="preserve">
          <source>Constant Pool</source>
          <target state="translated">恒定池</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="e20076a802d4d6fed29c34dfbbd095f1a4303bb6" translate="yes" xml:space="preserve">
          <source>Constants (atoms, integer, floats, lists, tuples, records, binaries, and maps)</source>
          <target state="translated">常量(原子、整数、浮点数、列表、元组、记录、二值和地图)。</target>
        </trans-unit>
        <trans-unit id="b9002264e3b8be0e5a771c041655682c3c04890d" translate="yes" xml:space="preserve">
          <source>Constants ::= Consts | Consts &lt;code&gt;:&lt;/code&gt; Type | RegExpr</source>
          <target state="translated">常量:: =常量| Consts &lt;code&gt;:&lt;/code&gt; 类型| 正则表达式</target>
        </trans-unit>
        <trans-unit id="34f461426e164418878dde5aeb8fb12763014553" translate="yes" xml:space="preserve">
          <source>Constants can well replace term &lt;code&gt;node&lt;/code&gt; also, but this still has a declarative value, mainly when used in combination with &lt;code&gt;NodeRefs == all_nodes&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#types&quot;&gt;Types&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">常量也可以很好地代替term &lt;code&gt;node&lt;/code&gt; ，但是它仍然具有声明性值，主要是与 &lt;code&gt;NodeRefs == all_nodes&lt;/code&gt; 结合使用时（请参见 &lt;code&gt;&lt;a href=&quot;#types&quot;&gt;Types&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21be61b96cffe6ca7b1165136773aecc5eaa2360" translate="yes" xml:space="preserve">
          <source>Constants make the test specification term &lt;code&gt;alias&lt;/code&gt;, in previous versions of &lt;code&gt;Common Test&lt;/code&gt;, redundant. This term is deprecated but remains supported in upcoming &lt;code&gt;Common Test&lt;/code&gt; releases. Replacing &lt;code&gt;alias&lt;/code&gt; terms with &lt;code&gt;define&lt;/code&gt; is strongly recommended though. An example of such replacement follows:</source>
          <target state="translated">常量使测试规范术语 &lt;code&gt;alias&lt;/code&gt; （在先前版本的 &lt;code&gt;Common Test&lt;/code&gt; 中）变得多余。该术语已弃用，但在即将推出的 &lt;code&gt;Common Test&lt;/code&gt; 版本中仍受支持。但是，强烈建议使用 &lt;code&gt;define&lt;/code&gt; 替换 &lt;code&gt;alias&lt;/code&gt; 。此类替换的示例如下：</target>
        </trans-unit>
        <trans-unit id="8a5e37085481b760804cbc7b5cc4fd93c4883fa7" translate="yes" xml:space="preserve">
          <source>Construct a megaco_receive_handle record from user config</source>
          <target state="translated">从用户配置中构建一个megaco_receive_handle记录。</target>
        </trans-unit>
        <trans-unit id="729a559814639c65233d1bc9939910a711214293" translate="yes" xml:space="preserve">
          <source>Construct a megaco_receive_handle record.</source>
          <target state="translated">构造一个megaco_receive_handle记录。</target>
        </trans-unit>
        <trans-unit id="080d00f2a1b4ab0493444768788667c25f4a433b" translate="yes" xml:space="preserve">
          <source>Constructing a new map is done by letting an expression &lt;code&gt;K&lt;/code&gt; be associated with another expression &lt;code&gt;V&lt;/code&gt;:</source>
          <target state="translated">通过让表达式 &lt;code&gt;K&lt;/code&gt; 与另一个表达式 &lt;code&gt;V&lt;/code&gt; 关联来构造新的映射：</target>
        </trans-unit>
        <trans-unit id="5e0cb8439a00ff66a080d006db256cf4251bb30c" translate="yes" xml:space="preserve">
          <source>Constructing new instructions on the right side</source>
          <target state="translated">在右侧构建新的指令</target>
        </trans-unit>
        <trans-unit id="6f9ebd028f2b393c1489cd50c343fd65cf6291a5" translate="yes" xml:space="preserve">
          <source>Constructs a new binary by replacing the parts in &lt;code&gt;Subject&lt;/code&gt; matching &lt;code&gt;Pattern&lt;/code&gt; with the content of &lt;code&gt;Replacement&lt;/code&gt;.</source>
          <target state="translated">通过将 &lt;code&gt;Subject&lt;/code&gt; 匹配 &lt;code&gt;Pattern&lt;/code&gt; 中的部分 &lt;code&gt;Replacement&lt;/code&gt; 为替换内容来构造新的二进制文件。</target>
        </trans-unit>
        <trans-unit id="e29f3b3c5fb6da2bad84eb33811c5a8e702e13db" translate="yes" xml:space="preserve">
          <source>Constructs an abstract list skeleton. The result has type &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If &lt;code&gt;List&lt;/code&gt; is a nonempty list &lt;code&gt;[E1, ..., En]&lt;/code&gt;, the result has type &lt;code&gt;list&lt;/code&gt; and represents either &quot;&lt;code&gt;[E1, ..., En]&lt;/code&gt;&quot;, if &lt;code&gt;Tail&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, or otherwise &quot;&lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt;&quot;. If &lt;code&gt;List&lt;/code&gt; is the empty list, &lt;code&gt;Tail&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;none&lt;/code&gt;, and in that case the result has type &lt;code&gt;nil&lt;/code&gt; and represents &quot;&lt;code&gt;[]&lt;/code&gt;&quot; (see &lt;code&gt;&lt;a href=&quot;#nil-0&quot;&gt;nil/0&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">构造一个抽象列表框架。结果的类型为 &lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; 。如果 &lt;code&gt;List&lt;/code&gt; 是非空列表 &lt;code&gt;[E1, ..., En]&lt;/code&gt; ，则结果具有类型 &lt;code&gt;list&lt;/code&gt; 并且如果 &lt;code&gt;Tail&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; ，则表示&amp;ldquo; &lt;code&gt;[E1, ..., En]&lt;/code&gt; &amp;rdquo;，否则为&amp;ldquo; &lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt; &amp;rdquo;。如果 &lt;code&gt;List&lt;/code&gt; 是空列表，则 &lt;code&gt;Tail&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt;为 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，结果的类型为 &lt;code&gt;nil&lt;/code&gt; 并表示&amp;ldquo; &lt;code&gt;[]&lt;/code&gt; &amp;rdquo;（请参见 &lt;code&gt;&lt;a href=&quot;#nil-0&quot;&gt;nil/0&lt;/a&gt;&lt;/code&gt; ）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c1bd0529d6b40d4b62e4277842d1853cd4eb139" translate="yes" xml:space="preserve">
          <source>Consts ::= Constant | &lt;code&gt;[&lt;/code&gt;Constant&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt; | &lt;code&gt;{&lt;/code&gt;Constant&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">常量:: =常量| &lt;code&gt;[&lt;/code&gt; 常数 &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;]&lt;/code&gt; | &lt;code&gt;{&lt;/code&gt; 常数 &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39992774518c9fff46f13d958f364c2a177e12dd" translate="yes" xml:space="preserve">
          <source>Consumed by &lt;code&gt;&lt;a href=&quot;#next-1&quot;&gt;maps:next/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;maps:filter/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;maps:fold/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;maps:map/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#next-1&quot;&gt;maps:next/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#filter-2&quot;&gt;maps:filter/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;maps:fold/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#map-2&quot;&gt;maps:map/2&lt;/a&gt;&lt;/code&gt; 消耗。</target>
        </trans-unit>
        <trans-unit id="b920c3a03e725c9d61f35dce2d6a6eca4e7f8c8f" translate="yes" xml:space="preserve">
          <source>Consuming a URI containing percent-encoded triplets can take many steps. The following example shows how to handle an input URI that is not normalized and contains multiple percent-encoded triplets. First, the input &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; is to be parsed into a &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt;. The parsing only splits the URI into its components without doing any decoding:</source>
          <target state="translated">使用包含百分比编码的三元组的URI可能需要很多步骤。下面的示例演示如何处理未规范化的输入URI，该输入URI包含多个百分比编码的三元组。首先，将输入 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 解析为 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 。解析仅将URI分成其组件，而不进行任何解码：</target>
        </trans-unit>
        <trans-unit id="0e2fed826e8d11841c46e6f1e7451ec0fc8a31bc" translate="yes" xml:space="preserve">
          <source>Contacts the &lt;code&gt;epmd&lt;/code&gt; listening on the specified TCP port number (default 4369). This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">联系监听指定TCP端口号的 &lt;code&gt;epmd&lt;/code&gt; （默认值为 4369）。也可以使用环境变量 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 进行设置；请参阅 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 一节。</target>
        </trans-unit>
        <trans-unit id="6d418a206c8b5fc2a7fb5cc7d0c97c6096d675e8" translate="yes" xml:space="preserve">
          <source>Contains a list of additional library directories that the code server searches for applications and adds to the code path; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">包含代码库搜索应用程序并将其添加到代码路径的其他库目录的列表；参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20db3f99344de7dc045e4e80f4e3b33db4b93cd7" translate="yes" xml:space="preserve">
          <source>Contains a menu item for each open Debugger window. Selecting one of the items raises the corresponding window.</source>
          <target state="translated">包含每个打开的调试器窗口的菜单项。选择其中一个项目会引发相应的窗口。</target>
        </trans-unit>
        <trans-unit id="800cc7c747ed734c3bd2436ca1facd3a4a3339c0" translate="yes" xml:space="preserve">
          <source>Contains the function arguments passed to the NIF.</source>
          <target state="translated">包含传递给NIF的函数参数。</target>
        </trans-unit>
        <trans-unit id="8a6cf6761af3cc1e8f4d362dab65afa469817b97" translate="yes" xml:space="preserve">
          <source>Content = [Element]</source>
          <target state="translated">内容=[元素]</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="8c8c410b4730be3fa7570f8567cda07ab85717c1" translate="yes" xml:space="preserve">
          <source>Contexts with an internal state that should not be manipulated but passed between function calls.</source>
          <target state="translated">具有内部状态的上下文,不应该被操作,而是在函数调用之间传递。</target>
        </trans-unit>
        <trans-unit id="4bc28ecdc9f36671383cecd55edcb0d089e248e6" translate="yes" xml:space="preserve">
          <source>Contextual errors - If API functions are used in the wrong context, the &lt;code&gt;Reason&lt;/code&gt; in the error tuple will be a descriptive atom. For instance if you try to call the function &lt;code&gt;last/[1,2]&lt;/code&gt; without first calling &lt;code&gt;select_count/[2,3]&lt;/code&gt; to associate a result set with the connection. If the ODBC-driver does not support some functions, or if you disabled some functionality for a connection and then try to use it.</source>
          <target state="translated">上下文错误-如果在错误的上下文中使用API​​函数，则错误元组中的 &lt;code&gt;Reason&lt;/code&gt; 将是描述性原子。例如，如果您尝试调用函数 &lt;code&gt;last/[1,2]&lt;/code&gt; 而不先调用 &lt;code&gt;select_count/[2,3]&lt;/code&gt; 将结果集与连接相关联。如果ODBC驱动程序不支持某些功能，或者您为连接禁用了某些功能，然后尝试使用它。</target>
        </trans-unit>
        <trans-unit id="070764532b4de17830b5b69712f55feaff04ff9a" translate="yes" xml:space="preserve">
          <source>Continuation = (&lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-context&quot;&gt;context()&lt;/a&gt;&lt;/code&gt;) -&amp;gt; &lt;code&gt;&lt;a href=&quot;prettypr#type-document&quot;&gt;prettypr:document()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Continuation =（ &lt;code&gt;&lt;a href=&quot;#type-syntaxTree&quot;&gt;syntaxTree()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-context&quot;&gt;context()&lt;/a&gt;&lt;/code&gt; ）-&amp;gt; &lt;code&gt;&lt;a href=&quot;prettypr#type-document&quot;&gt;prettypr:document()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e03e8eebfab40a4fd9be2718ad485476abef0bd3" translate="yes" xml:space="preserve">
          <source>Continuation returned by &lt;code&gt;open/1,2&lt;/code&gt; or &lt;code&gt;chunk/1,2&lt;/code&gt;.</source>
          <target state="translated">继续由 &lt;code&gt;open/1,2&lt;/code&gt; 或 &lt;code&gt;chunk/1,2&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="091fbe1ad605666c6170536967f53980c001530f" translate="yes" xml:space="preserve">
          <source>Continue the SSL/TLS handshake possiby with new, additional or changed options.</source>
          <target state="translated">继续进行SSL/TLS握手,可以使用新的、附加的或改变的选项。</target>
        </trans-unit>
        <trans-unit id="c36cec59175b4924eb232c04762cff854c28eb3b" translate="yes" xml:space="preserve">
          <source>Continue the TLS handshake possiby with new, additional or changed options.</source>
          <target state="translated">用新的、附加的或改变的选项继续进行TLS握手。</target>
        </trans-unit>
        <trans-unit id="f105f8dee43358db799a59af5e9759b95ef60124" translate="yes" xml:space="preserve">
          <source>Continue the traversal and accumulate &lt;code&gt;Val&lt;/code&gt;. The following function is supplied to collect all objects of a table in a list:</source>
          <target state="translated">继续遍历并累积 &lt;code&gt;Val&lt;/code&gt; 。提供以下功能来收集列表中表的所有对象：</target>
        </trans-unit>
        <trans-unit id="fec4067a3f18b3c51fe634a426bc57ca6d7ece02" translate="yes" xml:space="preserve">
          <source>Continue to perform the traversal. For example, the following function can be used to print the contents of a table:</source>
          <target state="translated">继续执行遍历。例如,下面的功能可以用来打印表格的内容。</target>
        </trans-unit>
        <trans-unit id="c63ee0550edcb4c377c408f4d3f3eb757e2e5c77" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;match/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">继续以 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 开始的比赛。初始 &lt;code&gt;match/3&lt;/code&gt; 调用中指定的下一个大小块将与新的 &lt;code&gt;Continuation&lt;/code&gt; 一起返回，该新Continuation可在后续对该函数的调用中使用。</target>
        </trans-unit>
        <trans-unit id="221675e363c83fa1b19e54f0bc32768b67b07030" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;match_object/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">继续以 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; 开始的比赛。初始 &lt;code&gt;match_object/3&lt;/code&gt; 调用中指定的下一个大小块将与新的 &lt;code&gt;Continuation&lt;/code&gt; 一起返回，该新Continuation可以在后续对该函数的调用中使用。</target>
        </trans-unit>
        <trans-unit id="73c4a5596193700b0e1ff38275cce559943a7265" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;. The next chunk of the size specified in the initial &lt;code&gt;select/3&lt;/code&gt; call is returned together with a new &lt;code&gt;Continuation&lt;/code&gt;, which can be used in subsequent calls to this function.</source>
          <target state="translated">继续以 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 开始的比赛。在初始 &lt;code&gt;select/3&lt;/code&gt; 调用中指定的下一个大小块将与新的 &lt;code&gt;Continuation&lt;/code&gt; 一起返回，该新Continuation可以在此函数的后续调用中使用。</target>
        </trans-unit>
        <trans-unit id="e0fa645328109d154f1b0ff83c174bc21403d328" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt; select_reverse/3&lt;/a&gt;&lt;/code&gt;. For tables of type &lt;code&gt;ordered_set&lt;/code&gt;, the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">继续以 &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt; select_reverse/3&lt;/a&gt;&lt;/code&gt; 开始的比赛。对于 &lt;code&gt;ordered_set&lt;/code&gt; 类型的表，该表的遍历继续进行到具有Erlang术语顺序中前面的键的对象。返回的列表还包含带有相反顺序键的对象。对于所有其他表类型，其行为与 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="058b95d57ca8bcafbb27b235c4372981f494e185" translate="yes" xml:space="preserve">
          <source>Continues a match started with &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt;select_reverse/3&lt;/a&gt;&lt;/code&gt;. For tables of type &lt;code&gt;ordered_set&lt;/code&gt;, the traversal of the table continues to objects with keys earlier in the Erlang term order. The returned list also contains objects with keys in reverse order. For all other table types, the behavior is exactly that of &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">继续以 &lt;code&gt;&lt;a href=&quot;#select_reverse-3&quot;&gt;select_reverse/3&lt;/a&gt;&lt;/code&gt; 开始的比赛。对于 &lt;code&gt;ordered_set&lt;/code&gt; 类型的表，该表的遍历继续进行到具有Erlang术语顺序中较早键的对象。返回的列表还包含具有相反顺序键的对象。对于所有其他表类型，其行为与 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="8990bdea87bba1599cb1fdcf1951a0e63de9aab9" translate="yes" xml:space="preserve">
          <source>Continues computing the adler32 checksum by combining the previous checksum, &lt;code&gt;OldAdler&lt;/code&gt;, with the checksum of &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">通过将先前的校验和 &lt;code&gt;OldAdler&lt;/code&gt; 与 &lt;code&gt;Data&lt;/code&gt; 的校验和相结合，继续计算adler32校验和。</target>
        </trans-unit>
        <trans-unit id="4996c9d2c0f3507c722df9afeb51e0b92b87a37f" translate="yes" xml:space="preserve">
          <source>Continues computing the crc32 checksum by combining the previous checksum, &lt;code&gt;OldCrc&lt;/code&gt;, with the checksum of &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">通过将先前的校验和 &lt;code&gt;OldCrc&lt;/code&gt; 与 &lt;code&gt;Data&lt;/code&gt; 的校验和相结合，继续计算crc32校验和。</target>
        </trans-unit>
        <trans-unit id="da1ef0dedc7faef987b7a5a3deb0c768440cd306" translate="yes" xml:space="preserve">
          <source>Continues the execution until the current function returns.</source>
          <target state="translated">继续执行,直到当前函数返回。</target>
        </trans-unit>
        <trans-unit id="b9a0121ae80323caf5e3871d3094c46759575a34" translate="yes" xml:space="preserve">
          <source>Continues the execution.</source>
          <target state="translated">继续执行。</target>
        </trans-unit>
        <trans-unit id="60ebcff772231040684a03eaac59ec0ef5b0efaf" translate="yes" xml:space="preserve">
          <source>Continuing the dialogue with the Erlang shell produces the following:</source>
          <target state="translated">继续与Erlang shell对话会产生以下结果。</target>
        </trans-unit>
        <trans-unit id="550a49346d51f6c69177d23de6582bd904a644a5" translate="yes" xml:space="preserve">
          <source>Continuing the example from the previous section, the three nodes are started, specifying the system configuration file:</source>
          <target state="translated">继续上节的例子,启动三个节点,指定系统配置文件。</target>
        </trans-unit>
        <trans-unit id="154943d578744b27e5c0e12560a0ba0b4d4c5ec5" translate="yes" xml:space="preserve">
          <source>Contrary to the fact with &quot;handwritten&quot; match specifications, the &lt;code&gt;is_record&lt;/code&gt; guard works as in ordinary Erlang code.</source>
          <target state="translated">与&amp;ldquo;手写&amp;rdquo;匹配规范相反， &lt;code&gt;is_record&lt;/code&gt; 保护的工作方式与普通的Erlang代码相同。</target>
        </trans-unit>
        <trans-unit id="ea1d3df298ca84104dbf8b2f6f916c02f6f77c6e" translate="yes" xml:space="preserve">
          <source>Control</source>
          <target state="translated">Control</target>
        </trans-unit>
        <trans-unit id="046e85c2c64b10ec2f7a5a0972a793a917f581c6" translate="yes" xml:space="preserve">
          <source>Control A to control Z</source>
          <target state="translated">控制A来控制Z</target>
        </trans-unit>
        <trans-unit id="bce115b0c925643288d6d66089149032ada8c603" translate="yes" xml:space="preserve">
          <source>Control characters</source>
          <target state="translated">控制字符</target>
        </trans-unit>
        <trans-unit id="1bd11088990a2634cb50a4cfec1f5eac588c67e2" translate="yes" xml:space="preserve">
          <source>Control sequences, which have the general format &lt;code&gt;~*FMC&lt;/code&gt;, where:</source>
          <target state="translated">控制序列，其一般格式为 &lt;code&gt;~*FMC&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="ffca644d69cdda7bca9ab35919dc344a16cd88cb" translate="yes" xml:space="preserve">
          <source>Control the timer that a driver can use. The timer has the emulator call the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; entry function after a specified time. Only one timer is available for each driver instance.</source>
          <target state="translated">控制驱动程序可以使用的计时器。计时器让仿真器在指定时间后调用 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; 输入功能。每个驱动程序实例只有一个计时器可用。</target>
        </trans-unit>
        <trans-unit id="d30fd30f66df6d80482e65684b05e8c7c4bc0bb4" translate="yes" xml:space="preserve">
          <source>Control the timer that a driver can use. The timer has the emulator call the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; entry function after a specified time. Only one timer is available for each driver instance.</source>
          <target state="translated">控制驱动程序可以使用的计时器。计时器让仿真器在指定时间后调用 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 输入功能。每个驱动程序实例只有一个计时器可用。</target>
        </trans-unit>
        <trans-unit id="eeaa2647da0732597913d53570b365738ee8b070" translate="yes" xml:space="preserve">
          <source>Controlling Bursts of Log Requests</source>
          <target state="translated">控制突发的日志请求</target>
        </trans-unit>
        <trans-unit id="5f8185b4b9e44a4d0b11e748fbfb331ea2dacd6c" translate="yes" xml:space="preserve">
          <source>Controlling the Discrepancies Reported by Dialyzer</source>
          <target state="translated">控制拨号器报告的差异性</target>
        </trans-unit>
        <trans-unit id="3304568e9e0e1543499ce0803d55dd51136c2a1c" translate="yes" xml:space="preserve">
          <source>ControllingEntity :: port() | pid()}</source>
          <target state="translated">ControllingEntity ::port()| pid()}。</target>
        </trans-unit>
        <trans-unit id="1d39ae8d696d2ab79619e780f95f15abc4711971" translate="yes" xml:space="preserve">
          <source>Controls how many reports &lt;code&gt;rb_server&lt;/code&gt; is to read at startup. This option is useful, as the directory can contain a large amount of reports. If this option is specified, the &lt;code&gt;MaxNoOfReports&lt;/code&gt; latest reports are read. Default is &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">控制启动时要读取的报告 &lt;code&gt;rb_server&lt;/code&gt; 的数量。此选项很有用，因为该目录可以包含大量报告。如果指定此选项，则读取 &lt;code&gt;MaxNoOfReports&lt;/code&gt; 最新报告。默认为 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d569f69f912af29157becf380c027c33c514e56" translate="yes" xml:space="preserve">
          <source>Controls if and how schedulers are bound to logical processors.</source>
          <target state="translated">控制调度器是否以及如何与逻辑处理器绑定。</target>
        </trans-unit>
        <trans-unit id="c4c206d13c1cf477fffe7e0fbace2e00e092dbe0" translate="yes" xml:space="preserve">
          <source>Controls the level of debug printouts. Default is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">控制调试打印输出的级别。默认为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f467f08eaae850725a566433bcae52e439e5302a" translate="yes" xml:space="preserve">
          <source>Controls the number of log files written before older files are reused. Defaults to 5, minimum is 2, maximum is 1000.</source>
          <target state="translated">控制在重用旧文件之前写入的日志文件的数量,默认为5,最小为2,最大为1000。默认为5,最小为2,最大为1000。</target>
        </trans-unit>
        <trans-unit id="2caaa1a4bcd099e84cf653002bba67518b149f50" translate="yes" xml:space="preserve">
          <source>Controls what kind of reports &lt;code&gt;rb_server&lt;/code&gt; is to read at startup. &lt;code&gt;ReportType&lt;/code&gt; is a supported type, &lt;code&gt;all&lt;/code&gt;, or a list of supported types. Default is &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">控制启动时读取 &lt;code&gt;rb_server&lt;/code&gt; 的报告类型。 &lt;code&gt;ReportType&lt;/code&gt; 是受支持的类型， &lt;code&gt;all&lt;/code&gt; 或受支持类型的列表。默认为 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78f7ae24acbeb3e89d74388b0c043f4636b4e000" translate="yes" xml:space="preserve">
          <source>Controls what types of files to be compressed. Defaults to &lt;code&gt;all&lt;/code&gt;. The following values of &lt;code&gt;What&lt;/code&gt; are allowed:</source>
          <target state="translated">控制要压缩的文件类型。默认为 &lt;code&gt;all&lt;/code&gt; 。以下值 &lt;code&gt;What&lt;/code&gt; 是允许的：</target>
        </trans-unit>
        <trans-unit id="3fcba1873e0dd51f27a814aa230b6082f568ea52" translate="yes" xml:space="preserve">
          <source>Controls what types of files to be uncompressed. Defaults to &lt;code&gt;[&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;]&lt;/code&gt;. The following values of &lt;code&gt;What&lt;/code&gt; are allowed:</source>
          <target state="translated">控制要解压缩的文件类型。默认为 &lt;code&gt;[&quot;.Z&quot;, &quot;.zip&quot;, &quot;.zoo&quot;, &quot;.arc&quot;, &quot;.lzh&quot;, &quot;.arj&quot;]&lt;/code&gt; 。lzh&amp;rdquo;，&amp;ldquo;。arj&amp;rdquo;]。以下值 &lt;code&gt;What&lt;/code&gt; 是允许的：</target>
        </trans-unit>
        <trans-unit id="72d4d021ee27a02ab04e242eb179eea92a205773" translate="yes" xml:space="preserve">
          <source>Controls whether to behave as a namespace conformant XML parser, 'false' (default) to not otherwise 'true'.</source>
          <target state="translated">控制是否作为一个符合命名空间的XML解析器,'false'(默认),否则为'true'。</target>
        </trans-unit>
        <trans-unit id="014f53bfb51da0f31d7ad874005aae30ff2fdae7" translate="yes" xml:space="preserve">
          <source>Controls whether to process as a validating XML parser: 'off' (default) no validation, or validation 'dtd' by DTD or 'schema' by XML Schema. 'false' and 'true' options are obsolete (i.e. they may be removed in a future release), if used 'false' equals 'off' and 'true' equals 'dtd'.</source>
          <target state="translated">控制是否以验证性XML解析器的方式进行处理,'off'(默认)不验证,或通过DTD验证'dtd'或通过XML Schema验证'schema'。'off'(默认)不进行验证,或通过DTD进行验证'dtd'或通过XML Schema进行验证'schema'。'false'和'true'选项已经过时(即在未来的版本中可能会被删除),如果使用'false'等于'off','true'等于'dtd'。</target>
        </trans-unit>
        <trans-unit id="a3bb7bd3cd29a5c3a6c03c82349c51e51bf95ff6" translate="yes" xml:space="preserve">
          <source>Controls which features to reject. This is mostly useful for the server as it can restrict the use of certain TFTP options or read/write access.</source>
          <target state="translated">控制拒绝哪些功能。这对于服务器来说是非常有用的,因为它可以限制某些TFTP选项的使用或读/写访问。</target>
        </trans-unit>
        <trans-unit id="1c4be7e6e4f92b537985118ffae61f13674d390a" translate="yes" xml:space="preserve">
          <source>Convenience functions</source>
          <target state="translated">便利功能</target>
        </trans-unit>
        <trans-unit id="5c1d5aa10fc30b8ff720235b29bc6f6835f69529" translate="yes" xml:space="preserve">
          <source>Convenience functions for microstate accounting</source>
          <target state="translated">微观国家会计的便利功能</target>
        </trans-unit>
        <trans-unit id="8ce25c173c335f61eac029ac12bf1102e9bcacfb" translate="yes" xml:space="preserve">
          <source>Convenience functions for some common name lookup functions.</source>
          <target state="translated">一些常用名称查询功能的便利功能。</target>
        </trans-unit>
        <trans-unit id="697e08358094ab2a49005b63006ea40b28418bea" translate="yes" xml:space="preserve">
          <source>Convenient to be used from the command line (erl -s et_viewer).</source>
          <target state="translated">方便在命令行中使用(erl -s et_viewer)。</target>
        </trans-unit>
        <trans-unit id="82972fa0f197d3cff3b3cec5ebfaa62f25d5f57a" translate="yes" xml:space="preserve">
          <source>Conventions Used in This Document</source>
          <target state="translated">本文件中使用的约定</target>
        </trans-unit>
        <trans-unit id="8d2687667dee08113bf89108622393aba24f20fa" translate="yes" xml:space="preserve">
          <source>Conversion of data between C and Erlang formats</source>
          <target state="translated">C和Erlang格式之间的数据转换</target>
        </trans-unit>
        <trans-unit id="a7637a6e621da70105c089476553bfc5d74a542a" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;Raw Trace Data&lt;/code&gt; into an appropriate &lt;code&gt;Event&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;Raw Trace Data&lt;/code&gt; 转换为适当的 &lt;code&gt;Event&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fdde520c3a3d433579d6c33b3e490f3ec80c4b5" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;RefURI&lt;/code&gt; reference that might be relative to a given base URI into the parsed components of the reference's target, which can then be recomposed to form the target URI.</source>
          <target state="translated">将可能与给定基本URI相关的 &lt;code&gt;RefURI&lt;/code&gt; 引用转换为引用目标的已解析组件，然后可以将其重组以形成目标URI。</target>
        </trans-unit>
        <trans-unit id="99a05219f8c5c7b0532f80113a0dad96f501d271" translate="yes" xml:space="preserve">
          <source>Convert a log message on report form to &lt;code&gt;{Format, Args}&lt;/code&gt;. This is the default report callback used by &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; when no custom report callback is found. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for information about report callbacks and valid forms of log messages.</source>
          <target state="translated">将报告表单上的日志消息转换为 &lt;code&gt;{Format, Args}&lt;/code&gt; 。当未找到自定义报告回调时，这是 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt; logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 使用的默认报告回调。有关报告回调和有效形式的日志消息的 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; ，请参见《内核用户指南》中的&amp;ldquo;日志消息&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="1e08b6dbc72e0b9830476f0a00a81ef9d8b25c7b" translate="yes" xml:space="preserve">
          <source>Convert a log message on report form to &lt;code&gt;{Format, Args}&lt;/code&gt;. This is the default report callback used by &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter&lt;/a&gt;&lt;/code&gt; when no custom report callback is found. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for information about report callbacks and valid forms of log messages.</source>
          <target state="translated">将报告表单上的日志消息转换为 &lt;code&gt;{Format, Args}&lt;/code&gt; 。当找不到自定义报告回调时，这是 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter&lt;/a&gt;&lt;/code&gt; 使用的默认报告回调。有关报告回调和有效形式的日志消息的 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; ，请参见《内核用户指南》中的&amp;ldquo;日志消息&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0f555788b20b5f7be0fc65347cd28b0e5580c6e4" translate="yes" xml:space="preserve">
          <source>Convert a token tag to a string</source>
          <target state="translated">将标记转换为字符串</target>
        </trans-unit>
        <trans-unit id="044a64115586f4d31170517f8714ccd4f18c3c87" translate="yes" xml:space="preserve">
          <source>Convert an IPv4 address to an IPv4-mapped IPv6 address or the reverse. When converting from an IPv6 address all but the 2 low words are ignored so this function also works on some other types of addresses than IPv4-mapped.</source>
          <target state="translated">将IPv4地址转换为IPv4映射的IPv6地址,或者反之。当从IPv6地址转换时,除了2个低字外,其他所有的地址都会被忽略,所以这个功能也适用于一些其他类型的地址,而不是IPv4映射的地址。</target>
        </trans-unit>
        <trans-unit id="85648e18f68f2ea31b9073f5d647f354e9027d9e" translate="yes" xml:space="preserve">
          <source>Convert binary representation, of an integer, to an Erlang integer.</source>
          <target state="translated">将一个整数的二进制表示法转换为Erlang整数。</target>
        </trans-unit>
        <trans-unit id="19f5c5b5e2440fd1432aaad4d1dccfb67de8582b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; to OpenSSL name string.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; 转换为OpenSSL名称字符串。</target>
        </trans-unit>
        <trans-unit id="00d1f5a857dbd91b22c2e606f74ae73b3d9ca632" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; to RFC name string.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;#type-erl_cipher_suite&quot;&gt;erl_cipher_suite()&lt;/a&gt;&lt;/code&gt; 转换为RFC名称字符串。</target>
        </trans-unit>
        <trans-unit id="12bd127af4ad25815294c36888f6e3b3cb5271a2" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Key&lt;/code&gt; to an OBJECT IDENTIFIER.</source>
          <target state="translated">将 &lt;code&gt;Key&lt;/code&gt; 转换为对象标识符。</target>
        </trans-unit>
        <trans-unit id="64acc9e991da9583e9d8988fd1ae350af1f7d94a" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Path&lt;/code&gt; to a form accepted by the command shell and native applications on the current platform. On Windows, forward slashes are converted to backward slashes. On all platforms, the name is normalized as done by &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Path&lt;/code&gt; 转换为命令Shell和当前平台上的本机应用程序接受的格式。在Windows上，正斜杠将转换为反斜杠。在所有平台上，名称均通过 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; 进行归一化。</target>
        </trans-unit>
        <trans-unit id="ea3719a7fe934bac8263241169003d73b077c876" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to a case-agnostic comparable string. Function &lt;code&gt;casefold/1&lt;/code&gt; is preferred over &lt;code&gt;lowercase/1&lt;/code&gt; when two strings are to be compared for equality. See also &lt;code&gt;&lt;a href=&quot;#equal-4&quot;&gt;equal/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 转换为与大小写无关的可比较字符串。当要比较两个字符串是否相等时，函数 &lt;code&gt;casefold/1&lt;/code&gt; 优于 &lt;code&gt;lowercase/1&lt;/code&gt; 。另请参见 &lt;code&gt;&lt;a href=&quot;#equal-4&quot;&gt;equal/4&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83e6c836c0fe9bf44d0723384551fd211532d6a7" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to a list of grapheme clusters.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 转换为字素簇的列表。</target>
        </trans-unit>
        <trans-unit id="d925e32023288904ae94a121d00ca3faaf1f0cb6" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to lowercase.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 转换为小写。</target>
        </trans-unit>
        <trans-unit id="64e823d13feb3b6235edac36b29ebd1b351753fe" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to titlecase.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 转换为titlecase。</target>
        </trans-unit>
        <trans-unit id="40712f79e161abafd2f0cece5db1aa7f56d35ac2" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;String&lt;/code&gt; to uppercase.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 转换为大写。</target>
        </trans-unit>
        <trans-unit id="814be0b57ea4927c8c3826c53afee5e64f538f9e" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Subject&lt;/code&gt; to a list of &lt;code&gt;byte()&lt;/code&gt;s, each representing the value of one byte. &lt;code&gt;part()&lt;/code&gt; denotes which part of the &lt;code&gt;binary()&lt;/code&gt; to convert.</source>
          <target state="translated">将 &lt;code&gt;Subject&lt;/code&gt; 转换为一个 &lt;code&gt;byte()&lt;/code&gt; 列表，每个列表代表一个字节的值。 &lt;code&gt;part()&lt;/code&gt; 表示要转换 &lt;code&gt;binary()&lt;/code&gt; 的哪一部分。</target>
        </trans-unit>
        <trans-unit id="84357bb46ef942f3222928aff9a548ada141350b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; to pid &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt;. This function is only to be used when debugging.</source>
          <target state="translated">将 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;Y&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; 转换为pid &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 。此功能仅在调试时使用。</target>
        </trans-unit>
        <trans-unit id="e870de6673fb58678c90b76e38c40fdef81ef7e8" translate="yes" xml:space="preserve">
          <source>Converts Universal Time Coordinated (UTC) date and time to local date and time in the form &lt;code&gt;{{Year, Month, Day}, {Hour, Minute, Second}}&lt;/code&gt; if supported by the underlying OS. Otherwise no conversion is done, and &lt;code&gt;Universaltime&lt;/code&gt; is returned. Example:</source>
          <target state="translated">如果基础操作系统支持 &lt;code&gt;{{Year, Month, Day}, {Hour, Minute, Second}}&lt;/code&gt; 的形式将世界标准时间（UTC）日期和时间转换为本地日期和时间。否则，不进行任何转换，并返回 &lt;code&gt;Universaltime&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="dfd120e608567bf8e0e047df635cd48870a704de" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a list of possible universal time(s). The universal time value on the same format as defined in calendar(3).</source>
          <target state="translated">将DateAndTime列表转换为可能的通用时间列表。通用时间值的格式与calendar(3)中定义的相同。</target>
        </trans-unit>
        <trans-unit id="be2ab7a898419e8c5bc5fb6864e946862fab27d5" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a printable string, according to the DISPLAY-HINT definition in RFC2579, with the extension that it also allows the values &quot;hours from UTC&quot; = 14 together with &quot;minutes from UTC&quot; = 0.</source>
          <target state="translated">根据RFC2579中的DISPLAY-HINT定义,将DateAndTime列表转换为可打印的字符串,并扩展到允许 &quot;从UTC开始的小时&quot;=14和 &quot;从UTC开始的分钟&quot;=0。</target>
        </trans-unit>
        <trans-unit id="6e6041bd2c7a5e4ff13a4f7ea74a578cac2bcdd0" translate="yes" xml:space="preserve">
          <source>Converts a DateAndTime list to a printable string, according to the DISPLAY-HINT definition in RFC2579.</source>
          <target state="translated">根据RFC2579中的DISPLAY-HINT定义,将DateAndTime列表转换为可打印的字符串。</target>
        </trans-unit>
        <trans-unit id="df82c9aad820e9aeb421a06ce9d86abf62090da6" translate="yes" xml:space="preserve">
          <source>Converts a POSIX error code to a string (by calling &lt;code&gt;erl_posix_msg:message/1&lt;/code&gt;).</source>
          <target state="translated">将POSIX错误代码转换为字符串（通过调用 &lt;code&gt;erl_posix_msg:message/1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7cb36a1d5c42c93d73e9a9490af62b196a3459ce" translate="yes" xml:space="preserve">
          <source>Converts a dictionary to a list representation.</source>
          <target state="translated">将字典转换为列表表示。</target>
        </trans-unit>
        <trans-unit id="5145233388e4e63192922244ccdc8aad08c100c4" translate="yes" xml:space="preserve">
          <source>Converts a line in an Apache-like configuration file to an &lt;code&gt;{Option, Value}&lt;/code&gt; tuple. Some more complex configuration options, such as &lt;code&gt;directory&lt;/code&gt; and &lt;code&gt;security_directory&lt;/code&gt;, create an accumulator. This function only needs clauses for the options implemented by this particular callback module.</source>
          <target state="translated">将类似Apache的配置文件中的行转换为 &lt;code&gt;{Option, Value}&lt;/code&gt; 元组。一些更复杂的配置选项（例如 &lt;code&gt;directory&lt;/code&gt; 和 &lt;code&gt;security_directory&lt;/code&gt; ）创建累加器。该函数仅需要该特定回调模块实现的选项子句。</target>
        </trans-unit>
        <trans-unit id="1ba2baaacb5bd1fa86bcae22233808d6f9af2ca7" translate="yes" xml:space="preserve">
          <source>Converts a list to an extendible array. &lt;code&gt;Default&lt;/code&gt; is used as the value for uninitialized entries of the array. If &lt;code&gt;List&lt;/code&gt; is not a proper list, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">将列表转换为可扩展数组。 &lt;code&gt;Default&lt;/code&gt; 值用作未初始化的数组条目的值。如果 &lt;code&gt;List&lt;/code&gt; 不是正确的列表，则调用失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46ccd780115ddb3db3a4fceec0e82dd6e0b6fc95" translate="yes" xml:space="preserve">
          <source>Converts a local time value to a list of possible DateAndTime list(s). The local time value on the same format as defined in calendar(3).</source>
          <target state="translated">将一个本地时间值转换为一个可能的DateAndTime列表(s)。本地时间值的格式与calendar(3)中定义的相同。</target>
        </trans-unit>
        <trans-unit id="0677e1933e311ee3ab43091b45e003180be5b30d" translate="yes" xml:space="preserve">
          <source>Converts a port handle to the Erlang term format, usable in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt; erl_drv_send_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将端口句柄转换为Erlang术语格式，可在 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt; erl_drv_send_term&lt;/a&gt;&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="1ed8f6dfcb33426ca4e1a7205c23417d3a9d60fa" translate="yes" xml:space="preserve">
          <source>Converts a port handle to the Erlang term format, usable in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt;erl_drv_send_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将端口句柄转换为Erlang术语格式，可在 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#erl_drv_send_term&quot;&gt;erl_drv_send_term&lt;/a&gt;&lt;/code&gt; 中使用。</target>
        </trans-unit>
        <trans-unit id="f1537e7dd396d1f3ae28bd863e00e7d4f2a0ff80" translate="yes" xml:space="preserve">
          <source>Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian.</source>
          <target state="translated">将一个正整数转换为二进制数字表示法中尽可能小的表示法,可以是大恩迪安,也可以是小恩迪安。</target>
        </trans-unit>
        <trans-unit id="4b06d2c3db2372af5cb08f262a3a235fead48580" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list filename consisting of characters and atoms into the corresponding flat string filename.</source>
          <target state="translated">将一个可能由字符和原子组成的深层列表文件名转换为相应的平面字符串文件名。</target>
        </trans-unit>
        <trans-unit id="bcdf5ec8404937f0cc26b604615b645a3d632e2c" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Composed characters according to the Unicode standard.</source>
          <target state="translated">根据Unicode标准,将一个可能很深的字符和二进制列表转换为规范化形式的等效合成字符。</target>
        </trans-unit>
        <trans-unit id="25cde6c5eb02ad4f574bba02ec1c6f1c1e5ac62f" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of canonical equivalent Decomposed characters according to the Unicode standard.</source>
          <target state="translated">根据Unicode标准,将一个可能很深的字符和二进制列表转换为规范化形式的等效分解字符。</target>
        </trans-unit>
        <trans-unit id="3756e2cde9505923edd4d4e14aa5e042f713b23b" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Composed characters according to the Unicode standard.</source>
          <target state="translated">根据Unicode标准,将一个可能很深的字符和二进制列表转换为兼容的等价合成字符的规范化形式。</target>
        </trans-unit>
        <trans-unit id="530b1c8ab020feea5c4599c3a34122f44f338da2" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of characters and binaries into a Normalized Form of compatibly equivalent Decomposed characters according to the Unicode standard.</source>
          <target state="translated">根据Unicode标准,将一个可能很深的字符和二进制列表转换为兼容的等价分解字符的归一化形式。</target>
        </trans-unit>
        <trans-unit id="eea7568b698b464020aabc3712d814408bd4a0f7" translate="yes" xml:space="preserve">
          <source>Converts a possibly deep list of integers and binaries into a list of integers representing Unicode characters. The binaries in the input can have characters encoded as one of the following:</source>
          <target state="translated">将一个可能很深的整数和二进制列表转换为一个代表Unicode字符的整数列表。输入中的二进制字符可以有以下一种编码。</target>
        </trans-unit>
        <trans-unit id="24b7abb99fbb61c37725003b7ae6ea6832706f64" translate="yes" xml:space="preserve">
          <source>Converts a relative &lt;code&gt;Filename&lt;/code&gt; and returns an absolute name. No attempt is made to create the shortest absolute name, as this can give incorrect results on file systems that allow links.</source>
          <target state="translated">转换相对 &lt;code&gt;Filename&lt;/code&gt; 并返回绝对名称。请勿尝试创建最短的绝对名称，因为这会在允许链接的文件系统上产生不正确的结果。</target>
        </trans-unit>
        <trans-unit id="671a1aeac87b27d23dd6ee2e34e272472de95a3a" translate="yes" xml:space="preserve">
          <source>Converts a specified number of seconds into days, hours, minutes, and seconds. &lt;code&gt;Time&lt;/code&gt; is always non-negative, but &lt;code&gt;Days&lt;/code&gt; is negative if argument &lt;code&gt;Seconds&lt;/code&gt; is.</source>
          <target state="translated">将指定的秒数转换为天，小时，分钟和秒。 &lt;code&gt;Time&lt;/code&gt; 始终是非负的，但是如果参数 &lt;code&gt;Seconds&lt;/code&gt; 是，则 &lt;code&gt;Days&lt;/code&gt; 是负的。</target>
        </trans-unit>
        <trans-unit id="ed3af2f954d658c30bda990c05b304fc42cc2658" translate="yes" xml:space="preserve">
          <source>Converts a specified system time into local date and time.</source>
          <target state="translated">将指定的系统时间转换为本地日期和时间。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
