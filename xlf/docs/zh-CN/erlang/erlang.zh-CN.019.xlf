<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;io_lib:format/2&lt;/code&gt; 时使用Arguments &lt;code&gt;Format&lt;/code&gt; 和 &lt;code&gt;Args&lt;/code&gt; 创建注释字符串。否则 &lt;code&gt;comment/2&lt;/code&gt; 的行为与 &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt; 函数相同。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="translated">左边的算术位移</target>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="translated">算术位XOR</target>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="translated">算术表达式</target>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="translated">算术： &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;div&lt;/code&gt; ， &lt;code&gt;rem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">Arity :: =数字| &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="translated">水平或垂直排列文档，以空格分隔。返回一个文档，该文档表示文档（非空）序列 &lt;code&gt;Docs&lt;/code&gt; 的两种备用布局，这样 &lt;code&gt;Docs&lt;/code&gt; 中的所有元素要么水平连接，并用空格字符分隔，要么所有元素垂直连接（无额外分隔）。</target>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="translated">以类似段落的布局排列文档。返回一个文档，该文档表示文档（非空）序列 &lt;code&gt;Docs&lt;/code&gt; 的所有可能的左对齐的类似段落的布局。 &lt;code&gt;Docs&lt;/code&gt; 中的元素在水平方向上用单个空格字符分隔，在垂直方向上用单个换行符分隔。第一个（如果有的话）之后的所有行都缩进到同一左列，其缩进由相对于 &lt;code&gt;Docs&lt;/code&gt; 中第一个元素的位置的可选 &lt;code&gt;Offset&lt;/code&gt; 参数指定。例如，偏移量为-4，可以生成以下布局，以表示表示数字0到15的文档列表：</target>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="translated">数组使用基于&lt;strong&gt;零&lt;/strong&gt;的索引。这是一个故意的设计选择，与其他Erlang数据结构（例如元组）不同。</target>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; ,但会影响肮脏的CPU调度程序。默认为 &lt;code&gt;short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; ,但会影响脏的IO调度程序。默认为 &lt;code&gt;short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; ,但会影响肮脏的CPU调度程序。默认为 &lt;code&gt;medium&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; ,但会影响脏的IO调度程序。默认为 &lt;code&gt;medium&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt; 一样，但原子必须存在。</target>
        </trans-unit>
        <trans-unit id="ca2f4a2b2d5f93cadaa314fdad3b64d75313bbcf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt; but for ciphers without IVs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; ，但是将搜索 &lt;code&gt;Subject&lt;/code&gt; 直到将其用尽，然后返回所有与 &lt;code&gt;Pattern&lt;/code&gt; 匹配的非重叠部分的列表（按顺序）。</target>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; ，但不发送 &lt;code&gt;hello&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ，但不发送 &lt;code&gt;hello&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="translated">由于 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;S'&lt;/code&gt; 仅取决于 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; ，因此这里描述的状态机是Mealy机（例如，参见Wikipedia文章&amp;ldquo; Mealy机&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="translated">由于&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 总是至少完成当前测试用例，因此使用 &lt;code&gt;duration&lt;/code&gt; 或 &lt;code&gt;until&lt;/code&gt; 指定的时间永远是不确定的。</target>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="translated">与 &lt;code&gt;binary_to_list/1&lt;/code&gt; 相同，但返回一个 &lt;code&gt;Binary&lt;/code&gt; 列表，该整数列表对应于Binary中从位置 &lt;code&gt;Start&lt;/code&gt; 到位置 &lt;code&gt;Stop&lt;/code&gt; 的字节。二进制文件中的位置从1开始编号。</target>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="translated">作为 &lt;code&gt;binary_to_term/1&lt;/code&gt; ，但采用以下选项：</target>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="translated">当 &lt;code&gt;init_per_testcase&lt;/code&gt; 和end_per_testcase与 &lt;code&gt;end_per_testcase&lt;/code&gt; 在同一Erlang进程上执行时，这些配置函数的打印输出将包含在测试用例日志文件中。</target>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="translated">当 &lt;code&gt;reload/2&lt;/code&gt; 等待重新加载发生时，行为不正确的过程会导致驱动程序未打开端口（或保持驱动程序已加载），从而可能导致无限等待重新加载。必须在要求重新加载的过程之外或通过将低级接口 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 与驱动程序监视器结合使用来提供超时。</target>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="translated">如 &lt;code&gt;{Unused,Binary}&lt;/code&gt; 其中 &lt;code&gt;Unused&lt;/code&gt; 表示多少尾随零位0-7是在至少显著字节未使用的 &lt;code&gt;Binary&lt;/code&gt; 。接受此格式作为编码功能的输入，如果已给出 &lt;code&gt;compact_bit_string&lt;/code&gt; ,则将 &lt;code&gt;BIT STRING&lt;/code&gt; 解码为该格式。</target>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="translated">由于 Erl_Interface 是以 Erlang 外部术语格式运行的,因此必须将 port 设置为使用二进制文件。</target>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="translated">由于Erlang有固定数量的类型,程序员没有必要为某些应用程序内使用的外部格式定义规范。所有的Erlang术语都有一个外部表示,不同术语的解释是针对具体应用的。</target>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">由于 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管可以具有多个子代，因此它将所有子代异步关闭。这意味着孩子们并行进行清理，因此未定义他们停止的顺序。</target>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="translated">由于 NIF 库是动态链接到仿真器进程中的,所以这是调用 Erlang 中 C 代码的最快方式(与 port 驱动程序一起)。调用NIF不需要上下文切换。但它也是最不安全的,因为在 NIF 中的崩溃也会使仿真器瘫痪。</target>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="translated">作为 &lt;code&gt;set&lt;/code&gt; 操作的补充，可以指定测试功能。除了第一个参数是 &lt;code&gt;is_set_ok&lt;/code&gt; 而不是 &lt;code&gt;set&lt;/code&gt; 之外，此函数与上述set操作的语法相同。在设置变量之前将调用此函数。其目的是确保允许将变量设置为新值。</target>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="translated">作为一种方便的速记,如果在非捕获子模式的开头需要任何选项设置,选项字母可以出现在&quot;? &quot;和&quot;:&quot;之间。因此,以下两种模式匹配的是同一组字符串。</target>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="translated">按照惯例，所有I / O服务器都处理 &lt;code&gt;{setopts, [binary]}&lt;/code&gt; ， &lt;code&gt;{setopts, [list]}&lt;/code&gt; 和 &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt; ，因此使用 &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; 的技巧是：substitute_negations / 2和 &lt;code&gt;proplists:unfold/1&lt;/code&gt; 。如果无效的选项发送给我们，我们将 &lt;code&gt;{error, enotsup}&lt;/code&gt; 发送回给客户。</target>
        </trans-unit>
        <trans-unit id="2a763e7b020b36d9979aba8bffd33d0107367482" translate="yes" xml:space="preserve">
          <source>As a convention, the macro arguments in the head all start with an uppercase letter. In the body, the macro arguments can be expanded by preceding them with &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="translated">作为最后一个示例，我们演示了 &lt;code&gt;driver_async&lt;/code&gt; 的用法。我们还使用驱动程序术语接口。该驱动程序是用C ++编写的。这使我们能够使用STL中的算法。我们使用 &lt;code&gt;next_permutation&lt;/code&gt; 算法来获取整数列表的下一个排列。对于大型列表（&amp;gt; 100,000个元素），这需要一些时间，因此我们将其作为异步任务执行。</target>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="translated">作为十六进制数（或整数）。避免这种情况，因为很容易误解这种格式的 &lt;code&gt;BIT STRING&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="translated">作为最后的选择，该实现仅基于 &lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__sync_*&lt;/code&gt; 内置函数。但是，这将导致发出大量昂贵且不必要的内存屏障指令。即，性能将受到损害。如果 &lt;code&gt;configure&lt;/code&gt; 脚本无法找到其他替代方案，则会在执行结束时发出警告。</target>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="translated">由于匹配规范可以打开顺序跟踪，因此 &lt;code&gt;dbg&lt;/code&gt; 和 &lt;code&gt;seq_trace&lt;/code&gt; 的组合可能非常强大。此简短示例显示了使用顺序跟踪的会话：</target>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">作为 &lt;code&gt;add_frag&lt;/code&gt; 过程的一部分，Mnesia遍历与 &lt;code&gt;IterFrags&lt;/code&gt; 数字对应的所有片段 &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; 为每个记录启动key_to_frag_number（NewState，RecordKey）。如果新片段与旧片段不同，则记录将移至新片段。</target>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">作为 &lt;code&gt;del_frag&lt;/code&gt; 过程的一部分，Mnesia遍历与 &lt;code&gt;IterFrags&lt;/code&gt; 数字对应的所有片段 &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; 为每个记录启动key_to_frag_number（NewState，RecordKey）。如果新片段与旧片段不同，则记录将移至新片段。</target>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="translated">由于 port 驱动程序是动态链接到仿真器进程中的,所以这是调用 Erlang 中 C 代码的最快方式。在 port 驱动程序中调用函数不需要上下文切换。但这也是最不安全的方式,因为在 port 驱动程序中的崩溃也会使模拟器瘫痪。</target>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">作为副作用，该函数会打印它尝试编译的每个模块的名称。如果模块的编译失败，则make过程停止，并返回 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="translated">在特殊情况下， &lt;code&gt;{message, false}&lt;/code&gt; 禁止为此函数调用发送跟踪消息（&amp;ldquo; call&amp;rdquo;和&amp;ldquo; return_to&amp;rdquo;），就像匹配规范未匹配一样。如果只需要 &lt;code&gt;MatchBody&lt;/code&gt; 零件的副作用，这将很有用。</target>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="translated">作为一种特殊情况，只有在完全&lt;strong&gt;没有该驱动程序的用户的&lt;/strong&gt;情况下，才可以从没有对 &lt;code&gt;try_load/3&lt;/code&gt; 进行相应调用的进程中卸载&lt;strong&gt;驱动程序&lt;/strong&gt;，而如果包含最后一个用户的进程死亡，则可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="translated">作为特殊情况，以下条件适用于 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 部分：</target>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="translated">当测试套件运行时，所有信息（包括输出到 &lt;code&gt;stdout&lt;/code&gt; ）都记录在许多不同的日志文件中。用户控制台中显示的信息最少（仅开始和停止信息，以及每个失败的测试用例的注释）。</target>
        </trans-unit>
        <trans-unit id="579b2213688012ed19e294f3d42e5b38c477a26a" translate="yes" xml:space="preserve">
          <source>As above but with a descriptive string. The string is currently unused by &lt;code&gt;xref&lt;/code&gt; but other tools can make use of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="translated">由于Dets执行的所有操作都是磁盘操作，因此重要的是认识到单个查找操作涉及一系列磁盘搜索和读取操作。因此，尽管Dets导出了相似的接口，但Dets函数比相应的 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 函数要慢得多。</target>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="translated">由于从左到右都会尝试其他的分支,而且在子模式结束前不会重置选项,一个分支中的选项设置确实会影响到后续的分支,所以上述模式同时符合 &quot;SUNDAY &quot;和 &quot;Saturday&quot;。</target>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">作为 &lt;code&gt;-pa&lt;/code&gt; 的替代方法，如果要在代码路径前添加多个目录，并且这些目录具有公共的父目录，则可以在环境变量 &lt;code&gt;ERL_LIBS&lt;/code&gt; 中指定该父目录；参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="translated">作为构建引导脚本的替代方法，您可以在命令行上将路径显式添加到SSL &lt;code&gt;ebin&lt;/code&gt; 目录。这是通过命令行选项 &lt;code&gt;-pa&lt;/code&gt; 完成的。这可以工作，因为不需要启动SSL应用程序即可发布发行版本，因为SSL应用程序的克隆已挂接到内核应用程序中。因此，只要可以访问SSL应用程序代码，就开始分发。仅建议将 &lt;code&gt;-pa&lt;/code&gt; 方法用于测试目的。</target>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="translated">作为排序文件的替代方法，可以将一个参数的函数指定为输入。当使用参数 &lt;code&gt;read&lt;/code&gt; 调用时，假定该函数返回以下任一值：</target>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="translated">作为替代 &lt;code&gt;-callback&lt;/code&gt; 和 &lt;code&gt;-optional_callbacks&lt;/code&gt; 属性时，可能直接实现和出口 &lt;code&gt;behaviour_info()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="translated">或者，可以将已经打开的TCP套接字传递给 &lt;code&gt;TcpSocket&lt;/code&gt; 中的函数。SSH的启动和协商将在该套接字上启动，最后在TCP套接字另一端的主机上启动shell。</target>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="translated">或者，可以将已经打开的TCP套接字传递给 &lt;code&gt;TcpSocket&lt;/code&gt; 中的函数。当SSH在TCP套接字的另一端启动时，将在该端口上启动SSH启动和协商。</target>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="translated">或者，可以将已经打开的TCP套接字传递给 &lt;code&gt;TcpSocket&lt;/code&gt; 中的函数。SSH的启动和协商将在该一端启动，而SSH应当在另一端。</target>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="translated">作为示例，让我们首先在Kex列表中添加Diffie-Hellman Group1。根据 &lt;code&gt;Supported algoritms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="translated">作为分析间接调用的示例，以下Erlang函数试图回答以下问题：如果我们想知道某些模块间接使用了哪些模块，那么使用 &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; 而不是模块图值得吗？回想一下，如果M1中有某个函数调用了M2中的某个函数，则称模块M1调用了模块M2。如果我们可以使用更小的模块图，那就太好了，因为它也可以在Xref服务器的轻量 &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 下使用。</target>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="translated">作为如何使用该函数的示例，我们创建一个解释的脚本，该脚本使用 &lt;code&gt;emu_args&lt;/code&gt; 设置一些模拟器标志。在这种情况下，它会禁用 &lt;code&gt;smp_support&lt;/code&gt; 。我们还从新创建的脚本中提取不同的部分：</target>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="translated">作为如何使用函数 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 的示例，给出了 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 模块的QLC表的实现：</target>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="translated">作为默认行为的示例，以下调用作为第一个也是唯一一个捕获的字符串，将主题的匹配部分（中间为&amp;ldquo; abcd&amp;rdquo;）作为索引对 &lt;code&gt;{3,4}&lt;/code&gt; 返回，其中字符位置为零，基于，就像在偏移量中一样：</target>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">作为这些规则的示例，假设您要编写函数 &lt;code&gt;select&lt;/code&gt; ，该函数从元组列表中选择某些元素。假设您写 &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; 从提取的所有元组的意图 &lt;code&gt;L&lt;/code&gt; ，其中第一项是 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="translated">举个例子,假设旧的最大文件数是10,新的最大文件数是6,如果当前文件数不大于新的最大文件数,当文件6满时,文件7-10被删除,日志又开始向文件数1写入。否则,大于当前文件数的文件会在当前文件满时被删除(例如,如果当前文件数为8,则删除文件9和10)。新的最大文件数和当前文件之间的文件(即文件7和8)将在下次文件6满时被删除。</target>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="translated">作为一个例子,考虑对磁盘日志文件上的术语进行排序。一个从磁盘日志中读取分块并返回二进制文件列表的函数被用作输入。结果被收集在一个术语列表中。</target>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="translated">举个例子,考虑以下记录定义。</target>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="translated">举个例子,思考一下大写字母和小写字母之间的转换问题。通过阅读标准,你会意识到在所有的脚本中并不是简单的一对一的映射,例如:</target>
        </trans-unit>
        <trans-unit id="625ee0980ab37e0cc8ded0c3288fcfb1cdf01127" translate="yes" xml:space="preserve">
          <source>As an example, let say that we want to send &lt;code&gt;{call, &amp;lt;0.245.2&amp;gt;, {set_get_state, &amp;lt;&amp;lt;0:1024&amp;gt;&amp;gt;}}&lt;/code&gt; to registered process &lt;code&gt;reg&lt;/code&gt; using a fragment size of 128. To send this message we need a distribution header, atom cache updates, the control message (which would be &lt;code&gt;{6, &amp;lt;0.245.2&amp;gt;, [], reg}&lt;/code&gt; in this case) and finally the actual message. This would all be encoded into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="translated">例如，列表 &lt;code&gt;lists.erl&lt;/code&gt; 可用于简化list.erl中的某些功能：</target>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="translated">例如，可以将一个以 &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 作为键的对象插入 &lt;code&gt;ordered_set&lt;/code&gt; 中,并获得以 &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; 作为要搜索的键执行 &lt;code&gt;lookup/2&lt;/code&gt; 的结果返回的对象。</target>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="translated">例如，可以让跟踪消息通过网络发送到另一个Erlang节点（最好是&lt;strong&gt;不&lt;/strong&gt;分发的），在该节点上进行格式化：</target>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="translated">例如，假设您要在主机 &lt;code&gt;H&lt;/code&gt; 上以节点名 &lt;code&gt;Name@H&lt;/code&gt; 启动一个从属节点，并希望该从属节点具有以下属性：</target>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="translated">例如，用于交互式外壳程序的I / O服务器（在 &lt;code&gt;group.erl&lt;/code&gt; 中）理解以下选项：</target>
        </trans-unit>
        <trans-unit id="c349ed36989168b087d0841f096ffe34418c5158" translate="yes" xml:space="preserve">
          <source>As an example, the following specific instructions cannot be implemented as a combined instruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="translated">作为一个例子,我们将使用下面的函数,你可能会认识到它是manpage文件(3)中一个略有修改的基准函数。</target>
        </trans-unit>
        <trans-unit id="45ffebfcdac0f9d22d4c43b470257bc4c6356264" translate="yes" xml:space="preserve">
          <source>As an optimization this function may also return the port and version of the remote node. If port and version are returned &lt;code&gt;&lt;a href=&quot;#port_please-3&quot;&gt; port_please/3&lt;/a&gt;&lt;/code&gt; will not be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="translated">由于snmp自适应通常会在系统的整个生命周期内保留索引,这很少是一个问题。</target>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="translated">作为另一个示例，请考虑将两个查询 &lt;code&gt;QH1&lt;/code&gt; 和 &lt;code&gt;QH2&lt;/code&gt; 的答案串联起来，同时删除所有重复项。这可以通过使用 &lt;code&gt;unique&lt;/code&gt; 选项来实现：</target>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="translated">与其他任何类型的脚本一样，如果未设置脚本文件的执行位，则Erlang脚本在Unix平台上不起作用。（要打开执行位，请使用 &lt;code&gt;chmod +x script-name&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="translated">由于任何出现在fun头部的变量都被认为是一个新变量,所以写成如下的内容同样有效。</target>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="translated">如上所述，可以将参数列表与单个 &lt;code&gt;MatchVariable&lt;/code&gt; 或 &lt;code&gt;'_'&lt;/code&gt; 进行匹配。用单个变量替换整个参数列表是一种特殊情况。在所有其他情况下， &lt;code&gt;MatchHead&lt;/code&gt; 必须是&lt;strong&gt;正确的&lt;/strong&gt;列表。</target>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="translated">从上面的数字可以看出,当涉及到单个信息的解码时间时,非再入式和再入式柔性扫描仪之间没有真正的区别。</target>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="translated">可以看出，与 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 一起使用的乐趣是将单个列表作为参数而不是单个元组。该列表将参数列表与被跟踪函数匹配。也可以使用一个变量。乐趣的主体以一种更必要的方式表达了如果乐趣的负责人（和守卫）匹配则要采取的行动。在这里返回 &lt;code&gt;true&lt;/code&gt; ，只是因为一个乐趣的主体不能为空。返回值将被丢弃。</target>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="translated">可以看出，上面的函数只是 &lt;code&gt;get_until&lt;/code&gt; 请求中要提供的函数类型。</target>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="translated">默认情况下，结果集作为元组列表返回。该 &lt;code&gt;TupleMode&lt;/code&gt; 选项依然存在，以保持一定程度的向后兼容性。如果该选项设置为off，则结果集将作为列表列表而不是元组列表返回。</target>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="translated">如Robert的论文所述，I / O服务器和客户端使用 &lt;code&gt;io_request&lt;/code&gt; / &lt;code&gt;io_reply&lt;/code&gt; 元组进行通信，如下所示：</target>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="translated">如文件所述,选择在发起连接时假设知道对等体的DiameterIdentity,而diameter不需要。如果配置允许每个对等体建立多个连接,或者没有现存的连接,连接将被接受。请注意,选举过程只适用于不允许每个对等体建立多个连接的情况。</target>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="translated">由于每个事件处理程序都是一个回调模块，因此事件管理器具有许多动态添加和删除的回调模块。因此， &lt;code&gt;gen_event&lt;/code&gt; 比其他行为更能容忍回调模块错误。如果已安装的事件处理程序的回调函数因 &lt;code&gt;Reason&lt;/code&gt; 失败，或返回错误值 &lt;code&gt;Term&lt;/code&gt; ，则事件管理器不会失败。它通过调用回调函数 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 来删除事件处理程序，分别作为参数 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 或 &lt;code&gt;{error,Term}&lt;/code&gt; 。没有其他事件处理程序受到影响。</target>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="translated">评估此函数导致进程终止时，除非参数无效，否则它没有返回值，在这种情况下，该函数&lt;strong&gt;返回错误原因&lt;/strong&gt; &lt;code&gt;badarg&lt;/code&gt; 。如果要确保不返回，可以调用 &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; 并希望以后区分异常。</target>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="translated">由于每个尝试使用 &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;dbg&lt;/code&gt; 的人似乎最终都阅读了本手册页，因此此描述是对匹配规范概念的介绍。</target>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="translated">正如所料,10的两倍是20。</target>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="translated">据我们在撰写本文时所知，在没有任何密钥知识的情况下破坏 &lt;code&gt;des3_cbc&lt;/code&gt; 加密是不可行的。因此，只要密钥是安全的且不可猜测，加密的调试信息就&lt;strong&gt;应该&lt;/strong&gt;对入侵者是安全的。</target>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="translated">由于在大多数操作系统上文件时间以POSIX时间存储，因此使用 &lt;code&gt;posix&lt;/code&gt; 选项查询文件信息更快。</target>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="translated">对于 &lt;code&gt;i/1&lt;/code&gt; 和 &lt;code&gt;ni/1&lt;/code&gt; ，可以通过模块名称或文件名指定模块。</target>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="translated">至于 &lt;code&gt;select&lt;/code&gt; ，通过调用 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 遍历该表。区别在于匹配规范是明确指定的。这是说明状态匹配规范的方法，这些规范不能在QLC提供的语法中轻松表达。</target>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="translated">从ERTS 5.10开始,所有从进程到端口的信号都是真正的异步传输。</target>
        </trans-unit>
        <trans-unit id="54e61b5a72122095dbbd0cebf9a23eab4a8e63ab" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt; statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从ERTS 5.5（Erlang / OTP R11B）开始，此值不包括在当前计划的进程的当前时间片中执行的减少。如果需要一个精确值，请使用 &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="translated">从ERTS 5.5.2开始,对进程的退出信号就真正实现了异步传递。</target>
        </trans-unit>
        <trans-unit id="29adb187efe70ae7ea9eb1516c814ba1bd886f73" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">从ERTS 5.5.3开始，驱动程序界面已扩展（请参见 &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt; ）。扩展接口引入了 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ，在驱动程序初始化时将功能标志（请参阅 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt; ）传递给运行时系统的可能性，以及一些新的驱动程序API函数。</target>
        </trans-unit>
        <trans-unit id="cc982ada8a0ef67bfd186892ad9105718b94c2a0" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">从ERTS 5.5.3开始，驱动程序界面通过版本控制进行了扩展，并具有传递功能信息的可能性。功能标记存在于第48行。从ERTS 5.7.4 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; ，分发要使用的驱动程序需要ERL_DRV_FLAG_SOFT_BUSY标志。软繁忙标志意味着驱动程序可以将 &lt;code&gt;output&lt;/code&gt; 标记为忙，但可以处理对output和 &lt;code&gt;outputv&lt;/code&gt; 回调的调用。这一直是发行版使用的驱动程序的要求，但是以前没有与此相关的功能信息。想要查询更多的信息。参见 &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从ERTS 5.5.4.3开始，异步线程池中线程的默认堆栈大小为16 KB，在32位体系结构上为64 KB。选择此默认大小很小是因为异步线程的数量可能会很大。对于使用Erlang / OTP交付的驱动程序，默认堆栈大小已足够，但对于使用 &lt;code&gt;driver_async&lt;/code&gt; 功能的其他动态链接的驱动程序，默认堆栈大小可能不够大。在异步线程池线程一个建议的堆栈大小可以通过命令行参数来配置 &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="translated">从ERTS 5.6.1开始，仿真器拒绝在 &lt;code&gt;temp_alloc&lt;/code&gt; 之外的其他分配器上使用此策略。这是因为它只会给其他分配器带来问题。</target>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">从ERTS 5.6.4开始， &lt;code&gt;erlang:memory/0&lt;/code&gt; 要求启用所有 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 分配器（默认行为）。</target>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">从ERTS 5.6.4开始， &lt;code&gt;erlang:memory/1&lt;/code&gt; 要求启用所有 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 分配器（默认行为）。</target>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="translated">从ERTS 5.7.2开始,旧的原子缓存协议被取消,引入了新的协议。这个协议引入了分发头。ERTS版本早于5.7.2的节点仍可与新节点通信,但不使用分配头和原子缓存。</target>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">从ERTS 5.7.2开始，运行时系统在握手阶段传递分发标志，该标志允许在所有传递的消息上使用 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; 。在这种情况下，节点之间传递的消息具有以下格式：</target>
        </trans-unit>
        <trans-unit id="1259b645a71eafd28a440edcc0bee42c289d29ad" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt; version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从ERTS 5.9（Erlang / OTP R15B）开始，已将驱动程序接口更改为具有更大类型的回调 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 。请参阅驱动程序 &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从ERTS 5.9（Erlang / OTP R15B）开始，运行时系统默认情况下&lt;strong&gt;不会&lt;/strong&gt;将调度程序绑定到逻辑处理器。有关更多信息，请参见系统标志 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eaab9a3708d0c05a100d946be7959ae31e3845a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt; 64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从ERTS 5.9起，旧驱动程序必须重新编译并使用扩展接口。还必须将它们调整为支持 &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="translated">从ERTS 8.0 (Erlang/OTP 19)开始,任何仍在执行旧代码的滞留进程都会被这个函数杀死。在早期的版本中,这种不正确的使用可能会导致更致命的失败,比如模拟器崩溃。</target>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="translated">从ERTS 9.0（OTP 20）开始，原子可以包含任何Unicode字符，并且始终使用UTF-8外部格式 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 进行编码。不赞成使用旧的Latin-1格式 &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; ，仅在解码由较旧的节点编码的字词时才保留其向后兼容性。</target>
        </trans-unit>
        <trans-unit id="c56c4f98abd4a60cd0f47b8e3c9a0926a671f166" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt; System principles&lt;/code&gt; in System Documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">从Erlang / OTP 17开始，OTP发行号对应于主要的OTP版本号。没有 &lt;code&gt;erlang:system_info()&lt;/code&gt; 参数提供确切的OTP版本。这是因为一般情况下很难确定确切的OTP版本。有关更多信息，请参见系统文档中 &lt;code&gt;System principles&lt;/code&gt; 中的版本说明。</target>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="translated">从Erlang / OTP 18（ERTS 7.0）开始，时间功能已扩展。这包括用于时间和 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; ，这些时间和时间扭曲模式会在系统时间更改时更改系统行为。</target>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">从Erlang / OTP 20开始， &lt;code&gt;String&lt;/code&gt; 可以包含任何Unicode字符。较早的版本仅允许ISO-latin-1字符，因为实现不允许255以上的Unicode字符。有关原子中Unicode支持的更多信息，请参见《用户指南》中&amp;ldquo;外部术语格式&amp;rdquo;部分中 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">从Erlang / OTP 20开始， &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; 可以编码任何Unicode字符。如果二进制文件包含的Unicode字符&amp;gt; 255，则早期版本将失败。有关原子中Unicode支持的详细信息，请参阅《用户指南》中&amp;ldquo;外部术语格式&amp;rdquo;部分中 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 的注释。</target>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="translated">从Erlang / OTP 20开始，原子可以包含任何Unicode字符，并且如果 &lt;code&gt;Atom&lt;/code&gt; 的文本表示形式包含的Unicode字符&amp;gt; 255 ，则 &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; 可能会失败。</target>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="translated">从Erlang / OTP 21.0起，可以使用值为 &lt;code&gt;0&lt;/code&gt; 的字段宽度来指定一条线是无限长的，这意味着没有插入任何换行符。例如：</target>
        </trans-unit>
        <trans-unit id="634c1d87386aa4426d0d529b4d45ffef570a789c" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">从Erlang / OTP R13A开始，提供给函数 &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; 的数据将采用 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 格式。这意味着为该功能提供二进制文件的程序必须先将它们转换为UTF-8，然后再尝试在I / O设备上输出数据。</target>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">从Erlang / OTP R16开始， &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 确实是异步的。请注意，此操作始终被记录为异步操作，而基础实现已同步。但是，由于 &lt;code&gt;port_close/1&lt;/code&gt; 的错误行为，它仍然是完全同步的。</target>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">从Erlang / OTP R16开始， &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 确实是异步的。请注意，此操作始终被记录为异步操作，而基础实现已同步。但是，由于 &lt;code&gt;port_command/2&lt;/code&gt; 的错误行为，它仍然是完全同步的。</target>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">从Erlang / OTP R16开始， &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 确实是异步的。请注意，此操作始终被记录为异步操作，而基础实现已同步。但是，由于 &lt;code&gt;port_connect/2&lt;/code&gt; 的错误行为，它仍然是完全同步的。</target>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="translated">从Erlang / OTP R16开始，Erlang源文件可以UTF-8或字节编码（ &lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt; ）编写。有关如何声明Erlang源文件的编码的信息，请参见 &lt;code&gt;epp(3)&lt;/code&gt; 模块。从Erlang / OTP R16开始，可以使用Unicode编写字符串和注释。从Erlang / OTP 20开始，原子和函数也可以使用Unicode编写。必须仍使用ISO Latin-1字符集中的字符来命名模块，应用程序和节点。 （这些语言限制与源文件的编码无关。）</target>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="translated">从Erlang / OTP R16B开始，您可以通过分别提供启动标志 &lt;code&gt;+pc latin1&lt;/code&gt; 或 &lt;code&gt;+pc unicode&lt;/code&gt; 来选择ISO Latin-1范围或整个Unicode范围。为了向后兼容，默认为 &lt;code&gt;latin1&lt;/code&gt; 。这仅控制完成启发式字符串检测的方式。预计将来会增加更多范围，从而能够根据用户的语言和区域来定制启发式方法。</target>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="translated">从Erlang / OTP R9C开始， &lt;code&gt;abstract_code&lt;/code&gt; 块包含 &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt; ，其中 &lt;code&gt;AbstractCode&lt;/code&gt; 是本节中描述的抽象代码。</target>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="translated">从内核2.11.4版和ERTS 5.5.4版开始,保证以下几点。</target>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="translated">从内核版本2.11.4，在之前也可以做成订阅 &lt;code&gt;net_kernel&lt;/code&gt; 服务器启动，也就是 &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; 不返回 &lt;code&gt;ignored&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="translated">从Kernel 2.13版本和ERTS 5.7版本开始,保证以下内容。</target>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="translated">从R14A开始，编译器在尝试使用自动导入的BIF之前，将不带模块前缀的调用解析为本地或导入的函数。如果要调用BIF，请在调用中使用 &lt;code&gt;erlang&lt;/code&gt; 模块前缀，而不要使用 &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="translated">从R14A开始，如果名称与本地或显式导入的函数冲突，并且发出不带显式模块名称的调用，则编译器将不再调用自动导入的BIF。而是调用本地或导入的函数。仍然接受 &lt;code&gt;nowarn_bif_clash&lt;/code&gt; 会使模块调用与自动导入的BIF发生冲突的函数的模块能够同时使用新旧编译器进行编译，但语义完全不同。这就是为什么该选项被删除的原因。</target>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="translated">由于函数是关系,所以最后一项的定义(域、范围等)也适用于函数。</target>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="translated">如图所示，可以组合属性。例如，如果全部指定 &lt;code&gt;shuffle&lt;/code&gt; ， &lt;code&gt;repeat_until_any_fail&lt;/code&gt; 和 &lt;code&gt;sequence&lt;/code&gt; ，那么将以随机顺序重复执行组中的测试用例，直到测试用例失败。然后立即停止执行，并跳过其余情况。</target>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="translated">如图所示，这两个目录位于不同的节点上，因为 &lt;code&gt;/ldisc/scratch&lt;/code&gt; （&amp;ldquo;本地&amp;rdquo;磁盘）存在于两个不同的节点上。</target>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 中一样，使用 &lt;code&gt;unicode&lt;/code&gt; 选项编译的 &lt;code&gt;mp()&lt;/code&gt; 要求 &lt;code&gt;Subject&lt;/code&gt; 为Unicode &lt;code&gt;charlist()&lt;/code&gt; 。如果隐式完成编译并且为此函数指定了 &lt;code&gt;unicode&lt;/code&gt; 编译选项，则正则表达式和 &lt;code&gt;Subject&lt;/code&gt; 都应指定为有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="translated">和Erlang中一样,消息可以被发送到一个pid或一个注册名。向注册名发送消息比较容易,因为它避免了寻找合适的pid的问题。</target>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="translated">与构造中一样,键和值表达式的评估顺序没有被定义。更新中键值对的语法顺序没有关系,除非两个键匹配。在这种情况下,使用后一个值。</target>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">与 &lt;code&gt;run/3&lt;/code&gt; 函数一样，使用 &lt;code&gt;unicode&lt;/code&gt; 选项编译的 &lt;code&gt;mp()&lt;/code&gt; 要求 &lt;code&gt;Subject&lt;/code&gt; 为Unicode &lt;code&gt;charlist()&lt;/code&gt; 。如果隐式完成编译并且为此函数指定了 &lt;code&gt;unicode&lt;/code&gt; 编译选项，则将正则表达式和 &lt;code&gt;Subject&lt;/code&gt; 都指定为有效的Unicode &lt;code&gt;charlist()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64b4b80939944294d71727cd908b06dbe0c67247" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt; Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与在普通的Erlang匹配中一样，您可以使用&amp;ldquo;匹配内部匹配&amp;rdquo;将变量绑定到整个匹配对象，即a &lt;code&gt;=&lt;/code&gt; 。不幸的是，在翻译成匹配规范的乐趣中，仅在&amp;ldquo;顶层&amp;rdquo;才允许它，也就是说，将要匹配的&lt;strong&gt;整个&lt;/strong&gt;对象匹配到一个单独的变量中。如果您习惯于手工编写匹配规范，我们会提到变量A只是被转换为&amp;ldquo; $ _&amp;rdquo;。另外，伪函数 &lt;code&gt;object/0&lt;/code&gt; 也返回整个匹配的对象，请参阅 &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="a73b3d59b95737cd7fcd0d996094833b0e3aa133" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;ei_x_free()&lt;/code&gt; ensures that the data pointed to by &lt;code&gt;buf&lt;/code&gt; is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="translated">与前面的示例一样，您有责任释放为Erlang条款分配的内存。在此示例中， &lt;code&gt;erl_free_compound()&lt;/code&gt; 确保释放 &lt;code&gt;ep&lt;/code&gt; 指向的完整术语。这是必需的，因为从第二次调用到 &lt;code&gt;erl_format&lt;/code&gt; 的指针丢失了。</target>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">与上一节一样，PEM文件 &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; 包含服务器证书及其私钥。</target>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="translated">如名称所示,仿真器标志控制着仿真器的行为。</target>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="translated">只要所有的字符集都限制在256个字符以内,每个字符都可以存储在一个单一的字节中,因此,字符的实用编码或多或少只有一种。将每个字符用一个字节进行编码是非常普遍的,甚至连编码的名称都没有。在Unicode系统中,字符远远不止256个,所以需要一种通用的方式来表示这些字符。常用的表示码点的方式就是编码。这对程序员来说意味着一个全新的概念,即字符表示的概念,这在之前是不存在的。</target>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="translated">只要真实的标识符是正确的,就可以传递一个不是正确描述的CPU拓扑结构。如果小心使用,这可以是非常有用的。这来欺骗仿真器按照你的要求绑定它的调度器。例如,如果你想在同一台机器上运行多个Erlang运行时系统,你想减少使用的调度器数量,并操纵CPU拓扑,使它们绑定到不同的逻辑CPU上。一个例子,在一台四核机器上有两个Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="translated">只要 &lt;code&gt;ftp&lt;/code&gt; 应用程序处于运行状态，就可以对FTP会话进行监督，并可以对其进行软代码升级。</target>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="translated">只要数据始终为列表，则修饰符 &lt;code&gt;t&lt;/code&gt; 可以用于任何字符串，但是当涉及二进制数据时，必须注意正确选择格式字符。按字节编码的二进制文件也被解释为字符串，即使使用 &lt;code&gt;~ts&lt;/code&gt; 也会打印，但是它可能会被误认为是有效的UTF-8字符串。因此，如果二进制文件包含按字节编码的字符而不是UTF-8，请避免使用 &lt;code&gt;~ts&lt;/code&gt; 控件。</target>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="translated">只要消息队列的长度小于此值，就将异步处理所有日志事件。这意味着通过调用 &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 中的日志功能来发送日志事件的客户端进程不会等待处理程序的响应，而是会在事件发送后立即继续执行。它不受处理程序将事件打印到日志设备所花费的时间的影响。如果消息队列变得大于此值，则处理程序将开始同步处理日志事件，这意味着发送事件的客户端进程必须等待响应。当处理程序将消息队列减少到低于 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 的级别时阈值，恢复异步操作。从异步模式切换到同步模式可能会减慢一个或几个繁忙发件人的日志记录速度，但在许多繁忙并发发件人的情况下不能充分保护处理程序。</target>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="translated">只要调度器不超过16个,就永远不会出现驱动的端口锁争用的情况。</target>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="translated">如果指定的选项超出范围，则许多选项将被堆栈静默丢弃；最好检查原始选项是否被接受。以下代码将值放在变量 &lt;code&gt;TcpLinger2:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="translated">当匹配从左到右进行时,PCRE会查找主题中的每一个 &quot;a&quot;,然后查看后面的内容是否与剩余的模式匹配。如果模式被指定为</target>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="translated">由于md5在FIPS模式下不可用,所以只能使用使用sha哈希法签署的证书。当验证整个证书链时,所有证书(包括根CA)都必须符合这一规则。</target>
        </trans-unit>
        <trans-unit id="d5d8bb90e5a37caa06c5da65479a3526fd9c95dd" translate="yes" xml:space="preserve">
          <source>As mentioned above, the descriptors for the free segments are allocated in a separate area. This area has a constant configurable size (+MMscrfsd) that defaults to 65536 descriptors. This should be more than enough in most cases. If the descriptors area should fill up, new descriptor areas will be allocated first directly from the OS, and then from &lt;code&gt;sua&lt;/code&gt; and &lt;code&gt;sa&lt;/code&gt; in the super carrier, and lastly from the memory segment itself which is being deallocated. Allocating free descriptor areas from the super carrier is only a last resort, and should be avoided, as it creates fragmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="translated">如前所述，脚本可以包含预编译的 &lt;code&gt;beam&lt;/code&gt; 代码。在预编译的脚本中，脚本头的解释与包含源代码的脚本中的解释相同。这意味着您可以通过在文件前添加以 &lt;code&gt;#!&lt;/code&gt; 开始的行来使 &lt;code&gt;beam&lt;/code&gt; 文件可执行。和 &lt;code&gt;%%!&lt;/code&gt; 上文提到的。在预编译的脚本中，必须导出 &lt;code&gt;main/1&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e705de13180c5ffe8b4a054da182ea6ce56490f8" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt; List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">如前所述，查询以列表理解语法表示，如《Erlang参考手册》中的&amp;ldquo; &lt;code&gt;Expressions&lt;/code&gt; 部分所述。在下面，假定对列表理解有所了解。编程示例中的 &lt;code&gt;List Comprehensions&lt;/code&gt; 一节中的示例可以帮助您入门。请注意，列表推导并不会给语言增加任何计算能力。没有列表推导，任何可以做的事情也可以做到。但是它们添加了用于表达简单搜索问题的语法，一旦您习惯了它，它就会变得紧凑而清晰。</target>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="translated">如前所述,段有以下一般语法。</target>
        </trans-unit>
        <trans-unit id="04e043f1d8167a2d58dbe4fb1d07663eacbf966c" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt; erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">如本节开头的 &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; 文本中所述，至关重要的是，驱动程序回调相对较快地返回。很难给出允许驱动程序回调正常工作的最长时间，但是通常，行为良好的驱动程序回调将在1毫秒内返回。这可以使用不同的方法来实现。如果您完全控制要在驱动程序回调中执行的代码，则最好的方法是将工作分为多个工作块，并使用零超时来触发对 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; 多次调用。函数 &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; 对确定何时触发此类超时回调调用很有用。但是，有时无法以这种方式实现，例如在调用第三方库时。在这种情况下，您通常希望将工作分派到另一个线程。下面提供了有关线程基元的信息。</target>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="translated">如本手册页开头的 &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; 文本中所述，&lt;strong&gt;至关重要的是&lt;/strong&gt;，本机函数返回相对较快。很难给出允许本机函数正常工作的最长时间，但是通常，行为良好的本机函数是在1毫秒内返回到其调用方。这可以使用不同的方法来实现。如果您完全控制要在本机函数中执行的代码，最好的方法是将工作分为多个工作块，并多次调用本机函数。但是，这并非总是可能的，例如在调用第三方库时。</target>
        </trans-unit>
        <trans-unit id="d9a36e8e6187e92ea9445003806465beadc6eb3c" translate="yes" xml:space="preserve">
          <source>As mentioned in the Overview the size of the heap &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247&quot;&gt;grows&lt;/a&gt;&lt;/code&gt; to accommodate more data. Heaps grow in two stages, first a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208&quot;&gt;variation of the Fibonacci sequence&lt;/a&gt;&lt;/code&gt; is used starting at 233 words. Then at about 1 mega words the heap only &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227&quot;&gt;grows in 20% increments&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a0f4742d111106d49a722bae376fa32463cd1a" translate="yes" xml:space="preserve">
          <source>As mentioned in the introduction, the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; events are handled as messages. When writing a channel handling process without using the support by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior the process must handle thoose messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="translated">从 &lt;code&gt;Inets&lt;/code&gt; 5.0开始，HTTP服务器是易于启动/停止和自定义的Web服务器，提供了最基本的Web服务器功能。 Inets是为嵌入式系统设计的，如果您需要功能强大的Web服务器，则可以使用其他erlang开源替代方案。</target>
        </trans-unit>
        <trans-unit id="04f3b139a6a6595cb20185db3ca083fba34bbe19" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are other erlang open source alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33b6ffe68a9875e88f7c894ca5fdbb2187c6d41" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retransmissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">从ERTS 10.0版开始，已引入对分发控制器进程的支持。也就是说，可以通过进程而不是仅通过端口来管理分发通道上的流量。这样就可以在Erlang代码中实现大部分逻辑，甚至可能不需要该协议的新驱动程序。一个示例可以是使用 &lt;code&gt;gen_udp&lt;/code&gt; 在UDP上进行Erlang分发（在此示例中，您的Erlang代码当然必须照顾重传，等等）。也就是说，根据您要执行的操作，您可能根本不需要实现驱动程序，然后可以跳过下面与驱动程序相关的部分。 &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; 描述的 &lt;code&gt;gen_tcp_dist&lt;/code&gt; 示例 本节将使用分发控制器进程，如果您想使用分发控制器进程，则值得一看。</target>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="translated">从ERTS 9.0版开始，只有直接引用代码的过程才被认为在代码中徘徊。有关更多信息，请参见 &lt;code&gt;erlang:check_process_code/3&lt;/code&gt; 的文档，该文档用于确定此信息。</target>
        </trans-unit>
        <trans-unit id="6e7c328c76bb8c7c656e5de8a5de979edf715c89" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt; statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">从ERTS 9.0版开始，结果中还将包括脏的CPU调度程序。即，所有预期将处理CPU绑定工作的调度程序线程。如果您还需要有关脏I / O调度程序的信息，请改用 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="translated">从ERTS 9.0版本开始,Erlang运行时系统默认情况下,调度器会比逻辑处理器多。这是由于肮脏的调度器。</target>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="translated">从ERTS 9.0版开始，检查过程代码操作仅检查对代码的直接引用。通过 &lt;code&gt;fun&lt;/code&gt; 间接引用将被忽略。如果存在这样的 &lt;code&gt;fun&lt;/code&gt; ，并且在清除旧代码后使用了这些乐趣，则将在使用时引发异常（与清除后的流程接收到 &lt;code&gt;fun&lt;/code&gt; 的情况相同）。文字将在稍后阶段得到处理（复制）。在 &lt;code&gt;building OTP&lt;/code&gt; ，可以从ERTS版本8.1起启用此行为，如果启用了脏调度程序支持，则将自动启用此行为。</target>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="translated">从Erlang / OTP 17开始，大多数应用程序都提供有效的应用程序升级文件（ &lt;code&gt;appup&lt;/code&gt; ）。在早期版本中，Erlang / OTP中的大多数应用程序不支持升级。许多应用程序都使用 &lt;code&gt;restart_application&lt;/code&gt; 指令。这些应用程序对于支持真正的软件升级并不重要，例如工具和库应用程序。所述 &lt;code&gt;restart_application&lt;/code&gt; 指令确保在应用程序的所有模块被重新加载，从而运行新的代码。</target>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="translated">从Erlang/OTP 21.0开始,SASL报告的概念被删除了,这意味着默认行为如下。</target>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="translated">从 Erlang/OTP R16 开始,发送到 port 的消息是真正的异步传送。以前的底层实现是同步传递消息的。然而,消息传递一直被记录为异步操作。因此,对于与 ports 通信的 Erlang 程序来说,这并不是一个问题,除非对 ports 做了错误的假设。</target>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="translated">从OTP 17.0开始，应用程序版本使用与OTP版本相同的 &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; 。但是，候选发布版本的应用程序版本部分将没有 &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; 后缀作为OTP版本。还要注意，应用程序版本中的主要增量并不一定意味着OTP版本的主要增量。这取决于应用程序的主要更改是否被视为整个OTP的主要更改。</target>
        </trans-unit>
        <trans-unit id="f41a33ea3422f58a2c592a14e6ca2fd364ded6e8" translate="yes" xml:space="preserve">
          <source>As of OTP 22 the run-time complexity is &quot;n log n&quot; and the operation will complete quickly even when both lists are very long. In fact, it is faster and uses less memory than the commonly used workaround to convert both lists to ordered sets before subtracting them with &lt;code&gt;ordsets:subtract/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5518801a50c6a71ee3e8981653964ac2b6dbf8" translate="yes" xml:space="preserve">
          <source>As of OTP 23, a new process group implementation &lt;code&gt;pg&lt;/code&gt; is introduced. &lt;code&gt;pg&lt;/code&gt; is similar to &lt;code&gt;pg2&lt;/code&gt;, but with much better scalability properties. However, the API and behavior are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17f9053cdf5289c0081b64f5ede62361aa0f24" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d305318f18afb878956cbef1be26210771c5dcfd" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the distributed &lt;code&gt;disk_log&lt;/code&gt; feature has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a95f7bae08ccde7df39187dbb3cd7db985f457" translate="yes" xml:space="preserve">
          <source>As of OTP 24 &lt;code&gt;memsup_improved_system_memory_data&lt;/code&gt; configuration parameter will be removed and &lt;code&gt;get_system_memory_data()&lt;/code&gt; will begin behaving as it does now when the configuration parameter has been set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1a516e25f41f502502c2e85a3b2d0123bd4daa" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the Erlang compiler will refuse to compile source files encoded in Latin-1 but without a &lt;code&gt;%% coding: latin-1&lt;/code&gt; comment at the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aac901e7e27d750caa95cb4832b3614a3f6a5b" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the pre-release version 3 encoding configs; &lt;code&gt;prev3a&lt;/code&gt;, &lt;code&gt;prev3b&lt;/code&gt; and &lt;code&gt;prev3c&lt;/code&gt; will be removed. Use the full version instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从OTP版本17开始，OTP版本号对应于OTP版本的主要部分。OTP版本作为概念在OTP 17中引入。所使用的版本方案在 &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; 中进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="translated">从R15B01开始,动态跟踪代码被包含在OTP源码发行版中,尽管它被认为是实验性的。dtrace代码的主要开发工作仍在爱立信之外进行,但不需要获取OTP源代码的补丁版本来获得基本功能。</target>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="translated">从4.4版本开始,信息的格式已经改变。此功能用于转换为旧的(4.4之前)信息格式。</target>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">从4.4版开始，信息的格式已更改。要将信息转换为旧格式，请调用 &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="9906087c5fedcbfdab5bd69f8a1d9d0466df42d7" translate="yes" xml:space="preserve">
          <source>As one process can only be sending one fragmented message at once, it can be convenient to use the local PID as the sequence id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="translated">由于运算符本身并不是术语,所以当下面提到运算符时,运算符的表示方式将被视为具有与运算符相同字符组成的printtname的原子。</target>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">作为选项 &lt;code&gt;-M&lt;/code&gt; ，除了将Makefile写入 &lt;code&gt;Makefile&lt;/code&gt; 之外。没有产生目标文件。</target>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="translated">作为选项 &lt;code&gt;-MT&lt;/code&gt; ，除了引用 &lt;code&gt;make/1&lt;/code&gt; 特殊字符之外。</target>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="translated">由于参数 &lt;code&gt;Config&lt;/code&gt; 是键值元组的列表，即称为属性列表的数据类型，因此可以由 &lt;code&gt;proplists&lt;/code&gt; 模块处理。例如，可以使用 &lt;code&gt;proplists:get_value/2&lt;/code&gt; 函数搜索并返回一个值。同样，或替代地，常规 &lt;code&gt;lists&lt;/code&gt; 模块包含有用的功能。通常，对 &lt;code&gt;Config&lt;/code&gt; 执行的唯一操作是插入（将元组添加到列表的开头）和查找。 &lt;code&gt;Common Test&lt;/code&gt; 提供了一个名为 &lt;code&gt;?config&lt;/code&gt; 的简单宏，该宏在给定键的情况下返回 &lt;code&gt;Config&lt;/code&gt; 中某个项目的值（完全类似于 &lt;code&gt;proplists:get_value&lt;/code&gt; ）。例： &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df954ec42f95212c23047d3734e01ef2d3ae2ca4" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如前所述，执行表访问操作的功能对象（Fun）（如此处所列）可以作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="translated">如前所述,该规范也可以通过配置文件中的以下条目来提供。</target>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="translated">如前所述， &lt;code&gt;Mnesia&lt;/code&gt; 使用的锁定策略是在读取记录时锁定一个记录，并在写入记录时锁定记录的所有副本。但是，某些应用程序主要使用 &lt;code&gt;Mnesia&lt;/code&gt; 来实现其容错质量。可以为这些应用程序配置一个节点来完成所有繁重的工作，并配置一个备用节点，以便在主节点出现故障时可以接管该节点。这样的应用程序可以从使用粘锁而不是普通锁方案中受益。</target>
        </trans-unit>
        <trans-unit id="f370e8c40b9c4aba3e02b9314c912aaa28fee118" translate="yes" xml:space="preserve">
          <source>As producing and consuming standard URIs can get quite complex, Erlang/OTP provides a module, &lt;code&gt;uri_string&lt;/code&gt;, to handle all the most difficult operations such as parsing, recomposing, normalizing and resolving URIs against a base URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="translated">如 &lt;code&gt;stream_start message&lt;/code&gt; 所接收</target>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="f4cda5fd62bef4cb2abdbf95c2aa051fe7320a88" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 返回； &lt;code&gt;pid()&lt;/code&gt; 是处理I / O协议的进程。</target>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="ff99780124925e73d20d6ffc6b9d429009c7ddfb" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt; erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="822165ce6b0feadb4e6119638d0ca82bfef5ff78" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; 返回由 &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="1972d70c337d0516468a049aa6934a58903d2c1e" translate="yes" xml:space="preserve">
          <source>As returned by init/0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="translated">从帮助文本中可以看到-除非尚未升级Emacs（嗯，您还在这里等什么？您可以升级！）- &lt;code&gt;etags&lt;/code&gt; 将文件扩展名 &lt;code&gt;.erl&lt;/code&gt; 和 &lt;code&gt;.hrl&lt;/code&gt; 与Erlang 关联。</target>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="translated">可以看出，类型的基本语法是原子，后跟封闭的括号。使用 &lt;code&gt;-type&lt;/code&gt; 和 &lt;code&gt;-opaque&lt;/code&gt; 属性声明新类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="translated">如上所示，某些文件的扩展名为 &lt;code&gt;.hrl&lt;/code&gt; 。这些是 &lt;code&gt;.erl&lt;/code&gt; 文件中包含的头文件，其方式如下：</target>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="translated">如示例所示,函数也可以从shell中调用。当从shell中使用时,fun也必须在调用中按字面意思显示。</target>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="translated">如&amp;ldquo; &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 部分中所示，测试套件模块出于各种目的实现 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; （强制或可选），例如：</target>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="translated">如图所示，首先检查年份是否是leap年。如果一年可被400整除，则表示year年。要确定这一点，请先将年份除以400，然后使用BIF 截断 &lt;code&gt;trunc&lt;/code&gt; （稍后会详细介绍）来截断所有小数。然后再乘以400，看看是否再次返回相同的值。例如，2004年：</target>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="translated">如图所示，Erlang shell对可以输入的行进行了编号（如1&amp;gt; 2&amp;gt;），并且正确地指出2 + 5为7。如果您在shell中输入有误，则可以使用Backspace键删除，像大多数炮弹一样外壳程序中还有更多编辑命令（请参阅 &lt;code&gt;tty - A command line interface&lt;/code&gt; ERTS用户指南中的命令行界面）。</target>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="translated">如图所示，函数 &lt;code&gt;say_something&lt;/code&gt; 将其第一个参数写入第二个参数指定的次数。该函数 &lt;code&gt;start&lt;/code&gt; 启动两个Erlang进程，一个进程编写3次&amp;ldquo; hello&amp;rdquo;，另一个编写3次编写&amp;ldquo;再见&amp;rdquo;。这两个进程都使用函数 &lt;code&gt;say_something&lt;/code&gt; 。请注意，必须从模块中导出 &lt;code&gt;spawn&lt;/code&gt; 以这种方式使用的用于启动进程的函数（即，在模块开头的 &lt;code&gt;-export&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="translated">如图所示,乒乓程序已经运行。在 &quot;乒乓 &quot;方面。</target>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="translated">如前所述，更改子级规范不会影响现有的子级进程。新的子级规范会自动添加，但不会删除。子进程不会自动启动或终止，这必须使用 &lt;code&gt;apply&lt;/code&gt; 指令来完成。</target>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">如前所述，指令 &lt;code&gt;restart_new_emulator&lt;/code&gt; 使模拟器使用新版本的ERTS&amp;gt;，内核，STDLIB和SASL重新启动。但是，所有其他在启动时执行的应用程序都在此新模拟器中运行其旧版本。通常这是没有问题的，但是核心应用程序有时会发生不兼容的更改，这可能会导致此设置出现问题。这种不兼容的更改（在删除功能时）通常在两个主要版本之前都已弃用。为确保您的应用程序不会因不兼容的更改而崩溃，请始终尽快删除对不赞成使用的函数的任何调用。</target>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="translated">如前所述，指令的顺序很重要。升级时，必须先加载 &lt;code&gt;m1&lt;/code&gt; 并更改supervisor子级规范，然后才能启动新的子进程。降级时，必须先终止子进程，然后再更改子规范并删除模块。</target>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="translated">因此，客户端无法读取新的 &lt;code&gt;start_erl.data&lt;/code&gt; 文件（该文件无法动态更改）。引导文件和配置文件始终从同一位置获取（如果已安装新版本，则包含新内容）。</target>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="translated">当 &lt;code&gt;++&lt;/code&gt; 运算符复制其左操作数时，结果将被重复复制，从而导致二次复杂度。</target>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;add_frag&lt;/code&gt; 过程是架构事务的一部分，因此Mnesia会在受影响的表上获取写锁。即，对应于 &lt;code&gt;IterFrags&lt;/code&gt; 的片段和对应于 &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 的片段。</target>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="translated">由于省略了 &lt;code&gt;address&lt;/code&gt; 字段，因此使用其默认值。</target>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;del_frag&lt;/code&gt; 过程是架构事务的一部分，因此Mnesia会在受影响的表上获取写锁。即，对应于 &lt;code&gt;IterFrags&lt;/code&gt; 的片段和对应于 &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 的片段。</target>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="translated">由于 &lt;code&gt;total&lt;/code&gt; 值的总和 &lt;code&gt;processes&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; ，在误差 &lt;code&gt;system&lt;/code&gt; 传播到 &lt;code&gt;total&lt;/code&gt; 价值。</target>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="translated">由于Erlang ODBC应用依赖于第三方产品,所以在你启动和运行之前,需要做一些管理上的事情。</target>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="translated">由于Erlang ODBC应用程序依赖于第三方产品,并与可能运行在网络中另一台计算机上的数据库进行通信,因此有很多事情可能会出错。为了充分了解可能发生的事情,了解Erlang ODBC应用程序的设计是很有帮助的,因此这里对当前的设计做一个简短的描述。</target>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="translated">由于UTF-8编码被广泛传播,并且在7位ASCII范围内提供了一定的后向兼容性,因此在Erlang的二进制文件中,它被选为Unicode字符的标准编码。</target>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="translated">由于驱动程序是共享模块，而不是程序，因此不存在主要功能。在此示例中，未使用所有函数指针，并且 &lt;code&gt;driver_entry&lt;/code&gt; 结构中的相应字段设置为NULL。</target>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="translated">由于匹配规范的执行和结构就像一个fun,所以用熟悉的fun语法来写,并让其自动翻译成匹配规范,就比较直接了。一个真正的fun显然比match specifications允许的功能更强大,但是考虑到match specifications,以及它们能做的事情,还是把它全部写成fun更方便。这个模块包含了将 fun 语法翻译成 match specification 术语的代码。</target>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="translated">随着测试套件的执行,事件被记录在以下四种不同的方式。</target>
        </trans-unit>
        <trans-unit id="d51e39f06d97806b242fd21b87f9a687999b2271" translate="yes" xml:space="preserve">
          <source>As the high bit of the first two atoms in the cache are not set we know that they are already in the cache, so they do not have to be sent again (this is the node name of the receiving and sending node). Then follows the atoms that have to be sent, together with their segment ids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="translated">由于消息是 &lt;code&gt;ETERM&lt;/code&gt; 结构，因此可以使用Erl_Interface函数进行操作。在这种情况下，该消息将成为一个三元组，因为这就是Erlang代码的编写方式。第二个元素将是调用方的pid，第三个元素将是元组 &lt;code&gt;{Function,Arg}&lt;/code&gt; ,确定要调用哪个函数以及使用哪个参数。调用该函数的结果也将变成 &lt;code&gt;ETERM&lt;/code&gt; 结构，并使用 &lt;code&gt;erl_send()&lt;/code&gt; 发送回Erlang ，后者以打开文件描述符，一个pid和一个术语作为参数：</target>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="translated">由于该位置被指定为字节偏移量，因此在处理 &lt;code&gt;encoding&lt;/code&gt; 设置为 &lt;code&gt;latin1&lt;/code&gt; 以外的文件时，请特别小心，因为并非每个字节位置都是该文件上的有效字符边界。</target>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="translated">由于运行时系统处理优化(而不是编译器),所以很少有优化不成功的情况。</target>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="translated">随着源代码的分发，可以轻松地对其进行修改以接受其他选项。程序必须仍然接受具有上述语义的option &lt;code&gt;-data&lt;/code&gt; ，释放处理程序才能正常工作。</target>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="translated">由于时间偏移是不允许改变的,所以时间校正必须调整Erlang单调时钟的频率,使Erlang系统时间与OS系统时间顺利对齐。这种方法的一个重要缺点是,如果需要调整,我们故意会在Erlang单调时钟上使用一个错误的频率。这个误差可以大到1%。这个误差会在运行时系统的所有时间测量中显示出来。</target>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="translated">由于这两个替代项都位于 &lt;code&gt;(?|&lt;/code&gt; 组中，所以两组捕获括号都被编号为1.。因此，当模式匹配时，您可以查看捕获的子串编号1，无论哪种匹配项。当您要捕获时，此构造都非常有用在 &lt;code&gt;(?|&lt;/code&gt; 组中，圆括号按常规方式编号，但在每个分支的开头重设了编号。在子模式之后的任何捕获圆括号的编号均在之后开始以下示例来自Perl文档；下面的数字显示捕获的内容存储在哪个缓冲区中：</target>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="translated">由于一个模式中可以包含许多捕获括号，因此反斜杠后的所有数字都将作为潜在的反向参考号的一部分。如果模式以数字字符继续，则必须使用一些定界符来终止反向引用。如果设置了 &lt;code&gt;extended&lt;/code&gt; 选项，则可以为空格。否则，可以使用空注释（请参阅 &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt; 部分）。</target>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="translated">由于示例的最后一部分（&amp;ldquo; g&amp;rdquo;）没有匹配的子表达式，因此此后不会插入任何内容。为了使字符串组和与子表达式匹配的部分更加明显，可以使用option &lt;code&gt;group&lt;/code&gt; ，它在分割字符串时将主题字符串的部分与与子表达式匹配的部分组合在一起：</target>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="translated">由于这些都是C库,所以同样的限制也适用。</target>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="translated">由于这个接口意味着当最后一个用户消失时,端口会被杀死,所以该函数不会挂起等待端口被关闭。</target>
        </trans-unit>
        <trans-unit id="e0d70780a73e5bd4165a4b0dfafa2579d2f5f128" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt; compile(3)&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">因为此模块仅对编译器的维护人员有用，并且在两个地方都避免了相同的描述，所以仅在 &lt;code&gt;compile(3)&lt;/code&gt; 模块中描述控制警告的 &lt;code&gt;Options&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="translated">如前所述，图分析对 &lt;code&gt;digraph&lt;/code&gt; 表示进行操作。默认情况下，有 &lt;code&gt;digraph&lt;/code&gt; 表示形式在需要时创建（在不再使用时删除），但也可以使用 &lt;code&gt;closure&lt;/code&gt; 运算符显式创建：</target>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="translated">正如上一节中所提到的， &lt;code&gt;start_erl&lt;/code&gt; 需要 &lt;code&gt;sys.config&lt;/code&gt; 在发布版本目录（ &lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt; ）。如果没有这样的文件，则系统启动失败。因此，还必须添加这样的文件。</target>
        </trans-unit>
        <trans-unit id="ec4d55429ba417e5335bd49e46c6d6d7ae28aa98" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 一样，不进行所有权转移。仍然需要使用 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 释放资源。</target>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="translated">与 &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt; 一样：格外小心。</target>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="translated">与 &lt;code&gt;run/3&lt;/code&gt; 一样，编译错误会引发 &lt;code&gt;badarg&lt;/code&gt; 异常。 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 可用于获取有关错误的更多信息。</target>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="translated">与以 &lt;code&gt;ei_&lt;/code&gt; 开头的所有其他函数一样，您&lt;strong&gt;不&lt;/strong&gt;希望自己在程序中将套接字置于非阻塞模式。每次使用非阻塞模式都会嵌入到超时功能中。操作完成后，套接字将始终返回阻塞模式（无论结果如何）。为避免问题，请不要使用套接字选项。 &lt;code&gt;ei&lt;/code&gt; 处理任何需要修改的套接字选项。</target>
        </trans-unit>
        <trans-unit id="9f18e260b234899264f52d7e455efafe8a0b767f" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process are lost if the supervisor itself restarts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="translated">与动态添加的子进程一样,如果主管本身重新启动,删除静态子进程的效果就会消失。</target>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="translated">与普通树结构一样,查找(成员测试)、插入和删除的复杂度为对数。</target>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与过程监视器一样，每个驱动程序监视器集仅生成&lt;strong&gt;一个消息&lt;/strong&gt;。发送消息后，监视器被&amp;ldquo;销毁&amp;rdquo;，因此不需要调用 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7211803cb34fb7ce9f0ec3a041a6c83ef73def40" translate="yes" xml:space="preserve">
          <source>As with processes we wanted to be able to do the most fundamental operations without having to acquire a lock on it. The most important being able to determine if we should enqueue a process in a specific run queue or not. This involves being able to read actual load, and load balancing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="translated">从示例中可以看到，该函数也可以从shell调用。的 &lt;code&gt;fun()&lt;/code&gt; 需要从壳使用以及何时从字面上通话。在外壳程序中使用了parse_transform以外的其他方法，但是或多或少地应用了相同的限制（记录是例外，因为它们不由外壳程序处理）。</target>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="translated">从插图中可以理解， &lt;code&gt;Common Test&lt;/code&gt; 需要一个测试用例来生成运行时错误以指示失败（例如，通过引起匹配错误或通过调用 &lt;code&gt;exit/1&lt;/code&gt; ，最好通过帮助功能 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; ）。测试用例函数的正常返回指示成功执行。</target>
        </trans-unit>
        <trans-unit id="1d0f02291e9385ef819c0f808420bd9d22f20f88" translate="yes" xml:space="preserve">
          <source>As you have seen in the previous chapter, a standard URI can only contain a strict subset of the US ASCII character set, moreover the allowed set of characters is not the same in the different URI components. Percent-encoding is a mechanism to represent a data octet in a component when that octet's corresponding character is outside of the allowed set or is being used as a delimiter. This is what you see when &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is encoded as &lt;code&gt;%C3%B6&lt;/code&gt; and &lt;code&gt;space&lt;/code&gt; as &lt;code&gt;%20&lt;/code&gt;. Most of the API functions are expecting UTF-8 encoding when handling percent-encoded triplets. The UTF-8 encoding of the &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is two octets: &lt;code&gt;OxC3 0xB6&lt;/code&gt;. The character &lt;code&gt;space&lt;/code&gt; is in the first 128 characters of &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; and it is encoded using a single octet &lt;code&gt;0x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="translated">如您所见，可以显式使用 &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; 函数。通过使用这些功能，您可以编写自己的跟踪客户端，该客户机从以任何格式存储的任何源中读取跟踪数据，并仅将其提供给 &lt;code&gt;Collector&lt;/code&gt; 。您可以用将新的令人兴奋的跟踪数据格式转换为 &lt;code&gt;Event Records&lt;/code&gt; 的过滤器替换默认的 &lt;code&gt;Collector Filter&lt;/code&gt; 过滤器，也可以在调用 &lt;code&gt;et_collector:report/2&lt;/code&gt; 然后依赖默认的 &lt;code&gt;Collector Filter&lt;/code&gt; 处理新格式之前将其转换为 &lt;code&gt;Event Record&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="translated">要求他们转换内部状态格式,切换到新版模块。</target>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="translated">询问和检查原始套接字选项需要有关当前操作系统和TCP协议栈的低级信息。</target>
        </trans-unit>
        <trans-unit id="f8fa830a1c76cc3d9b64640309d56c10ee2a5f9a" translate="yes" xml:space="preserve">
          <source>Asks the remote server of &lt;code&gt;ConnectionRef&lt;/code&gt; to listen to &lt;code&gt;ListenHost:ListenPort&lt;/code&gt;. When someone connects that address, the connection is forwarded in an encrypted channel from the server to the client. The client (that is, at the node that calls this function) then connects to &lt;code&gt;ConnectToHost:ConnectToPort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="translated">断言字符串(或行,在多行模式下)的末端</target>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="translated">断言字符串(或行,在多行模式下)的开始。</target>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="translated">断言子模式不是捕获子模式。如果这样的断言中包含了捕获子模式,那么在对整个模式中的捕获子模式进行编号时,这些子模式会被计算在内。然而,子串捕获只对正断言进行。(Perl有时,但并不总是在负断言中执行捕获。)</target>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="translated">断言可以任意组合嵌套。例如,下面匹配的 &quot;baz &quot;的出现,其前面是 &quot;bar&quot;,而 &quot;bar &quot;又不在 &quot;foo &quot;前面。</target>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="translated">通过使用以下Erlang代码，可以为Erlang中的 &lt;code&gt;Operational&lt;/code&gt; 类型分配一个值：</target>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="translated">赋值:: =变量 &lt;code&gt;:=&lt;/code&gt; 表达式| 变量 &lt;code&gt;=&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="7585e904a125702314b9a3cc974072554cd19dc1" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;&lt;a href=&quot;gen_udp#controlling_process-2&quot;&gt;gen_udp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="translated">将新的控制过程 &lt;code&gt;Pid&lt;/code&gt; 分配给 &lt;code&gt;Socket&lt;/code&gt; 。与 &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt; 相同的实现。</target>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="translated">将新的控制过程 &lt;code&gt;Pid&lt;/code&gt; 分配给 &lt;code&gt;Socket&lt;/code&gt; 。控制过程是从套接字接收消息的过程。如果由当前控制进程以外的任何其他进程调用，则返回 &lt;code&gt;{error, not_owner}&lt;/code&gt; 。如果由 &lt;code&gt;Pid&lt;/code&gt; 标识的进程不是现有的本地pid，则返回 &lt;code&gt;{error, badarg}&lt;/code&gt; 。在某些情况下，在执行此函数期间关闭 &lt;code&gt;Socket&lt;/code&gt; 时，也可能返回 &lt;code&gt;{error, badarg}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="translated">为SSL套接字分配一个新的控制进程。控制进程是SSL套接字的所有者,并接收来自套接字的所有消息。</target>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">将包含整个表 &lt;code&gt;EMPLOYEE&lt;/code&gt; 的结果集与连接相关联。返回结果集中的行数。</target>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">将包含所有女性员工的 &lt;code&gt;FIRSTNAME&lt;/code&gt; 和 &lt;code&gt;NR&lt;/code&gt; 字段的结果集与该连接相关联。返回结果集中的行数。</target>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="translated">协会 &lt;code&gt;Key&lt;/code&gt; 以价值 &lt;code&gt;Value&lt;/code&gt; 和嵌入式协成地图 &lt;code&gt;Map2&lt;/code&gt; 。如果关键的 &lt;code&gt;Key&lt;/code&gt; 已经在地图中存在 &lt;code&gt;Map1&lt;/code&gt; ，旧的相关值由替代 &lt;code&gt;Value&lt;/code&gt; 。该函数返回一个新的地图 &lt;code&gt;Map2&lt;/code&gt; 包含新的协会，并在协会的老 &lt;code&gt;Map1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="translated">将UDP端口号（ &lt;code&gt;Port&lt;/code&gt; ）与调用过程相关联。</target>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">将名称 &lt;code&gt;Name&lt;/code&gt; （一个原子）与进程 &lt;code&gt;Pid&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="translated">将名称 &lt;code&gt;RegName&lt;/code&gt; 与进程标识符（pid）或端口标识符相关联。可以使用 &lt;code&gt;RegName&lt;/code&gt; （必须是一个原子）来代替send运算符中的pid或端口标识符（ &lt;code&gt;RegName ! Message&lt;/code&gt; ）。例：</target>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="translated">将测试运行与打印在概览HTML日志文件中的名称联系起来。</target>
        </trans-unit>
        <trans-unit id="98d38dc74b49e5a78d0c258ce1027deadc489dd0" translate="yes" xml:space="preserve">
          <source>Association File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437c9a7c9031d1af11bb4c9c4f2d1cfe844e612f" translate="yes" xml:space="preserve">
          <source>Association Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">协会成功建立。这表明 &lt;code&gt;connect&lt;/code&gt; 成功完成。</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="9517f720a79af71f615e7adc80ef320ce8b35b80" translate="yes" xml:space="preserve">
          <source>Assume a test that generates some parallel stateful commands, and runs 300 tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">假定通过添加接口函数来扩展模块，如 &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 中的示例所示，其中 &lt;code&gt;ch3&lt;/code&gt; 中添加了 &lt;code&gt;available/0&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="translated">假设应验证以下程序的测试用例。</target>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="translated">假定用户不希望Erlang使用本机查找方法，而是希望Erlang从开始就读取所有必要的信息，并将其用于解析名称和地址。如果查找失败，则Erlang将从域名服务器请求数据（使用Erlang DNS客户端，该客户端设置为使用EDNS允许更大的响应）。解析程序的配置文件更改时，更新解析器配置。同样，DNS记录永远也不会被缓存。用户配置文件（在此示例中为 &lt;code&gt;erl_inetrc&lt;/code&gt; ，存储在目录 &lt;code&gt;./cfg_files&lt;/code&gt; 中）可以如下所示（Unix）：</target>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="translated">假定以这种方式进行跟踪时没有任何反应。永不使用这些参数调用该函数。我们得出的结论是其他人（其他模块）正在执行此操作，并且意识到我们必须在 &lt;code&gt;ets:insert/2&lt;/code&gt; 上进行跟踪并希望看到调用函数。可以使用匹配规范函数 &lt;code&gt;caller&lt;/code&gt; 程序来检索调用函数。为了使其进入跟踪消息，必须使用匹配规范功能 &lt;code&gt;message&lt;/code&gt; 。过滤器调用如下所示（查找对 &lt;code&gt;ets:insert/2&lt;/code&gt; 的调用）：</target>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="translated">假设该模块现在通过所有测试并进入系统。一段时间后，发现表 &lt;code&gt;toy_table&lt;/code&gt; 在系统运行时增长，并且有许多元素以原子为键。我们只期望整数键，系统的其余部分也是如此，但显然不是整个系统。我们打开呼叫跟踪，并尝试查看以原子为键的模块调用：</target>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="translated">假设套件包含独立于其他两种情况的测试用例 &lt;code&gt;get_resource_status&lt;/code&gt; ，则函数 &lt;code&gt;all&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="translated">假设有两个系统 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 在单独的测试运行中进行了测试。系统 &lt;code&gt;s1&lt;/code&gt; 包含经过测试运行 &lt;code&gt;s1&lt;/code&gt; 测试的库模块 &lt;code&gt;m1&lt;/code&gt; ，并且包含在 &lt;code&gt;s1&lt;/code&gt; 的封面规格中，如下所示：</target>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="translated">假设有一个网络应用程序接收ASN.1定义的类型 &lt;code&gt;Person&lt;/code&gt; 的实例，对其进行修改并将其再次发送回：</target>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="translated">假设某个记录类型的位置 &lt;code&gt;Pos&lt;/code&gt; 上有一个索引。此功能可用于读取记录，而无需知道记录的实际密钥。例如，在表中第1位置的索引 &lt;code&gt;person&lt;/code&gt; ，呼叫 &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; 返回与年龄36.所有人员的名单 &lt;code&gt;Pos&lt;/code&gt; 也可以是属性名称（原子），但如果使用符号 &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; ，则在运行时针对每个调用搜索字段位置。</target>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="translated">假设我们还没有发现问题，并且想看看 &lt;code&gt;ets:new/2&lt;/code&gt; 返回了什么。我们使用略有不同的跟踪模式：</target>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="translated">假设我们要的是整个对象的匹配,而不是只有一个元素。一种替代方法是给记录的每个部分都分配一个变量,然后在趣味的主体中再一次建立起来,但下面的方法更简单。</target>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="translated">假设我们要获得2000年之前雇用的所有雇员的雇员人数。在这里不能使用 &lt;code&gt;ets:match/2&lt;/code&gt; ，因为那里不能表示关系运算符。 &lt;code&gt;ets:foldr/3&lt;/code&gt; 可以再次做到这一点（虽然缓慢，但正确）：</target>
        </trans-unit>
        <trans-unit id="35f82a62b9c069adc233b8d62c83260928f4ae7a" translate="yes" xml:space="preserve">
          <source>Assume that we want to test the lists:sort/1 function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">假设您有一个 &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; 的启动过程，如下所示：</target>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="translated">假设你想计算1的阶乘。</target>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="translated">假设您想将 &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; 文档转换为HTML。如果您希望结果HTML文档的结构和标签与XML文档相同，则可以使用 &lt;code&gt;xmerl:export/2&lt;/code&gt; 函数。下列：</target>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="translated">假设如下:</target>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="translated">假设我们要检查以下模块。</target>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">假设 &lt;code&gt;Term&lt;/code&gt; 是具有相同结构作为一个术语 &lt;code&gt;erl_parse&lt;/code&gt; 树，但与 &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; ，其中一个 &lt;code&gt;erl_parse&lt;/code&gt; 树有注释的集合。返回 &lt;code&gt;erl_parse&lt;/code&gt; 树，其中每个位置 &lt;code&gt;L&lt;/code&gt; 都由 &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt; 返回的值替换。术语 &lt;code&gt;Term&lt;/code&gt; 以深度优先，从左到右的方式遍历。</target>
        </trans-unit>
        <trans-unit id="d66afe8dfdd48d923747ad2c5c5b06df8c1510d8" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt; erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">假设 &lt;code&gt;Term&lt;/code&gt; 是一个与 &lt;code&gt;erl_parse&lt;/code&gt; 树具有相同结构的术语，但是带有术语 &lt;code&gt;T&lt;/code&gt; ，其中 &lt;code&gt;erl_parse&lt;/code&gt; 树具有注释的集合。返回 &lt;code&gt;erl_parse&lt;/code&gt; 树，其中每个项 &lt;code&gt;T&lt;/code&gt; 都由 &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; 返回的值替换。术语 &lt;code&gt;Term&lt;/code&gt; 以深度优先，从左到右的方式遍历。</target>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="translated">假设 &lt;code&gt;Forms&lt;/code&gt; 代表一个程序（或&amp;ldquo;程序表单&amp;rdquo;的任何序列），则第一行未与特定程序表单直接关联的任何注释将成为插入相邻程序表单之间的独立注释。此外，列位置小于或等于1的注释将不会附加到以冲突的行号开头的程序表单中（这种情况可能发生在预处理程序生成的 &lt;code&gt;line&lt;/code&gt; -attributes上）。</target>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="translated">假设在kosken上已经启动了一个叫ping的Erlang系统(但不是 &quot;ping &quot;进程),那么在gollum上就可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="translated">假设一个使用 &lt;code&gt;idno&lt;/code&gt; 作为键的Ets表包含以下内容：</target>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="translated">假设参数和C函数的结果均小于256，则采用简单的编码/解码方案。在此方案中， &lt;code&gt;foo&lt;/code&gt; 由字节1表示， &lt;code&gt;bar&lt;/code&gt; 由2表示，并且参数/结果也由单个字节表示：</target>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="translated">假设已经正确设置了环境变量，则在特定OS上使用 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 编码包含一个字符串，其中包含针对环境变量名称和值的有效字符。字符串中出现的第一个 &lt;code&gt;$=&lt;/code&gt; 字符将环境变量名称（左侧）与环境变量值（右侧）分开。</target>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="translated">假定对 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; 的调用在光盘上找不到要读取的任何架构，则 &lt;code&gt;Mnesia&lt;/code&gt; 将从无光盘节点开始，然后将其更改为使用光盘在本地存储架构的节点。</target>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="translated">假设节点已被启动,如下所示。</target>
        </trans-unit>
        <trans-unit id="51630ab3cd71a8b020a5db0bc163d0f23a13638c" translate="yes" xml:space="preserve">
          <source>Assuming that the thread progress functionality is efficient, a lot of algorithms can both be simplified and made more efficient than using the first approach that comes to mind. A couple of examples follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="translated">假设满足了这些要求,启用了时间校正,并且使用NTP等时间调整协议调整了操作系统的系统时间,那么在定稿后,只需要对Erlang单调时间进行小范围的调整,就可以保持系统时间的一致。只要系统不暂停,需要进行的最大调整是插入(或删除)闰秒。</target>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="translated">假设这些类型是从模块 &lt;code&gt;'mod'&lt;/code&gt; 导出的，则可以使用如下所示的远程类型表达式从其他模块中引用它们：</target>
        </trans-unit>
        <trans-unit id="13fa45ba7f2afed612bcb3c59e68416368c08493" translate="yes" xml:space="preserve">
          <source>Assuming that we spawn fewer processes than the maximum amount of unique process identifiers in the system, one has always been able to determine the order of process creation just by comparing process identifiers. If PidX is larger than PidY, then PidX was created after PidY assuming both identifiers originates from the same node. However, since we have a quite limited amount of unique identifiers today (2^28), this property cannot be relied upon if we create large amount of processes. But never the less, this is a property the system always have had.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="translated">假设我们想要销售部门每个人的员工人数,有几种方法。</target>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="translated">假设 &lt;code&gt;.rel file&lt;/code&gt; 存储在当前目录的文件 &lt;code&gt;start_ssl.rel&lt;/code&gt; 中，则可以如下构建启动脚本：</target>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="translated">假定与上面相同的 &lt;code&gt;CLIENTDIR&lt;/code&gt; ，最后一行如下所示：</target>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="translated">假设有一个具有安装根目录 &lt;code&gt;$ROOT&lt;/code&gt; 的可操作目标系统，则具有新版本发行版的发行包将被复制到 &lt;code&gt;$ROOT/releases&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="translated">假设这些定义。</target>
        </trans-unit>
        <trans-unit id="c8b26ebcc3e9bf5dbba85fc702138c186d9e4f8c" translate="yes" xml:space="preserve">
          <source>Assures that literals have a compact representation. This is occasionally useful if &lt;code&gt;c_cons_skel/2&lt;/code&gt;, &lt;code&gt;c_tuple_skel/1&lt;/code&gt; or &lt;code&gt;unfold_literal/1&lt;/code&gt; were used in the construction of &lt;code&gt;Node&lt;/code&gt;, and you want to revert to the normal &quot;folded&quot; representation of literals. If &lt;code&gt;Node&lt;/code&gt; represents a tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons/2&lt;/code&gt; or &lt;code&gt;c_tuple/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa99efafd6c95c8611da8fa8895116da74ab832" translate="yes" xml:space="preserve">
          <source>Assures that literals have a fully expanded representation. If &lt;code&gt;Node&lt;/code&gt; represents a literal tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons_skel/2&lt;/code&gt; or &lt;code&gt;c_tuple_skel/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed. The &lt;code&gt;&lt;a href=&quot;#fold_literal-1&quot;&gt;fold_literal/1&lt;/a&gt;&lt;/code&gt; can be used to revert to the normal compact representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="translated">没有为 &lt;code&gt;put&lt;/code&gt; 操作定义异步队列长度。</target>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="translated">各种链接到的驱动程序（主要是文件驱动程序）使用异步线程来卸载非CPU密集型工作。有关更多详细信息，请参见 &lt;code&gt;erl +A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">异步 &lt;code&gt;get-bulk-request&lt;/code&gt; （请参阅RFC1905）。</target>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">异步 &lt;code&gt;get-next-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">异步 &lt;code&gt;get-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">异步 &lt;code&gt;set-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c7ffbaa8ef4ef8420694da665321a4afef34039" translate="yes" xml:space="preserve">
          <source>Asynchronous calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">异步请求清除时间。对于每个请求，一些信息都存储在内部，以便能够将答复（到达时）传递到正确的目的地。如果收到答复，此信息将被删除。但是，如果没有（及时）答复，则必须在经过&lt;strong&gt;最&lt;/strong&gt;长时间&lt;strong&gt;之前&lt;/strong&gt;删除信息。此清理将按由 &lt;code&gt;server_timeout()&lt;/code&gt; 时间定义的固定间隔执行。该信息将具有&lt;strong&gt;最佳的&lt;/strong&gt;时间 &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; ，该时间间隔由调用请求函数时给定的 &lt;code&gt;Expire&lt;/code&gt; 时间定义（请参阅async_get， &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="56364b7086d1002ef3358c7012d8995780475b16" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">异步取消请求。 &lt;code&gt;Async&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt; ，这导致取消同步执行。当 &lt;code&gt;Async&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，取消操作将异步执行。即， &lt;code&gt;cancel_timer()&lt;/code&gt; 向管理计时器的计时器服务发送异步取消请求，然后返回 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="translated">异步请求状态信息。 &lt;code&gt;Async&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt; ，这将导致操作同步执行。在这种情况下， &lt;code&gt;Result&lt;/code&gt; 由 &lt;code&gt;erlang:read_timer&lt;/code&gt; 返回。当 &lt;code&gt;Async&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时， &lt;code&gt;erlang:read_timer&lt;/code&gt; 将对状态信息的异步​​请求发送到管理计时器的计时器服务，然后返回 &lt;code&gt;ok&lt;/code&gt; 。处理完成后，格式为 &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; 将发送到 &lt;code&gt;erlang:read_timer&lt;/code&gt; read_timer的调用方。</target>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">异步将项目列表附加到磁盘日志。 &lt;code&gt;alog_terms/2&lt;/code&gt; 用于内部格式化的日志， &lt;code&gt;balog_terms/2&lt;/code&gt; 用于外部格式化的日志。如果二进制文件是通过对 &lt;code&gt;term_to_binary/1&lt;/code&gt; 的调用构建的，那么 &lt;code&gt;balog_terms/2&lt;/code&gt; 也可以用于内部格式化的日志。</target>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">异步将项目添加到磁盘日志。 &lt;code&gt;alog/2&lt;/code&gt; 用于内部格式化的日志， &lt;code&gt;balog/2&lt;/code&gt; 用于外部格式化的日志。如果二进制文件是通过对 &lt;code&gt;term_to_binary/1&lt;/code&gt; 的调用构造的，那么 &lt;code&gt;balog/2&lt;/code&gt; 也可以用于内部格式化的日志。</target>
        </trans-unit>
        <trans-unit id="073b543723ae65bc813de7052a4d54e6f69f1707" translate="yes" xml:space="preserve">
          <source>Asynchronously send a spawn request. Returns a request identifier &lt;code&gt;ReqId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="translated">在 &quot;顶层&quot;,这些递归测试条件都是假的。递归模式的语法描述如下。</target>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">在 &lt;code&gt;success()&lt;/code&gt; 处， &lt;code&gt;UserReply&lt;/code&gt; 包含&amp;ldquo; ActionReply&amp;rdquo;记录的列表，其中可能包含错误指示。</target>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="translated">在 &lt;code&gt;success()&lt;/code&gt; 处， &lt;code&gt;UserReply&lt;/code&gt; 包含：</target>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">任何时候，当前的Erlang Top显示都可以转储到具有 &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt; 功能的文本文件中。</target>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">任何时候，要获取测试节点的当前状态，请调用函数 &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="654554d0e9934eea080ddb2f39b539e93c3b2e5f" translate="yes" xml:space="preserve">
          <source>At carrier deallocation, we want to coalesce with any adjacent free segments, to form one large free segment. To do that, all free segments are also organized in a tree sorted in address order (&lt;code&gt;atree&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="translated">在子模式的每次迭代中,后引用都会与前一次迭代对应的字符串相匹配。为了使之工作,模式必须是这样的,即第一次迭代不需要匹配后引用。这可以使用交替,如上面的例子,或者通过最小为零的量化符来实现。</target>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="translated">在每次记录访问时， &lt;code&gt;mnesia_frag&lt;/code&gt; 首先根据记录键计算哈希值。其次，根据哈希值确定表片段的名称。最后，实际的表访问是通过与非分段表相同的功能执行的。如果事先不知道密钥，则将在所有片段中搜索匹配记录。</target>
        </trans-unit>
        <trans-unit id="4fa74bb3403235c6895e68dc73b513ddac9e1482" translate="yes" xml:space="preserve">
          <source>At least one host key must be defined. The default value of SYSDIR is &lt;code id=&quot;#/etc/ssh&quot;&gt;/etc/ssh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="translated">除 &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; 之外，至少还有一个其他标识符类型也必须具有标识符列表。</target>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="translated">目前，代理 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 仅提供默认模块。</target>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="translated">在启动时，一个节点被分配了一个随机原子作为其魔术cookie，其他节点的cookie被假定为 &lt;code&gt;nocookie&lt;/code&gt; 。然后，Erlang网络身份验证服务器（ &lt;code&gt;auth&lt;/code&gt; ）的第一步是读取名为 &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt; 的文件。如果该文件不存在，则会创建它。该文件的UNIX权限模式设置为八进制400（用户只读），其内容为随机字符串。根据文件的内容创建一个原子 &lt;code&gt;Cookie&lt;/code&gt; ，并使用 &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt; 将本地节点的Cookie设置为此。这也使本地节点假定所有其他节点具有相同的cookie &lt;code&gt;Cookie&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="translated">在启动时， &lt;code&gt;Mnesia&lt;/code&gt; 假定其本地副本为最新版本，并且如果检测到以下情况之一，则从磁盘加载表：</target>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="translated">在启动时， &lt;code&gt;Mnesia&lt;/code&gt; 将不同的节点彼此连接，然后它们彼此交换表定义，并且表定义被合并。在合并过程中， &lt;code&gt;Mnesia&lt;/code&gt; 会执行完整性测试，以确保表定义彼此兼容。如果一个表存在于多个节点上，则cookie必须相同，否则 &lt;code&gt;Mnesia&lt;/code&gt; 将关闭其中一个节点。如果在断开连接的两个节点上彼此独立地创建了表，则会发生这种不幸的情况。为了解决这个问题，必须删除其中一个表（由于cookie的不同，即使它们具有相同的名称，也被视为两个不同的表）。</target>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="translated">在启动时， &lt;code&gt;Mnesia&lt;/code&gt; 将加载表以使其可用于其应用程序。有时 &lt;code&gt;Mnesia&lt;/code&gt; 决定加载所有本地驻留的表，有时 &lt;code&gt;Mnesia&lt;/code&gt; 带来了另一个节点的表副本之前无法访问这些表。</target>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">在启动时，无论Mnesia何时以及是否在其他节点上终止，Mnesia始终在本地加载 &lt;code&gt;read_only&lt;/code&gt; 表。此参数返回表的访问方式。访问模式可以是 &lt;code&gt;read_only&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="translated">在启动时，请注意，没有 &lt;code&gt;mnesia_down&lt;/code&gt; 条目的节点上的所有表都可以具有更新的副本。在当前节点上的 &lt;code&gt;Mnesia&lt;/code&gt; 终止后，它们的副本可以已更新。为了赶上最新的更新，请从其他&amp;ldquo;新鲜&amp;rdquo;节点之一转移该表的副本。如果您不走运，其他节点可能会关闭，并且您必须等待在这些节点之一上加载表后才能收到表的新副本。</target>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">启动时，将忽略 &lt;code&gt;Mnesia&lt;/code&gt; 普通表加载算法，并从为该表定义的主节点之一加载该表，而不考虑日志中可能存在的 &lt;code&gt;mnesia_down&lt;/code&gt; 条目。 &lt;code&gt;Nodes&lt;/code&gt; 只能包含表具有副本的节点。如果&amp;ldquo; &lt;code&gt;Nodes&lt;/code&gt; 为空，则将重置特定表的主节点恢复机制，并在下次重新启动时使用常规加载机制。</target>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在系统启动时，将通过内核配置参数来配置Logger。 &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt; 一节中介绍了适用于Logger的参数。可在&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt; 部分中找到示例。</target>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="translated">在媒体网关控制器（MGC）侧也能够拒绝的连接请求（并发送消息错误回复到网关）通过返回 &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; 或简单地 &lt;code&gt;error&lt;/code&gt; ，其生成与代码402（未授权的）的错误描述符和原因&amp;ldquo;用户拒绝连接&amp;rdquo;（对于所有未知结果，例如退出信号或抛出也是如此）。</target>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="translated">在匹配结束时,捕获小括号的值是最外层的值。如果上述模式与</target>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="translated">在第一阶段结束时，将为每个标量变量以及每组表操作调用用户定义的 &lt;code&gt;is_set_ok&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="translated">在文件结束时,会有以下的调用来表示传输的结束。</target>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="translated">目前,由于目前不支持政策,所以这始终是一个空列表。</target>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="translated">在另一端,服务器在5678端口监听,接受连接,并接收二进制文件。</target>
        </trans-unit>
        <trans-unit id="6f9ff8879a1b69159c6bc968e733a435a351ea07" translate="yes" xml:space="preserve">
          <source>At the time of writing this document, in October 2020, there are two major standards concerning Universal Resource Identifiers and Universal Resource Locators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="translated">在顶层,第一个字符被匹配,但由于它不在字符串的末尾,所以第一个选择失败,采用第二个选择,然后递归开始。子模式1的递归调用成功匹配了下一个字符(&quot;b&quot;)。注意行首和行尾测试不属于递归的一部分)。</target>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="translated">在这一点上，创建一个 &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt; 有意义的，但是在此特定示例中，编译器看到很快将调用一个函数（在本例中为 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 本身），该函数将立即创建一个新的匹配上下文并丢弃子二进制文件。</target>
        </trans-unit>
        <trans-unit id="053fad4995ec80f53388ef89516e030604b7c2c8" translate="yes" xml:space="preserve">
          <source>At this point the client has stored the received session tickets and ready to use them when establishing new connections to the same server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">在这个阶段，当我们有几个 &lt;code&gt;Events&lt;/code&gt; ，是时候在 &lt;code&gt;et_viewer&lt;/code&gt; 的图形界面中显示它的外观了：</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="translated">Atom ::=-与Erlang原子相同------。</target>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="translated">Atom是Erlang中的另一种数据类型。 &lt;code&gt;Atom&lt;/code&gt; 以小写字母开头（请参阅Atom），例如 &lt;code&gt;charles&lt;/code&gt; ， &lt;code&gt;centimeter&lt;/code&gt; 和 &lt;code&gt;inch&lt;/code&gt; 。原子只是名称，仅此而已。它们不像可以具有值的变量。</target>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="translated">AtomConst ::=Application | Module | Release</target>
        </trans-unit>
        <trans-unit id="b2ee6dcaa3e3bc365b8aefab9465e716d6296685" translate="yes" xml:space="preserve">
          <source>Atomic Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="translated">原子内存操作和虚拟机</target>
        </trans-unit>
        <trans-unit id="23f3697ab5a23225ef71292b3984b7a0da58971b" translate="yes" xml:space="preserve">
          <source>Atomic addition and return of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="translated">原子分组子模式不捕获子模式。可以将诸如上述示例之类的简单案例视为最大的重复，它必须吞噬一切。那么，同时\ d +和\ d +呢？准备调整它们匹配的位数以使其余模式匹配， &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; 只能匹配整个数字序列。</target>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="translated">原子组一般可以包含任何复杂的子模式,并且可以嵌套。然而,当一个原子组的子模式只是一个单一的重复项时,就像上面的例子一样,可以使用一个更简单的符号,称为 &quot;占有式量化符&quot;。它由一个额外的+字符组成,跟在一个量化符后面。使用这种符号,前面的例子可以改写为</target>
        </trans-unit>
        <trans-unit id="982546c2c1a7dfe452b41223e0b9ac156cdae924" translate="yes" xml:space="preserve">
          <source>Atomic subtraction and return of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="translated">原子事务。一系列的表操作操作可以归为一个原子事务。</target>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">以原子方式将所有节点上的注册名称 &lt;code&gt;Name&lt;/code&gt; 更改为引用 &lt;code&gt;Pid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2493472ac358dd449dd5c5363f10400e17b2f569" translate="yes" xml:space="preserve">
          <source>Atomically compares the atomic with &lt;code&gt;Expected&lt;/code&gt;, and if those are equal, set atomic to &lt;code&gt;Desired&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if &lt;code&gt;Desired&lt;/code&gt; was written. Returns the actual atomic value if not equal to &lt;code&gt;Expected&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d81a1603d3a7688828359e353ff047ffd9ff583" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic with &lt;code&gt;Desired&lt;/code&gt; and returns the value it held previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="translated">当需要在同一事务中原子地写多个记录时，原子性很重要。如上例所示，函数 &lt;code&gt;raise/2&lt;/code&gt; 仅写入一条记录。&amp;ldquo; &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; &amp;rdquo;程序清单中显示的函数 &lt;code&gt;insert_emp/3&lt;/code&gt; 将记录的 &lt;code&gt;employee&lt;/code&gt; 以及雇员关系（例如 &lt;code&gt;at_dep&lt;/code&gt; 和 &lt;code&gt;in_proj&lt;/code&gt; ）写入数据库。如果后面的代码在事务内部运行，则事务处理程序将确保事务完全成功或根本不成功。</target>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="translated">原子性是指事务执行的数据库变更在所有参与的节点上生效,或者在任何节点上都不生效。也就是说,事务要么完全成功,要么完全失败。</target>
        </trans-unit>
        <trans-unit id="9fd0fef61eacad14e3b6ee3330650b0b6285e00f" translate="yes" xml:space="preserve">
          <source>Atomics are 64 bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668e283c28347d455368391a2021ca18daf0d65e" translate="yes" xml:space="preserve">
          <source>Atomics are not tied to the current process and are automatically garbage collected when they are no longer referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85a2063ae4b966a0609e0b05bc24c3b00cbb202" translate="yes" xml:space="preserve">
          <source>Atomics can be represented as either signed or unsigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd729319f6838749442998b087a916cd07e23c32" translate="yes" xml:space="preserve">
          <source>Atomics wrap around at overflow and underflow operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="translated">原子和变量可以使用所有拉丁字母1。</target>
        </trans-unit>
        <trans-unit id="cad694cf01aa8c5551f1401deeab34aabdb5d17c" translate="yes" xml:space="preserve">
          <source>Atoms are compared using their string value, codepoint by codepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="translated">原子是不会被垃圾回收的。原子一旦被创建,就不会被删除。如果达到原子数量的限制(默认为1,048,576个),仿真器就会终止。</target>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;@&lt;/code&gt; 开头的原子，例如 &lt;code&gt;'@foo'&lt;/code&gt; 或 &lt;code&gt;'@Foo'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="translated">将注释附加到语法树。结果是一对 &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; ，其中 &lt;code&gt;NewTree&lt;/code&gt; 是给定的 &lt;code&gt;Tree&lt;/code&gt; ，列表中的 &lt;code&gt;Comments&lt;/code&gt; 已附加在适当的位置。 &lt;code&gt;Remainder&lt;/code&gt; 是 &lt;code&gt;Comments&lt;/code&gt; 中尚未插入的条目列表，因为它们的行号大于树中任何节点的行号。 &lt;code&gt;Comments&lt;/code&gt; 中的条目按顺序插入；如果两个注释附加到同一节点，它们将在程序文本中以相同的顺序出现。</target>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="translated">将注释附加到表示程序的语法树上。给定的 &lt;code&gt;Forms&lt;/code&gt; 应该是 &lt;code&gt;form_list&lt;/code&gt; 类型的单个语法树，或者是表示&amp;ldquo;程序表单&amp;rdquo;的语法树的列表。语法树必须包含有效的位置信息（有关详细信息，请参见 &lt;code&gt;recomment_tree/2&lt;/code&gt; ）。其结果是类型的相应语法树 &lt;code&gt;form_list&lt;/code&gt; 在列表中的所有评论 &lt;code&gt;Comments&lt;/code&gt; 已附着在适当的地方。</target>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="translated">附加到调试的进程 &lt;code&gt;Pid&lt;/code&gt; 。将为该过程打开一个&amp;ldquo;附加过程&amp;rdquo;窗口。</target>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="translated">附加到调试的进程 &lt;code&gt;Pid&lt;/code&gt; 。解释器调用 &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; （并忽略结果）。</target>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">附加到进程并打开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="translated">尝试删除当前目录。在某些平台上，返回 &lt;code&gt;eacces&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="translated">属性 &lt;code&gt;-dialyzer()&lt;/code&gt; 也可用于打开警告。例如，如果已修复了与不匹配退货有关的模块，则添加以下行可以帮助确保不引入新的不匹配退货警告：</target>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="translated">通过指定函数或警告选项，可将 &lt;code&gt;-dialyzer()&lt;/code&gt; 属性用于关闭模块中的警告。例如，要关闭功能 &lt;code&gt;f/0&lt;/code&gt; 的所有警告，请包含以下行：</target>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="translated">函数声明后允许使用 &lt;code&gt;-dialyzer()&lt;/code&gt; 属性。允许列出警告选项或功能：</target>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="translated">Attribute={atom(),term()}。</target>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="translated">Attributes=[{Name,Value}| #xmlAttribute{}]。</target>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="translated">审计跟踪记录</target>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="translated">Auth-Application-Id AVP</target>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="translated">Auth-Grace-Period AVP</target>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="translated">Auth-Request-Type AVP</target>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="translated">Auth-Request-Type AVP值。</target>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="translated">Auth-Session-State AVP</target>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="translated">Auth-Session-State AVP值</target>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="translated">使用简单的认证来验证连接。</target>
        </trans-unit>
        <trans-unit id="35d60aabf722ed742565d9c00b64a125d7839912" translate="yes" xml:space="preserve">
          <source>Authenticated Encryption with Associated Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="translated">认证握手信息的完整性;</target>
        </trans-unit>
        <trans-unit id="efa60b3797f87eb6c6f0da41e22b02554c4d0aa2" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt; net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">身份验证（由 &lt;code&gt;net_kernel(3)&lt;/code&gt; 完成）（3）</target>
        </trans-unit>
        <trans-unit id="2ff2f3c3923c0921f88e897f48c0cfff1d679d6c" translate="yes" xml:space="preserve">
          <source>Authentication Protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="translated">身份验证确定允许哪些节点相互通信。在不同Erlang节点的网络中，它以最低的级别内置于系统中。每个节点都有自己的&lt;strong&gt;魔术cookie&lt;/strong&gt;，它是一个Erlang原子。</target>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="translated">对等体的认证是通过RFC 3280中定义的公钥路径验证来完成的。这基本上意味着以下几点:</target>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="translated">认证/准入检查;</target>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="translated">授权会话状态机</target>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="translated">授权和核算反车辆程序在所提供的字典中定义。用户有责任正确使用它们。</target>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="translated">授权是用户的责任。</target>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">授权是用户的责任:直径不实现这个状态机。</target>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="translated">授权-终身AVP</target>
        </trans-unit>
        <trans-unit id="11627de117205b8d3e5249886b3c5fcffd98fb20" translate="yes" xml:space="preserve">
          <source>Authorized Keys - OpenSSH Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="translated">授权密钥-OpenSSH格式如下:</target>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="translated">自动导入的BIFs没有模块前缀。有模块前缀的BIF不自动导入。</target>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="translated">自动执行测试套件(测试用例集)</target>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="translated">自动编译测试套件(和帮助模块)。</target>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="translated">收到事务回复后自动发送事务确认（请参见下面的 &lt;code&gt;trans_ack&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">如果在交易回复发送之前,定时器过期,则自动发送交易等待。这个定时器也叫临时响应定时器。</target>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="translated">自动进入状态呼叫</target>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">自动类型转换可能仅对于遇到大小&amp;gt; 32位的驱动程序才需要进行这些更改。</target>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">由Logger自动插入。该值与添加处理程序时指定的 &lt;code&gt;HandlerId&lt;/code&gt; 相同，并且无法更改。</target>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">由Logger自动插入。该值与添加处理程序时指定的 &lt;code&gt;Module&lt;/code&gt; 相同，并且无法更改。</target>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">如果定时器过期,在交易回复发送之前,自动发送待定。这个定时器也叫临时响应定时器。</target>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="51349a6371eec8fabecdb286d36f04bc3ea24184" translate="yes" xml:space="preserve">
          <source>Available in all OpenSSL compatible with Erlang CRYPTO if not disabled by configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="translated">仅在某些POSIX系统中可用，此调用导致对 &lt;code&gt;fsync()&lt;/code&gt; 的调用，或者在不提供 &lt;code&gt;fdatasync()&lt;/code&gt; syscall的系统中无效。</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">可用的选项有:</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">可用的选项:</target>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="translated">可用属性与服务器的启动选项相同，但是属性 &lt;code&gt;bind_address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 无法更改。</target>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;'receive'&lt;/code&gt; 和 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 的 &lt;code&gt;erlang:trace/3&lt;/code&gt; 作为跟踪器模块使用。</target>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;call&lt;/code&gt; &lt;code&gt;erlang:trace/3&lt;/code&gt; 和作为跟踪器模块的 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;call&lt;/code&gt; &lt;code&gt;erlang:trace/3&lt;/code&gt; 或作为跟踪器模块的 &lt;code&gt;return_to&lt;/code&gt; 和 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">通过 &lt;code&gt;erlang:trace/3&lt;/code&gt; 可以使用，带有跟踪标志 &lt;code&gt;garbage_collection&lt;/code&gt; 和 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 作为跟踪器模块。</target>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;ports&lt;/code&gt; &lt;code&gt;erlang:trace/3&lt;/code&gt; 和作为跟踪器模块的 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;procs&lt;/code&gt; 的 &lt;code&gt;erlang:trace/3&lt;/code&gt; 和作为跟踪器模块的 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过 &lt;code&gt;running&lt;/code&gt; 跟踪标志并通过 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 作为跟踪器模块的 &lt;code&gt;erlang:trace/3&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">可通过带有跟踪标志 &lt;code&gt;send&lt;/code&gt; 的 &lt;code&gt;erlang:trace/3&lt;/code&gt; 和作为跟踪器模块的 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 使用。</target>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="translated">套接字收到的平均数据包大小偏差,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="translated">从套接字发送的平均数据包大小偏差,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="translated">套接字收到的数据包的平均大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="translated">从套接字发送的数据包的平均大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="translated">避免在根键上调用这个,因为它可能很慢。</target>
        </trans-unit>
        <trans-unit id="9ecc5c52604408ca037f4b32a55f99303082c7df" translate="yes" xml:space="preserve">
          <source>Avoid md5 for hashing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="translated">避免将多个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 与驱动程序重新加载请求混在一起。</target>
        </trans-unit>
        <trans-unit id="64e751996a0cede9d2045cdc8ba23d1357661337" translate="yes" xml:space="preserve">
          <source>Avoid storing a retrieved persistent term in a process if that persistent term could be deleted or updated in the future. If a process holds a reference to a persistent term when the term is deleted, the process will be garbage collected and the term copied to process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="translated">避免使用以下 &lt;code&gt;ResourceId&lt;/code&gt; 值，否则Erlang / OTP无法正常工作：</target>
        </trans-unit>
        <trans-unit id="69f8c47d6443544fd8368765fa26d69b3ce0d361" translate="yes" xml:space="preserve">
          <source>Avoid updating or deleting more than one persistent term at a time. Each deleted term will trigger its own global GC. That means that deleting N terms will make the system less responsive N times longer than deleting a single persistent term. Therefore, terms that are to be updated at the same time should be collected into a larger term, for example, a map or a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd4af0dc21ec9248c3098d7f5fe046b4b61faff" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;IP_ADJUSTMENT&lt;/code&gt; directly. Use &lt;code&gt;SET_I_REL()&lt;/code&gt; or one of the macros that invoke such as &lt;code&gt;FAIL()&lt;/code&gt; or &lt;code&gt;JUMP()&lt;/code&gt; defined in &lt;code&gt;macros.tab&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="translated">避免常见的错误。</target>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="translated">BEAM是一个基于寄存器的虚拟机,它有1024个虚拟寄存器,用于保存临时值和调用函数时传递参数。它有1024个虚拟寄存器,用于保存临时值和调用函数时传递参数。需要在函数调用中存活下来的变量被保存到堆栈中。</target>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="translated">BEAM是一个线程代码解释器。每条指令都是字直接指向可执行的C代码,使得指令调度的速度非常快。</target>
        </trans-unit>
        <trans-unit id="afd33b1e8c4969947e4dc49baade4763f8ff8b20" translate="yes" xml:space="preserve">
          <source>BEAM_FORMAT_NUMBER</source>
          <target state="translated">BEAM_FORMAT_NUMBER</target>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="translated">BIF是由于某种原因内置在Erlang虚拟机中的功能。BIF通常会实现无法或在Erlang中实现效率太低的功能。某些BIF只能使用函数名称来调用，但是默认情况下它们属于 &lt;code&gt;erlang&lt;/code&gt; 模块。例如，以下BIF &lt;code&gt;trunc&lt;/code&gt; 的调用等同于 &lt;code&gt;erlang:trunc&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="translated">BIF在运行时系统中以C代码实现。 BIF所做的事情很难或不可能在Erlang中实现。大多数BIF属于模块 &lt;code&gt;erlang&lt;/code&gt; ,但也有BIF属于其他几个模块，例如 &lt;code&gt;lists&lt;/code&gt; 和 &lt;code&gt;ets&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="translated">BIF可能由于各种原因而失败。如果使用错误类型的参数调用所有 &lt;code&gt;badarg&lt;/code&gt; 则它们的失败原因为badarg。其他原因在每个单独的BIF的说明中进行了描述。</target>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="translated">回到顶层,下一个字符(&quot;c&quot;)与子模式2匹配的 &quot;a &quot;进行比较。这就失败了。由于递归被视为一个原子组,现在没有回溯点,因此整个匹配失败。(Perl 现在可以重新进入递归,并尝试第二个备选方案。)然而,如果将模式的备选方案按其他顺序写,情况就不同了。</target>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="translated">这种类型的回溯引用会导致其引用的组被当作一个原子组。一旦整个组被匹配,随后的匹配失败不会导致回溯到组的中间。</target>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt; 使用的后端函数。</target>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt; 使用的后端函数。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="5563f67965aa081b7f33678be0a71475fa96ccb8" translate="yes" xml:space="preserve">
          <source>Backing Up the Registry to Mnesia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="dd96994d01e723dd6f9b0bdb6119722dbeb9faf0" translate="yes" xml:space="preserve">
          <source>Backup</source>
          <target state="translated">Backup</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 之间备份和还原C节点状态</target>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="translated">备份操作有以下功能:</target>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="translated">备份管理员处理的持久性数据。</target>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="translated">备份由代理处理的持久/永久数据(如local-db、mib-data和vacm)。</target>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="translated">备份、还原、回退和灾难恢复。</target>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="translated">BackupDir不能与DbDir相同。</target>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="translated">后进字</target>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="translated">后杀线</target>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="translated">向后杀字</target>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="translated">逆向词</target>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="translated">算术表达式中的错误论点。</target>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="translated">糟糕的说法。</target>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="translated">坏的参数。参数的数据类型不对,或其他方面不好。</target>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open_port&lt;/code&gt; 的输入参数错误。</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="translated">基本协议命令AVP表</target>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="translated">OTP应用程序SASL基于此功能，提供了一个框架，用于在运行时在整个发行版的不同版本之间进行升级和降级。这称为&lt;strong&gt;发布处理&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="translated">基本AVP数据格式</target>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="translated">基本编码规则(BER)</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d805a220598736617f1f5898d5984c11a47e33" translate="yes" xml:space="preserve">
          <source>Basic functions on Core Erlang abstract syntax trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="translated">具备Emacs和Erlang/OTP的基础知识。</target>
        </trans-unit>
        <trans-unit id="d3e42820dfcf4a655372ec7f0d0863e80c0b502a" translate="yes" xml:space="preserve">
          <source>Basic knowledge of property based testing is assumed in the following. It is also assumed that at least one of the following property based testing tools is installed and available in the library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="translated">基本用法包括使用 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 创建一个本地实现的Diameter节点及其功能的表示形式，使用 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 添加传输功能，发送Diameter请求并通过 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 接收Diameter答案。根据服务配置中的规定，传入的Diameter请求将作为回调传递给 &lt;code&gt;diameter_app(3)&lt;/code&gt; 回调模块。</target>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="translated">基本上与UTF-32相同,但没有一些Unicode语义,由IEEE定义,作为一个独立的编码标准没有什么用。对于所有正常的(可能是不正常的)使用,UTF-32和UCS-4是可以互换的。</target>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="translated">基本上， &lt;code&gt;etags&lt;/code&gt; 实用程序使用以下形式运行：</target>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="translated">基本上,程序如下:</target>
        </trans-unit>
        <trans-unit id="0912c94afdbb67bfe98617e8b201d30776d260bb" translate="yes" xml:space="preserve">
          <source>Basics of the ssh protocol's algorithms handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="translated">计算机编程的基础知识</target>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="61a2382405e7fcf34f5d81f378bf0ae437ec6326" translate="yes" xml:space="preserve">
          <source>Be Less Aggressive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="translated">请注意， &lt;code&gt;enif_schedule_nif&lt;/code&gt; ，enif_schedule_nif仅调度NIF以供将来执行。调用NIF不会阻止等待调度的NIF执行并返回。这意味着调用NIF不能期望接收调度的NIF返回值并将其用于进一步的操作。</target>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">当子进程为工作进程时，将关闭时间设置为 &lt;code&gt;infinity&lt;/code&gt; 时要小心。因为在这种情况下，监视树的终止取决于子进程，所以它必须以安全的方式实现，并且其清除过程必须始终返回。</target>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">当子进程为工作进程时，将关闭时间设置为 &lt;code&gt;infinity&lt;/code&gt; 时要小心。因为在这种情况下，监督树的终止取决于子进程；它必须以安全的方式实施，并且其清理过程必须始终返回。</target>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="translated">注意版本头，请在适当的时候使用 &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="translated">要以使过程适合监督树的方式开始。</target>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="translated">请确保&lt;strong&gt;不要&lt;/strong&gt;没有为包含以&amp;ldquo; megaco-&amp;rdquo;开头的测量二进制文件的目录命名，例如megaco-meas。这会混淆erlang应用程序加载器（erlang应用程序被命名为megaco-1.0.2）。</target>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="translated">编写NIF之前，请务必先阅读有关 &lt;code&gt;Long-running NIFs&lt;/code&gt; 的NIF的信息。</target>
        </trans-unit>
        <trans-unit id="88f10cc94f264a9568d393b9037d05b81b7daf69" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-dist_auto_connect&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, the system will have to manually call &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; in order to start the distribution. If the distribution channel is closed, when a node uses a dynamic node name, the node will stop the distribution and a new call to &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; has to be made. Note that the node name may change if the distribution is dropped and then set up again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">因为 &lt;code&gt;simple_one_for_one&lt;/code&gt; 主管可以有许多子级，所以它会异步关闭所有子级。这意味着孩子将并行进行清理，因此未定义停止它们的顺序。</target>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="translated">因为列表是常用的，所以它们具有速记类型符号。类型 &lt;code&gt;list(T)&lt;/code&gt; 和 &lt;code&gt;nonempty_list(T)&lt;/code&gt; 分别具有简写 &lt;code&gt;[T]&lt;/code&gt; 和 &lt;code&gt;[T,...]&lt;/code&gt; 。这两个速记之间的唯一区别是 &lt;code&gt;[T]&lt;/code&gt; 可以为空列表，但 &lt;code&gt;[T,...]&lt;/code&gt; 不能为空列表。</target>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="translated">由于网络和处理的延迟,追踪的周期是近似的。</target>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="translated">由于不同平台上动态加载界面的特殊性，仅&lt;strong&gt;当在出现错误的Erlang虚拟机的同一实例中调用format_error / 1时，&lt;/strong&gt;才保证返回的字符串描述正确的错误（表示相同的操作系统进程）。 ）。</target>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="translated">由于类型之间存在子类型关系，因此类型会形成一个格，其中最上面的元素 &lt;code&gt;any()&lt;/code&gt; 表示所有Erlang项的集合，而最下面的元素 &lt;code&gt;none()&lt;/code&gt; 表示空项的集合。</target>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="translated">由于原子的长度有限，建议改用 &lt;code&gt;-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="translated">变成&lt;strong&gt;\ h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Ll}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Lu}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {L}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Nd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Xan}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Xps}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="translated">成为&lt;strong&gt;\ p {Xwd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="translated">在ERTS 10.0（OTP 21.0）之前，如果受监视的进程驻留在未实现远程进程监视的原始节点（例如erl_interface或jinterface）上，则监视进程可能会失败并使用 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="translated">在ERTS 5.9之前,可以配置比调度器更少的线程专用实例。但是,现在已经不可能了。</target>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="translated">在ERTS 7.0（Erlang / OTP 18）之前，必须从NIF返回 &lt;code&gt;enif_make_badarg&lt;/code&gt; 的返回值。现在已取消此要求，因为如果已调用 &lt;code&gt;enif_make_badarg&lt;/code&gt; ,则将忽略NIF的返回值。</target>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="translated">在ERTS 9.0（OTP-20.0）之前，所有资源项的比较彼此相等，并且与空二进制文件（ &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ）比较。如果被序列化，它们将被重新创建为纯空二进制文件。</target>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="translated">ERTS 9.1 (OTP-20.1)之前,字符串中只接受0-255范围内的码点。现在任何unicode字符串都是有效的。</target>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="translated">在Erlang/OTP 17.1之前,如果你的测试运行由多个测试组成,覆盖将在测试运行中为每个测试启动和停止。通过测试套件结果页面上的 &quot;覆盖日志 &quot;链接可以获得单独的日志。这些链接仍然可用,但现在它们都指向同一个页面,如顶层索引页面上的按钮。该日志包含完整测试运行的累积结果。有关这一变化的细节,请参见发布说明。</target>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="translated">在Erlang / OTP 19之前，对于没有初始值的字段，将单例类型 &lt;code&gt;'undefined'&lt;/code&gt; 添加到所有声明的类型中。换句话说，以下两个记录声明具有相同的作用：</target>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="translated">在Erlang / OTP R11B（ERTS 5.5）的 &lt;code&gt;demonitor/1&lt;/code&gt; 行为完全异步之前，也就是说，在&amp;ldquo;守护程序信号&amp;rdquo;到达被监视实体之前，监视器一直处于活动状态。这产生了一种不良影响。您永远不会知道由于显示器而&lt;strong&gt;无法&lt;/strong&gt;保证何时收到 &lt;code&gt;DOWN&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="translated">在Erlang / OTP R11B（ERTS 5.5）之前， &lt;code&gt;unlink/1&lt;/code&gt; 的行为完全异步，也就是说，直到&amp;ldquo; unlink signal&amp;rdquo;到达链接实体之前，该链接才处于活动状态。这产生了不良影响，因为您永远不知道何时可以保证&lt;strong&gt;不会&lt;/strong&gt;受到链接的影响。</target>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="translated">在Erlang/OTP R16之前,端口ID可以通过适当的铸造来作为密钥,但在重写了端口子系统之后,就不再是这样了。有了这个功能,你可以实现和Erlang/OTP R16之前一样的基于端口ID的分发。</target>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="translated">在Linux 3.8之前，可以设置此套接字选项，但无法使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 进行检索。从Linux 3.8开始，它是可读的。</target>
        </trans-unit>
        <trans-unit id="6730ee065030a00d88c78657469d331d9b0d4526" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but not get. Only works for some socket types (e.g. &lt;code&gt;inet&lt;/code&gt;). If empty value is set, the binding is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="translated">在OTP 19之前，如果 &lt;code&gt;on_load&lt;/code&gt; 函数失败，那么任何以前的当前代码都将变旧，从而使系统失去该模块的任何可用实例。OTP 19中已消除了该问题。</target>
        </trans-unit>
        <trans-unit id="4a26f53b8fd124a2195afd74e62b113f37b0fb17" translate="yes" xml:space="preserve">
          <source>Before OTP 22, the option &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; was only recognized when given in the file with attribute &lt;code&gt;-compile()&lt;/code&gt;. (The option &lt;code&gt;{nowarn_unused_function,FAs}&lt;/code&gt; was incorrectly documented to only work in a file, but it also worked when given in the option list.) Starting from OTP 22, all options that can be given in the file can also be given in the option list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6280bf5d40e1ad7fd5221aeb6433bc3d21c56c" translate="yes" xml:space="preserve">
          <source>Before OTP 23, &lt;code&gt;Size&lt;/code&gt; was restricted to be an integer or a variable bound to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89094b9481b9b8c9439e6748d4ddfcd926381b9" translate="yes" xml:space="preserve">
          <source>Before OTP 23, the expression defining the key &lt;code&gt;K&lt;/code&gt; was restricted to be either a single variable or a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="translated">在OTP R14A之前(ERTS 5.8版),对一个与自动导入的BIF同名的函数的隐式限定函数调用总是导致BIF被调用。在新版本的编译器中,本地函数会被调用。这是为了避免将来增加的自动导入BIF集不会默默地改变旧代码的行为。</target>
        </trans-unit>
        <trans-unit id="e9407c86312dec72e66a3d1afa8b0f111f642f45" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when an Erlang code module was loaded, all other execution in the VM were halted while the load operation was carried out in single threaded mode. This might not be a big problem for initial loading of modules during VM boot, but it can be a severe problem for availability when upgrading modules or adding new code on a VM with running payload. This problem grows with the number of cores as both the time it takes to wait for all schedulers to stop increases as well as the potential amount of halted ongoing work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e13a53367593b9c5d185550d151836210a12440" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when trace settings were changed by &lt;code&gt;erlang:trace_pattern&lt;/code&gt;, all other execution in the VM were halted while the trace operation was carried out in single threaded mode. Similar to code loading, this can impose a severe problem for availability that grows with the number of cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f7f3432428a2eb46f419c68c366cf2370764d0" translate="yes" xml:space="preserve">
          <source>Before OTP-17.4 the search algorithm had a problem as the search always started at the same position in the pool, the sentinel. This could lead to contention from concurrent searching processes. But even worse, it could lead to a &quot;bad&quot; state when searches fail with a high rate leading to new carriers instead being allocated. These new carriers may later be inserted into the pool due to bad utilization. If the frequency of insertions into the pool is higher than successful fetching from the pool, memory will eventually get exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6244bef3fa35080f6be664c665752e7ae747946" translate="yes" xml:space="preserve">
          <source>Before OTP-23 the user &lt;strong&gt;needed&lt;/strong&gt; to supply a valid &lt;code&gt;-sname&lt;/code&gt; or &lt;code&gt;-name&lt;/code&gt; for &lt;code&gt;-remsh&lt;/code&gt; to work. This is still the case if the target node is not running OTP-23 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="translated">在R14之前,需要有如下括号:</target>
        </trans-unit>
        <trans-unit id="2556eabbc9f968558043782e1fcdc348f5df35c3" translate="yes" xml:space="preserve">
          <source>Before STDLIB 3.4 (OTP 20.0) compiled match specifications did not have an external representation. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result was always an empty binary &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787dfaa6bed7bb38d94c61fd72dc85362aa99313" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successful, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">在从Erlang调用驱动程序之前，必须先加载并打开它。加载是使用 &lt;code&gt;erl_ddll&lt;/code&gt; 模块完成的（加载动态驱动程序的 &lt;code&gt;erl_ddll&lt;/code&gt; 驱动程序实际上是驱动程序本身）。如果加载成功，则可以使用 &lt;code&gt;open_port/2&lt;/code&gt; 打开端口。端口名称必须与共享库的名称和驱动程序条目结构中的名称匹配。</target>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="translated">在传输文件之前，进行以下调用以指示文件传输的开始以及文件的大小。回调函数的返回值将是 &lt;code&gt;UserProgressTerm&lt;/code&gt; 的新值，该值将在下次调用回调函数时用作输入。</target>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">在启动应用程序之前，必须先&lt;strong&gt;加载&lt;/strong&gt;它。应用程序控制器从 &lt;code&gt;.app&lt;/code&gt; 文件读取并存储信息：</target>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="translated">在应用程序首次访问表 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; 将执行mnesia：wait_for_tables（TabList，Timeout）以确保可从本地节点访问该表。如果函数超时，则应用程序可以选择使用 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 强制加载本地副本，并故意丢失在本地节点关闭时可以在其他节点上执行的所有更新。如果 &lt;code&gt;Mnesia&lt;/code&gt; 已经或打算将表加载到另一个节点上，请从该节点复制该表，以避免不必要的不​​一致。</target>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="translated">在进行任何分析之前，必须先&lt;strong&gt;设置&lt;/strong&gt;模块数据。例如，当所有模块数据都已知时，将计算交叉引用和未知函数。需要完整数据的函数（ &lt;code&gt;analyze&lt;/code&gt; ， &lt;code&gt;q&lt;/code&gt; ， &lt;code&gt;variables&lt;/code&gt; ）负责自动设置数据。在调用 &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;replace&lt;/code&gt; ， &lt;code&gt;remove&lt;/code&gt; ， &lt;code&gt;set_library_path&lt;/code&gt; 或 &lt;code&gt;update&lt;/code&gt; 函数中的任何一个之后，都需要再次设置模块数据。</target>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">在进行任何分析之前，必须对&lt;strong&gt;涵盖的&lt;/strong&gt;模块进行&lt;strong&gt;封面编译&lt;/strong&gt;。这意味着在将模块编译为二进制文件然后 &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt; 之前，会向模块添加一些额外的信息。模块的源文件不受影响，并且不会创建 &lt;code&gt;.beam&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">在进行任何分析之前，必须对&lt;strong&gt;涵盖的&lt;/strong&gt;模块进行&lt;strong&gt;封面编译&lt;/strong&gt;。这意味着在将模块编译成二进制文件然后加载之前，会将一些额外的信息添加到模块中。模块的源文件不受影响，并且不会创建 &lt;code&gt;.beam&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="translated">在应用补丁之前，您需要在源目录中&lt;strong&gt;完整&lt;/strong&gt;构建OTP。</target>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="translated">提出问题之前，您可以浏览&lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt;邮件列表档案&lt;/a&gt;并阅读&amp;ldquo; &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;常见问题&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">在调用任何其他 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数之前，只调用一次 &lt;code&gt;erl_init()&lt;/code&gt; 即可初始化库。 &lt;code&gt;erl_init()&lt;/code&gt; 有两个参数。但是，参数不再由 &lt;code&gt;Erl_Interface&lt;/code&gt; 使用，因此将被指定为 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="258c449a5777b1e0308a8597c71acd1f65986e67" translate="yes" xml:space="preserve">
          <source>Before calling any of the other functions in the library, initialize it by calling &lt;code&gt;ei_init()&lt;/code&gt; exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="translated">在调用Erl_Interface中的任何其他函数之前,必须启动内存处理。</target>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">在开始执行组之前，将调用配置函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; 。从此函数返回的元组列表以通常的方式通过参数 &lt;code&gt;Config&lt;/code&gt; 传递给测试用例。 &lt;code&gt;init_per_group/2&lt;/code&gt; 用于组中测试用例的通用初始化。组执行完成后，将调用函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; 。该函数用于 &lt;code&gt;init_per_group/2&lt;/code&gt; 之后的清理。如果定义了init函数，则必须定义end函数。</target>
        </trans-unit>
        <trans-unit id="742d99c38a98962fb67614d643aed1075c662a8f" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="translated">在执行时间陷阱功能（在并行的专用时间陷阱过程上执行）之前， &lt;code&gt;Common Test&lt;/code&gt; 会取消测试用例或配置功能的任何先前设置的计时器。当timetrap函数返回时，&lt;strong&gt;除非&lt;/strong&gt;返回值是有效的时间陷阱时间（例如整数或 &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; 元组），&lt;strong&gt;否则&lt;/strong&gt;超时将被触发（有关详细信息，请参见模块 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; ）。如果返回时间值，则将在指定时间后开始新的时间陷阱以生成超时。</target>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="translated">在详细介绍Erlang系统中的监督和错误处理之前，让我们看一下Erlang进程如何终止，或者用Erlang术语&lt;strong&gt;退出&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">在改进Messenger程序之前，让我们以乒乓程序为例来了解一些通用原则。回想一下，当&amp;ldquo; ping&amp;rdquo;完成时，它通过将&amp;ldquo;原子 &lt;code&gt;finished&lt;/code&gt; 作为消息发送给&amp;ldquo; pong&amp;rdquo; ，从而告诉&amp;ldquo; pong&amp;rdquo;它已经这样做，以便&amp;ldquo; pong&amp;rdquo;也可以完成。另一种让&amp;ldquo; pong&amp;rdquo;结束的方法是，如果&amp;ldquo; pong&amp;rdquo;在一定时间内没有收到来自ping的消息，则退出该状态。这可以通过添加一个进行&lt;strong&gt;超时&lt;/strong&gt;到 &lt;code&gt;pong&lt;/code&gt; 如图以下示例：</target>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="translated">在安装之前,你应该通过运行我们的烟雾测试来测试你的构建是否正常工作,烟雾测试是完整的 Erlang/OTP 测试套件的子集。烟雾测试是完整的 Erlang/OTP 测试套件的一个子集。首先你需要构建并发布测试套件。</target>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="translated">在查看此程序的工作方式之前，请注意，一些注释已添加到代码中。注释以％字符开头，然后一直到行尾。还要注意 &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; 行仅包含函数 &lt;code&gt;format_temps/1&lt;/code&gt; 。其他功能是&lt;strong&gt;局部&lt;/strong&gt;功能，也就是说，从模块 &lt;code&gt;tut5&lt;/code&gt; 外部看不到它们。</target>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="translated">在注册名称之前，您应该已经在 &lt;code&gt;epmd&lt;/code&gt; 中注册了端口号。这不是严格必要的，但是如果您忽略了这样做，那么希望与您的服务进行通信的其他节点将找不到或连接到您的进程。</target>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="translated">向 &lt;code&gt;epmd&lt;/code&gt; 注册之前，必须首先创建一个监听套接字并将其绑定到端口。然后：</target>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="translated">在启动 &lt;code&gt;Mnesia&lt;/code&gt; 之前，必须完成以下操作：</target>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="translated">在开始之前,要注意以下几点。</target>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="translated">在调用 &lt;code&gt;deflateParams&lt;/code&gt; 之前，必须像调用 &lt;code&gt;deflate/3&lt;/code&gt; 一样设置流状态，因为可能需要压缩和刷新当前可用的输入。</target>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="translated">在第一次调用 &lt;code&gt;allow/1&lt;/code&gt; 之前，可以连接任何具有正确cookie的节点。当 &lt;code&gt;allow/1&lt;/code&gt; 被调用，建立允许节点列表。从（或到）不在该列表中的节点进行的任何访问尝试都将被拒绝。</target>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="translated">在转储日志之前，将文件 &lt;code&gt;LATEST.LOG&lt;/code&gt; 重命名为 &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; ，并创建一个新的 &lt;code&gt;LATEST.LOG&lt;/code&gt; 文件。成功转储日志后，将删除文件 &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="translated">在创建端口之前，必须先加载驱动程序。这可以通过功能 &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt; 来完成，共享库的名称作为参数。</target>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="translated">在遍历开始之前，使用 &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt; 打开源备份媒体，并使用 &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt; 打开目标备份媒体。参数如下：</target>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">在执行此指令之前，必须使用 &lt;code&gt;load_object_code&lt;/code&gt; 加载 &lt;code&gt;Mod&lt;/code&gt; 。该指令加载模块。 &lt;code&gt;PrePurge&lt;/code&gt; 被忽略。有关 &lt;code&gt;PostPurge&lt;/code&gt; 的描述，请参阅前面的高级指令 &lt;code&gt;update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">开始前缀-URI命名空间映射的范围。请注意,start/endPrefixMapping事件并不能保证彼此之间正确地相对嵌套:所有startPrefixMapping事件将紧接在相应的startElement事件之前发生,所有endPrefixMapping事件将紧接在相应的endElement事件之后发生,但它们的顺序并没有其他保证。对于 &quot;xml &quot;前缀,不会有start/endPrefixMapping事件,因为它是预先声明的,是不可改变的。</target>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="translated">行首</target>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="translated">从Erlang/OTP R14开始,在访问或更新嵌套记录时,可以省略括号。假设记录定义如下。</target>
        </trans-unit>
        <trans-unit id="04a97d065ff4fbd74684b1f948daab7f3b7943dc" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">表现为 &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; ，但生成一个二进制而不是Unicode列表。</target>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="translated">表现为 &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; ,除了它允许指定一个额外的选项，即 &lt;code&gt;allow_passive_connect&lt;/code&gt; 。此选项允许BIF等待正常的网络连接超时，以使&lt;strong&gt;受监视的节点&lt;/strong&gt;自行连接，即使无法从该节点主动连接（即被阻止）也是如此。仅在使用内核选项 &lt;code&gt;dist_auto_connect once&lt;/code&gt; 才能实现此状态。如果不使用该选项，则选项 &lt;code&gt;allow_passive_connect&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="58884446ca5852c4e8961c8c91d6b677aceaea96" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">描述用于SSH客户端公钥处理的API的行为。通过实现此行为中定义的回调，可以自定义SSH客户端的公钥处理。默认情况下， &lt;code&gt;ssh&lt;/code&gt; 应用程序在标准OpenSSH文件的帮助下实现此行为，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 应用程序手册。</target>
        </trans-unit>
        <trans-unit id="6c2cfec7cf1dcce3dafc9cae66013644e8eff42f" translate="yes" xml:space="preserve">
          <source>Behaviour Module Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505f096bd0cf99b3b2b5bc3d911574d1d3ac320" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">描述用于SSH服务器公钥处理​​的API的行为。通过实现此行为中定义的回调，可以自定义SSH服务器的公钥处理。默认情况下，SSH应用程序在标准OpenSSH文件的帮助下实现此行为，请参见 &lt;code&gt;ssh(6)&lt;/code&gt; 应用程序手册。</target>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="translated">报告SNMP代理错误的行为模块</target>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="translated">SNMP代理发现处理程序的行为模块。</target>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="translated">SNMP代理mib存储的行为模块。</target>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="translated">SNMP代理mib-服务器数据模块的行为模块。</target>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="translated">SNMP代理网络接口的行为模块。</target>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="translated">SNMP代理网络接口过滤器的行为模块。</target>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="translated">SNMP代理通知传递信息接收器的行为模块。</target>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="translated">SNMP代理通知过滤器的行为模块。</target>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="translated">SNMP管理器网络接口的行为模块。</target>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="translated">SNMP管理器网络接口过滤器的行为模块。</target>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="translated">SNMP管理器用户的行为模块。</target>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="translated">行为与可选的回调来定制inets HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="translated">下面是一个完整的示例，说明如果将OTP安装在目录 &lt;code&gt;/usr/local/otp&lt;/code&gt; 中，应该添加到用户的 &lt;code&gt;.emacs&lt;/code&gt; 中的内容：</target>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">下面是一个完整的示例，说明如果将OTP安装在目录 &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt; 中，则应添加到用户的 &lt;code&gt;.emacs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="translated">下面以上面的语法为例,加入结构建筑代码。</target>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="translated">基准可以测量壁时钟时间或CPU时间。</target>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">似乎是并发的基准通常是连续的。例如，estone基准完全是连续的。&amp;ldquo;环形基准&amp;rdquo;的最常见实现也是如此；通常一个进程处于活动状态，而其他进程则在 &lt;code&gt;receive&lt;/code&gt; 语句中等待。</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;qlc:table/2&lt;/code&gt; 之外，其他函数还返回查询句柄。它们比表格很少使用，但有时很有用。 &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; 互相遍历许多表或列表中的对象。例如，如果您想遍历查询 &lt;code&gt;QH&lt;/code&gt; 的所有答案，然后以术语 &lt;code&gt;{finished}&lt;/code&gt; 完成，则可以通过调用 &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt; 。 &lt;code&gt;append/2&lt;/code&gt; 首先返回 &lt;code&gt;QH&lt;/code&gt; 的所有对象，然后返回 &lt;code&gt;{finished}&lt;/code&gt; 。如果在 &lt;code&gt;QH&lt;/code&gt; 的答案中存在一个元组 &lt;code&gt;{finished}&lt;/code&gt; ，它会从 &lt;code&gt;append/2&lt;/code&gt; 返回两次。</target>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="translated">除了使用进程的pid对其进行寻址外,还有一些BIF用于用名字注册进程。该名称必须是一个原子,如果进程终止,该名称将自动取消注册。</target>
        </trans-unit>
        <trans-unit id="453d7ac3df855ff457e6e90c9784d798c45f0f44" translate="yes" xml:space="preserve">
          <source>Besides implementing the functionality enabling the scheduling, preparation of signal data without port lock, etc, each operation sending signals to ports had to be quite extensively re-written. This in order to move all sub-operations that can be done without the lock to a place before we have acquired the lock, and also since signals now sometimes are executed immediately and sometimes scheduled for execution at a later time which put different requirements on the data to pass along with the signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fc21da73002de65cd31f4246dde118952a0ef0" translate="yes" xml:space="preserve">
          <source>Besides passing carrier pool name as value to the parameter, you can also pass &lt;code&gt;:&lt;/code&gt;. By passing &lt;code&gt;:&lt;/code&gt; instead of carrier pool name, the allocator will use the carrier pool associated with itself. By passing the command line argument &quot;&lt;code&gt;+Mucg :&lt;/code&gt;&quot;, all allocators that have an associated carrier pool will use the carrier pool associated with themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5348075792306c67e1b0814d6ba0ff860d6cb22" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除了报告时间外， &lt;code&gt;erlang:now/0&lt;/code&gt; 还产生唯一且严格单调增加的值。为了将此功能与时间测量分开，我们引入了 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="translated">除了测试用例和组外，测试套件还可以包含配置功能。这些功能旨在用于在SUT（和/或 &lt;code&gt;Common Test&lt;/code&gt; 主机节点）中设置（和验证）环境和状态，这些是测试正确执行所必需的。操作示例包括：打开与SUT的连接，初始化数据库，运行安装脚本等。可以针对每个套件，每个测试用例组以及每个单独的测试用例执行配置。</target>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="translated">除了已经提到的源参数 &lt;code&gt;root_dir&lt;/code&gt; 和 &lt;code&gt;lib_dirs&lt;/code&gt; 之外，还支持以下系统（ &lt;code&gt;sys&lt;/code&gt; ）级选项：</target>
        </trans-unit>
        <trans-unit id="e7b2c0c382d27b288446a0bacbb0c94ce486cb4f" translate="yes" xml:space="preserve">
          <source>Best Practices for Using Persistent Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="translated">模块之间</target>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="translated">节点之间</target>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="translated">进程之间</target>
        </trans-unit>
        <trans-unit id="f6202bc62a181da8db026f3b5d7d396e4ee251e7" translate="yes" xml:space="preserve">
          <source>Between step 6 and 8, runninng processes might execute the written &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction. They will get the breakpoint structure written in step 3, read &lt;code&gt;erts_active_bp_index&lt;/code&gt; and execute the corresponding part of the breakpoint. Before the switch in step 8 becomes visible they will however execute the disabled part of the breakpoint structure and do nothing other than executing the saved original instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0ece311d270b7fe14ea09dcb08057562506122" translate="yes" xml:space="preserve">
          <source>Beware</source>
          <target state="translated">Beware</target>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="translated">谨防混淆M位意义上的强制性和命令语法意义上的强制性。前者是语义要求:接收者要理解AVP在有关上下文中的语义。后者是句法上的要求:AVP是否必须出现在有关消息中。</target>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="translated">当心要使用的 &lt;code&gt;Replacement&lt;/code&gt; 的尾随空间。如果在 &lt;code&gt;Re&lt;/code&gt; 中必须有一个空格，请使用例如编码 &lt;code&gt;\040&lt;/code&gt; 的字符，请参见 &lt;code&gt;re(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在乐趣不是短暂的并且在运行时将要升级代码的情况下，请小心使用形式为 &lt;code&gt;fun Name/Arity&lt;/code&gt; 的 fun表达式，因为任何保留这种乐趣的进程都将引用旧代码。特别是，在传递给 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 的配置中，这样的值通常是不合适的。</target>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="translated">请注意,RFC 6733改变了RFC3588中指定的DiameterURI传输/端口默认值。依赖默认值会导致互操作性问题。</target>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="translated">注意&lt;strong&gt;直径&lt;/strong&gt;（不大写）和&lt;strong&gt;直径&lt;/strong&gt;（大写）之间的差异。前者是指Erlang应用程序，该应用程序在此处定义了其主要api的直径，而后者是在RFC 6733意义上的Diameter协议。</target>
        </trans-unit>
        <trans-unit id="7e27c93748471a211ccbeda730113ee702b30a76" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the bignum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Bignum以带 &lt;code&gt;Sign&lt;/code&gt; 字节的一元形式存储，即，如果Binum为正，则为0；如果Binum为负，则为1。这些数字与最低有效字节一起存储。要计算整数，可以使用以下公式：</target>
        </trans-unit>
        <trans-unit id="915f680c2bd74e3a951cc35061c83bda7c9d3906" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt; erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt; erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">二进制文件使用位语法表达式或 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; ， &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt; 或从二进制端口输入来生成。的 &lt;code&gt;Len&lt;/code&gt; 长度字段是无符号的4字节整数（大端）。</target>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="translated">二进制文件比较麻烦。出于性能原因，程序通常将文本数据存储在二进制文件中而不是列表中，这主要是因为它们更紧凑（每个字符一个字节，而不是每个字符两个字，如列表所示）。使用 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; ，可以有效地使用按字节编码将ISO Latin-1 Erlang字符串转换为二进制：每个字符一个字节。这对于有限的Erlang字符串很方便，但对于任意Unicode列表则无法实现。</target>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="translated">二进制文件是整个字节的序列。目前还不支持任意位长的位串。</target>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="translated">二进制文件可以通过以下方式有效构建。</target>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="translated">二进制可以这样高效匹配。</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="translated">Binary &lt;code&gt;Bin&lt;/code&gt; 包含与 &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt; 的输出相同的信息。使用 &lt;code&gt;binary_to_list/1&lt;/code&gt; 从二进制文件中获取字符串。</target>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="translated">二进制启动脚本</target>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="translated">二进制回调函数 &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; 用于查找表中的对象。第一个参数 &lt;code&gt;Position&lt;/code&gt; 是键位置或索引位置，第二个参数 &lt;code&gt;Keys&lt;/code&gt; 是唯一值的排序列表。返回值将是所有对象（元组）的列表，以使 &lt;code&gt;Position&lt;/code&gt; 处的元素成为 &lt;code&gt;Keys&lt;/code&gt; 的成员。任何其他返回值都将立即作为查询评估值返回。如果在编译时进行的语法转换可以确定过滤器匹配并比较 &lt;code&gt;Position&lt;/code&gt; 上的元素，从而只使用 &lt;code&gt;Keys&lt;/code&gt; ,则调用 &lt;code&gt;LookupFun&lt;/code&gt; 而不是遍历表 需要查找所有可能的答案。</target>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="translated">二进制编解码器</target>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="translated">二进制数据在进程之间是共享的。如果另一个进程还在引用较大的二进制数据,那么复制这个进程使用的部分只会消耗更多的内存,而不会释放较大的二进制数据用于垃圾回收。使用这种侵入性函数要格外小心,只有在发现真正的问题时才会使用。</target>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="translated">二进制处理在R12B中得到了显著改进。因为在R11B中高效的代码在R12B中可能并不高效,反之亦然,所以本《效率指南》的早期修订版包含了一些关于R11B中二进制处理的信息。</target>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="translated">只要拆分二进制文件，就会发生二进制共享。这是二进制文件快速运行的根本原因，总能以O（1）复杂度完成分解。但是，在极少数情况下，这种数据共享是不可取的，为什么在优化内存使用时将此功能与 &lt;code&gt;copy/1&lt;/code&gt; 一起使用可能会很有用。</target>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="translated">以UTF-8或UTF-16编码的二进制字符。</target>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="translated">二进制,字符编码为iso-latin-1。</target>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="translated">BinaryGraphOp :: = &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">BinarySetOp :: = &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eb97ea1779ca334fa82951915ccbbf0c411af8d" translate="yes" xml:space="preserve">
          <source>Bind a name to a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13da3886205091801df2d6f1afb4618b1d0ec53" translate="yes" xml:space="preserve">
          <source>Bind the socket identified by &lt;code&gt;ctx&lt;/code&gt; to a local interface and then listen on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4666da54d73c3984e4c044ae18083dcbc9b65311" translate="yes" xml:space="preserve">
          <source>Binding and Using a Size Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="translated">在具体的平台上不支持调度器的绑定。</target>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="translated">调度器的绑定只在较新的Linux、Solaris、FreeBSD和Windows系统上支持。</target>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将套接字绑定到特定的网络接口。必须在创建套接字的函数调用中使用此选项，即 &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63d9eb9271114848197174178defd97f77fc4e24" translate="yes" xml:space="preserve">
          <source>Bit Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="translated">位串理解类似于列表理解。它们用于高效、简洁地生成位串。</target>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="translated">位串理解的写法如下。</target>
        </trans-unit>
        <trans-unit id="5d2f7999e57c41f3eb88a4f59c1cc481292645c5" translate="yes" xml:space="preserve">
          <source>Bit strings are compared bit by bit. If one bit string is a prefix of the other, the shorter bit string is considered smaller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">位字符串使用 &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="translated">由数个可以被八整除的位数组成的位串称为&lt;strong&gt;二进制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="translated">右移位</target>
        </trans-unit>
        <trans-unit id="a8a268a3b89f5db9e48e02038fd78e154fb41041" translate="yes" xml:space="preserve">
          <source>Bitstring Element Type Specifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">位元 AND</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">位式OR</target>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="translated">位运算符： &lt;code&gt;band&lt;/code&gt; ， &lt;code&gt;bor&lt;/code&gt; ， &lt;code&gt;bxor&lt;/code&gt; ， &lt;code&gt;bnot&lt;/code&gt; ， &lt;code&gt;bsl&lt;/code&gt; ， &lt;code&gt;bsr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="translated">对任何类型的目标系统进行黑盒测试（不一定在Erlang中实现）。通过标准的O＆M接口（例如SNMP，HTTP，CORBA和Telnet）以及必要时通过用户特定的接口（通常称为测试端口）来执行此操作。</target>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">分组密码-分组密码模式下的DES和AES- &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="translated">类似于子句主体，块表达式提供了一种对表达式序列进行分组的方法。返回值是最后一个表达式 &lt;code&gt;ExprN&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="translated">通常不需要阻塞多个调度和正常的多个调度。如果您认为需要使用这些功能，请再考虑几次。阻塞式多调度仅用作最后的手段，因为它很可能是解决问题的&lt;strong&gt;非常低效的&lt;/strong&gt;方法。</target>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="translated">大于单块载波阈值（ &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; ）参数的值的块将放置在单块载波中。</target>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="translated">小于参数 &lt;code&gt;sbct&lt;/code&gt; 的值的块将放置在多块载波中。</target>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="translated">布尔表达式</target>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="translated">布尔运算符： &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;andalso&lt;/code&gt; ， &lt;code&gt;orelse&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="translated">ASN.1中的布尔值表示可以为 &lt;code&gt;TRUE&lt;/code&gt; 或 &lt;code&gt;FALSE&lt;/code&gt; 的值。分配给 &lt;code&gt;TRUE&lt;/code&gt; 和 &lt;code&gt;FALSE&lt;/code&gt; 的含义超出了本文的范围。</target>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="translated">启动脚本</target>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="translated">使用SASL应用程序中的 &lt;code&gt;systools&lt;/code&gt; 实用程序来构建引导脚本。有关 &lt;code&gt;systools&lt;/code&gt; 的更多信息，请参见SASL文档。这仅仅是可以做的一个例子。</target>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="translated">其他 Erlang 机器的启动服务器。</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">双方 &lt;code&gt;GetInfo&lt;/code&gt; 和 &lt;code&gt;GetBin&lt;/code&gt; 必须在内部调用 &lt;code&gt;Fun&lt;/code&gt; 。如果在 &lt;code&gt;Fun&lt;/code&gt; 上下文之外调用它们，则它们的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="translated">无论 &lt;code&gt;WarningList&lt;/code&gt; 和 &lt;code&gt;ErrorList&lt;/code&gt; 格式如下：</target>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="translated">两者 &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt; 有&lt;strong&gt;返回值&lt;/strong&gt;，也就是，在上述例子 &lt;code&gt;case&lt;/code&gt; 返回的任一 &lt;code&gt;{inch,X/2.54}&lt;/code&gt; 或 &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt; 。 &lt;code&gt;case&lt;/code&gt; 的行为也可以通过使用防护来修改。以下示例对此进行了说明。它告诉我们给定年份的长度。必须知道这一年，因为二月是a年的29天。</target>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="translated">无论 &lt;code&gt;sys&lt;/code&gt; 和 &lt;code&gt;proc_lib&lt;/code&gt; 属于STDLIB应用。</target>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="translated">使用动态跟踪探针构建和使用它们都是实验性的,而且不受Erlang/OTP的支持。它是作为一个选项被包含在系统中,供开发者跟踪和调试性能问题。</target>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">客户端和守护程序都接受控制确切行为的选项。某些选项是两者共有的。这三组称为&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; ，&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="translated">下文将介绍这两种功能。</target>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="translated">允许增加和减少 &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="translated">这两种机制的理论时间和记忆复杂度相同,而选择性接收语言建构的常数因素较小。</target>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="translated">它们都可以为空，但不能同时为空。如果 &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; 为空，则不会进行任何更改以更改任何应用程序的生成结果。例如，这可能是构建系统的纯错误修复。行的顺序是不确定的。此文件中的所有空白字符都是空格（字符32）或换行符（字符10）。</target>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="translated">一个模块的旧代码和当前代码都是有效的,甚至可以同时进行评估。不同的是,旧代码中的导出函数不可用。因此,不能对旧代码中的导出函数进行全局调用,但旧代码仍然可以被评估,因为其中有进程滞留。</target>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="translated">旧代码和当前代码都是有效的,并且可以同时进行评估。完全合格的函数调用总是参考当前代码。旧代码仍然可以被评估,因为进程在旧代码中滞留。</target>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">这两个选项都具有相同的效果，输入字符串被解释为UTF-8。请注意，通过这些指令， &lt;code&gt;re&lt;/code&gt; 功能不会执行列表到UTF-8的自动转换。因此，不建议使用这些序列。而是在运行 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 时添加选项 &lt;code&gt;unicode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">服务器和事件管理器都是已注册的进程，可以期望它们始终可访问。因此，它们被指定为 &lt;code&gt;permanent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="translated">该模块的源代码和对象代码均已找到。</target>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="translated">代理和管理器均可配置为记录传入和传出消息。它使用Erlang标准日志机制 &lt;code&gt;disk_log&lt;/code&gt; 进行日志记录。日志文件的大小和位置是可配置的。使用自动换行日志，这意味着当日志增长到最大大小时，它将从日志的开头开始，覆盖现有的日志记录。</target>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="translated">&lt;code&gt;main/1&lt;/code&gt; 函数的模块声明和导出声明都是可选的。</target>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 和 &lt;code&gt;.rel&lt;/code&gt; 文件的旧版本和新版本以及 &lt;code&gt;.appup&lt;/code&gt; 和（新） &lt;code&gt;.beam&lt;/code&gt; 文件都必须在代码路径中。可以使用选项 &lt;code&gt;path&lt;/code&gt; 扩展代码路径：</target>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="translated">注册和锁定服务都是原子的。参与这些操作的所有节点都有相同的信息视图。</target>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="translated">这两个工具都使用随工具提供的消息包(time_test.msgs),尽管它可以在任何消息包上运行,只要它具有相同的结构。</target>
        </trans-unit>
        <trans-unit id="127d494892f18e1ed814ec5250b9730b0af20bb3" translate="yes" xml:space="preserve">
          <source>Both times are in milli seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="translated">同时支持连接建立时的传输安全和通过带内安全AVP协商的安全。</target>
        </trans-unit>
        <trans-unit id="6c92949313aaa03bcf35ffa7934493789f21f7cd" translate="yes" xml:space="preserve">
          <source>Both when the client establishes a connection with ssh:connect or other functions, or a daemon is started with ssh:daemon, the option lists in the function calls are also used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="translated">对收到的Diameter消息的预期大小进行约束。超过指定字节数的信息将被丢弃。</target>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="translated">绑定部件(Erlang术语</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="5ff74b881495206c989aabf9a3102e44cc4e4f4e" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Suppresses generation of dispatch of the next instruction (&lt;code&gt;-no_next&lt;/code&gt;). Typical use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ee5bc7776fe10e3fd6ef23bda664af1a74f8a6" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Will suppress prefetch (&lt;code&gt;-no_prefetch&lt;/code&gt;). Typical use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="translated">分支的现有关联 &lt;code&gt;Assoc&lt;/code&gt; 以插座 &lt;code&gt;Socket&lt;/code&gt; 类型的 &lt;code&gt;seqpacket&lt;/code&gt; （一到许多风格）到一个新的套接字 &lt;code&gt;NewSocket&lt;/code&gt; 类型的 &lt;code&gt;stream&lt;/code&gt; （一到一个样式）。</target>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="translated">只有在lookbehind断言的顶层才允许匹配不同长度字符串的分支。这是与Perl相比的一个扩展,Perl要求所有的分支都要匹配相同长度的字符串。像下面这样的断言是不允许的,因为它的单个顶层分支可以匹配两个不同长度的字符串。</target>
        </trans-unit>
        <trans-unit id="2e74a43e735ca8cd77a918952d725756f6ea7331" translate="yes" xml:space="preserve">
          <source>Break Menu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1151e1739c46421831435065fa64d3a4378e7dc" translate="yes" xml:space="preserve">
          <source>Break, Windows, and Help Menus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="translated">以这种方式拆分长期运行的函数,使虚拟机能够在调用NIF之间重新获得控制权。</target>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="translated">使用&amp;ldquo; 监视&amp;rdquo;窗口，&amp;ldquo;查看模块&amp;rdquo;窗口或&amp;ldquo;附加过程&amp;rdquo;窗口的&amp;ldquo; &lt;strong&gt;中断&amp;rdquo;&lt;/strong&gt;菜单可以创建和删除断点。</target>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="translated">断点用停止符号标记。</target>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="translated">断点是以行为单位指定的。当一个在解释模块中执行代码的进程到达断点时,它就会停止。这意味着断点必须设置在可执行行,即包含可执行表达式的代码行。</target>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="translated">简单介绍一下Solaris 10</target>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="translated">在条件变量上广播。也就是说，如果其他线程正在等待广播条件变量，则&lt;strong&gt;所有&lt;/strong&gt;线程都将被唤醒。</target>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">在指定节点上以异步方式将消息 &lt;code&gt;Msg&lt;/code&gt; 广播到注册的进程 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">在指定节点上将消息 &lt;code&gt;Msg&lt;/code&gt; 同步广播到已注册的进程 &lt;code&gt;Name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="translated">浏览应用程序配置文件（做&lt;strong&gt;不&lt;/strong&gt;编辑）。通过添加 &lt;code&gt;/ebin/os_mon.app&lt;/code&gt; ，从文件系统中 &lt;code&gt;os_mon&lt;/code&gt; 应用程序的位置获取应用程序配置文件的全名。</target>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="translated">浏览终端上的表 &lt;code&gt;Tab&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="translated">通过加载页面 &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; 或 &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; (如果已使用prefix选项）来浏览html页面。</target>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="translated">Buf被初始化为包含对象属性。</target>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="translated">缓冲区太小。</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="translated">建立Erlang/OTP</target>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="translated">建设问题</target>
        </trans-unit>
        <trans-unit id="9bd5d4eae87e4cb4572c4356e658e62097907c06" translate="yes" xml:space="preserve">
          <source>Build Your Own Tool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="translated">构建或安装FIPS对象模块和支持FIPS的OpenSSL库。</target>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="translated">构建Erlang/OTP版本。</target>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="translated">建立启动脚本。</target>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="translated">建立文件。</target>
        </trans-unit>
        <trans-unit id="a24b09d07965fb944dc46c1d07ebc9828be50298" translate="yes" xml:space="preserve">
          <source>Build with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="translated">建筑二郎山/ OTP可以通过使用来完成 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 脚本，或通过调用 &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 直接。使用 &lt;code&gt;otp_build&lt;/code&gt; 进行构建比较容易，因为它涉及的步骤更少，但是 &lt;code&gt;otp_build&lt;/code&gt; 构建过程并不像 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 构建过程那样灵活。请注意， &lt;code&gt;otp_build configure&lt;/code&gt; 将产生一个默认配置，该 &lt;code&gt;configure&lt;/code&gt; 与configure将默认产生的配置不同。例如，当前 &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; 已添加到 &lt;code&gt;configure&lt;/code&gt; 命令行参数中，除非 &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; 已显式传递。我们提供的二进制发行版使用 &lt;code&gt;otp_build&lt;/code&gt; 构建。 &lt;code&gt;otp_build configure&lt;/code&gt; 使用的默认值可能随时更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">建筑二郎山/ OTP可以通过使用来完成 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 脚本，或通过调用 &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 直接。使用 &lt;code&gt;otp_build&lt;/code&gt; 进行构建比较容易，因为它涉及的步骤更少，但是 &lt;code&gt;otp_build&lt;/code&gt; 构建过程并不像 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 构建过程那样灵活。我们提供的Windows二进制发行版是使用 &lt;code&gt;otp_build&lt;/code&gt; 构建的。</target>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">在相对较快的计算机上构建Erlang / OTP大约需要5分钟。为了加快速度，可以使用带有 &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; 选项的并行make 。</target>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="translated">构建一个Bootstrap系统</target>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="translated">在Git中建设</target>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="translated">使用 &lt;code&gt;otp_build&lt;/code&gt; 脚本最容易构建：</target>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="translated">以OS X为基础</target>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="translated">建立术语和模式</target>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="translated">使用wxErlang构建</target>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="translated">使用wxWidgets构建。下载 wxWidgets-3.0.3 或更高版本。</target>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="translated">从一个分块列表中构建一个BEAM模块(作为二进制)。</target>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">构建表示搜索模式编译的内部结构，稍后将在功能 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt; 中使用。返回的 &lt;code&gt;cp()&lt;/code&gt; 保证为 &lt;code&gt;tuple()&lt;/code&gt; ,以使程序可以将其与非预编译的搜索模式区分开。</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="translated">内置期限存储。</target>
        </trans-unit>
        <trans-unit id="0bb738fd2329e288e2fef0e51024a5ca1fdbc3e0" translate="yes" xml:space="preserve">
          <source>Busy Port Queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5c53caa503fd2d5724e0037aba0a5ac29a1adc" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;'ssh-dss'&lt;/code&gt; is selected although the call inserted &lt;strong&gt;only&lt;/strong&gt;&lt;code&gt;'ecdsa-sha2-nistp256'&lt;/code&gt; as acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298adb411a18178593c4d780e03d5a00362414a8" translate="yes" xml:space="preserve">
          <source>But before all name servers are tried again, there is a (user configurable) timeout, &lt;code&gt;servfail_retry_timeout&lt;/code&gt;. The point of this is to prevent the new query to be handled by to the servfail cache (a client that is to eager will actually only get what is in the servfail cache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb37192b82c7544aec29ebacff8270ec18c0cbee" translate="yes" xml:space="preserve">
          <source>But how can the client know that the host</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="translated">但是，如果将常量发送到另一个进程（或存储在Ets表中），则会&lt;strong&gt;将&lt;/strong&gt;其&lt;strong&gt;复制&lt;/strong&gt;。原因是运行时系统必须能够跟踪对常量的所有引用，以正确卸载包含常量的代码。（当卸载代码时，将常量复制到引用它们的进程的堆中。）在将来的Erlang / OTP版本中可能会删除常量的复制。</target>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="translated">但是在比较复杂的代码中,如何才能知道是否应用了优化呢?</target>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="translated">但它会在第一个子句中生成构建子二进制的代码。</target>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="translated">但这就是历史。在R6B中为Funs提供了自己的数据类型，并在R7B中对其进行了进一步优化。现在，一个有趣的调用的成本大致介于调用本地函数和 &lt;code&gt;apply/3&lt;/code&gt; 的成本之间。</target>
        </trans-unit>
        <trans-unit id="ff87650cc86869f3f95aa712bb2012bf312a0ec1" translate="yes" xml:space="preserve">
          <source>But they &lt;strong&gt;cannot&lt;/strong&gt; be combined with intAgentTransports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="translated">但是这个失败了,因为弗雷德已经注销了。</target>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="translated">但这个失败了。</target>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但这还不够。网络接口实体还必须能够接收和发送一组&lt;strong&gt;强制&lt;/strong&gt;消息。在 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt; 一章中对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="translated">但是，按如下方式使用 &lt;code&gt;++&lt;/code&gt; 也不错：</target>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="translated">但是你意识到,在这个里面没有必要有Erlang编译器。</target>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="translated">但是，即使如此，我们仍然&lt;strong&gt;可以&lt;/strong&gt;找到对链接驱动程序的调用，该驱动程序对主机操作系统执行文件操作：</target>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="translated">通过&lt;strong&gt;附加到&lt;/strong&gt;执行解释代码的进程，可以检查变量绑定并命令逐步执行。这是通过通过称为元流程的第三流程向流程发送信息或从流程接收信息来完成的。您可以实现自己的附加过程。见 &lt;code&gt;int.erl&lt;/code&gt; 可用的功能和 &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; 可能的消息。</target>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="translated">我们所说的SASL报告是指主管报告、碰撞报告和进度报告。</target>
        </trans-unit>
        <trans-unit id="df385cba3294f848291c72e2a88cfe1519f5944b" translate="yes" xml:space="preserve">
          <source>By being able to determine when the first event above has occurred we can easily know when all managed threads have completed accesses to a data structure. This can be determined the following way. We have an implementation of some functionality &lt;code&gt;F&lt;/code&gt; using a data structure &lt;code&gt;D&lt;/code&gt;. The reference to &lt;code&gt;D&lt;/code&gt; is always looked up before &lt;code&gt;D&lt;/code&gt; is being accessed, and the references to &lt;code&gt;D&lt;/code&gt; is always dropped before we leave the code implementing &lt;code&gt;F&lt;/code&gt;. If we remove the possibility to look up &lt;code&gt;D&lt;/code&gt; and then wait until the first event has occurred in all managed threads, no managed threads can have any references to the data structure &lt;code&gt;D&lt;/code&gt;. This could for example have been achieved by using reference counting, but the cache line containing the reference counter would in this case be ping ponged between all processors accessing &lt;code&gt;D&lt;/code&gt; at every access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524b3185d88f75bd50294ceb9e69a53458ed7610" translate="yes" xml:space="preserve">
          <source>By being able to determine when the second event has occurred it is quite easy to do complex modifications of memory that needs to be seen consistently by other threads without having to resort to locking. By doing the modifications, then issuing a full memory barrier, then wait until the second event has occurred in all managed threads, and then publish the modifications, we know that all managed threads reading this memory will get a consistent view of the modifications. Managed threads reading this will not have to issue any extra memory barriers at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="translated">通过在由 &lt;code&gt;new/4&lt;/code&gt; 创建的任何颜色项上调用 &lt;code&gt;blend/2&lt;/code&gt; ，可以如由两个映射项所确定的那样计算所得颜色。</target>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="translated">通过在生成的模块中调用函数 &lt;code&gt;info/0&lt;/code&gt; ，您可以获得有关使用了哪些编译器选项的信息。</target>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="translated">通过单击任何表的列标题中的名称（例如&amp;ldquo; Ok&amp;rdquo;，&amp;ldquo; Case&amp;rdquo;，&amp;ldquo; Time&amp;rdquo;，等等），表行以对值类型有意义的任何顺序排序（例如，数字表示&amp;ldquo;确定&amp;rdquo;或&amp;ldquo;时间&amp;rdquo;，字母表示&amp;ldquo;案例&amp;rdquo;。通过自动插入HTML日志文件中的JavaScript代码执行排序。 &lt;code&gt;Common Test&lt;/code&gt; 为此实现使用 &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; 库和 &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; 插件以及自定义排序功能。</target>
        </trans-unit>
        <trans-unit id="6ea0e955d25fd75ff5b4bf677527caab934dbed9" translate="yes" xml:space="preserve">
          <source>By combining the modifications of the process state management and the run queue management, we can do large parts of the work involved when managing processes with regards to scheduling and migration without having any locks locked at all. In these situations we previously had to have multiple locks locked. This of course caused a lot of rewrites across large parts of the runtime system, but the rewrite both simplified code and eliminated locking at a number of places. The major benefit is, of course, reduced contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="translated">通过配置,您还可以修改或禁用默认处理程序,用自定义处理程序替换,并安装其他处理程序。</target>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="translated">按照惯例，此模块中包含大多数内置函数（BIF）。某些BIF或多或少被视为Erlang编程语言的一部分，并且会&lt;strong&gt;自动导入&lt;/strong&gt;。因此，无需指定模块名称。例如，调用 &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; 和 &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; 是相同的。</target>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="translated">按照惯例，tar文件的名称以&amp;ldquo; &lt;code&gt;.tar&lt;/code&gt; &amp;rdquo; 结尾。为了遵守约定，在名称中添加&amp;ldquo; &lt;code&gt;.tar&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="translated">按照惯例，zip文件的名称以 &lt;code&gt;.zip&lt;/code&gt; 结尾。为了遵守约定，请在文件名中添加 &lt;code&gt;.zip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="translated">默认情况下,一次可合并16个文件。这个选项很少需要。</target>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">默认情况下，每当已在日志中写入100条记录或经过三分钟时， &lt;code&gt;Mnesia&lt;/code&gt; 都会转储日志。这由两个应用程序参数 &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; 和 &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="f74ee3ee744473dfcdc8d613d9c22514ab7711d7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 1000 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b4d9f0f830cdbeba0bff6368aca7f38a671867" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;ei&lt;/code&gt; supplies a TCP/IPv4 socket interface that is used when communicating. The user can however plug in his/her own IPv4 socket implementation. This, for example, in order to communicate over TLS. A user supplied socket implementation is plugged in by passing a &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks&quot;&gt;callback structure&lt;/a&gt;&lt;/code&gt; to either &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">默认情况下，即使您可以使用与内核中 &lt;code&gt;gen_tcp&lt;/code&gt; 模块相同的应用程序编程接口（API）插入任何其他可靠的传输协议，SSL / TLS 仍会通过TCP / IP协议运行。默认情况下，DTLS通过UDP / IP运行，这意味着应用程序数据没有交付保证人。将来的版本可能会支持其他传输，例如SCTP。</target>
        </trans-unit>
        <trans-unit id="eabed6d7dfce1497434c059489829d94c31442b4" translate="yes" xml:space="preserve">
          <source>By default TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="translated">默认情况下,从文件中读取的约512*1024字节会被内部排序。这个选项很少需要。</target>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">在OTP 17中，默认情况下已更改了以Erlang术语表示的 &lt;code&gt;BIT STRING&lt;/code&gt; 和 &lt;code&gt;OCTET STRING&lt;/code&gt; 类型的表示。 &lt;code&gt;BIT STRING&lt;/code&gt; 值现在是Erlang位字符串， &lt;code&gt;OCTET STRING&lt;/code&gt; 值是二进制。另外，现在将未解码的打开类型包装在 &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; 元组中。有关详细信息，请参阅《用户指南》中的 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="translated">默认情况下,它是不包含的,但如果这个选项存在,它将会被包含。</target>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="translated">默认情况下,它不被包含,但如果这个选项存在,它将被包含。参考文本将被放在表的mib条目记录(#me{})的allocList字段中。</target>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="translated">在此类系统上，默认情况下，如果终端支持UTF-8，则Erlang以 &lt;code&gt;utf8&lt;/code&gt; 文件名模式启动，否则以 &lt;code&gt;latin1&lt;/code&gt; 模式启动。</target>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="translated">默认情况下，除非服务器在功能列表中包括 &lt;code&gt;:candidate&lt;/code&gt; 或 &lt;code&gt;:startup&lt;/code&gt; ，否则只有运行中的目标可用。</target>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="translated">默认情况下，系统级别的 &lt;code&gt;Application inclusion policy&lt;/code&gt; 用于所有应用程序。如果要显式包括一个特定的应用程序，则将值设置为 &lt;code&gt;include&lt;/code&gt; 。如果您想排除该应用程序，尽管它被另一个（显式或隐式）包含的应用程序使用，则将其设置为 &lt;code&gt;exclude&lt;/code&gt; 。 &lt;code&gt;derived&lt;/code&gt; 意思是，如果其他（显式或隐式）包含的应用程序使用该应用程序，则该应用程序将自动包含在内。</target>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="translated">默认情况下，系统级别的 &lt;code&gt;Module inclusion policy&lt;/code&gt; 用于所有应用程序。如果只希望包含实际使用的模块，请将其设置为 &lt;code&gt;derived&lt;/code&gt; 。如果您除了派生模块之外还希望包含app文件中列出的模块，请将其设置为 &lt;code&gt;app&lt;/code&gt; 。如果除了派生模块之外，还希望包含作为梁文件存在于ebin目录中的模块，请将其设置为 &lt;code&gt;ebin&lt;/code&gt; 。如果要包含所有模块，则将其设置为 &lt;code&gt;all&lt;/code&gt; ，即在ebin目录中找到并在应用文件中列出的模块的并集。</target>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="translated">默认情况下,EPMD在4369端口监听。</target>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="translated">默认情况下,TLS/DTLS客户端会尝试重用一个可用的会话,默认情况下,TLS/DTLS服务器也同意在客户端要求时重用会话。</target>
        </trans-unit>
        <trans-unit id="81d8c9fb8831024a08c4d93b4cdac4bc82433614" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it. See also &lt;code&gt; Session Reuse Pre TLS-1.3 &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="translated">默认情况下,当前存储的事件(existing)会被写入一个全新的文件(write),事件被写入文件后会被保留(keep)。</target>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="translated">默认情况下，Flex扫描仪报告错误的行号。但是它可以在没有行号报告的情况下构建。而是使用令牌号。这样可以将扫描速度提高5-10％。配置应用程序时，请使用 &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="translated">默认情况下，建立连接时使用由功能 &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; 设置的套接字选项。</target>
        </trans-unit>
        <trans-unit id="c911090b3724ca04bd13ed3fc1bce3d52a0723e3" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt; erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认情况下，如果特定平台上存在对时间校正的支持，则启用时间校正。对它的支持包括OS提供的OS单调时间，以及使用OS单调时间的Erlang运行时系统中的实现。要检查您的系统是否支持OS单调时间，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 。要检查系统上是否启用了时间校正，请调用 &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 从所有节点获取跟踪日志和跟踪信息文件。日志存储在跟踪控制节点工作目录下名为 &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; 的新目录中。取可通过提供选项禁用 &lt;code&gt;nofetch&lt;/code&gt; 到 &lt;code&gt;ttb:stop/1&lt;/code&gt; 。用户可以通过传递选项 &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt; 来指定获取目录。</target>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;Char&lt;/code&gt; 为 &lt;code&gt;$\s&lt;/code&gt; 而 &lt;code&gt;Dir&lt;/code&gt; 为 &lt;code&gt;trailing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="translated">默认情况下， &lt;code&gt;Common Test&lt;/code&gt; 在每个测试运行中创建一个中央私有目录，由所有测试用例共享。这并不总是合适的。尤其是如果相同的测试用例在测试运行期间多次执行（也就是说，如果它们属于具有属性 &lt;code&gt;repeat&lt;/code&gt; 的测试用例组），则存在私有目录中的文件被覆盖的风险。在这种情况下，可以将 &lt;code&gt;Common Test&lt;/code&gt; 配置为为每个测试用例创建一个专用的专用目录，然后执行。这是通过标志/选项 &lt;code&gt;create_priv_dir&lt;/code&gt; （与 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 程序 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 一起使用)完成的。功能，或作为测试规范术语）。此选项有三个可能的值，如下所示：</target>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;Dir&lt;/code&gt; 的 &lt;code&gt;leading&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="translated">默认情况下，仅保证 &lt;code&gt;ERTS&lt;/code&gt; 与 &lt;code&gt;ERTS&lt;/code&gt; 本身相同版本中的其他Erlang / OTP组件兼容。</target>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;IgnoreCase&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;Norm&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;Length&lt;/code&gt; 为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">默认情况下， &lt;code&gt;relup&lt;/code&gt; 文件位于当前工作目录中。如果指定了选项 &lt;code&gt;{outdir,Dir}&lt;/code&gt; ，则 &lt;code&gt;relup&lt;/code&gt; 文件位于 &lt;code&gt;Dir&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="translated">默认情况下，如果找不到有关初始调用的信息 &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; 则返回{proc_lib，init_p，5}。假定调用者知道该进程已由 &lt;code&gt;proc_lib&lt;/code&gt; 模块产生。</target>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="translated">默认情况下，调试器仅保存有关递归函数调用的信息，即尚未返回值的函数调用（选项&lt;strong&gt;Stack On，No Tail&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="translated">默认情况下， &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt; 将本机编译的结果缓存在$ XDG_CACHE_HOME / erlang / dialyzer_hipe_cache目录中。 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 的默认值为 &lt;code&gt;$HOME/.cache&lt;/code&gt; 。使用此选项禁用缓存。</target>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="translated">默认情况下，将启动Erlang，以便仅 &lt;code&gt;latin1&lt;/code&gt; 字符范围表示整数列表是字符串。</target>
        </trans-unit>
        <trans-unit id="600a9af71026fcfac59ffff3d502bc67475337e3" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt; printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">默认情况下，Erlang仅将Latin-1范围内的字符列表检测为字符串，但是 &lt;code&gt;+pc unicode&lt;/code&gt; 标志可用于更改此列表（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; ）。例如：</target>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，Erlang / OTP版本将安装在 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 中。例如，如果您没有权限安装在标准位置，则可以在其他位置安装Erlang / OTP。例如，要安装在 &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt; 中，请使用 &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="97faf8e4ee820690a95a2f9c0c26ec78fc837744" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/23.2/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/23.2&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="translated">默认情况下，PCRE将主题字符串视为由一行字符组成（即使包含换行符）。&amp;ldquo;行首&amp;rdquo;元字符（ &lt;code&gt;^&lt;/code&gt; ）仅在字符串的开头匹配，而&amp;ldquo;行尾&amp;rdquo;元字符（ &lt;code&gt;$&lt;/code&gt; ）仅在字符串的末尾或终止换行符之前匹配（除非指定了option &lt;code&gt;dollar_endonly&lt;/code&gt; ）。这与Perl中的相同。</target>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="translated">默认情况下，断点处于活动状态，具有触发器动作 &lt;code&gt;enable&lt;/code&gt; ，并且没有关联条件。有关断点的详细信息，请参见《用户指南》。</target>
        </trans-unit>
        <trans-unit id="e107c7882dfb4fe6b976132714721e9f7743401c" translate="yes" xml:space="preserve">
          <source>By default, a filter with the content: &lt;code&gt;#{family =&amp;gt; default, flags =&amp;gt; any}&lt;/code&gt; is used. This will return all interfaces with adresses in the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet6&lt;/code&gt; families.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="translated">默认情况下，名称在模式中必须唯一，但是可以通过在编译时设置选项 &lt;code&gt;dupnames&lt;/code&gt; 来放宽此约束。（重复编号的名称也始终允许具有相同编号的子模式使用，如上一节中所述进行设置。）重复名称对于只有一个命名括号实例可以匹配的模式很有用。假设您要匹配工作日的名称（以3个字母的缩写形式或全名形式），并且在两种情况下都希望提取该缩写形式。以下模式（忽略换行符）可以完成此工作：</target>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="translated">默认情况下,在不跟在{后面的\x之后,会读取0到2个十六进制数字(字母可以是大写或小写)。在\x{和}之间可以出现任意数量的十六进制数字。如果在 \x{和}之间出现了非十六进制数字的字符,或者没有终止 },则会出现错误。</target>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="translated">默认情况下，OTP中的所有I / O设备都设置为 &lt;code&gt;list&lt;/code&gt; 模式。但是，I / O功能可以处理这些模式中的任何一种，并且其他表现为I / O服务器客户端的，用户编写的模块也应如此。</target>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认情况下，所有NETCONF通信都记录在一个日志文件中。但是，不同的连接可以记录在单独的文件中。为此，请使用挂钩选项 &lt;code&gt;hosts&lt;/code&gt; 并列出套件中要使用的服务器/连接的名称。必须命名连接才能正常工作，也就是说，必须使用 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 打开它们。</target>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">默认情况下，所有应用程序在所有节点上的权限均为 &lt;code&gt;true&lt;/code&gt; 。可以使用内核配置参数 &lt;code&gt;permissions&lt;/code&gt; 来配置该权限。</target>
        </trans-unit>
        <trans-unit id="5f0f346db1a0fb06831da54e7c60fe03cdae297d" translate="yes" xml:space="preserve">
          <source>By default, all code is compiled in a separate process which is terminated at the end of compilation. However, some tools, like Dialyzer or compilers for other BEAM languages, may already manage their own worker processes and spawning an extra process may slow the compilation down. In such scenarios, you can pass this option to stop the compiler from spawning an additional process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="translated">默认情况下,所有与 tar 文件中的文件同名的现有文件都会被覆盖。使用这个选项,现有文件不会被覆盖。</target>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="translated">默认情况下，所有文件均从tar文件中提取。使用此选项，仅提取名称包含在 &lt;code&gt;FileList&lt;/code&gt; 中的那些文件。</target>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="translated">默认情况下，所有文件都是从zip存档中提取的。使用选项 &lt;code&gt;{file_list, FileList}&lt;/code&gt; ，函数 &lt;code&gt;unzip/2&lt;/code&gt; 仅提取名称包含在 &lt;code&gt;FileList&lt;/code&gt; 中的文件。必须指定完整路径，包括zip归档文件中所有子目录的名称。</target>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="translated">默认情况下，与zip存档中的文件具有相同名称的所有文件都将被覆盖。设置了选项 &lt;code&gt;keep_old_files&lt;/code&gt; 后，函数 &lt;code&gt;unzip/2&lt;/code&gt; 不会覆盖现有文件。请注意，即使指定了选项 &lt;code&gt;memory&lt;/code&gt; ，这也就意味着不会覆盖任何文件，现有文件也会从结果中排除。</target>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="translated">默认情况下,除了以前所谓的 &quot;SASL报告 &quot;之外,所有源自OTP内部的日志事件看起来都和以前一样。</target>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="translated">默认情况下,字符串的所有部分,包括空字符串,都会从函数中返回,例如。</target>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="translated">默认情况下， &lt;code&gt;OCTET STRING&lt;/code&gt; 始终表示为Erlang二进制文件。如果使用选项 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 编译了规范，则encoding函数将接受列表和二进制文件，而解码函数会将 &lt;code&gt;OCTET STRING&lt;/code&gt; 解码为列表。</target>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="translated">默认情况下，自动启动信息存储在每个节点上名为 &lt;code&gt;ttb_autostart.bin&lt;/code&gt; 的文件中。如果不需要（例如，在无盘节点上），则可以通过为应用程序 &lt;code&gt;ttb_autostart_module&lt;/code&gt; 指定环境变量ttb_autostart_module来提供处理自动启动信息存储和检索的自定义模块。该模块必须响应以下API：</target>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="translated">默认情况下，值大于255的字符与任何Posix字符类都不匹配。但是，如果将选项 &lt;code&gt;PCRE_UCP&lt;/code&gt; 传递给 &lt;code&gt;pcre_compile()&lt;/code&gt; ，则将更改某些类，以便使用Unicode字符属性。这是通过将其他某些Posix类替换为其他序列来实现的，如下所示：</target>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">默认情况下，所有Telnet连接的数据都记录在一个公共文件（名为 &lt;code&gt;default&lt;/code&gt; ）中，例如，如果多个Telnet会话并行运行，该文件可能会变得混乱。因此，可以为每个连接创建一个单独的日志文件。要进行配置，请使用挂钩选项 &lt;code&gt;hosts&lt;/code&gt; 并列出套件中要使用的服务器/连接的名称。必须命名连接才能使其正常工作（请参阅 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="translated">默认情况下，每个安装的CTH均按安装顺序执行，以进行初始化调用，然后以相反的顺序执行以结束调用。并非总是如此，因此 &lt;code&gt;Common Test&lt;/code&gt; 允许用户为每个挂钩指定优先级。可以在CTH函数 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 中指定优先级，也可以在安装挂钩时指定优先级。安装时指定的优先级会覆盖CTH返回的优先级。</target>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="translated">默认情况下，每次安装CTH都会激活它的新实例。如果您想覆盖测试规范中的CTH，同时仍将其包含在套件信息功能中，则可能会导致问题。该 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; 回调的存在是为了解决这个问题。通过在两个地方都返回相同的 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 知道此CTH已经安装，因此不会尝试再次安装。</target>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">默认情况下，错误和警告会打印到tty，并且该函数返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。如果指定了 &lt;code&gt;silent&lt;/code&gt; 选项，则该函数将返回 &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt; （其中 &lt;code&gt;Relup&lt;/code&gt; 是发行升级文件），或者返回 &lt;code&gt;{error,Module,Error}&lt;/code&gt; 。可以通过调用 &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; 或 &lt;code&gt;Module:format_error(Error)&lt;/code&gt; 将警告和错误转换为字符串。</target>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">默认情况下，错误和警告会打印到tty，并且该函数返回 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。如果指定了 &lt;code&gt;silent&lt;/code&gt; 选项，该函数将返回 &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; 或 &lt;code&gt;{error,Module,Error}&lt;/code&gt; 。可以通过调用 &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; 或 &lt;code&gt;Module:format_error(Error)&lt;/code&gt; 将警告和错误转换为字符串。</target>
        </trans-unit>
        <trans-unit id="4b92da4aa5277f398cb7d427508ed2a69567e18a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">默认情况下，功能 &lt;code&gt;open/2&lt;/code&gt; 功能以 &lt;code&gt;raw&lt;/code&gt; 模式打开tar文件，该模式速度更快，但不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认值，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的tar文件。</target>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">默认情况下，功能 &lt;code&gt;open/2&lt;/code&gt; 在 &lt;code&gt;raw&lt;/code&gt; 模式下打开tar文件，该模式速度更快，但不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认值，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的tar文件。</target>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="translated">默认情况下，如果 &lt;code&gt;Beam&lt;/code&gt; 中缺少任何请求的块，则会返回一个 &lt;code&gt;error&lt;/code&gt; 元组。但是，如果指定了选项 &lt;code&gt;allow_missing_chunks&lt;/code&gt; ，则即使缺少块也将返回结果。在结果列表中，所有丢失的块都表示为 &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt; 。但是请注意，如果缺少块 &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; ，则将其视为致命错误，并且返回值是 &lt;code&gt;error&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="translated">默认情况下，在 &lt;code&gt;unicode&lt;/code&gt; 模式下，值大于255的字符（即ISO Latin-1字符集以外的所有字符）从不匹配\ d，\ s或\ w，并且始终匹配\ D，\ S和\ W.这些序列保留了支持UTF之前的原始含义，主要是出于效率方面的考虑。但是，如果设置了 &lt;code&gt;ucp&lt;/code&gt; 选项，则会更改行为，以便使用Unicode属性确定字符类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="translated">默认情况下，符号链接存储为tar文件中的符号链接。要覆盖默认值并将符号链接指向的文件存储到tar文件中，请使用选项 &lt;code&gt;dereference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="translated">默认情况下,该锁是在驱动程序级别的,也就是说,如果对同一个驱动程序开放了几个端口,那么在同一时间只能运行一个端口的代码。</target>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认情况下，仅保证 &lt;code&gt;Erl_Interface&lt;/code&gt; 库与该库本身相同发行版中的其他Erlang / OTP组件兼容。有关如何与早期版本中的Erlang / OTP组件进行通信的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">默认情况下， &lt;code&gt;Erl_Interface&lt;/code&gt; 库只能保证与来自同一版本的其他二郎山/ OTP组件兼容 &lt;code&gt;Erl_Interface&lt;/code&gt; 库本身。例如， &lt;code&gt;Erl_Interface&lt;/code&gt; 来自Erlang / OTP R10的Erl_Interface与来自Erlang / OTP R9的Erlang仿真器不兼容。</target>
        </trans-unit>
        <trans-unit id="f1410ec7350e5013f18865c794a36ebbd177c8c8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt; ei_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">默认情况下， &lt;code&gt;ei&lt;/code&gt; 库只能保证与来自同一版本的其他二郎山/ OTP组件兼容 &lt;code&gt;ei&lt;/code&gt; 库本身。例如，默认情况下，来自Erlang / OTP R10的 &lt;code&gt;ei&lt;/code&gt; 与来自Erlang / OTP R9的Erlang仿真器不兼容。</target>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="translated">默认情况下，&lt;strong&gt;默认用户&lt;/strong&gt;设置为 &lt;code&gt;snmpm_user_default&lt;/code&gt; 模块，该模块仅向info_logger发送信息消息。但是，强烈建议将该模块替换为一个有用的模块（有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="translated">默认情况下，测试完成后，封面工具会自动停止。这将导致原始（未覆盖编译的）模块被加载回测试节点。如果此时某个进程仍在运行被掩护编译的任何模块的旧代码，这意味着在掩护编译后它尚未执行任何完全限定的函数调用，则该进程将被终止。为了避免这种情况，请将option &lt;code&gt;cover_stop&lt;/code&gt; 的值设置为 &lt;code&gt;false&lt;/code&gt; 。这意味着模块始终处于编译状态。因此，仅在测试完成后终止被测Erlang节点或可以手动停止封面的情况下才建议这样做。</target>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="translated">默认情况下，内核应用程序在系统启动时安装一个日志处理程序。该处理程序名为 &lt;code&gt;default&lt;/code&gt; 。它接收并处理由Erlang运行时系统产生的标准日志事件，标准行为和不同的Erlang / OTP应用程序。默认情况下，日志事件会打印到终端。</target>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="translated">默认情况下，内核应用程序在系统启动时安装一个日志处理程序。该处理程序名为 &lt;code&gt;default&lt;/code&gt; 。它接收并处理由Erlang运行时系统产生的标准日志事件，标准行为和不同的Erlang / OTP应用程序。默认情况下，日志事件被写入终端。</target>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，对备份介质的实际访问是通过模块 &lt;code&gt;mnesia_backup&lt;/code&gt; 对读取和写入执行的。当前， &lt;code&gt;mnesia_backup&lt;/code&gt; 是通过标准库模块 &lt;code&gt;disc_log&lt;/code&gt; 实现的。但是，您可以使用与 &lt;code&gt;mnesia_backup&lt;/code&gt; 相同的接口编写自己的模块，并配置 &lt;code&gt;Mnesia&lt;/code&gt; ,以便备用模块执行对备份介质的实际访问。因此，用户可以将备份放在 &lt;code&gt;Mnesia&lt;/code&gt; 不知道的媒体上，可能放在Erlang未运行的主机上。 &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; 请使用配置参数-mnesia backup_module &amp;lt;module&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认情况下，除了默认上下文 &lt;code&gt;&quot;&quot;&lt;/code&gt; 之外，代理不了解任何其他上下文。如果要支持更多上下文，则必须使用适当的配置文件 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt; 明确添加这些上下文。</target>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">默认情况下，启动脚本和启动文件与 &lt;code&gt;Name.rel&lt;/code&gt; 位于同一目录中。也就是说，在当前工作目录中，除非 &lt;code&gt;Name&lt;/code&gt; 包含路径。如果指定了选项 &lt;code&gt;{outdir,Dir}&lt;/code&gt; ，则它们位于 &lt;code&gt;Dir&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="12131639ccba633c1e0c7ee60e1e122164ffcb95" translate="yes" xml:space="preserve">
          <source>By default, the compile server is not used. It can be enabled by giving &lt;code&gt;erlc&lt;/code&gt; the option &lt;code&gt;-server&lt;/code&gt; or by setting the environment variable &lt;code&gt;ERLC_USE_SERVER&lt;/code&gt; to &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="translated">默认情况下，为操作 &lt;code&gt;Record#record_tag.field&lt;/code&gt; 生成的代码将验证元组 &lt;code&gt;Record&lt;/code&gt; 具有该记录的正确大小，并且第一个元素是标记 &lt;code&gt;record_tag&lt;/code&gt; 。使用此选项可以省略验证码。</target>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="translated">默认情况下，最大原子数为1,048,576。可以使用 &lt;code&gt;+t&lt;/code&gt; 选项提高或降低此限制。</target>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="translated">默认情况下,生成的解析器不会将错误信息打印到屏幕上,用户必须通过打印返回的错误信息,或者在与语法文件相关的Erlang代码中插入测试和打印指令来实现。用户必须通过打印返回的错误信息,或者在与语法文件的语法规则相关联的Erlang代码中插入测试和打印指令来实现。</target>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="translated">默认情况下,量化符是 &quot;贪婪的&quot;,也就是说,它们尽可能多地匹配(最大允许次数),而不会导致剩余模式失败。这带来问题的典型例子是在尝试匹配C程序中的注释。这些注释出现在**和*/之间。在注释中,可以出现单独的*和/字符。试图通过应用模式来匹配C语言的注释</target>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="translated">默认情况下，该发行包包含每个包含的应用程序的目录 &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; 和 &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; 。如果要包含更多目录，则指定选项 &lt;code&gt;dirs&lt;/code&gt; ，例如 &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">默认情况下，发行包文件与 &lt;code&gt;Name.rel&lt;/code&gt; 位于同一目录中。也就是说，在当前工作目录中，除非 &lt;code&gt;Name&lt;/code&gt; 包含路径。如果指定了选项 &lt;code&gt;{outdir,Dir}&lt;/code&gt; ，则它位于 &lt;code&gt;Dir&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="translated">默认情况下,脚本将被解释。你可以通过在脚本文件中加入以下一行来强迫它被编译。</target>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">默认情况下，tar文件以 &lt;code&gt;raw&lt;/code&gt; 模式打开，这是较快的操作，但是不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认值，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的tar文件。</target>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">默认情况下，该值与以前一样，即 &lt;code&gt;minimal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76563b7abdc9fe4d5e61b108b45efa4f79168faa" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853ca12d28a4ac6514c7cb70a17bec30cd8f3e6f" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">默认情况下，此函数在指定命令的末尾添加新行。如果不需要这样做，请使用选项 &lt;code&gt;{newline,false}&lt;/code&gt; 。例如，当发送带有字符解释为命令（IAC）前缀的Telnet命令序列时，这是必需的。</target>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">默认情况下，此函数在指定命令的末尾添加换行符。如果不希望这样，可以使用选项 &lt;code&gt;{newline,false}&lt;/code&gt; 。例如，当发送带有字符解释为命令（IAC）前缀的Telnet命令序列时，这是必需的。</target>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">默认情况下，此功能以 &lt;code&gt;raw&lt;/code&gt; 模式打开zip文件，该模式速度更快，但不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认设置，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的zip文件。</target>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="translated">默认情况下，此功能以 &lt;code&gt;raw&lt;/code&gt; 模式打开zip文件，该模式速度更快，但不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认值，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的zip文件。提取的文件也是如此。</target>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="translated">默认情况下，此功能以 &lt;code&gt;raw&lt;/code&gt; 模式打开zip文件，该模式速度更快，但不允许使用远程（Erlang）文件服务器。将 &lt;code&gt;cooked&lt;/code&gt; 添加到模式列表将覆盖默认值，并打开不带 &lt;code&gt;raw&lt;/code&gt; 选项的zip文件。添加的文件也是如此。</target>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="translated">默认情况下,该选项未被设置。这意味着数量不受限制。</target>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">默认情况下，此规则写入 &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; 。但是，如果设置了 &lt;code&gt;binary&lt;/code&gt; 选项，则不会写入任何内容，并且该规则将在 &lt;code&gt;Binary&lt;/code&gt; 中返回。</target>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="translated">默认情况下，将&lt;strong&gt;不&lt;/strong&gt;使用。</target>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="translated">默认情况下,除了以下划线开头的变量之外,未使用的变量都会发出警告(&quot;Prolog风格警告&quot;)。使用这个选项可以关闭这种警告。</target>
        </trans-unit>
        <trans-unit id="25048d6dfb90d946e1d4080a2f5aec1215e6a89c" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted when inlining is enabled in a module that may load NIFs, as the compiler may inline NIF fallbacks by accident. Use this option to turn off this kind of warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="translated">默认情况下，当 &lt;code&gt;[]&lt;/code&gt; 作为 &lt;code&gt;ModifierList&lt;/code&gt; 传递时，可以返回负整数和正整数。这使用尽可能不需要堆内存分配的整数范围。默认情况下，返回的整数也只能保证是唯一的，也就是说，任何返回的整数都可以小于或大于先前返回的整数。</target>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="translated">根据定义，不可能发送在通知中 &lt;code&gt;not-accessible&lt;/code&gt; 具有ACCESS的对象。但是，从历史上看，通常会这样做，因此，我们在通知发送中允许这样做。如果变量具有 &lt;code&gt;not-accessible&lt;/code&gt; ACCESS ，则用户必须在 &lt;code&gt;Varbinds&lt;/code&gt; 列表中提供该变量的值。代理程序无法执行get操作来检索此值。</target>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="translated">通过刻意复制单个二进制数据以避免引用更大的二进制数据,可以在以后的垃圾收集中释放更大的二进制数据,而不是创造出比需要的多得多的二进制数据。共享二进制数据通常是好的。只有在特殊情况下,当小部分引用大的二进制数据,而大的二进制数据在任何过程中都不再使用时,刻意复制才是一个好主意。</target>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="translated">通过执行这些命令，两个Erlang节点被配置为运行 &lt;code&gt;Company&lt;/code&gt; 数据库，并因此初始化数据库。设置时仅需要一次。下次启动系统时，将在两个节点上调用 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; ，以从磁盘初始化系统。</target>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="translated">到目前为止,最常见的情况是,当你得到UTF-8而不是正确的Unicode字符串列表,然后在二进制文件或文件中把它们转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">通过专注于使代码通过测试，程序员可以提高工作效率，不会过分规范或迷失于过早的优化中，并从一开始就创建正确的代码（所谓的&lt;strong&gt;测试驱动开发&lt;/strong&gt;；请参见 &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">通过提供格式处理程序 &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; ，您可以在ET应用程序中使用 &lt;code&gt;et_viewer&lt;/code&gt; 以图形方式 &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt; （请参阅使用Event Tracer呈现跟踪日志一节）。</target>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="translated">通过提供格式处理程序 &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; ，可以在ET应用程序中使用 &lt;code&gt;et_viewer&lt;/code&gt; 以图形方式显示跟踪日志。 &lt;code&gt;ttb&lt;/code&gt; 提供了可以从菜单中选择的过滤器&lt;strong&gt;过滤&lt;/strong&gt;在 &lt;code&gt;et_viewer&lt;/code&gt; 窗口。过滤器的名称取决于它们所呈现的参与者的类型（即，序列图中每个垂直线代表的角色）。演员之间的互动显示为两条垂直线之间的红色箭头，而演员内部的活动则显示为演员线条右侧的蓝色文本。</target>
        </trans-unit>
        <trans-unit id="67f7db44464541266f3f0704ea1cb52a5cffad39" translate="yes" xml:space="preserve">
          <source>By going different directions when inserting and fetching, we avoid contention between threads inserting and threads fetching as much as possible. By skipping one element when we begin searching, we preserve the sentinel unmodified as much as possible. This is beneficial since all search operations need to read the content of the sentinel. If we were to modify the sentinel, the cache line containing the sentinel would unnecessarily be bounced between processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8645150b63184ee0f8a1f1a7796ff9caeac2c2be" translate="yes" xml:space="preserve">
          <source>By increasing the size of identifiers, at least on 64-bit machines (which isn't as easy as it first might seem) we get further room for improvement. Besides the obvious improvement of not reusing identifiers as fast as we currently do, it makes it possible to further avoid contention when inserting elements in the table. At least if we drop this ordering property, which isn't that useful anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="translated">通过检查头文件或编写小型C程序，可以发现 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 为6， &lt;code&gt;TCP_INFO&lt;/code&gt; 为11，结构大小为92（字节）， &lt;code&gt;tcpi_sacked&lt;/code&gt; 的偏移量为28字节，并且值为32位整数。以下代码可用于检索值：</target>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="translated">通过检查实现，您可能会注意到某些特定信号比上述信号提供了更严格的保证。至关重要的是，Erlang代码&lt;strong&gt;不&lt;/strong&gt;使用有关实现的知识，因为实现可以随时更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="0d5d59f9d063b86f9130d5f5210753452085dc85" translate="yes" xml:space="preserve">
          <source>By introduction of this new busy state we still can provide the flow control. Old driver do not even have to be changed. The limits can, however, be configured and even disabled by the port. By default the high limit is 8 KB and the low limit is 4 KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a61522ba19814181bc4db8e5c44cbf812700d2" translate="yes" xml:space="preserve">
          <source>By keeping this part when reverting back to a locked implementation, we could remove a pointer field in each process structure, and avoid unnecessary operations on the process and the queue which might cause contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="translated">通过查看分析结果，可以 &lt;code&gt;test.erl&lt;/code&gt; 当分配所有通道并应相应扩展test.erl时，测试用例并不涵盖这种情况。</target>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="translated">通过解析一个XML文档,你会得到一个记录,显示文档的结构,作为返回值。xmerl在以下情况下使用非常方便。</target>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="translated">通过将指针传递到包含值 &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt; 的整数变量，可以读取当前使用的限制并将其写回到该整数变量。可以通过将指针传递到包含有效限制的整数变量来设置新限制。传递的值将写入内部限制。然后调整内部极限。此后，将调整后的极限写回到读取新值的整数变量中。值以字节为单位。</target>
        </trans-unit>
        <trans-unit id="5fab0b335aad4687a0efd2b2918fb0d4d20a2d30" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-1&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">通过将相同的&amp;ldquo; fun&amp;rdquo;作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; ，它在与函数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; 几乎相同的上下文中执行。不同之处在于操作是同步执行的。调用方等待在所有活动副本上执行更新。在以下情况下，使用 &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; 很有用：</target>
        </trans-unit>
        <trans-unit id="07cd49a0634099807d33616dd0caa93e4fb6d9a9" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">通过将相同的&amp;ldquo; fun&amp;rdquo;作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; ，可以在脏上下文中执行该操作。函数调用映射到相应的脏函数。这仍然涉及日志记录，复制和订阅，但不涉及锁定，本地事务存储或提交协议。检查点保持器已更新，但已更新为&amp;ldquo;脏&amp;rdquo;。因此，它们被异步更新。这些功能等待在一个节点上执行该操作，而不在其他节点上执行。如果表位于本地，则不会等待。</target>
        </trans-unit>
        <trans-unit id="e0b3ed9cf7bda275ce89d365e3ae0df2fa60e975" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-1&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">通过将相同的&amp;ldquo; fun&amp;rdquo;作为参数传递给函数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; ，可以在同步事务上下文中执行该操作。从 &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; 调用返回之前，同步的事务要等到所有活动副本将事务提交到磁盘为止。在以下情况下，使用 &lt;code&gt;sync_transaction&lt;/code&gt; 很有用：</target>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="translated">这些函数可以优先包含在 &lt;code&gt;shell_default&lt;/code&gt; 模块中。默认情况下，它们包含在该模块中。</target>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="translated">通过将 &lt;code&gt;SourceMod&lt;/code&gt; 和 &lt;code&gt;TargetMod&lt;/code&gt; 设置为不同的模块，可以将备份从一种备份媒体复制到另一种。</target>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">通过以自下而上的方式进行测试，从最小的程序单元开始，并确信它们可以正常工作，这样可以更容易地测试由多个此类单元组成的更高级别的组件是否也符合规范（称为&lt;strong&gt;集成测试&lt;/strong&gt;；请参见 &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="translated">通过这种方式,可以使选项在模式的不同部分有不同的设置。在一个选项中所做的任何改变都会延续到同一子模式中的后续分支。例如:在一个选项中所做的任何改变都会延续到同一子模式中的后续分支中。</target>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt; ，您可以指定是在本地还是全局模式下启动Debugger：</target>
        </trans-unit>
        <trans-unit id="99adfb49899ce85d907d066e2103689e06c7ae25" translate="yes" xml:space="preserve">
          <source>By using one data structure of free blocks in each carrier and an allocator instance-wide data structure of carriers managed by the allocator instance, the work needed in order to remove and add carriers can be kept to a minimum. When migration of carriers is enabled on a specific allocator type, we require that an allocation strategy with such an implementation is used. Currently we've implemented this for three different allocation strategies. All of these strategies use a search tree of carriers sorted so that we can find the carrier with the lowest address that can satisfy the request. Internally in carriers we use yet another search tree that either implement address order first fit, address order best fit, or best fit. The abbreviations used for these different allocation strategies are &lt;code&gt;aoff&lt;/code&gt;, and &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="translated">通过在启动跟踪器时使用选项 &lt;code&gt;handler&lt;/code&gt; ，有关如何格式化文件的信息存储在跟踪信息文件（ &lt;code&gt;.ti&lt;/code&gt; ）中。这不是必需的，因为可以在格式化时指定它。但是，如果，例如，要格式化跟踪日志自动使用选项，可以是有用的 &lt;code&gt;format&lt;/code&gt; 在 &lt;code&gt;ttb:stop/1&lt;/code&gt; 。此外，您不需要二进制日志内容的任何知识即可按照预期的方式对其进行格式化。如果在启动跟踪程序和格式化时都指定了选项 &lt;code&gt;handler&lt;/code&gt; ，那么将使用格式化时指定的选项处理程序。</target>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="translated">通过使用 &lt;code&gt;sed&lt;/code&gt; 和 &lt;code&gt;grep&lt;/code&gt; 这样的普通UNIX工具，您可以轻松找到各种问题的答案，例如：</target>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="translated">通过使用新的API，您可以自动获得可伸缩性和性能改进。这也使您能够使用 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; ，以提高时间测量的准确性和精确度。</target>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="translated">当新API不可用时，通过使用回退到 &lt;code&gt;erlang:now/0&lt;/code&gt; 的函数包装API ，并使用这些包装而不是直接使用API​​，可以解决此问题。这些包装程序可以例如在 &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="translated">绕过所有消息到接收过程。</target>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="translated">绕过Dialyzer在透析许多文件时启发式执行的一些关键文件的本地代码编译。这避免了编译时间,但会导致(更长的)分析时间。</target>
        </trans-unit>
        <trans-unit id="ed612f8fe61f0988ef76386aa7006b8a480853b5" translate="yes" xml:space="preserve">
          <source>Byte Order Marks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="translated">超出0x2A、0x2D、0x2E、0x30至0x39、0x41至0x5A、0x5F、0x61至0x7A范围的字节,均采用百分比编码(U+0025 PERCENT SIGN字符(%),后面跟着代表字节十六进制值的大写ASCII十六进制数字)。</target>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="translated">以任何方式写入文件的字节在存储到磁盘文件之前都会被翻译成UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b723b73b1800e21096c057fb6a01f5938c1a20f5" translate="yes" xml:space="preserve">
          <source>C Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf32b3ba375bfb965d1f8f4ebf787e42c9dc1ea" translate="yes" xml:space="preserve">
          <source>C Nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="translated">如果C节点希望系统中的其他节点能够找到并连接到它们，则也可以向 &lt;code&gt;epmd&lt;/code&gt; 注册自己。</target>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="8bcd80750450915a11400a818b9b66c894b79ce2" translate="yes" xml:space="preserve">
          <source>C. J. Cheney. A nonrecursive list compacting algorithm. Commun. ACM, 13(11):677&amp;ndash;678, Nov. 1970.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="translated">CEA是按直径发送和接收的。</target>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="translated">CER是按直径发送和接收的。</target>
        </trans-unit>
        <trans-unit id="dc47309cd47139b3a06fa2c74bdb7d228d8051f1" translate="yes" xml:space="preserve">
          <source>CGI Version 1.1, RFC 3875</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="translated">CHARACTER (size),CHAR (size)</target>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="translated">CHARACTER变量(大小),CHAR变量(大小)</target>
        </trans-unit>
        <trans-unit id="c58d76589eba57b4dea4b621e7f3e9e5e0856e8f" translate="yes" xml:space="preserve">
          <source>CMAC</source>
          <target state="translated">CMAC</target>
        </trans-unit>
        <trans-unit id="af34028d9d3b30dd0a7cd2e8ede32a3c41ceeef2" translate="yes" xml:space="preserve">
          <source>CMAC with the following ciphers are available with OpenSSL 1.0.1 or later if not disabled by configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4f0e1b5b9cde6b772cb89e0e6bdb0a6ab6de56" translate="yes" xml:space="preserve">
          <source>CR, LF, or CRLF only</source>
          <target state="translated">仅CR、LF或CRLF</target>
        </trans-unit>
        <trans-unit id="d5ab3cb5603f8a4df9b9b5741bc8bf57061a02e7" translate="yes" xml:space="preserve">
          <source>CRL cache</source>
          <target state="translated">CRL缓存</target>
        </trans-unit>
        <trans-unit id="8e2fa37cd7a6f667709e92e12f402a4fd5543726" translate="yes" xml:space="preserve">
          <source>CRL validation is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022add99e35c24f3ac862da0a40f1d2f32554546" translate="yes" xml:space="preserve">
          <source>CRLstatus</source>
          <target state="translated">CRLstatus</target>
        </trans-unit>
        <trans-unit id="3d8d83bcad675694b718b08da5328dd4f850b82a" translate="yes" xml:space="preserve">
          <source>CTH Execution Order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be6f7027968e8a0c958298b44e28e9e66535873" translate="yes" xml:space="preserve">
          <source>CTH Processes and Tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff86d60418e1cef1253cf01c43b18051224fcb54" translate="yes" xml:space="preserve">
          <source>CTHs are run with the same process scoping as normal test suites, that is, a different process executes the &lt;code&gt;init_per_suite&lt;/code&gt; hooks then the &lt;code&gt;init_per_group&lt;/code&gt; or &lt;code&gt;per_testcase&lt;/code&gt; hooks. So if you want to spawn a process in the CTH, you cannot link with the CTH process, as it exits after the post hook ends. Also, if you for some reason need an ETS table with your CTH, you must spawn a process that handles it.</source>
          <target state="translated">CTH的运行范围与普通测试套件相同，即，与 &lt;code&gt;init_per_group&lt;/code&gt; 或 &lt;code&gt;per_testcase&lt;/code&gt; 挂钩不同的是，执行 &lt;code&gt;init_per_suite&lt;/code&gt; 挂钩的进程不同。因此，如果要在CTH中生成进程，则不能与CTH进程链接，因为该进程会在post hook结束后退出。另外，如果由于某种原因需要CTH的ETS表，则必须产生一个处理它的进程。</target>
        </trans-unit>
        <trans-unit id="7e6e1792db904ba826af372ccec45b6e25fb5024" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">也可以在测试套件中添加CTH。这是通过从 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 的配置列表中返回 &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="fd9865647296ea1525fdd1865f581111a13d82e1" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt; init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt; init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcaf761552337b6a6de3a9db00451f69633f4b" translate="yes" xml:space="preserve">
          <source>CTHs can be used to synchronize test runs with external user applications. The init function can, for example, start and/or communicate with an application that has the purpose of preparing the SUT for an upcoming test run, or initialize a database for saving test data to during the test run. The terminate function can similarly order such an application to reset the SUT after the test run, and/or tell the application to finish active sessions and terminate. Any system error- or progress reports generated during the init- or termination stage are saved in the &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt;. (This is also true for any printouts made with &lt;code&gt;ct:log/2&lt;/code&gt; and &lt;code&gt;ct:pal/2&lt;/code&gt;).</source>
          <target state="translated">CTH可用于将测试运行与外部用户应用程序同步。初始化功能可以，例如，启动和/或与应用程序通信，该应用程序的目的是为即将进行的测试运行准备SUT，或者初始化数据库以在测试运行期间将测试数据保存到其中。终止功能可以类似地命令此类应用程序在测试运行后重置SUT，和/或告诉应用程序完成活动会话并终止。在初始化或终止阶段生成的任何系统错误或进度报告都将保存在 &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt; 。 （对于使用 &lt;code&gt;ct:log/2&lt;/code&gt; 和 &lt;code&gt;ct:pal/2&lt;/code&gt; 进行的任何打印输出也是如此）。</target>
        </trans-unit>
        <trans-unit id="1413152f77878171b8b1aa5bd33bfea4b91b1e35" translate="yes" xml:space="preserve">
          <source>CTHs cannot be added here right now. That feature may be added in a later release, but it would right now break backwards compatibility.</source>
          <target state="translated">现在这里不能添加CTH。该功能可能会在以后的版本中加入,但现在会破坏向后的兼容性。</target>
        </trans-unit>
        <trans-unit id="27930480546a406089acbe7e97d210e59cf3f0a5" translate="yes" xml:space="preserve">
          <source>Caches a new session or updates an already cached one. Is only called from the cache handling process.</source>
          <target state="translated">缓存一个新的会话或更新一个已经缓存的会话。只在缓存处理过程中被调用。</target>
        </trans-unit>
        <trans-unit id="a61c27140fecb8e4a22ce80c81760b45147855bd" translate="yes" xml:space="preserve">
          <source>Calculate scheduler utilizations for the time interval from when &lt;code&gt;Sample&lt;/code&gt; was taken and &quot;now&quot;. The same as calling &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt;.</source>
          <target state="translated">计算从 &lt;code&gt;Sample&lt;/code&gt; 开始到&amp;ldquo;现在&amp;rdquo; 的时间间隔内的调度程序利用率。与调用 &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3159ceb44a5156030b65aa273f276c3747dcacc9" translate="yes" xml:space="preserve">
          <source>Calculates a key for later use in &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt;. The keys are evenly distributed so that a fair mapping between port IDs and async thread IDs is achieved.</source>
          <target state="translated">计算密钥，以供以后在 &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; 中使用。密钥均匀分布，以便在端口ID和异步线程ID之间实现公平的映射。</target>
        </trans-unit>
        <trans-unit id="97a16654177af632fa24a3c60a60a85917da19f0" translate="yes" xml:space="preserve">
          <source>Calculates a ssh fingerprint from a public host key as openssh does.</source>
          <target state="translated">像openssh一样,从公共主机密钥计算ssh指纹。</target>
        </trans-unit>
        <trans-unit id="96b67c5752326af1f998bcfc9d0641aa609cb938" translate="yes" xml:space="preserve">
          <source>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</source>
          <target state="translated">计算模块代码的MD5冗余检查(不包括编译日期和其他属性)。</target>
        </trans-unit>
        <trans-unit id="49556b91adcf0245cb3d710749c75861fa022a4f" translate="yes" xml:space="preserve">
          <source>Calculates and returns the length of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">计算并返回队列 &lt;code&gt;Q&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="2e81ece084c83acdfbcc583fdce8e53ba5b901b1" translate="yes" xml:space="preserve">
          <source>Calculates scheduler utilizations for the time interval between the two samples obtained from calling &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">计算从调用 &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt; 获得的两个样本之间的时间间隔的调度程序利用率。</target>
        </trans-unit>
        <trans-unit id="227b790ced77d840153cd69f4b9d2467f87af6d9" translate="yes" xml:space="preserve">
          <source>Calculates the Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;Data&lt;/code&gt; 的Adler-32校验和。</target>
        </trans-unit>
        <trans-unit id="f486ba07e5a51271bcf5c7397d6baef999b087f1" translate="yes" xml:space="preserve">
          <source>Calculates the CRC checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;Data&lt;/code&gt; 的CRC校验和。</target>
        </trans-unit>
        <trans-unit id="59cabfc35187ea21aad19caf8aed979cfcc7efbb" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt; erlang:timestamp/0&lt;/code&gt; or &lt;code&gt; os:timestamp/0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8a87c52d80ef29c6c7f4e720f1eb69b8f5e769" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt;erlang:timestamp/0&lt;/code&gt; or &lt;code&gt;os:timestamp/0&lt;/code&gt;.</source>
          <target state="translated">计算时间差 &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; 以&lt;strong&gt;微秒为单位）&lt;/strong&gt;，其中 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 是时间戳元组，格式与从 &lt;code&gt;erlang:timestamp/0&lt;/code&gt; 或 &lt;code&gt;os:timestamp/0&lt;/code&gt; 返回的格式相同。</target>
        </trans-unit>
        <trans-unit id="31e631ed71da6b22331e1ba2c1ab40350acc8c94" translate="yes" xml:space="preserve">
          <source>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</source>
          <target state="translated">在不进行编码的情况下,计算以Erlang外部术语格式编码的术语的最大字节大小。以下条件始终适用。</target>
        </trans-unit>
        <trans-unit id="d9a2b0161d342ba687bae1cf3bd6fc16726fc85e" translate="yes" xml:space="preserve">
          <source>Call ::= FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt;MFA&lt;code&gt;,&lt;/code&gt; MFA&lt;code&gt;}&lt;/code&gt; | AtomConst &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt;AtomConst&lt;code&gt;,&lt;/code&gt; AtomConst&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">调用:: = FunSpec- &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt; MFA &lt;code&gt;,&lt;/code&gt; MFA &lt;code&gt;}&lt;/code&gt; | AtomConst- &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt; AtomConst &lt;code&gt;,&lt;/code&gt; AtomConst &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecdbacce8a3993e206cefb1a9385869bf9d9f72a" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; to establish a connection to a server, then pass the returned handle to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; to establish a NETCONF session on a new SSH channel. Each call to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; establishes a new session on the same connection, and results in a hello message to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff341ca2509327aaf0ceb26b489066bc294ca073" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87defee9508517c6c10659d4e0fee5236449ad6" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; ，将要执行的脏NIF的指针传递给该指针，并使用参数 &lt;code&gt;flags&lt;/code&gt; 指示是否期望该操作受CPU约束或受I / O约束。</target>
        </trans-unit>
        <trans-unit id="69bfcf4495124cb65edd6183c66a7288de41dd51" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;analyze&lt;/code&gt; with &lt;code&gt;total&lt;/code&gt; option when profiling has been stopped to display the results per function call, that is in which function calls the time has been spent.</source>
          <target state="translated">呼叫 &lt;code&gt;analyze&lt;/code&gt; 与 &lt;code&gt;total&lt;/code&gt; 选项时，剖析已停止显示每个函数调用，也就是在函数调用的时候已经花了结果。</target>
        </trans-unit>
        <trans-unit id="166bcff3bd03bad3b22be129a767e953b92bb7c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">通话 &lt;code&gt;info&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b32de2da67e0b479c6558da688c298d2c8d61df" translate="yes" xml:space="preserve">
          <source>Call Graph Edges (*).</source>
          <target state="translated">调用图形边缘(*)。</target>
        </trans-unit>
        <trans-unit id="ee61800f5d1b4760400245c96aa2f8c30730dd00" translate="yes" xml:space="preserve">
          <source>Call Graph Vertices (*).</source>
          <target state="translated">调用Graph Vertices(*)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
