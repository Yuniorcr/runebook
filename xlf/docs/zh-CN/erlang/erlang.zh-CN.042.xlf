<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="247d880cbbfe17329068c2a487e83b52be0b8fd0" translate="yes" xml:space="preserve">
          <source>The validity period of the certificate.</source>
          <target state="translated">证书的有效期;</target>
        </trans-unit>
        <trans-unit id="de095b0c0154458957667b823417f32d9c762772" translate="yes" xml:space="preserve">
          <source>The value (in seconds) must be in the range 10 &amp;lt; X &amp;lt;= 65535.</source>
          <target state="translated">值（以秒为单位）必须在10 &amp;lt;X &amp;lt;= 65535的范围内。</target>
        </trans-unit>
        <trans-unit id="c7d9f4f2d7422b47b5c88e4d58854e12adae49bd" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;-1&lt;/code&gt; in any field means &quot;unknown&quot;, and in most cases it means that the dump was truncated somewhere around this field.</source>
          <target state="translated">在任何字段中的值 &lt;code&gt;-1&lt;/code&gt; 表示&amp;ldquo;未知&amp;rdquo;，并且在大多数情况下，它意味着转储在该字段周围的某个地方被截断了。</target>
        </trans-unit>
        <trans-unit id="86c20a3a7328e6bc498fe9dc567872d5f84e6318" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;extended&lt;/code&gt; means that a special 'process' is also created intended to handle &lt;strong&gt;all&lt;/strong&gt; notifications.</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; 的值意味着还将创建一个特殊的&amp;ldquo;过程&amp;rdquo;以处理&lt;strong&gt;所有&lt;/strong&gt;通知。</target>
        </trans-unit>
        <trans-unit id="ebb9639bd59b81ac3f0302e2ea6264dd43e978a9" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;random&lt;/code&gt; will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version.</source>
          <target state="translated">值 &lt;code&gt;random&lt;/code&gt; 将导致在每次连接尝试时创建一个随机字符串。这使得恶意对等方很难找到ssh软件的品牌和版本。</target>
        </trans-unit>
        <trans-unit id="59cae5c48ebf4d4c60edc8af8c6900b2f10cdd93" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; will make a random string with at least &lt;code&gt;Nmin&lt;/code&gt; characters and at most &lt;code&gt;Nmax&lt;/code&gt; characters.</source>
          <target state="translated">值 &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; 将构成一个随机字符串，其中至少包含 &lt;code&gt;Nmin&lt;/code&gt; 个字符，最多包含 &lt;code&gt;Nmax&lt;/code&gt; 个字符。</target>
        </trans-unit>
        <trans-unit id="cc2e81fd931d300e3783349335314abc90033f4a" translate="yes" xml:space="preserve">
          <source>The value associated with key &lt;code&gt;alpha&lt;/code&gt; is fetched for both arguments using the &lt;code&gt;:=&lt;/code&gt; operator. The other keys in the map are ignored, only the key &lt;code&gt;alpha&lt;/code&gt; is required and checked for.</source>
          <target state="translated">使用 &lt;code&gt;:=&lt;/code&gt; 运算符为两个参数都获取与键 &lt;code&gt;alpha&lt;/code&gt; 关联的值。映射中的其他键将被忽略，仅需要键 &lt;code&gt;alpha&lt;/code&gt; 并进行检查。</target>
        </trans-unit>
        <trans-unit id="ae3beea41eb5f49f177e89c9a2690def73d412bd" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt; logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">过滤器使用与此键关联的值来对源自（例如）特定功能区域的日志事件进行分组。有关如何使用此字段的说明，请参见 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt; logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86b0b34c5895cd8049a0c1760924204afc238fc1" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">与此过滤器关联的值被过滤器用来对源自例如特定功能区域的日志事件进行分组。有关如何使用此字段的说明，请参见 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9b31d1fc7f3b413bcae938dfe03589bb5285a5" translate="yes" xml:space="preserve">
          <source>The value defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">该值默认为 &lt;code&gt;infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73cc3165471e18765106ff9988f4618f4de5f7c9" translate="yes" xml:space="preserve">
          <source>The value defined here can be used in several ways. It can, for example, be used as the value in some &lt;code&gt;DEFAULT&lt;/code&gt; component:</source>
          <target state="translated">此处定义的值可以通过多种方式使用。例如，它可以用作某些 &lt;code&gt;DEFAULT&lt;/code&gt; 组件中的值：</target>
        </trans-unit>
        <trans-unit id="00cedad00d133d50963e34c659f0ef80545f6ee4" translate="yes" xml:space="preserve">
          <source>The value denotes a regular expression (see module &lt;code&gt;re&lt;/code&gt;). Tidying will only be applied to those regular files whose names match this pattern. The default value is &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt;, which matches normal Erlang source file names.</source>
          <target state="translated">该值表示一个正则表达式（请参阅模块 &lt;code&gt;re&lt;/code&gt; ）。整理仅适用于名称与此模式匹配的常规文件。默认值为 &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt; ，它与普通的Erlang源文件名匹配。</target>
        </trans-unit>
        <trans-unit id="a7fc7c904bc65fe1f04425c2c4301dd4dfba43f3" translate="yes" xml:space="preserve">
          <source>The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.</source>
          <target state="translated">该值具有RFC 6733的8.8节所要求的形式。Ident应该是包含返回值的消息将从其发送的对等体的Origin-Host。</target>
        </trans-unit>
        <trans-unit id="df5a9468ae2eff2ec8d99706ab1e3ddc685940bb" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt; process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">如果该过程的呼叫保存未处于活动状态，则该值为 &lt;code&gt;false&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt; process_flag/3&lt;/a&gt;&lt;/code&gt; ）。如果激活了通话保存功能，则返回一个列表，其中最后一个元素是最近通话的元素。</target>
        </trans-unit>
        <trans-unit id="565bd9ff9980988d34e45f60f24a9df4493a532c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">如果该过程的呼叫保存未处于活动状态，则该值为 &lt;code&gt;false&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt; ）。如果激活了通话保存功能，则返回一个列表，其中最后一个元素是最近通话的元素。</target>
        </trans-unit>
        <trans-unit id="fca5756bcf0742c5fb8a83c510ae9ce36b623343" translate="yes" xml:space="preserve">
          <source>The value is a &lt;code&gt;boolean()&lt;/code&gt;. The value &lt;code&gt;true&lt;/code&gt; will make the client accept any unknown Host Key without any user interaction. The value &lt;code&gt;false&lt;/code&gt; preserves the default behaviour of asking the user on stdio.</source>
          <target state="translated">该值为 &lt;code&gt;boolean()&lt;/code&gt; 。值 &lt;code&gt;true&lt;/code&gt; 将使客户端无需任何用户交互即可接受任何未知的主机密钥。值 &lt;code&gt;false&lt;/code&gt; 保留在stdio上询问用户的默认行为。</target>
        </trans-unit>
        <trans-unit id="4b03c47ccab46f2579d8f24abc755f87cc416f2a" translate="yes" xml:space="preserve">
          <source>The value is a list of pairs, associating tuples &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; with tuples &lt;code&gt;{NewModule, NewName}&lt;/code&gt;, specifying renamings of calls to remote functions. By default, the value is the empty list.</source>
          <target state="translated">该值是成对的列表，将元组 &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; 与元组 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; ，指定对远程函数的调用重命名。默认情况下，该值为空列表。</target>
        </trans-unit>
        <trans-unit id="1df1db1ba1c8748b25a7c5b626dd8804fd835229" translate="yes" xml:space="preserve">
          <source>The value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; section 9.1.</source>
          <target state="translated">该值由协议级别响应中的sftp错误代码形成，如 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; 部分9.1中所定义。</target>
        </trans-unit>
        <trans-unit id="148473653e344b665aad6d10ff3c1fcf44e7835b" translate="yes" xml:space="preserve">
          <source>The value is set when the handler is added, and it cannot be changed in runtime.</source>
          <target state="translated">该值是在添加处理程序时设置的,在运行时不能更改。</target>
        </trans-unit>
        <trans-unit id="bd41f86d28c143add491ec9132e29dfc8b19621e" translate="yes" xml:space="preserve">
          <source>The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use &lt;code&gt;atom()&lt;/code&gt;s or &lt;code&gt;string()&lt;/code&gt;s to specify the subpatterns to be returned. For example, consider the regular expression:</source>
          <target state="translated">值列表是要返回的子模式的索引列表，其中索引0表示所有模式，而索引1表示正则表达式中的第一个显式捕获子模式，依此类推。在正则表达式中使用命名的捕获子模式（请参见下文）时，可以使用 &lt;code&gt;atom()&lt;/code&gt; 或 &lt;code&gt;string()&lt;/code&gt; 来指定要返回的子模式。例如，考虑正则表达式：</target>
        </trans-unit>
        <trans-unit id="c81f48007ff0ed091ec4764a41dbf0e172a8f0bb" translate="yes" xml:space="preserve">
          <source>The value must be a function with arity 1, returning &lt;code&gt;{Format,Args}&lt;/code&gt;, and it will be called with a report as only argument.</source>
          <target state="translated">该值必须是具有Arity 1的函数，返回 &lt;code&gt;{Format,Args}&lt;/code&gt; ，并且将使用报告作为唯一参数来调用它。</target>
        </trans-unit>
        <trans-unit id="07ff5095c8d8cce91ccc3bf32364fcee41686369" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值与编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值相同；否则，运行时系统将拒绝加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="4212c98e758e516a6abcce4b67d7189dbcf1c3f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值可能不同于编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e234819107a6b5dcfa3fe173976c85b1ea1b28f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值与编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值相同；否则，运行时系统将拒绝加载驱动程序。</target>
        </trans-unit>
        <trans-unit id="116150239ed1360f1b36349687371da72b694bcd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。该值可能不同于编译驱动程序时使用的 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="78be37cd91f4cf995f8b06a4daace135c812602c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="0b2195f8068d2a10ede4ea4cc9fcbf6ff4d98d21" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">编译运行时系统时的 &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="b118746e3fc7bb9edb78696fb5442fd44cb5a3e1" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Misc&lt;/code&gt; varies for different types of processes, for example:</source>
          <target state="translated">&lt;code&gt;Misc&lt;/code&gt; 的值因不同类型的过程而异，例如：</target>
        </trans-unit>
        <trans-unit id="8dae040f4f2546c55f00cef77a0cb74993dea2c6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 的值乘以单位将得出位数。 &lt;code&gt;binary&lt;/code&gt; 类型的段的大小必须被8整除。</target>
        </trans-unit>
        <trans-unit id="bed25a5020d26519961367afdf71569ec20e8253" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8. For a segment of type &lt;code&gt;float&lt;/code&gt; the size must be either 64 or 32.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 的值乘以单位将得出位数。 &lt;code&gt;binary&lt;/code&gt; 类型的段的大小必须被8整除。对于 &lt;code&gt;float&lt;/code&gt; 类型的段，该大小必须为64或32。</target>
        </trans-unit>
        <trans-unit id="780ca2b28783a99a4c631093f06c672e54bdfc8a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; specifies the size of the segment in units (see below). The default value depends on the type (see below):</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 的值指定段的大小（以单位为单位）（请参见下文）。默认值取决于类型（请参见下文）：</target>
        </trans-unit>
        <trans-unit id="b1854e31941d7fbfcb3749a7e6c4457829e3447d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;State&lt;/code&gt; varies for different types of processes, as follows:</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 的价值因不同类型的过程而异，如下所示：</target>
        </trans-unit>
        <trans-unit id="67326e380fdef2e7ca1cffaffc1a499d8945109f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;engine_id&lt;/code&gt; is a string, which should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;engine_id&lt;/code&gt; 的值是一个字符串，应具有非常特定的结构。有关详细信息，请参见RFC 2271/2571。</target>
        </trans-unit>
        <trans-unit id="67a488abfbc3355615ef1fdf9842c10e39f374ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;file&lt;/code&gt; overrides the value of &lt;code&gt;file&lt;/code&gt; as defined in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">值 &lt;code&gt;file&lt;/code&gt; 覆盖的值 &lt;code&gt;file&lt;/code&gt; 中的定义， &lt;code&gt;.app&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="ce398bd65bb25721ffa1a8a7e0185e8682912540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;intAgentTransports&lt;/code&gt; is a list of &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuples, where &lt;code&gt;Domain&lt;/code&gt; is either &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is the address in the domain. &lt;code&gt;Addr&lt;/code&gt; can be specified either as an &lt;code&gt;IpAddr&lt;/code&gt; or as an &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; tuple. &lt;code&gt;IpAddr&lt;/code&gt; is either a regular Erlang/OTP &lt;code&gt;ip_address()&lt;/code&gt; or a traditional SNMP integer list and &lt;code&gt;IpPort&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;intAgentTransports&lt;/code&gt; 的值是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 元组的列表，其中 &lt;code&gt;Domain&lt;/code&gt; 是 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; ，而 &lt;code&gt;Addr&lt;/code&gt; 是域中的地址。可以将 &lt;code&gt;Addr&lt;/code&gt; 指定为 &lt;code&gt;IpAddr&lt;/code&gt; 或 &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; 元组。 &lt;code&gt;IpAddr&lt;/code&gt; 是常规的Erlang / OTP &lt;code&gt;ip_address()&lt;/code&gt; 或传统的SNMP整数列表，而 &lt;code&gt;IpPort&lt;/code&gt; 是整数。</target>
        </trans-unit>
        <trans-unit id="fa552c79540af3ff0c608c82bebe09aa87d449b9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;parent_value&lt;/code&gt; is the value returned by &lt;code&gt;ParentFun&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if there is no &lt;code&gt;ParentFun&lt;/code&gt;. &lt;code&gt;ParentFun&lt;/code&gt; is called once just before the call of &lt;code&gt;PreFun&lt;/code&gt; in the context of the process calling &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">值 &lt;code&gt;parent_value&lt;/code&gt; 是返回的值 &lt;code&gt;ParentFun&lt;/code&gt; ，或者 &lt;code&gt;undefined&lt;/code&gt; 如果没有 &lt;code&gt;ParentFun&lt;/code&gt; 。在调用 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; 的进程的上下文中，仅在 &lt;code&gt;ParentFun&lt;/code&gt; 调用之前调用一次 &lt;code&gt;PreFun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="403588e32c3c599137f65e61edac93c0adc811e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;snmpEngineID&lt;/code&gt; is a string, which for a deployed agent should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;snmpEngineID&lt;/code&gt; 的值是一个字符串，对于已部署的代理，该字符串应具有非常特定的结构。有关详细信息，请参见RFC 2271/2571。</target>
        </trans-unit>
        <trans-unit id="39576763fb2878e58995adcb19edf7b1f8b5b52e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;stop_fun&lt;/code&gt; is a nullary fun that deletes the cursor if called from the parent, or &lt;code&gt;undefined&lt;/code&gt; if there is no cursor.</source>
          <target state="translated">&lt;code&gt;stop_fun&lt;/code&gt; 的值是一个无效游标，如果从父级调用该游标，则删除游标；如果没有游标，则 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbda166cbb0a64342130a713cafa3ff8a579278c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;tc_group_properties&lt;/code&gt; is a list of status tuples, each with the key &lt;code&gt;ok&lt;/code&gt;, &lt;code&gt;skipped&lt;/code&gt;, and &lt;code&gt;failed&lt;/code&gt;. The value of a status tuple is a list with names of test cases that have been executed with the corresponding status as result.</source>
          <target state="translated">&lt;code&gt;tc_group_properties&lt;/code&gt; 的值是状态元组的列表，每个元组具有键 &lt;code&gt;ok&lt;/code&gt; ， &lt;code&gt;skipped&lt;/code&gt; 和 &lt;code&gt;failed&lt;/code&gt; 。状态元组的值是一个列表，其中列出了已用相应状态作为结果执行的测试用例的名称。</target>
        </trans-unit>
        <trans-unit id="c90e20096422723556a7637012d02aa52ba6cd06" translate="yes" xml:space="preserve">
          <source>The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 检索配置参数的值。</target>
        </trans-unit>
        <trans-unit id="0e674f5f0ae9761a28b0e34a6e1578f6940f7307" translate="yes" xml:space="preserve">
          <source>The value of a field in a record can be an instance of a record. Retrieval of nested data can be done stepwise, or in a single step, as shown in the following example:</source>
          <target state="translated">记录中字段的值可以是记录的一个实例。嵌套数据的检索可以逐步进行,也可以一步到位,如下例所示。</target>
        </trans-unit>
        <trans-unit id="090fd2fb5e0fd0eb93688d1bfcea8e341fe24db7" translate="yes" xml:space="preserve">
          <source>The value of option &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; is to be &lt;code&gt;'=:='&lt;/code&gt; if the table considers two keys equal if they match, and to be &lt;code&gt;'=='&lt;/code&gt; if two keys are equal if they compare equal. Defaults to &lt;code&gt;'=:='&lt;/code&gt;.</source>
          <target state="translated">选项的值 &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; 是成为 &lt;code&gt;'=:='&lt;/code&gt; 如果表认为两个密钥相等，如果它们匹配，并为 &lt;code&gt;'=='&lt;/code&gt; 如果两个密钥相等，当它们相等比较。默认为 &lt;code&gt;'=:='&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b5f4463cd58d2c1d9f4f3e85881555f2a7d602d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;Parserfile&lt;/code&gt; option stripped of the &lt;code&gt;.erl&lt;/code&gt; extension is used by Yecc as the module name of the generated parser file.</source>
          <target state="translated">所述的值 &lt;code&gt;Parserfile&lt;/code&gt; 剥去的选项 &lt;code&gt;.erl&lt;/code&gt; 扩展用于通过Yecc作为生成的分析器文件的模块名称。</target>
        </trans-unit>
        <trans-unit id="2c64d7956fe51b588938aacaa6f88fb7a9310598" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;closure&lt;/code&gt; operator (the &lt;code&gt;digraph&lt;/code&gt; representation) is represented by the atom &lt;code&gt;'closure()'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; 运算符的值（ &lt;code&gt;digraph&lt;/code&gt; 表示）由原子 &lt;code&gt;'closure()'&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="22be0277bd691cf393301070a38cd39e17abb844" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;mod&lt;/code&gt; key of the including application must be set to &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; as usual is the application callback module. &lt;code&gt;StartArgs&lt;/code&gt; is a term provided as argument to the callback function &lt;code&gt;Module:start/2&lt;/code&gt;:</source>
          <target state="translated">必须将包含应用程序的 &lt;code&gt;mod&lt;/code&gt; 密钥的值设置为 &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt; ，其中照常， &lt;code&gt;Module&lt;/code&gt; 是应用程序回调模块。 &lt;code&gt;StartArgs&lt;/code&gt; 是作为回调函数 &lt;code&gt;Module:start/2&lt;/code&gt; 的参数提供的术语：</target>
        </trans-unit>
        <trans-unit id="da373a852b7bee0733084683f1b87c03b30e88ac" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 时间单位的值或多或少没有给您有关时间质量值的信息。它为时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 设置了限制，但没有提供有关时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 的信息。的分辨率 &lt;code&gt;native&lt;/code&gt; 时间单位和时间值的分辨率可以显著不同。</target>
        </trans-unit>
        <trans-unit id="e1d24fa6cc650f3b91539b4d964f2dd68411a599" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 时间单位的值或多或少没有给您有关时间质量值的信息。它为时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 设置了限制，但没有提供有关时间值的 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 的信息。本 &lt;code&gt;native&lt;/code&gt; 时间单位的分辨率和时间值的分辨率可能会有很大差异。</target>
        </trans-unit>
        <trans-unit id="75115f0cbc11f2e0c976711bd383faef47f72f73" translate="yes" xml:space="preserve">
          <source>The value of the Kernel configuration parameter &lt;code&gt;logger&lt;/code&gt; is a list of tuples. It is possible to write the term on the command line when starting an erlang node, but as the term grows, a better approach is to use the system configuration file. See the &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; manual page for more information about this file.</source>
          <target state="translated">内核配置参数 &lt;code&gt;logger&lt;/code&gt; 的值是一个元组列表。启动erlang节点时可以在命令行上写该术语，但是随着该术语的增长，更好的方法是使用系统配置文件。有关此文件的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="096809c94755b1b48047ae78701c25d723875bee" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;offset&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="4ed44d3d955ffacf489b8abf33f5d265d4032122" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;offset&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="de235421fccf5bce601796cc084376b482bb1b5e" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;time_designator&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="3c25e0afe475bdf7bd456a401767e588d0dff287" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">此参数的值用作 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 的 &lt;code&gt;time_designator&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fcf4c591c4a3e4e565b4ce6c5bc397552958d5be" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on application level.</source>
          <target state="translated">该参数的值会覆盖应用层的同名参数。</target>
        </trans-unit>
        <trans-unit id="5f26c290284005b85aff4a14161e0e2b51659761" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on system level.</source>
          <target state="translated">该参数的值会覆盖系统级的同名参数。</target>
        </trans-unit>
        <trans-unit id="afeb557b1f15dc186755d5f00deaf5e3432d37f3" translate="yes" xml:space="preserve">
          <source>The value range stated at the top of this function description is technically correct, but &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically.</source>
          <target state="translated">从功能上讲，此函数说明顶部的值范围在技术上是正确的，但 &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; 是对生成数字的统计分布的更好描述。除了从不返回精确的0.0，这在统计上是不可能观察到的。</target>
        </trans-unit>
        <trans-unit id="f7e9882005855e83068faaf2ba230799c0a1530e" translate="yes" xml:space="preserve">
          <source>The value returned from &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; equals the, by this thread, latest confirmed value plus two. The global value may be latest confirmed value or latest confirmed value minus one. In order to be certain that all other managed threads actually will call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; at least once before we reach the value returned from &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;, the global counter plus one is not enough. This since all other threads may already have confirmed current global value plus one at the time when we call &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;. They are however guaranteed not to have confirmed global value plus two at this time.</source>
          <target state="translated">&lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 返回的值等于该线程的最新确认值加两个。全局值可以是最新确认值或最新确认值减一。为了确保所有其他托管线程实际上会调用 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 至少一次，我们到达从返回的值前 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; ，全球计数器加一远远不够的。这是因为在我们调用 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 时，所有其他线程可能已经确认了当前全局值加一。但是，可以保证他们目前没有确定的全球价值加上2。</target>
        </trans-unit>
        <trans-unit id="de293b0684a913e1bf7ebfb80ee4f6ab7675b8bf" translate="yes" xml:space="preserve">
          <source>The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, at the time the diameter application was started.</source>
          <target state="translated">返回的值是自19680120T031408Z开始可以应用的秒数，该值可以在开始应用直径 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 被编码为Diameter Time（）。</target>
        </trans-unit>
        <trans-unit id="a55ba7f90cd067fd29a372ba9492df0943f53a10" translate="yes" xml:space="preserve">
          <source>The value specifies a list of source files to be merged with the file being compiled; cf. &lt;code&gt;merge_files/4&lt;/code&gt;.</source>
          <target state="translated">该值指定要与正在编译的文件合并的源文件的列表。cf. &lt;code&gt;merge_files/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9a745307527128e1be0119641ffa2f422dcd359" translate="yes" xml:space="preserve">
          <source>The value(s) correspond to the currently active socket &lt;code&gt;&lt;a href=&quot;#type-socket_setopt&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt;, or for a single send operation the option(s) to override the currently active socket option(s).</source>
          <target state="translated">该值对应于当前活动的套接字 &lt;code&gt;&lt;a href=&quot;#type-socket_setopt&quot;&gt;options&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; ，或者对于单个发送操作，该选项将覆盖当前活动的套接字选项。</target>
        </trans-unit>
        <trans-unit id="9f03a18e612b75547971d666854d8f1114a5bb61" translate="yes" xml:space="preserve">
          <source>The values encoded in the fields of generated records depends on the type and number of times the AVP can occur. In particular, an AVP which is specified as occurring exactly once is encoded as a value of the AVP's type while an AVP with any other specification is encoded as a list of values of the AVP's type. The AVP's type is as specified in the AVP definition, the RFC 6733 types being described below.</source>
          <target state="translated">生成的记录字段中的编码值取决于AVP的类型和出现的次数。特别是,被指定为准确出现一次的AVP被编码为AVP的类型值,而具有任何其他规格的AVP被编码为AVP的类型值列表。AVP的类型是在AVP定义中指定的,RFC 6733类型如下所述。</target>
        </trans-unit>
        <trans-unit id="28cbef0507c54b3b51d13679291493de8c4ec6f1" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file and the values in a system configuration file can be overridden directly from the command line:</source>
          <target state="translated">在的值 &lt;code&gt;.app&lt;/code&gt; 文件，并在系统配置文件中的值可以直接从命令行来覆盖：</target>
        </trans-unit>
        <trans-unit id="25131865afbeb61db1691607b17034d98faf548c" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file can be overridden by values in a &lt;strong&gt;system configuration file&lt;/strong&gt;. This is a file that contains configuration parameters for relevant applications:</source>
          <target state="translated">在的值 &lt;code&gt;.app&lt;/code&gt; 文件可以由值在被覆盖&lt;strong&gt;的系统配置文件&lt;/strong&gt;。这是一个文件，其中包含相关应用程序的配置参数：</target>
        </trans-unit>
        <trans-unit id="626a57e5be3f05ed3f7f8f360fb873aeecee8e88" translate="yes" xml:space="preserve">
          <source>The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is &lt;code&gt;index&lt;/code&gt;, the tuple &lt;code&gt;{-1,0}&lt;/code&gt; is returned for values with no corresponding subpattern in the regular expression, but for the other types (&lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;), the values are the empty binary or list, respectively.</source>
          <target state="translated">值列表可以指定正则表达式中不存在的索引或名称，在这种情况下，返回值取决于类型。如果类型为 &lt;code&gt;index&lt;/code&gt; ，则对于正则表达式中没有对应子模式的值，返回元组 &lt;code&gt;{-1,0}&lt;/code&gt; ，但对于其他类型（ &lt;code&gt;binary&lt;/code&gt; 和 &lt;code&gt;list&lt;/code&gt; ），则分别返回空的二进制或列表。</target>
        </trans-unit>
        <trans-unit id="98c64e5c6439b461a184b2c5ad5e2ae137e1bafa" translate="yes" xml:space="preserve">
          <source>The values of L used in the tree is a dense range from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;Max - 1&lt;/code&gt;, where &lt;code&gt;N =&amp;lt; Max =&amp;lt; N + size(Tree)&lt;/code&gt;. Note that it is possible that no labels are used at all, i.e., &lt;code&gt;N = Max&lt;/code&gt;.</source>
          <target state="translated">树中使用的L值是从 &lt;code&gt;N&lt;/code&gt; 到 &lt;code&gt;Max - 1&lt;/code&gt; 的密集范围，其中 &lt;code&gt;N =&amp;lt; Max =&amp;lt; N + size(Tree)&lt;/code&gt; 。注意，有可能根本不使用标签，即 &lt;code&gt;N = Max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="863d5cefc2b644473a83e6d5a4a11ff192199273" translate="yes" xml:space="preserve">
          <source>The values of each ASN.1 type have their own representation in Erlang, as described in the following sections. Users must provide these values for encoding according to the representation, as shown in the following example:</source>
          <target state="translated">每个ASN.1类型的值在Erlang中都有自己的表示方式,在下面的章节中描述。用户必须根据表示法提供这些值进行编码,如下例所示。</target>
        </trans-unit>
        <trans-unit id="3cda52f885cae0f363921f91bfa5571c49510a4d" translate="yes" xml:space="preserve">
          <source>The values of the largest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">最大多块载波大小（ &lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt; ）的值</target>
        </trans-unit>
        <trans-unit id="dcd3ad0ab905a987c601beb85b07dfe07ff7ed75" translate="yes" xml:space="preserve">
          <source>The values of the previously listed thresholds can be specified by the user. This way, a handler can be configured to, for example, not drop or flush messages unless the message queue length of the handler process grows extremely large. Notice that large amounts of memory can be required for the node under such circumstances. Another example of user configuration is when, for performance reasons, the client processes must never be blocked by synchronous log requests. It is possible, perhaps, that dropping or flushing events is still acceptable, since it does not affect the performance of the client processes sending the log events.</source>
          <target state="translated">前面列出的阈值可以由用户指定。这样,可以将处理程序配置为,例如,除非处理程序进程的消息队列长度增长得非常大,否则不会丢弃或刷新消息。注意,在这种情况下,节点可能需要大量的内存。另一个用户配置的例子是,出于性能考虑,客户端进程决不能被同步日志请求阻塞。也许,丢弃或刷新事件仍然是可以接受的,因为它不会影响发送日志事件的客户端进程的性能。</target>
        </trans-unit>
        <trans-unit id="98636015bbae4c3fb1d161c6f8cb32205bc5b72f" translate="yes" xml:space="preserve">
          <source>The values of unused bits are disregarded and does not need to be cleared.</source>
          <target state="translated">未使用的位的值被忽略,不需要清除。</target>
        </trans-unit>
        <trans-unit id="8b7f02eea975023ab88f97c824c6cf6ba208bfb2" translate="yes" xml:space="preserve">
          <source>The values of unused bits in the first and last byte are undefined and cannot be relied on.</source>
          <target state="translated">第一和最后一个字节中未使用的位的值是未定义的,不能依赖。</target>
        </trans-unit>
        <trans-unit id="20d445c310ac867e11827b280d08f4096d3c3c12" translate="yes" xml:space="preserve">
          <source>The values stored when &lt;code&gt;put&lt;/code&gt; is evaluated within the scope of a &lt;code&gt;catch&lt;/code&gt; are not retracted if a &lt;code&gt;throw&lt;/code&gt; is evaluated, or if an error occurs.</source>
          <target state="translated">当存储的值 &lt;code&gt;put&lt;/code&gt; 被一个的范围内评价 &lt;code&gt;catch&lt;/code&gt; 如果不缩回 &lt;code&gt;throw&lt;/code&gt; 被评估，或者如果发生错误。</target>
        </trans-unit>
        <trans-unit id="f0e48d6dd38ad6c9102722d33252c5ae65615ba8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;$ERL_TOP&lt;/code&gt; will be mentioned a lot of times. It refers to the top directory in the source tree. More information about &lt;code&gt;$ERL_TOP&lt;/code&gt; can be found in the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; section below. If you are building in git you probably want to take a look at the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section below before proceeding.</source>
          <target state="translated">变量 &lt;code&gt;$ERL_TOP&lt;/code&gt; 将被多次提及。它引用源树中的顶层目录。有关 &lt;code&gt;$ERL_TOP&lt;/code&gt; 更多信息 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; 下面的make和$ ERL_TOP部分。如果您正在使用git进行 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 在继续操作之前，可能要先阅读下面的&amp;ldquo; 在Git中构建&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b71a4a47f8b57681eb67d0f149cf4d7c4811e3e6" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$$'&lt;/code&gt; expands to a list of the values of all bound variables in order (that is, &lt;code&gt;['$1','$2', ...]&lt;/code&gt;).</source>
          <target state="translated">变量 &lt;code&gt;'$$'&lt;/code&gt; 按顺序扩展到所有绑定变量的值的列表（即 &lt;code&gt;['$1','$2', ...]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9e92c9812c408c5ff3803c9050d025112ca40670" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$_'&lt;/code&gt; expands to the whole &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; term.</source>
          <target state="translated">变量 &lt;code&gt;'$_'&lt;/code&gt; 扩展为整个 &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; 词。</target>
        </trans-unit>
        <trans-unit id="223547b0ee006d68fdeafe7dbabcdb4195ccc06b" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;Bin&lt;/code&gt; must contain a whole number of bytes, because the &lt;code&gt;binary&lt;/code&gt; type defaults to &lt;code&gt;unit:8&lt;/code&gt;. A &lt;code&gt;badarg&lt;/code&gt; exception is generated if &lt;code&gt;Bin&lt;/code&gt; consist of, for example, 17 bits.</source>
          <target state="translated">变量 &lt;code&gt;Bin&lt;/code&gt; 必须包含整数个字节，因为 &lt;code&gt;binary&lt;/code&gt; 类型默认为 &lt;code&gt;unit:8&lt;/code&gt; 。甲 &lt;code&gt;badarg&lt;/code&gt; 如果产生异常 &lt;code&gt;Bin&lt;/code&gt; 组成的，例如，17位。</target>
        </trans-unit>
        <trans-unit id="b327cd3ab139aaaeb5479b3a8cd2e03a44cba9d4" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the bit string comprehensions.</source>
          <target state="translated">生成器模式中的变量,函数子句中的影子变量,围绕位串理解。</target>
        </trans-unit>
        <trans-unit id="ba7b76fc37dd4760f96fd86e277ce66335f21492" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the list comprehensions.</source>
          <target state="translated">生成器模式中的变量,函数子句中的影子变量,围绕列表理解。</target>
        </trans-unit>
        <trans-unit id="c3cbd2f6779e41d23e6821f5cc806aa75af8d5cf" translate="yes" xml:space="preserve">
          <source>The variables in the specified test system configuration files are imported for the test.</source>
          <target state="translated">指定的测试系统配置文件中的变量被导入测试。</target>
        </trans-unit>
        <trans-unit id="16b31340c6df5777f901eec1b8dd72202ecc99a3" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;iodata()&lt;/code&gt; that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</source>
          <target state="translated">&lt;code&gt;iodata()&lt;/code&gt; 的变体，它使用当前的实现（通常是二进制文件，但不依赖于它）提供最少的数据复制。</target>
        </trans-unit>
        <trans-unit id="7db0c9c9f81aaee69d11da93235542d480ff9436" translate="yes" xml:space="preserve">
          <source>The variants &lt;code&gt;http_bin&lt;/code&gt; and &lt;code&gt;httph_bin&lt;/code&gt; return strings (&lt;code&gt;HttpString&lt;/code&gt;) as binaries instead of lists.</source>
          <target state="translated">变体 &lt;code&gt;http_bin&lt;/code&gt; 和 &lt;code&gt;httph_bin&lt;/code&gt; 返回字符串（ &lt;code&gt;HttpString&lt;/code&gt; ）作为二进制文件而不是列表。</target>
        </trans-unit>
        <trans-unit id="386d7a023ddb83a55d49c04d2e00b77bbc947fdc" translate="yes" xml:space="preserve">
          <source>The verb name comes from the observation that it can be used for a pattern-based if-then-else block:</source>
          <target state="translated">动词名称来自于观察,它可以用于基于模式的if-then-else块。</target>
        </trans-unit>
        <trans-unit id="e53a018823f7d0826b490411f9a345448e7e805f" translate="yes" xml:space="preserve">
          <source>The verbs described above provide four different &quot;strengths&quot; of control when subsequent matching fails:</source>
          <target state="translated">上述动词在后续匹配失败时提供了四种不同的控制 &quot;力度&quot;。</target>
        </trans-unit>
        <trans-unit id="f2b992bf8000e459ed5b0cdc131fc96ec8dcdccf" translate="yes" xml:space="preserve">
          <source>The verification fun is called during the X509-path validation when an error or an extension unknown to the SSL application is encountered. It is also called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. It differentiates between the peer certificate and the CA certificates by using &lt;code&gt;valid_peer&lt;/code&gt; or &lt;code&gt;valid&lt;/code&gt; as second argument to the verification fun. See the &lt;code&gt;public_key User's Guide&lt;/code&gt; for definition of &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; and &lt;code&gt;#'Extension'{}&lt;/code&gt;.</source>
          <target state="translated">当遇到错误或SSL应用程序未知的扩展名时，将在X509路径验证期间调用验证乐趣。当路径验证认为证书有效时，也将调用此方法，以允许访问用户应用程序路径中的每个证书。通过使用 &lt;code&gt;valid_peer&lt;/code&gt; 或 &lt;code&gt;valid&lt;/code&gt; 作为验证功能的第二个参数，它区分对等证书和CA证书。有关 &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; 和 &lt;code&gt;#'Extension'{}&lt;/code&gt; 的定义，请参见 &lt;code&gt;public_key User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1de90c0b2842f11f7973bd5edddedba51c5c85c5" translate="yes" xml:space="preserve">
          <source>The verification fun is to be defined as follows:</source>
          <target state="translated">核查乐趣的定义如下:</target>
        </trans-unit>
        <trans-unit id="e534d40ef492be59da6ec155736a8f23e023fdd5" translate="yes" xml:space="preserve">
          <source>The verification process</source>
          <target state="translated">核查过程</target>
        </trans-unit>
        <trans-unit id="a7587f36555080700643b0019cdfdef45f4827cd" translate="yes" xml:space="preserve">
          <source>The version is defined by the module attribute &lt;code&gt;vsn&lt;/code&gt;, if any. There is no such attribute in &lt;code&gt;ch3&lt;/code&gt;, so in this case the version is the checksum (a huge integer) of the beam file, an uninteresting value, which is ignored.</source>
          <target state="translated">版本由模块属性 &lt;code&gt;vsn&lt;/code&gt; （如果有）定义。 &lt;code&gt;ch3&lt;/code&gt; 中没有这样的属性，因此在这种情况下，版本是波束文件的校验和（一个巨大的整数），一个无意义的值，将被忽略。</target>
        </trans-unit>
        <trans-unit id="b6440cebe392d666b5024e49f82c9929c9694517" translate="yes" xml:space="preserve">
          <source>The version numbers differ in your system. Whenever one of the applications included in the script is upgraded, change the script.</source>
          <target state="translated">您的系统中的版本号不同。每当脚本中包含的一个应用程序升级时,请更改脚本。</target>
        </trans-unit>
        <trans-unit id="81ee8706973e7d65b914ed727a2144141d282b58" translate="yes" xml:space="preserve">
          <source>The version of an application specified in the &lt;code&gt;.rel&lt;/code&gt; file is to be the same as the version specified in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">在指定的应用程序的版本 &lt;code&gt;.rel&lt;/code&gt; 文件将是相同的指定的版本 &lt;code&gt;.app&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d2168251640676c1f75844920669340f83623b6f" translate="yes" xml:space="preserve">
          <source>The version of net-if provided by this application makes no use of this data, with one exception: Any tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; may be used by the agent and is therefor &lt;strong&gt;reserved&lt;/strong&gt;.</source>
          <target state="translated">此应用程序提供的net-if版本不使用此数据，但有一个例外：代理可以使用任何包含原子 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 的元组，因此&lt;strong&gt;保留&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="35ae167373b6abecea965d3976c2d1e8cb0f8001" translate="yes" xml:space="preserve">
          <source>The version of the application. In an installed system there may exist several versions of an application. The &lt;code&gt;vsn&lt;/code&gt; parameter controls which version of the application will be chosen.</source>
          <target state="translated">应用程序的版本。在已安装的系统中，可能存在一个应用程序的多个版本。所述 &lt;code&gt;vsn&lt;/code&gt; 该应用程序的版本将被选择的参数的控制。</target>
        </trans-unit>
        <trans-unit id="0f6691af69660ac2dbeef6458e54f6b092b02a7f" translate="yes" xml:space="preserve">
          <source>The version scheme was changed as of OTP 17.0. This implies that application versions used prior to OTP 17.0 do not adhere to this version scheme. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; is included at the end of this section</source>
          <target state="translated">从OTP 17.0开始，版本方案已更改。这意味着在OTP 17.0之前使用的应用程序版本不遵循该版本方案。本节末尾包含 &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71667a4b4c466db83cfa8dccda4dd2b33a602563" translate="yes" xml:space="preserve">
          <source>The versions are defined in following RFCs</source>
          <target state="translated">这些版本在以下RFC中定义</target>
        </trans-unit>
        <trans-unit id="b4892e73c1831bf8a3d6b46b7aa415cf267e8507" translate="yes" xml:space="preserve">
          <source>The viewed trace data is normally collected from Erlang trace ports or files.</source>
          <target state="translated">所查看的跟踪数据通常是从 Erlang 跟踪端口或文件中收集的。</target>
        </trans-unit>
        <trans-unit id="1a0d8d976122d98e4cfd120d6e6af690ee189bd4" translate="yes" xml:space="preserve">
          <source>The virtual binary heap exists in order to &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; garbage collections earlier when potentially there is a very large amount of off-heap binary data that could be reclaimed. This approach does not catch all problems with binary memory not being released soon enough, but it does catch a lot of them.</source>
          <target state="translated">存在虚拟二进制堆是为了在可能存在大量可回收的堆外二进制数据时更早 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 垃圾收集。这种方法并不能解决二进制存储器没有足够快释放的所有问题，但是确实可以解决很多问题。</target>
        </trans-unit>
        <trans-unit id="4c8e60b869b23fc7c125b17fff74830d66f135c3" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_NET_RAW&lt;/code&gt;.</source>
          <target state="translated">虚拟机还需要提升的特权，这些特权可以以超级用户身份运行或（对于Linux）具有 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 能力。</target>
        </trans-unit>
        <trans-unit id="cc464fdb800c73159385639322d0fc6141087504" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; according to the documentation for &lt;code&gt;setns(2)&lt;/code&gt;. However, during testing also &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; and &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; have proven to be necessary.</source>
          <target state="translated">根据 &lt;code&gt;setns(2)&lt;/code&gt; 的文档，虚拟机还需要提升的特权，以超级用户身份运行或（对于Linux）以 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 能力运行。但是，在测试过程中， &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; 和 &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; 也被证明是必需的。</target>
        </trans-unit>
        <trans-unit id="c60aa1ccef629b3d22eb0b09964d1681efe07a87" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows MacOS X and Android.</source>
          <target state="translated">虚拟机在处理文件名时,就像使用UTF-8(或其他系统特定的Unicode编码)一样。这是强制执行Unicode编码的操作系统(即Windows MacOS X和Android)的默认设置。</target>
        </trans-unit>
        <trans-unit id="006ddc155b00e369e7d44f1b15919a8110bdd467" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows and MacOS X.</source>
          <target state="translated">虚拟机在处理文件名时,就像使用UTF-8编码(或其他系统特定的Unicode编码)一样。这是强制执行Unicode编码的操作系统(即Windows和MacOS X)的默认设置。</target>
        </trans-unit>
        <trans-unit id="c517daaf8ca72cb9652e4e1b82ea25a6ea34e353" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using the ISO Latin-1 encoding, disallowing Unicode characters with code points &amp;gt; 255.</source>
          <target state="translated">虚拟机使用文件名，就像使用ISO Latin-1编码对文件名进行编码一样，不允许代码点&amp;gt; 255的Unicode字符。</target>
        </trans-unit>
        <trans-unit id="7328722d5a1a5caf291033df806ee0e4a77a5bcb" translate="yes" xml:space="preserve">
          <source>The waiting for thread progress in 4-6 is necessary in order for processes to read &lt;code&gt;the_active_code_index&lt;/code&gt; atomic during normal execution without any expensive memory barriers. When we write a new value into &lt;code&gt;the_active_code_index&lt;/code&gt; in step 6, we know that all schedulers will see an updated and consistent view of all the new active access structures once they become reachable through &lt;code&gt;the_active_code_index&lt;/code&gt;.</source>
          <target state="translated">为了使进程在正常执行期间读取 &lt;code&gt;the_active_code_index&lt;/code&gt; 原子而没有任何昂贵的内存屏障，必须等待4-6中的线程进度。当我们在步骤6 &lt;code&gt;the_active_code_index&lt;/code&gt; 新值写入the_active_code_index时，我们知道所有调度程序都会通过 &lt;code&gt;the_active_code_index&lt;/code&gt; 到达所有新的活动访问结构，它们将看到更新且一致的视图。</target>
        </trans-unit>
        <trans-unit id="c8d97e463a7a60c3b6aea9ab7db9eb585b1ed683" translate="yes" xml:space="preserve">
          <source>The waiting in step 10 is to make sure no lingering thread is still accessing disabled breakpoint structures to be deallocated in step 12.</source>
          <target state="translated">第10步中的等待是为了确保没有滞留线程还在访问被禁用的断点结构,以便在第12步中进行deallocated。</target>
        </trans-unit>
        <trans-unit id="72bf42f8550a67bb1de6bfd1cb44b03b77930eb8" translate="yes" xml:space="preserve">
          <source>The waiting in step 4 is to make sure all threads will see an updated view of the breakpoint structures once they become reachable through the &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction written in step 5.</source>
          <target state="translated">步骤4中的等待操作是确保一旦通过步骤5中编写的 &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; 指令可访问所有线程，就可以看到所有断点结构的更新视图。</target>
        </trans-unit>
        <trans-unit id="053a67fd8d554f23b57dd15ba93a7604fd04b7ad" translate="yes" xml:space="preserve">
          <source>The waiting in step 6 is to make the activation of the new trace settings &quot;as atomic as possible&quot;. Different cores might see the new value of &lt;code&gt;erts_active_bp_index&lt;/code&gt; at different times as it is read without any memory barrier. But this is the best we can do without more expensive thread synchronization.</source>
          <target state="translated">在步骤6中等待的是&amp;ldquo;尽可能使原子&amp;rdquo;激活新的跟踪设置。由于读取它们时没有任何内存障碍，因此不同的内核可能会在不同的时间看到 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 的新值。但这是我们最好的方法，而不需要更昂贵的线程同步。</target>
        </trans-unit>
        <trans-unit id="8e0755f04339935ab04dbc314aa1c277dab33406" translate="yes" xml:space="preserve">
          <source>The waiting in step 8 is to make sure we dont't restore the original bream instructions for disabled breakpoints until we know that no thread is still accessing the old enabled part of a disabled breakpoint.</source>
          <target state="translated">第8步中的等待是为了确保我们不会恢复禁用断点的原始bream指令,直到我们知道没有线程还在访问禁用断点的旧启用部分。</target>
        </trans-unit>
        <trans-unit id="13ed31f912a0c3756dff51206169f32f13717017" translate="yes" xml:space="preserve">
          <source>The wanted string encoding is specified by &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt;. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from &lt;code&gt;*was&lt;/code&gt;. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from &lt;code&gt;*result&lt;/code&gt;. Both &lt;code&gt;was&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;*result&lt;/code&gt; can differ from &lt;code&gt;want&lt;/code&gt; if &lt;code&gt;want&lt;/code&gt; is a bitwise OR'd combination like &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; or if &lt;code&gt;*result&lt;/code&gt; turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</source>
          <target state="translated">所需的字符串编码由 &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt; 指定。可以从 &lt;code&gt;*was&lt;/code&gt; 获得二进制格式（Latin-1或UTF-8）中使用的原始编码。可以从 &lt;code&gt;*result&lt;/code&gt; 获得结果字符串的编码（7位ASCII，Latin-1或UTF-8）。无论 &lt;code&gt;was&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 可以为 &lt;code&gt;NULL&lt;/code&gt; 。 &lt;code&gt;*result&lt;/code&gt; 可以从不同 &lt;code&gt;want&lt;/code&gt; 如果 &lt;code&gt;want&lt;/code&gt; 是按位或运算等的组合 &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; 或者如果 &lt;code&gt;*result&lt;/code&gt; 证明是纯的7位ASCII码（同时兼容的Latin-1和UTF-8）。</target>
        </trans-unit>
        <trans-unit id="018d5b3762ed16f8137ce9fdaea1d65522f0b4e2" translate="yes" xml:space="preserve">
          <source>The warning for the first clause says that the creation of a sub binary cannot be delayed, because it will be returned. The warning for the second clause says that a sub binary will not be created (yet).</source>
          <target state="translated">第一个子句的警告说,子二进制的创建不能被延迟,因为它将被返回。第二个子句的警告是说,子二进制的创建不会(还没有)。</target>
        </trans-unit>
        <trans-unit id="5ce61e8b18d0497bc2e9762acc6fdf3697ac3b7b" translate="yes" xml:space="preserve">
          <source>The warning is given if the number of shift/reduce conflicts differs from 2, or if there are reduce/reduce conflicts.</source>
          <target state="translated">如果移位/缩位冲突的数量与2不同,或者存在缩位/缩位冲突,则发出警告。</target>
        </trans-unit>
        <trans-unit id="eac3dbbed6bc0bb402c42ed8978c9b0740688aad" translate="yes" xml:space="preserve">
          <source>The warning message will look like this:</source>
          <target state="translated">警告信息会是这样的。</target>
        </trans-unit>
        <trans-unit id="40ff587868921130f6eb1c6a720b2933f27272e9" translate="yes" xml:space="preserve">
          <source>The warnings detected include:</source>
          <target state="translated">检测到的警告包括:</target>
        </trans-unit>
        <trans-unit id="57441a0a1920375468fcb3cda7b741895e7ab716" translate="yes" xml:space="preserve">
          <source>The warnings look as follows:</source>
          <target state="translated">警告内容如下:</target>
        </trans-unit>
        <trans-unit id="3bcce3258cf3577717dad6c74c35c711e27cd4cd" translate="yes" xml:space="preserve">
          <source>The way EUnit represents tests and test sets as data is flexible, powerful, and concise. This section describes the representation in detail.</source>
          <target state="translated">EUnit 将测试和测试集表示为数据的方式灵活、强大、简洁。本节将详细介绍这种表示方式。</target>
        </trans-unit>
        <trans-unit id="965b7339512f62c1c68183166bad964a056729e8" translate="yes" xml:space="preserve">
          <source>The web-based GUI, Virtual Test Server (VTS), is started with the &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program. From the GUI, you can load configuration files and select directories, suites, and cases to run. You can also state the configuration files, directories, suites, and cases on the command line when starting the web-based GUI.</source>
          <target state="translated">基于Web的GUI虚拟测试服务器（VTS）是使用 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 程序启动的。从GUI，您可以加载配置文件并选择要运行的目录，套件和案例。启动基于Web的GUI时，还可以在命令行上声明配置文件，目录，套件和案例。</target>
        </trans-unit>
        <trans-unit id="6550d3349d235f242c72f62c04f437d2ce48c34b" translate="yes" xml:space="preserve">
          <source>The well-known quick sort routine can be written as follows:</source>
          <target state="translated">著名的快速排序例程可以写成如下。</target>
        </trans-unit>
        <trans-unit id="1daf9c055686d26205a86325249ab61a258c6aa6" translate="yes" xml:space="preserve">
          <source>The whole list comprehension must be given to the function &lt;code&gt;qlc:q/1&lt;/code&gt;.</source>
          <target state="translated">整个列表理解必须赋予函数 &lt;code&gt;qlc:q/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a700c9c164740d8193a70ef5191bc6f87818b7c6" translate="yes" xml:space="preserve">
          <source>The whole original data chunk attempted to be sent.</source>
          <target state="translated">整个原始数据块尝试发送。</target>
        </trans-unit>
        <trans-unit id="3f50dc8a9a7232f081e9d82f5c58d1d5ab88774d" translate="yes" xml:space="preserve">
          <source>The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">通配符字符串看起来就像一个普通的文件名,除了以下的 &quot;通配符字符 &quot;会以一种特殊的方式解释。</target>
        </trans-unit>
        <trans-unit id="445ca2425df9850fe9ecf76a693661ab20880f20" translate="yes" xml:space="preserve">
          <source>The window is divided into the following five parts:</source>
          <target state="translated">窗口分为以下五个部分。</target>
        </trans-unit>
        <trans-unit id="7aff75c1f4395e5c6a248f745c978774f96901a5" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;ANNO&lt;/code&gt; in this section represents an annotation, and denotes among other things the number of the line in the source file where the construction occurred. See &lt;code&gt;erl_anno(3)&lt;/code&gt; for details. Several instances of &lt;code&gt;ANNO&lt;/code&gt; in the same construction can denote different annotations.</source>
          <target state="translated">本节中的单词 &lt;code&gt;ANNO&lt;/code&gt; 表示注释，除其他外，它表示源文件中发生构造的行号。有关详细信息，请参见 &lt;code&gt;erl_anno(3)&lt;/code&gt; 。具有相同构造的 &lt;code&gt;ANNO&lt;/code&gt; 的多个实例可以表示不同的注释。</target>
        </trans-unit>
        <trans-unit id="3c5d5fc6a6c1a668ddf6252dfa60f0a768f4fd44" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;LINE&lt;/code&gt; in this section represents an integer, and denotes the number of the line in the source file where the construction occurred. Several instances of &lt;code&gt;LINE&lt;/code&gt; in the same construction can denote different lines.</source>
          <target state="translated">本节中的单词 &lt;code&gt;LINE&lt;/code&gt; 表示整数，并表示源文件中发生构造的行号。同一构造中 &lt;code&gt;LINE&lt;/code&gt; 的多个实例可以表示不同的线。</target>
        </trans-unit>
        <trans-unit id="eade7caf0a719386f3ed9bf0405c428ad15ea3eb" translate="yes" xml:space="preserve">
          <source>The workflow is as follows:</source>
          <target state="translated">工作流程如下:</target>
        </trans-unit>
        <trans-unit id="c9930007b7ab7effc4f3827d9e45f7224f2de6c3" translate="yes" xml:space="preserve">
          <source>The working directory for the Erlang emulator. Must be on a local drive (no network drives are mounted when a service starts). Default working directory for services is &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt;. Debug log files will be placed in this directory.</source>
          <target state="translated">Erlang仿真器的工作目录。必须在本地驱动器上（服务启动时未安装网络驱动器）。服务的默认工作目录为 &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt; 。调试日志文件将放置在此目录中。</target>
        </trans-unit>
        <trans-unit id="256bb673e1707d94ab2537efadaa95bffde4c53b" translate="yes" xml:space="preserve">
          <source>The written string is always &lt;code&gt;NULL&lt;/code&gt;-terminated, unless buffer &lt;code&gt;size&lt;/code&gt; is &amp;lt; &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">除非缓冲区 &lt;code&gt;size&lt;/code&gt; 小于 &lt;code&gt;1&lt;/code&gt; ，否则写入的字符串始终以 &lt;code&gt;NULL&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="8f7a1436c802ad678039fa82fd904d4269922bbb" translate="yes" xml:space="preserve">
          <source>The wxWidgets-3.1 version should also work if 2.8 compatibility is enabled, add &lt;code&gt;--enable-compat28&lt;/code&gt; to configure commands below.</source>
          <target state="translated">如果启用了2.8兼容性，则wxWidgets-3.1版本也应该工作，请添加 &lt;code&gt;--enable-compat28&lt;/code&gt; 来配置以下命令。</target>
        </trans-unit>
        <trans-unit id="8a53a91ff254f2bc93279dc81109c603e90d0d26" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec.</source>
          <target state="translated">xmerl_xpath模块处理整个XPath 1.0规范。</target>
        </trans-unit>
        <trans-unit id="119bf8dc786018631b7988a88beda339c2ba800b" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec. XPath expressions typically occur in XML attributes and are used to address parts of an XML document. The grammar is defined in &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt;. The core functions are defined in &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt;.</source>
          <target state="translated">xmerl_xpath模块处理整个XPath 1.0规范。XPath表达式通常出现在XML属性中，并用于寻址XML文档的某些部分。语法在 &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt; 中定义。核心功能在 &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="6a5386595bb90d8f1e716194fa384056a3c48037" translate="yes" xml:space="preserve">
          <source>The young heap, or the allocation heap, consists of the stack and heap as described in the Overview. However, it also includes any heap fragments that are attached to the heap. All of the heap fragments are considered to be above the high-watermark and part of the young generation. Heap fragments contain terms that either did not fit on the heap, or were created by another process and then attached to the heap. For instance if the bif &lt;code&gt;binary_to_term/1&lt;/code&gt; created a term which does not fit on the current heap without doing a garbage collection, it will create a heap-fragment for the term and then schedule a garbage collection for later. Also if a message is sent to the process, the payload may be placed in a heap-fragment and that fragment is added to young heap when the message is matched in a receive clause.</source>
          <target state="translated">如概述中所述，新堆或分配堆由堆栈和堆组成。但是，它也包括附加到堆的所有堆碎片。所有的堆碎片都被认为高于高水位线并且是年轻一代的一部分。堆片段包含的术语要么不适合堆，要么由另一个进程创建，然后附加到堆。例如，如果bif &lt;code&gt;binary_to_term/1&lt;/code&gt; 在不进行垃圾回收的情况下创建了一个不适合当前堆的术语，则它将为该术语创建一个堆碎片，然后安排垃圾回收以供以后使用。同样，如果将消息发送到进程，则有效负载可能会放在堆碎片中，并且当在接收子句中将消息匹配时，该碎片会添加到年轻堆中。</target>
        </trans-unit>
        <trans-unit id="f0a5d4ec5e9af18ded993eb6992af6fcaadb42e4" translate="yes" xml:space="preserve">
          <source>The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported.</source>
          <target state="translated">zip模块支持6.1以下的压缩包版本。但是,不支持密码保护和Zip64。</target>
        </trans-unit>
        <trans-unit id="f89ec6f488689cc3f3700cb5183e203d59254205" translate="yes" xml:space="preserve">
          <source>The | operator can also be used to add a head to a list:</source>
          <target state="translated">操作符&quot;|&quot;也可以用来在列表中添加一个头部。</target>
        </trans-unit>
        <trans-unit id="40fe3907425ba07df22ef0d6959c2d137d54e469" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;m1&lt;/code&gt; is cover compiled in test run &lt;code&gt;s2&lt;/code&gt;, but not shown in the coverage log. Instead, if &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; is called after both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; test runs are completed, the accumulated result for &lt;code&gt;m1&lt;/code&gt; is available in the cross cover log for test run &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">然后，在测试运行 &lt;code&gt;s2&lt;/code&gt; 中对 &lt;code&gt;m1&lt;/code&gt; 进行覆盖编译，但未在coverage日志中显示。相反，如果在 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 测试运行均完成之后调用 &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; ,则在 &lt;code&gt;m1&lt;/code&gt; 的累积结果可在测试运行 &lt;code&gt;s1&lt;/code&gt; 的跨封面日志中找到。</target>
        </trans-unit>
        <trans-unit id="a8047a09730147dedb7e9d78a5e192ccf03ab6c4" translate="yes" xml:space="preserve">
          <source>Then go to the cross host system and setup the erlang installed in (4) or (5) to be in your &lt;code&gt;$PATH&lt;/code&gt;. Then go to what previously was &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; and issue the following command.</source>
          <target state="translated">然后转到跨主机系统，并将（4）或（5）中安装的erlang设置为 &lt;code&gt;$PATH&lt;/code&gt; 。然后转到以前的 &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; 并发出以下命令。</target>
        </trans-unit>
        <trans-unit id="d8c63d4c24a80d8a897066cde6b4458486a7ca80" translate="yes" xml:space="preserve">
          <source>Then one column per state is printed with a the percentage of time this thread spent in the state out of it's own real-time. After the thread specific time, the accumulated time for each type of thread is printed in a similar format.</source>
          <target state="translated">然后每一个状态打印一列,写着这个线程在该状态下花费的时间占自己实时时间的百分比。在具体的线程时间之后,以类似的格式打印出各类线程的累计时间。</target>
        </trans-unit>
        <trans-unit id="58043576d5fe13fa1a246436e2e8c6ef745d143f" translate="yes" xml:space="preserve">
          <source>Then proceed as follows:</source>
          <target state="translated">然后按以下步骤进行:</target>
        </trans-unit>
        <trans-unit id="7d9412fbd0462825f974f875c15e384433c2ca1a" translate="yes" xml:space="preserve">
          <source>Then read the trace file and create the raw profile data with &lt;code&gt;fprof:profile()&lt;/code&gt;, or perhaps &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; for non-default filename.</source>
          <target state="translated">然后读取跟踪文件，并使用 &lt;code&gt;fprof:profile()&lt;/code&gt; 或使用 &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; 非默认文件名的原始配置文件数据。</target>
        </trans-unit>
        <trans-unit id="5663aeb9e710685d724afdba3fc67379b487af35" translate="yes" xml:space="preserve">
          <source>Then the compact text version without indentation and with short keywords:</source>
          <target state="translated">然后是无缩进、有短关键词的精简版文本。</target>
        </trans-unit>
        <trans-unit id="139ac9c79449e95e5f9e070852b997046b48832a" translate="yes" xml:space="preserve">
          <source>Then the compact version without indentation and with short keywords:</source>
          <target state="translated">然后是无缩进、有短关键词的精简版。</target>
        </trans-unit>
        <trans-unit id="b190b45bdf5a8e168cb79c9debb9d2ba24df930e" translate="yes" xml:space="preserve">
          <source>Then the listing of the atoms comes, starting with 10 and 5 which are the atom refs of the already cached atoms. Then the new atoms are sent.</source>
          <target state="translated">然后是原子列表,从10和5开始,它们是已经缓存的原子的原子引用。然后发送新的原子。</target>
        </trans-unit>
        <trans-unit id="641d01dad066a8551404d7310477baa1cb6f8772" translate="yes" xml:space="preserve">
          <source>Then the new event handler &lt;code&gt;Handler2&lt;/code&gt; is added and initiated by calling &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Module2&lt;/code&gt; is the callback module of &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module1:terminate/2&lt;/code&gt;. This makes it possible to transfer information from &lt;code&gt;Handler1&lt;/code&gt; to &lt;code&gt;Handler2&lt;/code&gt;.</source>
          <target state="translated">然后，通过调用 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 添加和启动新的事件处理程序 &lt;code&gt;Handler2&lt;/code&gt; ，其中 &lt;code&gt;Module2&lt;/code&gt; 是 &lt;code&gt;Handler2&lt;/code&gt; 的回调模块，而 &lt;code&gt;Term&lt;/code&gt; 是 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 的返回值。这使得可以将信息从 &lt;code&gt;Handler1&lt;/code&gt; 传输到 &lt;code&gt;Handler2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0c562a001db2c4ae28ac1742e8925ddf8af7163" translate="yes" xml:space="preserve">
          <source>Then the sublists are sorted and the results are combined.</source>
          <target state="translated">然后对子列表进行排序,并对结果进行合并。</target>
        </trans-unit>
        <trans-unit id="73b24c998d871947414c80ba0ded68c358316e6c" translate="yes" xml:space="preserve">
          <source>Then we continue with the call flow on the destination side:</source>
          <target state="translated">然后我们继续在目的端进行呼叫流转。</target>
        </trans-unit>
        <trans-unit id="57e50fb97a5f7d14f675710dd9c64d82897d7f75" translate="yes" xml:space="preserve">
          <source>Then we have the updates to the atom cache:</source>
          <target state="translated">然后,我们还要对原子缓存进行更新。</target>
        </trans-unit>
        <trans-unit id="b5acd2104208de4c3faf2546e133d8d457c2a417" translate="yes" xml:space="preserve">
          <source>Then you can add your favorite application my_app to the new PLT:</source>
          <target state="translated">然后你可以将你喜欢的应用程序my_app添加到新的PLT中。</target>
        </trans-unit>
        <trans-unit id="d31669bbfe7c81803e33f753695ac857feb8b190" translate="yes" xml:space="preserve">
          <source>Then you can proceed as follows:</source>
          <target state="translated">那么你可以进行如下操作。</target>
        </trans-unit>
        <trans-unit id="78475e203a352f84ea57f7b84f34d9e978f720ec" translate="yes" xml:space="preserve">
          <source>Then you can run it through the export_simple/2 function:</source>
          <target state="translated">然后你可以通过export_simple/2函数运行它。</target>
        </trans-unit>
        <trans-unit id="7e9e10c047b34e0b14a433931956d6784d8af0a2" translate="yes" xml:space="preserve">
          <source>Then you send events to the &lt;code&gt;Collector&lt;/code&gt; with the function &lt;code&gt;et_collector:report_event/6&lt;/code&gt; like this:</source>
          <target state="translated">然后使用函数 &lt;code&gt;et_collector:report_event/6&lt;/code&gt; 将事件发送到 &lt;code&gt;Collector&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="84181b0c3516063c275e5c08beaa5fc4213cccf5" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and configure it to log to file:</source>
          <target state="translated">然后，添加一个新的处理程序，将其打印到文件中。您可以使用处理程序模块 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; ，并将其配置为记录到文件：</target>
        </trans-unit>
        <trans-unit id="32ec0c3065e7c7e83edd0f5ba55760ca9ae6826d" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and specify type &lt;code&gt;{file,File}&lt;/code&gt;.:</source>
          <target state="translated">然后，添加一个新的处理程序，将其打印到文件中。您可以使用处理程序模块 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; ，并指定类型 &lt;code&gt;{file,File}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6ff57f64121d7cfa622102225ba9e153cee5fdd8" translate="yes" xml:space="preserve">
          <source>Then, all loaded modules are listed. The following fields exist:</source>
          <target state="translated">然后,列出所有加载的模块。存在以下字段:</target>
        </trans-unit>
        <trans-unit id="37285406a539aba18b235f1780c7ea66141aed2d" translate="yes" xml:space="preserve">
          <source>Then, an &lt;strong&gt;application specification&lt;/strong&gt; is needed, which is put in an &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt;. Among other things, this file specifies which modules the application consists of and the name of the callback module.</source>
          <target state="translated">然后，需要一个&lt;strong&gt;应用程序规范&lt;/strong&gt;，该&lt;strong&gt;规范&lt;/strong&gt;被放在 &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt; 。除其他外，该文件指定应用程序包含哪些模块以及回调模块的名称。</target>
        </trans-unit>
        <trans-unit id="6b038b9a866b08fa7aa12d5de74309b996761d25" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;strong&gt;system event&lt;/strong&gt; to be logged or traced, the following function is to be called.</source>
          <target state="translated">然后，对于要记录或跟踪的每个&lt;strong&gt;系统事件&lt;/strong&gt;，将调用以下函数。</target>
        </trans-unit>
        <trans-unit id="b2b275200d1a22a2d00f625e244ca1c19bb04f51" translate="yes" xml:space="preserve">
          <source>Then, for the primary application and each included application in top-down, left-to-right order, the application master calls &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; for each phase defined for the primary application, in that order. If a phase is not defined for an included application, the function is not called for this phase and application.</source>
          <target state="translated">然后，对于主应用程序和每个包含的应用程序，按从上到下的顺序（从左到右），应用程序主控器按该顺序为为主应用程序定义的每个阶段调用 &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; 。如果未为包含的应用程序定义阶段，则不会为该阶段和应用程序调用该函数。</target>
        </trans-unit>
        <trans-unit id="9bce82c8d0395aa60449fa59c5a8cfb50a252f9b" translate="yes" xml:space="preserve">
          <source>Then, you can use the &lt;code&gt;?Q(Text)&lt;/code&gt; macros in your code to create ASTs or match on existing ASTs. For example:</source>
          <target state="translated">然后，您可以在代码中使用 &lt;code&gt;?Q(Text)&lt;/code&gt; 宏来创建AST或与现有AST匹配。例如：</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="54025678c0a48ad36d078ae7c486444ea8302d6e" translate="yes" xml:space="preserve">
          <source>There are 146097 days in a 400 year period.</source>
          <target state="translated">400年中有146097天。</target>
        </trans-unit>
        <trans-unit id="4922e83fd8840f5a8507bbf756cb975adb85c4c4" translate="yes" xml:space="preserve">
          <source>There are 1461 days in a 4 year period.</source>
          <target state="translated">4年内有1461天。</target>
        </trans-unit>
        <trans-unit id="a006b5eea15a1aff01c844f4450c0802ffc7c5a3" translate="yes" xml:space="preserve">
          <source>There are 3 categories of events: &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;internal&lt;/code&gt;.</source>
          <target state="translated">事件分为3类： &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;internal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e61c510a0f262f537c452aa189ebaa55b2635db" translate="yes" xml:space="preserve">
          <source>There are 3 types of time-out events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">状态机可以使用相应的 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 为其自身生成3种超时事件。</target>
        </trans-unit>
        <trans-unit id="6ff16aed8586d53e007c3bcd2bdd6ec77fd89ba9" translate="yes" xml:space="preserve">
          <source>There are 3 types of time-outs in &lt;code&gt;gen_statem&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 中有3种超时类型：</target>
        </trans-unit>
        <trans-unit id="2631fe7788bb799ec0d53ee0b2da8319a05517e4" translate="yes" xml:space="preserve">
          <source>There are 3 types of timeout events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">状态机可以使用相应的 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 为其自身生成3种超时事件。</target>
        </trans-unit>
        <trans-unit id="32e2588a4d8a20d2c12320bd314f5979f4fc80b1" translate="yes" xml:space="preserve">
          <source>There are 365 days in an ordinary year.</source>
          <target state="translated">普通一年有365天。</target>
        </trans-unit>
        <trans-unit id="d970b2470b79eb6a87c891f0b7f5a8f224ef200c" translate="yes" xml:space="preserve">
          <source>There are 36524 days in a 100 year period.</source>
          <target state="translated">100年内有36524天。</target>
        </trans-unit>
        <trans-unit id="dd3485b6c23bf0750711aa938792fc3cb9795cf2" translate="yes" xml:space="preserve">
          <source>There are 366 days in a leap year.</source>
          <target state="translated">闰年有366天。</target>
        </trans-unit>
        <trans-unit id="e5fe64c83f46614adbd1fbe2801f7f2ef313c16d" translate="yes" xml:space="preserve">
          <source>There are 719528 days between Jan 1, 0 and Jan 1, 1970.</source>
          <target state="translated">0年1月1日到1970年1月1日之间有719528天。</target>
        </trans-unit>
        <trans-unit id="f35333b685e5533111f684a33ff4796d2d156cad" translate="yes" xml:space="preserve">
          <source>There are 86400 seconds in a day.</source>
          <target state="translated">一天有86400秒。</target>
        </trans-unit>
        <trans-unit id="7cc84f53d33e39866ff05a650b846f5a9e42e844" translate="yes" xml:space="preserve">
          <source>There are a bunch of different tradeoffs that come into play when trying to figure out which of the strategies you want to use.</source>
          <target state="translated">在试图找出你想使用哪种策略时,会有一堆不同的权衡。</target>
        </trans-unit>
        <trans-unit id="180512e757bce690ec3e5179e5aff8954ea8a216" translate="yes" xml:space="preserve">
          <source>There are a few other shells available, but in all examples below we assume that you use bash.</source>
          <target state="translated">还有一些其他的shell,但是在下面的所有例子中,我们假设你使用bash。</target>
        </trans-unit>
        <trans-unit id="1edf8f04e2a157900339e6be967c14131457929f" translate="yes" xml:space="preserve">
          <source>There are a number of BIFs for type conversions.</source>
          <target state="translated">类型转换的BIF有很多。</target>
        </trans-unit>
        <trans-unit id="242b6cdf7d5bf2f5010f113ba9575096eca5ab25" translate="yes" xml:space="preserve">
          <source>There are a number of configuration parameter's that control the operation of the transaction sender. In principle, a message with everything stored (ack's and request's) is sent from the process when:</source>
          <target state="translated">有许多配置参数控制事务发送者的操作。原则上,当以下情况发生时,进程会发送一条包含所有存储内容(ACK和请求)的消息:</target>
        </trans-unit>
        <trans-unit id="14ebd1b2612f7ab9a04862c2c58993cbe8294ef0" translate="yes" xml:space="preserve">
          <source>There are also Erlang plugins for other code editors &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt; Atom &lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; and &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">也有用于其他代码编辑器&lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim（vim-erlang）&lt;/a&gt;，&lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt;Atom&lt;/a&gt;，&lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse（ErlIDE）&lt;/a&gt;和&lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA的&lt;/a&gt; Erlang插件。</target>
        </trans-unit>
        <trans-unit id="3ab85aacb25c2dac1de9193bd4c1c96c59434beb" translate="yes" xml:space="preserve">
          <source>There are also buttons to clear the contents of each window.</source>
          <target state="translated">还有一些按钮可以清除每个窗口的内容。</target>
        </trans-unit>
        <trans-unit id="a0e9837f18730715ec49993436d5ae3ed6b58962" translate="yes" xml:space="preserve">
          <source>There are also corresponding trace client types that can read the Erlang trace data format from such files or ports. The &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; function makes use of these Erlang trace clients and redirects the trace data to the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">还有相应的跟踪客户端类型，可以从此类文件或端口读取Erlang跟踪数据格式。该 &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; 功能使得使用这些二郎跟踪客户和重定向跟踪数据的 &lt;code&gt;Collector&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c99ca7c6f5a9145961cb429767668ca00d8aa464" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x&lt;/code&gt; use a dynamic buffer.</source>
          <target state="translated">也有使用动态缓冲区的编码功能。使用它们来编码数据通常更方便。所有的编码功能都有两个版本。以 &lt;code&gt;ei_x&lt;/code&gt; 开头的用户使用动态缓冲区。</target>
        </trans-unit>
        <trans-unit id="f9d5093112a2fcba39a0f2eed1157356fdbc134d" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x_&lt;/code&gt; use a dynamic buffer of type &lt;code&gt;&lt;a href=&quot;#ei_x_buff&quot;&gt;ei_x_buff&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">也有使用动态缓冲区的编码功能。使用它们来编码数据通常更方便。所有的编码功能都有两个版本。那些开始 &lt;code&gt;ei_x_&lt;/code&gt; 使用类型的动态缓冲器 &lt;code&gt;&lt;a href=&quot;#ei_x_buff&quot;&gt;ei_x_buff&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c973e8a6ad46963c3452623094e6dbd1de252e5" translate="yes" xml:space="preserve">
          <source>There are also existing functions in the API that reads from various sources and calls &lt;code&gt;et_collector:report/2&lt;/code&gt;:</source>
          <target state="translated">API中还存在一些从各种来源读取并调用 &lt;code&gt;et_collector:report/2&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="6b0b6ca2d317b12bcab295cfefa25fba1f494f42" translate="yes" xml:space="preserve">
          <source>There are also several open source tools outside of Erlang/OTP that can be used to help profiling. Some of them are:</source>
          <target state="translated">在Erlang/OTP之外,还有一些开源工具可以用来帮助进行剖析。其中一些工具是:</target>
        </trans-unit>
        <trans-unit id="142cde2c5e7c063e8b6e633dcb4d8f992d4a63a0" translate="yes" xml:space="preserve">
          <source>There are also some tools that can be used to get a view of the whole system with more or less overhead.</source>
          <target state="translated">还有一些工具可以用来获取整个系统的视图,开销或多或少。</target>
        </trans-unit>
        <trans-unit id="d345e5c9462888e4d0e72da3171fd099f28666f6" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt; 模块中，还有一些有用的函数可用于SNMP消息的编码和解码。</target>
        </trans-unit>
        <trans-unit id="d2c12c548107750b36f7254260f1588ab2784f00" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;snmp_pdus&lt;/code&gt; 模块中，还有一些有用的函数可用于SNMP消息的编码和解码。</target>
        </trans-unit>
        <trans-unit id="fc4b5b08a6ea2fb2b0f10fe9a664d0767cb557d8" translate="yes" xml:space="preserve">
          <source>There are also two optional functions that may be exported:</source>
          <target state="translated">还有两个可选函数可以导出。</target>
        </trans-unit>
        <trans-unit id="02924d8e6964e4587d120c6a611e73172eec6d8f" translate="yes" xml:space="preserve">
          <source>There are also unary set operators:</source>
          <target state="translated">还有单利集运算符。</target>
        </trans-unit>
        <trans-unit id="3acf11feebdd585e34d9bb7c8762ccd18c3ff0dc" translate="yes" xml:space="preserve">
          <source>There are any number of &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; differing by their &lt;code&gt;Name&lt;/code&gt;. They have no automatic cancelling.</source>
          <target state="translated">有许多 &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; ，其 &lt;code&gt;Name&lt;/code&gt; 不同。他们没有自动取消。</target>
        </trans-unit>
        <trans-unit id="18a4256a63577ca8fbaba2b8f665cf1ca462e6b4" translate="yes" xml:space="preserve">
          <source>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</source>
          <target state="translated">使用多个表复制的原因基本上有两个:容错和速度。请注意,表复制为这两个系统要求提供了一个解决方案。</target>
        </trans-unit>
        <trans-unit id="efcb011fbe2418732f8e84878ff0611edcbe6375" translate="yes" xml:space="preserve">
          <source>There are basically two ways to avoid copying a binary that is sent to a driver:</source>
          <target state="translated">基本上有两种方法可以避免复制发送到驱动程序的二进制。</target>
        </trans-unit>
        <trans-unit id="3f19d4715aab222132c414bca72739542361f550" translate="yes" xml:space="preserve">
          <source>There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. If the amount of data surpasses those limits, a key update is triggered and a new set of keys are installed. See also the option &lt;code&gt;key_update_at&lt;/code&gt;.</source>
          <target state="translated">可以在给定的密钥集下安全加密的明文数量有加密限制。如果数据量超过这些限制，则会触发密钥更新并安装新的密钥集。另请参阅选项 &lt;code&gt;key_update_at&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34bb0f988efea166c1a1ee7437789e3a88d3fdd7" translate="yes" xml:space="preserve">
          <source>There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. The current default ensures that data integrity will not be breached with probability greater than 1/2^57. For more information see &lt;code&gt;&lt;a href=&quot;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&quot;&gt;Limits on Authenticated Encryption Use in TLS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以在给定的密钥集下安全加密的明文数量有加密限制。当前默认值确保不会以大于1/2 ^ 57的概率破坏数据完整性。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&quot;&gt;Limits on Authenticated Encryption Use in TLS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="427d1b12162110ab82e9ecb95a1e779c90521928" translate="yes" xml:space="preserve">
          <source>There are different ways to run the mstone1 tool, e.g. with or without the use of drivers, with &lt;strong&gt;only&lt;/strong&gt; flex-empowered configs.</source>
          <target state="translated">有多种方法可以运行mstone1工具，例如，使用或不使用驱动程序，&lt;strong&gt;仅使用&lt;/strong&gt; flex-empowered配置。</target>
        </trans-unit>
        <trans-unit id="d082ef660d4f3ab42a161139d41ebc8c9796aa24" translate="yes" xml:space="preserve">
          <source>There are different ways to traverse through the objects of a table.</source>
          <target state="translated">有不同的方法来遍历一个表的对象。</target>
        </trans-unit>
        <trans-unit id="fb3a2985df3c8dbb9f72f40ce1f7662ef09722ea" translate="yes" xml:space="preserve">
          <source>There are directives to classify specific instructions depending on how frequently used they are:</source>
          <target state="translated">根据具体指令的使用频率,有指令对其进行分类。</target>
        </trans-unit>
        <trans-unit id="83886161e156439b88f864a15f0682e914bef032" translate="yes" xml:space="preserve">
          <source>There are errors in the module.</source>
          <target state="translated">模块中存在错误。</target>
        </trans-unit>
        <trans-unit id="9f2059c62b05489c060b2ff7738b1e0f09fb659b" translate="yes" xml:space="preserve">
          <source>There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern, as described in the previous section.)</source>
          <target state="translated">有五个捕获子串,但只有一个在匹配后被设置。解决这个问题的另一种方法是使用 &quot;分支重置 &quot;子模式,如上一节所述)。</target>
        </trans-unit>
        <trans-unit id="33595bb67b93a0d4d29156619db2bde17172f1a9" translate="yes" xml:space="preserve">
          <source>There are five kinds of atomic literals, which are represented in the same way in patterns, expressions, and guards:</source>
          <target state="translated">原子识字有五种,它们在模式、表达式和卫士中的表现方式是一样的。</target>
        </trans-unit>
        <trans-unit id="51d0a41716062d2a82d15d8d350dc23a6b9ec6b3" translate="yes" xml:space="preserve">
          <source>There are five lists exchanged in the connection setup. Three of them are also divided in two directions, to and from the server.</source>
          <target state="translated">连接设置中共有五个列表交换。其中有三个也是分两个方向,到服务器和从服务器。</target>
        </trans-unit>
        <trans-unit id="cf8e92c428bfd92f9fbf9d5334e7e6eb53e744e5" translate="yes" xml:space="preserve">
          <source>There are five other standard MIBs, which also may be loaded into the agent. These MIBs are:</source>
          <target state="translated">还有五个标准的MIB,也可以加载到代理中。这些MIBs是:</target>
        </trans-unit>
        <trans-unit id="152329e6587feacf4160245f8023f9e4b43d1b9a" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the &lt;code&gt;Application dependencies&lt;/code&gt; page. If the application is used by other applications, these are listed under &lt;code&gt;Used by&lt;/code&gt;. If the application requires other applications be started before it can be started, these are listed under &lt;code&gt;Required&lt;/code&gt;. These applications are listed in the &lt;code&gt;applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application includes other applications, these are listed under &lt;code&gt;Included&lt;/code&gt;. These applications are listed in the &lt;code&gt;included_applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application uses other applications, these are listed under &lt;code&gt;Uses&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Application dependencies&lt;/code&gt; 页面上有四类应用程序。如果该应用程序被其他应用程序使用，则这些应用程序将在&amp;ldquo; &lt;code&gt;Used by&lt;/code&gt; 。如果该应用程序需要先启动其他应用程序，然后才能启动，则这些应用程序将在&amp;ldquo; &lt;code&gt;Required&lt;/code&gt; 。这些应用程序在 &lt;code&gt;applications&lt;/code&gt; &lt;code&gt;app&lt;/code&gt; 文件的应用程序部分中列出。如果该应用程序包括其他应用程序，则这些应用程序将在 &lt;code&gt;Included&lt;/code&gt; 下列出。这些应用程序在 &lt;code&gt;app&lt;/code&gt; 文件的 &lt;code&gt;included_applications&lt;/code&gt; 部分中列出。如果该应用程序使用其他应用程序，则这些应用程序将在&amp;ldquo; &lt;code&gt;Uses&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d82c54f7bd20fbaa9331c2a4418fb92d7a4c19" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the applications page. &lt;code&gt;Included&lt;/code&gt; contains applications that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains applications that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains applications that either are used directly by explicitly included applications or by other derived applications. &lt;code&gt;Available&lt;/code&gt; contains the remaining applications.</source>
          <target state="translated">应用程序页面上有四类应用程序。 &lt;code&gt;Included&lt;/code&gt; 包含显式包含的应用程序。 &lt;code&gt;Excluded&lt;/code&gt; 包含明确排除的应用程序。 &lt;code&gt;Derived&lt;/code&gt; 包含直接由显式包含的应用程序或其他派生应用程序直接使用的应用程序。 &lt;code&gt;Available&lt;/code&gt; 包含剩余的应用程序。</target>
        </trans-unit>
        <trans-unit id="b68efc29dbc075cb27e8313dd48ca56abcbcbd47" translate="yes" xml:space="preserve">
          <source>There are four categories of modules on the modules page. &lt;code&gt;Included&lt;/code&gt; contains modules that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains modules that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains modules that either are used directly by explicitly included modules or by other derived modules. &lt;code&gt;Available&lt;/code&gt; contains the remaining modules.</source>
          <target state="translated">&amp;ldquo;模块&amp;rdquo;页面上有四类模块。 &lt;code&gt;Included&lt;/code&gt; 包含明确包含的模块。 &lt;code&gt;Excluded&lt;/code&gt; 包含明确排除的模块。 &lt;code&gt;Derived&lt;/code&gt; 包含的模块可以由显式包含的模块直接使用，也可以由其他派生模块直接使用。 &lt;code&gt;Available&lt;/code&gt; 包含剩余的模块。</target>
        </trans-unit>
        <trans-unit id="c2b0337aead7f70c27290d4535794d260d389da6" translate="yes" xml:space="preserve">
          <source>There are four different encodings present during the handling of URIs:</source>
          <target state="translated">在处理URI的过程中,有四种不同的编码存在。</target>
        </trans-unit>
        <trans-unit id="413ab333b189c985048445074e9603bae2ba9723" translate="yes" xml:space="preserve">
          <source>There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions.</source>
          <target state="translated">有四种条件:对子模式的引用,对递归的引用,一种叫做DEFINE的伪条件,以及断言。</target>
        </trans-unit>
        <trans-unit id="0e3cede13e2f3ea6f18d8aafca7fbdcb89de6d8f" translate="yes" xml:space="preserve">
          <source>There are four rounds of waiting for thread progress in the above sequence. In the code loading sequence we sacrificed memory overhead of three generations to avoid a second round of thread progress. The latency of &lt;code&gt;trace_pattern&lt;/code&gt; should not be such a big problem for however, as it is normally not called in a rapid sequence.</source>
          <target state="translated">按照上述顺序，有四轮等待线程进度。在代码加载序列中，我们牺牲了三代的内存开销，以避免第二轮线程进度。但是， &lt;code&gt;trace_pattern&lt;/code&gt; 的等待时间应该不是一个大问题，因为通常不会快速调用它。</target>
        </trans-unit>
        <trans-unit id="ff7d1dc7b48a9dea55fd34247a8586111ade0080" translate="yes" xml:space="preserve">
          <source>There are from OTP-23.0 two main ways to set an option:</source>
          <target state="translated">从OTP-23.0开始,有两种主要的方式来设置一个选项。</target>
        </trans-unit>
        <trans-unit id="afecc58bc3779a5734aaac232e18d7916a22144d" translate="yes" xml:space="preserve">
          <source>There are function clauses, if clauses, case clauses, and catch clauses.</source>
          <target state="translated">有功能子句、if子句、大小写子句和捕捉子句。</target>
        </trans-unit>
        <trans-unit id="72251a5ed304e5df93ccf96c6a4cfa369e458578" translate="yes" xml:space="preserve">
          <source>There are however attacks that are not detected by those checks. Suppose a bad guy has succeded with a DNS infection. Then the client could belive it is connecting to one host but ends up at another but evil one. Though it is evil, it could have a perfectly legal certificate! The certificate has a valid signature, it is not revoked, the certificate chain is not faked and has a trusted root and so on.</source>
          <target state="translated">然而,也有一些攻击是这些检查所检测不到的。假设一个坏人成功地感染了DNS。那么客户端可能会相信它正在连接到一个主机,但最终在另一个邪恶的主机。虽然它是邪恶的,但它可能有一个完全合法的证书! 证书有一个有效的签名,它没有被撤销,证书链没有伪造,有一个可信的根等等。</target>
        </trans-unit>
        <trans-unit id="3713f84d148979b203b3befe641b4b77769eb559" translate="yes" xml:space="preserve">
          <source>There are limitations to when you can execute time warp unsafe code using this mode. If it is possible to use time warp safe code only, it is &lt;strong&gt;much&lt;/strong&gt; better to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">使用此模式可以执行时间扭曲不安全代码的时间有所限制。如果能够只使用时间隧道安全的代码，它是&lt;strong&gt;多少&lt;/strong&gt;，最好使用 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 来代替。</target>
        </trans-unit>
        <trans-unit id="cd4bd83b271a665a5b58936e70ef38dadf1155ad" translate="yes" xml:space="preserve">
          <source>There are limitations with this transaction mechanism. If complex dependencies exist between variables, for example between &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;day&lt;/code&gt;, another mechanism is needed. Setting the date to 'Feb 31' can be avoided by a somewhat more generic transaction mechanism. You can continue and find more and more complex situations and construct an N-phase set-mechanism. This toolkit only contains a trivial mechanism.</source>
          <target state="translated">这种交易机制有局限性。如果变量之间存在复杂的依赖关系，例如在 &lt;code&gt;month&lt;/code&gt; 和 &lt;code&gt;day&lt;/code&gt; 之间，则需要另一种机制。通过某种更通用的交易机制可以避免将日期设置为&amp;ldquo; 2月31日&amp;rdquo;。您可以继续查找越来越复杂的情况，并构建N相设定机制。该工具包仅包含一个简单的机制。</target>
        </trans-unit>
        <trans-unit id="439879eaa90ceaba58052efe3928a2c96e71eaa0" translate="yes" xml:space="preserve">
          <source>There are many different ways of writing back references to named subpatterns. The .NET syntax &lt;code&gt;\k{name}&lt;/code&gt; and the Perl syntax &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt; are supported, as is the Python syntax &lt;code&gt;(?P=name)&lt;/code&gt;. The unified back reference syntax in Perl 5.10, in which \g can be used for both numeric and named references, is also supported. The previous example can be rewritten in the following ways:</source>
          <target state="translated">有许多种写回对命名子模式的引用的方法。支持.NET语法 &lt;code&gt;\k{name}&lt;/code&gt; 和Perl语法 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'name'&lt;/code&gt; 也支持Python语法 &lt;code&gt;(?P=name)&lt;/code&gt; 。还支持Perl 5.10中的统一反向引用语法，其中\ g可以用于数字引用和命名引用。可以通过以下方式重写前面的示例：</target>
        </trans-unit>
        <trans-unit id="ed05625b139b4d644de6d7f67ce1fa7c2638ef57" translate="yes" xml:space="preserve">
          <source>There are many kinds of test suites. Some concentrate on calling every function or command (in the documented way) in a certain interface. Some others do the same, but use all kinds of illegal parameters, and verify that the server stays alive and rejects the requests with reasonable error codes. Some test suites simulate an application (typically consisting of a few modules of an application), some try to do tricky requests in general, and some test suites even test internal functions with help of special Load Modules on target.</source>
          <target state="translated">测试套件有很多种类。有些集中在调用某个接口中的每一个函数或命令(以记录的方式)。其他一些测试套件也是这样做的,但是使用了各种非法参数,并验证服务器是否还活着,用合理的错误代码拒绝请求。一些测试套件模拟一个应用程序(通常由应用程序的几个模块组成),一些测试套件尝试做一些棘手的请求,一些测试套件甚至借助目标上的特殊负载模块来测试内部功能。</target>
        </trans-unit>
        <trans-unit id="7c87c0f774843afd2689dfb3a9a1edad461eb107" translate="yes" xml:space="preserve">
          <source>There are many other BIFs such as &lt;code&gt;trunc&lt;/code&gt;. Only a few BIFs can be used in guards, and you cannot use functions you have defined yourself in guards. (see &lt;code&gt;Guard Sequences&lt;/code&gt;) (For advanced readers: This is to ensure that guards do not have side effects.) Let us play with a few of these functions in the shell:</source>
          <target state="translated">还有许多其他BIF，例如 &lt;code&gt;trunc&lt;/code&gt; 。保护中只能使用几个BIF，并且不能使用在保护中定义了自己的功能。（请参阅 &lt;code&gt;Guard Sequences&lt;/code&gt; ）（对于高级读者：这是为了确保Guard不会产生副作用。）让我们在Shell中使用其中一些功能：</target>
        </trans-unit>
        <trans-unit id="7ad50dd0c2f864512dffbc3444e8c2dbdeaa7fbe" translate="yes" xml:space="preserve">
          <source>There are many very useful functions in the &lt;code&gt;lists&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;lists&lt;/code&gt; 模块中有许多非常有用的功能。</target>
        </trans-unit>
        <trans-unit id="ebf4e0ad405ef3fed32697182bdabfe322f69cbb" translate="yes" xml:space="preserve">
          <source>There are more efficient ways to create tables manually, i.e. to use the module &lt;code&gt;snmp_index&lt;/code&gt;.</source>
          <target state="translated">有许多手动创建表的有效方法，即使用模块 &lt;code&gt;snmp_index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e356f188420ccd305fbbe430543827bbca4a813" translate="yes" xml:space="preserve">
          <source>There are more specific &lt;strong&gt;transition actions&lt;/strong&gt; that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt; return value &lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible &lt;strong&gt;transition actions&lt;/strong&gt;:</source>
          <target state="translated">回调函数返回后，回调函数可以命令 &lt;code&gt;gen_statem&lt;/code&gt; 引擎执行更具体的&lt;strong&gt;过渡动作&lt;/strong&gt;。这些都是通过返回的列表指挥 &lt;code&gt;actions&lt;/code&gt; 的 &lt;code&gt; return value &lt;/code&gt; 从 &lt;code&gt;callback function&lt;/code&gt; 。这些是可能的&lt;strong&gt;过渡操作&lt;/strong&gt;：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd92c71af502e8043671a8043ed8709a47495a40" translate="yes" xml:space="preserve">
          <source>There are more specific state-transition actions that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt;return value&lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible state transition actions:</source>
          <target state="translated">在回调函数返回之后，回调函数可以命令 &lt;code&gt;gen_statem&lt;/code&gt; 引擎执行更具体的状态转换操作。这些都是通过返回的列表指挥 &lt;code&gt;actions&lt;/code&gt; 的 &lt;code&gt;return value&lt;/code&gt; 从 &lt;code&gt;callback function&lt;/code&gt; 。这些是可能的状态转换操作：</target>
        </trans-unit>
        <trans-unit id="b36a2cfd042d4aa3ef25491b61074f01870dd914" translate="yes" xml:space="preserve">
          <source>There are no errors in the module.</source>
          <target state="translated">该模块没有错误。</target>
        </trans-unit>
        <trans-unit id="cf5c5dc136c77b62a5f73ee583f29675f0867a0a" translate="yes" xml:space="preserve">
          <source>There are no good and explicit ways to declare dependencies, so it can be difficult to see and understand these in test suite code and in test logs.</source>
          <target state="translated">没有很好的和明确的方法来声明依赖关系,所以在测试套件代码和测试日志中很难看到和理解这些。</target>
        </trans-unit>
        <trans-unit id="ccfb4d80adcf6550acd24e6e86b074a68a3505fb" translate="yes" xml:space="preserve">
          <source>There are no guarantees exactly when the destructor of an unreferenced resource is called. It could be called directly by &lt;code&gt;enif_release_resource&lt;/code&gt; but it could also be scheduled to be called at a later time possibly by another thread.</source>
          <target state="translated">不能完全保证何时调用未引用资源的析构函数。可以由 &lt;code&gt;enif_release_resource&lt;/code&gt; 直接调用它，但也可以安排在以后的某个时间（可能由另一个线程）调用它。</target>
        </trans-unit>
        <trans-unit id="79dc22722039d0f06f11ce0ecbb4a728b9b8c1f7" translate="yes" xml:space="preserve">
          <source>There are no restrictions on the number of bits in the tail.</source>
          <target state="translated">对尾部的位数没有限制。</target>
        </trans-unit>
        <trans-unit id="5da19bcdc35b1de403b2d378cd184c875b0de577" translate="yes" xml:space="preserve">
          <source>There are no special option values (like zero) to clear an option. Some of the options have a unspecified minimum value. Lower values will be adjusted to the minimum value. For example, it is currently not possible to monitor all garbage collections with &lt;code&gt;{long_gc, 0}&lt;/code&gt;.</source>
          <target state="translated">没有用于清除选项的特殊选项值（例如零）。一些选项具有未指定的最小值。较低的值将被调整为最小值。例如，当前无法使用 &lt;code&gt;{long_gc, 0}&lt;/code&gt; 监视所有垃圾回收。</target>
        </trans-unit>
        <trans-unit id="9e0f9557377e4510903384f151fd0ecbad27b195" translate="yes" xml:space="preserve">
          <source>There are obvious dependencies between the listed functions. The server cannot be configured if it has not first been started, a client connot be connectd until the server is properly configured, and so on. If we want to have one test case for each function, we might be tempted to try to always run the test cases in the stated order and carry possible data (identities, handles, and so on) between the cases and therefore introduce dependencies between them.</source>
          <target state="translated">所列功能之间存在明显的依赖关系。如果服务器没有首先被启动,就无法配置,客户端在服务器被正确配置之前不能被连接,等等。如果我们希望每个函数都有一个测试用例,我们可能会尝试总是按照规定的顺序运行测试用例,并在用例之间携带可能的数据(身份、句柄等),因此在它们之间引入依赖关系。</target>
        </trans-unit>
        <trans-unit id="8523e884f51973cbccd87b9cb2dffcddaeb778e9" translate="yes" xml:space="preserve">
          <source>There are often sufficient means to work around the need for test case dependencies. Generally, the problem is related to the state of the System Under Test (SUT). The action of one test case can change the system state. For some other test case to run properly, this new state must be known.</source>
          <target state="translated">通常有足够的手段来解决测试用例依赖性的需求。一般来说,这个问题与被测系统(SUT)的状态有关。一个测试用例的动作可以改变系统状态。为了使其他一些测试用例能够正常运行,必须知道这个新的状态。</target>
        </trans-unit>
        <trans-unit id="e108f06d2e6b2fe834e0d25027b8927df7aa555e" translate="yes" xml:space="preserve">
          <source>There are other types of runtime systems that can be built as well using the similar steps just described.</source>
          <target state="translated">还有其他类型的运行时系统也可以使用刚才描述的类似步骤来构建。</target>
        </trans-unit>
        <trans-unit id="e163c970efe377af5c8f879ce7a54392863fd666" translate="yes" xml:space="preserve">
          <source>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</source>
          <target state="translated">有几种算法可以将碎片表中的记录均匀地分布在一个节点池上。没有一种是最好的,这取决于应用需求。下面的情况例子需要注意一些。</target>
        </trans-unit>
        <trans-unit id="ba499c73dc1ea2d5a2d0497363ce986917b4ed09" translate="yes" xml:space="preserve">
          <source>There are several constraints available for testing whether a call is to a BIF or a function.</source>
          <target state="translated">有几个约束条件可用于测试一个调用是指向BIF还是函数。</target>
        </trans-unit>
        <trans-unit id="3da498f3aa13476c3eb92930717e01466d88d04f" translate="yes" xml:space="preserve">
          <source>There are several error cases which may prevent an answer from being received and passed to a &lt;code&gt;handle_answer/4&lt;/code&gt; callback:</source>
          <target state="translated">有几种错误情况可能会阻止接收答案并将其传递到 &lt;code&gt;handle_answer/4&lt;/code&gt; 回调：</target>
        </trans-unit>
        <trans-unit id="d5e18c76899cc79f203e980d3f385f0b37cfdefe" translate="yes" xml:space="preserve">
          <source>There are several implementations provided with the agent: &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt;, &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; and &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt;.</source>
          <target state="translated">代理提供了几种实现： &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt; ， &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; 和 &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3ff816ccd8ec855be66bcf7ca689d7727faafd3" translate="yes" xml:space="preserve">
          <source>There are several occasions when &lt;code&gt;Mnesia&lt;/code&gt; can detect that the network has been partitioned because of a communication failure, for example:</source>
          <target state="translated">在多种情况下， &lt;code&gt;Mnesia&lt;/code&gt; 可以检测到由于通信故障而导致网络已分区，例如：</target>
        </trans-unit>
        <trans-unit id="7c57bfac8bb05da0f5a10e7726d24981a1293333" translate="yes" xml:space="preserve">
          <source>There are several other process flags, see &lt;code&gt;erlang(3)&lt;/code&gt;. Changing the default behaviour of a process in this way is usually not done in standard user programs, but is left to the supervisory programs in OTP. However, the ping pong program is modified to illustrate exit trapping.</source>
          <target state="translated">还有其他几个进程标志，请参见 &lt;code&gt;erlang(3)&lt;/code&gt; 。以这种方式更改过程的默认行为通常不在标准用户程序中完成，而是留给OTP中的监视程序。但是，对乒乓程序进行了修改以说明出口陷阱。</target>
        </trans-unit>
        <trans-unit id="8ff05058f0f15f23c288c9626be84922c9b765fc" translate="yes" xml:space="preserve">
          <source>There are several pre-made filter rule(s) and one general:</source>
          <target state="translated">有几个预制的过滤规则和一个通用的。</target>
        </trans-unit>
        <trans-unit id="4e75da42e192bf5430b68298e12cdc636289e3c2" translate="yes" xml:space="preserve">
          <source>There are several ways to send a binary created with &lt;code&gt;driver_alloc_binary()&lt;/code&gt;:</source>
          <target state="translated">有多种方法可以发送使用 &lt;code&gt;driver_alloc_binary()&lt;/code&gt; 创建的二进制文件：</target>
        </trans-unit>
        <trans-unit id="75f05fa20e3e2427a955f3a2446bd3c23ed22b34" translate="yes" xml:space="preserve">
          <source>There are several ways to write a metavariable in your quoted code:</source>
          <target state="translated">有几种方法可以在你引用的代码中写一个元变量。</target>
        </trans-unit>
        <trans-unit id="f82aa827e8118fb053e3d4c4658ad116b8c399af" translate="yes" xml:space="preserve">
          <source>There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows:</source>
          <target state="translated">Windows注册表中有六个入口点,即顶层键。在本模块中,它们的缩写如下:</target>
        </trans-unit>
        <trans-unit id="70680607de60b05f98568bdca23a84c98a7353e4" translate="yes" xml:space="preserve">
          <source>There are some new data types in SNMPv2 that are useful in SNMPv1 as well. In the STANDARD-MIB, three data types are defined, &lt;code&gt;RowStatus&lt;/code&gt;, &lt;code&gt;TruthValue&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. These data types are originally defined as textual conventions in SNMPv2-TC (RFC1903).</source>
          <target state="translated">SNMPv2中有一些新数据类型在SNMPv1中也很有用。在STANDARD-MIB中，定义了三种数据类型： &lt;code&gt;RowStatus&lt;/code&gt; ， &lt;code&gt;TruthValue&lt;/code&gt; 和 &lt;code&gt;DateAndTime&lt;/code&gt; 。这些数据类型最初在SNMPv2-TC（RFC1903）中定义为文本约定。</target>
        </trans-unit>
        <trans-unit id="0e7ae6c930ff553042b2aaa2a5bab43d6e99da70" translate="yes" xml:space="preserve">
          <source>There are still a few percent-encoded triplets left in the output. At this point, when the URI is already parsed, it is safe to apply application specific decoding on the remaining character triplets. Erlang/OTP provides a function, &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; for raw percent decoding that you can use on the host and path components, or on the whole map:</source>
          <target state="translated">在输出中还剩下几个百分比编码的三元组。此时，当已经解析URI时，可以在其余字符三元组上应用特定于应用程序的解码是安全的。Erlang / OTP提供了 &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; 函数，用于原始百分比解码，可以在主机和路径组件或整个地图上使用：</target>
        </trans-unit>
        <trans-unit id="6d7f436b6808fb57326aab28c43cc3d495d3886b" translate="yes" xml:space="preserve">
          <source>There are three built-in trace patterns: &lt;code&gt;exception_trace&lt;/code&gt;, &lt;code&gt;caller_trace&lt;/code&gt; and &lt;code&gt;caller_exception_trace&lt;/code&gt; (or &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;cx&lt;/code&gt; respectively). Exception trace sets a trace which will show function names, parameters, return values and exceptions thrown from functions. Caller traces display function names, parameters and information about which function called it. An example using a built-in alias:</source>
          <target state="translated">共有三种内置跟踪模式： &lt;code&gt;exception_trace&lt;/code&gt; ， &lt;code&gt;caller_trace&lt;/code&gt; 和 &lt;code&gt;caller_exception_trace&lt;/code&gt; （或分别为 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;cx&lt;/code&gt; ）。异常跟踪设置一个跟踪，该跟踪将显示函数名称，参数，返回值和从函数引发的异常。调用者跟踪显示函数名称，参数以及有关哪个函数调用它的信息。使用内置别名的示例：</target>
        </trans-unit>
        <trans-unit id="ce6e977a031f0f78d9783247027132e2871000ad" translate="yes" xml:space="preserve">
          <source>There are three entities: department, employee, and project.</source>
          <target state="translated">有三个实体:部门、员工、项目。</target>
        </trans-unit>
        <trans-unit id="b95942457dca44926353518936009aaa1a127415" translate="yes" xml:space="preserve">
          <source>There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; is subpattern index 1, &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; is subpattern index 2, and &lt;code&gt;(..d)&lt;/code&gt; is subpattern index 3. When matched against the following string:</source>
          <target state="translated">共有三个明确捕获的子模式，其中括号的位置确定结果的顺序，因此 &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; 是子模式索引1， &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; 是子模式索引2，而 &lt;code&gt;(..d)&lt;/code&gt; 是子模式索引3。与以下字符串匹配时：</target>
        </trans-unit>
        <trans-unit id="b9d8071a7cab5fe6bb06cfbf16feb00bf5b9bf05" translate="yes" xml:space="preserve">
          <source>There are three kinds of configuration:</source>
          <target state="translated">有三种配置。</target>
        </trans-unit>
        <trans-unit id="6f596c95045c35d0f6872618b7a800aff23b78f1" translate="yes" xml:space="preserve">
          <source>There are three main reasons for using this mapping:</source>
          <target state="translated">使用这种图谱的原因主要有三个。</target>
        </trans-unit>
        <trans-unit id="21dcf13609dda19f86b7a0c362b1f37accd05aea" translate="yes" xml:space="preserve">
          <source>There are three relationships between these entities:</source>
          <target state="translated">这些实体之间有三种关系。</target>
        </trans-unit>
        <trans-unit id="a6f8a9d2ff844ea14957c3bca79e832dabec9620" translate="yes" xml:space="preserve">
          <source>There are to be no circular dependencies among the applications.</source>
          <target state="translated">各个应用程序之间不存在循环依赖关系。</target>
        </trans-unit>
        <trans-unit id="a76c3a9ace292c2e0f4031bfd80c3c9f908baded" translate="yes" xml:space="preserve">
          <source>There are to be no duplicated modules, that is, modules with the same name but belonging to different applications.</source>
          <target state="translated">不得有重复的模块,即名称相同但属于不同应用的模块。</target>
        </trans-unit>
        <trans-unit id="b018774fca4517707ee8766e662ecc9fb5f61fbf" translate="yes" xml:space="preserve">
          <source>There are to be no undefined applications, that is, dependencies to applications that are not included in the release. (Key &lt;code&gt;applications&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file).</source>
          <target state="translated">不得有未定义的应用程序，也就是说，对发行版中未包含的应用程序的依赖性。（ &lt;code&gt;.app&lt;/code&gt; 文件中的关键 &lt;code&gt;applications&lt;/code&gt; 程序）。</target>
        </trans-unit>
        <trans-unit id="8657af51c1708a2f767083749fec728b2f15dd21" translate="yes" xml:space="preserve">
          <source>There are two Elisp modules included in this tool package for Emacs. There is erlang.el that defines the actual erlang mode and there is erlang-start.el that makes some nice initializations.</source>
          <target state="translated">这个Emacs的工具包中包含了两个Elisp模块,其中有一个是erlang.el,它定义了实际的erlang模式,还有一个是erlang-start.el,它做了一些不错的初始化。其中erlang.el定义了实际的erlang模式,还有erlang-start.el做了一些漂亮的初始化。</target>
        </trans-unit>
        <trans-unit id="4650ca14e027a543e950b128c780c1aff1d2ced2" translate="yes" xml:space="preserve">
          <source>There are two alternatives for &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 有两种选择：</target>
        </trans-unit>
        <trans-unit id="e8bf9361085b975630319d83556ce12329f9229c" translate="yes" xml:space="preserve">
          <source>There are two basic ways to use the binary encodings: With package related name and termination id transformation (the 'native' encoding config) or without. This transformation converts package related names and termination id's to a more convenient internal form (equivalent with the decoded text message).</source>
          <target state="translated">有两种基本的方式来使用二进制编码。使用与包相关的名称和终止ID转换(&quot;原生 &quot;编码配置)或不使用。这种转换将包相关名称和终止ID转换为更方便的内部形式(相当于解码后的文本消息)。</target>
        </trans-unit>
        <trans-unit id="dd1db3d75a354d15737e7ae7563e82290092028f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Dependencies&lt;/code&gt; 页面上有两类模块。如果该模块被其他模块使用，则这些 &lt;code&gt;Modules using this&lt;/code&gt; 将在&amp;ldquo; 使用此模块&amp;rdquo;下列出。如果模块使用其他模块，则这些模块将在&amp;ldquo; &lt;code&gt;Used modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887d7e8bf421025bcb8d521eeed1d2552d08027f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Module dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Module dependencies&lt;/code&gt; 页面上有两类模块。如果该模块被其他模块使用，则这些 &lt;code&gt;Modules using this&lt;/code&gt; 将在&amp;ldquo; 使用此模块&amp;rdquo;下列出。如果模块使用其他模块，则这些模块将在&amp;ldquo; &lt;code&gt;Used modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e74dd0da2a3747be954c0f8457f4880fc1f5333a" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt; Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">与仅使用普通端口的 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt; Ports&lt;/a&gt;&lt;/code&gt; 中的示例相比，在C端使用Erl_Interface有两个区别：</target>
        </trans-unit>
        <trans-unit id="599878b5a82e164996281429b80e489ea9c477d5" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">与仅使用普通端口的 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 中的示例相比，在C端使用Erl_Interface有两个区别：</target>
        </trans-unit>
        <trans-unit id="23c004d4c8512a14978a320110e39b1a0ff94575" translate="yes" xml:space="preserve">
          <source>There are two different measurement tools:</source>
          <target state="translated">有两种不同的测量工具。</target>
        </trans-unit>
        <trans-unit id="a94aa96b73c7ee440863f41a5aef58bc994511af" translate="yes" xml:space="preserve">
          <source>There are two implementations available:</source>
          <target state="translated">有两种实现方式。</target>
        </trans-unit>
        <trans-unit id="6b217d8aaa3bcdc7db2e259b15d48c394ea4df29" translate="yes" xml:space="preserve">
          <source>There are two kinds of variables: predefined variables and user variables.  &lt;strong id=&quot;predefined_variable&quot;&gt;Predefined variables&lt;/strong&gt; hold set up module data, and cannot be assigned to but only used in queries.  &lt;strong id=&quot;user_variable&quot;&gt;User variables&lt;/strong&gt; on the other hand can be assigned to, and are typically used for temporary results while evaluating a query, and for keeping results of queries for use in subsequent queries. The predefined variables are (variables marked with (*) are available in &lt;code&gt;functions&lt;/code&gt; mode only):</source>
          <target state="translated">变量有两种：预定义变量和用户变量。 &lt;strong id=&quot;predefined_variable&quot;&gt;预定义变量&lt;/strong&gt;保存设置的模块数据，不能分配给&lt;strong id=&quot;predefined_variable&quot;&gt;变量&lt;/strong&gt;，而只能在查询中使用。 另一方面，&lt;strong id=&quot;user_variable&quot;&gt;用户变量&lt;/strong&gt;可以分配给&lt;strong id=&quot;user_variable&quot;&gt;用户变量&lt;/strong&gt;，通常用于评估查询时的临时结果，并保留查询结果以用于后续查询。预定义的变量为（标有（*）的变量仅在 &lt;code&gt;functions&lt;/code&gt; 模式下可用）：</target>
        </trans-unit>
        <trans-unit id="51e96249f31fef90280598a64efcee667d150bd9" translate="yes" xml:space="preserve">
          <source>There are two known shortcomings in xmerl:</source>
          <target state="translated">xmerl有两个已知的缺点。</target>
        </trans-unit>
        <trans-unit id="99e9898726a4d1ec0a543937d2f79fae5062fc44" translate="yes" xml:space="preserve">
          <source>There are two occasions when the young heap grows:</source>
          <target state="translated">幼堆的成长有两个场合。</target>
        </trans-unit>
        <trans-unit id="e9f480805fea8601c547a9eb29f50f8f9cd8ca43" translate="yes" xml:space="preserve">
          <source>There are two occasions when the young heap is shrunk:</source>
          <target state="translated">幼堆缩水有两种情况。</target>
        </trans-unit>
        <trans-unit id="cc0e3ffc28ca1f923c575a2ec112ffd273f7f33c" translate="yes" xml:space="preserve">
          <source>There are two options for handling syntax errors (that is when an unexpected event is received when the digit map evaluator is expecting some other event). The unexpected events may either be ignored or rejected. The latter means that the evaluation is aborted and an error is returned.</source>
          <target state="translated">有两种处理语法错误的方法(即当数字图评估器期待其他事件时收到意外事件时)。意外事件可以被忽略或拒绝。后者意味着评估被中止,并返回一个错误。</target>
        </trans-unit>
        <trans-unit id="e7ea701d75f10ddf239c1c9acff7a8b7f85969f9" translate="yes" xml:space="preserve">
          <source>There are two reasons why &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; are not to be used: they are not efficient, and they prevent the use of key &lt;code&gt;'$end_of_table'&lt;/code&gt;, as this atom is used to indicate the end of the table. If possible, use functions &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; for traversing tables.</source>
          <target state="translated">为何不使用 &lt;code&gt;first/1&lt;/code&gt; 和 &lt;code&gt;next/2&lt;/code&gt; 的原因有两个：它们效率不高，并且由于使用了这个原子来指示表的结尾，因此它们阻止了键 &lt;code&gt;'$end_of_table'&lt;/code&gt; 使用。如果可能，请使用 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt; 函数，并 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 遍历表。</target>
        </trans-unit>
        <trans-unit id="80545dc051cca46852b43329d06d54cf9d266b54" translate="yes" xml:space="preserve">
          <source>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</source>
          <target state="translated">在使用这个函数而不是读取记录、进行运算和书写记录时,有两个显著的区别。</target>
        </trans-unit>
        <trans-unit id="7dad1bd4e1026419dc7de0c5664baefca6532877" translate="yes" xml:space="preserve">
          <source>There are two special cases for the timeout value &lt;code&gt;ExprT&lt;/code&gt;:</source>
          <target state="translated">超时值 &lt;code&gt;ExprT&lt;/code&gt; 有两种特殊情况：</target>
        </trans-unit>
        <trans-unit id="c56d561a526dd7ff6bad858caa6d005781753b5c" translate="yes" xml:space="preserve">
          <source>There are two types of numeric literals, &lt;strong&gt;integers&lt;/strong&gt; and &lt;strong&gt;floats&lt;/strong&gt;. Besides the conventional notation, there are two Erlang-specific notations:</source>
          <target state="translated">数字文字有两种类型，&lt;strong&gt;整数&lt;/strong&gt;和&lt;strong&gt;浮点数&lt;/strong&gt;。除了传统的符号外，还有两种特定于Erlang的符号：</target>
        </trans-unit>
        <trans-unit id="a3c927021e9667cac0b76e4d583b237c1b874a0a" translate="yes" xml:space="preserve">
          <source>There are two types of unique integers both created using the &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF:</source>
          <target state="translated">有两种类型的唯一整数都使用 &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF创建：</target>
        </trans-unit>
        <trans-unit id="adcec4978d9685360563b69cc57cc9c6d0c475d9" translate="yes" xml:space="preserve">
          <source>There are two versions of the &lt;code&gt;server_transfer&lt;/code&gt; function: one with four arguments (&lt;code&gt;server_transfer/4&lt;/code&gt;) and one with five (&lt;code&gt;server_transfer/5&lt;/code&gt;). These are regarded by Erlang as two separate functions.</source>
          <target state="translated">&lt;code&gt;server_transfer&lt;/code&gt; 函数有两个版本：一个带有四个参数（ &lt;code&gt;server_transfer/4&lt;/code&gt; ），另一个带有五个参数（ &lt;code&gt;server_transfer/5&lt;/code&gt; ）。这些被Erlang视为两个独立的功能。</target>
        </trans-unit>
        <trans-unit id="1b723932d3f965d03f997c2929d90177ac53f1a0" translate="yes" xml:space="preserve">
          <source>There are two ways of shutting down an &lt;code&gt;ssh&lt;/code&gt; daemon, see &lt;strong&gt;Step 5a&lt;/strong&gt; and &lt;strong&gt;Step 5b&lt;/strong&gt;.</source>
          <target state="translated">关闭 &lt;code&gt;ssh&lt;/code&gt; 守护程序有两种方法，请参见&lt;strong&gt;步骤5a&lt;/strong&gt;和&lt;strong&gt;步骤5b&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ca0c875bf6657b9c2873d094d99069621f5c3b26" translate="yes" xml:space="preserve">
          <source>There are two ways to define internal generic instructions:</source>
          <target state="translated">有两种方法来定义内部通用指令。</target>
        </trans-unit>
        <trans-unit id="67a5f230cec8e69ad074e79327cb344b91c01c42" translate="yes" xml:space="preserve">
          <source>There are two ways to handle the different megaco encoding versions. Either using &lt;strong&gt;dynamic version detection&lt;/strong&gt; (only valid for for incoming messages) or by &lt;strong&gt;explicit version&lt;/strong&gt; setting in the connection info.</source>
          <target state="translated">有两种方法可以处理不同的megaco编码版本。使用&lt;strong&gt;动态版本检测&lt;/strong&gt;（仅对传入消息有效）或通过连接信息中的&lt;strong&gt;显式版本&lt;/strong&gt;设置。</target>
        </trans-unit>
        <trans-unit id="d9e65fcf80d23dd2690fb225a26bd4c0425947c3" translate="yes" xml:space="preserve">
          <source>There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching.</source>
          <target state="translated">有两种方法可以在PCRE处理的模式中包含注释。在这两种情况下,注释的开始不能在字符类中,也不能在任何其他相关字符序列的中间,如(? 或子模式名称或数字。组成注释的字符在模式匹配中不发挥作用。</target>
        </trans-unit>
        <trans-unit id="d20c200558da5edbf4cd1004014da1b7247909e5" translate="yes" xml:space="preserve">
          <source>There are two ways to set a timeout for the underlying ssh connection:</source>
          <target state="translated">有两种方法可以设置底层ssh连接的超时。</target>
        </trans-unit>
        <trans-unit id="f355209178288a170c04f2c9a20a04655a8e5d7d" translate="yes" xml:space="preserve">
          <source>There are two ways to start a restricted shell session:</source>
          <target state="translated">有两种方法可以启动限制性shell会话。</target>
        </trans-unit>
        <trans-unit id="6b5c659495ea0b68ab11f6dd415042864496550c" translate="yes" xml:space="preserve">
          <source>There are various reasons for using multi-file compilation:</source>
          <target state="translated">使用多文件编译有各种原因。</target>
        </trans-unit>
        <trans-unit id="a4bd267d265d01937064d3e1fb0e66e780b2cf5c" translate="yes" xml:space="preserve">
          <source>There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;:</source>
          <target state="translated">同一子模式可以有多个反向引用。如果一个子模式没有在特定的匹配中使用过,那么对它的任何反向引用总是失败的。例如,以下模式如果开始匹配 &quot;a &quot;而不是 &quot;bc&quot;,则总是失败。</target>
        </trans-unit>
        <trans-unit id="23ffd59215d348fa8988a623fd249aee7018b927" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first parameter has to be an integer() and the last a string().</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过4个,所以第一个参数必须是整数(),最后一个参数必须是字符串()。</target>
        </trans-unit>
        <trans-unit id="1112d47dc0a89deb75a8a7d00a4b483aae845be6" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first three parameters has to be integer()'s and the last three string()'s.</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过四个,所以前三个参数必须是整数()的,后三个字符串()的。</target>
        </trans-unit>
        <trans-unit id="abdb1ae11dc35da6f7877497944147afcc093ef4" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first two parameters has to be integer()'s and the last two string()'s.</source>
          <target state="translated">任何类型的参数(整数()或字符串())不能超过四个,所以前两个参数必须是整数()的,后两个是字符串()的。</target>
        </trans-unit>
        <trans-unit id="a9363b97aec7cf5ddf082ad0d169c592d9050f71" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary pattern. A binary pattern can occur wherever patterns are allowed, including inside other patterns. Binary patterns cannot be nested. The pattern &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; matches a zero length binary.</source>
          <target state="translated">二进制模式中可以有零个或多个段。二进制模式可以在任何允许的模式下发生，包括在其他模式内部。二进制模式不能嵌套。模式 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 匹配零长度的二进制。</target>
        </trans-unit>
        <trans-unit id="e406e24fdab0c44cf1156b1456ae80afb50bb754" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary to be constructed. The expression &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; constructs a zero length binary.</source>
          <target state="translated">要构造的二进制文件中可以有零个或多个段。表达式 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 构造一个零长度的二进制。</target>
        </trans-unit>
        <trans-unit id="92428ad0a4bfb32617492b37faa92496b8ccd220" translate="yes" xml:space="preserve">
          <source>There exist a number of other &lt;code&gt;spawn&lt;/code&gt; BIFs, for example, &lt;code&gt;spawn/4&lt;/code&gt; for spawning a process at another node.</source>
          <target state="translated">存在许多其他的 &lt;code&gt;spawn&lt;/code&gt; BIF，例如，用于在另一个节点 &lt;code&gt;spawn/4&lt;/code&gt; 进程的spawn / 4。</target>
        </trans-unit>
        <trans-unit id="0bf1452fa6d696c476949e9f9eb92d75ee28307f" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate maps.</source>
          <target state="translated">存在一些BIF来操作地图。</target>
        </trans-unit>
        <trans-unit id="5a19838f7ca93f30ce58e7113784f915faaff575" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate tuples.</source>
          <target state="translated">存在一些BIF来操作元组。</target>
        </trans-unit>
        <trans-unit id="d71ba36f320e1a48ef1d206a22dd1cb9d13cc9ef" translate="yes" xml:space="preserve">
          <source>There is &lt;strong&gt;no&lt;/strong&gt; automatic mechanism for avoiding priority inversion, such as priority inheritance or priority ceilings. When using priorities, take this into account and handle such scenarios by yourself.</source>
          <target state="translated">有&lt;strong&gt;没有&lt;/strong&gt;用于避免优先级反转，如优先级继承或优先天花板自动机构。使用优先级时，请考虑到这一点并自己处理此类情况。</target>
        </trans-unit>
        <trans-unit id="9a070af877637494ae1a1cb6aabfadc95370405a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;separate chapter&lt;/a&gt;&lt;/code&gt; about how &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; co-operate. How the different configuration levels affect them, is described here in this section.</source>
          <target state="translated">有 &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;separate chapter&lt;/a&gt;&lt;/code&gt; 介绍了 &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 是如何协作的。本节在此介绍不同的配置级别如何影响它们。</target>
        </trans-unit>
        <trans-unit id="e441464fc3e7bb22aba940b66dbb7ca5c94b38df" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;server&lt;/code&gt; config option, &lt;code&gt;&lt;a href=&quot;snmp_config#manager_server_nis&quot;&gt;netif_sup&lt;/a&gt;&lt;/code&gt; that enables &quot;active&quot; Net If supervision. This is very simple mechanism. The (supervising) process simply sends a &lt;code&gt;&lt;a href=&quot;#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; message and expects a &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message response (withing a specific time). The interval between each &lt;code&gt;ping/pong&lt;/code&gt; exhange is user configurable. As is the time that is allowed for the &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message to arrive. Both the NetIf module(s) provided with the app supports active supervision. If a NetIf module/process is used which do not implement this, then the server cannot be configured with active supervision.</source>
          <target state="translated">有一个 &lt;code&gt;server&lt;/code&gt; 配置选项 &lt;code&gt;&lt;a href=&quot;snmp_config#manager_server_nis&quot;&gt;netif_sup&lt;/a&gt;&lt;/code&gt; 启用&amp;ldquo;活动的&amp;rdquo; Net If监督。这是非常简单的机制。 （监督）过程仅发送 &lt;code&gt;&lt;a href=&quot;#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; 消息，并期望 &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 消息响应（在特定时间范围内）。每个 &lt;code&gt;ping/pong&lt;/code&gt; 交换之间的间隔是用户可配置的。 &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 消息到达所允许的时间是这样。该应用程序随附的两个NetIf模块均支持主动监管。如果使用的NetIf模块/进程未实现此功能，则无法在主动监管下配置服务器。</target>
        </trans-unit>
        <trans-unit id="ea2c52d8c1115defbbd414994b65799bf1261e4f" translate="yes" xml:space="preserve">
          <source>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community string to a &lt;code&gt;contextEngineID&lt;/code&gt; and &lt;code&gt;contextName&lt;/code&gt;. Thus, each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always uniquely identifies a context.</source>
          <target state="translated">有一个MIB，即SNMP-COMMUNITY-MIB，它将社区字符串映射到 &lt;code&gt;contextEngineID&lt;/code&gt; 和 &lt;code&gt;contextName&lt;/code&gt; 。因此，每个消息（SNMPv1，SNMPv2c或SNMPv3消息）始终唯一地标识上下文。</target>
        </trans-unit>
        <trans-unit id="4962d5e61edd677f3200f2d2f1cbd369fddee679" translate="yes" xml:space="preserve">
          <source>There is a bit of setup needed to allow filters to decide whether a specific process should be allowed to log. This is because the default primary log level is notice and it is enforced before the primary filters. So in order for the pid filter to be useful we have to raise the primary log level to &lt;code&gt;all&lt;/code&gt; and then add a level filter that only lets certain messages at or greater than notice through. When the setup is done, it is simple to add a filter that allows a certain pid through.</source>
          <target state="translated">需要进行一些设置，以允许过滤器确定是否应允许记录特定进程。这是因为默认的主日志级别是notify，并且在主过滤器​​之前强制执行。因此，为了使pid过滤器有用，我们必须将主要日志级别提高到 &lt;code&gt;all&lt;/code&gt; 级别，然后添加一个级别过滤器，该级别过滤器仅允许某些消息达到或超过通知范围。设置完成后，添加允许特定pid通过的过滤器很简单。</target>
        </trans-unit>
        <trans-unit id="9ade9e507a62a79d9f797b73458450166ab26545" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 定义了默认的主机名匹配过程，在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 定义了与协议相关的变体。默认过程在 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 中实现。客户端可以使用选项列表来挂钩修改后的规则。</target>
        </trans-unit>
        <trans-unit id="a6736bbeb782d86b747de9c6e8819acd895d1cff" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section/6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section/6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 定义了默认的主机名匹配过程，在 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 定义了与协议相关的变体。默认过程在 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 中实现。客户端可以使用选项列表来挂接修改后的规则。</target>
        </trans-unit>
        <trans-unit id="d57b5d67847213c70927a42448b10614ec369aea" translate="yes" xml:space="preserve">
          <source>There is a scaling problem with this database.</source>
          <target state="translated">这个数据库有一个缩放问题。</target>
        </trans-unit>
        <trans-unit id="2622c0a39c247fb494769606e0e52cccfb438701" translate="yes" xml:space="preserve">
          <source>There is a set of standard MIBs, which are used to control and configure an SNMP agent. All of these MIBs, with the exception of the optional SNMP-PROXY-MIB (which is only used for proxy agents), are implemented in this agent. Further, it is configurable which of these MIBs are actually loaded, and thus made visible to SNMP managers. For example, in a non-secure environment, it might be a good idea to not make MIBs that define access control visible. Note, the data the MIBs define is used internally in the agent, even if the MIBs not are loaded. This chapter describes these standard MIBs, and some aspects of their implementation.</source>
          <target state="translated">有一组标准MIB,用于控制和配置SNMP代理。除了可选的SNMP-PROXY-MIB(仅用于代理代理代理),所有这些MIB都在该代理中实现。此外,可以配置这些MIB中的哪些MIB被实际加载,从而使SNMP管理器可见。例如,在一个非安全的环境中,不使定义访问控制的MIB可见可能是一个好主意。注意,即使没有加载MIBs,MIBs定义的数据也会在代理中内部使用。本章介绍了这些标准MIB,以及它们实现的一些方面。</target>
        </trans-unit>
        <trans-unit id="245adc1cc09d9e8cf3fbaea30fefe11a104de911" translate="yes" xml:space="preserve">
          <source>There is a severe performance penalty in using &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; after any modifying operation is done on that table in the same transaction. That is, avoid using &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;mnesia:select&lt;/code&gt; in the same transaction.</source>
          <target state="translated">在同一事务中对该表执行任何修改操作后，使用 &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; 严重影响性能。也就是说，避免在同一事务中的 &lt;code&gt;mnesia:select&lt;/code&gt; 之前使用 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd2145693c339b562c11a1ada444dad48f07688b" translate="yes" xml:space="preserve">
          <source>There is a special case for the argument &lt;code&gt;Length&lt;/code&gt;. If it is set to zero (0), it means &quot;give me everything you currently have&quot;.</source>
          <target state="translated">参数 &lt;code&gt;Length&lt;/code&gt; 是一个特殊情况。如果将其设置为零（0），则表示&amp;ldquo;给我您当前拥有的所有内容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e3a6368bd3434309374ec5b9d503fef73c80480" translate="yes" xml:space="preserve">
          <source>There is a special case for this field. When the &lt;code&gt;max_retries&lt;/code&gt; has the value &lt;code&gt;infinity_restartable&lt;/code&gt;, it means that the timer is restartable as long as some external event occurs (e.g. receipt of a pending message for instance). But the timer will never be restarted &quot;by itself&quot;, i.e. when the timer expires (whatever the timeout time), so does the timer. Whenever the timer is restarted, the timeout time will be calculated in the usual way! Also, as mentioned above, beware the consequences of setting the value to &lt;code&gt;infinity&lt;/code&gt; if &lt;strong&gt;incr&lt;/strong&gt; has been set to an negative value.</source>
          <target state="translated">此字段有一个特殊情况。当 &lt;code&gt;max_retries&lt;/code&gt; 的值是 &lt;code&gt;infinity_restartable&lt;/code&gt; 时，这意味着只要发生​​某些外部事件（例如，接收到待处理的消息），计时器就可以重新启动。但是计时器永远不会&amp;ldquo;自行&amp;rdquo;重新启动，即计时器到期（无论超时时间如何），计时器也不会重新启动。每当定时器重启时，超时时间将以通常的方式计算！另外，如上所述，请注意如果将&lt;strong&gt;incr&lt;/strong&gt;设置为负值，则将值设置为 &lt;code&gt;infinity&lt;/code&gt; 的后果。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="518160f1e4844414329120e09f304c63bc2e3610" translate="yes" xml:space="preserve">
          <source>There is a way to exclude a varbind from the notification. In the normal &lt;code&gt;varbinds&lt;/code&gt; list, providing the special value &lt;code&gt;'$ignore-oid'&lt;/code&gt; (instead of a normal value) will exclude this varbind from the notification.</source>
          <target state="translated">有一种方法可以从通知中排除varbind。在常规 &lt;code&gt;varbinds&lt;/code&gt; 列表中，提供特殊值 &lt;code&gt;'$ignore-oid'&lt;/code&gt; （而不是常规值）会将此varbind从通知中排除。</target>
        </trans-unit>
        <trans-unit id="447c2e61ea99ad24abf33df5c7d87ca6d434b459" translate="yes" xml:space="preserve">
          <source>There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom &lt;code&gt;default&lt;/code&gt; instead of the name.</source>
          <target state="translated">还有一个&amp;ldquo;默认&amp;rdquo;值，它具有空字符串作为名称。使用原子 &lt;code&gt;default&lt;/code&gt; 而不是name进行读写。</target>
        </trans-unit>
        <trans-unit id="72a2dc39e7a01a6896da1efca2f9a2f1bfe9f0eb" translate="yes" xml:space="preserve">
          <source>There is also a file that only contains macro definitions:</source>
          <target state="translated">还有一个文件,只包含宏定义。</target>
        </trans-unit>
        <trans-unit id="2f4ba43d3ad9541719761e12f97fd9eb701de696" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory (e.g. VxWorks). The output on other systems is however still valid, although sparse.</source>
          <target state="translated">还有一个与系统相关的内存数据的接口 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 。结果高度依赖于底层操作系统，并且该接口主要针对没有虚拟内存的系统（例如VxWorks）。尽管稀疏，但其他系统上的输出仍然有效。</target>
        </trans-unit>
        <trans-unit id="f33caba16ae1707839afdef5cf02caa858272566" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory. However, the output on other systems is still valid, although sparse.</source>
          <target state="translated">还有一个与系统相关的内存数据的接口 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 。结果高度依赖于底层操作系统，并且该接口主要针对没有虚拟内存的系统。但是，尽管稀疏，但其他系统上的输出仍然有效。</target>
        </trans-unit>
        <trans-unit id="52cbe6243fc1056f1d917ea0abcda645d19b3500" translate="yes" xml:space="preserve">
          <source>There is also a low limit. When the amount of queued &lt;code&gt;command&lt;/code&gt; data falls below this limit and the port is in a busy port queue state, the busy port queue state is automatically disabled. The low limit should typically be significantly lower than the high limit in order to prevent frequent oscillation around the busy port queue state.</source>
          <target state="translated">还有一个下限。当排队的 &lt;code&gt;command&lt;/code&gt; 数据量低于此限制并且端口处于繁忙端口队列状态时，繁忙端口队列状态将被自动禁用。下限通常应大大低于上限，以防止繁忙端口队列状态周围的频繁振荡。</target>
        </trans-unit>
        <trans-unit id="7c9bc41f259857156ea8f5d5261fcd25f2b407e3" translate="yes" xml:space="preserve">
          <source>There is also a module &lt;code&gt;make&lt;/code&gt;, which provides a set of functions similar to the UNIX type Make functions, see the &lt;code&gt;make(3)&lt;/code&gt; manual page in Tools.</source>
          <target state="translated">还有一个模块 &lt;code&gt;make&lt;/code&gt; ，它提供了一组类似于UNIX类型的Make函数的功能，请参见Tools中的 &lt;code&gt;make(3)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d5ca1aa3efc4be83f80c48a432fa83fd2335f9cf" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after, Timeout} &lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#start_monitor-3&quot;&gt;start_monitor/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4,5,6&lt;/a&gt;&lt;/code&gt;, that may be used to automatically hibernate the server.</source>
          <target state="translated">还有一个用于 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#start_monitor-3&quot;&gt;start_monitor/3,4&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4,5,6&lt;/a&gt;&lt;/code&gt; 的服务器启动选项 &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after, Timeout} &lt;/a&gt;&lt;/code&gt; ，可以用来自动休眠服务器。</target>
        </trans-unit>
        <trans-unit id="0dad695a19ca238ba2a763d955fb786b98d2dc49" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; ，还有一个服务器启动选项 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; ，可用于自动使服务器休眠。</target>
        </trans-unit>
        <trans-unit id="f24b3a3437fd8a632ab4bcd78a41f42013e20b72" translate="yes" xml:space="preserve">
          <source>There is also a type test BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt;.</source>
          <target state="translated">还有一个类型测试BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daa23f797927415980ee4810932d3c90b6953794" translate="yes" xml:space="preserve">
          <source>There is also an API to block or unblock users manually. This API can also list blocked users or users who have been authenticated within a configurable amount of time.</source>
          <target state="translated">还有一个API可以手动阻止或解除阻止用户。这个API还可以列出被封杀的用户或在可配置的时间内被认证的用户。</target>
        </trans-unit>
        <trans-unit id="7110ad7a4f42b784159bbbf21bed3303346edd8d" translate="yes" xml:space="preserve">
          <source>There is also function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels.</source>
          <target state="translated">还有一个函数 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 返回所有标志（按位或：在一起），这些标志对应于要求在分发通道上对数据进行严格排序的功能。</target>
        </trans-unit>
        <trans-unit id="6fa8c8dbb4f5b93ed951ec7e3ddcfaace3c9a8bb" translate="yes" xml:space="preserve">
          <source>There is also the single sequence \N, which matches a non-newline character. This is the same as the &quot;.&quot; metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set. Perl also uses \N to match characters by name, but PCRE does not support this.</source>
          <target state="translated">还有一个单个序列\ N，它与非换行符匹配。这与&amp;ldquo;。&amp;rdquo;相同。未设置 &lt;code&gt;dotall&lt;/code&gt; 时的元字符。Perl还使用\ N来按名称匹配字符，但是PCRE不支持此功能。</target>
        </trans-unit>
        <trans-unit id="b98454e1dad347bf57900e7a0165181c58bc516a" translate="yes" xml:space="preserve">
          <source>There is always a process registered under the name of &lt;code&gt;user&lt;/code&gt;. This can be used for sending output to the user.</source>
          <target state="translated">总会有一个以 &lt;code&gt;user&lt;/code&gt; 名义注册的进程。这可用于将输出发送给用户。</target>
        </trans-unit>
        <trans-unit id="48f05fa36ef8d48104e41cb6957499643b973e55" translate="yes" xml:space="preserve">
          <source>There is an important command to list the actual algorithms and their ordering: &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有一个重要的命令可以列出实际算法及其顺序： &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83f929c7ba80aeba27f85a0a055bddbdc902825" translate="yes" xml:space="preserve">
          <source>There is an information function for the types above:</source>
          <target state="translated">以上类型有一个信息功能。</target>
        </trans-unit>
        <trans-unit id="dacb594bad469f1ce7f5caf10b3b3ec583858f47" translate="yes" xml:space="preserve">
          <source>There is an ordering, which is:</source>
          <target state="translated">有一个顺序,就是:</target>
        </trans-unit>
        <trans-unit id="9bbb406addbf195bc5bf6f601577bdb5f7463970" translate="yes" xml:space="preserve">
          <source>There is another non-standard property, Xuc, which matches any character that can be represented by a Universal Character Name in C++ and other programming languages. These are the characters $, @, ` (grave accent), and all characters with Unicode code points &amp;gt;= U+00A0, except for the surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are excluded. (Universal Character Names are of the form \uHHHH or \UHHHHHHHH, where H is a hexadecimal digit. Notice that the Xuc property does not match these sequences but the characters that they represent.)</source>
          <target state="translated">还有另一个非标准属性Xuc，它与可以用C ++和其他编程语言的通用字符名称表示的任何字符匹配。这些是字符$，@，`（重音符），以及所有带有Unicode代码点&amp;gt; = U + 00A0的字符，但从U + D800到U + DFFF的替代字符除外。请注意，排除了大多数基本（ASCII）字符。 （通用字符名称的格式为\ uHHHH或\ UHHHHHHHHH，其中H是十六进制数字。请注意，Xuc属性与这些序列不匹配，但与它们表示的字符匹配。）</target>
        </trans-unit>
        <trans-unit id="24db043e3e85ec5f96858860abaa48c0bebec77d" translate="yes" xml:space="preserve">
          <source>There is currently &lt;strong&gt;no&lt;/strong&gt; support for Windows.</source>
          <target state="translated">当前&lt;strong&gt;不&lt;/strong&gt;支持Windows。</target>
        </trans-unit>
        <trans-unit id="01441ce6d74363dda8f15648c06b7b0537c64a86" translate="yes" xml:space="preserve">
          <source>There is however a utility module, &lt;code&gt;dist_util&lt;/code&gt;, which does most of the hard work of handling handshakes, cookies, timers, and ticking. Using &lt;code&gt;dist_util&lt;/code&gt; makes implementing a distribution module much easier and that is done in the example application.</source>
          <target state="translated">但是，有一个实用程序模块 &lt;code&gt;dist_util&lt;/code&gt; ，它完成了处理握手，cookie，计时器和滴答的大部分艰苦的工作。使用 &lt;code&gt;dist_util&lt;/code&gt; 使实现分发模块更加容易，这在示例应用程序中完成。</target>
        </trans-unit>
        <trans-unit id="4ca5bc74ccdc1a7e5bdfd46cd1aa8fff1884417d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;rsh&lt;/code&gt; program on the computer.</source>
          <target state="translated">计算机上没有 &lt;code&gt;rsh&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="df2ff6a55b257f4164ad71e8f10123efe9394150" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;send&lt;/code&gt; call with a time-out option, use socket option &lt;code&gt;send_timeout&lt;/code&gt; if time-outs are desired. See section &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有带有超时选项的 &lt;code&gt;send&lt;/code&gt; 呼叫，如果需要超时，请使用套接字选项 &lt;code&gt;send_timeout&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="788a001e209f8fbfb495d59e087ae4ffbefebb3f" translate="yes" xml:space="preserve">
          <source>There is no Boolean data type in Erlang. Instead the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to denote Boolean values.</source>
          <target state="translated">Erlang中没有布尔数据类型。相反，原子 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 用于表示布尔值。</target>
        </trans-unit>
        <trans-unit id="37147d996eecd281a8ba511598164eac1e447d2f" translate="yes" xml:space="preserve">
          <source>There is no attempt to balance trees after deletions. As deletions do not increase the height of a tree, this should be OK.</source>
          <target state="translated">在删除后,没有尝试平衡树木。由于删除不会增加树的高度,所以应该是可以的。</target>
        </trans-unit>
        <trans-unit id="caf2aa5b2cbffe36cef8b0ea41ca0022fd85db8a" translate="yes" xml:space="preserve">
          <source>There is no connection to the node where the process is located.</source>
          <target state="translated">没有连接到进程所在的节点。</target>
        </trans-unit>
        <trans-unit id="5b7a1543335bb44ae5cf0c88c1eac25c65cd7e3b" translate="yes" xml:space="preserve">
          <source>There is no difference between rows in a table and &lt;code&gt;Mnesia&lt;/code&gt; records. Both concepts are the same and are used interchangeably throughout this User's Guide.</source>
          <target state="translated">表格中的行与 &lt;code&gt;Mnesia&lt;/code&gt; 记录之间没有区别。这两个概念相同，并且在本《用户指南》中可以互换使用。</target>
        </trans-unit>
        <trans-unit id="9a1861aef615622b38a7ac58736c71ae81c27ee3" translate="yes" xml:space="preserve">
          <source>There is no guarantee of consistency in the returned list. Tables created or deleted by other processes &quot;during&quot; the &lt;code&gt;ets:all()&lt;/code&gt; call either are or are not included in the list. Only tables created/deleted &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;ets:all()&lt;/code&gt; is called are guaranteed to be included/excluded.</source>
          <target state="translated">不能保证返回列表的一致性。在 &lt;code&gt;ets:all()&lt;/code&gt; 调用过程中由其他进程创建或删除的表不包含在列表中。只有在调用 &lt;code&gt;ets:all()&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;创建/删除的表才被保证包含/排除。</target>
        </trans-unit>
        <trans-unit id="23cb6eb28b6463357c5d086be78e4c28d974313b" translate="yes" xml:space="preserve">
          <source>There is no guarantee that this function will return the same encoded representation for the same term.</source>
          <target state="translated">不保证这个函数会对同一术语返回相同的编码表示。</target>
        </trans-unit>
        <trans-unit id="9a78fbe3d9cb96a901b01d191391ac77c129ae95" translate="yes" xml:space="preserve">
          <source>There is no local function handler.</source>
          <target state="translated">没有本地函数处理程序。</target>
        </trans-unit>
        <trans-unit id="33d688593567ec97b98492916d41c5719d414cf7" translate="yes" xml:space="preserve">
          <source>There is no non-local function handler.</source>
          <target state="translated">没有非本地函数处理程序。</target>
        </trans-unit>
        <trans-unit id="7e798f2b7954fbb8128c8deaa8091eb40c413ae4" translate="yes" xml:space="preserve">
          <source>There is no performance advantage of building (and using) a non-reentrant flex scanner over a reentrant flex scanner (if flex supports building such a scanner).</source>
          <target state="translated">与再入式柔性扫描仪相比,构建(和使用)非再入式柔性扫描仪没有性能优势(如果柔性扫描仪支持构建这样的扫描仪)。</target>
        </trans-unit>
        <trans-unit id="c626748bd3f9380817d9836ccd98f9458d1a0bc7" translate="yes" xml:space="preserve">
          <source>There is no space left on the device (if &lt;code&gt;write&lt;/code&gt; access was specified).</source>
          <target state="translated">设备上没有剩余空间（如果指定了 &lt;code&gt;write&lt;/code&gt; 访问权限）。</target>
        </trans-unit>
        <trans-unit id="2a40eb7111de1638bc04c597cd24719439c9fafa" translate="yes" xml:space="preserve">
          <source>There is not enough memory for the contents of the file.</source>
          <target state="translated">文件的内容没有足够的内存。</target>
        </trans-unit>
        <trans-unit id="68171e010dd69d363d2cc2e5daa9281d1e1ce0d2" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;start_ssl.boot&lt;/code&gt; file in the current directory.</source>
          <target state="translated">现在，当前目录中有一个 &lt;code&gt;start_ssl.boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="894f17b55577d9c71ce16f3c9d0e450cd2e02a30" translate="yes" xml:space="preserve">
          <source>There is often a need to configure some other exec evaluator to tailor the input language or restrict the possible functions to call. There are two ways of doing this which will be shown with examples below. See &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">通常需要配置一些其他执行程序评估器以定制输入语言或限制可能的函数调用。这样做的方法有两种，下面将通过示例进行说明。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5e42ae9f7b3d65e666833c9febb65491e9e97dc0" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; that is automatically cancelled by any event. Note that &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;inserted&lt;/a&gt;&lt;/code&gt; events cancel this time-out just as external events.</source>
          <target state="translated">有一个 &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; 会被任何事件自动取消。请注意， &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed &lt;/a&gt;&lt;/code&gt; 事件和 &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;inserted&lt;/a&gt;&lt;/code&gt; 事件会像外部事件一样取消此超时。</target>
        </trans-unit>
        <trans-unit id="b94bfc7e6754ca3ea8a6de36cb806cf966b369f7" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; that is automatically cancelled by a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="translated">有一个 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; 会通过&lt;strong&gt;状态更改&lt;/strong&gt;自动取消。</target>
        </trans-unit>
        <trans-unit id="50c0d56eee94679c32dbfb957c35b23a7c464276" translate="yes" xml:space="preserve">
          <source>There is one exception to the rule that a variable that is as size must be previously bound. It is possible to match and bind a variable, and use it as a size within the the same binary pattern. For example:</source>
          <target state="translated">作为大小的变量必须事先绑定的规则有一个例外。我们可以匹配和绑定一个变量,并在同一个二进制模式中使用它作为大小。例如</target>
        </trans-unit>
        <trans-unit id="982e604305f35dec38eb296c4a9c3f70aede4f41" translate="yes" xml:space="preserve">
          <source>There is one exception to the rule that the tuple is copied. If the compiler clearly can see that destructively updating the tuple would give the same result as if the tuple was copied, the call to &lt;code&gt;setelement/3&lt;/code&gt; is replaced with a special destructive &lt;code&gt;setelement&lt;/code&gt; instruction. In the following code sequence, the first &lt;code&gt;setelement/3&lt;/code&gt; call copies the tuple and modifies the ninth element:</source>
          <target state="translated">元组被复制的规则有一个例外。如果编译器清楚地看到破坏性地更新元组将得到与复制元组相同的结果，则对 &lt;code&gt;setelement/3&lt;/code&gt; 的调用将替换为特殊的破坏性 &lt;code&gt;setelement&lt;/code&gt; 指令。在以下代码序列中，第一个 &lt;code&gt;setelement/3&lt;/code&gt; 调用复制该元组并修改第九个元素：</target>
        </trans-unit>
        <trans-unit id="961aa3429c05e4421a44dd6baffbd85ca75ea3dd" translate="yes" xml:space="preserve">
          <source>There is one exception. &lt;strong&gt;Any&lt;/strong&gt; tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; will, in this context, be considered belonging to this application, and may be processed by the agent.</source>
          <target state="translated">有一个例外。在这种情况下，包含原子 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 的&lt;strong&gt;任何&lt;/strong&gt;元组都将被视为属于此应用程序，并且可以由代理进行处理。</target>
        </trans-unit>
        <trans-unit id="fb83be6c2e955864087572066b00b5e6d77bfed6" translate="yes" xml:space="preserve">
          <source>There is seldom or never any need to use this BIF as other processes have a chance to run in another scheduler thread anyway. Using this BIF without a thorough grasp of how the scheduler works can cause performance degradation.</source>
          <target state="translated">很少或根本不需要使用这个BIF,因为其他进程有机会在另一个调度线程中运行。在没有彻底掌握调度器工作原理的情况下使用这个BIF会导致性能下降。</target>
        </trans-unit>
        <trans-unit id="672d0cbc29fa0c58939d66ddc95453e76a3b8e80" translate="yes" xml:space="preserve">
          <source>There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself.</source>
          <target state="translated">在shell中对读取和打印记录有一些支持。在编译过程中,记录表达式被翻译成元组表达式。在运行时,不知道元组是否代表记录,编译器使用的记录定义在运行时不可用。所以,为了尽可能地读取记录语法并将元组打印为记录,记录定义必须由shell自己维护。</target>
        </trans-unit>
        <trans-unit id="f75ce9844eb4486f4e4b30867918c3e4b3911386" translate="yes" xml:space="preserve">
          <source>There is support for this in xmerl by the &quot;simple-form&quot; format. You can put your data in a simple-form data structure and feed it into &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt;. Content may be a mixture of simple-form and xmerl records as xmlElement and xmlText.</source>
          <target state="translated">xmerl通过&amp;ldquo;简单形式&amp;rdquo;格式对此提供支持。您可以将数据放入简单形式的数据结构中，并将其输入 &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt; 中。内容可能是xmlElement和xmlText等简单形式和xmerl记录的混合。</target>
        </trans-unit>
        <trans-unit id="3edc744598fcc737ca378c211064f17614a02e99" translate="yes" xml:space="preserve">
          <source>There is usually not much difference between a body-recursive list function and tail-recursive function that reverses the list at the end. Therefore, concentrate on writing beautiful code and forget about the performance of your list functions. In the time-critical parts of your code (and only there), &lt;strong&gt;measure&lt;/strong&gt; before rewriting your code.</source>
          <target state="translated">主体递归列表函数和尾部递归函数（在末尾反向列表）之间通常没有太大区别。因此，请专注于编写漂亮的代码，而不必理会列表函数的性能。在代码的时间紧迫部分（并且仅在那儿），在重写代码之前先进行&lt;strong&gt;测量&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="175f3e4c19799f026ed2193325a08cc18afee059" translate="yes" xml:space="preserve">
          <source>There may be a tuple &lt;code&gt;{saved, N}&lt;/code&gt; in the return value, if the MatchSpec is other than []. The integer &lt;code&gt;N&lt;/code&gt; may then be used in subsequent calls to this function and will stand as an &quot;alias&quot; for the given expression. There are also a couple of built-in aliases for common expressions, see &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; below for details.</source>
          <target state="translated">如果MatchSpec不是[]，则返回值中可能有一个元组 &lt;code&gt;{saved, N}&lt;/code&gt; 。然后，整数 &lt;code&gt;N&lt;/code&gt; 可以在对该函数的后续调用中使用，并且将作为给定表达式的&amp;ldquo;别名&amp;rdquo;。通用表达式还有两个内置别名，有关详细信息，请参见下面的 &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="439af89f2aedc3e47e38162227f9dad598919f3e" translate="yes" xml:space="preserve">
          <source>There may be label characters before or/and after the wildcard. For example: &lt;code&gt;a*d.example.com&lt;/code&gt; matches &lt;code&gt;abcd.example.com&lt;/code&gt; and &lt;code&gt;ad.example.com&lt;/code&gt;, but not &lt;code&gt;ab.cd.example.com&lt;/code&gt;.</source>
          <target state="translated">通配符之前或之后可能有标签字符。例如： &lt;code&gt;a*d.example.com&lt;/code&gt; 与 &lt;code&gt;abcd.example.com&lt;/code&gt; 和 &lt;code&gt;ad.example.com&lt;/code&gt; 匹配，但与ab.cd.example.com不 &lt;code&gt;ab.cd.example.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2139ae87af2ed5426b73952d31a1c1937f8c40d6" translate="yes" xml:space="preserve">
          <source>There may only be one wildcard character and that is in the first label, for example: &lt;code&gt;*.example.com&lt;/code&gt;. This matches &lt;code&gt;foo.example.com&lt;/code&gt; but neither &lt;code&gt;example.com&lt;/code&gt; nor &lt;code&gt;foo.bar.example.com&lt;/code&gt;.</source>
          <target state="translated">可能只有一个通配符，并且在第一个标签中，例如： &lt;code&gt;*.example.com&lt;/code&gt; 。这与 &lt;code&gt;foo.example.com&lt;/code&gt; 匹配，但与 &lt;code&gt;example.com&lt;/code&gt; 或 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 都不匹配。</target>
        </trans-unit>
        <trans-unit id="86d38102deb0f5be31f5b5646bc1d23391a9239c" translate="yes" xml:space="preserve">
          <source>There must be no calls to another function in between the calls to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">在对 &lt;code&gt;setelement/3&lt;/code&gt; 的调用之间，不得存在对另一个函数的调用。</target>
        </trans-unit>
        <trans-unit id="4379219137f82ad3d5f85ec7793035a5647a5347" translate="yes" xml:space="preserve">
          <source>There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems:</source>
          <target state="translated">在实现现在未被记录的算法时存在一些问题,这就是为什么它们被废弃的原因。新的算法速度稍慢,但不存在这些问题。</target>
        </trans-unit>
        <trans-unit id="c8702fd6526747089f634470b6b71a67546749e1" translate="yes" xml:space="preserve">
          <source>There will be three almost identical copies of the code. Given the size of the code, that could be too high cost to pay.</source>
          <target state="translated">将有三份几乎相同的代码。考虑到代码的规模,这可能是太高的成本。</target>
        </trans-unit>
        <trans-unit id="94edc56fd4c7a685211aeb70698042dc2126321d" translate="yes" xml:space="preserve">
          <source>Therefor in the tests, binary codecs are tested with four different encoding configs to determine exactly how the different options effect the performance: with transformation and without driver ([]), without transformation and without driver ([native]), with transformation and with driver ([driver]) and finally without transformation and with driver ([driver,native]).</source>
          <target state="translated">因此,在测试中,二进制编解码器用四种不同的编码配置进行测试,以确定不同的选项对性能的影响:有转换和无驱动([]),无转换和无驱动([native]),有转换和有驱动([driver]),最后无转换和有驱动([driver,native])。</target>
        </trans-unit>
        <trans-unit id="243f02477e6596c18fd3c62ae8ed5666e8ef7097" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;my_binary_to_list/1&lt;/code&gt; calls itself with the match context instead of with a sub binary. The instruction that initializes the matching operation basically does nothing when it sees that it was passed a match context instead of a binary.</source>
          <target state="translated">因此， &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 会使用match上下文而不是子二进制文件进行调用。初始化匹配操作的指令在看到已传递给匹配上下文而不是二进制文件时，基本上什么也不做。</target>
        </trans-unit>
        <trans-unit id="a8aae9f4ba098f331d48e185f24980e7223ed137" translate="yes" xml:space="preserve">
          <source>Therefore it is not enough to only recompile drivers written with version management for pre R15B types; the types must be changed in the driver suggesting other rewrites, especially regarding size variables. &lt;strong&gt;Investigate all warnings when recompiling.&lt;/strong&gt;</source>
          <target state="translated">因此，仅针对R15B之前的类型仅重新编译使用版本管理编写的驱动程序是不够的。必须在驱动程序中更改类型，建议进行其他重写，尤其是有关大小变量的重写。&lt;strong&gt;重新编译时，请检查所有警告。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8451cc048f68604a8e6f8398bb63201daf908b58" translate="yes" xml:space="preserve">
          <source>Therefore the following call:</source>
          <target state="translated">因此下面的电话。</target>
        </trans-unit>
        <trans-unit id="cac855cec75c6e990039722ee7ddfc227fe28ddc" translate="yes" xml:space="preserve">
          <source>Therefore the old api (see next section) is kept for now but internally implemented with new primitives.</source>
          <target state="translated">因此,旧的 api(见下一节)暂时保留,但在内部使用新基元实现。</target>
        </trans-unit>
        <trans-unit id="f4080dae433bd65ba4f78438abd73a9dcd511aa9" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;after_zero/1&lt;/code&gt; builds one match context and one sub binary (assuming it is passed a binary that contains a zero byte).</source>
          <target state="translated">因此， &lt;code&gt;after_zero/1&lt;/code&gt; 构建一个匹配上下文和一个子二进制文件（假定传递了一个包含零字节的二进制文件）。</target>
        </trans-unit>
        <trans-unit id="9e7c3bfd969d68d13350f73c07ad4f037893dc43" translate="yes" xml:space="preserve">
          <source>Therefore, certain operations on a binary mark it so that any future append operation will be forced to copy the binary. In most cases, the binary object will be shrunk at the same time to reclaim the extra space allocated for growing.</source>
          <target state="translated">因此,对二进制的某些操作会对其进行标记,这样未来的任何追加操作都会强制复制二进制。在大多数情况下,二进制对象将同时被收缩,以回收分配给增长的额外空间。</target>
        </trans-unit>
        <trans-unit id="1bd6b474df592c0536d4daa44f7c1bfcafdb1fcf" translate="yes" xml:space="preserve">
          <source>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; can be used to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</source>
          <target state="translated">因此，在连续运行的系统中，将任意输入字符串转换为原子可能很危险。如果仅允许某些定义明确的原子作为输入，则可以使用 &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; 来防止拒绝服务攻击。（例如，可以通过在模块中简单地使用所有原子并加载该模块来创建所有允许的原子。）</target>
        </trans-unit>
        <trans-unit id="92e119795a21e7955d1c30f27f5a24fcb874b645" translate="yes" xml:space="preserve">
          <source>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; can be used to to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</source>
          <target state="translated">因此，在连续运行的系统中，将任意输入字符串转换为原子可能很危险。如果只允许使用某些定义明确的原子作为输入，则 &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; 可以用于防范拒绝服务攻击。（例如，可以通过简单地在模块中使用所有原子并加载该模块来创建所有允许的原子。）</target>
        </trans-unit>
        <trans-unit id="0afb1e74cde0028071d12983306cbaa758aaee89" translate="yes" xml:space="preserve">
          <source>Therefore, if you want to send both a pre-existing binary and some extra data to a driver without copying the binary, you must call &lt;code&gt;port_control/3&lt;/code&gt; twice; once with the binary and once with the extra data. However, that will only work if there is only one process communicating with the port (because otherwise another process can call the driver in-between the calls).</source>
          <target state="translated">因此，如果您想将既有的二进制文件和一些额外的数据发送给驱动程序而不复制二进制文件，则必须调用 &lt;code&gt;port_control/3&lt;/code&gt; 两次；一次使用二进制文件，一次使用额外数据。但是，这仅在只有一个进程与端口进行通信时才起作用（因为否则，另一个进程可以在调用之间调用驱动程序）。</target>
        </trans-unit>
        <trans-unit id="e1058e576d020e27852d4dd63c7e76baf9cb4f3e" translate="yes" xml:space="preserve">
          <source>Therefore, setting this option to &lt;code&gt;true&lt;/code&gt; when creating a socket never fails, except possibly on a platform where you have customized the kernel to only allow &lt;code&gt;false&lt;/code&gt;, which can be doable (but awkward) on, for example, OpenBSD.</source>
          <target state="translated">因此，在创建套接字时将此选项设置为 &lt;code&gt;true&lt;/code&gt; 永远不会失败，除非可能是在您已将内核自定义为仅允许 &lt;code&gt;false&lt;/code&gt; 的平台上进行，但可以在OpenBSD上这样做（但尴尬）。</target>
        </trans-unit>
        <trans-unit id="fa03132e315d50b20abbcf96beb07d6fa4be6ede" translate="yes" xml:space="preserve">
          <source>Therefore, the following example is a valid Erlang instance of type 'Oid':</source>
          <target state="translated">因此,下面的例子是一个有效的'Oid'类型的Erlang实例。</target>
        </trans-unit>
        <trans-unit id="3d5269f23f196ee210eee4acf06c960dda47d1df" translate="yes" xml:space="preserve">
          <source>These &lt;strong&gt;transition actions&lt;/strong&gt; can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; when it is called with an &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过以下方式调用这些&lt;strong&gt;转换动作：&lt;/strong&gt;从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; （通过 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt; 调用）返回它们，从 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 返回,或者将其赋予 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02bc7790d560067efd73b09c97b9c65eaaef9ebf" translate="yes" xml:space="preserve">
          <source>These &lt;strong&gt;transition actions&lt;/strong&gt; can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ，从 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 返回它们或将它们提供给 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用这些&lt;strong&gt;转换动作&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a00c80e549287bbb93dadd392554fafbbbc24b24" translate="yes" xml:space="preserve">
          <source>These Erlang variables are now bound to valid instances of ASN.1 defined types. This style of value can be passed directly to the encoder for transformation into a series of bytes.</source>
          <target state="translated">这些Erlang变量现在被绑定到ASN.1定义类型的有效实例上。这种风格的值可以直接传递给编码器,以便转化为一系列字节。</target>
        </trans-unit>
        <trans-unit id="0f0a03fdc3b62893e944bf31939f2cfaecae96b7" translate="yes" xml:space="preserve">
          <source>These MIBs are not loaded by default.</source>
          <target state="translated">这些MIB在默认情况下没有被加载。</target>
        </trans-unit>
        <trans-unit id="2ec64a39b7d4c54784cd2ad56d92c227d3e17b9a" translate="yes" xml:space="preserve">
          <source>These MIBs contain the &lt;code&gt;snmp-&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; groups from MIB-II which is defined in RFC1213 (STANDARD-MIB) or RFC1907 (SNMPv2-MIB). They are implemented in the &lt;code&gt;snmp_standard_mib&lt;/code&gt; module. The &lt;code&gt;snmp&lt;/code&gt; counters all reside in volatile memory and the &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; variables in persistent memory, using the SNMP built-in database (refer to the Reference Manual, section &lt;code&gt;snmp&lt;/code&gt;, module &lt;code&gt;snmpa_local_db&lt;/code&gt; for more details).</source>
          <target state="translated">这些MIB包含来自MIB-II 的 &lt;code&gt;snmp-&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; 组，这些组在RFC1213（STANDARD-MIB）或RFC1907（SNMPv2-MIB）中定义。它们在 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 模块中实现。该 &lt;code&gt;snmp&lt;/code&gt; 计数器都驻留在易失性存储器和 &lt;code&gt;system&lt;/code&gt; 以及 &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; 在永久存储器中的变量，使用SNMP内置数据库（请参阅参考手册，章节 &lt;code&gt;snmp&lt;/code&gt; ，模块 &lt;code&gt;snmpa_local_db&lt;/code&gt; 有详细介绍）。</target>
        </trans-unit>
        <trans-unit id="e67a93a99a7e370f0477c918676f4cf69ff8699a" translate="yes" xml:space="preserve">
          <source>These are a few  facts about the predefined variables (the set operators &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; (union) and &lt;code&gt;-&lt;/code&gt; (difference) as well as the cast operator &lt;code&gt;(&lt;/code&gt;Type&lt;code&gt;)&lt;/code&gt; are described below):</source>
          <target state="translated">以下是有关预定义变量的一些事实（集合运算符 &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; （联合）和 &lt;code&gt;-&lt;/code&gt; （差）以及强制转换运算符 &lt;code&gt;(&lt;/code&gt; 类型 &lt;code&gt;)&lt;/code&gt; 描述如下）：</target>
        </trans-unit>
        <trans-unit id="b41fa5eb73a7806528a8254a84f2a17ca0515977" translate="yes" xml:space="preserve">
          <source>These are deprecated because the annoying double meaning of the name servers/time-out argument, and because they have no decent place for a resolver options list.</source>
          <target state="translated">由于名称服务器/超时参数具有恼人的双重含义,而且它们在解析器选项列表中没有合适的位置,因此这些选项已被废弃。</target>
        </trans-unit>
        <trans-unit id="60cf421719fdc337d9a96b28085e43063192f175" translate="yes" xml:space="preserve">
          <source>These are only recognized by Erlang nodes, not by hidden nodes.</source>
          <target state="translated">这些只被Erlang节点识别,不被隐藏节点识别。</target>
        </trans-unit>
        <trans-unit id="3295d73ec7e802c1f14b2c332abe46ab60bbbcd5" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;originating&lt;/code&gt; in this agent.</source>
          <target state="translated">这些是影响 &lt;code&gt;originating&lt;/code&gt; 此代理的发现的选项。</target>
        </trans-unit>
        <trans-unit id="e5c03f74465d648a5862f1fc098e9296ee6d6bfb" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;terminating&lt;/code&gt; in this agent (i.e. initiated by a manager).</source>
          <target state="translated">这些是影响发现 &lt;code&gt;terminating&lt;/code&gt; 于此代理程序（即由管理者发起）的选项。</target>
        </trans-unit>
        <trans-unit id="1fced9f787994ac75d8652655a2b16fb12a62921" translate="yes" xml:space="preserve">
          <source>These are read-only and cannot be changed in runtime.</source>
          <target state="translated">这些都是只读的,在运行时不能更改。</target>
        </trans-unit>
        <trans-unit id="787f23076fd9f126101a07d4716e5cdc858d0ff6" translate="yes" xml:space="preserve">
          <source>These are the supported entries and their value types:</source>
          <target state="translated">这些是支持的条目及其价值类型。</target>
        </trans-unit>
        <trans-unit id="b54f8e7581e4b11655c99aa67637a8c43ce11aa5" translate="yes" xml:space="preserve">
          <source>These are the tools you need in order to unpack and build Erlang/OTP.</source>
          <target state="translated">这些都是你在解压和构建Erlang/OTP时需要的工具。</target>
        </trans-unit>
        <trans-unit id="c2b3c62dddfeb24a018a3dfcfce0b24364d8a6b9" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt;, &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt;, and &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt;, respectively.</source>
          <target state="translated">它们分别表现为 &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt; ， &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt; 和 &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1e4b991ff6fe7d1f2495f5a84c72e419f949594" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; and &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt;, respectively.</source>
          <target state="translated">它们分别表现为 &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; 和 &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="187481b8c7b89208071bec932d3843dbbff8e5a2" translate="yes" xml:space="preserve">
          <source>These are two different SMP performance monitoring tool(s).</source>
          <target state="translated">这是两种不同的SMP性能监测工具。</target>
        </trans-unit>
        <trans-unit id="8edbe321eae68320d9237c6f46dbbe92c6832bc5" translate="yes" xml:space="preserve">
          <source>These are variants of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; where you can supply your own message term &lt;code&gt;msg&lt;/code&gt; that will be sent to the process instead of the predefined tuple &lt;code&gt;{select,_,_,_}.&lt;/code&gt;</source>
          <target state="translated">这些是 &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; 的变体，您可以在其中提供自己的消息术语 &lt;code&gt;msg&lt;/code&gt; ，而不是预定义的元组 &lt;code&gt;{select,_,_,_}.&lt;/code&gt; 这些消息将被发送到进程。</target>
        </trans-unit>
        <trans-unit id="4a7d9dd0e596b5ce481a5779ed708189763b4369" translate="yes" xml:space="preserve">
          <source>These behaviors occur regardless if the subpattern is called recursively. The treatment of subroutines in Perl is different in some cases.</source>
          <target state="translated">无论子程序是否被递归调用,这些行为都会发生。在Perl中对子程序的处理在某些情况下是不同的。</target>
        </trans-unit>
        <trans-unit id="4ec49381162072262ed7e981970a8f6edfbd0ee9" translate="yes" xml:space="preserve">
          <source>These books are highly recommended as a start for learning Erlang.</source>
          <target state="translated">强烈推荐这些书作为学习Erlang的开始。</target>
        </trans-unit>
        <trans-unit id="f21525376606a80acbcf6dfcd0372134852c9de3" translate="yes" xml:space="preserve">
          <source>These callback functions are called from local and non-local evaluation function handlers, described in the &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; manual page. (Arguments in &lt;code&gt;ArgList&lt;/code&gt; are evaluated before the callback functions are called.)</source>
          <target state="translated">这些回调函数从本地和非本地评估函数处理程序调用，如 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; 手册页所述。（在调用回调函数之前先评估 &lt;code&gt;ArgList&lt;/code&gt; 中的参数。）</target>
        </trans-unit>
        <trans-unit id="0717b31aef17edf30fcfa1ecdd0c63f7b41ab7a8" translate="yes" xml:space="preserve">
          <source>These case switches only allow &lt;code&gt;?Q(...)&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; as clause patterns, and the guards may contain any expressions, not just Erlang guard expressions.</source>
          <target state="translated">这些大小写开关仅允许 &lt;code&gt;?Q(...)&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 作为子句模式，并且防护可能包含任何表达式，而不仅仅是Erlang防护表达式。</target>
        </trans-unit>
        <trans-unit id="b82509cdccdd98b3f35ff2498648839db3e7e6d5" translate="yes" xml:space="preserve">
          <source>These changes are essential not to crash the emulator or worse cause malfunction. Without them a driver can return garbage in the high 32 bits to the emulator, causing it to build a huge result from random bytes, either crashing on memory allocation or succeeding with a random result from the driver call.</source>
          <target state="translated">这些变化是必不可少的,不会使仿真器崩溃或更糟的是导致故障。如果没有它们,一个驱动程序可能会返回高32位的垃圾给仿真器,导致它从随机字节中建立一个巨大的结果,要么在内存分配时崩溃,要么成功地从驱动程序调用一个随机的结果。</target>
        </trans-unit>
        <trans-unit id="573248e1d06102f3107f0a34b228df99492a4b03" translate="yes" xml:space="preserve">
          <source>These choices depend a lot on your problem domain. If you don't have real time monitoring and ability to fix problems quickly, for example in an embedded system, you might want to accept at most one restart per minute before the supervisor should give up and escalate to the next level to try to clear the error automatically. On the other hand, if it is more important that you keep trying even at a high failure rate, you might want a sustained rate of as much as 1-2 restarts per second.</source>
          <target state="translated">这些选择在很大程度上取决于你的问题域。如果你没有实时监控和快速解决问题的能力,例如在嵌入式系统中,你可能希望在主管应该放弃并升级到下一级试图自动清除错误之前,每分钟最多接受一次重启。另一方面,如果更重要的是,即使在高故障率的情况下,你也要继续尝试,你可能希望有一个持续的速率,即每秒多达1-2次重启。</target>
        </trans-unit>
        <trans-unit id="7cc39d5ee560666c19b1d761a7fa1de1841363b5" translate="yes" xml:space="preserve">
          <source>These commands are only added for convenience, the normal way to manipulate the state of a service is through the control panels services applet.</source>
          <target state="translated">这些命令只是为了方便而添加的,正常情况下是通过控制面板服务小程序来操作服务的状态。</target>
        </trans-unit>
        <trans-unit id="f0bb49d0ba352c03c469accf5e7d24180534a7f3" translate="yes" xml:space="preserve">
          <source>These constructs makes it possible to define open types, that is, values of that type can be of any ASN.1 type. Also, relationships can be defined between different types and values, as classes can hold types, values, objects, object sets, and other classes in their fields. A class can be defined in ASN.1 as follows:</source>
          <target state="translated">这些构造使得定义开放类型成为可能,即该类型的值可以是任何ASN.1类型。同时,不同类型和值之间也可以定义关系,因为类可以在其字段中容纳类型、值、对象、对象集和其他类。在ASN.1中可以定义一个类,具体如下。</target>
        </trans-unit>
        <trans-unit id="befa22022ba0fc273ee1c740958946648b1b19ef" translate="yes" xml:space="preserve">
          <source>These data types are described in the documentation for the &lt;code&gt;SNMP&lt;/code&gt; application.</source>
          <target state="translated">这些数据类型在 &lt;code&gt;SNMP&lt;/code&gt; 应用程序的文档中描述。</target>
        </trans-unit>
        <trans-unit id="7607e5152380b649a4dfea1427608d47b7252b27" translate="yes" xml:space="preserve">
          <source>These declarations mean that &lt;code&gt;'='&lt;/code&gt; is defined as a &lt;code&gt;right associative binary&lt;/code&gt; operator with precedence 100, &lt;code&gt;'=='&lt;/code&gt; and &lt;code&gt;'=/='&lt;/code&gt; are operators with &lt;code&gt;no associativity&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt; are &lt;code&gt;left associative binary&lt;/code&gt; operators, where &lt;code&gt;'*'&lt;/code&gt; takes precedence over &lt;code&gt;'+'&lt;/code&gt; (the normal case), and &lt;code&gt;'-'&lt;/code&gt; is a &lt;code&gt;unary&lt;/code&gt; operator of higher precedence than &lt;code&gt;'*'&lt;/code&gt;. The fact that '==' has no associativity means that an expression like &lt;code&gt;a == b == c&lt;/code&gt; is considered a syntax error.</source>
          <target state="translated">这些声明意味着 &lt;code&gt;'='&lt;/code&gt; 被定义为优先级为100 的 &lt;code&gt;right associative binary&lt;/code&gt; 运算符， &lt;code&gt;'=='&lt;/code&gt; 和 &lt;code&gt;'=/='&lt;/code&gt; 是 &lt;code&gt;no associativity&lt;/code&gt; 运算符， &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;'*'&lt;/code&gt; 则是 &lt;code&gt;left associative binary&lt;/code&gt; 运算符，其中 &lt;code&gt;'*'&lt;/code&gt; 优先于 &lt;code&gt;'+'&lt;/code&gt; （在正常情况下），而 &lt;code&gt;'-'&lt;/code&gt; 是一 &lt;code&gt;unary&lt;/code&gt; 符，其优先级高于 &lt;code&gt;'*'&lt;/code&gt; 。 &amp;ldquo; ==&amp;rdquo;没有关联性的事实意味着像 &lt;code&gt;a == b == c&lt;/code&gt; 这样的表达式被视为语法错误。</target>
        </trans-unit>
        <trans-unit id="c79b2e48d3b3c9cd539a4e7c436d24545530e8a9" translate="yes" xml:space="preserve">
          <source>These events, of course, need to occur ordered to other memory operations. The operation of determining this begins by initiating the thread progress operation. The thread that initiated the thread progress operation after this poll for the completion of the operation. Both of these events must occur at least once &lt;strong&gt;after&lt;/strong&gt; the thread progress operation has been initiated, and at least once &lt;strong&gt;before&lt;/strong&gt; the operation has completed in each managed thread. This is ordered using communication via memory which makes it possible to draw conclusion about the memory state after the thread progress operation has completed. Lets call the progress made from initiation to comletion for &quot;thread progress&quot;.</source>
          <target state="translated">当然，这些事件需要按顺序执行以进行其他内存操作。确定该操作的操作从启动线程进度操作开始。在该轮询之后启动线程进度操作的线程以完成操作。这两个事件必须在启动线程进度操作&lt;strong&gt;之后&lt;/strong&gt;至少发生一次，并且必须在每个受管线程中完成操作&lt;strong&gt;之前&lt;/strong&gt;至少发生一次。这是通过通过内存进行的通信来排序的，这使得可以在线程进度操作完成后得出有关内存状态的结论。让我们将从启动到完成的进度称为&amp;ldquo;线程进度&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="751552b3c6781f0e0e58af55485f1a42f3adbfcd" translate="yes" xml:space="preserve">
          <source>These function simply fetch the appropriate field from the &lt;code&gt;ec&lt;/code&gt; structure. Read the field directly will probably be safe for a long time, so these functions are not really needed.</source>
          <target state="translated">这些功能只是从 &lt;code&gt;ec&lt;/code&gt; 结构中获取适当的字段。直接阅读该字段可能很长一段时间都是安全的，因此实际上并不需要这些功能。</target>
        </trans-unit>
        <trans-unit id="04605460ad130e7237d6de8796f71c1d7f55abcb" translate="yes" xml:space="preserve">
          <source>These functions are all called in the same manner as &lt;code&gt;printf()&lt;/code&gt;, that is, with a string containing format specifiers followed by a list of corresponding arguments. All output from these functions is to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">所有这些函数都以与 &lt;code&gt;printf()&lt;/code&gt; 相同的方式调用，即，使用包含格式说明符的字符串，后跟相应的参数列表。这些函数的所有输出都将 &lt;code&gt;stderr&lt;/code&gt; 到stderr。</target>
        </trans-unit>
        <trans-unit id="52fc81f0ba111d2acbf6995d34d870aacab348cf" translate="yes" xml:space="preserve">
          <source>These functions are called for each object in an MIB when the MIB is unloaded or loaded, respectively.</source>
          <target state="translated">当MIB被卸载或加载时,分别对MIB中的每个对象调用这些函数。</target>
        </trans-unit>
        <trans-unit id="d9faf69dba0c1f70caf123cc3782e49dc958f249" translate="yes" xml:space="preserve">
          <source>These functions are described in detail in &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些功能在 &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt; 中详细介绍。</target>
        </trans-unit>
        <trans-unit id="fd7a6a1b98572c10143c1d93f4f329a609ec28fe" translate="yes" xml:space="preserve">
          <source>These functions are equivalent to the corresponding functions in module &lt;code&gt;dbg&lt;/code&gt;, but all calls are stored in the history. The history buffer makes it easy to create configuration files; the same trace environment can be set up many times, for example, to compare two test runs. It also reduces the amount of typing when using &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell.</source>
          <target state="translated">这些函数等效于 &lt;code&gt;dbg&lt;/code&gt; 模块中的相应函数，但是所有调用都存储在历史记录中。历史记录缓冲区使创建配置文件变得容易。可以多次设置相同的跟踪环境，例如，比较两个测试运行。当从Erlang shell中使用 &lt;code&gt;ttb&lt;/code&gt; 时，它还减少了键入量。</target>
        </trans-unit>
        <trans-unit id="158d67977a08a84d4924f2a647ba82873c18061b" translate="yes" xml:space="preserve">
          <source>These functions are explained in the following sections. See also &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt;, which describes the two functions used to activate and deactivate checkpoints.</source>
          <target state="translated">这些功能将在以下各节中说明。另请参阅 &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt; ，它描述了用于激活和停用检查点的两个功能。</target>
        </trans-unit>
        <trans-unit id="60e3f3ff3408849e7fd9edf60400f772dde55362" translate="yes" xml:space="preserve">
          <source>These functions are further described and exemplified in &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些功能将在 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt; 中进一步描述和举例说明。</target>
        </trans-unit>
        <trans-unit id="fa8057e2cae698872b37c80f8aa0f3fe06d7cf59" translate="yes" xml:space="preserve">
          <source>These functions are intended for interactive use in the Erlang shell only. The module prefix can be omitted.</source>
          <target state="translated">这些函数只用于在Erlang shell中的交互式使用,模块前缀可以省略。模块前缀可以省略。</target>
        </trans-unit>
        <trans-unit id="9545561ba594c4d5a35ac49f33ac5958ae1e125a" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging, and are not to be called from normal code. They are provided for convenience, allowing developers to avoid having to create their own custom state replacement functions.</source>
          <target state="translated">这些函数只是为了帮助调试,而不是从正常的代码中调用。提供这些函数是为了方便,让开发人员避免创建自己的自定义状态替换函数。</target>
        </trans-unit>
        <trans-unit id="b678d1c2ff800ccba92fa1081c74821cd431ce2f" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging. They are provided for convenience, allowing developers to avoid having to create their own state extraction functions and also avoid having to interactively extract the state from the return values of &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; while debugging.</source>
          <target state="translated">这些功能仅用于帮助调试。提供它们是为了方便，使开发人员可以不必创建自己的状态提取函数，也可以避免在调试时必须从 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; 的返回值中交互式提取状态。</target>
        </trans-unit>
        <trans-unit id="9805074016be864764142bf2ab2b984041e919be" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且新代码不得使用这些功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3ee8c4cccd9aad5a3a976e7ebf9dacddb3f7a5d" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且新代码不得使用这些功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82227a3a076544e3bda2b44fe272f5c2177cda00" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且新代码不得使用这些功能。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb8d168e922a05dff4b0cd171803a7675b2fbf08" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35c1fc44955a642a5777cca455981c0556303f1d" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请改用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5de333f99c5ead1d8115c4087c9a72a0f601d546" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">保留这些功能是为了向后兼容，并且不得由新代码使用。请使用 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 宏或 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="2d9a4daca1ac6f764626bf603aa4c73a5aa770a0" translate="yes" xml:space="preserve">
          <source>These functions are much slower than the ordinary store and load functions of &lt;code&gt;Mnesia&lt;/code&gt;. However, this is mainly intended for minor experiments and initial prototyping. The major advantage of these functions is that they are easy to use.</source>
          <target state="translated">这些功能比 &lt;code&gt;Mnesia&lt;/code&gt; 的普通存储和加载功能要慢得多。但是，这主要用于较小的实验和初始原型制作。这些功能的主要优点是易于使用。</target>
        </trans-unit>
        <trans-unit id="cc96780ae3ae54fcc394e1c818c2355204d00877" translate="yes" xml:space="preserve">
          <source>These functions are not thread safe.</source>
          <target state="translated">这些功能不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="8afae98b4e16a8e03fc3cf30a7699eb78e0fa80a" translate="yes" xml:space="preserve">
          <source>These functions are performed in a transaction context involving mechanisms, such as locking, logging, replication, checkpoints, subscriptions, and commit protocols. However, the same function can also be evaluated in other activity contexts.</source>
          <target state="translated">这些函数是在涉及机制的事务上下文中执行的,如锁定、日志、复制、检查点、订阅和提交协议。然而,同样的函数也可以在其他活动上下文中进行评估。</target>
        </trans-unit>
        <trans-unit id="d43be56fdde5e5de270664b9730584c3eb30df12" translate="yes" xml:space="preserve">
          <source>These functions are primarily intended for simplified testing of &lt;code&gt;.appup&lt;/code&gt; files. They are not run within the context of the &lt;code&gt;release_handler&lt;/code&gt; process. They must therefore &lt;strong&gt;not&lt;/strong&gt; be used together with calls to &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;, as this causes the &lt;code&gt;release_handler&lt;/code&gt; to end up in an inconsistent state.</source>
          <target state="translated">这些功能主要用于简化 &lt;code&gt;.appup&lt;/code&gt; 文件的测试。它们不在 &lt;code&gt;release_handler&lt;/code&gt; 进程的上下文中运行。因此，&lt;strong&gt;不得&lt;/strong&gt;将它们与对 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 的调用一起使用，因为这会导致 &lt;code&gt;release_handler&lt;/code&gt; 最终处于不一致状态。</target>
        </trans-unit>
        <trans-unit id="bfdb7ec140eb86cb272ecdbb50138f14fef17e5c" translate="yes" xml:space="preserve">
          <source>These functions are to be used with trace flag &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;'receive'&lt;/code&gt; for setting and clearing trace patterns.</source>
          <target state="translated">这些功能将与跟踪标志 &lt;code&gt;call&lt;/code&gt; ， &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 一起使用,以设置和清除跟踪模式。</target>
        </trans-unit>
        <trans-unit id="1f17b4d328843c30adfc4895bdc753282346f128" translate="yes" xml:space="preserve">
          <source>These functions can be called to retrieve information about the module.</source>
          <target state="translated">这些功能可以被调用来检索模块的信息。</target>
        </trans-unit>
        <trans-unit id="1311856f69e61fe882b7ae9bfc9de73ea32a8732" translate="yes" xml:space="preserve">
          <source>These functions can be used to find records in a table when it is impossible to write constraints for the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt;, or when you want to perform some action on certain records.</source>
          <target state="translated">当无法为函数 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 编写约束时，或者要对某些记录执行某些操作时，可以使用这些函数在表中查找记录。</target>
        </trans-unit>
        <trans-unit id="0186f872732540e967fd668deb3a4c289a66df35" translate="yes" xml:space="preserve">
          <source>These functions create or delete a table index on a field defined by &lt;code&gt;AttributeName&lt;/code&gt;. To illustrate this, add an index to the table definition &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt;, which is the example table from the &lt;code&gt;Company&lt;/code&gt; database. The function that adds an index on element &lt;code&gt;salary&lt;/code&gt; can be expressed as &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt;.</source>
          <target state="translated">这些函数在 &lt;code&gt;AttributeName&lt;/code&gt; 定义的字段上创建或删除表索引。为了说明这一点，在表定义中添加一个索引 &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt; ，这是 &lt;code&gt;Company&lt;/code&gt; 数据库中的示例表。可以在元素 &lt;code&gt;salary&lt;/code&gt; 上添加索引的函数可以表示为 &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b321dfec9cbea3824adf71432c75a84bb7f39aaa" translate="yes" xml:space="preserve">
          <source>These functions iterate over the &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;Tab&lt;/code&gt; and apply the function &lt;code&gt;Fun&lt;/code&gt; to each record. &lt;code&gt;Fun&lt;/code&gt; takes two arguments, the first is a record from the table, and the second is the accumulator. &lt;code&gt;Fun&lt;/code&gt; returns a new accumulator.</source>
          <target state="translated">这些函数遍历 &lt;code&gt;Mnesia&lt;/code&gt; 表 &lt;code&gt;Tab&lt;/code&gt; 然后将 &lt;code&gt;Fun&lt;/code&gt; 函数应用于每个记录。 &lt;code&gt;Fun&lt;/code&gt; 有两个参数，第一个是表中的记录，第二个是累加器。 &lt;code&gt;Fun&lt;/code&gt; 返回一个新的累加器。</target>
        </trans-unit>
        <trans-unit id="e2241c04aed6e2c04c16cc3d0bc2e51744dc9b5c" translate="yes" xml:space="preserve">
          <source>These functions match a &lt;code&gt;Pattern&lt;/code&gt; against all records in table &lt;code&gt;Tab&lt;/code&gt;. In a &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;Pattern&lt;/code&gt; is a part of &lt;code&gt;MatchSpecification&lt;/code&gt; described in the following. It is not necessarily performed as an exhaustive search of the entire table. By using indexes and bound values in the key of the pattern, the actual work done by the function can be condensed into a few hash lookups. Using &lt;code&gt;ordered_set&lt;/code&gt; tables can reduce the search space if the keys are partially bound.</source>
          <target state="translated">这些函数将 &lt;code&gt;Pattern&lt;/code&gt; 与表 &lt;code&gt;Tab&lt;/code&gt; 中的所有记录进行匹配。在 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; 调用中， &lt;code&gt;Pattern&lt;/code&gt; 是下面描述的 &lt;code&gt;MatchSpecification&lt;/code&gt; 的一部分。它不一定是对整个表的详尽搜索。通过在模式的键中使用索引和绑定值，该函数完成的实际工作可以简化为几个哈希查找。如果键是部分绑定的，则使用 &lt;code&gt;ordered_set&lt;/code&gt; 表可以减少搜索空间。</target>
        </trans-unit>
        <trans-unit id="4380dbd51df4c218d4fc67f122b3a31fa9dad5e7" translate="yes" xml:space="preserve">
          <source>These functions must return the current values of the associated variables.</source>
          <target state="translated">这些函数必须返回相关变量的当前值。</target>
        </trans-unit>
        <trans-unit id="d73e48f290f1971fad9fc4d6418f2f3ddc239932" translate="yes" xml:space="preserve">
          <source>These functions return a negative value indicating that an error occurred.</source>
          <target state="translated">这些函数返回一个负值,表示发生了错误。</target>
        </trans-unit>
        <trans-unit id="f2d4535f8dedc594af82a7502daf5f4472256bee" translate="yes" xml:space="preserve">
          <source>These functions return an open file descriptor on success, or a negative value indicating that an error occurred. In the latter case they set &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">这些函数在成功时返回打开的文件描述符，或者返回负值指示发生错误。在后一种情况下，他们将 &lt;code&gt;erl_errno&lt;/code&gt; 设置为以下之一：</target>
        </trans-unit>
        <trans-unit id="33b0bf879f0be35d9275b8556a8bb8e4605058f4" translate="yes" xml:space="preserve">
          <source>These functions return the number of bytes written to buffer on success, otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">这些函数返回成功时写入缓冲区的字节数，否则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="492a4ea8131a6460ecb2bb728f7492324b79c821" translate="yes" xml:space="preserve">
          <source>These functions returns &lt;code&gt;noError&lt;/code&gt; if the assignment was successful, otherwise an error code.</source>
          <target state="translated">如果分配成功，这些函数将返回 &lt;code&gt;noError&lt;/code&gt; ，否则返回错误代码。</target>
        </trans-unit>
        <trans-unit id="a52d30d9d64255b930d9d116fb319458b1376b07" translate="yes" xml:space="preserve">
          <source>These functions sends a signal to the outer space and the caller hopes that someone is listening. In other words, they invoke &lt;code&gt;et:trace_me/4&lt;/code&gt; and &lt;code&gt;et:trace_me/5&lt;/code&gt; respectively.</source>
          <target state="translated">这些功能将信号发送到外层空间，并且呼叫者希望有人正在监听。换句话说，它们分别调用 &lt;code&gt;et:trace_me/4&lt;/code&gt; 和 &lt;code&gt;et:trace_me/5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c5096edbc3525bc8e760ed1084c3016bcbfb9a7" translate="yes" xml:space="preserve">
          <source>These have the same meanings as the normal returns but the characters in &lt;code&gt;PushBackList&lt;/code&gt; will be prepended to the input characters and scanned for the next token. Note that pushing back a newline will mean the line numbering will no longer be correct.</source>
          <target state="translated">这些具有与正常返回相同的含义，但 &lt;code&gt;PushBackList&lt;/code&gt; 中的字符将被放在输入字符之前，并扫描下一个标记。请注意，推回换行符将意味着行号将不再正确。</target>
        </trans-unit>
        <trans-unit id="28abed6097a4fa5f0db1c6ca4ce80910586cfeeb" translate="yes" xml:space="preserve">
          <source>These heuristics are also used by &lt;code&gt;io:format/2&lt;/code&gt;, &lt;code&gt;io_lib:format/2&lt;/code&gt;, and friends when modifier &lt;code&gt;t&lt;/code&gt; is used with &lt;code&gt;~p&lt;/code&gt; or &lt;code&gt;~P&lt;/code&gt;:</source>
          <target state="translated">这些启发式也使用 &lt;code&gt;io:format/2&lt;/code&gt; ， &lt;code&gt;io_lib:format/2&lt;/code&gt; ，和朋友当改性剂 &lt;code&gt;t&lt;/code&gt; 使用具有 &lt;code&gt;~p&lt;/code&gt; 或 &lt;code&gt;~P&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="216fd64a35c1d2baaf5b3f037d998a945eb81f1e" translate="yes" xml:space="preserve">
          <source>These host entries are searched after all added with &lt;code&gt;{file, hosts, File}&lt;/code&gt; above or &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; below when lookup option &lt;code&gt;file&lt;/code&gt; is used.</source>
          <target state="translated">当使用查找选项 &lt;code&gt;file&lt;/code&gt; 时 &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; 全部添加上面的 &lt;code&gt;{file, hosts, File}&lt;/code&gt; 或下面的{host，IP，Aliases}来搜索这些主机条目。</target>
        </trans-unit>
        <trans-unit id="07700975c4ec0500ef74d72b43eae1d34a325990" translate="yes" xml:space="preserve">
          <source>These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurances of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is &lt;code&gt;otp_win64_21.exe&lt;/code&gt;.</source>
          <target state="translated">这些说明适用于32位和64位Windows。请注意，即使您构建64位版本的Erlang，所涉及的大多数目录和文件仍被命名为win32。但是，出现了一些名称为win64的情况。例如，用于64位Windows版本的Erlang的安装文件是 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a77e8aed44d3c5857cf64a2b419ef6f4260faa79" translate="yes" xml:space="preserve">
          <source>These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurrences of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is &lt;code&gt;otp_win64_23.exe&lt;/code&gt;.</source>
          <target state="translated">这些说明适用于32位和64位Windows。请注意，即使您构建64位版本的Erlang，所涉及的大多数目录和文件仍被命名为win32。但是，出现了一些名称为win64的情况。例如，用于64位Windows版本的Erlang的安装文件是 &lt;code&gt;otp_win64_23.exe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c394330d6ef054d071d8f890cc4c3711a8bdc95c" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to be used when it is considered an error that ports are open to a driver that no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has loaded. The ports that are still open when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;unload_driver/1&lt;/code&gt; or when the last process having the driver loaded dies, are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt;.</source>
          <target state="translated">当认为端口向没有 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 加载的驱动程序打开错误时，应使用这些接口。当最后一个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;unload_driver/1&lt;/code&gt; 或最后一个加载了驱动程序的进程死掉时，仍处于打开状态的端口由于 &lt;code&gt;driver_unloaded&lt;/code&gt; 原因而被杀死。</target>
        </trans-unit>
        <trans-unit id="976444f76eef13967574c5a3e92db1199465ca38" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c5c84c302204b5ad2412f8768bea313cd0255d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;agent_net_if_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7fa27f4823b4c40fb38224a9f2c44f5dc1ff3d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05b3a993da19e30da69e0542004935e23fe64b41" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">这些选项实际上特定于所使用的模块。此处显示的内容适用于默认的 &lt;code&gt;manager_net_if_module()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f52e46ef3067f96590cea6bfd8ffc4461c4cb9d7" translate="yes" xml:space="preserve">
          <source>These options are available when starting the name server. The name server is normally started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; (if not already available), but it can also be started at system startup.</source>
          <target state="translated">启动名称服务器时，这些选项可用。通常，名称服务器是通过命令 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 自动启动的（如果尚不可用），但是也可以在系统启动时启动。</target>
        </trans-unit>
        <trans-unit id="b991dcaf8a3c7fdb1bfc134be14dc32ae7b61b5d" translate="yes" xml:space="preserve">
          <source>These options are described in &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt; create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些选项在 &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt; create/3&lt;/a&gt;&lt;/code&gt; 中进行了描述。</target>
        </trans-unit>
        <trans-unit id="60feb775a5a2a0fc8f58b8ddfb26ab5e82088613" translate="yes" xml:space="preserve">
          <source>These options are described in &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些选项在 &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt; 中进行了描述。</target>
        </trans-unit>
        <trans-unit id="e6e76727821c709b0e581bace27e5e3b9ee3793f" translate="yes" xml:space="preserve">
          <source>These options are only for debugging and testing &lt;code&gt;epmd&lt;/code&gt; clients. They are not to be used in normal operation.</source>
          <target state="translated">这些选项仅用于调试和测试 &lt;code&gt;epmd&lt;/code&gt; 客户端。请勿在正常操作中使用它们。</target>
        </trans-unit>
        <trans-unit id="3184ea6ec742a62558f1e2dbf393dc6981719dd9" translate="yes" xml:space="preserve">
          <source>These options are preset by the &lt;code&gt;rename&lt;/code&gt; function and cannot be overridden by the user.</source>
          <target state="translated">这些选项由 &lt;code&gt;rename&lt;/code&gt; 功能预设，并且不能被用户覆盖。</target>
        </trans-unit>
        <trans-unit id="7d74113369f61132f3b23365e982841353df0d4a" translate="yes" xml:space="preserve">
          <source>These options make &lt;code&gt;epmd&lt;/code&gt; run as an interactive command, displaying the results of sending queries to an already running instance of &lt;code&gt;epmd&lt;/code&gt;. The &lt;code&gt;epmd&lt;/code&gt; contacted is always on the local node, but option &lt;code&gt;-port&lt;/code&gt; can be used to select between instances if several are running using different ports on the host.</source>
          <target state="translated">这些选项使 &lt;code&gt;epmd&lt;/code&gt; 作为交互式命令运行，显示将查询发送到已经运行的 &lt;code&gt;epmd&lt;/code&gt; 实例的结果。联系的 &lt;code&gt;epmd&lt;/code&gt; 始终在本地节点上，但是如果几个实例正在使用主机上的不同端口运行，则可以使用 &lt;code&gt;-port&lt;/code&gt; 选项在实例之间进行选择。</target>
        </trans-unit>
        <trans-unit id="e10be32239987c6f4a5a6c8dce5e7fc454e9dfca" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt;. For example, the following pattern changes the convention to CR:</source>
          <target state="translated">这些将覆盖默认值和指定为 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 的选项。例如，以下模式将约定更改为CR：</target>
        </trans-unit>
        <trans-unit id="76493b00ea7c71eb89b79e6053d97efaadb6e80f" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to the compiling function, but they can themselves be overridden by options specified to a matching function. Notice that these special settings, which are not Perl-compatible, are recognized only at the very start of a pattern, and that they must be in upper case. If more than one of them is present, the last one is used. They can be combined with a change of newline convention; for example, a pattern can start with:</source>
          <target state="translated">这些设置覆盖了默认值和指定给编译函数的选项,但是它们本身也可以被指定给匹配函数的选项所覆盖。请注意,这些特殊的设置并不兼容Perl,只有在模式的开头才会被识别,而且它们必须是大写的。如果它们中有一个以上的设置,则使用最后一个。它们可以与换行约定结合起来,例如,一个模式可以用以下开头。</target>
        </trans-unit>
        <trans-unit id="7c8826c9e11e1f3d846a339b100ceac99eba779d" translate="yes" xml:space="preserve">
          <source>These packet types only have effect on receiving. When sending a packet, it is the responsibility of the application to supply a correct header. On receiving, however, one message is sent to the controlling process for each complete packet received, and, similarly, each call to &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; returns one complete packet. The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">这些数据包类型仅对接收有效。发送数据包时，应用程序有责任提供正确的标头。但是，在接收时，对于接收到的每个完整数据包，将一条消息发送到控制过程，并且类似地，对 &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; 的每次调用都返回一个完整数据包。标头&lt;strong&gt;未&lt;/strong&gt;剥离。</target>
        </trans-unit>
        <trans-unit id="703061c1f2854688bcb586643b95905fd657c226" translate="yes" xml:space="preserve">
          <source>These parameters can be modified by the user with the following configuration term:</source>
          <target state="translated">这些参数可以由用户通过以下配置项进行修改。</target>
        </trans-unit>
        <trans-unit id="019f3eb722d3988d7298c6a669ca65df0fbbaa93" translate="yes" xml:space="preserve">
          <source>These questions are not always trivial to answer. Some benchmarks might be needed to back up your theory and to avoid making things slower if your theory is wrong. For details, see &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些问题并非总是微不足道的。如果您的理论是错误的，可能需要一些基准来支持您的理论并避免使事情变慢。有关详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="764b3f2b692c282ad0bd05c88a3b6913fb526534" translate="yes" xml:space="preserve">
          <source>These record definitions use the &quot;new&quot; spelling 'adaptation', not the deprecated 'adaption', regardless of which spelling the underlying C API uses.</source>
          <target state="translated">这些记录定义使用 &quot;新的 &quot;拼写 &quot;adaptation&quot;,而不是被废弃的 &quot;adapttion&quot;,无论底层C API使用哪种拼写。</target>
        </trans-unit>
        <trans-unit id="dc5ac270ae2ee1136906b421f96b332ee47c42ac" translate="yes" xml:space="preserve">
          <source>These relations are interpreted as follows: if we are in state &lt;code&gt;S&lt;/code&gt; and event &lt;code&gt;E&lt;/code&gt; occurs, we are to perform actions &lt;code&gt;A&lt;/code&gt; and make a transition to state &lt;code&gt;S'&lt;/code&gt;. Notice that &lt;code&gt;S'&lt;/code&gt; can be equal to &lt;code&gt;S&lt;/code&gt; and that &lt;code&gt;A&lt;/code&gt; can be empty.</source>
          <target state="translated">这些关系的解释如下：如果我们处于状态 &lt;code&gt;S&lt;/code&gt; 且发生事件 &lt;code&gt;E&lt;/code&gt; ，则我们将执行动作 &lt;code&gt;A&lt;/code&gt; 并转换为状态 &lt;code&gt;S'&lt;/code&gt; 。请注意， &lt;code&gt;S'&lt;/code&gt; 可以等于 &lt;code&gt;S&lt;/code&gt; ，而 &lt;code&gt;A&lt;/code&gt; 可以为空。</target>
        </trans-unit>
        <trans-unit id="ae00fb07c3a51201cd4652ed075fa902a7ed72cb" translate="yes" xml:space="preserve">
          <source>These relations are interpreted as follows: if we are in state &lt;code&gt;S&lt;/code&gt; and event &lt;code&gt;E&lt;/code&gt; occurs, we are to perform actions &lt;code&gt;A&lt;/code&gt;, and make a transition to state &lt;code&gt;S'&lt;/code&gt;. Notice that &lt;code&gt;S'&lt;/code&gt; can be equal to &lt;code&gt;S&lt;/code&gt;, and that &lt;code&gt;A&lt;/code&gt; can be empty.</source>
          <target state="translated">这些关系的解释如下：如果我们处于状态 &lt;code&gt;S&lt;/code&gt; 且发生事件 &lt;code&gt;E&lt;/code&gt; ，则我们将执行动作 &lt;code&gt;A&lt;/code&gt; ，并转换为状态 &lt;code&gt;S'&lt;/code&gt; 。请注意， &lt;code&gt;S'&lt;/code&gt; 可以等于 &lt;code&gt;S&lt;/code&gt; ，并且 &lt;code&gt;A&lt;/code&gt; 可以为空。</target>
        </trans-unit>
        <trans-unit id="663a0dde4969fddd76e6f124e908bc76a6818654" translate="yes" xml:space="preserve">
          <source>These services are controlled through the process &lt;code&gt;global_name_server&lt;/code&gt; that exists on every node. The global name server starts automatically when a node is started. With the term &lt;strong&gt;global&lt;/strong&gt; is meant over a system consisting of many Erlang nodes.</source>
          <target state="translated">这些服务通过每个节点上存在的进程 &lt;code&gt;global_name_server&lt;/code&gt; 进行控制。启动节点时，全局名称服务器将自动启动。术语&amp;ldquo; &lt;strong&gt;全局&amp;rdquo;&lt;/strong&gt;是指由许多Erlang节点组成的系统。</target>
        </trans-unit>
        <trans-unit id="18b3db7ac68ef66e01ea9e3110a4d7998bc037fb" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; when it is called with an &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过以下方式调用这些状态转换动作：从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; （使用 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt; 调用时），从 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 返回它们，或将其赋予 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f84a998101580824af52c1efde9742c062b4f3ac" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些状态转换动作可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或将它们赋予 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用。</target>
        </trans-unit>
        <trans-unit id="61a80d0c0fec3872bf24b97867cc3c3fed9d0143" translate="yes" xml:space="preserve">
          <source>These tests cannot (always) be done automatically when cross compiling. You usually do not need to set these variables.</source>
          <target state="translated">这些测试不能(总是)在交叉编译时自动完成。你通常不需要设置这些变量。</target>
        </trans-unit>
        <trans-unit id="2d05ecef6dec2328daa1fa8983fc44a7ac6b969f" translate="yes" xml:space="preserve">
          <source>These three BIFs do conversions that would be difficult (or impossible) to do in Erlang.</source>
          <target state="translated">这三个BIF可以完成在Erlang中很难(或不可能)完成的转换。</target>
        </trans-unit>
        <trans-unit id="9fc1faee4aad725a39321bd959c62d7b61fc838d" translate="yes" xml:space="preserve">
          <source>These three tables, &lt;code&gt;employees&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, and &lt;code&gt;projects&lt;/code&gt;, are made up of real records. The following database content is stored in the tables and is built on relationships. These tables are &lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, and &lt;code&gt;in_proj&lt;/code&gt;.</source>
          <target state="translated">这三个表 &lt;code&gt;employees&lt;/code&gt; ， &lt;code&gt;dept&lt;/code&gt; 和 &lt;code&gt;projects&lt;/code&gt; 由真实记录组成。以下数据库内容存储在表中，并且建立在关系上。这些表是 &lt;code&gt;manager&lt;/code&gt; ， &lt;code&gt;at_dep&lt;/code&gt; 和 &lt;code&gt;in_proj&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0128c9fb51c2ef33512e0f9218f6c647c34f70b" translate="yes" xml:space="preserve">
          <source>These time-out actions sets time-out &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些超时操作设置超时 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be4aeb784d73a7483bb30162082ef141d284732" translate="yes" xml:space="preserve">
          <source>These timeout actions sets timeout &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些超时操作设置超时 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1c1c65f29a414599f1da742468bf0977b89b3ea" translate="yes" xml:space="preserve">
          <source>These tuples are strictly monotonically ordered on the current runtime system instance according to creation time. It is important that the monotonic time is in the first element (the most significant element when comparing two-tuples). Using the monotonic time in the tuples, you can calculate time between events.</source>
          <target state="translated">这些元组在当前运行时系统实例上按照创建时间严格单调排序。重要的是,单调时间在第一个元素中(比较两个元组时最重要的元素)。使用元组中的单调时间,可以计算事件之间的时间。</target>
        </trans-unit>
        <trans-unit id="d52f80b222da3d294b0f671c73049263b3d9e584" translate="yes" xml:space="preserve">
          <source>These two functions are provided in the standard module &lt;code&gt;lists&lt;/code&gt;. &lt;code&gt;foreach&lt;/code&gt; takes a list and applies a fun to every element in the list. &lt;code&gt;map&lt;/code&gt; creates a new list by applying a fun to every element in a list. Going back to the shell, &lt;code&gt;map&lt;/code&gt; is used and a fun to add 3 to every element of a list:</source>
          <target state="translated">标准模块 &lt;code&gt;lists&lt;/code&gt; 中提供了这两个功能。 &lt;code&gt;foreach&lt;/code&gt; 获取一个列表，并对列表中的每个元素都添加了乐趣。 &lt;code&gt;map&lt;/code&gt; 通过将乐趣应用于列表中的每个元素来创建新列表。回到外壳，使用 &lt;code&gt;map&lt;/code&gt; 并为列表中的每个元素添加3的乐趣：</target>
        </trans-unit>
        <trans-unit id="4144563beb40dfa20763e7a44f564ed7df7e5fe8" translate="yes" xml:space="preserve">
          <source>These two functions have a similar structure. They both iterate over a list and do something to each element in the list. The &quot;something&quot; is passed on as an extra argument to the function that does this.</source>
          <target state="translated">这两个函数有类似的结构。它们都对一个列表进行迭代,并对列表中的每个元素做一些事情。这个 &quot;东西 &quot;是作为额外的参数传递给做这件事的函数的。</target>
        </trans-unit>
        <trans-unit id="6bf31d937cdb8656e463da3517deb67f3a158915" translate="yes" xml:space="preserve">
          <source>These two functions look up an executable program, with the specified name and a search path, in the same way as the underlying OS. &lt;code&gt;find_executable/1&lt;/code&gt; uses the current execution path (that is, the environment variable &lt;code&gt;PATH&lt;/code&gt; on Unix and Windows).</source>
          <target state="translated">这两个函数以与基础OS相同的方式查找具有指定名称和搜索路径的可执行程序。 &lt;code&gt;find_executable/1&lt;/code&gt; 使用当前的执行路径（即，Unix和Windows上的环境变量 &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e0d074a20ddd5e5f33562cc40bc5760ad507e2a6" translate="yes" xml:space="preserve">
          <source>These two pieces work in concert. Basically, the &lt;code&gt;Collector&lt;/code&gt; receives &lt;code&gt;Raw Trace Data&lt;/code&gt; and processes it into &lt;code&gt;Events&lt;/code&gt; in a &lt;code&gt;et&lt;/code&gt; specific format (defined in &lt;code&gt;et/include/et.hrl&lt;/code&gt;). The &lt;code&gt;Viewer&lt;/code&gt; interrogates the &lt;code&gt;Collector&lt;/code&gt; and displays an interactive representation of the data.</source>
          <target state="translated">这两个部分协同工作。基本上， &lt;code&gt;Collector&lt;/code&gt; 接收 &lt;code&gt;Raw Trace Data&lt;/code&gt; 并将其以 &lt;code&gt;et&lt;/code&gt; 特定格式（在 &lt;code&gt;et/include/et.hrl&lt;/code&gt; 中定义）处理为 &lt;code&gt;Events&lt;/code&gt; 。该 &lt;code&gt;Viewer&lt;/code&gt; 询问 &lt;code&gt;Collector&lt;/code&gt; 和显示数据的交互式表示。</target>
        </trans-unit>
        <trans-unit id="dda87b11f0a5cbea6a2795c81d6b6e5706e62c96" translate="yes" xml:space="preserve">
          <source>These two types are often not needed, as the socket automatically switches from &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;http_bin&lt;/code&gt; to &lt;code&gt;httph&lt;/code&gt;/&lt;code&gt;httph_bin&lt;/code&gt; internally after the first line is read. However, there can be occasions when they are useful, such as parsing trailers from chunked encoding.</source>
          <target state="translated">通常不需要这两种类型，因为在读取第一行之后， &lt;code&gt;httph_bin&lt;/code&gt; 内部自动从 &lt;code&gt;http&lt;/code&gt; / &lt;code&gt;http_bin&lt;/code&gt; 切换到 &lt;code&gt;httph&lt;/code&gt; / httph_bin。但是，有时可能有用，例如从分块编码中解析预告片。</target>
        </trans-unit>
        <trans-unit id="1c70e7bfedf23869960675efaf18a91ce706b0d2" translate="yes" xml:space="preserve">
          <source>These values can be used to determine order between events on the runtime system instance. That is, if both &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; and &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; are executed by different processes (or the same process) on the same runtime system instance and &lt;code&gt;X &amp;lt; Y&lt;/code&gt;, we know that &lt;code&gt;X&lt;/code&gt; was created before &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">这些值可用于确定运行时系统实例上事件之间的顺序。也就是说，如果 &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; 和 &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; 都由同一运行时系统实例上的不同进程（或同一进程）执行，并且 &lt;code&gt;X &amp;lt; Y&lt;/code&gt; ，我们知道即 &lt;code&gt;X&lt;/code&gt; 是之前创建 &lt;code&gt;Y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64037abeafa784d21870f15a8f477ebe7f35dde2" translate="yes" xml:space="preserve">
          <source>These variables currently have &lt;strong&gt;no&lt;/strong&gt; effect if you configure using the &lt;code&gt;configure&lt;/code&gt; script directly.</source>
          <target state="translated">这些变量目前有&lt;strong&gt;没有&lt;/strong&gt;影响，如果你是使用的 &lt;code&gt;configure&lt;/code&gt; 直接脚本。</target>
        </trans-unit>
        <trans-unit id="e4eeacbbfedd76f9009cc450f49274f9b8f50cf0" translate="yes" xml:space="preserve">
          <source>These verbs differ in exactly what kind of failure occurs when backtracking reaches them. The behavior described below is what occurs when the verb is not in a subroutine or an assertion. Subsequent sections cover these special cases.</source>
          <target state="translated">这些动词的不同之处在于当回溯到它们时,究竟会发生什么样的失败。下面描述的行为是当动词不在子程序或断言中时发生的行为。后面的章节会涉及这些特殊情况。</target>
        </trans-unit>
        <trans-unit id="2fdbca7f7f11b6cf955d9574790794bb8f837662" translate="yes" xml:space="preserve">
          <source>They are deprecated from 23.0 and for removal in 24.0.</source>
          <target state="translated">从23.0开始,它们就被取消了,并将在24.0中被移除。</target>
        </trans-unit>
        <trans-unit id="bcb7ed1357b82ff56473fd5066848225a0c020e2" translate="yes" xml:space="preserve">
          <source>They can also be combined with the (*UTF8), (*UTF), or (*UCP) special sequences. Inside a character class, \R is treated as an unrecognized escape sequence, and so matches the letter &quot;R&quot; by default.</source>
          <target state="translated">它们也可以与(*UTF8)、(*UTF)或(*UCP)特殊序列组合。在一个字符类中,\R被视为未识别的转义序列,因此默认与字母 &quot;R &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="4f19fb9eb943279dbf1aab1f1a7e9449243b24c1" translate="yes" xml:space="preserve">
          <source>They can then be used in either of the following ways:</source>
          <target state="translated">然后,它们可以以下列任何一种方式使用:</target>
        </trans-unit>
        <trans-unit id="f10af1c6b334490e5b1459d0c8bfcff29264cd5a" translate="yes" xml:space="preserve">
          <source>Thin space</source>
          <target state="translated">狭窄的空间</target>
        </trans-unit>
        <trans-unit id="6196f53beeed99bac9dd3ff39c523037e81c3134" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. If you still need to use it, always &lt;code&gt;call os:type()&lt;/code&gt; first.</source>
          <target state="translated">使用此功能前请三思。如果仍然需要使用它，请始终先 &lt;code&gt;call os:type()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea8743046d2b98d1556841772481beb6c8b7be7" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. Use module &lt;code&gt;filename&lt;/code&gt; if you want to inspect or build filenames in a portable way. Avoid matching on atom &lt;code&gt;Osname&lt;/code&gt;.</source>
          <target state="translated">使用此功能前请三思。如果要以便携式方式检查或生成文件名，请使用模块 &lt;code&gt;filename&lt;/code&gt; 名。避免在原子 &lt;code&gt;Osname&lt;/code&gt; 上匹配。</target>
        </trans-unit>
        <trans-unit id="3f8c7ac9b539ff01e43c48a7bf8bc197468de776" translate="yes" xml:space="preserve">
          <source>Third, its possible to alter the global default value in runtime by calling the function &lt;code&gt;&lt;a href=&quot;socket#use_registry-1&quot;&gt;use_registry/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第三，可以通过调用 &lt;code&gt;&lt;a href=&quot;socket#use_registry-1&quot;&gt;use_registry/1&lt;/a&gt;&lt;/code&gt; 函数在运行时更改全局默认值。</target>
        </trans-unit>
        <trans-unit id="7b64bf09f4307d3d16c58fc0bfca8ad10a7fe410" translate="yes" xml:space="preserve">
          <source>This &quot;bad&quot; state consists of a cluster of small and/or highly fragmented carriers located at the sentinel in the pool. The largest free block in such a &quot;bad&quot; carrier is rather small, making it unable to satisfy most allocation requests. As the search always started at the sentinel, any such &quot;bad&quot; carriers that had been left in the pool would eventually cluster together at the sentinel. All searches first have to skip past this cluster of &quot;bad&quot; carriers to reach a &quot;good&quot; carrier. When the cluster gets to the same size as the search limit, all searches will essentially fail.</source>
          <target state="translated">这种 &quot;坏 &quot;状态由位于池中哨兵处的小块和/或高度分散的载波群组成。这种 &quot;坏 &quot;载波中最大的空闲区块相当小,使得它无法满足大多数分配请求。由于搜索总是从哨兵处开始,任何这样的 &quot;坏 &quot;载波被留在池中,最终都会在哨兵处聚拢。所有的搜索首先要跳过这个 &quot;坏 &quot;载波集群,才能到达一个 &quot;好 &quot;载波。当群集的大小与搜索极限相同时,所有的搜索基本上都会失败。</target>
        </trans-unit>
        <trans-unit id="d592d2f7893043a1b846652e39ab1418e618bc4e" translate="yes" xml:space="preserve">
          <source>This (most common) scenario simply supports that each &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver loads it when needed and unloads it when no longer needed. The driver is always reference counted and as long as a process keeping the driver loaded is still alive, the driver is present in the system.</source>
          <target state="translated">此（最常见）方案仅支持驱动程序的每个 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 在需要时加载它，并在不再需要时卸载它。该驱动程序始终按引用计数，只要保持加载该驱动程序的进程仍处于活动状态，该驱动程序就存在于系统中。</target>
        </trans-unit>
        <trans-unit id="cb6a47e588a181452c326fa39e3e06a8bbaf215e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;at_dep&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;at_dep&lt;/code&gt; 记录具有Erlang元组表示形式 &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb50969a4322693220f1622878a187ec8ef7865" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;employee&lt;/code&gt; record has the Erlang record/tuple representation &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;employee&lt;/code&gt; 记录具有Erlang记录/元组表示形式 &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6f78a7a573f4788a961abb21d13018ab8263739" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;in_proj&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;in_proj&lt;/code&gt; 记录具有Erlang元组表示形式 &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30eaf1b61fcff886440404502320b8087244781b" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how a simple manager can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">本&lt;strong&gt;实施示例&lt;/strong&gt;部分介绍了如何使用SNMP开发工具包实施简单的管理器。</target>
        </trans-unit>
        <trans-unit id="ffdeda27af47f2d41561b45e8678ebc080646b29" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how an MIB can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">本&lt;strong&gt;实施示例&lt;/strong&gt;部分介绍了如何使用SNMP开发工具包实施MIB。</target>
        </trans-unit>
        <trans-unit id="90786d1bedc2d134f9012ff5026a27ec4ce6ae1d" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;transition action&lt;/strong&gt; can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以通过从 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 或将其提供给 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 来调用此&lt;strong&gt;转换动作&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8285515d6a8ffd60d079855281d19dbb335db5a" translate="yes" xml:space="preserve">
          <source>This BIF can be removed in a future version of the Beam machine without prior warning. It is unlikely to be implemented in other Erlang implementations.</source>
          <target state="translated">这个BIF可以在未来的Beam机器版本中被删除,而不会事先警告。它不太可能在其他Erlang实现中实现。</target>
        </trans-unit>
        <trans-unit id="d2c9f52ffa82790c5add5ce609c3b465fa6b5f87" translate="yes" xml:space="preserve">
          <source>This BIF is always to be used for hashing terms. It distributes small integers better than &lt;code&gt;phash/2&lt;/code&gt;, and it is faster for bignums and binaries.</source>
          <target state="translated">此BIF始终用于哈希术语。它比 &lt;code&gt;phash/2&lt;/code&gt; 更好地分配小整数，并且对于bignums和binaries分配更快。</target>
        </trans-unit>
        <trans-unit id="ca02fa554a6262c386a3db4a859b0b9b57b609dd" translate="yes" xml:space="preserve">
          <source>This BIF is documented for completeness. Usually &lt;code&gt;is_record/2&lt;/code&gt; is to be used.</source>
          <target state="translated">记录此BIF是为了完整性。通常使用 &lt;code&gt;is_record/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83e449dcefb700e8a09d27413d7037f287088ef7" translate="yes" xml:space="preserve">
          <source>This BIF is intended for &lt;strong&gt;debugging only&lt;/strong&gt;. For all other purposes, use &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt; process_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此BIF仅用于&lt;strong&gt;调试&lt;/strong&gt;。对于所有其他目的，请使用 &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt; process_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e919cc7df793008049931bcf01d09ffb06683260" translate="yes" xml:space="preserve">
          <source>This BIF is intended for &lt;strong&gt;debugging only&lt;/strong&gt;. For all other purposes, use &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此BIF仅用于&lt;strong&gt;调试&lt;/strong&gt;。对于所有其他目的，请使用 &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b16cda9185776fda7cf953473f68ed8eae22005c" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging and is not to be used in application programs.</source>
          <target state="translated">这个BIF是用来调试的,不能用在应用程序中。</target>
        </trans-unit>
        <trans-unit id="3a485a9d729fff78ad515ca89ab62a61dc168854" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging only.</source>
          <target state="translated">此BIF仅用于调试。</target>
        </trans-unit>
        <trans-unit id="33eab8a0dcb284396b1bdbf0824f52f98a707748" translate="yes" xml:space="preserve">
          <source>This BIF is intended for the code server (see &lt;code&gt;code(3)&lt;/code&gt;) and is not to be used elsewhere.</source>
          <target state="translated">此BIF用于代码服务器（请参阅 &lt;code&gt;code(3)&lt;/code&gt; ），并且不能在其他地方使用。</target>
        </trans-unit>
        <trans-unit id="bbc3f97203615ffb6be54801dfb7bad70393f210" translate="yes" xml:space="preserve">
          <source>This BIF is mainly intended for debugging, but it can sometimes be useful in library functions that need to verify, for example, the arity of a fun.</source>
          <target state="translated">这个BIF主要是为了调试,但有时在需要验证的库函数中也很有用,例如,一个fun的arity。</target>
        </trans-unit>
        <trans-unit id="ed42f39086e8ec9c7b1c29cd5a589cf6f72ca9ff" translate="yes" xml:space="preserve">
          <source>This BIF is useful for builders of cross-reference tools.</source>
          <target state="translated">这个BIF对交叉参考工具的构建者很有用。</target>
        </trans-unit>
        <trans-unit id="c6cc75865613bc58e0eb7ecb4f457c6d233e733d" translate="yes" xml:space="preserve">
          <source>This DNS client can resolve DNS records even if it is not used for normal name resolving in the node.</source>
          <target state="translated">该DNS客户端即使不用于节点的正常名称解析,也可以解析DNS记录。</target>
        </trans-unit>
        <trans-unit id="babe61c293ec427280b1edacc01c731077dee4c0" translate="yes" xml:space="preserve">
          <source>This Efficiency Guide cannot really teach you how to write efficient code. It can give you a few pointers about what to avoid and what to use, and some understanding of how certain language features are implemented. This guide does not include general tips about optimization that works in any language, such as moving common calculations out of loops.</source>
          <target state="translated">本效率指南不能真正教你如何编写高效的代码。它可以为你提供一些关于什么是应该避免的,什么是应该使用的指针,以及对某些语言特性如何实现的一些理解。本指南不包括在任何语言中都有效的关于优化的一般提示,例如将常用计算移出循环。</target>
        </trans-unit>
        <trans-unit id="ae1ff29eb10c59731ea6c65a3606a80e84b3335c" translate="yes" xml:space="preserve">
          <source>This Erlang/OTP application supplies a framework for building applications that needs to utilize the Megaco/H.248 protocol.</source>
          <target state="translated">这个Erlang/OTP应用程序为构建需要利用Megaco/H.248协议的应用程序提供了一个框架。</target>
        </trans-unit>
        <trans-unit id="b18f63f410f90b5069c9dc2f1ae77d811c62158c" translate="yes" xml:space="preserve">
          <source>This MIB is not loaded by default.</source>
          <target state="translated">该MIB默认不加载。</target>
        </trans-unit>
        <trans-unit id="a407b3d8ce92982dd769f80205472707dd33acd9" translate="yes" xml:space="preserve">
          <source>This MIB is now loaded into the agent, and a manager can ask questions. As an example of this, we start another Erlang system and the simple Erlang manager in the toolkit:</source>
          <target state="translated">现在这个MIB已经加载到代理中,经理可以提出问题。作为一个例子,我们启动另一个Erlang系统和工具箱中的简单Erlang管理器。</target>
        </trans-unit>
        <trans-unit id="8bee977533f2540fecf48c418b1e1c4b1c9441e8" translate="yes" xml:space="preserve">
          <source>This PCRE pattern solves the nested parentheses problem (assume that option &lt;code&gt;extended&lt;/code&gt; is set so that whitespace is ignored):</source>
          <target state="translated">此PCRE模式解决了嵌套括号问题（假定已设置 &lt;code&gt;extended&lt;/code&gt; 选项，以便忽略空格）：</target>
        </trans-unit>
        <trans-unit id="ba3b1c781a2b003455c5f276cc7adab4167d61a9" translate="yes" xml:space="preserve">
          <source>This Reference Manual describes the Mnesia API. This includes functions that define and manipulate Mnesia tables.</source>
          <target state="translated">本参考手册介绍了Mnesia API。这包括定义和操作Mnesia表的函数。</target>
        </trans-unit>
        <trans-unit id="5a1ea321f8ef4337012dd060505384a468b6d8b6" translate="yes" xml:space="preserve">
          <source>This Reference Manual uses a table of persons to illustrate various examples. The following record definition is assumed:</source>
          <target state="translated">本《参考手册》使用人员表来说明各种例子。假设记录定义如下:</target>
        </trans-unit>
        <trans-unit id="eba208a5a64a9fe2d23e89684b28919d090b1bf5" translate="yes" xml:space="preserve">
          <source>This User's Guide describes how to build Mnesia database applications, and how to integrate and use the Mnesia database management system with OTP. Programming constructs are described, and numerous programming examples are included to illustrate the use of Mnesia.</source>
          <target state="translated">本用户指南介绍了如何建立Mnesia数据库应用程序,以及如何将Mnesia数据库管理系统与OTP集成和使用。本指南描述了编程结构,并包括许多编程实例,以说明Mnesia的使用。</target>
        </trans-unit>
        <trans-unit id="4f455597a879e8e0b44bd2b0f60e41d0029eaba8" translate="yes" xml:space="preserve">
          <source>This User's Guide describes the documentation storage format initially described in &lt;code&gt;&lt;a href=&quot;https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html&quot;&gt;EEP-48&lt;/a&gt;&lt;/code&gt;. By standardizing how API documentation is stored, it will be possible to write tools that work across languages.</source>
          <target state="translated">本用户指南介绍了 &lt;code&gt;&lt;a href=&quot;https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html&quot;&gt;EEP-48&lt;/a&gt;&lt;/code&gt; 中最初介绍的文档存储格式。通过标准化API文档的存储方式，可以编写跨语言工作的工具。</target>
        </trans-unit>
        <trans-unit id="d7c2e051140679b5fabfd3850166d5e44acd182d" translate="yes" xml:space="preserve">
          <source>This User's Guide is organized as follows:</source>
          <target state="translated">本用户指南的组织结构如下。</target>
        </trans-unit>
        <trans-unit id="6e07c970a29206fa6177bb430aa23651cee332f1" translate="yes" xml:space="preserve">
          <source>This access functions example shows how &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; can be implemented using &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; from outside the module:</source>
          <target state="translated">此访问函数示例演示如何从模块外部使用 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; 实现 &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e453611cc830c0fe9b4a7d78e62c5d3c550a27db" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">这将在整个表 &lt;code&gt;Tab&lt;/code&gt; 上获得 &lt;code&gt;LockKind&lt;/code&gt; 类型的锁。</target>
        </trans-unit>
        <trans-unit id="f91dd38ac67f0332e475b1b711e06f95a62ba56f" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the global resource &lt;code&gt;GlobalKey&lt;/code&gt;. The lock is acquired on all active nodes in the &lt;code&gt;Nodes&lt;/code&gt; list.</source>
          <target state="translated">该收购类型的锁 &lt;code&gt;LockKind&lt;/code&gt; 对全球资源 &lt;code&gt;GlobalKey&lt;/code&gt; 。将在&amp;ldquo; &lt;code&gt;Nodes&lt;/code&gt; 列表中的所有活动节点上获取锁定。</target>
        </trans-unit>
        <trans-unit id="c854770bc65f05e5983d655656fa66f6c7914156" translate="yes" xml:space="preserve">
          <source>This action does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; but instead stores the specified &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; for insertion after all actions have been executed.</source>
          <target state="translated">此操作不设置任何 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; ，而是存储指定的 &lt;code&gt;EventType&lt;/code&gt; 和 &lt;code&gt;EventContent&lt;/code&gt; 以便在执行所有操作后插入。</target>
        </trans-unit>
        <trans-unit id="52b66d36db3f8d918f682c24c470f8a1a0d1add9" translate="yes" xml:space="preserve">
          <source>This action does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead stores the specified &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; for insertion after all actions have been executed.</source>
          <target state="translated">此操作不设置任何 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; ，而是存储指定的 &lt;code&gt;EventType&lt;/code&gt; 和 &lt;code&gt;EventContent&lt;/code&gt; 以便在执行所有操作后插入。</target>
        </trans-unit>
        <trans-unit id="49d5b8cf3248f457c3e4fd7bf845d80256d7c600" translate="yes" xml:space="preserve">
          <source>This actually is a simulation of the process &lt;code&gt;Events&lt;/code&gt; caused by a &lt;code&gt;Mnesia&lt;/code&gt; transaction that writes a record in a local table:</source>
          <target state="translated">这实际上是对 &lt;code&gt;Mnesia&lt;/code&gt; 事务引起的流程 &lt;code&gt;Events&lt;/code&gt; 的模拟，该事务在本地表中写入一条记录：</target>
        </trans-unit>
        <trans-unit id="dbd8d5b06b09c15de60879a1a8a9947df8335726" translate="yes" xml:space="preserve">
          <source>This address family only works on Unix-like systems.</source>
          <target state="translated">这个地址族只适用于类Unix系统。</target>
        </trans-unit>
        <trans-unit id="b5576569da19d1b2e935e949277425b3e7400242" translate="yes" xml:space="preserve">
          <source>This address format is for now experimental and for completeness to make all address families have a &lt;code&gt;{Family, Destination}&lt;/code&gt; representation.</source>
          <target state="translated">此地址格式目前处于试验阶段，并且为了使所有地址系列都具有 &lt;code&gt;{Family, Destination}&lt;/code&gt; 表示形式，是完整的。</target>
        </trans-unit>
        <trans-unit id="63d593ef2ab6f3e8b14006b9f741f5c521ea7089" translate="yes" xml:space="preserve">
          <source>This affects the access logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">这会影响由 &lt;code&gt;mod_log&lt;/code&gt; 和 &lt;code&gt;mod_disk_log&lt;/code&gt; 编写的访问日志。</target>
        </trans-unit>
        <trans-unit id="2fd1765db5e4a1421a5a77cd061597e64ef02887" translate="yes" xml:space="preserve">
          <source>This affects the error logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">这会影响由 &lt;code&gt;mod_log&lt;/code&gt; 和 &lt;code&gt;mod_disk_log&lt;/code&gt; 写入的错误日志。</target>
        </trans-unit>
        <trans-unit id="bbd6bb60897f850ec49a0aac99503d287bd1842d" translate="yes" xml:space="preserve">
          <source>This allows info events to pass through to the default handler, and be printed to the terminal as well. If there are many info events, it can be useful to print these to a file instead.</source>
          <target state="translated">这允许信息事件传递到默认的处理程序,并打印到终端。如果有很多信息事件,可以将这些事件打印到文件中。</target>
        </trans-unit>
        <trans-unit id="23e19f7d8ad7331e73f9393236fe1782f10bda23" translate="yes" xml:space="preserve">
          <source>This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl's &lt;code&gt;/x&lt;/code&gt; option, and it can be changed within a pattern by a &lt;code&gt;(?x)&lt;/code&gt; option setting.</source>
          <target state="translated">这还会导致在字符类外部的未转义的＃与下一个换行符（包括）之间的字符被忽略。这等效于Perl的 &lt;code&gt;/x&lt;/code&gt; 选项，并且可以通过 &lt;code&gt;(?x)&lt;/code&gt; 选项设置在模式内进行更改。</target>
        </trans-unit>
        <trans-unit id="58f3cb66f380a5c19ef8ab400cfe6287edaa6dfa" translate="yes" xml:space="preserve">
          <source>This also means that if a user implement their own transport service then it has to maintain its own statistics.</source>
          <target state="translated">这也意味着,如果用户实现了自己的传输服务,那么就必须维护自己的统计数据。</target>
        </trans-unit>
        <trans-unit id="6e14170723475328c130ae9f6473e132cd1b01e7" translate="yes" xml:space="preserve">
          <source>This and also previous implementation do not work well when the table is nearly full. We will both get long search times for free slots, and we will reuse identifiers more frequently since we more frequently wrap during the search. These tables works best when the table is much larger than the amount of simultaneous existing processes. One easy improvement is to always have room for more processes than we allow in the table. This will also be implemented in the next release, but this should probably also be worked more on trying to find an even better solution.</source>
          <target state="translated">当表快满的时候,这个和之前的实现都不能很好地工作。我们都会得到较长的空闲槽的搜索时间,而且我们会更频繁地重用标识符,因为我们在搜索过程中会更频繁地缠绕。当表比同时存在的进程量大得多时,这些表的效果最好。一个简单的改进是,总是有空间容纳比我们在表中允许的更多进程。这也将在下一个版本中实现,但这可能也应该在试图找到一个更好的解决方案上多下功夫。</target>
        </trans-unit>
        <trans-unit id="c7dd22038e1768c05bfb1a8b06817075c1c09560" translate="yes" xml:space="preserve">
          <source>This appendix describes the conversion of SNMPv2 to SNMPv1 error messages. The instrumentation functions should return v2 error messages.</source>
          <target state="translated">本附录描述了SNMPv2到SNMPv1错误信息的转换。仪表功能应返回v2错误信息。</target>
        </trans-unit>
        <trans-unit id="87860fce150658815e0dd8f84b7b2d2085183f77" translate="yes" xml:space="preserve">
          <source>This application covers all features of ASN.1 up to the 1997 edition of the specification. In the 2002 edition, new features were introduced. The following features of the 2002 edition are fully or partly supported:</source>
          <target state="translated">本应用程序涵盖1997年版规范之前ASN.1的所有功能。在2002年版中,引入了新的功能。完全或部分支持2002年版的下列特征:</target>
        </trans-unit>
        <trans-unit id="569634e92b8ce1ce008d5489ba01f7e7d69d8d45" translate="yes" xml:space="preserve">
          <source>This application has been deprecated and will be removed in a furture release.</source>
          <target state="translated">该应用已被废弃,将在后续版本中删除。</target>
        </trans-unit>
        <trans-unit id="dfc6af9c7770c0d0747ed2380e862e5393774125" translate="yes" xml:space="preserve">
          <source>This application provides an Erlang interface to communicate with relational SQL-databases. It is built on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to the database that you want to connect to.</source>
          <target state="translated">这个应用程序提供了一个Erlang接口来与关系型SQL数据库进行通信,它是建立在Microsofts ODBC接口之上的,因此需要你有一个连接到数据库的ODBC驱动。它建立在Microsofts ODBC接口之上,因此需要你有一个连接到数据库的ODBC驱动。</target>
        </trans-unit>
        <trans-unit id="33c8dd3d5797a890a9a711bb22cf2594354b0bee" translate="yes" xml:space="preserve">
          <source>This approach is always preferred over the other alternatives described below. This both from a performance perspective and a system characteristics perspective.</source>
          <target state="translated">这种方法总是优于下文所述的其他选择。无论是从性能的角度还是从系统特性的角度来看,都是如此。</target>
        </trans-unit>
        <trans-unit id="8068bc8d1c806d61b5dde8f35515f5de0ccd108c" translate="yes" xml:space="preserve">
          <source>This approach is probably easier for an Erlanger but if you need to use real XSLT stylesheets in order to &quot;comply to the standard&quot; there is an adapter available to the Sablotron XSLT package which is written i C++. See also the &lt;code&gt;Tutorial&lt;/code&gt;.</source>
          <target state="translated">对于Erlanger来说，这种方法可能更容易，但是如果您需要使用真实的XSLT样式表以&amp;ldquo;符合标准&amp;rdquo;，则可以使用用C ++编写的Sablotron XSLT软件包提供一个适配器。另请参见 &lt;code&gt;Tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f62d188dacb48bbbcc2b2321f9f579397d8bbfe1" translate="yes" xml:space="preserve">
          <source>This associates the name &lt;code&gt;a&lt;/code&gt; with the top-level &lt;code&gt;node&lt;/code&gt; entry. For this to work, the configuration file must at least contain:</source>
          <target state="translated">这会将名称 &lt;code&gt;a&lt;/code&gt; 与顶级 &lt;code&gt;node&lt;/code&gt; 条目相关联。为此，配置文件必须至少包含：</target>
        </trans-unit>
        <trans-unit id="3e34095000c0319f418ac3ee68cd3bf8ccd8bc10" translate="yes" xml:space="preserve">
          <source>This assumes that this is the first line of the input text, and that &lt;code&gt;'$end'&lt;/code&gt; is the distinguished &lt;code&gt;end_of_input&lt;/code&gt; symbol.</source>
          <target state="translated">假定这是输入文本的第一行，并且 &lt;code&gt;'$end'&lt;/code&gt; 是专有的 &lt;code&gt;end_of_input&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="821b03bacc21c4d7e259e58631986fc8983788a2" translate="yes" xml:space="preserve">
          <source>This attribute is to be specified first and is the only mandatory attribute.</source>
          <target state="translated">这个属性要先指定,而且是唯一的强制性属性。</target>
        </trans-unit>
        <trans-unit id="d5e89f840b948b0e856ea77d5bc34a2eb62f41fa" translate="yes" xml:space="preserve">
          <source>This attribute is used by tools, such as Yecc, to inform the compiler that the source program is generated by another tool. It also indicates the correspondence of source files to lines of the original user-written file, from which the source program is produced.</source>
          <target state="translated">这个属性被Yecc等工具用来通知编译器源程序是由其他工具生成的。它还表明源文件与用户编写的原始文件的行数的对应关系,源程序就是从该文件中产生的。</target>
        </trans-unit>
        <trans-unit id="d9c8cd0265b456f941da20d0c6f623c0e29a3c55" translate="yes" xml:space="preserve">
          <source>This attribute names a function that is to be run automatically when a module is loaded. For more information, see &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt; Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该属性命名了一个功能，该功能在加载模块时将自动运行。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt; Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e21a2982771a0d227b0a5afc10f4b081e89b3ac5" translate="yes" xml:space="preserve">
          <source>This attribute names a function that is to be run automatically when a module is loaded. For more information, see &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此属性命名一个在模块加载时自动运行的函数。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1862f101a5a9233b48a831149fc7167f1c97802b" translate="yes" xml:space="preserve">
          <source>This automatically starts the error logger event manager, and adds &lt;code&gt;error_logger&lt;/code&gt; as a handler to Logger, with the following configuration:</source>
          <target state="translated">这将自动启动错误记录器事件管理器，并使用以下配置将 &lt;code&gt;error_logger&lt;/code&gt; 作为处理程序添加到Logger中：</target>
        </trans-unit>
        <trans-unit id="ce539a9df53bac997ca6cb301b22b25cdb3ea47c" translate="yes" xml:space="preserve">
          <source>This avoids TCP's TIME_WAIT state, but leaves open the possibility that another &quot;incarnation&quot; of this connection being created.</source>
          <target state="translated">这就避免了TCP的TIME_WAIT状态,但留下了这个连接被创建的另一个 &quot;化身 &quot;的可能性。</target>
        </trans-unit>
        <trans-unit id="3fdb9b714260fc3296ea31ac0070bb8141246799" translate="yes" xml:space="preserve">
          <source>This behavior appeared in Erlang/OTP 19.0.</source>
          <target state="translated">这个行为出现在Erlang/OTP 19.0中。</target>
        </trans-unit>
        <trans-unit id="b6abecdecbe55a6c353c6503f8fff17fe757dd78" translate="yes" xml:space="preserve">
          <source>This behavior appeared in Erlang/OTP 19.0. In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; was introduced. In OTP 20.0 the &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">此行为出现在Erlang / OTP 19.0中。在OTP 19.1中，对 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 的返回元组进行了向后不兼容的更改，并引入了强制性的回调函数 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 。在OTP 20.0中，添加了 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="785543b1d2c442c04e0906335bd46635b1eb96f6" translate="yes" xml:space="preserve">
          <source>This behavior can be controlled through command-line flag &lt;code&gt;-code_path_choice Choice&lt;/code&gt;. If the flag is set to &lt;code&gt;relaxed&lt;/code&gt;, the code server instead chooses a suitable directory depending on the actual file structure. If a regular application &lt;code&gt;ebin&lt;/code&gt; directory exists, it is chosen. Otherwise, the directory &lt;code&gt;ebin&lt;/code&gt; in the archive is chosen if it exists. If neither of them exists, the original directory is chosen.</source>
          <target state="translated">可以通过命令行标志 &lt;code&gt;-code_path_choice Choice&lt;/code&gt; 来控制此行为。如果该标志设置为 &lt;code&gt;relaxed&lt;/code&gt; ，则代码服务器将根据实际文件结构选择合适的目录。如果存在常规应用程序 &lt;code&gt;ebin&lt;/code&gt; 目录，则将其选中。否则，将选择存档中的目录 &lt;code&gt;ebin&lt;/code&gt; （如果存在）。如果它们都不存在，则选择原始目录。</target>
        </trans-unit>
        <trans-unit id="53636ccb870bbfa8ce6166a610a444015328245d" translate="yes" xml:space="preserve">
          <source>This behavior module implements the back end of the Erlang tracing system. The functions in this module are called whenever a trace probe is triggered. Both the &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;trace&lt;/code&gt; functions are called in the context of the entity that triggered the trace probe. This means that the overhead by having the tracing enabled is greatly effected by how much time is spent in these functions. So, do as little work as possible in these functions.</source>
          <target state="translated">该行为模块实现了Erlang跟踪系统的后端。每当触发跟踪探测时，就会调用此模块中的功能。在触发跟踪探针的实体的上下文中调用了已 &lt;code&gt;enabled&lt;/code&gt; 和 &lt;code&gt;trace&lt;/code&gt; 功能。这意味着启用跟踪功能的开销在这些功能中花费了多少时间而受到很大影响。因此，在这些功能中要做的工作尽可能少。</target>
        </trans-unit>
        <trans-unit id="23ed37aa93d3cb97e2709aafd5c39ba7bb1b8c68" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see &lt;code&gt; Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块提供了一个监督者桥，该过程将未按照OTP设计原则设计的子系统连接到监督树。主管桥位于主管和子系统之间。它的行为就像是其自己的主管的真实主管，但与真实子系统的子系统具有不同的界面。有关更多信息，请参见OTP设计原则中的 &lt;code&gt; Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70c20f09b1094d916dd54fcb5f009aa1d7c32e52" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块提供了一个监督者桥，该过程将未根据OTP设计原则设计的子系统连接到监督树。主管网桥位于主管与子系统之间。它的行为就像是其自己的主管的真正主管，但与子系统的真正主管具有不同的界面。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d78ebb85e52ea715b460d534876e2e64780e260" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see &lt;code&gt; Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">此行为模块提供了一个主管，一个监督其他进程（称为子进程）的进程。子进程可以是另一个主管或工作进程。通常使用 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 行为之一实现工作进程。使用此模块实现的主管具有一组标准的接口功能，并且包括用于跟踪和错误报告的功能。监督程序用于构建称为监督树的分层过程结构，这是构建容错应用程序的一种好方法。有关更多信息，请参见OTP设计原则中的 &lt;code&gt; Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce3316c8111b9876ff9b5ef8da2949d18e1dd45d" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">此行为模块提供了一个主管，一个监督其他进程（称为子进程）的进程。子进程可以是另一个主管或工作进程。通常使用 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 行为之一来实现工作进程。使用此模块实现的主管具有一组标准的接口功能，并且包括用于跟踪和错误报告的功能。监督程序用于构建称为监督树的分层过程结构，这是构建容错应用程序的一种好方法。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d6df5b9b0f7a74dbafdab8bc790e47d7e7f9481" translate="yes" xml:space="preserve">
          <source>This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically.</source>
          <target state="translated">该行为模块提供事件处理功能。它由一个通用的事件管理器进程组成,该进程具有任意数量的事件处理程序,可以动态地添加和删除。</target>
        </trans-unit>
        <trans-unit id="80aef52a4a9d2d5e57ced3f744cf231173e5382d" translate="yes" xml:space="preserve">
          <source>This behavior module provides the server of a client-server relation. A generic server process (&lt;code&gt;gen_server&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section &lt;code&gt; gen_server Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块为服务器提供了客户端-服务器关系。使用此模块实现的通用服务器进程（ &lt;code&gt;gen_server&lt;/code&gt; ）具有一组标准的接口功能，并包括用于跟踪和错误报告的功能。它还适合于OTP监管树。有关更多信息，请参见OTP设计原则中的 &lt;code&gt; gen_server Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abfb5bf41909c33228afc455141ff017bc6cbde2" translate="yes" xml:space="preserve">
          <source>This behavior module provides the server of a client-server relation. A generic server process (&lt;code&gt;gen_server&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section &lt;code&gt;gen_server Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">该行为模块为服务器提供了客户端-服务器关系。使用此模块实现的通用服务器进程（ &lt;code&gt;gen_server&lt;/code&gt; ）具有一组标准的接口功能，并包括用于跟踪和错误报告的功能。它也适合OTP监管树。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;gen_server Behaviour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73e10e87f957712b985d39a62945e43bbfb9c199" translate="yes" xml:space="preserve">
          <source>This behaviour is different from how it worked prior to Erlang/OTP 19.0. Before 19.0 the literal check was done by checking if the pointer pointed to the young or old heap block. If it did not, then it was considered a literal. This lead to considerable overhead and strange memory usage scenarios, so it was removed in 19.0.</source>
          <target state="translated">这种行为与Erlang/OTP 19.0之前的工作方式不同。在19.0之前,文字检查是通过检查指针是指向年轻的还是老的堆块来完成的。如果不是,那么它就被认为是一个字面意义。这导致了相当大的开销和奇怪的内存使用情况,所以在19.0中被删除了。</target>
        </trans-unit>
        <trans-unit id="cfe536c202221de15418e3b0398e40a018dac1a4" translate="yes" xml:space="preserve">
          <source>This binds variable &lt;code&gt;B&lt;/code&gt; to integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">这将变量 &lt;code&gt;B&lt;/code&gt; 绑定到整数 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5921d4e93c827b7d95c4a9acb4bbf5b9f3ecb5c5" translate="yes" xml:space="preserve">
          <source>This brand and version may be changed with the option &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt;. We start a daemon with that option:</source>
          <target state="translated">可以使用选项 &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt; 更改此品牌和版本。我们使用该选项启动守护程序：</target>
        </trans-unit>
        <trans-unit id="43864d6a93dcab0bbcc900bd0174b5bbab1fdc75" translate="yes" xml:space="preserve">
          <source>This call is equivalent to &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt;:</source>
          <target state="translated">此调用等效于 &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5d23eee97c1eb9e0a1493c034b0bfc305e9ddf21" translate="yes" xml:space="preserve">
          <source>This call is used with connection-based socket types (&lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;seqpacket&lt;/code&gt;). It extracs the first pending connection request for the listen socket and returns the (newly) connected socket.</source>
          <target state="translated">该调用与基于连接的套接字类型（ &lt;code&gt;stream&lt;/code&gt; 或 &lt;code&gt;seqpacket&lt;/code&gt; ）一起使用。它为侦听套接字提取第一个未决的连接请求，并返回（新连接的）套接字。</target>
        </trans-unit>
        <trans-unit id="0cb45c675dbc6c57c7e83453d414ea4d5859f32a" translate="yes" xml:space="preserve">
          <source>This callback format consumes much memory, as the whole response must be generated before it is sent to the user. This callback format is deprecated. For new development, use &lt;code&gt;Module:Function/3&lt;/code&gt;.</source>
          <target state="translated">这种回调格式会消耗大量内存，因为必须在将整个响应发送给用户之前生成整个响应。不建议使用此回调格式。对于新开发，请使用 &lt;code&gt;Module:Function/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c021922a0bcd25050486be93ca9a01fe228c8b3e" translate="yes" xml:space="preserve">
          <source>This callback function is mandatory.</source>
          <target state="translated">这个回调函数是必须的。</target>
        </trans-unit>
        <trans-unit id="19c59aed8326cb258e589ba8cff9c5c632aa9fd0" translate="yes" xml:space="preserve">
          <source>This callback function is optional.</source>
          <target state="translated">这个回调函数是可选的。</target>
        </trans-unit>
        <trans-unit id="f25d747572c59dd9f293a1f0fcfc6c190d3c0ac9" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;. In it any side effects needed by the tracer are to be done. The tracepoint payload is located in the &lt;code&gt;TraceTerm&lt;/code&gt;. The content of the &lt;code&gt;TraceTerm&lt;/code&gt; depends on which &lt;code&gt;TraceTag&lt;/code&gt; is triggered. &lt;code&gt;TraceTerm&lt;/code&gt; corresponds to the fourth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。在此过程中，将完成示踪剂所需的任何副作用。跟踪点有效负载位于 &lt;code&gt;TraceTerm&lt;/code&gt; 中。 &lt;code&gt;TraceTerm&lt;/code&gt; 的内容取决于触发了哪个 &lt;code&gt;TraceTag&lt;/code&gt; 。 &lt;code&gt;TraceTerm&lt;/code&gt; 对应于 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt; 中描述的跟踪元组中的第四个元素。</target>
        </trans-unit>
        <trans-unit id="38e550ff4f657cf80a8775b069566d9feb16c83b" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;. In it any side effects needed by the tracer are to be done. The tracepoint payload is located in the &lt;code&gt;TraceTerm&lt;/code&gt;. The content of the &lt;code&gt;TraceTerm&lt;/code&gt; depends on which &lt;code&gt;TraceTag&lt;/code&gt; is triggered. &lt;code&gt;TraceTerm&lt;/code&gt; corresponds to the fourth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。在此过程中，将完成示踪剂所需的任何副作用。跟踪点有效负载位于 &lt;code&gt;TraceTerm&lt;/code&gt; 中。 &lt;code&gt;TraceTerm&lt;/code&gt; 的内容取决于触发了哪个 &lt;code&gt;TraceTag&lt;/code&gt; 。 &lt;code&gt;TraceTerm&lt;/code&gt; 对应于 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 中描述的跟踪元组中的第四个元素。</target>
        </trans-unit>
        <trans-unit id="b5b2df4ee795088b10e9a8743810a608e160f791" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt; Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt; Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="d37d000bba6ae99564128c8b7446cc5273b6a04e" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="09e7a6fd7ae94a8b204e4555cbdb97edc835e6f0" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt; Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt; Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="15198a7c2fc8240482ba94b944bdfc0b14e586ba" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="7b7f965ceb723c3e428aae9e712be01c5751a24c" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt; Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt; Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="2aa5dde256677cc6703eaf4ec5d19bc2b8283932" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="de8b6dabb1b9aedf64269ee027289b838928ff19" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt; Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt; Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="6dcc032a652781d3a4cff57f32134bdf4ec6b88d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="3c07c7052c71939e18500a6ffce1aa3ea1692a61" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt; Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt; Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="cfff3392a7d289ca0c61ca7155845689c03dcb44" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="389d25478a53bcbad4b00f57b0c975a597be05f0" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt; Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt; Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="c24bf92b0df20158eb77c36643c943e9fdb3807a" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="eedf109955855e438df9878211bbefe0268cab51" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt; Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt; Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="b6742c8972ca63b4eed6ff400182d4ad91035680" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="9102deaae3699fe52f8c3288eb5f0454907ef640" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt; Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt; Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="6f48d6f8f965dcfd900008bb64742372d353ae2d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">当触发跟踪点并且 &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; 回调返回 &lt;code&gt;trace&lt;/code&gt; 时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="7d06f96f4aade9b952b7ce9c8005f3b70b23dcd8" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint is triggered. It allows the tracer to decide whether a trace is to be generated or not. This check is made as early as possible to limit the amount of overhead associated with tracing. If &lt;code&gt;trace&lt;/code&gt; is returned, the necessary trace data is created and the trace callback of the tracer is called. If &lt;code&gt;discard&lt;/code&gt; is returned, this trace call is discarded and no call to trace is done.</source>
          <target state="translated">每当触发跟踪点时，都会调用此回调。它允许跟踪程序决定是否要生成跟踪。尽早进行此检查，以限制与跟踪相关的开销。如果返回 &lt;code&gt;trace&lt;/code&gt; ，则将创建必要的跟踪数据，并调用跟踪器的跟踪回调。如果返回 &lt;code&gt;discard&lt;/code&gt; ，则此跟踪调用将被丢弃，并且不会完成对跟踪的调用。</target>
        </trans-unit>
        <trans-unit id="d90dbf0e78bbedf9e4bcbc34379a7cf3dd298fa5" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; running_procs | running&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当具有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; running_procs | running&lt;/a&gt;&lt;/code&gt; 的跟踪点被调用时，都会调用此回调。运行被触发。</target>
        </trans-unit>
        <trans-unit id="94e6048cf0014e861feb66ee170c873413ff3161" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="6fa7e2961f153a4436cefe4499cc280336994838" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当具有跟踪标志的跟踪点调用时，都会调用此回调 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; 被触发。</target>
        </trans-unit>
        <trans-unit id="69b3512c1f3ede51a7ecf30950dad7b0634b3377" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="04e6a249465c46d45e283c5f1f0285668b198409" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="af6001baab0a6ade22947ab13bfa31245cf0abe6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="0be59b7c2110146187e5c0eeaf4bc0878afe0cb6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="334c413e0dbeba2235f5db1ca4ea0969695570e1" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当具有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; 的跟踪点被调用时，都会调用此回调。运行被触发。</target>
        </trans-unit>
        <trans-unit id="7c04ab99901eac2f63941068c90d7843bba53367" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">每当触发带有跟踪标志 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 的跟踪点时，都会调用此回调。</target>
        </trans-unit>
        <trans-unit id="69eb6ef56ec8902494bd21822d312f399e05340c" translate="yes" xml:space="preserve">
          <source>This callback is delegated to the &lt;code&gt;ssh_file&lt;/code&gt; module.</source>
          <target state="translated">此回调委托给 &lt;code&gt;ssh_file&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="0eb3991244f8edb7b0e0b02b52e72b978996b94e" translate="yes" xml:space="preserve">
          <source>This callback is mandatory.</source>
          <target state="translated">这个回调是必须的。</target>
        </trans-unit>
        <trans-unit id="945a522c510e59f03864e9eeb3d8a618307d8e56" translate="yes" xml:space="preserve">
          <source>This callback is optional, so a callback module does not need to export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation of this function that returns &lt;code&gt;{State,Data}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块不需要导出它。该 &lt;code&gt;gen_statem&lt;/code&gt; 模块提供此功能的默认实现，它返回 &lt;code&gt;{State,Data}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53a31bbe3f39f2d360082e09b97e8bd9a8a3c01e" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/4&lt;/code&gt; is not implemented the process will crash with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果在未实现 &lt;code&gt;code_change/4&lt;/code&gt; 的情况下进行了 &lt;code&gt;.appup&lt;/code&gt; 文件中指定的 &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; 发行版升级/降级，则该过程将因退出原因 &lt;code&gt;undef&lt;/code&gt; 而崩溃。</target>
        </trans-unit>
        <trans-unit id="adab3ff296df418bda26c9ab38b8afebec6b2122" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the event handler will crash with an &lt;code&gt;undef&lt;/code&gt; error reason.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果未实现 &lt;code&gt;code_change/3&lt;/code&gt; 时，在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的发行版升级/降级，则事件处理程序将因 &lt;code&gt;undef&lt;/code&gt; 错误原因而崩溃。</target>
        </trans-unit>
        <trans-unit id="02bb4941fa7a9741c99ed42c9b52e91f322657b1" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/4&lt;/code&gt; is not implemented the process will crash with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果在未实现 &lt;code&gt;code_change/4&lt;/code&gt; 的情况下在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的发行版升级/降级，则该过程将因退出原因 &lt;code&gt;undef&lt;/code&gt; 而崩溃。</target>
        </trans-unit>
        <trans-unit id="09246fb26a04b28ca2f447f072f0daaf17b1ea05" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the process will crash with an &lt;code&gt;undef&lt;/code&gt; exit reason.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。如果未实施 &lt;code&gt;code_change/3&lt;/code&gt; 时在 &lt;code&gt;appup&lt;/code&gt; 文件中指定了带有 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 的版本升级/降级，则该过程将因 &lt;code&gt;undef&lt;/code&gt; 退出原因而崩溃。</target>
        </trans-unit>
        <trans-unit id="449de06640c440754deb50b818d7f03da9dfc15a" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_event&lt;/code&gt; 模块提供此功能的默认实现，大约意想不到的日志 &lt;code&gt;Info&lt;/code&gt; 的消息，删除它，然后返回 &lt;code&gt;{noreply, State}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cfc4d1b1611e681e7a69a610747f2faafb9e670" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_event&lt;/code&gt; 模块提供此功能的默认实现，大约意想不到的日志 &lt;code&gt;Info&lt;/code&gt; 的消息，删除它并返回 &lt;code&gt;{ok, State}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="642a938f2c13878b19e630eed4ff743e43a98666" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_event&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="33b5eb4eda106379d214a532dea20df13c6ee4a7" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供此功能的默认实现，大约意想不到的日志 &lt;code&gt;Info&lt;/code&gt; 的消息，删除它，然后返回 &lt;code&gt;{noreply, State}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0950a9f920ccec0ce58fea7dd4cc52647d84000" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that returns the callback module state.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供这个函数，返回回调模块状态的默认实现。</target>
        </trans-unit>
        <trans-unit id="d3374de84ad48d0fa717caa3233068cba7f0a810" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_server&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="ed16700adf3de2342c41a38a47218a24b4797c88" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">此回调是可选的，因此回调模块无需导出它。该 &lt;code&gt;gen_statem&lt;/code&gt; 模块提供不清理的默认实现。</target>
        </trans-unit>
        <trans-unit id="b14aaa8a71c534451d8b2fa83d586d1d7132b252" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need to export it only if they return &lt;code&gt;{continue,Continue}&lt;/code&gt; from another callback. If continue is used and the callback is not implemented, the process will exit with &lt;code&gt;undef&lt;/code&gt; error.</source>
          <target state="translated">此回调是可选的，因此仅当回调模块从另一个回调返回 &lt;code&gt;{continue,Continue}&lt;/code&gt; 时，才需要导出该回调。如果使用continue并且未实现回调，则该过程将退出，并显示 &lt;code&gt;undef&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="d62e7ff4624439456f6274f30841bc2cd438369b" translate="yes" xml:space="preserve">
          <source>This callback is optional, so event handler modules need not export it. If a handler does not export this function, the &lt;code&gt;gen_event&lt;/code&gt; module uses the handler state directly for the purposes described below.</source>
          <target state="translated">此回调是可选的，因此事件处理程序模块无需导出它。如果处理程序未导出此函数，则 &lt;code&gt;gen_event&lt;/code&gt; 模块将为以下所述目的直接使用处理程序状态。</target>
        </trans-unit>
        <trans-unit id="a8935ee23c0cb706a83f87286f51dc3308c662e0" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;accept_handshake_complete&lt;/code&gt; field in the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">此回调是可选的。如果未实现，请将 &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 结构中的 &lt;code&gt;accept_handshake_complete&lt;/code&gt; 字段设置为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c513a3136958e118a1ed88eed71f06f5a1ba1689" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;connect_handshake_complete&lt;/code&gt; field in the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">此回调是可选的。如果未实现，请将 &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 结构中的 &lt;code&gt;connect_handshake_complete&lt;/code&gt; 字段设置为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0e38e8024185274ef8f80ab9c3c0eabdc425b5d" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;writev&lt;/code&gt; field in the the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">此回调是可选的。如果未实现， &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 结构中的 &lt;code&gt;writev&lt;/code&gt; 字段设置为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e665adac2e338eb903db4caf99617c276a94da3" translate="yes" xml:space="preserve">
          <source>This callback may also return the port of the given node. In that case &lt;code&gt;port_please/3&lt;/code&gt; may be omitted.</source>
          <target state="translated">此回调也可能返回给定节点的端口。在这种情况下，可以省略 &lt;code&gt;port_please/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="220a2abc00984810bc967fbaf4c4a46c06726d6c" translate="yes" xml:space="preserve">
          <source>This can also be achieved in a more customized way by using parameter &lt;code&gt;export&lt;/code&gt; in the cover specification and analysing the result off line. However, the cross cover mechanism is a built-in solution that also provides logging.</source>
          <target state="translated">也可以通过使用封面规范中的参数 &lt;code&gt;export&lt;/code&gt; 并离线分析结果，以更加定制的方式来实现。但是，跨封面机制是一种内置解决方案，还提供了日志记录。</target>
        </trans-unit>
        <trans-unit id="d55911e226611b9c595d6a76da5448bc48c50a57" translate="yes" xml:space="preserve">
          <source>This can be defined as follows, but is faster:</source>
          <target state="translated">可定义如下,但速度更快。</target>
        </trans-unit>
        <trans-unit id="051b7b690babeaa0408d0d0c0e8d2f3f38cca0df" translate="yes" xml:space="preserve">
          <source>This can be done, for example, by focusing on one state at the time and for every state ensure that all events are handled. Alternatively, you can focus on one event at the time and ensure that it is handled in every state. You can also use a mix of these strategies.</source>
          <target state="translated">例如,可以通过同时关注一个状态,并为每个状态确保所有事件都被处理来实现。或者,你也可以每次只关注一个事件,并确保在每个状态下都能处理它。你也可以混合使用这些策略。</target>
        </trans-unit>
        <trans-unit id="d4598fb964d80c17b9042cf3810c56c1f2f70ecf" translate="yes" xml:space="preserve">
          <source>This can be the name of a binary log, a list of such logs, or the name of a directory containing one or more binary logs.</source>
          <target state="translated">这可以是一个二进制日志的名称,这样的日志的列表,或包含一个或多个二进制日志的目录的名称。</target>
        </trans-unit>
        <trans-unit id="0d49d5ccf3611383b79c9580f8c0026d786e3ee8" translate="yes" xml:space="preserve">
          <source>This can be used for various purposes, for example, writing a term to a file in an efficient way, or sending an Erlang term to some type of communications channel not supported by distributed Erlang.</source>
          <target state="translated">这可以用于各种目的,例如,以一种有效的方式将一个术语写入文件,或者将一个Erlang术语发送到分布式Erlang不支持的某种通信通道。</target>
        </trans-unit>
        <trans-unit id="a87fd0d612d477544f48342a46839027b50293f1" translate="yes" xml:space="preserve">
          <source>This can be used to detect problems with NIFs or drivers that take too long to execute. 1 ms is considered a good maximum time for a driver callback or a NIF. However, a time-sharing system is usually to consider everything &amp;lt; 100 ms as &quot;possible&quot; and fairly &quot;normal&quot;. However, longer schedule times can indicate swapping or a misbehaving NIF/driver. Misbehaving NIFs and drivers can cause bad resource utilization and bad overall system performance.</source>
          <target state="translated">这可用于检测NIF或驱动程序执行所需时间太长的问题。 1 ms被认为是驱动程序回调或NIF的最佳最长时间。但是，分时系统通常会将所有&amp;lt;100 ms的内容视为&amp;ldquo;可能&amp;rdquo;且相当&amp;ldquo;正常&amp;rdquo;。但是，较长的调度时间可能表示交换或NIF /驱动程序行为异常。 NIF和驱动程序的行为不当会导致资源利用率下降和整体系统性能下降。</target>
        </trans-unit>
        <trans-unit id="7c309ba8d110cc132caf3f434048be18fd8c888d" translate="yes" xml:space="preserve">
          <source>This can be useful to know, even if &lt;code&gt;systools&lt;/code&gt; is not used, since Erlang/OTP is packaged according to the OTP principles and thus comes with a specific directory structure. The code server (see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel) automatically uses code from the directory with the highest version number, if more than one version of an application is present.</source>
          <target state="translated">即使不使用 &lt;code&gt;systools&lt;/code&gt; ，这也很有用，因为Erlang / OTP是根据OTP原则打包的，因此带有特定的目录结构。如果存在一个应用程序的多个版本，则代码服务器（请参阅内核中的 &lt;code&gt;code(3)&lt;/code&gt; 手册页）自动使用目录中具有最高版本号的代码。</target>
        </trans-unit>
        <trans-unit id="c0a78708d83a11d18d7b6fde7a226d981a5c9a17" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to hold arbitrary terms: skip them and copy the binary term data to some buffer.</source>
          <target state="translated">当你想保存任意项时,这很有用:跳过它们,将二进制项数据复制到某个缓冲区。</target>
        </trans-unit>
        <trans-unit id="9dccf3f6d2f60b79a3b5bd80d61cef8142d3c9f1" translate="yes" xml:space="preserve">
          <source>This can occur even if a &lt;code&gt;reload&lt;/code&gt; option is specified, if &lt;code&gt;DriverOptionList&lt;/code&gt; differs from the current.</source>
          <target state="translated">即使 &lt;code&gt;DriverOptionList&lt;/code&gt; 与当前选项不同，即使指定了 &lt;code&gt;reload&lt;/code&gt; 选项，也会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="e696f35629ec0f432c29538e2e6c58a6cd4c896e" translate="yes" xml:space="preserve">
          <source>This can override the configuration parameters &lt;code&gt;nameserver&lt;/code&gt; and &lt;code&gt;search&lt;/code&gt; depending on the contents of the specified file. They can also change any time in the future reflecting the file contents.</source>
          <target state="translated">这可以覆盖配置参数 &lt;code&gt;nameserver&lt;/code&gt; 并根据指定文件的内容进行 &lt;code&gt;search&lt;/code&gt; 。它们还可以在将来的任何时间更改以反映文件内容。</target>
        </trans-unit>
        <trans-unit id="8dec9a62f192435d695441ed01fd661a8d8c315a" translate="yes" xml:space="preserve">
          <source>This causes &lt;code&gt;epmd&lt;/code&gt; to close the connection from the far end. Notice that if the name was in fact still in use by a node, the results of this operation are unpredictable. Also, doing this does not cause the local end of the connection to close, so resources can be consumed.</source>
          <target state="translated">这导致 &lt;code&gt;epmd&lt;/code&gt; 从远端关闭连接。请注意，如果该名称实际上仍被节点使用，则此操作的结果是不可预测的。同样，这样做不会导致连接的本地端关闭，因此可以消耗资源。</target>
        </trans-unit>
        <trans-unit id="b14b393bb418a216b0875dc8287af117dd7067bb" translate="yes" xml:space="preserve">
          <source>This causes a parse transform to substitute a fun for the QLC. The (compiled) fun is called when the query handle is evaluated.</source>
          <target state="translated">这将导致一个解析变换来代替QLC的fun。当查询句柄被评估时,这个(编译的)fun被调用。</target>
        </trans-unit>
        <trans-unit id="6b5f81b2ddca32cf291bc3217d330648ab91cbde" translate="yes" xml:space="preserve">
          <source>This causes a warning for an unused variable, &lt;code&gt;Elem&lt;/code&gt;, if the code is compiled with the flag &lt;code&gt;warn_unused_vars&lt;/code&gt; set. Instead, the code can be rewritten to:</source>
          <target state="translated">如果代码在设置了 &lt;code&gt;warn_unused_vars&lt;/code&gt; 标志的情况下编译，则会对未使用的变量 &lt;code&gt;Elem&lt;/code&gt; 发出警告。相反，可以将代码重写为：</target>
        </trans-unit>
        <trans-unit id="6cb1d2e7687337b9f0ef3870a3a41bbcb1151114" translate="yes" xml:space="preserve">
          <source>This causes outstanding megaco:call/3 requests to return. The callback functions UserMod:handle_reply/4 and UserMod:handle_trans_ack/4 are also invoked where it applies. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">这将导致未完成的megaco:call/3请求返回。回调函数 UserMod:handle_reply/4 和 UserMod:handle_trans_ack/4 也会在适用的地方被调用。关于回调参数的更多信息,请参见 megaco_user 模块。</target>
        </trans-unit>
        <trans-unit id="68c0a11988374396554e35c1339e4b4d296f9cbb" translate="yes" xml:space="preserve">
          <source>This causes the variable to be lifted (after parsing) to the next higher level in the syntax tree, replacing that entire subtree. In this case, the &lt;code&gt;'@_@Name'/0&lt;/code&gt; will be replaced with &lt;code&gt;'@@Name'&lt;/code&gt;, and the &lt;code&gt;/0&lt;/code&gt; part was just used as dummy notation and will be discarded.</source>
          <target state="translated">这导致变量在语法树中被提升（在解析之后）到更高的级别，从而替换了整个子树。在这种情况下， &lt;code&gt;'@_@Name'/0&lt;/code&gt; 将替换为 &lt;code&gt;'@@Name'&lt;/code&gt; ，并且 &lt;code&gt;/0&lt;/code&gt; 部分仅用作虚拟符号，并将被丢弃。</target>
        </trans-unit>
        <trans-unit id="9ae4d618ecb9ded2a891114f68fd094d009bf146" translate="yes" xml:space="preserve">
          <source>This chapter aims at explaining the differences and giving a rationale for why Erlang/OTP handles &quot;user&quot; as it does.</source>
          <target state="translated">这一章的目的是解释两者之间的差异,并给出为什么Erlang/OTP要这样处理 &quot;用户 &quot;的理由。</target>
        </trans-unit>
        <trans-unit id="84078e161475adc15a1fe15da8646e8557d4b551" translate="yes" xml:space="preserve">
          <source>This chapter briefly describes Erlang records derived from ASN.1 specifications used to handle public key infrastructure. The scope is to describe the data types of each component, not the semantics. For information on the semantics, refer to the relevant standards and RFCs linked in the sections below.</source>
          <target state="translated">本章简要介绍了源于ASN.1规范的Erlang记录,用于处理公钥基础设施。范围是描述每个组件的数据类型,而不是语义。关于语义的信息,请参考下面章节中链接的相关标准和RFC。</target>
        </trans-unit>
        <trans-unit id="b2f23bd1830ba030caede6017d114b23d96a8156" translate="yes" xml:space="preserve">
          <source>This chapter contains in extenso versions of the OpenSSL and SSLeay licenses.</source>
          <target state="translated">本章包含OpenSSL和SSLeay许可证的扩展版本。</target>
        </trans-unit>
        <trans-unit id="6b1d044a8e1dfdfc0b3ead8b82c9c3d5d936b5ef" translate="yes" xml:space="preserve">
          <source>This chapter describes FIPS mode support in the crypto application.</source>
          <target state="translated">本章介绍加密应用中的FIPS模式支持。</target>
        </trans-unit>
        <trans-unit id="5241988387a67e2c505ee80c2f8d37b1169baacf" translate="yes" xml:space="preserve">
          <source>This chapter describes details of algorithms in the crypto application.</source>
          <target state="translated">本章介绍了加密应用中算法的细节。</target>
        </trans-unit>
        <trans-unit id="5f466e689949ed0c106ed58e883f29857cfc9906" translate="yes" xml:space="preserve">
          <source>This chapter describes the new api to encryption and decryption.</source>
          <target state="translated">本章介绍了新的加密和解密的api。</target>
        </trans-unit>
        <trans-unit id="ffd1f44c4ed57b40721b93cf5c0efd3d78d52a33" translate="yes" xml:space="preserve">
          <source>This chapter describes the support for loading encryption engines in the crypto application.</source>
          <target state="translated">本章介绍了对加密应用中加载加密引擎的支持。</target>
        </trans-unit>
        <trans-unit id="84e8d13b539f47c00293308a5f44715292e8675e" translate="yes" xml:space="preserve">
          <source>This chapter describes the support in the crypto application for using public and private keys stored in encryption engines.</source>
          <target state="translated">本章介绍了加密应用中对使用存储在加密引擎中的公钥和私钥的支持。</target>
        </trans-unit>
        <trans-unit id="66dda50ba5ba17ea40a6d362cc6e7f81e1f3b82a" translate="yes" xml:space="preserve">
          <source>This chapter is about creating such a system, which is called a &lt;strong&gt;target system&lt;/strong&gt;.</source>
          <target state="translated">本章是关于创建这样的系统的，该系统称为&lt;strong&gt;目标系统&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="303cc2fd7c07d62117308f568c6c7a69cd42b456" translate="yes" xml:space="preserve">
          <source>This checks that the pid &lt;code&gt;From&lt;/code&gt; is in the &lt;code&gt;User_List&lt;/code&gt;:</source>
          <target state="translated">这将检查pid &lt;code&gt;From&lt;/code&gt; 是否在 &lt;code&gt;User_List&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="d13a092e40b41fbf6f89dd0baee37b0578462112" translate="yes" xml:space="preserve">
          <source>This clause is equivalent to &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;send(Socket, Host, Port, [], Packet)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此子句等效于 &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;send(Socket, Host, Port, [], Packet)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd754cddd9c96097f025a6b91734f43531e07dcf" translate="yes" xml:space="preserve">
          <source>This closes the Erlang/OTP shell.</source>
          <target state="translated">这将关闭Erlang/OTP shell。</target>
        </trans-unit>
        <trans-unit id="7d1fa1715e259b26d3b25f592aabf2747c705ee2" translate="yes" xml:space="preserve">
          <source>This code adds a set of people to the database. Running this code within one transaction ensures that either the whole family is added to the database, or the whole transaction terminates. For example, if the last child is badly formatted, or the executing process terminates because of an &lt;code&gt;'EXIT'&lt;/code&gt; signal while executing the family code, the transaction terminates. Thus, the situation where half a family is added can never occur.</source>
          <target state="translated">此代码将一组人员添加到数据库中。在一个事务中运行此代码可确保将整个族添加到数据库中，或者整个事务终止。例如，如果最后一个子文件的格式不正确，或者由于执行家族代码时由于 &lt;code&gt;'EXIT'&lt;/code&gt; 信号而导致执行过程终止，则事务终止。因此，永远不会出现增加一半家庭的情况。</target>
        </trans-unit>
        <trans-unit id="98b115ab987715d60781ca89e47fa4411fb40cb5" translate="yes" xml:space="preserve">
          <source>This code behaves differently from &quot;&lt;code&gt;--&lt;/code&gt;&quot; if the lists contain duplicate elements (one occurrence of an element in HugeList2 removes &lt;strong&gt;all&lt;/strong&gt; occurrences in HugeList1.)</source>
          <target state="translated">如果列表包含重复的元素，则此代码的行为与&amp;ldquo; &lt;code&gt;--&lt;/code&gt; &amp;rdquo; 不同（HugeList2中元素的一次出现会删除HugeList1中的&lt;strong&gt;所有&lt;/strong&gt;出现。）</target>
        </trans-unit>
        <trans-unit id="620f0e09a670821d9a2abe04fa98afa74a5ef2a9" translate="yes" xml:space="preserve">
          <source>This code is easier to write and to understand, and it also executes much faster.</source>
          <target state="translated">这种代码更容易写,也更容易理解,而且执行起来也更快。</target>
        </trans-unit>
        <trans-unit id="92fb78009d0b11b8b67edb3a1a517f7f5d300af8" translate="yes" xml:space="preserve">
          <source>This code lock state machine can be implemented using &lt;code&gt;gen_statem&lt;/code&gt; with the following &lt;strong&gt;callback module&lt;/strong&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;gen_statem&lt;/code&gt; 和以下&lt;strong&gt;回调模块&lt;/strong&gt;来实现此代码锁定状态机：</target>
        </trans-unit>
        <trans-unit id="c2b34933ffae95b8a853f8ff645604fbd952d3ab" translate="yes" xml:space="preserve">
          <source>This code lock state machine can be implemented using &lt;code&gt;gen_statem&lt;/code&gt; with the following callback module:</source>
          <target state="translated">可以使用 &lt;code&gt;gen_statem&lt;/code&gt; 和以下回调模块来实现此代码锁定状态机：</target>
        </trans-unit>
        <trans-unit id="7b2443919e593a0d589592796a6acfa56ef58bd8" translate="yes" xml:space="preserve">
          <source>This code uses the function &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; instead of the function &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; The function &lt;code&gt;s_write/1&lt;/code&gt; sets a sticky lock instead of a normal lock. If the table is not replicated, sticky locks have no special effect. If the table is replicated, and a sticky lock is set on node &lt;code&gt;N1&lt;/code&gt;, this lock then sticks to node &lt;code&gt;N1&lt;/code&gt;. The next time you try to set a sticky lock on the same record at node &lt;code&gt;N1&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; detects that the lock is already set and do no network operation to acquire the lock.</source>
          <target state="translated">此代码使用函数 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; 而不是函数 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 。函数 &lt;code&gt;s_write/1&lt;/code&gt; 设置了粘滞锁而不是普通锁。如果不复制表，则粘滞锁没有特殊作用。如果复制了表，并且在节点 &lt;code&gt;N1&lt;/code&gt; 上设置了粘滞锁，则此锁将粘在节点 &lt;code&gt;N1&lt;/code&gt; 上。下次您尝试在节点 &lt;code&gt;N1&lt;/code&gt; 的同一记录上设置粘性锁定时， &lt;code&gt;Mnesia&lt;/code&gt; 会检测到该锁定已设置，并且不执行任何网络操作来获取该锁定。</target>
        </trans-unit>
        <trans-unit id="d473cae681409fa329e6bc7b44d312e6bb308a91" translate="yes" xml:space="preserve">
          <source>This command can only be used when contacting &lt;code&gt;epmd&lt;/code&gt; instances started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;.</source>
          <target state="translated">仅当联系以 &lt;code&gt;epmd&lt;/code&gt; 标志 &lt;code&gt;-relaxed_command_check&lt;/code&gt; epmd实例时，才可以使用此命令。</target>
        </trans-unit>
        <trans-unit id="a8da29ec7d90c1769855d7fc9ae5d438b9bb9d86" translate="yes" xml:space="preserve">
          <source>This command file is then set as heart command.</source>
          <target state="translated">这个命令文件就会被设置为心脏命令。</target>
        </trans-unit>
        <trans-unit id="52d8f2983dee948139d1e9e434673f9c52bda692" translate="yes" xml:space="preserve">
          <source>This command will create a file named &lt;code&gt;root.TAGS&lt;/code&gt; in the current directory. The file will contain references to all Erlang source files in the Erlang distribution.</source>
          <target state="translated">此命令将在当前目录中创建一个名为 &lt;code&gt;root.TAGS&lt;/code&gt; 的文件。该文件将包含对Erlang发行版中所有Erlang源文件的引用。</target>
        </trans-unit>
        <trans-unit id="aa2bc19b983020ccb9b326fcd4731f0bd1161c57" translate="yes" xml:space="preserve">
          <source>This composes a test set from the exported test functions of the named module, i.e., those functions with arity zero whose names end with &lt;code&gt;_test&lt;/code&gt; or &lt;code&gt;_test_&lt;/code&gt;. Basically, the &lt;code&gt;..._test()&lt;/code&gt; functions become simple tests, while the &lt;code&gt;..._test_()&lt;/code&gt; functions become generators.</source>
          <target state="translated">此构成从命名模块，即具有零元数名称以结束这些功能的导出的测试功能测试集 &lt;code&gt;_test&lt;/code&gt; 或 &lt;code&gt;_test_&lt;/code&gt; 。基本上， &lt;code&gt;..._test()&lt;/code&gt; 函数成为简单的测试，而 &lt;code&gt;..._test_()&lt;/code&gt; 函数成为生成器。</target>
        </trans-unit>
        <trans-unit id="63c3c21b3eef82be8246811ccf2f3c14d371f943" translate="yes" xml:space="preserve">
          <source>This concludes the example. It is fully runnable and you can read or write to the I/O server by using, for example, the &lt;code&gt;io&lt;/code&gt; module or even the &lt;code&gt;file&lt;/code&gt; module. It is as simple as that to implement a fully fledged I/O server in Erlang.</source>
          <target state="translated">到此结束示例。它是完全可运行的，您可以通过使用 &lt;code&gt;io&lt;/code&gt; 模块甚至 &lt;code&gt;file&lt;/code&gt; 模块来读取或写入I / O服务器。就像在Erlang中实现成熟的I / O服务器一样简单。</target>
        </trans-unit>
        <trans-unit id="1bc6422d46a0ceffe44a706f105bee33bbb50726" translate="yes" xml:space="preserve">
          <source>This concludes the quick tour of the features of &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="translated">到此结束了&lt;strong&gt;Beam_makeops&lt;/strong&gt;功能的快速浏览。</target>
        </trans-unit>
        <trans-unit id="33f0e49393f960fdbb1f12f5f92189e125a0ce06" translate="yes" xml:space="preserve">
          <source>This configuration function is called as the first function in the suite. It typically contains initializations that are common for all test cases in the suite, and that must only be done once. Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. Whatever is returned from this function is specified as &lt;code&gt;Config&lt;/code&gt; to all configuration functions and test cases in the suite.</source>
          <target state="translated">此配置功能称为套件中的第一个功能。它通常包含该套件中所有测试用例都通用的初始化，并且只能执行一次。参数 &lt;code&gt;Config&lt;/code&gt; 是可以修改的配置数据。从此函数返回的所有内容均指定为套件中所有配置函数和测试用例的 &lt;code&gt;Config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7813765274dd4ee3556852945789f955a7b535a" translate="yes" xml:space="preserve">
          <source>This configuration function is called before execution of a test case group. It typically contains initializations that are common for all test cases and subgroups in the group, and that must only be performed once. &lt;code&gt;GroupName&lt;/code&gt; is the name of the group, as specified in the group definition (see &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt;). Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. The return value of this function is given as &lt;code&gt;Config&lt;/code&gt; to all test cases and subgroups in the group.</source>
          <target state="translated">在执行测试用例组之前，将调用此配置功能。它通常包含该组中所有测试用例和子组都通用的初始化，并且只能执行一次。 &lt;code&gt;GroupName&lt;/code&gt; 是组的名称，如组定义中所指定（请参阅 &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt; ）。参数 &lt;code&gt;Config&lt;/code&gt; 是可以修改的配置数据。该函数的返回值以 &lt;code&gt;Config&lt;/code&gt; 的形式提供给该组中的所有测试用例和子组。</target>
        </trans-unit>
        <trans-unit id="3fc12196aaa3c7c817d997888a6e0c0d511e97b1" translate="yes" xml:space="preserve">
          <source>This configuration function is called before execution of a test case group. It typically contains initializations that are common for all test cases and subgroups in the group, and that must only be performed once. &lt;code&gt;GroupName&lt;/code&gt; is the name of the group, as specified in the group definition (see &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt;). Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. The return value of this function is given as &lt;code&gt;Config&lt;/code&gt; to all test cases and subgroups in the group.</source>
          <target state="translated">在执行测试用例组之前，将调用此配置功能。它通常包含该组中所有测试用例和子组都通用的初始化，并且只能执行一次。 &lt;code&gt;GroupName&lt;/code&gt; 是组的名称，如组定义中所指定（请参阅 &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; ）。参数 &lt;code&gt;Config&lt;/code&gt; 是可以修改的配置数据。该函数的返回值以 &lt;code&gt;Config&lt;/code&gt; 的形式提供给该组中的所有测试用例和子组。</target>
        </trans-unit>
        <trans-unit id="7b59f052b21fb5d16deae6ffc52f3f1d17300c30" translate="yes" xml:space="preserve">
          <source>This configuration parameter defaults &lt;code&gt;false&lt;/code&gt; and will do so up until OTP 23. As of OTP 24 this configuration parameter will be removed and &lt;code&gt;get_system_memory_data()&lt;/code&gt; will begin behaving as it does now when the configuration parameter has been set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此配置参数默认为 &lt;code&gt;false&lt;/code&gt; ，直到OTP 23才这样做。从OTP 24开始，此配置参数将被删除，并且 &lt;code&gt;get_system_memory_data()&lt;/code&gt; 将像现在将其设置为 &lt;code&gt;true&lt;/code&gt; 时一样开始工作。</target>
        </trans-unit>
        <trans-unit id="23368b3fe2d449c2692eb8e3e91bed68d4ab16da" translate="yes" xml:space="preserve">
          <source>This conforms to the format used by the scanner in the Erlang &lt;code&gt;io&lt;/code&gt; library module.</source>
          <target state="translated">这符合Erlang &lt;code&gt;io&lt;/code&gt; 库模块中扫描程序使用的格式。</target>
        </trans-unit>
        <trans-unit id="89e7ad5998bd8d56a5635438c81b21cdbc5fbf20" translate="yes" xml:space="preserve">
          <source>This construction does not consume any messages, only suspends execution in the process for &lt;code&gt;ExprT&lt;/code&gt; milliseconds. This can be used to implement simple timers.</source>
          <target state="translated">这种构造不会消耗任何消息，只会在进程中暂停执行 &lt;code&gt;ExprT&lt;/code&gt; 毫秒。这可以用来实现简单的计时器。</target>
        </trans-unit>
        <trans-unit id="e9b232bbe87386ece629cac0a167c63032d6651c" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT2&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;EXIT2&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="31e56f278047c16bfcdee2f58fb054509e25ef75" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT2_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;EXIT2_TT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="2f2c61e7c0a9740ed09540a374d303740287e237" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;EXIT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="900bb411e26a0ffdc2a46615c860d514eaa89642" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;EXIT_TT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="b27db693ded90f8d66758ebab03e1e0cfcb72730" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;MONITOR_P_EXIT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;MONITOR_P_EXIT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="7ba4af6a7f34aa01d96e5575c3aff6bb9e026456" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;SEND&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="13ed13e3031f229e67c3f6d88ff54ba590b010d0" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;SEND_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="ff79977655b81c53aa0929475789c463d4c65ccd" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="61b1bf1e5da0665206d28c63a8251c70f9437da9" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">该控制消息代替 &lt;code&gt;SEND_TT&lt;/code&gt; 控制消息，并且在连接建立握手中协商了分发标志 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 时将发送该控制消息。</target>
        </trans-unit>
        <trans-unit id="3811bd05c74f86fcbc14a9c1b9034f65fa2fcd06" translate="yes" xml:space="preserve">
          <source>This could be accomplished with the option &lt;code&gt;fail_callback&lt;/code&gt; which will be called if the hostname verification fails:</source>
          <target state="translated">这可以通过选项 &lt;code&gt;fail_callback&lt;/code&gt; 来完成，如果主机名验证失败，则将调用该选项：</target>
        </trans-unit>
        <trans-unit id="51a1cc36e31cb197216b50eb9eb632d0459ddabc" translate="yes" xml:space="preserve">
          <source>This creates a boot script, both the readable version, &lt;code&gt;ch_rel-1.script&lt;/code&gt;, and the binary version, &lt;code&gt;ch_rel-1.boot&lt;/code&gt;, used by the runtime system.</source>
          <target state="translated">这将创建一个由运行时系统使用的引导脚本，即可读版本 &lt;code&gt;ch_rel-1.script&lt;/code&gt; 和二进制版本 &lt;code&gt;ch_rel-1.boot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f83e183c685a8bf96ad1d1d03b74d255f5c951a" translate="yes" xml:space="preserve">
          <source>This creates a test set from all the modules belonging to the specified application, by consulting the application's &lt;code&gt;.app&lt;/code&gt; file (see &lt;code&gt;{file, FileName}&lt;/code&gt;), or if no such file exists, by testing all object files in the application's &lt;code&gt;ebin&lt;/code&gt;-directory (see &lt;code&gt;{dir, Path}&lt;/code&gt;); if that does not exist, the &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; directory is used.</source>
          <target state="translated">这可以通过查询属于应用程序的 &lt;code&gt;.app&lt;/code&gt; 文件（请参阅 &lt;code&gt;{file, FileName}&lt;/code&gt; ）从属于指定应用程序的所有模块创建测试集，或者如果不存在此类文件，则可以通过测试应用程序的 &lt;code&gt;ebin&lt;/code&gt; -directory 中的所有目标文件来创建测试集（参见 &lt;code&gt;{dir, Path}&lt;/code&gt; ）; 如果不存在，则使用 &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="7dfbabbf55ded6bc40cb089b7e7b9db65720b207" translate="yes" xml:space="preserve">
          <source>This creates a tuple with the brand of the motorcycle and the output format. We use the brand name only for sorting purpose. We have to end the template function with the &quot;built in clause&quot; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt;</source>
          <target state="translated">这将创建一个具有摩托车品牌和输出格式的元组。我们仅将品牌名称用于分类目的。我们必须以&amp;ldquo;内建子句&amp;rdquo; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd1d3feb38283e93bdf7380a9a3f2767d2d85c6a" translate="yes" xml:space="preserve">
          <source>This creates an &lt;code&gt;(ETERM *)&lt;/code&gt; structure corresponding to the Erlang term &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt;</source>
          <target state="translated">这将创建一个与Erlang术语 &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt; 相对应的 &lt;code&gt;(ETERM *)&lt;/code&gt; 结构</target>
        </trans-unit>
        <trans-unit id="ae606f82f5ea62f5942a0adf3b9e512950c71e07" translate="yes" xml:space="preserve">
          <source>This creates an additional folder in &lt;code&gt;$ERL_TOP/release&lt;/code&gt; called &lt;code&gt;tests&lt;/code&gt;. Now, it's time to start the smoke test.</source>
          <target state="translated">这将在 &lt;code&gt;$ERL_TOP/release&lt;/code&gt; 创建一个名为 &lt;code&gt;tests&lt;/code&gt; 的附加文件夹。现在，该开始进行烟雾测试了。</target>
        </trans-unit>
        <trans-unit id="ef73a8deed0f6aa219ae36f5994c464c421d1dae" translate="yes" xml:space="preserve">
          <source>This creates an anonymous function of &lt;code&gt;N&lt;/code&gt; arguments and binds it to the variable &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">这产生的匿名功能 &lt;code&gt;N&lt;/code&gt; 参数和它结合到可变 &lt;code&gt;F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="524be8f1a981b01e7043d75c61d487bdaac91459" translate="yes" xml:space="preserve">
          <source>This creates:</source>
          <target state="translated">这就造成了:</target>
        </trans-unit>
        <trans-unit id="c46e82b8048ee48e1624490a06ae6b4a6e2f1c62" translate="yes" xml:space="preserve">
          <source>This daemon acts as a name server on all hosts involved in distributed Erlang computations. When an Erlang node starts, the node has a name and it obtains an address from the host OS kernel. The name and address are sent to the &lt;code&gt;epmd&lt;/code&gt; daemon running on the local host. In a TCP/IP environment, the address consists of the IP address and a port number. The node name is an atom on the form of &lt;code&gt;Name@Node&lt;/code&gt;. The job of the &lt;code&gt;epmd&lt;/code&gt; daemon is to keep track of which node name listens on which address. Hence, &lt;code&gt;epmd&lt;/code&gt; maps symbolic node names to machine addresses.</source>
          <target state="translated">该守护程序在涉及分布式Erlang计算的所有主机上充当名称服务器。当Erlang节点启动时，该节点将具有一个名称，并从主机OS内核获取地址。名称和地址将发送到在本地主机上运行的 &lt;code&gt;epmd&lt;/code&gt; 守护程序。在TCP / IP环境中，该地址由IP地址和端口号组成。节点名称是原子，形式为 &lt;code&gt;Name@Node&lt;/code&gt; 。 &lt;code&gt;epmd&lt;/code&gt; 守护程序的工作是跟踪哪个节点名称在哪个地址上侦听。因此， &lt;code&gt;epmd&lt;/code&gt; 将符号节点名称映射到机器地址。</target>
        </trans-unit>
        <trans-unit id="be132e0b64312cab1412b3c061af9dbcd07c2db2" translate="yes" xml:space="preserve">
          <source>This data can also be specified explicitly in the user configuration file. This file is to contain lines of configuration parameters (each terminated with a full stop). Some parameters add data to the configuration (such as host and nameserver), others overwrite any previous settings (such as domain and lookup). The user configuration file is always examined last in the configuration process, making it possible for the user to override any default values or previously made settings. Call &lt;code&gt;inet:get_rc()&lt;/code&gt; to view the state of the &lt;code&gt;inet&lt;/code&gt; configuration database.</source>
          <target state="translated">也可以在用户配置文件中显式指定此数据。该文件包含配置参数行（每行以句号终止）。一些参数将数据添加到配置中（例如主机和名称服务器），其他参数将覆盖之前的所有设置（例如域和查找）。在配置过程中，始终会最后检查用户配置文件，从而使用户可以覆盖任何默认值或先前进行的设置。调用 &lt;code&gt;inet:get_rc()&lt;/code&gt; 以查看 &lt;code&gt;inet&lt;/code&gt; 配置数据库的状态。</target>
        </trans-unit>
        <trans-unit id="48f25fc645975c60f249d68b5dd230f51d28d68c" translate="yes" xml:space="preserve">
          <source>This date and time identifier has the same format as the XML type &lt;code&gt;dateTime&lt;/code&gt; and is compliant with RFC 3339 Date and Time on the Internet Timestamps. The format is as follows:</source>
          <target state="translated">此日期和时间标识符与XML类型 &lt;code&gt;dateTime&lt;/code&gt; 的格式相同，并且符合RFC 3339 Internet时间戳上的&amp;ldquo;日期和时间&amp;rdquo;。格式如下：</target>
        </trans-unit>
        <trans-unit id="738523548a30e709bb5b81f10988c30ec76d3772" translate="yes" xml:space="preserve">
          <source>This defines a local function handler that is called with:</source>
          <target state="translated">这定义了一个本地函数处理程序,这个函数处理程序被调用。</target>
        </trans-unit>
        <trans-unit id="948cd7e2c415cc3a421a26b31393fafc514d648b" translate="yes" xml:space="preserve">
          <source>This defines a non-local function handler that is called with:</source>
          <target state="translated">这定义了一个非本地函数处理程序,该函数处理程序被调用。</target>
        </trans-unit>
        <trans-unit id="662f224ab983c6f766721b42aada149c79c7000c" translate="yes" xml:space="preserve">
          <source>This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes are stable since many years.</source>
          <target state="translated">这一说明远未完成。如果协议更新了,它将会被更新。然而,从Erlang节点到Erlang端口映射守护进程(EPMD)以及Erlang节点之间的协议自多年来都是稳定的。</target>
        </trans-unit>
        <trans-unit id="e8b60a37d6f9b5dab9afb438915682d979c1ca85" translate="yes" xml:space="preserve">
          <source>This diagnostic warns that the variable &lt;code&gt;X&lt;/code&gt; in the pattern is not the same as the variable &lt;code&gt;X&lt;/code&gt; that occurs in the function head.</source>
          <target state="translated">此诊断警告说，变量 &lt;code&gt;X&lt;/code&gt; 在图案是不一样的变量 &lt;code&gt;X&lt;/code&gt; 中发生的功能头。</target>
        </trans-unit>
        <trans-unit id="9c0a88d7e60d7e7f1439fe6fcfcc1a50b22440f9" translate="yes" xml:space="preserve">
          <source>This directory is the &lt;strong&gt;installation directory&lt;/strong&gt; of the embedded environment.</source>
          <target state="translated">该目录是嵌入式环境的&lt;strong&gt;安装目录&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7a3cf407193e52ba658ffaccdcac32c81fba9803" translate="yes" xml:space="preserve">
          <source>This disables the use of style sheets and JavaScripts (see &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这将禁用样式表和JavaScript的使用（请参阅 &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ecec3c07eff61196ca0de8babf79aab0e2d1d31" translate="yes" xml:space="preserve">
          <source>This document describes how to build and install Erlang/OTP-21. Erlang/OTP should be possible to build from source on any Unix/Linux system, including OS X. You are advised to read the whole document before attempting to build and install Erlang/OTP.</source>
          <target state="translated">本文档介绍了如何构建和安装Erlang/OTP-21。Erlang/OTP应该可以在任何Unix/Linux系统上从源码编译,包括OS X。</target>
        </trans-unit>
        <trans-unit id="b4d112b823ab84ed3043a977bee18b4c73f73d72" translate="yes" xml:space="preserve">
          <source>This document describes how to build and install Erlang/OTP-23. Erlang/OTP should be possible to build from source on any Unix/Linux system, including OS X. You are advised to read the whole document before attempting to build and install Erlang/OTP.</source>
          <target state="translated">本文档介绍了如何构建和安装Erlang/OTP-23。Erlang/OTP应该可以在任何Unix/Linux系统(包括OS X)上从源码开始构建,建议你在尝试构建和安装Erlang/OTP之前阅读整个文档。</target>
        </trans-unit>
        <trans-unit id="154342527042516d1b93b9115b8c8965ef041d9a" translate="yes" xml:space="preserve">
          <source>This document describes how to cross compile Erlang/OTP-21. You are advised to read the whole document before attempting to cross compile Erlang/OTP. However, before reading this document, you should read the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document which describes building and installing Erlang/OTP in general. &lt;code&gt;$ERL_TOP&lt;/code&gt; is the top directory in the source tree.</source>
          <target state="translated">本文档介绍了如何交叉编译Erlang / OTP-21。建议您在尝试交叉编译Erlang / OTP之前先阅读整个文档。但是，在阅读本文档之前，您应该阅读 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 文档，该文档通常描述了如何构建和安装Erlang / OTP。 &lt;code&gt;$ERL_TOP&lt;/code&gt; 是源树中的顶级目录。</target>
        </trans-unit>
        <trans-unit id="8a45990179b4af3d1fed1b433dba16b703f213db" translate="yes" xml:space="preserve">
          <source>This document describes how to cross compile Erlang/OTP-23. You are advised to read the whole document before attempting to cross compile Erlang/OTP. However, before reading this document, you should read the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document which describes building and installing Erlang/OTP in general. &lt;code&gt;$ERL_TOP&lt;/code&gt; is the top directory in the source tree.</source>
          <target state="translated">本文档介绍了如何交叉编译Erlang / OTP-23。建议您在尝试交叉编译Erlang / OTP之前先阅读整个文档。但是，在阅读本文档之前，您应该阅读 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 文档，该文档通常描述了如何构建和安装Erlang / OTP。 &lt;code&gt;$ERL_TOP&lt;/code&gt; 是源树中的顶层目录。</target>
        </trans-unit>
        <trans-unit id="191135bf8635f2eb1fba713547f0e7f062a60990" translate="yes" xml:space="preserve">
          <source>This document describes strategy regarding supported Releases, compatibility, deprecations and removal of functionality. This document was introduced in OTP 21. Actions taken regarding these issues before OTP 21 did not adhere this document.</source>
          <target state="translated">本文档描述了有关支持的发布、兼容性、废弃和删除功能的策略。本文档是在OTP21中引入的。在OTP21之前就这些问题所采取的行动没有遵守本文件。</target>
        </trans-unit>
        <trans-unit id="fc5c2a0c7bfb9a9029380c09ce1ef9700c0544c7" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;strong&gt;beam_makeops&lt;/strong&gt; script.</source>
          <target state="translated">本文档介绍了&lt;strong&gt;beam_makeops&lt;/strong&gt;脚本。</target>
        </trans-unit>
        <trans-unit id="71a24568f8a61fe472275bbbf1ab8d95f3724c6d" translate="yes" xml:space="preserve">
          <source>This document describes the process of patching an existing OTP installation with one or more Erlang/OTP applications of newer versions than already installed. The tool &lt;code&gt;otp_patch_apply&lt;/code&gt; is available for this specific purpose. It resides in the top directory of the Erlang/OTP source tree.</source>
          <target state="translated">本文档介绍了使用一个或多个比已安装的版本更高的Erlang / OTP应用程序修补现有OTP安装的过程。工具 &lt;code&gt;otp_patch_apply&lt;/code&gt; 可用于此特定目的。它位于Erlang / OTP源代码树的顶层目录中。</target>
        </trans-unit>
        <trans-unit id="a3d8a881ed785c2bbf80ae1ed7354f59f5918b23" translate="yes" xml:space="preserve">
          <source>This document does not give an introduction to XML. There are a lot of books available that describe XML from different views. At the &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; site you will find the &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; and other related specs. One site were you can find tutorials on XML and related specs is &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">本文档未介绍XML。有很多书籍可以从不同的角度描述XML。在 &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; 网站上，您可以找到 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; 和其他相关规范。您可以在一个站点上找到 &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt; ,它是有关XML和相关规范的教程。</target>
        </trans-unit>
        <trans-unit id="143fad2c70e90531f505c4657ec791c944d5326a" translate="yes" xml:space="preserve">
          <source>This document focuses on the graphical parts of the tool. The concepts are explained in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt;.</source>
          <target state="translated">本文档重点介绍该工具的图形部分。有关概念，请参见模块 &lt;code&gt;reltool&lt;/code&gt; 的参考手册。</target>
        </trans-unit>
        <trans-unit id="c0852a621150eac160bbaa6ef0c4a98523bb7541" translate="yes" xml:space="preserve">
          <source>This document list all functionality in Erlang/OTP that currently are scheduled for removal. For more information regarding the strategy regarding removal of functionality see the documentation of &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt;.</source>
          <target state="translated">本文档列出了当前计划删除的Erlang / OTP中的所有功能。有关删除功能策略的更多信息，请参见 &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="eb9c1c47dda29ee89c688498445546e5263115a7" translate="yes" xml:space="preserve">
          <source>This document lists all deprecated functionality in Erlang/OTP. For more information regarding the strategy regarding deprecations see the documentation of &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt;.</source>
          <target state="translated">本文档列出了Erlang / OTP中所有不推荐使用的功能。有关折旧策略的更多信息，请参阅 &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="d0a13f41d530fac43cd74427e80d4e61f60e1273" translate="yes" xml:space="preserve">
          <source>This does not reduce the overall time for the upgrade, but it allows checks and purge to be executed in the background before the real upgrade is started.</source>
          <target state="translated">这并没有减少升级的整体时间,但它允许在真正的升级开始之前在后台执行检查和清除。</target>
        </trans-unit>
        <trans-unit id="05624a0b5087d8c82b1545072e5dc7e9346c97f4" translate="yes" xml:space="preserve">
          <source>This driver is called like the others from Erlang. However, as we use &lt;code&gt;driver_output_term&lt;/code&gt;, there is no need to call &lt;code&gt;binary_to_term&lt;/code&gt;. The Erlang code is in the sample file &lt;code&gt;next_perm.erl&lt;/code&gt;.</source>
          <target state="translated">该驱动程序的名称与Erlang中的其他驱动程序相同。但是，由于我们使用 &lt;code&gt;driver_output_term&lt;/code&gt; ，因此无需调用 &lt;code&gt;binary_to_term&lt;/code&gt; 。Erlang代码在示例文件 &lt;code&gt;next_perm.erl&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0d94d056a098777bcb956ee04ca4b41885a25660" translate="yes" xml:space="preserve">
          <source>This driver uses the &lt;code&gt;writev&lt;/code&gt; system call to send data onto the socket. A combination of &lt;code&gt;writev&lt;/code&gt; and the driver output queues is very convenient. An &lt;code&gt;ErlIOVec&lt;/code&gt; structure contains a &lt;code&gt;SysIOVec&lt;/code&gt; (which is equivalent to the &lt;code&gt;struct iovec&lt;/code&gt; structure defined in &lt;code&gt;uio.h&lt;/code&gt;. The &lt;code&gt;ErlIOVec&lt;/code&gt; also contains an array of &lt;code&gt;ErlDrvBinary&lt;/code&gt; pointers, of the same length as the number of buffers in the I/O vector itself. One can use this to allocate the binaries for the queue &quot;manually&quot; in the driver, but here the binary array is filled with &lt;code&gt;NULL&lt;/code&gt; values (line 7). The runtime system then allocates its own buffers when &lt;code&gt;driver_enqv&lt;/code&gt; is called (line 37).</source>
          <target state="translated">该驱动程序使用 &lt;code&gt;writev&lt;/code&gt; 系统调用将数据发送到套接字。将 &lt;code&gt;writev&lt;/code&gt; 和驱动程序输出队列结合使用非常方便。一个 &lt;code&gt;ErlIOVec&lt;/code&gt; 结构包含一个 &lt;code&gt;SysIOVec&lt;/code&gt; （其等同于 &lt;code&gt;struct iovec&lt;/code&gt; 中定义的结构 &lt;code&gt;uio.h&lt;/code&gt; 该 &lt;code&gt;ErlIOVec&lt;/code&gt; 还包含的阵列 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 指针相同的长度，如缓冲剂的在I / O向量本身的数量。人们可以使用它为驱动程序中的队列&amp;ldquo;手动&amp;rdquo;分配二进制文件，但此处二进制数组中填充了 &lt;code&gt;NULL&lt;/code&gt; 值（第7行），然后运行系统在 &lt;code&gt;driver_enqv&lt;/code&gt; 时分配其自己的缓冲区 被称为（第37行）。</target>
        </trans-unit>
        <trans-unit id="93162ce71b1395d9e7f9c6b572069d33e4ac790f" translate="yes" xml:space="preserve">
          <source>This driver was written before the runtime system had SMP support. The driver will still function in the runtime system with SMP support, but performance will suffer from lock contention on the driver lock used for the driver. This can be alleviated by reviewing and perhaps rewriting the code so that each instance of the driver safely can execute in parallel. When instances safely can execute in parallel, it is safe to enable instance-specific locking on the driver. This is done by passing &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; as a driver flag. This is left as an exercise for the reader.</source>
          <target state="translated">该驱动程序是在运行时系统具有SMP支持之前编写的。该驱动程序仍将在具有SMP支持的运行时系统中运行，但是性能会因用于该驱动程序的驱动程序锁上的锁争用而受损。这可以通过查看并重写代码来缓解，以便驱动程序的每个实例可以安全地并行执行。当实例可以安全地并行执行时，可以在驱动程序上启用特定于实例的锁定。这是通过传递 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; 作为驱动程序标志来完成的。这留给读者练习。</target>
        </trans-unit>
        <trans-unit id="08f20d866bfb101e15cb4fdb27b1335c719c4f1c" translate="yes" xml:space="preserve">
          <source>This driver was written before the runtime system had SMP support. The driver will still function in the runtime system with SMP support, but performance will suffer from lock contention on the driver lock used for the driver. This can be alleviated by reviewing and perhaps rewriting the code so that each instance of the driver safely can execute in parallel. When instances safely can execute in parallel, it is safe to enable instance-specific locking on the driver. This is done by passing &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; as a driver flag. This is left as an exercise for the reader.</source>
          <target state="translated">该驱动程序是在运行时系统具有SMP支持之前编写的。该驱动程序仍将在具有SMP支持的运行时系统中运行，但是性能会因用于该驱动程序的驱动程序锁上的锁争用而受损。这可以通过查看并重写代码来缓解，以便驱动程序的每个实例都可以安全地并行执行。当实例可以安全地并行执行时，可以在驱动程序上启用特定于实例的锁定。这是通过传递 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; 作为驱动程序标志来完成的。这留给读者练习。</target>
        </trans-unit>
        <trans-unit id="c64c900bac343dda7e6756119d5d4e6241d815d7" translate="yes" xml:space="preserve">
          <source>This effectively closes down the Erlang node. Therefore, use the erl scheme instead, until this security breach is fixed.</source>
          <target state="translated">这实际上关闭了Erlang节点。因此,在这个安全漏洞被修复之前,请使用 erl 方案代替。</target>
        </trans-unit>
        <trans-unit id="bc0795bd08428b2fedc177925549e5f08fa86748" translate="yes" xml:space="preserve">
          <source>This element has a total size of 4*8 = 32 bits, and it contains a signed integer in little-endian order.</source>
          <target state="translated">这个元素的总大小为4*8=32位,它包含了一个有符号的整数,按小安培顺序排列。</target>
        </trans-unit>
        <trans-unit id="60545e850b697ee47719a2ce1a4b108461f703aa" translate="yes" xml:space="preserve">
          <source>This enables references to the fields of the record by name. For example, if &lt;code&gt;P&lt;/code&gt; is a variable whose value is a &lt;code&gt;person&lt;/code&gt; record, the following code access the name and address fields of the records:</source>
          <target state="translated">这样可以按名称引用记录的字段。例如，如果 &lt;code&gt;P&lt;/code&gt; 是一个值是 &lt;code&gt;person&lt;/code&gt; 记录的变量，则以下代码访问记录的名称和地址字段：</target>
        </trans-unit>
        <trans-unit id="aa641702f4a74845596c27dedfc3c223048bd207" translate="yes" xml:space="preserve">
          <source>This encoding has many similarities to UTF-8, but the basic unit is a 16-bit number. This means that all characters occupy at least two bytes, and some high numbers four bytes. Some programs, libraries, and operating systems claiming to use UTF-16 only allow for characters that can be stored in one 16-bit entity, which is usually sufficient to handle living languages. As the basic unit is more than one byte, byte-order issues occur, which is why UTF-16 exists in both a big-endian and a little-endian variant.</source>
          <target state="translated">这种编码与UTF-8有许多相似之处,但基本单位是一个16位数字。这意味着所有的字符至少要占用两个字节,一些高数要占用四个字节。一些声称使用UTF-16的程序、库和操作系统只允许在一个16位实体中存储字符,这通常足以处理活语言。由于基本单位超过一个字节,就会出现字节顺序的问题,这就是为什么UTF-16存在大恩典和小恩典两种变体。</target>
        </trans-unit>
        <trans-unit id="57b04c69f42e5cd6d283dd11cf050111e35a9d54" translate="yes" xml:space="preserve">
          <source>This entry is normally not shown. It signifies that getting the rest of the information about this scheduler failed for some reason.</source>
          <target state="translated">这个条目通常不显示。它表示由于某种原因,获取该调度器的其他信息失败。</target>
        </trans-unit>
        <trans-unit id="5a4d6d82470e813a7acad87293099d4181101f42" translate="yes" xml:space="preserve">
          <source>This entry is shown only if there is a current process. It is similar to &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt; &lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that only the function frames are shown (that is, the stack variables are omitted). Also, only the top and bottom part of the stack are shown. If the stack is small (&amp;lt; 512 slots), the entire stack is shown. Otherwise the entry &lt;strong&gt;skipping ## slots&lt;/strong&gt; is shown, where &lt;code&gt;##&lt;/code&gt; is replaced by the number of slots that has been skipped.</source>
          <target state="translated">仅当存在当前进程时，才显示此条目。它与 &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt; &lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 相似，不同之处在于仅显示功能框（即，省略了堆栈变量）。另外，仅显示堆栈的顶部和底部。如果堆栈很小（&amp;lt;512个插槽），则会显示整个堆栈。否则，将显示&lt;strong&gt;跳过##插槽&lt;/strong&gt;的条目，其中 &lt;code&gt;##&lt;/code&gt; 替换为已跳过的插槽数。 &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ee6d539dd946aea2f2282406d3b99f607f84e26" translate="yes" xml:space="preserve">
          <source>This entry is shown only if there is a current process. It is similar to &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that only the function frames are shown (that is, the stack variables are omitted). Also, only the top and bottom part of the stack are shown. If the stack is small (&amp;lt; 512 slots), the entire stack is shown. Otherwise the entry &lt;strong&gt;skipping ## slots&lt;/strong&gt; is shown, where &lt;code&gt;##&lt;/code&gt; is replaced by the number of slots that has been skipped.</source>
          <target state="translated">仅当存在当前进程时，才显示此条目。它与 &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 相似，除了仅显示功能框（即，忽略堆栈变量）。另外，仅显示堆栈的顶部和底部。如果堆栈很小（&amp;lt;512个插槽），则会显示整个堆栈。否则，将显示&lt;strong&gt;跳过##插槽&lt;/strong&gt;的条目，其中 &lt;code&gt;##&lt;/code&gt; 替换为已跳过的插槽数。</target>
        </trans-unit>
        <trans-unit id="f4c1826f8578bafadcea5382ece74a9e3ca2e0c8" translate="yes" xml:space="preserve">
          <source>This equals:</source>
          <target state="translated">这就等于:</target>
        </trans-unit>
        <trans-unit id="8ee9f6a74af74dded0ab21396013fd65cb0cdb5f" translate="yes" xml:space="preserve">
          <source>This error is very similar to &lt;code&gt;match_limit&lt;/code&gt;, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the &lt;code&gt;match_limit_recursion&lt;/code&gt; limit, which defaults to 10,000,000 as well. Notice that as long as the &lt;code&gt;match_limit&lt;/code&gt; and &lt;code&gt;match_limit_default&lt;/code&gt; values are kept at the default values, the &lt;code&gt;match_limit_recursion&lt;/code&gt; error cannot occur, as the &lt;code&gt;match_limit&lt;/code&gt; error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt;) or by specifying options to &lt;code&gt;run/3&lt;/code&gt;.</source>
          <target state="translated">此错误与 &lt;code&gt;match_limit&lt;/code&gt; 非常相似，但是当PCRE的内部匹配函数被&amp;ldquo;递归&amp;rdquo;调用的次数超过 &lt;code&gt;match_limit_recursion&lt;/code&gt; 限制的次数时，也会发生此错误，该限制也默认为10,000,000。请注意，只要 &lt;code&gt;match_limit&lt;/code&gt; 和 &lt;code&gt;match_limit_default&lt;/code&gt; 值被保持在默认值，则 &lt;code&gt;match_limit_recursion&lt;/code&gt; 不能发生错误，因为 &lt;code&gt;match_limit&lt;/code&gt; 之前（每次递归调用也是一个呼叫，但不能反过来）会出现误差。但是，可以通过直接在正则表达式字符串中设置限制（请参阅 &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt; 一节）或通过指定选项 &lt;code&gt;run/3&lt;/code&gt; 来更改两个限制。。</target>
        </trans-unit>
        <trans-unit id="b2c6321b6b0826055e2105517a81fb4bbe80e26b" translate="yes" xml:space="preserve">
          <source>This event gives initial test run information that can be interpreted as: &quot;This test run will execute &lt;code&gt;Tests&lt;/code&gt; separate tests, in total containing &lt;code&gt;Cases&lt;/code&gt; number of test cases, in &lt;code&gt;Suites&lt;/code&gt; number of suites&quot;. However, if a test case group with a repeat property exists in any test, the total number of test cases cannot be calculated (unknown).</source>
          <target state="translated">此事件提供的初始测试运行信息可以解释为：&amp;ldquo;此测试运行将执行 &lt;code&gt;Tests&lt;/code&gt; 单独的测试，总共包含 &lt;code&gt;Cases&lt;/code&gt; 数，以 &lt;code&gt;Suites&lt;/code&gt; 数为套件&amp;rdquo;。但是，如果在任何测试中都存在具有重复属性的测试用例组，则无法计算测试用例的总数（未知）。</target>
        </trans-unit>
        <trans-unit id="157a7ac786729b7a02e45935d66765ea641c0a63" translate="yes" xml:space="preserve">
          <source>This event indicates that &lt;code&gt;Common Test&lt;/code&gt; has finished initial preparations and begins executing test cases.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 已完成初始准备并开始执行测试用例。</target>
        </trans-unit>
        <trans-unit id="a311dceedd521d1962d136632b3e667b19bb56be" translate="yes" xml:space="preserve">
          <source>This event indicates that the last test case has been executed and &lt;code&gt;Common Test&lt;/code&gt; is shutting down.</source>
          <target state="translated">此事件表明最后一个测试用例已经执行，并且 &lt;code&gt;Common Test&lt;/code&gt; 正在关闭。</target>
        </trans-unit>
        <trans-unit id="e53e8156bb201879d980af4d7b34c6aceaecd401" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; has started successfully and is ready to receive I/O messages.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 的日志记录过程已成功启动，并准备接收I / O消息。</target>
        </trans-unit>
        <trans-unit id="76a023ae70d60675cb788ca95f5784d5e17403bb" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; was shut down at the end of the test run.</source>
          <target state="translated">此事件表明 &lt;code&gt;Common Test&lt;/code&gt; 的日志记录过程在测试运行结束时已关闭。</target>
        </trans-unit>
        <trans-unit id="1defde33c0ddbc9bf09303976e2df4c21eb56168" translate="yes" xml:space="preserve">
          <source>This event informs about the end of a test case or a configuration function (see event &lt;code&gt;tc_start&lt;/code&gt; for details on element &lt;code&gt;FuncOrGroup&lt;/code&gt;). With this event comes the final result of the function in question. It is possible to determine on the top level of &lt;code&gt;Result&lt;/code&gt; if the function was successful, skipped (by the user), or if it failed.</source>
          <target state="translated">这大约测试用例或配置功能的结束事件通知（见事件 &lt;code&gt;tc_start&lt;/code&gt; 的详细信息，元件 &lt;code&gt;FuncOrGroup&lt;/code&gt; ）。伴随此事件，是该功能的最终结果。可以在 &lt;code&gt;Result&lt;/code&gt; 的最高级别上确定该功能是否成功，被用户跳过（是否被用户）或是否失败。</target>
        </trans-unit>
        <trans-unit id="196853db3112d60fc49c52cb43e5304105859b69" translate="yes" xml:space="preserve">
          <source>This event informs about the start of a test case, or a group configuration function. The event is sent also for &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt;, but not for &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt;. If a group configuration function starts, the group name and execution properties are also specified.</source>
          <target state="translated">此事件通知有关测试用例或组配置功能的开始。也为 &lt;code&gt;init_per_suite&lt;/code&gt; 和 &lt;code&gt;end_per_suite&lt;/code&gt; 发送该事件，但不为 &lt;code&gt;init_per_testcase&lt;/code&gt; 和 &lt;code&gt;end_per_testcase&lt;/code&gt; 发送该事件。如果启动了组配置功能，则还将指定组名称和执行属性。</target>
        </trans-unit>
        <trans-unit id="55e3d00fdb284c9c490ae4f7d70ddb7a214409ea" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt;.</source>
          <target state="translated">此事件由 &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt; 生成。</target>
        </trans-unit>
        <trans-unit id="3c14d9a9fed395d121d6715f83a9e812993ef517" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt;.</source>
          <target state="translated">此事件由 &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c6d6cfcfdec46a1017f209d71402b88e99f222" translate="yes" xml:space="preserve">
          <source>This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt;. Both the handling of this event and sending it are taken care of by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; 会发送此事件。 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 行为负责处理此事件以及将其发送。</target>
        </trans-unit>
        <trans-unit id="3bce9afff012f4ef208193d1a3f362891fa380a1" translate="yes" xml:space="preserve">
          <source>This event is sent at the start of each test case (and configuration function except &lt;code&gt;init/end_per_testcase&lt;/code&gt;) and carries information about the full name (that is, the file name including the absolute directory path) of the current test case log file.</source>
          <target state="translated">该事件在每个测试用例（以及除 &lt;code&gt;init/end_per_testcase&lt;/code&gt; 之外的配置函数）的开始处发送，并携带有关当前测试用例日志文件的全名（即，文件名，包括绝对目录路径）的信息。</target>
        </trans-unit>
        <trans-unit id="e4a38f01911d280761b98159e93b62180b939625" translate="yes" xml:space="preserve">
          <source>This event is sent for every test case or configuration function that &lt;code&gt;Common Test&lt;/code&gt; has skipped automatically because of either a failed &lt;code&gt;init_per_suite&lt;/code&gt; or &lt;code&gt;init_per_group&lt;/code&gt;, a failed &lt;code&gt;require&lt;/code&gt; in &lt;code&gt;suite/0&lt;/code&gt;, or a failed test case in a sequence. Notice that this event is never received as a result of a test case getting skipped because of &lt;code&gt;init_per_testcase&lt;/code&gt; failing, as that information is carried with event &lt;code&gt;tc_done&lt;/code&gt;. If a failed test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">此事件是为每一个测试用例或配置功能发送的 &lt;code&gt;Common Test&lt;/code&gt; 已经自动跳过，因为任一个失败 &lt;code&gt;init_per_suite&lt;/code&gt; 或 &lt;code&gt;init_per_group&lt;/code&gt; ，失败 &lt;code&gt;require&lt;/code&gt; 在 &lt;code&gt;suite/0&lt;/code&gt; ，或失败的测试用例的序列。请注意，由于 &lt;code&gt;init_per_testcase&lt;/code&gt; 失败而导致测试用例被跳过，因此永远不会收到此事件，因为该信息随事件 &lt;code&gt;tc_done&lt;/code&gt; 传递。如果失败的测试用例属于测试用例组，则第二个数据元素是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="85637c33d8358bfa807af40ed5b12cab4e94ad14" translate="yes" xml:space="preserve">
          <source>This event occurs when a transaction that caused a modification to the database is completed. It is useful for determining when a set of table events (see the next section), caused by a given activity, have been sent. Once this event is received, it is guaranteed that no further table events with the same &lt;code&gt;ActivityID&lt;/code&gt; will be received. Notice that this event can still be received even if no table events with a corresponding &lt;code&gt;ActivityID&lt;/code&gt; were received, depending on the tables to which the receiving process is subscribed.</source>
          <target state="translated">当引起数据库修改的事务完成时，将发生此事件。这对于确定何时发送由给定活动引起的一组表事件（请参阅下一节）非常有用。一旦接收到此事件，就可以保证不会 &lt;code&gt;ActivityID&lt;/code&gt; 收到具有相同ActivityID的表事件。请注意，即使没有接收到具有相应 &lt;code&gt;ActivityID&lt;/code&gt; 的表事件，也仍可以接收到此事件，具体取决于订阅了接收过程的表。</target>
        </trans-unit>
        <trans-unit id="f45e922ec57563cdea35247f1f7ed0e1f7d09af7" translate="yes" xml:space="preserve">
          <source>This event specifies that a test case was skipped by the user. It is only received if the skip is declared in a test specification. Otherwise, user skip information is received as a &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; result in event &lt;code&gt;tc_done&lt;/code&gt; for the test case. If a skipped test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">此事件指定用户跳过了一个测试用例。仅当在测试规范中声明跳过时才接收。否则，将在事件 &lt;code&gt;tc_done&lt;/code&gt; 的测试用例的 &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; 结果中接收用户跳过信息。如果跳过的测试用例属于测试用例组，则第二个数据元素是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="33a5b9cb740e8f063e9a381622f742f49651eec3" translate="yes" xml:space="preserve">
          <source>This example and all other examples in the document assumes a 64-bit archictecture, and furthermore that pointers to C code fit in 32 bits.</source>
          <target state="translated">这个例子和文档中的所有其他例子都假定是64位的架构,而且指向C代码的指针适合32位。</target>
        </trans-unit>
        <trans-unit id="9a24b66f55b1608bf70f4eb21d0c378bcfcc90e0" translate="yes" xml:space="preserve">
          <source>This example back up the contents of the registry to the specified &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;&quot;mtab&quot;&lt;/code&gt;. Once a registry has been backed up to &lt;code&gt;Mnesia&lt;/code&gt; like this, more backups only affect objects that have been modified since the most recent backup, that is, objects that have been created, changed, or deleted. The backup operation is done as a single atomic transaction, so that either the entire backup is performed or none of it.</source>
          <target state="translated">本示例将注册表的内容备份到指定的 &lt;code&gt;Mnesia&lt;/code&gt; 表 &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 。将注册表这样备份到 &lt;code&gt;Mnesia&lt;/code&gt; 后，更多备份将仅影响自最近备份以来已修改的对象，即已创建，更改或删除的对象。备份操作是作为单个原子事务完成的，因此可以执行整个备份，也可以不执行任何备份。</target>
        </trans-unit>
        <trans-unit id="8e5008e4f2f2212bcc7d9051d31593661ec6ce4d" translate="yes" xml:space="preserve">
          <source>This example concerns the body of the fun. Assume that all employee numbers beginning with zero (&lt;code&gt;0&lt;/code&gt;) must be changed to begin with one (&lt;code&gt;1&lt;/code&gt;) instead, and that we want to create the list &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt;:</source>
          <target state="translated">此示例涉及乐趣的主体。假设必须将所有以零（ &lt;code&gt;0&lt;/code&gt; ）开头的员工编号改为以一（ &lt;code&gt;1&lt;/code&gt; ）开头，并且我们要创建列表 &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9cd78123d895f5c9e7c353280ff2f48b8ea86e8" translate="yes" xml:space="preserve">
          <source>This example concerns the use of raw options. Consider a Linux system where you want to set option &lt;code&gt;TCP_LINGER2&lt;/code&gt; on protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt; in the stack. You know that on this particular system it defaults to 60 (seconds), but you want to lower it to 30 for a particular socket. Option &lt;code&gt;TCP_LINGER2&lt;/code&gt; is not explicitly supported by &lt;code&gt;inet&lt;/code&gt;, but you know that the protocol level translates to number 6, the option number to number 8, and the value is to be specified as a 32-bit integer. You can use this code line to set the option for the socket named &lt;code&gt;Sock&lt;/code&gt;:</source>
          <target state="translated">本示例涉及原始选项的使用。考虑一个Linux系统，您要在堆栈中的协议级别 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 上设置选项 &lt;code&gt;TCP_LINGER2&lt;/code&gt; 。您知道在该特定系统上，它的默认值为60（秒），但是对于特定的套接字，您希望将其降低到30。选项 &lt;code&gt;TCP_LINGER2&lt;/code&gt; 不受 &lt;code&gt;inet&lt;/code&gt; 明确支持，但是您知道协议级别转换为数字6，选项编号转换为数字8，并且该值将指定为32位整数。您可以使用此代码行为名为 &lt;code&gt;Sock&lt;/code&gt; 的套接字设置选项：</target>
        </trans-unit>
        <trans-unit id="530266a6d25402966cea0cb8b232a85a4ff316d8" translate="yes" xml:space="preserve">
          <source>This example gives a rough idea of how the new primitives can be used and what kind of output it produces.</source>
          <target state="translated">这个示例大致介绍了如何使用新基元及其产生的输出。</target>
        </trans-unit>
        <trans-unit id="0ddfeb93d9d64b8470aa81333fa112e188816f26" translate="yes" xml:space="preserve">
          <source>This example has two functions:</source>
          <target state="translated">这个例子有两个功能。</target>
        </trans-unit>
        <trans-unit id="2408082cfd117d50361179146f7eb693e76f1486" translate="yes" xml:space="preserve">
          <source>This example illustrates the most used calls in match specifications for &lt;code&gt;dbg&lt;/code&gt;. The other, more esoteric, calls are listed and explained in &lt;code&gt;Match specifications in Erlang&lt;/code&gt; in ERTS User's Guide, as they are beyond the scope of this description.</source>
          <target state="translated">此示例说明了 &lt;code&gt;dbg&lt;/code&gt; 的匹配规范中最常用的调用。其他更深奥的呼叫在ERTS用户指南的 &lt;code&gt;Match specifications in Erlang&lt;/code&gt; 中的Match规范中列出并说明，因为它们不在本说明的范围之内。</target>
        </trans-unit>
        <trans-unit id="033dde8b7dbcadc4f83a911a11c711666e02a4d2" translate="yes" xml:space="preserve">
          <source>This example is, as can be seen, run in an environment where the terminal supports Unicode input and output.</source>
          <target state="translated">可以看出,这个例子是在终端支持Unicode输入和输出的环境下运行的。</target>
        </trans-unit>
        <trans-unit id="140c4136b4fe3317fa34f309b20873f708ff5543" translate="yes" xml:space="preserve">
          <source>This example only shows the message passing logic - no attempt has been made to provide a nice graphical user interface, although this can also be done in Erlang.</source>
          <target state="translated">这个例子只显示了消息传递的逻辑--没有试图提供一个漂亮的图形用户界面,尽管这在Erlang中也可以做到。</target>
        </trans-unit>
        <trans-unit id="d78541768b15176d63561103133f9d3936557387" translate="yes" xml:space="preserve">
          <source>This example requires no special knowledge of match specifications to understand. The head of the fun matches what you want to filter out and the body returns what you want returned. As long as the fun can be kept within the limits of the match specifications, there is no need to transfer all table data to the process for filtering as in the &lt;code&gt;ets:foldr/3&lt;/code&gt; example. It is easier to read than the &lt;code&gt;ets:foldr/3&lt;/code&gt; example, as the select call in itself discards anything that does not match, while the fun of the &lt;code&gt;ets:foldr/3&lt;/code&gt; call needs to handle both the elements matching and the ones not matching.</source>
          <target state="translated">此示例不需要了解匹配规范的特殊知识。乐趣的头部与您要过滤的内容相匹配，主体返回您想要的内容。只要可以将乐趣保持在匹配规范的范围内，就不需要像 &lt;code&gt;ets:foldr/3&lt;/code&gt; 示例中那样将所有表数据传输到用于过滤的过程中。比 &lt;code&gt;ets:foldr/3&lt;/code&gt; 示例更容易阅读，因为select调用本身会丢弃不匹配的任何内容，而 &lt;code&gt;ets:foldr/3&lt;/code&gt; 调用的乐趣则需要处理匹配的元素和不匹配的元素。</target>
        </trans-unit>
        <trans-unit id="bf3189bf5037bf6c221e85b916b6c16513c6b111" translate="yes" xml:space="preserve">
          <source>This example showed that we could augment the set of algorithms with a config-file without the need to change the actual call.</source>
          <target state="translated">这个例子表明,我们可以用配置文件来增强算法集,而不需要改变实际的调用。</target>
        </trans-unit>
        <trans-unit id="742fc993326979930f137bea9115c77d5cbe9464" translate="yes" xml:space="preserve">
          <source>This example showed the use of &lt;code&gt;trunc&lt;/code&gt;. It is easier to use the Erlang operator &lt;code&gt;rem&lt;/code&gt; that gives the remainder after division, for example:</source>
          <target state="translated">这个例子展示了 &lt;code&gt;trunc&lt;/code&gt; 的用法。使用Erlang运算符 &lt;code&gt;rem&lt;/code&gt; 比较容易，该运算符给出除法后的余数，例如：</target>
        </trans-unit>
        <trans-unit id="1657ddee206598159941c1bc09bfc039bda09595" translate="yes" xml:space="preserve">
          <source>This example shows first the encryption of two blocks and then decryptions of the cipher text, but divided into three blocks just to show that it is possible to divide the plain text and cipher text differently for some ciphers:</source>
          <target state="translated">这个例子先展示了两个区块的加密,再展示了密文的解密,但分成了三个区块,只是为了说明对于某些密码来说,明文和密文的划分是可以不同的。</target>
        </trans-unit>
        <trans-unit id="576a654b801abd888323686420eb2be87d1e88d9" translate="yes" xml:space="preserve">
          <source>This example shows how to construct a key reference that is used in a sign operation. The actual key is stored in the engine that is loaded at prompt 1.</source>
          <target state="translated">这个例子展示了如何构造一个在符号操作中使用的键引用。实际的密钥存储在提示1加载的引擎中。</target>
        </trans-unit>
        <trans-unit id="8fc9c6e1c892b5ff940b330284e799595fb70aed" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database called &lt;code&gt;Company&lt;/code&gt; and the relationships shown in the following diagram:</source>
          <target state="translated">本示例说明如何创建一个名为 &lt;code&gt;Company&lt;/code&gt; 的数据库以及下图所示的关系：</target>
        </trans-unit>
        <trans-unit id="4ce8c4280e865227838d76a758d3b12d799a6916" translate="yes" xml:space="preserve">
          <source>This example shows that a function is generated by the compiler that returns a valid Erlang representation of the value, although the value is of a complex type.</source>
          <target state="translated">这个例子表明,编译器生成了一个函数,该函数返回一个有效的Erlang表示值,尽管该值是一个复杂类型。</target>
        </trans-unit>
        <trans-unit id="50ace829c34f91c2367e23e83ddbe5d2a03a399f" translate="yes" xml:space="preserve">
          <source>This example specifies the same tests as the original example. But now if started with a call to &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt;, test &lt;code&gt;t1&lt;/code&gt; is executed on node &lt;code&gt;ct_node@host_x&lt;/code&gt; (&lt;code&gt;node1&lt;/code&gt;), test &lt;code&gt;t2&lt;/code&gt; on &lt;code&gt;ct_node@host_y&lt;/code&gt; (&lt;code&gt;node2&lt;/code&gt;) and test &lt;code&gt;t3&lt;/code&gt; on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Configuration file &lt;code&gt;t1&lt;/code&gt; is only read on &lt;code&gt;node1&lt;/code&gt; and configuration file &lt;code&gt;t2&lt;/code&gt; only on &lt;code&gt;node2&lt;/code&gt;, while the configuration file &lt;code&gt;t3&lt;/code&gt; is read on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Both test nodes write log files to the same directory. (However, the &lt;code&gt;Common Test&lt;/code&gt; Master node uses a different log directory than the test nodes.)</source>
          <target state="translated">本示例指定与原始示例相同的测试。但现在如果开始调用 &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt; ，测试 &lt;code&gt;t1&lt;/code&gt; 在节点执行 &lt;code&gt;ct_node@host_x&lt;/code&gt; （ &lt;code&gt;node1&lt;/code&gt; ），测试 &lt;code&gt;t2&lt;/code&gt; 上 &lt;code&gt;ct_node@host_y&lt;/code&gt; （ &lt;code&gt;node2&lt;/code&gt; ）和测试 &lt;code&gt;t3&lt;/code&gt; 两个 &lt;code&gt;node1&lt;/code&gt; 和 &lt;code&gt;node2&lt;/code&gt; 。配置文件 &lt;code&gt;t1&lt;/code&gt; 是只读的 &lt;code&gt;node1&lt;/code&gt; ，并配置文件 &lt;code&gt;t2&lt;/code&gt; 只在 &lt;code&gt;node2&lt;/code&gt; ，而配置文件 &lt;code&gt;t3&lt;/code&gt; 读取两个 &lt;code&gt;node1&lt;/code&gt; 和 &lt;code&gt;node2&lt;/code&gt; 。两个测试节点将日志文件写入同一目录。（但是，&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 主&amp;rdquo;节点使用的日志目录与测试节点不同。）</target>
        </trans-unit>
        <trans-unit id="f919e3be6e1b9a58c077da63d3fa4b652b1b834d" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;gen_statem:call/2&lt;/code&gt;, which waits for a reply from the server. The reply is sent with a &lt;code&gt;{reply,From,Reply}&lt;/code&gt; tuple in an action list in the &lt;code&gt;{keep_state, ...}&lt;/code&gt; tuple that retains the current state. This return form is convenient when you want to stay in the current state but do not know or care about what it is.</source>
          <target state="translated">本示例使用 &lt;code&gt;gen_statem:call/2&lt;/code&gt; ，它等待服务器的答复。在 &lt;code&gt;{keep_state, ...}&lt;/code&gt; 元组的操作列表中 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 将使用{reply，From，Reply}元组发送回复，该元组保留当前状态。当您想保持当前状态但不知道或不关心它是什么时，此返回表单很方便。</target>
        </trans-unit>
        <trans-unit id="7e5afbec3d662e48a79fce4ee47d58154c988214" translate="yes" xml:space="preserve">
          <source>This example warrants some explanation:</source>
          <target state="translated">这个例子值得解释一下。</target>
        </trans-unit>
        <trans-unit id="b3dcc44bb471a63d75b0052d4b54fe647a04cb07" translate="yes" xml:space="preserve">
          <source>This example with the &lt;code&gt;file&lt;/code&gt; module operations is not necessary to use directly, as that is what function &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; in principle does.</source>
          <target state="translated">带有 &lt;code&gt;file&lt;/code&gt; 模块操作的该示例不必直接使用，因为原则上 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 是函数。</target>
        </trans-unit>
        <trans-unit id="9e9ac426961d89606271dd5da2f24c9429dfc0a7" translate="yes" xml:space="preserve">
          <source>This expression matches if the expression &lt;code&gt;Expr&lt;/code&gt; is of type map, otherwise it fails with an exception &lt;code&gt;badmatch&lt;/code&gt;.</source>
          <target state="translated">如果表达式 &lt;code&gt;Expr&lt;/code&gt; 的类型为map，则此表达式匹配，否则它将失败，并抛出 &lt;code&gt;badmatch&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="6184c20ff4fb14fe7267625d422557cd4d0fc7b2" translate="yes" xml:space="preserve">
          <source>This expression must be rewritten into the following, to be accepted by the compiler:</source>
          <target state="translated">这个表达式必须改写成以下内容,才能被编译器接受。</target>
        </trans-unit>
        <trans-unit id="87be2665458e0e8a04daa6def7ad816271a337f0" translate="yes" xml:space="preserve">
          <source>This feature also requires &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; to be enabled. When enabling this feature, multiple thread-specific instances are enabled if not already enabled, and the &lt;code&gt;aoffcbf&lt;/code&gt; strategy is enabled if the current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the &lt;code&gt;alloc_util&lt;/code&gt; framework, except &lt;code&gt;temp_alloc&lt;/code&gt; (which would be pointless).</source>
          <target state="translated">此功能还需要启用 &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; 。启用此功能时，如果尚未启用多个特定于线程的实例，则启用该功能；如果当前策略不支持废弃的载波，则启用 &lt;code&gt;aoffcbf&lt;/code&gt; 策略。可以在所有基于 &lt;code&gt;alloc_util&lt;/code&gt; 框架的分配器上启用此功能，但 &lt;code&gt;temp_alloc&lt;/code&gt; 除外（这将毫无意义）。</target>
        </trans-unit>
        <trans-unit id="bab1aaa22d7c52e3e995a41f937d2e85596d7686" translate="yes" xml:space="preserve">
          <source>This feature has been introduced as a temporary workaround for long-executing native code, and native code that does not bump reductions properly in OTP. When these bugs have be fixed, this flag will be removed.</source>
          <target state="translated">此功能的引入是作为一种临时的变通方法,适用于长时间执行的原生代码,以及在OTP中不能正确进行撞库的原生代码。当这些错误被修复后,这个标志将被移除。</target>
        </trans-unit>
        <trans-unit id="f75f84efbe70a72e01ed3ffc4edbe4eb52121806" translate="yes" xml:space="preserve">
          <source>This feature is similar to a lookbehind assertion (described below). However, in this case, the part of the subject before the real match does not have to be of fixed length, as lookbehind assertions do. The use of \K does not interfere with the setting of captured substrings. For example, when the following pattern matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;:</source>
          <target state="translated">这个功能类似于lookbehind断言(如下所述)。然而,在这种情况下,真正匹配之前的主题部分不必像lookbehind断言那样是固定长度的。使用\K不会干扰捕获子串的设置。例如,当下面的模式匹配 &quot;foobar &quot;时,第一个子串仍然被设置为 &quot;foo&quot;。</target>
        </trans-unit>
        <trans-unit id="495e6e419f3ba6bc2ae861673f26fe3c4b80e6f5" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in a future release</source>
          <target state="translated">此功能是暂时的,将在未来的版本中删除。</target>
        </trans-unit>
        <trans-unit id="bd4f30e27a6dd0784703ad9bdea45ca916a2edb1" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in future releases.</source>
          <target state="translated">这个功能是暂时的,在以后的版本中会被删除。</target>
        </trans-unit>
        <trans-unit id="77b5f46e3e133913367475d2045dfdc254bfa20f" translate="yes" xml:space="preserve">
          <source>This feature must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">必须使用源模块中的编译器选项或 &lt;code&gt;-compile()&lt;/code&gt; 属性显式启用此功能。</target>
        </trans-unit>
        <trans-unit id="aa96a44c28979dae84ca1a2a0e7d8160bebc38ef" translate="yes" xml:space="preserve">
          <source>This feature was added in Erlang 5.0/OTP R7.</source>
          <target state="translated">这个功能是在Erlang 5.0/OTP R7中加入的。</target>
        </trans-unit>
        <trans-unit id="1fc9bd5588c9ab451cbffd844cd0ccc06f39f29c" translate="yes" xml:space="preserve">
          <source>This field is either to be equal to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;. An old driver (not aware of the extended driver interface) is to set this field to &lt;code&gt;0&lt;/code&gt;. If this field is &lt;code&gt;0&lt;/code&gt;, all the following fields &lt;strong&gt;must&lt;/strong&gt; also be &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if it is a pointer field.</source>
          <target state="translated">该字段等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 。旧的驱动程序（不知道扩展的驱动程序接口）将将此字段设置为 &lt;code&gt;0&lt;/code&gt; 。如果此字段为 &lt;code&gt;0&lt;/code&gt; ，则以下所有字段也&lt;strong&gt;必须&lt;/strong&gt;为 &lt;code&gt;0&lt;/code&gt; ，如果它是指针字段则为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0406d7a19c673109ce77b1bb24bda04bd2987652" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator modifies this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">该字段保留给仿真器内部使用。仿真器会修改此字段，因此不要将 &lt;code&gt;driver_entry&lt;/code&gt; 声明为 &lt;code&gt;const&lt;/code&gt; ，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="881f24225a8501e9d8e685397754715f57019f9b" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator will modify this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">该字段保留给仿真器内部使用。仿真器将修改此字段，因此不要将 &lt;code&gt;driver_entry&lt;/code&gt; 声明为 &lt;code&gt;const&lt;/code&gt; ，这一点很重要。</target>
        </trans-unit>
        <trans-unit id="d71232de0ecbfffa5c29cf32c925bafa8bc48c5f" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">此字段是等于 &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; 如果场 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad9c786ae5049c8d53b5e5f11b7a559ebf7746cc" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">此字段是等于 &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; 如果场 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e98f5c415766c2c77bb045a0e8a36481a3244e3" translate="yes" xml:space="preserve">
          <source>This field is used to pass driver capability and other information to the runtime system. If field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;, it is to contain &lt;code&gt;0&lt;/code&gt; or driver flags (&lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt;) OR'ed bitwise. The following driver flags exist:</source>
          <target state="translated">此字段用于将驱动程序功能和其他信息传递给运行时系统。如果字段 &lt;code&gt;extended_marker&lt;/code&gt; 等于 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; ，则它将包含 &lt;code&gt;0&lt;/code&gt; 或驱动程序标志（ &lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt; ）或按位运算。存在以下驱动程序标志：</target>
        </trans-unit>
        <trans-unit id="53e33ba3e6e3853e3483bf977da426923d2e9210" translate="yes" xml:space="preserve">
          <source>This file can be &lt;code&gt;exported&lt;/code&gt; to a file structure by calling the &lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; function. This can be usefull if a measurement shall be done with an external tool. Exporting the messages creates a directory tree with the following structure:</source>
          <target state="translated">可以通过调用 &lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; 函数将该文件 &lt;code&gt;exported&lt;/code&gt; 为文件结构。如果必须使用外部工具进行测量，这将很有用。导出消息将创建具有以下结构的目录树：</target>
        </trans-unit>
        <trans-unit id="0a51732516468cf6dd3707af7a833e061746c186" translate="yes" xml:space="preserve">
          <source>This file does not need to be created manually, it can be generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. The relevant versions of the &lt;code&gt;.rel&lt;/code&gt; file, &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;.appup&lt;/code&gt; files are used as input. It is deduced which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the &lt;code&gt;.appup&lt;/code&gt; files and transformed into a single list of low-level instructions in the right order.</source>
          <target state="translated">该文件不需要手动创建，可以由 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成。 &lt;code&gt;.rel&lt;/code&gt; 文件， &lt;code&gt;.app&lt;/code&gt; 文件和 &lt;code&gt;.appup&lt;/code&gt; 文件的相关版本用作输入。推断出要添加和删除哪些应用程序，以及必须升级和/或降级哪些应用程序。这些指令是从 &lt;code&gt;.appup&lt;/code&gt; 文件中提取的，并以正确的顺序转换为低级指令的单个列表。</target>
        </trans-unit>
        <trans-unit id="1b4a5fcbbcbba39461ee90e5035cbad9ed093754" translate="yes" xml:space="preserve">
          <source>This file does not need to be created manually, it can be generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. The relevant versions of the &lt;code&gt;.rel&lt;/code&gt; file, &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;.appup&lt;/code&gt; files are used as input. It is deducted which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the &lt;code&gt;.appup&lt;/code&gt; files and transformed into a single list of low-level instructions in the right order.</source>
          <target state="translated">该文件不需要手动创建，可以通过 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 生成。 &lt;code&gt;.rel&lt;/code&gt; 文件， &lt;code&gt;.app&lt;/code&gt; 文件和 &lt;code&gt;.appup&lt;/code&gt; 文件的相关版本用作输入。可以推断出要添加和删除的应用程序，以及必须升级和/或降级的应用程序。这些指令是从 &lt;code&gt;.appup&lt;/code&gt; 文件中提取的，并以正确的顺序转换为低级指令的单个列表。</target>
        </trans-unit>
        <trans-unit id="9fb48b81944131df296ecee7753475785f0204cf" translate="yes" xml:space="preserve">
          <source>This file is automatically generated by &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;, using a release resource file (&lt;code&gt;.rel&lt;/code&gt;), application resource files (&lt;code&gt;.app&lt;/code&gt;), and application upgrade files (&lt;code&gt;.appup&lt;/code&gt;) as input.</source>
          <target state="translated">该文件由 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 使用释放资源文件（ &lt;code&gt;.rel&lt;/code&gt; ），应用程序资源文件（ &lt;code&gt;.app&lt;/code&gt; ）和应用程序升级文件（ &lt;code&gt;.appup&lt;/code&gt; ）作为输入自动生成。</target>
        </trans-unit>
        <trans-unit id="3aeac0892cbf387cc4689f055a52de4d8bad4eb9" translate="yes" xml:space="preserve">
          <source>This file is included in &lt;code&gt;mess_server.erl&lt;/code&gt;:</source>
          <target state="translated">该文件包含在 &lt;code&gt;mess_server.erl&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="0a6831b7fc3cca45884bb8df55f7ae10d0fb0b2b" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating a release upgrade file &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">生成版本升级文件 &lt;code&gt;relup&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 中的功能使用此文件。</target>
        </trans-unit>
        <trans-unit id="efd4a3fe5e769769e91e2007d57ff8d294a747ea" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating start scripts (&lt;code&gt;.script&lt;/code&gt;, &lt;code&gt;.boot&lt;/code&gt;) and release upgrade files (&lt;code&gt;relup&lt;/code&gt;).</source>
          <target state="translated">生成启动脚本（ &lt;code&gt;.script&lt;/code&gt; ， &lt;code&gt;.boot&lt;/code&gt; ）和发行升级文件（ &lt;code&gt;relup&lt;/code&gt; ）时， &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 中的功能使用此文件。</target>
        </trans-unit>
        <trans-unit id="2d508ac4a54e356dd39279346e885dd774ae9ca6" translate="yes" xml:space="preserve">
          <source>This file must be compiled before it can be used. The ASN.1 compiler checks that the syntax is correct and that the text represents proper ASN.1 code before generating an abstract syntax tree. The code-generator then uses the abstract syntax tree to generate code.</source>
          <target state="translated">这个文件在使用前必须进行编译。ASN.1编译器在生成抽象语法树之前,会检查语法是否正确,文本是否代表正确的ASN.1代码。然后,代码生成器使用抽象语法树生成代码。</target>
        </trans-unit>
        <trans-unit id="868c84f12466baa660608254f7e7fa45a1ab087f" translate="yes" xml:space="preserve">
          <source>This filter matches all events originating from a process that has its group leader on a remote node.</source>
          <target state="translated">该过滤器匹配所有来自远程节点上有组长的进程的事件。</target>
        </trans-unit>
        <trans-unit id="41612185cf4eec8055aef32ce6a1e85ef2253041" translate="yes" xml:space="preserve">
          <source>This filter matches all progress reports from &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">该过滤器匹配 &lt;code&gt;supervisor&lt;/code&gt; 和 &lt;code&gt;application_controller&lt;/code&gt; 的所有进度报告。</target>
        </trans-unit>
        <trans-unit id="3139608738bfff344c3bbc9f537737137e32b777" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on a &lt;code&gt;domain&lt;/code&gt; field in &lt;code&gt;Metadata&lt;/code&gt;. This field is optional, and the purpose of using it is to group log events from, for example, a specific functional area. This allows filtering or other specialized treatment in a Logger handler.</source>
          <target state="translated">该筛选器提供了一种基于 &lt;code&gt;Metadata&lt;/code&gt; 中的 &lt;code&gt;domain&lt;/code&gt; 字段筛选日志事件的方法。该字段是可选的，使用该字段的目的是对来自特定功能区域的日志事件进行分组。这允许在Logger处理程序中进行过滤或其他特殊处理。</target>
        </trans-unit>
        <trans-unit id="d6c38d318267fc9b1e770c2f91391135ae4bc653" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on the log level. It matches log events by comparing the log level with a specified &lt;code&gt;MatchLevel&lt;/code&gt;</source>
          <target state="translated">该过滤器提供了一种基于日志级别过滤日志事件的方法。它通过将日志级别与指定的 &lt;code&gt;MatchLevel&lt;/code&gt; 进行比较来匹配日志事件</target>
        </trans-unit>
        <trans-unit id="d91f4f911f4f31e3b8fc52c8256e3280febf9a2b" translate="yes" xml:space="preserve">
          <source>This first command enables microstate accounting for 1000 milliseconds. See &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; for more details. The second command prints the statistics gathered during that time. First three general statistics are printed.</source>
          <target state="translated">第一条命令启用微状态计费，持续时间为1000毫秒。有关更多详细信息，请参见 &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 。第二条命令显示在此期间收集的统计信息。将打印前三个常规统计信息。</target>
        </trans-unit>
        <trans-unit id="1bcacf63cfd99cc81866dfa553a1b3c4711304ba" translate="yes" xml:space="preserve">
          <source>This flag affects how the filenames are to be interpreted. On operating systems with transparent file naming, this must be specified to allow for file naming in Unicode characters (and for correct interpretation of filenames containing characters &amp;gt; 255).</source>
          <target state="translated">此标志影响如何解释文件名。在具有透明文件命名的操作系统上，必须指定此项以允许以Unicode字符命名文件（并正确解释包含&amp;gt; 255个字符的文件名）。</target>
        </trans-unit>
        <trans-unit id="401ad721e8e42c6f1dc3f91e171c1c2bd9b985da" translate="yes" xml:space="preserve">
          <source>This flag affects what is interpreted as string data when doing heuristic string detection in the shell and in &lt;code&gt;io&lt;/code&gt;/ &lt;code&gt;io_lib:format&lt;/code&gt; with the &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; and &lt;code&gt;~tP&lt;/code&gt; formatting instructions, as described earlier.</source>
          <target state="translated">这个标志会影响壳做启发式检测字符串时什么被解释为字符串数据 &lt;code&gt;io&lt;/code&gt; / &lt;code&gt;io_lib:format&lt;/code&gt; 与 &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; 和 &lt;code&gt;~tP&lt;/code&gt; 格式化指令，如前面所述。</target>
        </trans-unit>
        <trans-unit id="b90bcd3825735414823381e680fcf705ea0d5299" translate="yes" xml:space="preserve">
          <source>This flag can be removed or changed at any time without prior notice.</source>
          <target state="translated">此旗帜可随时删除或更改,无需事先通知。</target>
        </trans-unit>
        <trans-unit id="a25b86654b752dec058dc76f9788b85101c1cf33" translate="yes" xml:space="preserve">
          <source>This flag determines how messages in the message queue are stored, as follows:</source>
          <target state="translated">该标志决定了消息队列中消息的存储方式,具体如下。</target>
        </trans-unit>
        <trans-unit id="af384f81db1d48b161cd5aace187074a44597516" translate="yes" xml:space="preserve">
          <source>This flag field is optional.</source>
          <target state="translated">这个标志字段是可选的。</target>
        </trans-unit>
        <trans-unit id="26248d39ec39b326e49e6de9a0200d4728253816" translate="yes" xml:space="preserve">
          <source>This flag has effect only when the emulator is linked with the GNU C library, and uses its &lt;code&gt;malloc&lt;/code&gt; implementation.</source>
          <target state="translated">仅当仿真器与GNU C库链接并使用其 &lt;code&gt;malloc&lt;/code&gt; 实现时，此标志才有效。</target>
        </trans-unit>
        <trans-unit id="e70f57e7a7cbebfcc2d03ba88bc253eef993a7f7" translate="yes" xml:space="preserve">
          <source>This flag is only valid for allocators that have an associated carrier pool. Besides that, there are no restrictions on carrier pools to use for an allocator.</source>
          <target state="translated">这个标志只对有关联的载体池的分配器有效。除此之外,对分配器使用的载波池没有限制。</target>
        </trans-unit>
        <trans-unit id="f4f9950c6c7df7d55c31f657a13915f580c4acd7" translate="yes" xml:space="preserve">
          <source>This flag is particular useful when you want to elaborate with code loading from archives without editing the &lt;code&gt;boot script&lt;/code&gt;. For more information about interpretation of boot scripts, see &lt;code&gt;script(4)&lt;/code&gt;. The flag has also a similar effect on how the code server works; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">当您要详细说明从归档文件加载代码而不编辑 &lt;code&gt;boot script&lt;/code&gt; 时，此标志特别有用。有关启动脚本解释的更多信息，请参见 &lt;code&gt;script(4)&lt;/code&gt; 。该标志对代码服务器的工作方式也有类似的影响。参见 &lt;code&gt;code(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dbde97932c8eaba9606eccfc93ef4a1443c2369" translate="yes" xml:space="preserve">
          <source>This flag sets the maximum heap size for the calling process. If &lt;code&gt;MaxHeapSize&lt;/code&gt; is an integer, the system default values for &lt;code&gt;kill&lt;/code&gt; and &lt;code&gt;error_logger&lt;/code&gt; are used.</source>
          <target state="translated">此标志设置调用进程的最大堆大小。如果 &lt;code&gt;MaxHeapSize&lt;/code&gt; 是整数，则使用 &lt;code&gt;kill&lt;/code&gt; 和 &lt;code&gt;error_logger&lt;/code&gt; 的系统默认值。</target>
        </trans-unit>
        <trans-unit id="f9f03daf9384ca8f19df9da9a248cad12c12009a" translate="yes" xml:space="preserve">
          <source>This following definition of a &lt;code&gt;person&lt;/code&gt; is used in several examples in this section. Three fields are included, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt;, and &lt;code&gt;address&lt;/code&gt;. The default values for &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;phone&lt;/code&gt; is &quot;&quot; and [], respectively. The default value for &lt;code&gt;address&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;, since no default value is supplied for this field:</source>
          <target state="translated">在部分中的以下示例中使用了以下对 &lt;code&gt;person&lt;/code&gt; 定义。包括三个字段， &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;phone&lt;/code&gt; 和 &lt;code&gt;address&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;phone&lt;/code&gt; 的默认值分别是&amp;ldquo;&amp;rdquo;和[]。 &lt;code&gt;address&lt;/code&gt; 的默认值是原子 &lt;code&gt;undefined&lt;/code&gt; ，因为此字段没有提供默认值：</target>
        </trans-unit>
        <trans-unit id="02f5811e131af42f984f54f852032dfcb1311211" translate="yes" xml:space="preserve">
          <source>This form can also be used in header files (.hrl) to declare type information for exported functions. Then these header files can be included in files that (implicitly or explicitly) import these functions.</source>
          <target state="translated">这种形式也可以在头文件(.hrl)中用于声明导出函数的类型信息。然后这些头文件可以包含在(隐式或显式)导入这些函数的文件中。</target>
        </trans-unit>
        <trans-unit id="2059c23a56cf58a2c4674e36d5fde6d6cdf2124b" translate="yes" xml:space="preserve">
          <source>This form is the one mostly used in the &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">这种形式是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; 部分中最常用的形式。</target>
        </trans-unit>
        <trans-unit id="966c16aa39dbb79b8cefa816f56010ae727285a2" translate="yes" xml:space="preserve">
          <source>This format can be used for printing any object and truncating the output so it fits a specified field:</source>
          <target state="translated">此格式可用于打印任何对象,并截断输出,使其适合指定的字段。</target>
        </trans-unit>
        <trans-unit id="be0b18a70e2d41ab8912dadf086b908126403976" translate="yes" xml:space="preserve">
          <source>This format of the EdDSA curves is temporary and may change without prior notice!</source>
          <target state="translated">EdDSA曲线的格式是临时性的,可能会在没有事先通知的情况下发生变化。</target>
        </trans-unit>
        <trans-unit id="96bf1314fc9e30514fade10f4ed25bb52dc94221" translate="yes" xml:space="preserve">
          <source>This formats the text like &lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; and outputs it like &lt;code&gt;debugMsg&lt;/code&gt;. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">这会像 &lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; 这样格式化文本，并像 &lt;code&gt;debugMsg&lt;/code&gt; 一样输出文本。结果总是 &lt;code&gt;ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1dba461392e21176e94cffd9044c02a52e238da" translate="yes" xml:space="preserve">
          <source>This fun can also be used to make delays in authentication tries for example by calling &lt;code&gt;timer:sleep/1&lt;/code&gt;.</source>
          <target state="translated">这种乐趣也可用于延迟身份验证尝试，例如通过调用 &lt;code&gt;timer:sleep/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="336ab36451349be053fe7e9e786bb4268ca4fe0b" translate="yes" xml:space="preserve">
          <source>This function (&lt;code&gt;mnesia:activity/4&lt;/code&gt;) differs in an important way from the functions &lt;code&gt;mnesia:transaction&lt;/code&gt;, &lt;code&gt;mnesia:sync_transaction&lt;/code&gt;, &lt;code&gt;mnesia:async_dirty&lt;/code&gt;, &lt;code&gt;mnesia:sync_dirty&lt;/code&gt;, and &lt;code&gt;mnesia:ets&lt;/code&gt;. Argument &lt;code&gt;AccessMod&lt;/code&gt; is the name of a callback module, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; behavior.</source>
          <target state="translated">此函数（ &lt;code&gt;mnesia:activity/4&lt;/code&gt; ）与函数 &lt;code&gt;mnesia:transaction&lt;/code&gt; ， &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; ， &lt;code&gt;mnesia:async_dirty&lt;/code&gt; ， &lt;code&gt;mnesia:sync_dirty&lt;/code&gt; 和 &lt;code&gt;mnesia:ets&lt;/code&gt; 有重要的不同。参数 &lt;code&gt;AccessMod&lt;/code&gt; 是回调模块的名称，该模块实现 &lt;code&gt;mnesia_access&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="a856a99360229d9e49c9035cef153bdfeb299a54" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;never&lt;/strong&gt; returns. It calls either of the following functions:</source>
          <target state="translated">该函数&lt;strong&gt;永不&lt;/strong&gt;返回。它调用以下功能之一：</target>
        </trans-unit>
        <trans-unit id="dfd2b9df4a36c64900ffcea705f4eb600cd796ec" translate="yes" xml:space="preserve">
          <source>This function adds a remote node (&lt;code&gt;Nodename&lt;/code&gt;) to the list of nodes where tracing is performed. It starts a tracer process on the remote node, which will send all trace messages to the tracer process on the local node (via the Erlang distribution). If no tracer process is running on the local node, the error reason &lt;code&gt;no_local_tracer&lt;/code&gt; is returned. The tracer process on the local node must be started with the &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">此功能将远程节点（ &lt;code&gt;Nodename&lt;/code&gt; ）添加到执行跟踪的节点列表中。它在远程节点上启动跟踪程序，该跟踪程序会将所有跟踪消息发送到本地节点上的跟踪程序（通过Erlang分发）。如果本地节点上没有跟踪程序运行，则返回错误原因 &lt;code&gt;no_local_tracer&lt;/code&gt; 。本地节点上的跟踪器进程必须使用 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; 功能启动。</target>
        </trans-unit>
        <trans-unit id="e377bf478ddc23f833b9b7a7f1af28105f09ad03" translate="yes" xml:space="preserve">
          <source>This function always creates a new binary, even if &lt;code&gt;N = 1&lt;/code&gt;. By using &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; on a binary referencing a larger binary, one can free up the larger binary for garbage collection.</source>
          <target state="translated">即使 &lt;code&gt;N = 1&lt;/code&gt; ，此函数也始终创建一个新的二进制文件。通过在引用较大二进制文件的二进制文件上使用 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; ，可以释放较大的二进制文件以进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="72153fe9aa2fe79a7632e3bef35203ef37b284e3" translate="yes" xml:space="preserve">
          <source>This function and the related &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; provide a uniform way to extend the set of &lt;code&gt;erl_parse&lt;/code&gt; node types. The associated data is any term, whose format may depend on the type tag.</source>
          <target state="translated">该函数以及相关的 &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; 提供了一种统一的方式来扩展 &lt;code&gt;erl_parse&lt;/code&gt; 节点类型集。关联数据是任何术语，其格式可能取决于类型标签。</target>
        </trans-unit>
        <trans-unit id="433b989897815cc9d57ace923542cbea3cc51b3e" translate="yes" xml:space="preserve">
          <source>This function associates a match specification with trace event &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;. By default all executed &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; events are traced if enabled for a process. A match specification can be used to filter traced events based on sender, receiver and/or message content.</source>
          <target state="translated">该函数将匹配规范与跟踪事件 &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; 关联。默认情况下，如果为进程启用了所有执行的 &lt;code&gt;send&lt;/code&gt; 和 &lt;code&gt;'receive'&lt;/code&gt; 事件，则将对其进行跟踪。匹配规范可用于基于发送者，接收者和/或消息内容来过滤跟踪的事件。</target>
        </trans-unit>
        <trans-unit id="cc6a6435d8001a9dac7c73b8bb892f7ef3f27946" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt;, but takes a third parameter, a list of options. The only option is &lt;code&gt;noconnect&lt;/code&gt;, which makes the function return &lt;code&gt;false&lt;/code&gt; if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option &lt;code&gt;noconnect&lt;/code&gt; makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</source>
          <target state="translated">该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt; ，但采用第三个参数，即选项列表。唯一的选择是 &lt;code&gt;noconnect&lt;/code&gt; ，如果本地节点当前无法访问远程节点，则该函数将返回 &lt;code&gt;false&lt;/code&gt; 。正常的行为是尝试连接到节点，这可能会在短时间内使进程停止。使用选项 &lt;code&gt;noconnect&lt;/code&gt; 可以确保在发送到远程进程时不会有丝毫延迟。当与期望始终是连接部分的节点（即，用C或Java编写的节点）进行通信时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="89635cf270dd169c3a41d472bf8e396339e0014e" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt;, but takes a third parameter, a list of options. The only option is &lt;code&gt;noconnect&lt;/code&gt;, which makes the function return &lt;code&gt;false&lt;/code&gt; if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option &lt;code&gt;noconnect&lt;/code&gt; makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</source>
          <target state="translated">该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt; ，但采用第三个参数，即选项列表。唯一的选择是 &lt;code&gt;noconnect&lt;/code&gt; ，如果本地节点当前无法访问远程节点，则该函数将返回 &lt;code&gt;false&lt;/code&gt; 。正常行为是尝试连接到节点，这可能会在短时间内使进程停止。使用选项 &lt;code&gt;noconnect&lt;/code&gt; 可以确保在发送到远程进程时不会有丝毫延迟。当与希望始终是连接部分的节点（即，用C或Java编写的节点）进行通信时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="83333525c2547e13927665951a088eb3ec49c561" translate="yes" xml:space="preserve">
          <source>This function broadcasts a message to a list of processes:</source>
          <target state="translated">该函数向进程列表广播消息。</target>
        </trans-unit>
        <trans-unit id="925f375ec656eb11d5f62a0c683bf9b5d73e0618" translate="yes" xml:space="preserve">
          <source>This function calls the &lt;code&gt;inet:getopts/2&lt;/code&gt;, read that documentation.</source>
          <target state="translated">该函数调用 &lt;code&gt;inet:getopts/2&lt;/code&gt; ，阅读该文档。</target>
        </trans-unit>
        <trans-unit id="fbb073505ffa4a104f2a1483e1c97422cdc3c61a" translate="yes" xml:space="preserve">
          <source>This function calls the &lt;code&gt;inet:setopts/2&lt;/code&gt;, read that documentation and for &lt;code&gt;gen_tcp:option()&lt;/code&gt;.</source>
          <target state="translated">该函数调用 &lt;code&gt;inet:setopts/2&lt;/code&gt; ，阅读该文档以及 &lt;code&gt;gen_tcp:option()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acaeb65b7a88cf8025f411bf5bf4220c48f96174" translate="yes" xml:space="preserve">
          <source>This function can also be used to add a replica of the table named &lt;code&gt;schema&lt;/code&gt;.</source>
          <target state="translated">此函数还可用于添加名为 &lt;code&gt;schema&lt;/code&gt; 的表的副本。</target>
        </trans-unit>
        <trans-unit id="e0129c56bbfa8049fef6fe88075e59972e7cc29c" translate="yes" xml:space="preserve">
          <source>This function can also be used to change the storage type of the table named &lt;code&gt;schema&lt;/code&gt;. The schema table can only have &lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt; as the storage type. If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, no other table can be disc-resident on that node.</source>
          <target state="translated">此函数还可用于更改名为 &lt;code&gt;schema&lt;/code&gt; 的表的存储类型。模式表只能将 &lt;code&gt;ram_copies&lt;/code&gt; 或 &lt;code&gt;disc_copies&lt;/code&gt; 作为存储类型。如果架构的存储类型为 &lt;code&gt;ram_copies&lt;/code&gt; ，则该表上不能再有其他表驻留在该磁盘上。</target>
        </trans-unit>
        <trans-unit id="298f0bbfcd306bc36a218e1e5c945f51e02abf73" translate="yes" xml:space="preserve">
          <source>This function can also be used to delete a replica of the table named &lt;code&gt;schema&lt;/code&gt;. The Mnesia node is then removed. Notice that Mnesia must be stopped on the node first.</source>
          <target state="translated">此函数还可用于删除名为 &lt;code&gt;schema&lt;/code&gt; 的表的副本。然后删除Mnesia节点。请注意，必须先在节点上停止Mnesia。</target>
        </trans-unit>
        <trans-unit id="81355cc6547701f3b5dbcf62012e8964f7fd6864" translate="yes" xml:space="preserve">
          <source>This function can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">进程可以调用此函数以从本地主机上的EPMD中注销指定的节点。但是，这通常是不允许的，除非EPMD以标志 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 启动，但通常不会。</target>
        </trans-unit>
        <trans-unit id="0b9254d1fc6a965191d944b7d91a6f039c16821e" translate="yes" xml:space="preserve">
          <source>This function can be called from any thread if a &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; associated with the &lt;code&gt;port&lt;/code&gt; is locked by the calling thread during the call.</source>
          <target state="translated">此功能可以从任何线程，如果一个被称为 &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; 与相关的 &lt;code&gt;port&lt;/code&gt; 是通过调用线程在通话过程中锁定。</target>
        </trans-unit>
        <trans-unit id="f6c82e6849bd9680e104431bbaa2e398b9142d98" translate="yes" xml:space="preserve">
          <source>This function can be called from the net_if process at start-up. The options list defines which versions to use.</source>
          <target state="translated">这个函数可以在启动时从net_if进程中调用。选项列表定义了要使用的版本。</target>
        </trans-unit>
        <trans-unit id="f2ad971b905f90b5afe4b3c7ffde91a0186892d8" translate="yes" xml:space="preserve">
          <source>This function can be called from the shell as follows:</source>
          <target state="translated">这个函数可以在shell中调用,如下所示。</target>
        </trans-unit>
        <trans-unit id="522d795e31428058f3384591f93786fc5c38e61f" translate="yes" xml:space="preserve">
          <source>This function can be called multiple times per tracepoint, so it is important that it is both fast and without side effects.</source>
          <target state="translated">这个函数每个tracecepoint可以调用多次,所以既要快又要无副作用。</target>
        </trans-unit>
        <trans-unit id="19493e2b3285e45af7ae976c2c5428e204167ea2" translate="yes" xml:space="preserve">
          <source>This function can be described as a &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; function that does not delete any elements, but only counts them.</source>
          <target state="translated">可以将此函数描述为 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 函数，该函数不删除任何元素，仅对其进行计数。</target>
        </trans-unit>
        <trans-unit id="ce984ece3bfa8ffe74ac15019b28eb788ccbbd1c" translate="yes" xml:space="preserve">
          <source>This function can be used as follows:</source>
          <target state="translated">该功能的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="921fb0259ece312d46dac0b38aa1e96766ac7ff6" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_server&lt;/code&gt; process to explicitly send a reply to a client that called &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_server&lt;/code&gt; 进程可以使用此函数将答复显式发送给称为 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 的客户端。</target>
        </trans-unit>
        <trans-unit id="85a27177a667f0e1465cbdbd2008515b2cc73a28" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_server&lt;/code&gt; process to explicitly send a reply to a client that called &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_server&lt;/code&gt; 进程可以使用此函数将答复显式发送给称为 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 的客户端。</target>
        </trans-unit>
        <trans-unit id="2456490ca8943865684bc759cd5cd3ada4a8a3f8" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_statem&lt;/code&gt; to explicitly send a reply to a process that waits in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; when the reply cannot be defined in the return value of a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_statem&lt;/code&gt; 可以使用此函数将答复显式发送到在 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 中等待的进程。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08f1b8ca49849c35cc0d4d177f183a0add904508" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_statem&lt;/code&gt; to explicitly send a reply to a process that waits in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; when the reply cannot be defined in the return value of a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时， &lt;code&gt;gen_statem&lt;/code&gt; 可以使用此函数将答复显式发送到在 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 中等待的进程。</target>
        </trans-unit>
        <trans-unit id="8ea9dc0753a135b5574eec22abe8e746d04ba274" translate="yes" xml:space="preserve">
          <source>This function can be used by a channel to send a reply to a client that called &lt;code&gt;call/[2,3]&lt;/code&gt; when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 的返回值中定义答复时，通道可以使用此函数将答复发送给名为 &lt;code&gt;call/[2,3]&lt;/code&gt; 的客户端。</target>
        </trans-unit>
        <trans-unit id="dc2835de3bfc4793d24e098729054ecbb7df5c48" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. The crash report is sent using &lt;code&gt; logger(3)&lt;/code&gt;, and the event to be handled is of the format &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt;, where &lt;code&gt;GL&lt;/code&gt; is the group leader pid of process &lt;code&gt;Pid&lt;/code&gt; that sent the crash report.</source>
          <target state="translated">用户定义的旧版 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序可以使用此函数来格式化崩溃报告。使用 &lt;code&gt; logger(3)&lt;/code&gt; 发送崩溃报告，并且要处理的事件的格式为 &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt; ，其中 &lt;code&gt;GL&lt;/code&gt; 是发送崩溃报告的进程 &lt;code&gt;Pid&lt;/code&gt; 的组长pid。。</target>
        </trans-unit>
        <trans-unit id="db47f123c4d7737adc530bd1064733d21b41df5e" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. The crash report is sent using &lt;code&gt;logger(3)&lt;/code&gt;, and the event to be handled is of the format &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt;, where &lt;code&gt;GL&lt;/code&gt; is the group leader pid of process &lt;code&gt;Pid&lt;/code&gt; that sent the crash report.</source>
          <target state="translated">用户定义的旧版 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序可以使用此函数来格式化崩溃报告。使用 &lt;code&gt;logger(3)&lt;/code&gt; 发送崩溃报告，并且要处理的事件的格式为 &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt; ，其中 &lt;code&gt;GL&lt;/code&gt; 是发送崩溃报告的进程 &lt;code&gt;Pid&lt;/code&gt; 的组长pid。。</target>
        </trans-unit>
        <trans-unit id="9ee5cef59a670b3b68b71dece0a9f5e79fdb8155" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt;.</source>
          <target state="translated">用户定义的旧版 &lt;code&gt;error_logger&lt;/code&gt; 事件处理程序可以使用此函数来格式化崩溃报告。当Depth指定为正整数时，它在格式字符串中用于限制输出，如下所示： &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="617658033c030647cebceeeec015013360ae0d7a" translate="yes" xml:space="preserve">
          <source>This function can be used for sending &lt;code&gt;rpc&lt;/code&gt; requests that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">此功能可用于发送该模块中其他接口功能无法表达的 &lt;code&gt;rpc&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="42e7b32dc0277f5046892f45b1b0cb119299d8f7" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; to check if the status column of a table is modified.</source>
          <target state="translated">此函数可以在 &lt;code&gt;is_set_ok&lt;/code&gt; 的检测功能中使用， &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 为检查表的状态列是否被修改。</target>
        </trans-unit>
        <trans-unit id="fc3c92535fa29f8db696545ba3457c73577af82b" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve a given part of the table info.</source>
          <target state="translated">这个函数可以在仪表函数中用来检索表格信息的某一部分。</target>
        </trans-unit>
        <trans-unit id="7cdbbfa3213f416586603dfe437066c58b3bceec" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve the index types part of the table info.</source>
          <target state="translated">这个函数可以在仪表函数中用来检索表信息中的索引类型部分。</target>
        </trans-unit>
        <trans-unit id="f7be1756bfcf7a6c64caef1e2a4983a257ac163e" translate="yes" xml:space="preserve">
          <source>This function can be used to add an AGENT-CAPABILITY statement to the sysORTable in the agent. The table is defined in the SNMPv2-MIB.</source>
          <target state="translated">这个函数可以用来向代理中的sysORTable添加AGENT-CAPABILITY语句。该表在SNMPv2-MIB中定义。</target>
        </trans-unit>
        <trans-unit id="c7dac437f7278e03fe570daafa7cce023be74ce5" translate="yes" xml:space="preserve">
          <source>This function can be used to delete an AGENT-CAPABILITY statement to the sysORTable in the agent. This table is defined in the SNMPv2-MIB.</source>
          <target state="translated">这个函数可以用来删除代理中sysORTable的AGENT-CAPABILITY语句。该表在SNMPv2-MIB中定义。</target>
        </trans-unit>
        <trans-unit id="6c31d13d96b292d87ce9f4d791883f49fbaeb4b3" translate="yes" xml:space="preserve">
          <source>This function can be used to do a basic validation of the doc content of &lt;code&gt;application/erlang+html&lt;/code&gt; format.</source>
          <target state="translated">此功能可用于对 &lt;code&gt;application/erlang+html&lt;/code&gt; 格式的doc内容进行基本验证。</target>
        </trans-unit>
        <trans-unit id="840ed8b7989fdd1ae020baa41575fc56dc513298" translate="yes" xml:space="preserve">
          <source>This function can be used to do whitespace normalization of &lt;code&gt;application/erlang+html&lt;/code&gt; documentation.</source>
          <target state="translated">此功能可用于对 &lt;code&gt;application/erlang+html&lt;/code&gt; 文档进行空白标准化。</target>
        </trans-unit>
        <trans-unit id="72de58b341af03e3b7cb427708c4b243cb6b024a" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly start a key update on a TLS 1.3 connection. There are two types of the key update: if &lt;strong&gt;Type&lt;/strong&gt; is set to &lt;strong&gt;write&lt;/strong&gt;, only the writing key is updated; if &lt;strong&gt;Type&lt;/strong&gt; is set to &lt;strong&gt;read_write&lt;/strong&gt;, both the reading and writing keys are updated.</source>
          <target state="translated">此功能可用于在TLS 1.3连接上显式启动密钥更新。密钥更新有两种类型：如果将&lt;strong&gt;Type&lt;/strong&gt;设置为&lt;strong&gt;write&lt;/strong&gt;，则仅更新写入密钥；如果将&lt;strong&gt;Type&lt;/strong&gt;设置为&lt;strong&gt;read_write&lt;/strong&gt;，则读取和写入键都将更新。</target>
        </trans-unit>
        <trans-unit id="1102b37c65aef3cec918cc4b7670f14b8a81dbe0" translate="yes" xml:space="preserve">
          <source>This function can be used to load object code on remote Erlang nodes. Argument &lt;code&gt;Binary&lt;/code&gt; must contain object code for &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Filename&lt;/code&gt; is only used by the code server to keep a record of from which file the object code for &lt;code&gt;Module&lt;/code&gt; comes. Thus, &lt;code&gt;Filename&lt;/code&gt; is not opened and read by the code server.</source>
          <target state="translated">此功能可用于在远程Erlang节点上加载目标代码。参数 &lt;code&gt;Binary&lt;/code&gt; 必须包含 &lt;code&gt;Module&lt;/code&gt; 的目标代码。 &lt;code&gt;Filename&lt;/code&gt; 仅由代码服务器用来记录 &lt;code&gt;Module&lt;/code&gt; 的对象代码来自哪个文件。因此， &lt;code&gt;Filename&lt;/code&gt; 不会被代码服务器打开和读取。</target>
        </trans-unit>
        <trans-unit id="8a7a1c49364121587618310df79e658f758f578a" translate="yes" xml:space="preserve">
          <source>This function can be used to manually dump the database to file.</source>
          <target state="translated">这个功能可以用来手动将数据库转储到文件中。</target>
        </trans-unit>
        <trans-unit id="b39cd5560dc28e0d7d30d0cfa028ea7e687fcd3a" translate="yes" xml:space="preserve">
          <source>This function can be used to receive asynchronous notifications when OS-specific event objects become ready for either read or write operations.</source>
          <target state="translated">当操作系统特定的事件对象准备好进行读或写操作时,该函数可用于接收异步通知。</target>
        </trans-unit>
        <trans-unit id="4f3a58dc913baae062f654243c29c7f5eb0a4f46" translate="yes" xml:space="preserve">
          <source>This function can be used to restore an opaque continuation returned by &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; if the continuation has passed through external term format (been sent between nodes or stored on disk).</source>
          <target state="translated">如果连续性已通过外部术语格式传递（在节点之间发送或存储在磁盘上），则此功能可用于恢复由 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 返回的不透明连续性。</target>
        </trans-unit>
        <trans-unit id="fd7807ec473936d9df7098fd46d3b3b79853551d" translate="yes" xml:space="preserve">
          <source>This function can be useful when a node is started, and the names of the other network nodes are not initially known.</source>
          <target state="translated">当一个节点被启动,而其他网络节点的名称最初并不知道时,这个功能可以很有用。</target>
        </trans-unit>
        <trans-unit id="2f62afda090010612a0f62b821ddb83bdcfdcffb" translate="yes" xml:space="preserve">
          <source>This function can fail with one of the following error reasons:</source>
          <target state="translated">该函数可能因以下错误原因而失败。</target>
        </trans-unit>
        <trans-unit id="ba63a9a987b164fc62f29fa35526154bc8f7f106" translate="yes" xml:space="preserve">
          <source>This function can introduce some output latency (reading input without producing any output).</source>
          <target state="translated">这个函数可能会引入一些输出延迟(读取输入而不产生任何输出)。</target>
        </trans-unit>
        <trans-unit id="988314974f83c89323479c44bd0becefb3b2384f" translate="yes" xml:space="preserve">
          <source>This function can not change the result of the test case by returning skip or fail tuples, but it may insert items in &lt;code&gt;Config&lt;/code&gt; that can be read in &lt;code&gt;end_per_testcase/2&lt;/code&gt; or in &lt;code&gt;post_end_per_testcase/5&lt;/code&gt;.</source>
          <target state="translated">此函数无法通过返回跳过或失败元组来更改测试用例的结果，但是它可能会在 &lt;code&gt;Config&lt;/code&gt; 中插入可以在 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 或 &lt;code&gt;post_end_per_testcase/5&lt;/code&gt; 中读取的项目。</target>
        </trans-unit>
        <trans-unit id="6e10609e0797e589efd9411b6aba855461126929" translate="yes" xml:space="preserve">
          <source>This function can only be used from a NIF-calling thread, and with an environment corresponding to currently executing processes.</source>
          <target state="translated">该函数只能在NIF调用的线程中使用,且环境与当前执行的进程相对应。</target>
        </trans-unit>
        <trans-unit id="e042388a21a809a3fccbdc2d157a9abe40eeec97" translate="yes" xml:space="preserve">
          <source>This function can return multiple addresses for multihomed sockets, such as SCTP sockets. For other sockets it returns a one-element list.</source>
          <target state="translated">这个函数可以返回多套接字的多个地址,比如SCTP套接字。对于其他套接字,它返回一个单元素列表。</target>
        </trans-unit>
        <trans-unit id="11d63c52aba2de9f19866ae14e84baa28f340645" translate="yes" xml:space="preserve">
          <source>This function cannot be used on &lt;code&gt;local_content&lt;/code&gt; tables.</source>
          <target state="translated">此函数不能在 &lt;code&gt;local_content&lt;/code&gt; 表上使用。</target>
        </trans-unit>
        <trans-unit id="87440255dae77d1bf8907255759052234cd4e35c" translate="yes" xml:space="preserve">
          <source>This function cannot change the result of the test case by returning skip or fail tuples, but it may insert items in &lt;code&gt;Config&lt;/code&gt; that can be read in &lt;code&gt;end_per_testcase/2&lt;/code&gt; or in &lt;code&gt;post_end_per_testcase/5&lt;/code&gt;.</source>
          <target state="translated">此函数无法通过返回跳过或失败的元组来更改测试用例的结果，但是它可以在 &lt;code&gt;Config&lt;/code&gt; 中插入可以在 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 或 &lt;code&gt;post_end_per_testcase/5&lt;/code&gt; 中读取的项目。</target>
        </trans-unit>
        <trans-unit id="fe1d649e804662b3a5a46052ca328e2902ff015f" translate="yes" xml:space="preserve">
          <source>This function checks if a date is a valid.</source>
          <target state="translated">该函数检查日期是否有效。</target>
        </trans-unit>
        <trans-unit id="3517712921153c86ac3e375c1576c43c6781f969" translate="yes" xml:space="preserve">
          <source>This function checks that the</source>
          <target state="translated">该函数检查</target>
        </trans-unit>
        <trans-unit id="ddd56f29dbf260ed1f448685268e0f12bf606e89" translate="yes" xml:space="preserve">
          <source>This function checks whether microstate accounting is available or not.</source>
          <target state="translated">该功能可以检查是否有微观状态的核算。</target>
        </trans-unit>
        <trans-unit id="e7a6086739c9e28533ed8c3e368502ee3f910824" translate="yes" xml:space="preserve">
          <source>This function clears match specifications for the specified trace event (&lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;). It will revert back to the default behavior of tracing all triggered events.</source>
          <target state="translated">此函数清除指定跟踪事件（ &lt;code&gt;send&lt;/code&gt; 或 &lt;code&gt;'receive'&lt;/code&gt; ）的匹配规范。它将恢复为跟踪所有触发事件的默认行为。</target>
        </trans-unit>
        <trans-unit id="4c77841076843635a1a94dc794341ef980b21d96" translate="yes" xml:space="preserve">
          <source>This function connects the socket to the address specied by the &lt;code&gt;SockAddr&lt;/code&gt; argument.</source>
          <target state="translated">此函数将套接字连接到 &lt;code&gt;SockAddr&lt;/code&gt; 参数指定的地址。</target>
        </trans-unit>
        <trans-unit id="6638616d01daa0310e5374bdd67d7c94f4479869" translate="yes" xml:space="preserve">
          <source>This function controls if user tags are to be spread to other processes with the next message. Spreading of user tags work like spreading of sequential trace tokens, so that a received user tag will be active in the process until the next message arrives (if that message does not also contain the user tag.</source>
          <target state="translated">这个函数控制用户标签是否要随着下一个消息扩散到其他进程。用户标签的传播工作就像传播顺序跟踪令牌一样,因此,收到的用户标签将在进程中处于活动状态,直到下一个消息到达(如果该消息不包含用户标签)。</target>
        </trans-unit>
        <trans-unit id="3f633655709ac9db491c14cd930f2f22fb70ea32" translate="yes" xml:space="preserve">
          <source>This function creates a trace port generating &lt;strong&gt;fun&lt;/strong&gt;. The &lt;strong&gt;fun&lt;/strong&gt; takes no arguments and returns a newly opened trace port. The return value from this function is suitable as a second parameter to tracer/2, i.e. &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt;.</source>
          <target state="translated">此函数创建一个跟踪端口，从而产生&lt;strong&gt;乐趣&lt;/strong&gt;。的&lt;strong&gt;乐趣&lt;/strong&gt;不带任何参数，并返回一个新开的跟踪端口。此函数的返回值适合作为tracer / 2的第二个参数，即 &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39c3cc91bfce26f7b990777dc0e4b36098e14e8" translate="yes" xml:space="preserve">
          <source>This function destructively update the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at position &lt;code&gt;Pos&lt;/code&gt;. The new counter value is returned. If no position is specified, the element directly following key (&lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt;) is updated.</source>
          <target state="translated">通过在表 &lt;code&gt;Pos&lt;/code&gt; 上的元素上增加 &lt;code&gt;Incr&lt;/code&gt; ，此功能可使用表 &lt;code&gt;Tab&lt;/code&gt; 中的键 &lt;code&gt;Key&lt;/code&gt; 破坏性地更新对象。返回新的计数器值。如果未指定位置，则更新键（ &lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt; ）之后的元素。</target>
        </trans-unit>
        <trans-unit id="ae92bc5423506c0c5495964ace9028451dd49af5" translate="yes" xml:space="preserve">
          <source>This function destructively updates the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt;. The element at position &lt;code&gt;Pos&lt;/code&gt; is given the value &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="translated">此功能使用表 &lt;code&gt;Tab&lt;/code&gt; 中的键 &lt;code&gt;Key&lt;/code&gt; 破坏性地更新对象。位置 &lt;code&gt;Pos&lt;/code&gt; 上的元素的值为 &lt;code&gt;Value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dbc5b017b8dfa31be93dfdf684be5e007a7e9bb" translate="yes" xml:space="preserve">
          <source>This function determines the set of modules to compile and the compile options to use, by first looking for the &lt;code&gt;emake&lt;/code&gt; make option, if not present reads the configuration from a file named &lt;code&gt;Emakefile&lt;/code&gt; (see below). If no such file is found, the set of modules to compile defaults to all modules in the current working directory.</source>
          <target state="translated">该功能通过首先查找 &lt;code&gt;emake&lt;/code&gt; make选项（如果不存在）从名为 &lt;code&gt;Emakefile&lt;/code&gt; 的文件中读取配置（请参见下文）来确定要编译的模块集和要使用的compile选项。如果找不到此类文件，则默认情况下，要编译的模块集为当前工作目录中的所有模块。</target>
        </trans-unit>
        <trans-unit id="64faa483024d3289527baea651fb01006a7adc8e" translate="yes" xml:space="preserve">
          <source>This function disables call tracing on the specified functions. The semantics of the parameter is the same as for the corresponding function specification in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;. Both local and global call trace is disabled.</source>
          <target state="translated">此功能禁用指定功能上的呼叫跟踪。参数的语义与 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 中的相应功能规范相同。本地和全局呼叫跟踪均被禁用。</target>
        </trans-unit>
        <trans-unit id="730e9eafa28a60b99c0ff8551559f6cf3f087431" translate="yes" xml:space="preserve">
          <source>This function does not address the problem of a deadlock. A deadlock can never occur as long as processes only lock one resource at a time. A deadlock can occur if some processes try to lock two or more resources. It is up to the application to detect and rectify a deadlock.</source>
          <target state="translated">这个函数并不能解决死锁的问题。只要进程一次只锁定一个资源,就不会发生死锁。如果一些进程试图锁定两个或更多的资源,就会发生死锁。由应用程序来检测和纠正死锁。</target>
        </trans-unit>
        <trans-unit id="35227fc1f3835cb57763b0f1a4bfacec807769bc" translate="yes" xml:space="preserve">
          <source>This function does not return. It handles the system message and then either calls the following if process execution is to continue:</source>
          <target state="translated">这个函数不返回。它处理系统消息,然后如果要继续执行进程,则调用以下函数。</target>
        </trans-unit>
        <trans-unit id="0b16f3df149c3928770bb6f3facb54e082bb7a4e" translate="yes" xml:space="preserve">
          <source>This function does the same as (and does call) the &lt;code&gt; hibernate/3&lt;/code&gt; BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</source>
          <target state="translated">该功能与 &lt;code&gt; hibernate/3&lt;/code&gt; BIF相同（并调用），但确保在进程唤醒时异常处理和日志记录按预期继续工作。</target>
        </trans-unit>
        <trans-unit id="faacbdb3dacf5784f01df9011f0ba223b7d60c23" translate="yes" xml:space="preserve">
          <source>This function does the same as (and does call) the &lt;code&gt;hibernate/3&lt;/code&gt; BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</source>
          <target state="translated">此功能与 &lt;code&gt;hibernate/3&lt;/code&gt; BIF 相同（并且确实会进行调用），但可确保在进程唤醒时异常处理和日志记录按预期继续工作。</target>
        </trans-unit>
        <trans-unit id="36733f4f0e4a47c473ebe622e8727d51028dd793" translate="yes" xml:space="preserve">
          <source>This function enables call trace for one or more functions. All exported functions matching the &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; argument will be concerned, but the &lt;code&gt;match_spec()&lt;/code&gt; may further narrow down the set of function calls generating trace messages.</source>
          <target state="translated">此功能启用一个或多个功能的呼叫跟踪。将考虑所有与 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 参数匹配的导出函数，但是 &lt;code&gt;match_spec()&lt;/code&gt; 可以进一步缩小生成跟踪消息的函数调用的范围。</target>
        </trans-unit>
        <trans-unit id="368666e6ad2867a60cda73d9bf0c86e3149c145a" translate="yes" xml:space="preserve">
          <source>This function ensures that the results displayed by &lt;code&gt;analyze/0,1,2&lt;/code&gt; are printed both to the file &lt;code&gt;File&lt;/code&gt; and the screen.</source>
          <target state="translated">此功能确保将 &lt;code&gt;analyze/0,1,2&lt;/code&gt; 显示的结果打印到文件 &lt;code&gt;File&lt;/code&gt; 和屏幕上。</target>
        </trans-unit>
        <trans-unit id="1a7330bbeab182a749c3e5f5deba94d5a86ea474" translate="yes" xml:space="preserve">
          <source>This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. &lt;code&gt;Process&lt;/code&gt; can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process &lt;code&gt;Pid&lt;/code&gt; fetched through an &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; function call.</source>
          <target state="translated">此函数提取使用此模块中的spawn或start函数之一启动的进程的初始调用，并将其转换为更多有用的信息。 &lt;code&gt;Process&lt;/code&gt; 可以是pid，整数元组（可以从中创建pid），也可以是通过 &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; 函数调用获取的进程 &lt;code&gt;Pid&lt;/code&gt; 的进程信息。</target>
        </trans-unit>
        <trans-unit id="0051f23484a69ef2e8f6f7524656de38ffd28765" translate="yes" xml:space="preserve">
          <source>This function fail with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;ReqId&lt;/code&gt; is not a reference.</source>
          <target state="translated">如果 &lt;code&gt;ReqId&lt;/code&gt; 不是引用，则此函数失败，并出现 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e682f273c8e96989f5d96e73eb77713bc1444f02" translate="yes" xml:space="preserve">
          <source>This function fails if the atom is too long for the buffer or if it cannot be represented with encoding &lt;code&gt;want&lt;/code&gt;.</source>
          <target state="translated">如果该原子对于缓冲区而言太长，或者无法用 &lt;code&gt;want&lt;/code&gt; 编码表示，则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="83106e1343a863599453b8ae91e66534e53d1ef0" translate="yes" xml:space="preserve">
          <source>This function fails with a &lt;code&gt;badarg&lt;/code&gt; exception if no term has been stored with the key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">如果没有与 &lt;code&gt;Key&lt;/code&gt; 一起存储任何术语，则此函数将失败，并出现 &lt;code&gt;badarg&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="0da14902361aba9b7fcf3f2ac32b625e0ac51f73" translate="yes" xml:space="preserve">
          <source>This function first attempts to autoload &lt;code&gt;Module&lt;/code&gt;. If that is not possible, an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">此函数首先尝试自动加载 &lt;code&gt;Module&lt;/code&gt; 。如果这不可能，则会引发 &lt;code&gt;undef&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="2d26740fa881de95c3af6c29ab8da1324a33cbdf" translate="yes" xml:space="preserve">
          <source>This function first spawns a process &lt;code&gt;P&lt;/code&gt; which evaluates &lt;code&gt;Fun()&lt;/code&gt; or &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt;. Then, it starts profiling for &lt;code&gt;P&lt;/code&gt; and the processes in &lt;code&gt;Rootset&lt;/code&gt; (and any new processes spawned from them). Information about activity in any profiled process is stored in the Eprof database.</source>
          <target state="translated">此函数首先产生一个进程 &lt;code&gt;P&lt;/code&gt; ，该进程评估 &lt;code&gt;Fun()&lt;/code&gt; 或 &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt; 。然后，它开始对 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;Rootset&lt;/code&gt; 中的进程（以及由此产生的任何新进程）进行性能分析。有关任何概要分析过程中的活动的信息都存储在Eprof数据库中。</target>
        </trans-unit>
        <trans-unit id="a51eb8328b3ca7e73bd2ddec9c6cd1f1f6bce2fa" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.</source>
          <target state="translated">如果未为过程字典中的状态中指定的算法实现跳转功能，则此函数会生成一个 &lt;code&gt;not_implemented&lt;/code&gt; 错误异常。</target>
        </trans-unit>
        <trans-unit id="886d1bea974ef611ef862bdf736eeb1b8ee5deb0" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state.</source>
          <target state="translated">如果未为状态中指定的算法实现跳转功能，则此函数会生成 &lt;code&gt;not_implemented&lt;/code&gt; 错误异常。</target>
        </trans-unit>
        <trans-unit id="6058a385a21e4246b670869f65aa6fd981a5a8b7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations and by Mnesia during transactions.</source>
          <target state="translated">此功能在普通代码中的使用受到限制。 &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 模块使用它来执行 &lt;code&gt;dets:select()&lt;/code&gt; 操作，交易期间Mnesia 可以使用它。</target>
        </trans-unit>
        <trans-unit id="523fd33cf3afa46e759133c868d60920d18b1dc7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations.</source>
          <target state="translated">此功能在普通代码中的使用受到限制。 &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 模块使用它来执行 &lt;code&gt;dets:select()&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="d58459e2ceed77eb8305bceed246e818de9ca01c" translate="yes" xml:space="preserve">
          <source>This function implements case normalization, percent-encoding normalization, path segment normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP.</source>
          <target state="translated">该函数实现了HTTP(S)的大小写归一化、百分比编码归一化、路径段归一化和基于方案的归一化,基本支持FTP、SSH、SFTP和TFTP。</target>
        </trans-unit>
        <trans-unit id="c8514d81ff22e1ff67620750cdc3dfb27e9e6f77" translate="yes" xml:space="preserve">
          <source>This function initiates the DBMS locally.</source>
          <target state="translated">该函数在本地启动DBMS。</target>
        </trans-unit>
        <trans-unit id="57afe95d276fab56b0cc11453585653b09b00be9" translate="yes" xml:space="preserve">
          <source>This function investigates if support is available for either &lt;code&gt;&lt;a href=&quot;http://www.quviq.com&quot;&gt;QuickCheck&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://proper-testing.github.io&quot;&gt;PropEr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://github.com/krestenkrab/triq&quot;&gt;Triq&lt;/a&gt;&lt;/code&gt; and compiles the properties with the first tool found. It is supposed to be called in the &lt;code&gt;init_per_suite/1&lt;/code&gt; function in a CommonTest test suite.</source>
          <target state="translated">该功能是否支持调查适用于任何 &lt;code&gt;&lt;a href=&quot;http://www.quviq.com&quot;&gt;QuickCheck&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://proper-testing.github.io&quot;&gt;PropEr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://github.com/krestenkrab/triq&quot;&gt;Triq&lt;/a&gt;&lt;/code&gt; 和编译与第一工具的属性中找到。应该在 &lt;code&gt;init_per_suite/1&lt;/code&gt; 测试套件的init_per_suite / 1函数中调用它。</target>
        </trans-unit>
        <trans-unit id="fcbc273861fed1e51bf947867b1a084c27622209" translate="yes" xml:space="preserve">
          <source>This function investigates if support is available for either Quickcheck, PropEr, or Triq. The options &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; and &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; are set in the &lt;code&gt;Config&lt;/code&gt; returned.</source>
          <target state="translated">此功能将调查是否支持Quickcheck，PropEr或Triq。在返回的 &lt;code&gt;Config&lt;/code&gt; 中设置了 &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; 和 &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6a7d3a4b7f3328d175ce6a9a9eb8e20886f3bda3" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能是 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="423ca16d197ccc978bd5081d6b3eb1c403bc0744" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a516abdfc30d7c9e3685abf6e57bb1e1d0b658e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52d494db0c1567d04ee40812bdffbefd6c016473" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab94cedb464e4260389af7be6dfaf6ffb7bd2291" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="205cdd304fd7174c14274c85d2328b2a17ae0a9e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef02bd0b5153d37d1fa93514bd445ad29bc64930" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba5aba1911d9f1f71e6680b8d5f950e286eccad6" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0297c83560fb40b3e25160700b963d4d28d8cb3d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9483920738b267719838628a8df6eae176da3415" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29b69004da0d2e1742321c5e08d6472bd345f1bd" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1fca9e1ff35bcfc01c17bd46889f3070478dc5b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="206343ba93558e03d83b7d9b6041c45a9f4e4762" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdc288f4c8566ab96ad5a3c012d039a6f14b114d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad0121ab408cec82bbe0b526be72140c81e0eb43" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;[String1, String2]&lt;/code&gt; as &lt;code&gt;Data&lt;/code&gt; argument, and call &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt; unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt; unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; to flatten the output.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;[String1, String2]&lt;/code&gt; 作为 &lt;code&gt;Data&lt;/code&gt; 参数，并调用 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt; unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt; unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; 来展平输出。</target>
        </trans-unit>
        <trans-unit id="be41039c1c345076e4346d099bd59b24ee69b28b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;[String1, String2]&lt;/code&gt; as &lt;code&gt;Data&lt;/code&gt; argument, and call &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; to flatten the output.</source>
          <target state="translated">此功能已 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;[String1, String2]&lt;/code&gt; 作为 &lt;code&gt;Data&lt;/code&gt; 参数，并调用 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; 来展平输出。</target>
        </trans-unit>
        <trans-unit id="0fe0ff73852f97430972aade26b365aeb9d4dcca" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;not&lt;/strong&gt; to have any side effects, as it can be called multiple times by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">此功能&lt;strong&gt;不会&lt;/strong&gt;有任何副作用，因为 &lt;code&gt;Common Test&lt;/code&gt; 可以多次调用它。</target>
        </trans-unit>
        <trans-unit id="d1601bc7321a92135715173d0e057687db27b297" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;only&lt;/strong&gt; intended to be used from functions called by the Erl Scheme interface to deliver parts of the content to the user.</source>
          <target state="translated">此功能&lt;strong&gt;仅&lt;/strong&gt;旨在从Erl Scheme接口调用的功能中使用，以将部分内容交付给用户。</target>
        </trans-unit>
        <trans-unit id="c89b38cb90d4a8e0a8fc69ed167ebc21578ef61c" translate="yes" xml:space="preserve">
          <source>This function is a convenience function that calls &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;logger:set_module_level/2&lt;/a&gt;&lt;/code&gt; for each module associated with an application.</source>
          <target state="translated">此函数是一项便捷函数，它为与应用程序关联的每个模块调用 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;logger:set_module_level/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d39ae8bfc4be5823eb01c3edca7562d0f24640b9" translate="yes" xml:space="preserve">
          <source>This function is a convinience function that calls &lt;code&gt;&lt;a href=&quot;#unset_module_level-1&quot;&gt;logger:unset_module_level/2&lt;/a&gt;&lt;/code&gt; for each module associated with an application.</source>
          <target state="translated">此函数是一种便捷函数，它为与应用程序关联的每个模块调用 &lt;code&gt;&lt;a href=&quot;#unset_module_level-1&quot;&gt;logger:unset_module_level/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aef47781d467db25a7963a68f242afbbc794ce0b" translate="yes" xml:space="preserve">
          <source>This function is a shortcut allowing to start a trace with one command. Each tuple in &lt;code&gt;Patterns&lt;/code&gt; is converted to a list, which in turn is passed to &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt;.</source>
          <target state="translated">此功能是一种快捷方式，允许使用一个命令启动跟踪。 &lt;code&gt;Patterns&lt;/code&gt; 中的每个元组都转换为一个列表，该列表又传递给 &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43d5979e9394159963538ec618354c0f2550802" translate="yes" xml:space="preserve">
          <source>This function is a utility to test a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; used in calls to &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;. The function both tests &lt;code&gt;MatchSpec&lt;/code&gt; for &quot;syntactic&quot; correctness and runs the match specification against object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">此函数是用于测试对 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; 的调用中使用的 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 的实用程序。该函数既测试 &lt;code&gt;MatchSpec&lt;/code&gt; 的&amp;ldquo;语法&amp;rdquo;正确性，又对对象 &lt;code&gt;Tuple&lt;/code&gt; 运行匹配规范。</target>
        </trans-unit>
        <trans-unit id="d988191fa0dabe515db4af812656eff83c34cb63" translate="yes" xml:space="preserve">
          <source>This function is always called before any other callback function. Use it to initiate any common state. It is to return a state for this CTH.</source>
          <target state="translated">这个函数总是在任何其他回调函数之前被调用。用它来启动任何普通状态。它是为了返回这个 CTH 的状态。</target>
        </trans-unit>
        <trans-unit id="b516bc2e9034c1590527ec443de2c6737bcd4f59" translate="yes" xml:space="preserve">
          <source>This function is asynchronous, and does not return any information. If an error occurs, &lt;code&gt;user_err/2&lt;/code&gt; of the error report module is called and the notification is discarded.</source>
          <target state="translated">该函数是异步的，并且不返回任何信息。如果发生错误，则会调用错误报告模块的 &lt;code&gt;user_err/2&lt;/code&gt; 并丢弃该通知。</target>
        </trans-unit>
        <trans-unit id="85c98f3d29d4a07045be121e9e487541dab759e4" translate="yes" xml:space="preserve">
          <source>This function is automatically run by program &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">该功能由程序 &lt;code&gt;ct_run&lt;/code&gt; 自动运行。</target>
        </trans-unit>
        <trans-unit id="3279d0d6b02338f13c8bc53782a187d1879ee456" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="9188edb1cc0ebdde86ffdb4193d6c9cead6cb834" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="5632d3f19a46e6a63364561ccdcd84c5cbd07239" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="ed2c8cbf6eea27fe25c9e2e37745c13758f418bf" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="eeb41891de5f47fa39556ecfa785a92f82d5ca45" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains extra checks to ensure that all the correct dependencies are started correctly.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用。它通常包含额外的检查，以确保正确启动所有正确的依赖项。</target>
        </trans-unit>
        <trans-unit id="ab712217cf24a26d75845255e5f1d384ed7df651" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="3219df17fd8b1eea0c06b8129d77d9cbe10e0bf9" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt;. It is used to modify the set of test cases and test group to be executed, for instance to add or remove test cases and groups, change group properties, or even skip all tests in the suite.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt; 之后调用此函数。它用于修改要执行的测试用例和测试组集，例如添加或删除测试用例和组，更改组属性，甚至跳过套件中的所有测试。</target>
        </trans-unit>
        <trans-unit id="9805b08693eb6111d0c6f22681e3bb9e3c04afab" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="2965ff805c434996c492ec9bfa82d7f12ef9f74a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="519b61330b5ab107e5552267a7095ddb95972fc7" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用该函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="c3ff042e6f427cdbf0b138b5e0423a5307d82d20" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt;. It is used to modify the test group definitions, for instance to add or remove groups or change group properties.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 之后调用此函数。它用于修改测试组定义，例如添加或删除组或更改组属性。</target>
        </trans-unit>
        <trans-unit id="7f0db9c38b62ae93794067200327fd462e7ff4fe" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="a5820559120dedeb2862c70d6818189112741a21" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains extra checks to ensure that all the correct dependencies are started correctly.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之后调用。它通常包含额外的检查，以确保正确启动所有正确的依赖项。</target>
        </trans-unit>
        <trans-unit id="3c20b079f55383c227fa6f9819a5bdb26e2f8e5a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之后调用。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="aeda1395509b804f56af9852e8e45793868dfa12" translate="yes" xml:space="preserve">
          <source>This function is called after each test case, and can be used to clean up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and the test case. Any return value (besides &lt;code&gt;{fail, Reason}&lt;/code&gt; and &lt;code&gt;{save_config, SaveConfig}&lt;/code&gt;) is ignored. By returning &lt;code&gt;{fail, Reason}&lt;/code&gt;, &lt;code&gt;TestCase&lt;/code&gt; is marked as faulty (even though it was successful in the sense that it returned a value instead of terminating).</source>
          <target state="translated">在每个测试用例之后都会调用此函数，并且可以在 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 和测试用例之后使用此函数进行清理。任何返回值（除了 &lt;code&gt;{fail, Reason}&lt;/code&gt; 和 &lt;code&gt;{save_config, SaveConfig}&lt;/code&gt; ）都将被忽略。通过返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ， &lt;code&gt;TestCase&lt;/code&gt; 被标记为错误的（即使从返回值而不是终止的意义上来说它是成功的）。</target>
        </trans-unit>
        <trans-unit id="ac4e91297af25f1c85d719157b005b8f81db41e7" translate="yes" xml:space="preserve">
          <source>This function is called after each test case, and can be used to clean up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and the test case. Any return value (besides &lt;code&gt;{fail,Reason}&lt;/code&gt; and &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt;) is ignored. By returning &lt;code&gt;{fail,Reason}&lt;/code&gt;, &lt;code&gt;TestCase&lt;/code&gt; is marked as faulty (even though it was successful in the sense that it returned a value instead of terminating).</source>
          <target state="translated">在每个测试用例之后都会调用此函数，并且可以在 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 和测试用例之后使用此函数进行清理。任何返回值（除了 &lt;code&gt;{fail,Reason}&lt;/code&gt; 和 &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt; 之外）都将被忽略。通过返回 &lt;code&gt;{fail,Reason}&lt;/code&gt; ， &lt;code&gt;TestCase&lt;/code&gt; 被标记为错误的（即使从返回值而不是终止的意义上来说它是成功的）。</target>
        </trans-unit>
        <trans-unit id="7e30b5449913eda1e06199d0387c5463aed4235b" translate="yes" xml:space="preserve">
          <source>This function is called after the execution of a test case group is finished. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt;. A status value for a nested subgroup can be returned with &lt;code&gt;{return_group_result, Status}&lt;/code&gt;. The status can be retrieved in &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; for the group on the level above. The status is also used by &lt;code&gt;Common Test&lt;/code&gt; for deciding if execution of a group is to proceed if property &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;repeat_until_*&lt;/code&gt; is set.</source>
          <target state="translated">测试用例组的执行完成后，将调用此函数。它旨在用于在 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; 之后进行清理。可以使用 &lt;code&gt;{return_group_result, Status}&lt;/code&gt; 返回嵌套子组的状态值。可以在 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; 中获取上一级组的状态。如果设置了属性 &lt;code&gt;sequence&lt;/code&gt; 或 &lt;code&gt;repeat_until_*&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 还将使用该状态来确定是否要继续执行组。</target>
        </trans-unit>
        <trans-unit id="648d9b19e4f1798cccb4aa970ca13730d675986d" translate="yes" xml:space="preserve">
          <source>This function is called after the execution of a test case group is finished. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;. A status value for a nested subgroup can be returned with &lt;code&gt;{return_group_result,Status}&lt;/code&gt;. The status can be retrieved in &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; for the group on the level above. The status is also used by &lt;code&gt;Common Test&lt;/code&gt; for deciding if execution of a group is to proceed if property &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;repeat_until_*&lt;/code&gt; is set.</source>
          <target state="translated">测试用例组的执行完成后，将调用此函数。它旨在用于 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 之后的清理。嵌套子组的状态值可以使用 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 返回。可以在上 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 检索该状态。如果设置了属性 &lt;code&gt;sequence&lt;/code&gt; 或 &lt;code&gt;repeat_until_*&lt;/code&gt; ， &lt;code&gt;Common Test&lt;/code&gt; 也使用该状态来确定是否要继续执行组。</target>
        </trans-unit>
        <trans-unit id="345b7139db6080b24fa35a4e0da978a876eccf7f" translate="yes" xml:space="preserve">
          <source>This function is called as the last test case in the suite. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能称为套件中的最后一个测试用例。它旨在用于在 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; 之后进行清理。</target>
        </trans-unit>
        <trans-unit id="897cf1fddb4813f2f697f362b138508da5c7dd0a" translate="yes" xml:space="preserve">
          <source>This function is called as the last test case in the suite. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能称为套件中的最后一个测试用例。它旨在用于 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 之后的清理。</target>
        </trans-unit>
        <trans-unit id="a0372e5f1383e52f209cab7781bd11e0c4ba8e71" translate="yes" xml:space="preserve">
          <source>This function is called at the end of a CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt; 的末尾调用此函数。</target>
        </trans-unit>
        <trans-unit id="f0807a57b644a344571e1467f9b13cb9f18d17f0" translate="yes" xml:space="preserve">
          <source>This function is called at the end of stage 1 of the discovery process. It should return either the atom &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">在发现过程的第1阶段结束时调用此功能。它应该返回原子 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt; 。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb32881cf0a426df77fb1522665bfe4e0e2538b1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之前调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="e874f35f84af17d413fa61bed6f2c2a545583190" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="5d541acf0f757f563f08bac98ff0a9411ac868f8" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="6d4fd2c714fc08ec0ac6579748777b65c3366a58" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="c4fada08cbaf8b15ce7f51c95c9fe3b326d58378" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains initialization/logging that must be done before &lt;code&gt;init_per_suite&lt;/code&gt; is called. If &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, &lt;code&gt;init_per_suite&lt;/code&gt; and all test cases of the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; printed in the overview log of the suite.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它通常包含初始化/记录，必须在 &lt;code&gt;init_per_suite&lt;/code&gt; 之前完成。如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 或 &lt;code&gt;{fail,Reason}&lt;/code&gt; ， &lt;code&gt;init_per_suite&lt;/code&gt; 跳过init_per_suite和套件的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="14766708da0b30b7e24b398d506799e96916c97e" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="7d6fc181db4b0ff6e75db5d82c2a426d2f669226" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 之前调用它。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="f27a4871105482ca23e5467359a27c568a72b833" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="a88007750928f37d5492b2d8205ae78bccd986b1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在该函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="ccff703964dc8daaeec8f102943579dce11bf4b9" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="eb9adcaaae996c1718d810cc082dbbef5007dab0" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains initialization/logging that must be done before &lt;code&gt;init_per_suite&lt;/code&gt; is called. If &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, &lt;code&gt;init_per_suite&lt;/code&gt; and all test cases of the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; printed in the overview log of the suite.</source>
          <target state="translated">如果存在此函数，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它通常包含必须在 &lt;code&gt;init_per_suite&lt;/code&gt; 之前完成的初始化/日志记录。如果返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 或 &lt;code&gt;{fail,Reason}&lt;/code&gt; ， &lt;code&gt;init_per_suite&lt;/code&gt; 跳过init_per_suite和套件的所有测试用例，并将 &lt;code&gt;Reason&lt;/code&gt; 打印在套件的概述日志中。</target>
        </trans-unit>
        <trans-unit id="5865db8d52a4bd048de6b63002a57691f1a85fd1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果存在，则在 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 之前调用此函数。它的行为与 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 相同，但是对于函数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="bcb7e548f11fe13eae236fe02392162189ee68cc" translate="yes" xml:space="preserve">
          <source>This function is called before each test case. Argument &lt;code&gt;TestCase&lt;/code&gt; is the test case name, and &lt;code&gt;Config&lt;/code&gt; (list of key-value tuples) is the configuration data that can be modified. The &lt;code&gt;NewConfig&lt;/code&gt; list returned from this function is given as &lt;code&gt;Config&lt;/code&gt; to the test case. If &lt;code&gt;{fail, Reason}&lt;/code&gt; is returned, the test case is marked as failed without being executed.</source>
          <target state="translated">在每个测试用例之前调用此函数。参数 &lt;code&gt;TestCase&lt;/code&gt; 是测试用例名称，而 &lt;code&gt;Config&lt;/code&gt; （键值元组列表）是可以修改的配置数据。从此函数返回的 &lt;code&gt;NewConfig&lt;/code&gt; 列表作为 &lt;code&gt;Config&lt;/code&gt; 给出给测试用例。如果返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ，则测试用例被标记为失败而未执行。</target>
        </trans-unit>
        <trans-unit id="3ec02031e2fa8bc763f23eebb36182a4725659b4" translate="yes" xml:space="preserve">
          <source>This function is called before each test case. Argument &lt;code&gt;TestCase&lt;/code&gt; is the test case name, and &lt;code&gt;Config&lt;/code&gt; (list of key-value tuples) is the configuration data that can be modified. The &lt;code&gt;NewConfig&lt;/code&gt; list returned from this function is given as &lt;code&gt;Config&lt;/code&gt; to the test case. If &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, the test case is marked as failed without being executed.</source>
          <target state="translated">在每个测试用例之前调用此函数。参数 &lt;code&gt;TestCase&lt;/code&gt; 是测试用例的名称，而 &lt;code&gt;Config&lt;/code&gt; （键值元组的列表）是可以修改的配置数据。从此函数返回的 &lt;code&gt;NewConfig&lt;/code&gt; 列表作为 &lt;code&gt;Config&lt;/code&gt; 给出给测试用例。如果返回 &lt;code&gt;{fail,Reason}&lt;/code&gt; ，则测试用例被标记为失败而未执行。</target>
        </trans-unit>
        <trans-unit id="7cef0bc6ae48b3bc1a5099f8d9c601b37d907e07" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_event&lt;/code&gt; process in the following situations:</source>
          <target state="translated">在以下情况下， &lt;code&gt;gen_event&lt;/code&gt; 进程将调用此函数：</target>
        </trans-unit>
        <trans-unit id="4e47279564d310806f28fccb0940fabd880414dd" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process in the following situations:</source>
          <target state="translated">在以下情况下， &lt;code&gt;gen_server&lt;/code&gt; 进程将调用此函数：</target>
        </trans-unit>
        <trans-unit id="a51ead4642d619f15354dcc0634fe8062618949d" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when a time-out occurs or when it receives any other message than a synchronous or asynchronous request (or a system message).</source>
          <target state="translated">当发生超时或当它接收到除同步或异步请求（或系统消息）以外的任何其他消息时，此函数由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。</target>
        </trans-unit>
        <trans-unit id="81f55aa9a3503931bbd4c62f78241c8bfccce378" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_server&lt;/code&gt; process terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 进程即将终止时，将调用此函数。与 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 相反，并进行所有必要的清理。返回时， &lt;code&gt;gen_server&lt;/code&gt; 进程以 &lt;code&gt;Reason&lt;/code&gt; 终止。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="7103be2d22d49472aeafdc33422e8317e9a60060" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specifed in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see section &lt;code&gt; Release Handling Instructions&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">当要在发行版升级/降级期间更新其内部状态时，即在指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; （其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; )时，此函数由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见OTP设计原则中的 &lt;code&gt; Release Handling Instructions&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="854175a561611b0f58880036cbf8c4836509caea" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specifed in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see section &lt;code&gt;Release Handling Instructions&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">当要在发行版升级/降级期间更新其内部状态时，即在指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 中，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时，此函数由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见OTP设计原则中的 &lt;code&gt;Release Handling Instructions&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="6d4c34ae1c200b76e11bc231bee8bd2807964c89" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process whenever a previous callback returns &lt;code&gt;{continue, Continue}&lt;/code&gt;. &lt;code&gt;handle_continue/2&lt;/code&gt; is invoked immediately after the previous callback, which makes it useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">每当先前的回调返回 &lt;code&gt;{continue, Continue}&lt;/code&gt; 时，此函数就会由 &lt;code&gt;gen_server&lt;/code&gt; 进程调用。 &lt;code&gt;handle_continue/2&lt;/code&gt; 在上一个回调之后立即被调用，这对于在初始化后执行工作或在回调中将工作拆分为多个步骤，沿过程更新过程状态非常有用。</target>
        </trans-unit>
        <trans-unit id="7c755e5f75a4b9ab817fb2fc0f0f130048764892" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; process when any of the following apply:</source>
          <target state="translated">当以下任何情况适用时，此函数由 &lt;code&gt;gen_statem&lt;/code&gt; 进程调用：</target>
        </trans-unit>
        <trans-unit id="012052cb437447cd791b721593de5a645b47fd05" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_statem&lt;/code&gt; terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 即将终止时会调用此函数。与 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 相反，并进行所有必要的清理。返回时， &lt;code&gt;gen_statem&lt;/code&gt; 终止于 &lt;code&gt;Reason&lt;/code&gt; 。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="5286eefe6ed32df7949b89004772557939570746" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">这个功能是通过一个名为 &lt;code&gt;gen_statem&lt;/code&gt; 当它是一个发布升级/降级，即在更新其内部状态，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; ，其中 &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; ，是在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ca2b78a5bbaa99a4fbd81da5ab6158558318d3b" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">这个功能是通过一个名为 &lt;code&gt;gen_statem&lt;/code&gt; 当它是一个发布升级/降级，即在更新其内部状态，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; ，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; ，是在 &lt;code&gt;appup&lt;/code&gt; 文件中指定。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1029bd58312f364737a518c22f5aea571963829" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it needs to find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; of the callback module. The value is cached by &lt;code&gt;gen_statem&lt;/code&gt; for efficiency reasons, so this function is only called once after server start and after code change, but before the first &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in the current code version is called. More occasions may be added in future versions of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">当需要找出回调模块的 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 时，此函数由 &lt;code&gt;gen_statem&lt;/code&gt; 调用。由于效率原因，该值由 &lt;code&gt;gen_statem&lt;/code&gt; 缓存，因此该函数仅在服务器启动之后和代码更改之后被调用一次，但是在当前代码版本中的第一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 被调用之前。 &lt;code&gt;gen_statem&lt;/code&gt; 的未来版本中可能会添加更多场合。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7042442cd0c5a7ca8465130a637143865c36ff" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it needs to find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; of the callback module. The value is cached by &lt;code&gt;gen_statem&lt;/code&gt; for efficiency reasons, so this function is only called once after server start, after code change, and after changing the callback module, but before the first &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in the current callback module's code version is called. More occasions may be added in future versions of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">当需要查找回调模块的 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 时，此函数由 &lt;code&gt;gen_statem&lt;/code&gt; 调用。出于效率原因，该值由 &lt;code&gt;gen_statem&lt;/code&gt; 缓存，因此该函数仅在服务器启动后，代码更改后和更改回调模块之后，但在当前回调模块的代码版本中的第一个 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 被调用之前被调用一次。 &lt;code&gt;gen_statem&lt;/code&gt; 的未来版本中可能会添加更多场合。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86e4a64914f5fa58c43e59cda9e1371225dd82b8" translate="yes" xml:space="preserve">
          <source>This function is called by a channel process when it is about to terminate. Before this function is called, &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt; ssh_connection:close/2 &lt;/a&gt;&lt;/code&gt; is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">即将终止时，此功能由通道进程调用。如果尚未提前调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt; ssh_connection:close/2 &lt;/a&gt;&lt;/code&gt; ，则在此函数被调用之前。此功能会进行任何必要的清理。返回时，通道过程终止，原因为 &lt;code&gt;Reason&lt;/code&gt; 。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="46850b150e8f033a9f9fa7fa23905fcd27c1aa8d" translate="yes" xml:space="preserve">
          <source>This function is called by a channel process when it is about to terminate. Before this function is called, &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">即将终止时，此功能由通道进程调用。如果尚未早先调用 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; ，则在此函数被调用之前。此功能会进行任何必要的清理。返回时，通道过程终止，原因为 &lt;code&gt;Reason&lt;/code&gt; 。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="56c006741953e55f77a4441e9b362d11c170439b" translate="yes" xml:space="preserve">
          <source>This function is called by a client-side channel when it is to update its internal state during a release upgrade or downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is given in the &lt;code&gt;appup&lt;/code&gt; file. For more information, refer to Section 9.11.6 Release Handling Instructions in the &lt;code&gt;System Documentation&lt;/code&gt;.</source>
          <target state="translated">当要在版本升级或降级期间更新其内部状态（即，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; )（其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时，客户端通道调用此函数。}在 &lt;code&gt;appup&lt;/code&gt; 文件中给出。有关更多信息，请参阅 &lt;code&gt;System Documentation&lt;/code&gt; 中的9.11.6部分发布处理说明。</target>
        </trans-unit>
        <trans-unit id="98e32bc0ee74da52ca9a13438eac65dfb07d4d9a" translate="yes" xml:space="preserve">
          <source>This function is called by a process when it generates a system event. &lt;code&gt;FormFunc&lt;/code&gt; is a formatting function, called as &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; to print the events, which is necessary if tracing is activated. &lt;code&gt;Extra&lt;/code&gt; is any extra information that the process needs in the format function, for example, the process name.</source>
          <target state="translated">进程在生成系统事件时会调用此函数。 &lt;code&gt;FormFunc&lt;/code&gt; 是一种格式化函数，称为 &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; 用于打印事件，如果激活了跟踪，则这是必需的。 &lt;code&gt;Extra&lt;/code&gt; 是流程在格式功能中需要的任何其他信息，例如，流程名称。</target>
        </trans-unit>
        <trans-unit id="ed0e0eb61ef16ef99456d0c2364049ed3a1ebf47" translate="yes" xml:space="preserve">
          <source>This function is called by an application after a code replacement, if the configuration parameters have changed.</source>
          <target state="translated">如果配置参数发生变化,该函数会在代码替换后被应用程序调用。</target>
        </trans-unit>
        <trans-unit id="3225937a4973dfc80a61d8815ee667cbb935393b" translate="yes" xml:space="preserve">
          <source>This function is called by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior when the channel is terminated, see &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt;. Thus, channels implemented with the behavior are not to call this function explicitly.</source>
          <target state="translated">通道终止时，此函数由 &lt;code&gt;ssh_client_channel&lt;/code&gt; 行为调用，请参见 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt; 。因此，用该行为实现的通道不会显式调用此函数。</target>
        </trans-unit>
        <trans-unit id="6621bfc9a122170668fcc8fc8225320a135fa869" translate="yes" xml:space="preserve">
          <source>This function is called by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior when the channel is terminated, see &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt;. Thus, channels implemented with the behavior are not to call this function explicitly.</source>
          <target state="translated">通道终止时，此函数由 &lt;code&gt;ssh_client_channel&lt;/code&gt; 行为调用，请参见 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt; 。因此，用该行为实现的通道不会显式调用此函数。</target>
        </trans-unit>
        <trans-unit id="dc9dece5047c3cb54dec0afd24b5a01788985144" translate="yes" xml:space="preserve">
          <source>This function is called by the runtime system if a call is made to &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; and &lt;code&gt;Module:Function/N&lt;/code&gt; is undefined. Notice that this function is evaluated inside the process making the original call.</source>
          <target state="translated">如果调用 &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; 并且未定义 &lt;code&gt;Module:Function/N&lt;/code&gt; ，则运行时系统将调用此函数。请注意，此函数是在进行原始调用的过程中评估的。</target>
        </trans-unit>
        <trans-unit id="932dde8834dd201f9618df3e2b729505b50863cc" translate="yes" xml:space="preserve">
          <source>This function is called by the supervisor bridge when it is about to terminate. It is to be the opposite of &lt;code&gt;Module:init/1&lt;/code&gt; and stop the subsystem and do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">即将终止时，主管桥会调用此功能。与 &lt;code&gt;Module:init/1&lt;/code&gt; 相反，并停止子系统并进行任何必要的清理。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="ea3c4634990a20391de600270693f41ff61a2a1d" translate="yes" xml:space="preserve">
          <source>This function is called for an installed event handler that is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;.appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">已安装的事件处理程序将调用此函数，该事件处理程序将在发行版升级/降级期间（即，当指令 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; ，其中 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 时更新其内部状态）。在 &lt;code&gt;.appup&lt;/code&gt; 文件中指定。有关更多信息，请参见 &lt;code&gt;OTP Design Principles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea3d7b3ef2cbf8699a32c34a5ebc6edac5d50d7" translate="yes" xml:space="preserve">
          <source>This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message).</source>
          <target state="translated">当事件管理器收到除事件或同步请求(或系统消息)以外的任何其他消息时,该函数被每个已安装的事件处理程序调用。</target>
        </trans-unit>
        <trans-unit id="ce473b5b5bef5c09e6ef1d61b1ed1c647a383af4" translate="yes" xml:space="preserve">
          <source>This function is called for each target in the &lt;code&gt;Targets&lt;/code&gt; argument of the &lt;code&gt;delivery_targets/3&lt;/code&gt; function, see above.</source>
          <target state="translated">请参见 &lt;code&gt;delivery_targets/3&lt;/code&gt; 函数的 &lt;code&gt;Targets&lt;/code&gt; 参数中的每个目标调用此函数。</target>
        </trans-unit>
        <trans-unit id="1d6462e692fd6e4e41ce5594f4b497bff94fb6d6" translate="yes" xml:space="preserve">
          <source>This function is called for every event sent by the parser. The error handling is done through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the application encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">这个函数对解析器发送的每个事件都会被调用。错误处理是通过异常来完成的。如果应用程序遇到致命错误,使用 throw/1 发送以下元组{Tag=atom(),Reason=string()}。Tag是一个原子,标识发送异常的功能实体,Reason是描述问题的字符串。</target>
        </trans-unit>
        <trans-unit id="93bdecc9d17882d1b467ebb3869ace1d974136a0" translate="yes" xml:space="preserve">
          <source>This function is called from the supervisor at system start-up.</source>
          <target state="translated">该功能在系统启动时由上位机调用。</target>
        </trans-unit>
        <trans-unit id="a217044c5be614a5f094b6a72163b7e4bdd7856f" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before &lt;code&gt;init_per_suite is run&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">仅当 &lt;code&gt;init_per_suite is run&lt;/code&gt; 之前添加了CTH时，才调用此函数。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="b9e0725950962171a0e0acbaccc22d9af6bc48c9" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before &lt;code&gt;init_per_suite&lt;/code&gt; is run. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">仅在运行 &lt;code&gt;init_per_suite&lt;/code&gt; 之前添加了CTH时，才调用此函数。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9151faa7459c76d911ec31cbf5c69110f9a96417" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before or in &lt;code&gt;init_per_suite&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">仅当CTH在 &lt;code&gt;init_per_suite&lt;/code&gt; 之前或之中添加时，才调用此函数。有关详细信息，请参阅《用户指南》中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="5d413292a54f27c9406de8cff392ae42d2f42729" translate="yes" xml:space="preserve">
          <source>This function is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function is present and returns &lt;code&gt;noError&lt;/code&gt;.</source>
          <target state="translated">调用此函数以在设置请求处理的第二阶段执行设置。仅当存在相应的 &lt;code&gt;is_set_ok&lt;/code&gt; 函数并返回 &lt;code&gt;noError&lt;/code&gt; 时才调用它。</target>
        </trans-unit>
        <trans-unit id="19d4b60d6e3de5df91e369f01d6f092302794154" translate="yes" xml:space="preserve">
          <source>This function is called when a log event has passed through all primary filters, and all handler filters attached to the handler in question. The function call is executed on the client process, and it is up to the handler implementation if other processes are involved or not.</source>
          <target state="translated">当一个日志事件通过了所有的主过滤器,以及连接到相关处理程序的所有处理程序过滤器时,就会调用这个函数。该函数的调用是在客户端进程上执行的,是否涉及到其他进程由处理程序实现决定。</target>
        </trans-unit>
        <trans-unit id="c295250b137bf52da997b24c29441addd734d55e" translate="yes" xml:space="preserve">
          <source>This function is called when a message is received from an unknown agent.</source>
          <target state="translated">当收到来自未知代理的消息时,该函数被调用。</target>
        </trans-unit>
        <trans-unit id="5d70c9d97d9b9a958c936b8de051f3ed8d7ea9af" translate="yes" xml:space="preserve">
          <source>This function is called when a segment reply has been received if the &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; config option has been set to true.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; config选项设置为true，则在收到分段答复时将调用此函数。</target>
        </trans-unit>
        <trans-unit id="0a9e596fa34499a1e902a649a40ec5eaea84dc1d" translate="yes" xml:space="preserve">
          <source>This function is called when an application is about to be stopped, before shutting down the processes of the application.</source>
          <target state="translated">该函数在应用程序即将停止时,在关闭应用程序的进程之前被调用。</target>
        </trans-unit>
        <trans-unit id="e52a273e8b54ca8a87814403662bc4639ec75915" translate="yes" xml:space="preserve">
          <source>This function is called when the handshake has completed and the distribution channel is up. The distribution controller can begin dispatching traffic over the channel. This function is optional.</source>
          <target state="translated">当握手完成,分发通道启动时,该函数被调用。分销控制器可以开始通过通道调度流量。这个功能是可选的。</target>
        </trans-unit>
        <trans-unit id="78b766c6378e4e694c5a1f56cd06d012c7c1210f" translate="yes" xml:space="preserve">
          <source>This function is called when the manager needs to communicate an &quot;asynchronous&quot; error to the user: e.g. failure to send an asynchronous message (i.e. encoding error), a received message was discarded due to security error, the manager failed to generate a response message to a received inform-request, or when receiving an unexpected PDU from an agent (could be an expired async request).</source>
          <target state="translated">当管理器需要向用户传达一个 &quot;异步 &quot;错误时,就会调用这个函数:例如,未能发送异步消息(即编码错误),接收到的消息因安全错误而被丢弃,管理器未能对接收到的信息请求生成响应消息,或者当收到来自代理的意外PDU时(可能是过期的异步请求)。</target>
        </trans-unit>
        <trans-unit id="c1bd23363bb35671fd7a263f768278217cdab156" translate="yes" xml:space="preserve">
          <source>This function is called whenever Mnesia needs to determine which fragments that need to be searched for a &lt;code&gt;MatchSpec&lt;/code&gt;. It is typically called by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;.</source>
          <target state="translated">每当Mnesia需要确定需要为 &lt;code&gt;MatchSpec&lt;/code&gt; 搜索哪些片段时，都会调用此函数。通常由 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;match_object&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="01c69191566d604ec0e4348c19597985d6671a38" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) fails. It is called after the post function is called for the failed test case, that is:</source>
          <target state="translated">每当一个测试用例(或配置函数)失败时,这个函数就会被调用。它是在调用失败的测试用例的post函数之后被调用的,也就是说。</target>
        </trans-unit>
        <trans-unit id="d3efafaf0939c64a4ad9d5c14688207c28754d4e" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) is skipped. It is called after the post function is called for the skipped test case, that is:</source>
          <target state="translated">每当一个测试用例(或配置函数)被跳过时,这个函数就会被调用。它是在调用了跳过的测试用例的post函数之后被调用的,也就是说。</target>
        </trans-unit>
        <trans-unit id="c606577dcdb814f628921da1d374fa61eef9bcbd" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application has stopped. It is intended to be the opposite of &lt;code&gt;Module:start/2&lt;/code&gt; and is to do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">每当应用程序停止时，都会调用此函数。它打算与 &lt;code&gt;Module:start/2&lt;/code&gt; 相反，并进行任何必要的清理。返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="5ee521594d1ddf2a7d2b5598240a35e803ba7648" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application is started using &lt;code&gt;start/1,2&lt;/code&gt;, and is to start the processes of the application. If the application is structured according to the OTP design principles as a supervision tree, this means starting the top supervisor of the tree.</source>
          <target state="translated">每当使用 &lt;code&gt;start/1,2&lt;/code&gt; 启动应用程序时，就会调用此函数，该函数将启动应用程序的进程。如果根据OTP设计原则将应用程序构建为监督树，则意味着启动该树的最高主管。</target>
        </trans-unit>
        <trans-unit id="5ce2ffe3ef06f25d257eea92fe03c94bd042a9ba" translate="yes" xml:space="preserve">
          <source>This function is called whenever the parser runs out of input data. If the function can't get hold of more input an empty list or binary (depends on start input in stream/2) is returned. Other types of errors is handled through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the continuation function encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">当解析器的输入数据用完时,就会调用这个函数。如果函数无法获得更多的输入,则返回一个空列表或二进制(取决于 stream/2 中的起始输入)。其他类型的错误是通过异常处理的。如果延续函数遇到致命错误,使用 throw/1 发送以下元组{Tag=atom(),Reason=string()}。Tag是一个原子,标识发送异常的功能实体,Reason是描述问题的字符串。</target>
        </trans-unit>
        <trans-unit id="112c32a0ac8f37302565069e1af7c3d11d8ddc14" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous, that is, when this function returns, the name is either registered on all nodes or none.</source>
          <target state="translated">这个函数是完全同步的,也就是说,当这个函数返回时,名字要么在所有节点上注册,要么没有。</target>
        </trans-unit>
        <trans-unit id="d629551f45aed938b0210e2c4a23a00e3421b297" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous.</source>
          <target state="translated">这个功能是完全同步的。</target>
        </trans-unit>
        <trans-unit id="f35d4e7d98bb703e34921dfd922b82cf2abffe2a" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release.</source>
          <target state="translated">该功能已被废弃,并将在未来的版本中被删除。</target>
        </trans-unit>
        <trans-unit id="d2dfc217a2570094e6cc323282a9ac2ec312cf13" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:adler32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54ef9e0b04f05df35a0d8799f78f72ccd50b3d8" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:adler32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91fa6bf33569c121fe19cc7254b8b99d02f91829" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:adler32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f68676907fa9644a72b09b3e8e55084c3793ca2" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd82f4f6a6495fb95de1365c7dd445daddaeb507" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/1&lt;/code&gt; on the uncompressed data instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。在未压缩的数据上使用 &lt;code&gt; erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6bb5b48be5041ad67a139ae21d87cea520ccac4" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:crc32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e83cccb5a8d4e621eb6a5d9a0a7f3e0d9c4470d" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt; erlang:crc32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b70e6afc905702f524a5b9ff1b7ae5b183cbf540" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2 &lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2 &lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cf9e7b62dba47009024375097e3299049fe0a22" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57c472f59dd3d2f6ad17dc07c92e4c60fcf49729" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db4675d63f920313a1ea26e962187e1aa011dcdd" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ce49a62899e9f8f936f7b7c515c2cbbf4ad75dc" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a65b47bbbfbb54ad15ea7e9136f81e2f3a04ac4" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b52957272e25d9092e5e990877e3939651cbfce" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; on the uncompressed data instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。在未压缩的数据上使用 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f67f68973bfc4a8137b6bf187f50333109258a7" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/2&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb4d9b393f14dc50ae3c01015c208fd2e887250e" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">不建议使用此功能，以后的版本中将删除该功能。请改用 &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cf4312fba04cc8c15fd9776029ba4bd244d245c" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">不建议使用此功能，因为 &lt;code&gt;error_logger&lt;/code&gt; 不再是登录Erlang / OTP的首选接口。在Erlang / OTP 21.0中添加了新的 &lt;code&gt;logging API&lt;/code&gt; ，但仍可以使用旧的 &lt;code&gt;error_logger&lt;/code&gt; 处理程序。新的Logger处理程序不需要使用此功能，因为格式化回调（ &lt;code&gt;report_cb&lt;/code&gt; ）作为元数据包括在日志事件中。</target>
        </trans-unit>
        <trans-unit id="797c275c3663aa3f1286ac6e8f576a1c8979a3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">不赞成使用此功能，因为 &lt;code&gt;error_logger&lt;/code&gt; 不再是登录Erlang / OTP的首选接口。在Erlang / OTP 21.0中添加了新的 &lt;code&gt;logging API&lt;/code&gt; ，但仍可以使用旧的 &lt;code&gt;error_logger&lt;/code&gt; 处理程序。新的Logger处理程序不需要使用此功能，因为格式化回调（ &lt;code&gt;report_cb&lt;/code&gt; ）作为元数据包含在log事件中。</target>
        </trans-unit>
        <trans-unit id="2a5e0a6ac180dc5b3447b4979a16254d508048fc" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt; local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch &lt;strong&gt;to&lt;/strong&gt; daylight saving time, this function still returns a result.</source>
          <target state="translated">不推荐使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt; local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; ，因为它可以提供更正确和完整的结果。特别是对于不存在的时间段，由于在切换&lt;strong&gt;到&lt;/strong&gt;夏时制时会被跳过，因此此功能仍会返回结果。</target>
        </trans-unit>
        <trans-unit id="93275cd4e56a52fc18f140562459cc7469aef3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch &lt;strong&gt;to&lt;/strong&gt; daylight saving time, this function still returns a result.</source>
          <target state="translated">不推荐使用此功能。请改用 &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; ，因为它可以提供更正确和完整的结果。特别是对于不存在的时间段，由于在切换&lt;strong&gt;到&lt;/strong&gt;夏时制时会被跳过，因此此功能仍会返回结果。</target>
        </trans-unit>
        <trans-unit id="107787156b19ddd4b875082324ae72f8e4e9d678" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt; filelib:find_source/1&lt;/a&gt;&lt;/code&gt; instead for finding source files.</source>
          <target state="translated">不推荐使用此功能。使用 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt; filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 代替查找源文件。</target>
        </trans-unit>
        <trans-unit id="c812739c6fd83de52547a755970ceca008f0b790" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; instead for finding source files.</source>
          <target state="translated">不推荐使用此功能。使用 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 代替查找源文件。</target>
        </trans-unit>
        <trans-unit id="7862d9b3a29dd09774fab5841e177464de1a0d4c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#safe_relative_path-2&quot;&gt; filelib:safe_relative_path/2&lt;/a&gt;&lt;/code&gt; instead for sanitizing paths.</source>
          <target state="translated">不推荐使用此功能。请使用 &lt;code&gt;&lt;a href=&quot;filelib#safe_relative_path-2&quot;&gt; filelib:safe_relative_path/2&lt;/a&gt;&lt;/code&gt; 来清理路径。</target>
        </trans-unit>
        <trans-unit id="bad5bec42b08c1e7fcdb1abc8d7d5c436046ff91" translate="yes" xml:space="preserve">
          <source>This function is designed to be used by the KERNEL &lt;code&gt;logger&lt;/code&gt;. Be careful if you change it to something else as log messages may be lost. If you want to intercept emulator log messages, do it by adding a specialized handler to the KERNEL logger.</source>
          <target state="translated">该功能旨在供KERNEL &lt;code&gt;logger&lt;/code&gt; 。如果将其更改为其他内容，请小心，因为日志消息可能会丢失。如果要拦截仿真器日志消息，请通过向KERNEL记录器添加专门的处理程序来实现。</target>
        </trans-unit>
        <trans-unit id="e693393ef522640c54a2f9b1422caf298b96748a" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能等效于 &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4e6b180074e2f9f3f128b4c971b69623e3ec1e" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but acts on the given node. A tracer is started on the node (&lt;code&gt;Nodename&lt;/code&gt;) and the node is added to the list of traced nodes.</source>
          <target state="translated">此函数等效于 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; ，但作用于给定节点。在节点（ &lt;code&gt;Nodename&lt;/code&gt; ）上启动一个跟踪器，并将该节点添加到被跟踪节点的列表中。</target>
        </trans-unit>
        <trans-unit id="c92d04be5c71ca9752e01679ace3dd192a2701dc" translate="yes" xml:space="preserve">
          <source>This function is evaluated if a call is made to &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; when the module defining the fun is not loaded. The function is evaluated inside the process making the original call.</source>
          <target state="translated">如果未加载定义 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 的模块时对Fun（Arg1，..，ArgN）的调用，则会评估此函数。该函数在进行原始调用的过程中进行评估。</target>
        </trans-unit>
        <trans-unit id="397de6af2f56ed299f26a66779fa39dc2d87c829" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging only.</source>
          <target state="translated">此功能仅用于调试。</target>
        </trans-unit>
        <trans-unit id="6f93c6fcd137c8978ef002f7f0267507232415ce" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging only. It produces a slightly processed dump of the session database. The first list of the session information tuple will contain session information on an internal format. The last two lists of the session information tuple should always be empty if the code is working as intended. If no profile is specified, the default profile is used.</source>
          <target state="translated">这个函数只用于调试。它产生了一个略经处理的会话数据库转储。会话信息元组的第一个列表将包含内部格式的会话信息。如果代码工作正常,会话信息元组的最后两个列表应该始终为空。如果没有指定配置文件,则使用默认的配置文件。</target>
        </trans-unit>
        <trans-unit id="5e70db1a93c8f76d23e7c3d3fb2baea3f7a6af2b" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging purposes only.</source>
          <target state="translated">此功能仅用于调试目的。</target>
        </trans-unit>
        <trans-unit id="6f60000c240fa5a82e86efdce70cc54b8977641c" translate="yes" xml:space="preserve">
          <source>This function is intended for send operations to an unreliable remote node without ever blocking the sending (Erlang) process. If the connection to the remote node (usually not a real Erlang node, but a node written in C or Java) is overloaded, this function &lt;strong&gt;does not send the message&lt;/strong&gt; and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此功能旨在将操作发送到不可靠的远程节点，而不会阻止发送（Erlang）进程。如果到远程节点（通常不是真正的Erlang节点，而是用C或Java编写的节点）的连接过载，则此函数&lt;strong&gt;不会发送消息&lt;/strong&gt;并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81171218c09769a1d5b4af85d5937f41eeaa5f09" translate="yes" xml:space="preserve">
          <source>This function is intended to be called by a process belonging to an application, when the application is started, to determine the start type, which is &lt;code&gt;StartType&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">当启动应用程序时，应由属于该应用程序的进程调用此函数以确定启动类型，即 &lt;code&gt;StartType&lt;/code&gt; 或 &lt;code&gt;local&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c87f0aca040e4bc019e958efeaad03d57b852a" translate="yes" xml:space="preserve">
          <source>This function is intended to be called in test cases in test suites.</source>
          <target state="translated">这个函数是为了在测试套件的测试用例中调用。</target>
        </trans-unit>
        <trans-unit id="e10f123bbee56ea9b87adef7c85f24ef9a0bea62" translate="yes" xml:space="preserve">
          <source>This function is intended to be called in the test cases in the test suite.</source>
          <target state="translated">这个函数是为了在测试套件的测试用例中调用。</target>
        </trans-unit>
        <trans-unit id="1b921fbf118e94cca94277c181ed0c5045bbfaba" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked at strategic places in user applications in order to enable simplified tracing. The functions are extremely light weight as they do nothing besides returning an atom. The functions are designed for being traced. The global tracing mechanism in &lt;code&gt;et_collector&lt;/code&gt; defaults to set its trace pattern to these functions.</source>
          <target state="translated">该功能旨在在用户应用程序中的关键位置调用，以实现简化的跟踪。这些函数非常轻巧，因为它们除了返回原子之外什么也不做。这些功能旨在进行跟踪。默认情况下， &lt;code&gt;et_collector&lt;/code&gt; 中的全局跟踪机制会将其跟踪模式设置为这些函数。</target>
        </trans-unit>
        <trans-unit id="36a555885bb62cc8fb0d04fa074ce553eafe397b" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">这个函数的作用是当一些传输模块收到收到的消息时调用。实际使用哪种传输方式,由用户自行选择。</target>
        </trans-unit>
        <trans-unit id="6d3f5fd62fd46c21ebd6dea29aa844aba60cb08c" translate="yes" xml:space="preserve">
          <source>This function is invoked as this module is added as a child of the &lt;code&gt;erl_distribution&lt;/code&gt; supervisor.</source>
          <target state="translated">在将此模块作为 &lt;code&gt;erl_distribution&lt;/code&gt; 监管程序的子级添加时，将调用此函数。</target>
        </trans-unit>
        <trans-unit id="1d32e0beab2a86c2649b5c5e66d99028d158f64c" translate="yes" xml:space="preserve">
          <source>This function is invoked if the originating pending limit has been exceeded. This usually means that a request has taken abnormally long time to complete.</source>
          <target state="translated">如果超过了发起的挂起限制,就会调用这个函数。这通常意味着一个请求需要异常长的时间才能完成。</target>
        </trans-unit>
        <trans-unit id="7fe0a088ee8a115443a4b7c28bd5e240eaea2ffd" translate="yes" xml:space="preserve">
          <source>This function is mandatory.</source>
          <target state="translated">这个功能是必须的。</target>
        </trans-unit>
        <trans-unit id="23ddde2c73699705374784b1a6630cfc5af08e7d" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string directly from a test case to the test case log file.</source>
          <target state="translated">这个函数的作用是将测试用例中的字符串直接打印到测试用例日志文件中。</target>
        </trans-unit>
        <trans-unit id="1c8ca547da965f042e95bb1424e4289fdf1c4a1b" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case to the console.</source>
          <target state="translated">该函数用于打印测试用例的字符串到控制台。</target>
        </trans-unit>
        <trans-unit id="200109fd126bab7ec37db1035c7afff40cc8667c" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case, both to the test case log file and to the console.</source>
          <target state="translated">这个函数用于打印测试用例中的字符串,既可以打印到测试用例日志文件,也可以打印到控制台。</target>
        </trans-unit>
        <trans-unit id="2dbc6b277a2853a0b6bf11d0b8a4589a39100a82" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for debugging only.</source>
          <target state="translated">此功能仅用于调试。</target>
        </trans-unit>
        <trans-unit id="353984c9a0fb4f2aea1206112d183a058e95d4a0" translate="yes" xml:space="preserve">
          <source>This function is mostly for debugging purposes, Normally &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;next&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; are to be used instead.</source>
          <target state="translated">此功能主要用于调试目的，通常使用 &lt;code&gt;first&lt;/code&gt; / &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;last&lt;/code&gt; / &lt;code&gt;prev&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="932f20a018c847fbfb4197a37b0d2d604f5eb9f7" translate="yes" xml:space="preserve">
          <source>This function is normally not called by the user. The user only needs to call if the channel process needs to be started with help of &lt;code&gt;proc_lib&lt;/code&gt; instead of calling &lt;code&gt;start/4&lt;/code&gt; or &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">用户通常不调用此函数。仅当需要在 &lt;code&gt;proc_lib&lt;/code&gt; 的帮助下启动通道进程而不是调用 &lt;code&gt;start/4&lt;/code&gt; 或 &lt;code&gt;start_link/4&lt;/code&gt; 时，用户才需要调用。</target>
        </trans-unit>
        <trans-unit id="42f571587b780a1e6f46d35b2d96fbee773dc95d" translate="yes" xml:space="preserve">
          <source>This function is not equivalent to &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;. While &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; starts a process tracer which redirects all trace information to a process tracer on the local node (i.e. the trace control node), &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; starts a tracer of any type which is independent of the tracer on the trace control node.</source>
          <target state="translated">此函数不等于 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 。当 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 启动将所有跟踪信息重定向到本地节点（即，跟踪控制节点）上的进程跟踪器的进程跟踪器时， &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 启动与跟踪控制节点上的跟踪器无关的任何类型的跟踪器。</target>
        </trans-unit>
        <trans-unit id="bc4cccc5c4f2f3772a98e697fd645208ffc7bcd9" translate="yes" xml:space="preserve">
          <source>This function is obsolete. Use the conversion functions for gregorian days and seconds instead.</source>
          <target state="translated">这个功能已经过时了。请使用公历日和秒的转换函数。</target>
        </trans-unit>
        <trans-unit id="1410613873cd68c550a08bd7e69d18ff526645c9" translate="yes" xml:space="preserve">
          <source>This function is occasionally useful when it is necessary to have annotations on the subnodes of a list constructor node, even when the subnodes are constant literals. Note however that &lt;code&gt;is_literal/1&lt;/code&gt; will yield &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;concrete/1&lt;/code&gt; will fail if passed the result from this function.</source>
          <target state="translated">当必须在列表构造器节点的子节点上具有注释时，即使子节点是常量文字，此功能有时也很有用。但是请注意，如果从此函数传递结果，则 &lt;code&gt;is_literal/1&lt;/code&gt; 将产生 &lt;code&gt;false&lt;/code&gt; ,而 &lt;code&gt;concrete/1&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="da720859fde23616eefcd04feb5000fa3d749010" translate="yes" xml:space="preserve">
          <source>This function is occasionally useful when it is necessary to have annotations on the subnodes of a tuple node, even when all the subnodes are constant literals. Note however that &lt;code&gt;is_literal/1&lt;/code&gt; will yield &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;concrete/1&lt;/code&gt; will fail if passed the result from this function.</source>
          <target state="translated">当需要在元组节点的子节点上具有注释时，即使所有子节点都是常量文字，此功能有时也很有用。但是请注意，如果从此函数传递结果，则 &lt;code&gt;is_literal/1&lt;/code&gt; 将产生 &lt;code&gt;false&lt;/code&gt; ,而 &lt;code&gt;concrete/1&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="ce7c408302373e6adf8e0f46e04cfc34dc2748e9" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to have a same kind of interface as the &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">此功能仅用于测试目的。它应该具有与 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 函数相同的接口（带有 &lt;code&gt;EncodingMod&lt;/code&gt; 和 &lt;code&gt;EncodingConfig&lt;/code&gt; 参数）。它构成了一个完整的megaco消息尝试对其进行编码的最终尝试。返回值将是组成的megaco消息和编码结果的元组。</target>
        </trans-unit>
        <trans-unit id="f9e0331af836baa2d84d1f916d61996854b6352b" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to test the &lt;code&gt;actual_reply()&lt;/code&gt; return value of the callback functions &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">此功能仅用于测试目的。它应该测试回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; 函数（添加了 &lt;code&gt;EncodingMod&lt;/code&gt; 和 &lt;code&gt;EncodingConfig&lt;/code&gt; 参数）的actual_reply &lt;code&gt;actual_reply()&lt;/code&gt; 返回值。它构成了一个完整的megaco消息尝试对其进行编码的最终尝试。返回值将是组成的megaco消息和编码结果的元组。</target>
        </trans-unit>
        <trans-unit id="df58ae53df4ed25f773afed230f30889dcd5ca99" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used.</source>
          <target state="translated">该功能只有在使用支持SMP的仿真器时才是线程安全的。</target>
        </trans-unit>
        <trans-unit id="aef102baa9fb64ea372514334c60d7b3b9f264e9" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</source>
          <target state="translated">这个函数只有在使用支持SMP的仿真器时才是线程安全的。它只能在非SMP仿真器中由NIF调用线程使用。</target>
        </trans-unit>
        <trans-unit id="90c95c65aaea895304dfbed57d7ceb302b881182" translate="yes" xml:space="preserve">
          <source>This function is only to be used in rare circumstances where a process communicates with Erlang nodes that can disappear without any trace, causing the TCP buffers and the drivers queue to be over-full before the node is shut down (because of tick time-outs) by &lt;code&gt;net_kernel&lt;/code&gt;. The normal reaction to take when this occurs is some kind of premature shutdown of the other node.</source>
          <target state="translated">此功能仅在少数情况下使用，即进程与Erlang节点通信时，该节点可能消失而无任何踪迹，从而导致TCP缓冲区和驱动程序队列在该节点关闭之前变得过满（由于滴答超时） ）由 &lt;code&gt;net_kernel&lt;/code&gt; 。发生这种情况时，通常的反应是另一节点过早关闭。</target>
        </trans-unit>
        <trans-unit id="b91ea27388e04da4e23c43f3cd2a1b24a1b3f051" translate="yes" xml:space="preserve">
          <source>This function is only to be used on short lists, as a copy is created of the list, which is not released until after the NIF returns.</source>
          <target state="translated">这个函数只用于短列表,因为会创建一个列表副本,直到NIF返回后才会释放。</target>
        </trans-unit>
        <trans-unit id="1c2b27f3795376fc611944f7d7c38e8f0670e208" translate="yes" xml:space="preserve">
          <source>This function is optional.</source>
          <target state="translated">这个功能是可选的。</target>
        </trans-unit>
        <trans-unit id="c8eb9533643d424e90f80bd181b73132613e7c18" translate="yes" xml:space="preserve">
          <source>This function is optional. The return value is discarded.</source>
          <target state="translated">这个函数是可选的。返回值被丢弃。</target>
        </trans-unit>
        <trans-unit id="e2b3a473185dfec37318ffd01ffc565de71b54e4" translate="yes" xml:space="preserve">
          <source>This function is optional. Used when connection is up.</source>
          <target state="translated">此功能是可选的。在连接状态下使用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
