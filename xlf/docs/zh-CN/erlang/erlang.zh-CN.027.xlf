<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">如果请求已成功编码和发送，但在接收到答案之前已停止相关服务，则将使用 &lt;code&gt;Reason = cancel&lt;/code&gt; 进行 &lt;code&gt;handle_error/4&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="61d25df3bedf5d0be2cd7d314bbaa9b30da48753" translate="yes" xml:space="preserve">
          <source>If the request reached the peer, was handled and the response reached the requesting node the &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; is the status reported from the peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">如果请求的数据可用，则该子条目与 &lt;code&gt;Name&lt;/code&gt; 关联，以便可以使用 &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; 读取元素的值，前提是使用 &lt;code&gt;Name&lt;/code&gt; 而不是整个 &lt;code&gt;Required&lt;/code&gt; 术语。</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">如果在仿真器启动过程中通过设置STDLIB变量来激活受限外壳，并且无法加载回调模块，则默认的受限外壳仅允许使用 &lt;code&gt;q()&lt;/code&gt; 和 &lt;code&gt;init:stop()&lt;/code&gt; 命令作为后备。</target>
        </trans-unit>
        <trans-unit id="724b8206454c6a949fb926da63637eb525b4710d" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; 激活了受限制的外壳程序，并且无法加载回调模块，则会向错误记录器发送错误报告，并且调用返回 &lt;code&gt;{error,Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">如果&lt;strong&gt;显然&lt;/strong&gt;不使用列表理解的结果，则不会构造列表。例如，在此代码中：</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">如果运行时系统处于 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; ，则当运行时系统检测到 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 已更改时，时间偏移也会更改。但是，运行时系统不会立即检测到它。检查时间偏移的任务计划至少每分钟执行一次，因此在正常操作下，应在一分钟内检测到该任务，但是在重负载期间可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">如果运行时系统处于 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; ，则当运行时系统检测到 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 已更改时，时间偏移也会更改。但是，运行时系统不会立即检测到它。检查时间偏移的任务计划至少每分钟执行一次；因此，在正常操作下，一分钟之内即可检测到，但是在重负载下，则可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="842b5ecda8b77bc83a3f2909c3c676e780a3ce01" translate="yes" xml:space="preserve">
          <source>If the same option is set at two different levels, the one at the highest level is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">如果使用方案 &lt;code&gt;https&lt;/code&gt; ，则必须启动 &lt;code&gt;SSL&lt;/code&gt; 应用程序。当 &lt;code&gt;https&lt;/code&gt; 链接需要通过代理时，使用HTTP-1.1的CONNECT方法扩展来建立隧道，然后将连接升级到TLS。但是，不支持根据 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; 的 &amp;ldquo; TLS升级&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="5c3e2a035a8c91596ec4431ba0d0a851882160c2" translate="yes" xml:space="preserve">
          <source>If the second operand for &lt;code&gt;is_number/2&lt;/code&gt; is a literal, it will be moved to X register 1023. Then &lt;code&gt;is_number/2&lt;/code&gt; will test whether the value stored in X register 1023 is a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c6f2a7a376dda13bb7ffd101ed27e0bb2c89e4" translate="yes" xml:space="preserve">
          <source>If the selected cipher needs to have the input data partioned into blocks of a certain size, the &lt;code&gt;init_fun()&lt;/code&gt; should return the second form of return value with the &lt;code&gt;chunk_size()&lt;/code&gt; set to the block size. If the &lt;code&gt;chunk_size()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;chunk_size()&lt;/code&gt; is intended for block crypto. A &lt;code&gt;chunk_size()&lt;/code&gt; can be changed in the return from the &lt;code&gt;crypto_fun()&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">如果必须暂停发送方以进行发送， &lt;code&gt;nosuspend&lt;/code&gt; 返回nosuspend。</target>
        </trans-unit>
        <trans-unit id="603b5cbedb1c18808b9a489511a61b63ed3b0c0b" translate="yes" xml:space="preserve">
          <source>If the server changes callback module using any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果未在配置文件中指定服务器，请改用 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果未在配置文件中指定服务器，请改用 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在配置文件中指定了服务器选项，或者需要使用命名客户端进行日志记录（请参阅&amp;ldquo; 在此模块中 &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 一节），请改用 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在配置文件中指定了服务器选项，请改用 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">如果服务器从客户端收到与 &lt;code&gt;sni_hosts&lt;/code&gt; 选项中列出的主机匹配的SNI（服务器名称指示），则该主机的特定选项将覆盖先前指定的选项。选项 &lt;code&gt;sni_fun&lt;/code&gt; 和 &lt;code&gt;sni_hosts&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="6872d76e7fd0c2b2043184ce306dcf6a44377861" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; list. The function should be defined as: fun(ServerName :: string()) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">如果服务器从客户端接收到SNI（服务器名称指示），则将调用给定函数以检索所指示服务器的 &lt;code&gt;[ssl_option()]&lt;/code&gt; 。这些选项将合并到预定义的 &lt;code&gt;[ssl_option()]&lt;/code&gt; 中。该函数应定义为： &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; 并且可以指定为fun或命名为 &lt;code&gt;fun module:function/1&lt;/code&gt; 选项 &lt;code&gt;sni_fun&lt;/code&gt; 和 &lt;code&gt;sni_hosts&lt;/code&gt; 是互斥的。</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">如果减小文件的大小,该变化会立即影响当前的日志。在下次使用之前,它不会改变已经满的日志文件的大小。</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">如果进程中的活数据大小小于最小堆大小,则进程被唤醒后发生的第一次垃圾收集会确保堆大小改为不小于最小堆大小。</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">如果跳过的测试用例属于测试用例组，则第一个参数是元组 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ，否则仅是函数名称。</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">如果snmp代理被配置为分布式Erlang应用程序,它将在接管过程中尝试加载与老节点相同的MIB。它使用与旧节点相同的文件名。如果MIBs不在不同节点的相同路径中,则必须在接管后显式加载MIBs。</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">如果套接字是一个监听套接字,我们使用一个单独的(常规)文件来实现两个目的。</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">如果套接字被关闭,则会传递以下信息。</target>
        </trans-unit>
        <trans-unit id="4128dcf4e6f00732687760eccb66b0c9d45f8d7a" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; mode data received data is delivered to the controlling process as messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4248f996c2d366444661dd551e1e934e80a81f5" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode data can be received through the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">如果套接字处于 &lt;code&gt;{active, N}&lt;/code&gt; 模式（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; ），并且其消息计数器降至 &lt;code&gt;0&lt;/code&gt; ，则传递以下消息以指示套接字已转换为被动（ &lt;code&gt;{active, false}&lt;/code&gt; ）模式：</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">如果套接字处于繁忙状态,当ERTS套接字实现内部排队的数据量低于此限制时,套接字将被设置为不繁忙状态。默认值为4 kB。</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">如果套接字未处于活动模式，则可以通过 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; 调用来检索数据。请注意，长度超过接收缓冲区选项指定的到达UDP数据包可以被截断而不会发出警告。</target>
        </trans-unit>
        <trans-unit id="479b7a4579a072626569e57eba743d1c2936d55c" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfer is complete may cause this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">如果套接字被设置为活动模式,该函数将把调用者邮箱中的任何消息传输到新的控制进程。如果在传输过程中,有其他进程与套接字进行交互,那么传输可能无法正常进行,消息可能会留在调用者的邮箱中。例如,在传输完成之前改变套接字的活动模式可能会导致这种情况。</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">如果套接字消息队列处于繁忙状态,当消息队列中排队的数据量低于这个限制时,套接字消息队列被设置为不繁忙状态。注意,这个限制只涉及尚未到达ERTS内部套接字实现的数据。默认值为4 kB。</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">如果无法使用 &lt;code&gt;file:open/2&lt;/code&gt; 打开源文件和/或输出文件，则该函数返回 &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; ，其中 &lt;code&gt;File&lt;/code&gt; 是文件名， &lt;code&gt;Reason&lt;/code&gt; 是错误原因。</target>
        </trans-unit>
        <trans-unit id="8e799a198169d10fe4c08d9a95c18d2093196332" translate="yes" xml:space="preserve">
          <source>If the spawn operation succeeds, a new process is created on the node identified by &lt;code&gt;Node&lt;/code&gt;. When a spawn operation succeeds, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. Such a message is referred to as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">如果特殊进程被设置为陷阱退出,如果父进程终止,预期的行为是以同样的理由终止。</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">如果指定的 &lt;code&gt;SessionId&lt;/code&gt; 等于当前会话ID，则返回错误。</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">如果未启用指定的分配器类型，则调用将失败，并显示 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果未加载指定的应用程序，或者执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果未加载指定的应用程序，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。如果执行调用的进程不属于任何应用程序，则该函数返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ee2eec511fb223edba405cd2c1e33b5dd8cf299" translate="yes" xml:space="preserve">
          <source>If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. If the event manager dies before or during the request this function returns &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">如果指定的进程不属于任何应用程序，或者指定的进程或模块不存在，则该函数返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">如果启动过程失败，则函数 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 返回神秘的元组 &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; 。要获取有关启动失败的更多信息，请使用命令行参数 &lt;code&gt;-boot start_sasl&lt;/code&gt; 作为 &lt;code&gt;erl&lt;/code&gt; 脚本的参数。</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">如果状态发生变化,传入事件的队列将被重置,从最老的推迟开始。</target>
        </trans-unit>
        <trans-unit id="c8895677551ffa4a3c90ee4e7e492bffa6d9c323" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge. The challenge message can have two different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">如果状态为 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;ok_simultaneous&lt;/code&gt; ，则握手继续，并且 &lt;code&gt;B&lt;/code&gt; 向 &lt;code&gt;A&lt;/code&gt; 发送另一条消息，即质询。质询包含与最初从 &lt;code&gt;A&lt;/code&gt; 发送到 &lt;code&gt;B&lt;/code&gt; 的&amp;ldquo;名称&amp;rdquo;消息相同类型的信息，外加一个32位质询：</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">如果架构的存储类型为 &lt;code&gt;ram_copies&lt;/code&gt; ，即无盘节点，则 &lt;code&gt;Mnesia&lt;/code&gt; 不会在该特定节点上使用该盘。通过将表 &lt;code&gt;schema&lt;/code&gt; 的存储类型更改为 &lt;code&gt;disc_copies&lt;/code&gt; 来启用光盘使用。</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">如果结构化类型的组件具有嵌入的 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; ,而嵌入的类型又是 &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; ，则它会提供带有 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; 的记录，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">如果按照本示例那样安装样式表，则类别对于所讨论的套件是私有的。它们可以被套件中的所有测试用例使用，但不能被其他套件使用。使用套件私有样式表（如果已指定），则倾向于使用全局样式表（用flag &lt;code&gt;-stylesheet&lt;/code&gt; 指定的样式表）。样式表元组（由上面的 &lt;code&gt;suite/0&lt;/code&gt; 返回）也可以从测试用例信息函数中返回。在这种情况下，样式表中指定的类别只能在该特定测试用例中使用。使用测试用例专用样式表来代替套件或全局级别的样式表。</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">如果主语是 &quot;aaac...&quot;,在第一次匹配尝试失败后(从字符串中的第一个字符开始),起点会跳转到 &quot;c &quot;处开始下一次尝试。请注意,占有式定语符的效果与本例不同;虽然它将抑制第一次匹配尝试时的回溯,但第二次尝试将从第二个字符开始,而不是跳转到 &quot;c&quot;。</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">如果主题是 &quot;abac&quot;,Perl就会匹配,但PCRE失败了,因为组的第二个重复中的(*COMMIT)作用。</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">如果主题是 &quot;ba&quot;,这个模式就不匹配。由于.*?是不贪婪的,它最初匹配的字符为零。然后条件(?=a)失败,字符 &quot;b &quot;被匹配,但 &quot;c &quot;没有被匹配。这时,匹配并没有回溯到.*?,也许可以从存在的|字符中得到预期。条件子模式是构成整个模式的单一选项的一部分,因此匹配失败。(如果有一个回溯到.*?,允许它匹配 &quot;b&quot;,匹配就会成功。)</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">如果主题是 &quot;xyz123abc123&quot;,匹配点是第四个字符。因此,这样的模式不是隐性锚定的。</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">如果子系统选项不存在，则使用 &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; 的值。默认情况下，这将启用sftp子系统。如果您不希望守护程序运行任何子系统，则可以将该选项设置为空列表。</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">如果成功创建了主管及其子进程（即，如果所有子进程启动函数都返回 &lt;code&gt;{ok,Child}&lt;/code&gt; ， &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; ），则该函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是主管的pid。</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">如果主管桥和子系统已成功启动，则函数返回 &lt;code&gt;{ok,Pid}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是主管桥的pid。</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">如果主管是 &lt;code&gt;simple_one_for_one&lt;/code&gt; ，则 &lt;code&gt;Id&lt;/code&gt; 必须是子进程的 &lt;code&gt;pid()&lt;/code&gt; 。如果指定的进程处于活动状态，但不是指定的主管的子进程，则该函数返回 &lt;code&gt;{error,not_found}&lt;/code&gt; 。如果指定了子规范标识符而不是 &lt;code&gt;pid()&lt;/code&gt; ，则函数返回 &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">如果主管不是 &lt;code&gt;simple_one_for_one&lt;/code&gt; ，则 &lt;code&gt;Id&lt;/code&gt; 必须是子规范标识符。该过程（如果有的话）将终止，除非它是一个临时子进程，否则该子进程规范将由主管保留。子进程以后可以由主管重新启动。子进程也可以通过调用 &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; 显式重启。使用 &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; 删除子级规范。</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;badarg&lt;/code&gt; 未运行，则该函数失败，原因是badarg。</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果由 &lt;code&gt;Suspendee&lt;/code&gt; 标识的进程的挂起计数增加，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">如果递归子模式调用的语法(无论是数字还是名称)被用在它所引用的括号之外,它的操作就像编程语言中的子程序一样。被调用的子模式可以在引用之前或之后定义。编号引用可以是绝对的,也可以是相对的,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">如果系统由多个Erlang节点组成，则每个节点都可以使用自己的发行版。发布处理程序是一个本地注册的进程，必须在需要升级或降级的每个节点上调用它。释放处理指令 &lt;code&gt;sync_nodes&lt;/code&gt; 可以用于在多个节点上同步释放处理程序进程，请参阅SASL中的 &lt;code&gt;appup(4)&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">如果系统被BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; 暂停，则口号是传递给BIF的字符串参数，否则是由仿真器或（Erlang）内核生成的描述。通常，该消息足以理解问题，但是此处描述了一些消息。请注意，崩溃的建议原因&lt;strong&gt;仅是建议&lt;/strong&gt;。错误的确切原因可能会因本地应用程序和底层操作系统而异。</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">如果由于缺少心跳或终止的Erlang运行系统而要重新引导系统， &lt;code&gt;HEART_COMMAND&lt;/code&gt; 必须在启动系统之前设置环境变量HEART_COMMAND。如果未设置此变量，则会打印警告文本，但系统不会重新引导。</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">如果系统升级失败，则必须在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上重新启动 &lt;code&gt;Mnesia&lt;/code&gt; ,以还原旧数据库。成功启动后，将自动卸载后备。成功升级系统后，函数 &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; 也可用于卸载后备。同样，这是在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上执行的分布式操作，或者不执行任何操作。后备的安装和卸载都要求Erlang在所有 &lt;code&gt;db_nodes&lt;/code&gt; 上都可运行，但是 &lt;code&gt;Mnesia&lt;/code&gt; 是否正在运行都没有关系。</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">如果系统使用发布处理，则应将其设置为类似于 &lt;code&gt;start_erl.exe&lt;/code&gt; 的程序。</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">如果已使用 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 修复了该表，则该调用将返回一个元组，其中 &lt;code&gt;FixationTime&lt;/code&gt; 是该表首次由某个进程修复的时间，而该进程是现在已修复的进程之一，也可能不是该进程已修复的进程之一。</target>
        </trans-unit>
        <trans-unit id="28d80bca5a16b32c018007fa19be0d36c5975d0c" translate="yes" xml:space="preserve">
          <source>If the table identifier is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">如果该表是哈希表，即它不是 &lt;code&gt;ordered_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">如果该表是哈希表。包含有关该表的统计数据,如最大、最小和平均链长。最大值远大于平均值,标准差远大于预期标准差,这表明术语的哈希值由于某种原因表现得很糟糕。</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">如果表是 &lt;code&gt;ordered_set&lt;/code&gt; 。（元素的数量与表中对象的数量相同。）</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">如果删除了该表，则即使使用相同名称创建另一个命名表， &lt;code&gt;tid()&lt;/code&gt; 也将无效。</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">如果表为空，则返回 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="060a5cb7c2a9190e262dad862fd197847d59b457" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3fb17408533c8e1e68861ca6b015faef26d511" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the last time when the table changed from unfixed to fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">如果表是使用 &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; 或某些内部机制固定的。</target>
        </trans-unit>
        <trans-unit id="ab8f1f3f8186f2a911707d67d645de8494934784" translate="yes" xml:space="preserve">
          <source>If the table is not fixed at all, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该表从未修复过，则调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">如果表类型为 &lt;code&gt;ordered_set&lt;/code&gt; ,并且插入对象的键与表中任何对象的键&lt;strong&gt;相等&lt;/strong&gt;，则替换旧对象。</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且给定键存在多个对象，则选择其中一个对象。这不一定是输入函数返回的对象序列中具有给定键的最后一个对象。避免使用重复的密钥，否则文件将不必要地分散。这也适用于存储在 &lt;code&gt;bag&lt;/code&gt; 类型表中的重复对象。</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且给定键存在多个对象，则选择其中一个对象。这不一定是输入函数返回的对象序列中具有给定键的最后一个对象。这也适用于存储在 &lt;code&gt;bag&lt;/code&gt; 类型表中的重复对象。</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，并且插入对象的键与表中任何对象的键&lt;strong&gt;匹配&lt;/strong&gt;，则替换旧对象。</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">如果 &lt;code&gt;set&lt;/code&gt; 了表类型，则该函数将返回空列表或具有一个对象的列表，因为具有给定键的对象不能超过一个。如果表类型是 &lt;code&gt;bag&lt;/code&gt; 或 &lt;code&gt;duplicate_bag&lt;/code&gt; ，则该函数返回任意长度的列表。</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">如果在比较键是否相等时该表使用 &lt;code&gt;==/2&lt;/code&gt; ，则 &lt;code&gt;qlc&lt;/code&gt; 模块将查找常量，而不管QLC中使用了哪个运算符。但是， &lt;code&gt;==/2&lt;/code&gt; 是首选：</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">如果表格被压缩。</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">如果目标主机是 &quot;特殊 &quot;节点,则必须在配置文件中指定FTP地址,如下所示。</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">如果目标主机是其他的东西,例如,UNIX主机,配置文件还必须包括用户名和密码(两个字符串)。</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">如果测试用例函数崩溃或故意退出，则认为它&lt;strong&gt;失败&lt;/strong&gt;。如果它返回一个值（无论是什么值），则认为它是成功的。此规则的例外是返回值 &lt;code&gt;{skip,Reason}&lt;/code&gt; 。如果返回该元组，则认为该测试用例已跳过并被记录下来。</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果测试用例返回元组 &lt;code&gt;{comment,Comment}&lt;/code&gt; ，则认为该用例成功，并且 &lt;code&gt;Comment&lt;/code&gt; 被打印在概述日志文件中。这等于调用 &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">如果测试是在选项 &lt;code&gt;create_priv_dir&lt;/code&gt; 设置为 &lt;code&gt;manual_per_tc&lt;/code&gt; 的情况下启动的，为了使测试用例使用私有目录，它必须首先通过调用此函数来创建它。</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">如果改为通过调用 &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; 来启动测试会话，则结果是测试 &lt;code&gt;t1&lt;/code&gt; 不会在 &lt;code&gt;ct_node@host_x&lt;/code&gt; （或任何其他节点）上运行测试 &lt;code&gt;t3&lt;/code&gt; 在 &lt;code&gt;ct_node@host_y&lt;/code&gt; 和 &lt;code&gt;ct_node@host_z&lt;/code&gt; 上都运行。</target>
        </trans-unit>
        <trans-unit id="66bd8e7ff485cff1898efb9a85ff8aa7af9d4928" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">如果括号之间的文本由一个数字序列组成，则该条件为true，前提是该数字的捕获子模式先前已匹配。如果存在多个具有相同编号的捕获子模式（请参见前面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 一节），则条件是正确的，前提是它们中的任何一个都已匹配。另一种表示法是在数字前加上加号或减号。在这种情况下，子模式编号是相对的而不是绝对的。最近打开的括号可以用（？（-1）引用，下一个最近的括号可以用（？（-2）引用，依此类推。在循环内，引用后续组也很有意义。可以将其打开称为（？（+ 1），依此类推。（不使用任何这些形式的值零；它会引发编译时错误。）</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">如果计时器的类型为 &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ，则对于每个中间的timout，将重新发送答复（在接收到确认或计时器到期之前这是有效的）。</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">如果跟踪元组包含五个元素，则第五个元素将作为 &lt;code&gt;Opts&lt;/code&gt; 映射中的 &lt;code&gt;extra&lt;/code&gt; 值发送。</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">如果被跟踪的节点是无磁盘的， &lt;code&gt;ttb&lt;/code&gt; 必须从具有磁盘访问权限的跟踪控制节点启动ttb，并且必须将选项 &lt;code&gt;file&lt;/code&gt; 指定为函数 &lt;code&gt;tracer/2&lt;/code&gt; ，其值为 &lt;code&gt;{local, File}&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">如果跟踪进程/端口死亡或跟踪器模块返回 &lt;code&gt;remove&lt;/code&gt; ，则将静默删除这些标志。</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">如果跟踪应在函数返回后继续进行（例如，如果它是启动函数以生成要分析的进程），则可以使用 &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; 。必须在以后的适当时间使用 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 停止跟踪。</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">如果与对等方的传输连接在发送请求后但未收到应答之前断开，则尝试将请求重新发送给备用对等方。如果没有可用的此类对等方，或者后续的 &lt;code&gt;pick_peer/4&lt;/code&gt; 回调拒绝候选者，则将发生 &lt;code&gt;handle_error/4&lt;/code&gt; 回调，并带有 &lt;code&gt;Reason = failover&lt;/code&gt; 。如果选择了对等方，则发生 &lt;code&gt;prepare_retransmit/3&lt;/code&gt; 回调，此后的语义与执行初始 &lt;code&gt;prepare_request/3&lt;/code&gt; 回调之后的语义相同。</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">如果升级或降级失败,应用程序可能最终处于不一致的状态。</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">如果用户出于某种原因想要将跟踪令牌传递给端口，则必须在端口控制过程的代码中手动完成此操作。端口控制进程必须检查适当的顺序跟踪设置（从 &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; 获得），并将跟踪信息包含在发送到各自端口的消息数据中。</target>
        </trans-unit>
        <trans-unit id="7e2e034ddd571c04bf0e9592e1523dc28c51cfbb" translate="yes" xml:space="preserve">
          <source>If the user has configured transports &lt;strong&gt;with&lt;/strong&gt; options then those will take precedence over these options. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">如果用户为测试指定了整个目录的测试套件,套件的执行顺序取决于操作系统对文件的排列方式,不同系统之间的排列方式有所不同。</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">如果用户仅通过指定顶层目录（例如，使用start flag / option &lt;code&gt;dir&lt;/code&gt; ）来运行测试对象（或OTP应用程序）的所有测试套件，则 &lt;code&gt;Common Test&lt;/code&gt; 主要在名为 &lt;code&gt;test&lt;/code&gt; 的子目录中查找测试套件模块。。如果此子目录不存在，则假定指定的顶层目录为测试目录，并从那里读取测试套件。</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">如果用户想要更新记录，它是更有效地使用 &lt;code&gt;write/sticky_write&lt;/code&gt; 作为 &lt;code&gt;LockKind&lt;/code&gt; 。如果多数检查在表上处于活动状态，则在尝试写锁定时将对其进行检查。如果不满足多数条件，这可以用来快速结束。</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">如果用户想以机器容量的百分比来查看负载值,那么这种测量方式就会出现一个问题,因为负载值并不限制在一个固定的区间内。在这种情况下,以下简单的数学变换就可以得出负载值的百分比。</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">如果用户的DSA、RSA或ECDSA密钥受密码保护,可以提供这些选项。</target>
        </trans-unit>
        <trans-unit id="753352e4298655af61f31e670724bf4c6d758094" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;Value&lt;/code&gt; is equal to the value previously stored for the key, &lt;code&gt;put/2&lt;/code&gt; will do nothing and return quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">如果值为 &lt;code&gt;false&lt;/code&gt; （被动模式），则该进程必须通过调用 &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; 来显式接收传入的数据（取决于套接字的类型） ）。</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">如果该值为 &lt;code&gt;false&lt;/code&gt; ，则Igor将读取源文件而不将其通过Erlang预处理程序（ &lt;code&gt;epp&lt;/code&gt; ），以避免扩展诸如 &lt;code&gt;-include(...).&lt;/code&gt; 类的预处理程序指令。， &lt;code&gt;-define(...).&lt;/code&gt; 和 &lt;code&gt;-ifdef(...)&lt;/code&gt; 以及诸如 &lt;code&gt;?LINE&lt;/code&gt; 和 &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; 类的宏调用。默认值为 &lt;code&gt;false&lt;/code&gt; ，即未完成预处理。 （有关详细信息，请参见模块 &lt;code&gt;epp_dodger&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;once&lt;/code&gt; （ &lt;code&gt;{active, once}&lt;/code&gt; ），则来自套接字的&lt;strong&gt;一条&lt;/strong&gt;数据消息将发送到该进程。要再接收一条消息，必须使用选项 &lt;code&gt;{active, once}&lt;/code&gt; 再次调用 &lt;code&gt;setopts/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则原始代码中的所有 &lt;code&gt;-import(...)&lt;/code&gt; 声明都将在结果中扩展；否则，将保留尽可能多的原始进口申报单。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将删除所有import语句，并且对导入函数的调用将扩展为显式远程调用。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，那么将禁止显示所有信息消息和警告消息。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则所有匹配项&amp;ldquo; &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; &amp;rdquo;，其中 &lt;code&gt;E&lt;/code&gt; 是case-，if-或receive-expression，其分支均返回n个元组（或显式抛出异常）。直接绑定并导出变量 &lt;code&gt;V1&lt;/code&gt; ，...， &lt;code&gt;Vn&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则所有影响修改代码方式的选项都设置为&amp;ldquo;无更改&amp;rdquo;。例如，仅更新防护测试， &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; 更新其他任何内容，请使用选项[new_guard_tests，idem]。（请记住，靠近列表开头的选项具有更高的优先级。）</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则将使用列表推导重写对 &lt;code&gt;lists:map/2&lt;/code&gt; 和 &lt;code&gt;lists:filter/2&lt;/code&gt; 的调用。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在打开新文件进行写入之前，将重命名现有文件。通过将 &lt;code&gt;backup_suffix&lt;/code&gt; 选项给定的字符串附加到原始名称中来形成新名称。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则防护测试将更改为使用旧名称代替新名称，例如，使用&amp;ldquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;rdquo;代替&amp;ldquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;rdquo;。默认值为 &lt;code&gt;false&lt;/code&gt; 。此选项将覆盖 &lt;code&gt;new_guard_tests&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则防护测试将更新为使用新名称，例如&amp;ldquo; &lt;code&gt;is_integer(X)&lt;/code&gt; &amp;rdquo;而不是&amp;ldquo; &lt;code&gt;integer(X)&lt;/code&gt; &amp;rdquo;。默认值为 &lt;code&gt;true&lt;/code&gt; 。另请参见 &lt;code&gt;old_guard_tests&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则不会将文件写入磁盘，而是将其打印到stdout。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则即使目标模块的名称与任何输入模块的名称不同，也不会在结果模块的顶部添加任何标题注释。相反，Igor将尝试保留其代码位于输出顶部的模块的外观。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则不会修改任何文件。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则不会修改任何文件；如果启用了 &lt;code&gt;verbose&lt;/code&gt; 标志，这通常最有用，以生成有关程序文件的报告而不影响它们。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在源自特定输入模块的代码的每个部分的开头，都不会将标题注释添加到结果模块中。默认值为 &lt;code&gt;false&lt;/code&gt; ，这意味着通常在合并两个以上模块时会添加节头。</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在读取源代码时将进行预处理。有关详细信息，请参见 &lt;code&gt;merge_files/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息，除非 &lt;code&gt;quiet&lt;/code&gt; 选项为 &lt;code&gt;true&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息，除非 &lt;code&gt;quiet&lt;/code&gt; 选项为 &lt;code&gt;true&lt;/code&gt; 。当调用默认值 &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则在程序运行时将输出进度消息；否则，将显示进度消息。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则原始文件中的源代码注释将保留在输出中。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，那么将为所有与目标模块名称不同的导出模块自动生成存根模块文件。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将递归访问子目录。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则将跟随符号目录链接。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果该值是 &lt;code&gt;true&lt;/code&gt; ，所得到的代码将使用被处理 &lt;code&gt;erl_tidy&lt;/code&gt; 模块，其中删除未使用的功能和一般不代码清理。（有关其他选项，请参见 &lt;code&gt;erl_tidy:module/2&lt;/code&gt; 。）默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则等效于在 &lt;code&gt;export&lt;/code&gt; 选项中列出所有输入模块。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则未使用的功能不会从代码中删除。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，这是默认值，那么将从套接字接收的所有内容都作为消息发送到接收进程。</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;yes&lt;/code&gt; ，则输入源中的所有文件属性 &lt;code&gt;-file(...)&lt;/code&gt; 将保留在结果代码中。如果值是 &lt;code&gt;comment&lt;/code&gt; ，它们将被转换为注释，但相对于其他源代码形式，它们将保留在代码中的原始位置。如果值为 &lt;code&gt;no&lt;/code&gt; ，则所有文件属性都将从代码中删除，除非它们附加了注释，在这种情况下，将按 &lt;code&gt;comment&lt;/code&gt; 方式处理它们。默认值为 &lt;code&gt;no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;yes&lt;/code&gt; ，则将在代码中进行了重要更改的位置插入注释。如果该值 &lt;code&gt;always&lt;/code&gt; ，则将注释&lt;strong&gt;所有&lt;/strong&gt;对代码的更改。如果值为 &lt;code&gt;no&lt;/code&gt; ，则将进行更改而不会添加注释。默认值为 &lt;code&gt;yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">如果该值是-32768到32767（含）之间的整数 &lt;code&gt;N&lt;/code&gt; ，则将该值添加到套接字发送给控制进程的数据消息的计数中。套接字的默认消息计数为 &lt;code&gt;0&lt;/code&gt; 。如果指定了负值，并且其大小等于或大于套接字的当前消息计数，则套接字的消息计数将设置为 &lt;code&gt;0&lt;/code&gt; 。一旦套接字的消息计数达到 &lt;code&gt;0&lt;/code&gt; ，要么是由于向进程发送已接收的数据消息，要么是由于显式设置了套接字，然后通过特定于套接字类型的特殊消息通知该进程该套接字已进入被动模式。套接字进入被动模式后，要接收更多消息 &lt;code&gt;setopts/2&lt;/code&gt; 必须再次调用以将套接字设置回活动模式。</target>
        </trans-unit>
        <trans-unit id="1d64e50bdb357fa38cbabe7df4a1ba284de8e2a3" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is not changed. To reset unspecified data to default values, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5530eeda0dbd39b2cfac3192200b6c910a3a3fc5" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is set to default values. To update only specified data, and keep the existing configuration for the rest, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">如果该值未达到,则该连接的套接字关闭。</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">如果期权的价值 &lt;code&gt;keep_labels&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，这是默认情况下， &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; 顶点和边缘的 &lt;code&gt;Digraph&lt;/code&gt; 被用于子为好。如果值为 &lt;code&gt;false&lt;/code&gt; ，则默认标签 &lt;code&gt;[]&lt;/code&gt; 用于子组的顶点和边缘。</target>
        </trans-unit>
        <trans-unit id="4ff461d2c9c387ebf9328f2e5d5e82024d6aaa59" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">如果期权的价值 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;inherit&lt;/code&gt; ，这是默认的类型， &lt;code&gt;Digraph&lt;/code&gt; 用于子为好。否则，将 &lt;code&gt;type&lt;/code&gt; 的选项值用作 &lt;code&gt;digraph:new/1&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;os_mon.app&lt;/code&gt; 中列出的值不适合您的需求，请&lt;strong&gt;不要&lt;/strong&gt;编辑该文件。而是&lt;strong&gt;覆盖&lt;/strong&gt;&lt;strong&gt;系统配置文件中&lt;/strong&gt;的值，该&lt;strong&gt;文件&lt;/strong&gt;的完整路径名在命令行上提供给 &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">如果变量 &lt;code&gt;V&lt;/code&gt; 是未绑定的，则它将绑定到与键 &lt;code&gt;K&lt;/code&gt; 关联的值，该键K必须存在于映射 &lt;code&gt;M&lt;/code&gt; 中。如果变量 &lt;code&gt;V&lt;/code&gt; 被绑定，它必须与相关联的值相匹配 &lt;code&gt;K&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">如果将该变量设置为 &lt;code&gt;0&lt;/code&gt; 秒，则运行时系统甚至不会尝试写入故障转储文件。它只会终止。这是如果选项默认 &lt;code&gt;-heart&lt;/code&gt; 传递给 &lt;code&gt;erl&lt;/code&gt; 和 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">如果变量设置为正值 &lt;code&gt;S&lt;/code&gt; ，则等待 &lt;code&gt;S&lt;/code&gt; 秒以完成故障转储文件，然后使用 &lt;code&gt;SIGALRM&lt;/code&gt; 信号终止运行系统。</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">如果verify回调函数总是返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则关于验证失败，TLS / DTLS握手不会终止，并且连接已建立。</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">如果verify回调fun返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ，则立即停止验证过程，向对等方发送警报，并且TLS / DTLS握手终止。</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">如果verify回调fun返回 &lt;code&gt;{fail, Reason}&lt;/code&gt; ，则验证过程将立即停止。如果verify回调函数返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则验证过程将继续。这可以用来接受特定的路径验证错误，例如 &lt;code&gt;selfsigned_peer&lt;/code&gt; ，以及验证特定于应用程序的扩展。如果使用用户应用程序未知的扩展名进行调用，则将使用返回值 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">如果验证回调函数返回 &lt;code&gt;{valid, UserState}&lt;/code&gt; ，则验证过程将继续。</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">如果从开发系统中的 &lt;code&gt;OTP_VERSION&lt;/code&gt; 文件读取的版本带有 &lt;code&gt;**&lt;/code&gt; 后缀，则已使用 &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; 工具对系统进行了修补。在这种情况下，系统由来自多个OTP版本的应用程序版本组成。后缀 &lt;code&gt;**&lt;/code&gt; 之前的版本对应于已打补丁的基本系统的OTP版本。请注意，如果通过 &lt;code&gt;otp_patch_apply&lt;/code&gt; 以外的其他方式更新了开发系统，则文件 &lt;code&gt;OTP_VERSION&lt;/code&gt; 可以标识不正确的OTP版本。</target>
        </trans-unit>
        <trans-unit id="e21657b92f7a7a61994f9d4f2c34a81fd507ae44" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;otp_patch_apply&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">如果由于尚未使用所有文件而导致包装日志未满 &lt;code&gt;{error, end_of_log}&lt;/code&gt; 如果尝试跳出日志，则会返回{错误，end_of_log}。</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">如果随后加载了一个新的模块实例(例如,由于纠错),前一个实例的代码将变成 &quot;旧的&quot;,所有指向前一个实例的导出条目将被删除。之后,新的实例会像第一次一样被加载,并成为 &quot;当前&quot;。</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">如果已经存在带有指定标识符的子规范， &lt;code&gt;ChildSpec&lt;/code&gt; 丢弃ChildSpec，并且该函数将根据相应的子进程是否在运行而返回 &lt;code&gt;{error,already_present}&lt;/code&gt; 或 &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果已经存在具有指定 &lt;code&gt;SupBridgeName&lt;/code&gt; 的进程，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">如果已经存在具有指定 &lt;code&gt;SupName&lt;/code&gt; 的进程，则该函数返回 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; ，其中 &lt;code&gt;Pid&lt;/code&gt; 是该进程的pid。</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">如果模块已经有当前代码，则该代码将保持当前状态，并且可以调用该代码，直到返回 &lt;code&gt;on_load&lt;/code&gt; 函数为止。如果 &lt;code&gt;on_load&lt;/code&gt; 函数失败，则当前代码（如果有）将保持最新。如果没有模块的当前代码，则在 &lt;code&gt;on_load&lt;/code&gt; 函数完成之前对模块进行外部调用的任何过程都将被挂起，直到 &lt;code&gt;on_load&lt;/code&gt; 函数完成。</target>
        </trans-unit>
        <trans-unit id="e6ff40b943ba1d358ca3fc56a993cb85906a59fb" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">如果存在排队事件，则使用最早的排队事件调用可能的新状态的 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; ，然后从该列表的顶部重新开始。</target>
        </trans-unit>
        <trans-unit id="e9b0222c78d7e23a53bc0a01971716c3d93b0537" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">如果在请求休眠时有排队事件要处理，则通过不休眠而是调用 &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; 来模拟 &lt;code&gt;gen_statem&lt;/code&gt; 进入休眠状态并立即被排队事件唤醒来优化此过程。</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">如果有多个modify_algorithms选项,结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">如果在迭代器没有更多的关联， &lt;code&gt;none&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">如果表中没有记录，则此函数返回原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。不建议将此原子用作任何用户记录的键。</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">如果表中没有记录，则此函数返回原子 &lt;code&gt;'$end_of_table'&lt;/code&gt; 。因此，将原子作为任何用户记录的键是非常不希望的，但也是不允许的。</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">如果没有合适的对等体，或者如果 &lt;code&gt;pick_peer/4&lt;/code&gt; 次品他们通过返回 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;{error,no_connection}&lt;/code&gt; 被返回。否则， &lt;code&gt;pick_peer/4&lt;/code&gt; 之后是 &lt;code&gt;prepare_request/3&lt;/code&gt; 回调，对消息进行编码然后发送。</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果连接上有打开的NETCONF会话，这些会话将被残酷地中止。为避免这种情况，请使用 &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt; 关闭每个会话</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">如果驾驶员的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则仅减少驾驶员的参考计数，从而不再将呼叫者视为驾驶员的 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。有关使用场景，请参阅本模块开头的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">如果驾驶员的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则仅减少驾驶员的参考数量，从而不再将呼叫者视为 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 。有关使用场景，请参阅本模块开头的 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">如果有该驱动程序的其他 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; ，则该函数返回 &lt;code&gt;{error, pending_process}&lt;/code&gt; ，但是如果没有其他用户，该函数的调用将挂起，直到关闭所有打开的端口。</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">如果有两个活动的表副本,如果一个副本失败,所有信息仍然可用。在许多应用中,这可能是一个重要的属性。此外,如果一个表副本存在于两个特定的节点上,那么在其中任何一个节点上执行的应用程序都可以在不访问网络的情况下从表中读取数据。网络操作比本地操作慢得多,消耗的资源也多。</target>
        </trans-unit>
        <trans-unit id="4c985df66903880210d4fc66a0001c590df114fc" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;erase/1&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370b7e007fd730b4b67804cb8f3411b765c85a30" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;put/2&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">如果进程中没有任何异常，则stacktrace为 &lt;code&gt;[]&lt;/code&gt; 。在为该过程更改代码后，还可以将stacktrace重置为 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">如果没有&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段，将选中&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 字段。所有 &lt;code&gt;CN&lt;/code&gt; 名称将与所有主机名进行比较</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">如果有一个 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段中， &lt;code&gt;{uri_id,string()}&lt;/code&gt; 在函数调用将被比作任何 &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; 在证书字段。如果两个 &lt;code&gt;strings()&lt;/code&gt; 相等（不区分大小写），则存在匹配项。这同样适用于任何 &lt;code&gt;{dns_id,string()}&lt;/code&gt; 在呼叫时，所有比较 &lt;code&gt;{dNSName,string()}&lt;/code&gt; 在证书字段。</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;List&lt;/code&gt; 存在一个 &lt;code&gt;Value&lt;/code&gt; ，使得 &lt;code&gt;Pred(Value)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则为第一个此类 &lt;code&gt;Value&lt;/code&gt; 返回 &lt;code&gt;{value, Value}&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f55a97af173d19104e4db4d68ae43bf0a349635" translate="yes" xml:space="preserve">
          <source>If there is a garbage collection before the result is stored, the stack will move and if the &lt;code&gt;d&lt;/code&gt; operand refered to a Y register, the pointer will no longer be valid. (Y registers are stored on the stack.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">如果右边有匹配失败,回溯到 (*PRUNE)会导致它被触发,并采取其行动。永远不能回溯到(*COMMIT)。</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">如果文本中的某个地方出现了语法错误(比如上面第二个子句中缺少的分号),这允许Merl生成一个错误信息,指向源代码中的准确行。(只需记住将列表中的字符串用逗号隔开,否则Erlang会将这些字符串片段连接起来,就像它们是一个单一的字符串一样。)</target>
        </trans-unit>
        <trans-unit id="eb988198b3b89a8ead41c2c06ba00583a45e57ec" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; option on some level the whole set is replaced by that in that option and &lt;strong&gt;all modify_algorithms are applied&lt;/strong&gt; in level ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果套接字端口中缓冲了数据，则将尝试关闭套接字的操作推迟到该数据写入内核套接字发送缓冲区中为止。如果遇到任何错误，则关闭套接字，并在下一个 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 上返回 &lt;code&gt;{error, closed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">如果有一个以上同名的子模式,则使用最早的一个。</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">如果邮箱中没有匹配的信息,则立即发生超时。</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">如果没有具有正确保护序列的匹配模式，则会发生 &lt;code&gt;case_clause&lt;/code&gt; 运行时错误。</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">如果没有指定类型的公钥可用,那么相应的条目将被忽略。请注意,可用集取决于底层的密码库和当前用户的公钥。</target>
        </trans-unit>
        <trans-unit id="2104c47ce32bc96eff6c32dbc5479f514ba24093" translate="yes" xml:space="preserve">
          <source>If there is not enough space available on the heap to satisfy the &lt;code&gt;test_heap&lt;/code&gt; instructions request for memory, then a garbage collection is initiated. It may happen immediately in the &lt;code&gt;test_heap&lt;/code&gt; instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">如果在 &lt;code&gt;Handler1&lt;/code&gt; 和进程 &lt;code&gt;Pid&lt;/code&gt; 之间存在监督连接，则在 &lt;code&gt;Handler2&lt;/code&gt; 和 &lt;code&gt;Pid&lt;/code&gt; 之间存在监督连接。</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">如果 &lt;code&gt;lists:reverse/1&lt;/code&gt; 中存在一些错误，当它以 &lt;code&gt;[1,2]&lt;/code&gt; 作为输入时使它返回 &lt;code&gt;[2,1]&lt;/code&gt; 以外的内容，那么上面的最后一个测试将引发不 &lt;code&gt;badmatch&lt;/code&gt; 错误。前两个（我们假设它们没有出现不 &lt;code&gt;badmatch&lt;/code&gt; ）将分别简单地返回 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;[1]&lt;/code&gt; ，因此都成功。 （请注意，EUnit不是出于心理考虑：如果编写的测试返回一个值，即使它是错误的值，EUnit也会认为它是成功的。结果不是应该的。）</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">如果不满足这些要求,系统可能会表现得非常糟糕。</target>
        </trans-unit>
        <trans-unit id="b741a6b0067d17a99e20727d386f0f44e405815c" translate="yes" xml:space="preserve">
          <source>If these return values are used from a &lt;strong&gt;state enter call&lt;/strong&gt; the &lt;code&gt;OldState&lt;/code&gt; does not change, but if used from an event handling &lt;strong&gt;state callback&lt;/strong&gt; the new &lt;strong&gt;state enter call's&lt;/strong&gt;&lt;code&gt;OldState&lt;/code&gt; will be the current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">如果没有指定这个属性,版本默认为模块的MD5校验和。</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">如果此回调已导出但失败，以隐藏可能的敏感数据，则默认函数将返回 &lt;code&gt;{State,Info}&lt;/code&gt; ，其中 &lt;code&gt;Info&lt;/code&gt; 仅表示 &lt;code&gt;format_status/2&lt;/code&gt; 崩溃的事实。</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">如果设置了这个配置参数,它就会取代默认的报表回调,以及元数据中发现的任何报表回调。也就是说,所有的报表都会被这个配置函数所转换。</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">如果这在你的系统上不起作用,文档会以HTML的形式包含在Erlang/OTP版本中。你也可以从 www.erlang.se (商业版 Erlang)或 www.erlang.org (开源版)阅读 HTML 文档或下载 PDF 文档。例如,对于Erlang/OTP版本R9B。</target>
        </trans-unit>
        <trans-unit id="a3eb530f2543acfe6aa144c1bf97c7dbef8076b8" translate="yes" xml:space="preserve">
          <source>If this feature is used while no such &lt;code&gt;TimeoutType&lt;/code&gt; is running then a time-out event is immediately delivered as when starting a &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">如果存在此标志，则 &lt;code&gt;global&lt;/code&gt; 不会维护分布式Erlang节点的完全连接的网络，因此无法使用全局名称注册；参见 &lt;code&gt;global(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置了此标志，则当有错误时，将返回 &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; 。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">如果设置了此标志，则出现错误时将返回 &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置了此标志，则将包含 &lt;code&gt;Warnings&lt;/code&gt; 的额外字段添加到成功返回的元组中。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">如果设置了此标志，则将一个包含 &lt;code&gt;WarningList&lt;/code&gt; 的额外字段添加到成功返回的元组中。</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">这个函数是否被调用是由前面调用handle_trans_request/3的回复控制的。handle_trans_request/3函数可以决定自己处理动作请求,也可以将处理工作委托给这个函数。</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">这个函数是否被调用,由前面调用handle_trans_request/3的响应控制。handle_trans_request/3函数可能会决定返回{handle_ack,ack_data()}或{handle_sloppy_ack,ack_data()},意思是你需要一个立即确认的回复,这个函数应该被调用来处理这个确认。</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">如果调用此函数，则只能调用一次，并且必须在调用 &lt;code&gt;ei&lt;/code&gt; 库中的任何其他函数之前调用它。</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果调用此函数，则只能在调用函数 &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; 之后直接调用一次。</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">如果调用此函数，则将使用 &lt;code&gt;undo&lt;/code&gt; 或 &lt;code&gt;set&lt;/code&gt; 作为第一个参数再次调用它。</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">如果这个函数没有被调用,启动函数会返回一个错误元组(如果使用了链接和/或超时),否则就会挂起。</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">如果此函数返回的下一个状态与当前状态不相等（ &lt;code&gt;=/=&lt;/code&gt; ），则所有延迟事件将在下一个状态中重试。</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">如果这个函数的主体没有返回一个内联常量值,那么回调模块正在做一些奇怪的事情。</target>
        </trans-unit>
        <trans-unit id="33d0e448805fb8a37d99a0aff84679f18601e686" translate="yes" xml:space="preserve">
          <source>If this is a &lt;strong&gt;state change&lt;/strong&gt;, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">如果这是个问题;要生成一个布尔值,使用类似这样的方法。</target>
        </trans-unit>
        <trans-unit id="c64d2ab7023f50eed11754a4818012e0a3833abd" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean with these algorithms use something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">如果定义了这个宏,它就会覆盖NOASSERT宏,迫使断言宏始终处于启用状态,而不考虑其他设置。</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">如果定义了这个宏,它就会覆盖NODEBUG宏,强制启用调试宏。</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">如果定义了此宏，则在禁用测试的情况下，断言宏将无效。请参见声明 &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; 。启用测试后，断言宏始终自动启用，不能禁用。</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">如果定义了这个宏,测试功能的自动导出或剥离将被禁用。</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">如果定义了此宏，则调试宏将无效。请参阅 &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 。除非启用了测试，否则 &lt;code&gt;NODEBUG&lt;/code&gt; 也暗含 &lt;code&gt;NOASSERT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">如果存在此选项，则表数据将以更紧凑的格式存储，以消耗更少的内存。但是，这会使表操作变慢。尤其是需要检查整个对象的操作，例如 &lt;code&gt;match&lt;/code&gt; 和 &lt;code&gt;select&lt;/code&gt; ，速度会慢很多。关键元素未压缩。</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">如果存在此选项，则表将在其 &lt;code&gt;Name&lt;/code&gt; 下注册，然后可在后续操作中使用该表而不是表标识符。</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">如果设置了此选项，则模式中的大多数空白字符都将被完全忽略，除非进行转义或在字符类内部。但是，不允许在诸如 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 这样的序列中引入空白，该序列会引入各种带括号的子模式，也不允许在数字量词诸如 &lt;code&gt;{1,3}&lt;/code&gt; 之内。但是，在项目与后续量词之间以及在量词和以下+表示所有格。</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">如果此选项作为 &lt;code&gt;-compile&lt;/code&gt; 指令写在源代码中，则可以使用语法 &lt;code&gt;F/A&lt;/code&gt; 代替 &lt;code&gt;{F,A}&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">如果未指定此参数，则除非设置了环境变量 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; ，否则它将默认为 &lt;code&gt;/etc/hosts&lt;/code&gt; ，该环境变量将该文件的目录定义为 &lt;code&gt;/etc&lt;/code&gt; 以外的其他目录。</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">如果未指定此参数，则除非设置了环境变量 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; ，否则它将默认为 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; ，该环境变量将该文件的目录定义为 &lt;code&gt;/etc&lt;/code&gt; 以外的其他目录。</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">如果这个模式被嵌入到一个更大的模式中,可以使用一个相对引用。</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">如果定义了此属性，则 &lt;code&gt;Inets&lt;/code&gt; 希望找到此文件中定义的所有其他属性，这些文件使用类似Apache的语法。该文件必须包括在强制属性下列出的所有属性。类似于Apache的语法是属性，写为一个单词，其中每个新单词都以大写字母开头，后跟空白，然后是值，然后是新行。</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">如果定义了此属性，则 &lt;code&gt;Inets&lt;/code&gt; 希望找到此文件中定义的所有其他属性。该文件必须包括在强制属性下列出的所有属性。</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">如果这种情况不能接受,可以用这个函数来覆盖Mnesia表加载算法的策略。这可能会导致一些事务效果丢失的情况,结果是数据库不一致,但对于某些应用来说,高可用性比数据一致更重要。</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">如果这个值为false,那么当加载一个mib时,每个mib-条目都会在安装mib之前被检查。检查的目的是为了防止相同的符号mibentry名称被用于不同的id。</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">如果这个值为false,那么当加载一个mib时,每个陷阱都会在安装mib之前被检查。检查的目的是为了防止相同的符号陷阱名被用于不同的陷阱。</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">如果这是更大的模式的一部分,你就不希望将整个模式递归,所以你可以使用。</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">如果禁用了时间校正,二郎单调时间就会向前翘起或停止,甚至长时间冻结。那么就不能保证二郎单调时钟的频率是准确的或稳定的。</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">如果禁用了时间校正,如果OS系统时间向前跃进,则Erlang单调时间向前跃进。如果OS系统时间向后跃迁,则Erlang单调时间会短暂停止,但不会长时间冻结。这是因为改变了时间偏移,使Erlang系统时间与OS系统时间一致。</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">如果禁用了时间校正，则OS系统时间的更改会像使用 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 时一样影响单调时钟。</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">如果启用了时间校正，则将对Erlang单调时钟进行调整，以使其频率尽可能保持正确。但是，在尝试调整Erlang系统时间和OS系统时间时，&lt;strong&gt;没有&lt;/strong&gt;进行&lt;strong&gt;任何&lt;/strong&gt;调整。也就是说，在预备阶段，Erlang系统时间和OS系统时间可能会彼此偏离，因此未尝试阻止此情况。</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">如果启用了时间校正，则Erlang运行时系统将同时使用 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 来调整Erlang单调时钟的频率。时间校正可确保 &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 不会扭曲，并且频率相对准确。频率调整的类型取决于所使用的时间扭曲模式。部分 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; 提供了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">如果没有启用时间校正,当操作系统的时间向后跳跃时,Erlang的单调时间就会冻结。单调时间的冻结会一直持续到OS系统时间追上为止。冻结可以持续很长时间。当OS系统时间向前跳动时,Erlang单调时间也会向前跳动。</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">如果开启了跟踪模式,这将告诉ODBC驱动将跟踪日志写到文件SQL.LOG中,该文件被放置在erlang模拟器的当前目录下。如果你怀疑erlang的ODBC程序中存在bug,那么这些信息可能会很有用,你可以把这个文件发送给我们的支持人员。否则你可能不会有什么用处。</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">如果跟踪可以为启用 &lt;code&gt;P&lt;/code&gt; 和所有进程 &lt;code&gt;Rootset&lt;/code&gt; ，该函数返回 &lt;code&gt;{ok,Value}&lt;/code&gt; 当 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 与价值回报 &lt;code&gt;Value&lt;/code&gt; ，或 &lt;code&gt;{error,Reason}&lt;/code&gt; 如果 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 失败，退出原因 &lt;code&gt;Reason&lt;/code&gt; 。否则，它将立即返回 &lt;code&gt;{error, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">如果为真,使用服务器的ECC曲线选择偏好。如果为false(默认值),则使用客户端的偏好。</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">如果为真,则使用服务器的偏好来选择密码。如果为false(默认),则使用客户端的偏好。</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">如果指定了两个 &lt;code&gt;Dates&lt;/code&gt; ，则返回在这些日期之间发生的报告。</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">如果声明了两个匹配键,则后一个键优先。</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">如果两个进程通过给出相同的名称和参数打开同一个表,那么这个表就有两个用户。如果一个用户关闭了该表,那么在第二个用户关闭该表之前,该表一直是开放的。</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">如果两个进程同时执行 &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; ，则两个更新都将生效，而不会丢失其中一个更新。返回计数器的新值 &lt;code&gt;NewVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果在后卫的顶层使用，它将测试参数是否为浮点数；为了清楚起见，请改用 &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">如果打开了验证，并且使用选项 &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; 写入了文件，则读取文件的速度较慢，并且从根本上消耗更多的CPU时间。</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">如果打开了警告（ &lt;code&gt;report_warnings&lt;/code&gt; 介绍了选项report_warnings），则以下选项控制生成的警告类型。除了 &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; 以外，以下选项具有两种形式：</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">如果我们已连接（并且连接句柄不是 &lt;code&gt;NULL&lt;/code&gt; ），则从数据库中注销。我们需要检查是否应该对 &lt;code&gt;'ok'&lt;/code&gt; 进行编码，因为我们可以从函数 &lt;code&gt;stop&lt;/code&gt; 获得此处，该函数不会将数据返回给仿真器：</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">如果我们不是安全级别的 &lt;code&gt;noAuthNoPriv&lt;/code&gt; ，这可能会很复杂，因为代理将继续进行阶段2，在此之前必须完成与usm相关的更新。</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">如果未连接，则等待 &lt;code&gt;PQsendQuery&lt;/code&gt; 的结果，因此我们获取结果并将其返回。编码使用与先前示例相同的功能完成。</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">如果我们确定这种情况不会发生,我们可以将涉及的模块指定为 &quot;安全&quot;,它们之间的所有调用都将变成本地调用。需要注意的是,如果目标模块本身被指定为安全模块,那么对它本身的 &quot;远程 &quot;调用将变成本地调用。这将破坏典型服务器循环等的代码替换属性。</target>
        </trans-unit>
        <trans-unit id="7b66416ada226ef11ca8c9b5f2f89c92815edf3c" translate="yes" xml:space="preserve">
          <source>If we disregard the contended cases, we will inevitably get a higher latency when scheduling signals for execution at a later time than by executing the signal immediately. In order to preserve the low latency we now first check if this is a contended case or not. If it is, we schedule the signal for later execution; otherwise, we execute the signal immediately. It is a contended case if other signals already are scheduled on the port, or if we fail to acquire the port lock. That is we will not block waiting for the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b9f19e72ab9cc61b4cedbac5bd537174daa35" translate="yes" xml:space="preserve">
          <source>If we disregard the locking issues, the original solution is very appealing. The mapping from process identifier to index into the array is very fast, and this property is something we would like to keep. The vast majority of operations on these tables are lookups so optimizing for lookups is what we want to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">如果我们有一个连接结果（表示 &lt;code&gt;x&lt;/code&gt; 缓冲区中有数据），则不再需要在输出（ &lt;code&gt;ready_output&lt;/code&gt; ）上进行选择，因此可以通过调用 &lt;code&gt;driver_select&lt;/code&gt; 来删除它。</target>
        </trans-unit>
        <trans-unit id="b39cddb5344c13a7bcee4c7a5972425c4aa9fc95" translate="yes" xml:space="preserve">
          <source>If we have forgotten the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; there would be a message similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">如果现在将过滤器添加到正在运行的 &lt;code&gt;Collector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">如果现在我们从节点 &lt;code&gt;ant@stack&lt;/code&gt; 上的外壳发送消息，则跟踪从外壳发送的所有消息：</target>
        </trans-unit>
        <trans-unit id="43717b37beb4229f520c407e6567fb6706951645" translate="yes" xml:space="preserve">
          <source>If we only want debug messages from a specific process it is possible to do this with a filter like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc29b0b458c2d8c07af3ed4af13280313ed829" translate="yes" xml:space="preserve">
          <source>If we only want to match operands of a certain type, we can use a type constraint. A type constraint consists of one or more lowercase letters, each specifying a type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0ecc6f7afe07e419db3c1ee4dc39311f3c9091" translate="yes" xml:space="preserve">
          <source>If we remove the &lt;code&gt;-no_next&lt;/code&gt; directive, the code would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">如果我们像这样运行它： &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; 结果将是 &lt;code&gt;result_xs.html&lt;/code&gt; 。当输入文件的结构与先前的&amp;ldquo;摩托车&amp;rdquo; XML文件的结构相同，但是输入文件中的&amp;ldquo;自行车&amp;rdquo;元素更多，而&amp;ldquo;制造商&amp;rdquo;元素则没有顺序。</target>
        </trans-unit>
        <trans-unit id="245971475847fb8e843dded9b9424bc7fe234a7a" translate="yes" xml:space="preserve">
          <source>If we would have had a huge amount of unique identifiers available, it would have tempting to drop or modify this ordering property as described above. The ordering property could for example be based on the scheduler performing the spawn operation. It would have been possible to reserve large ranges of identifiers exclusive for each scheduler thread which could be used minimizing the need for communication when allocating identifiers. The amount of identifiers we got to work with today is, however, not even close to be enough for such an approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">如果x &lt;code&gt;F&lt;/code&gt; y和y &lt;code&gt;F&lt;/code&gt; x，则x = y（ &lt;code&gt;F&lt;/code&gt; 是反对称的）。</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">如果x &lt;code&gt;F&lt;/code&gt; y和y &lt;code&gt;F&lt;/code&gt; z，则x &lt;code&gt;F&lt;/code&gt; z（ &lt;code&gt;F&lt;/code&gt; 是可传递的）。</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">如果x是一个从I到X的族,那么x[i]表示函数在索引i处的值,这样的族用 &quot;X中的一个族 &quot;的记号。</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">如果x是X的子集族，则x范围的并集称为x &lt;strong&gt;族&lt;/strong&gt;的&lt;strong&gt;并集&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">如果x为非空（索引集为非空），&lt;strong&gt;则族&lt;/strong&gt; x的交集为x范围的交集。</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">如果&lt;strong&gt;必须&lt;/strong&gt;返回存储在Ets表中的所有数据，则可以使用 &lt;code&gt;ets:tab2list/1&lt;/code&gt; 。但是，通常您只对信息的子集感兴趣，在这种情况下， &lt;code&gt;ets:tab2list/1&lt;/code&gt; 是昂贵的。如果只想从每条记录中提取一个字段，例如每个人的年龄，则：</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">如果要从git构建Erlang / OTP，则需要运行 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 来生成配置脚本。</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">如果你正在构建一个64位版本的Erlang,你应该用不同的方式设置PATHs等。我们有两个模板可以在Cygwin和MSYS中工作,但需要编辑以在MSYS2中工作(见脚本中的注释)。以下是32位的模板。</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">如果要构建64位版本，请为 &lt;code&gt;otp_build&lt;/code&gt; 提供一个体系结构参数：</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">如果要在 &lt;code&gt;git&lt;/code&gt; 中构建，则首先需要生成 &lt;code&gt;configure&lt;/code&gt; 脚本：</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">如果要在Git中进行构建，则在继续操作之前，请先阅读 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 进行构建&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">如果你要发布你的应用程序的源代码供其他人编译和运行,你可能要确保代码在EUnit不可用的情况下也能编译。就像上一节的例子一样,你可以在一个普通的头文件中加入以下几行。</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">如果你在时间偏移可能发生变化的模式下执行,而你想得到事件发生时实际的Erlang系统时间,你可以将时间偏移保存为元组中的第三个元素(比较三个元组时最不重要的元素)。</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">如果你要建立一个64位的Windows版本,你应该确保安装MinGW的64位gcc与Cygwin。它在一个开发包中。</target>
        </trans-unit>
        <trans-unit id="e873962d506d0453e258cd67b870cfcf9fdf56aa" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">如果您对事件发生时的Erlang系统时间感兴趣，还可以使用 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 保存事件之前或之后的时间偏移。加上时间偏移量的Erlang单调时间对应于Erlang系统时间。</target>
        </trans-unit>
        <trans-unit id="2501e29b8883667aa63c6065f64ad533173ff055" translate="yes" xml:space="preserve">
          <source>If you are new to &lt;code&gt;gen_statem&lt;/code&gt; and want an overview of concepts and operation the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; located in the User's Guide &lt;code&gt; OTP Design Principles &lt;/code&gt; is recommended to read before this reference manual, possibly after the Description section you are reading here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">如果您不熟悉Cygwin，MSYS，MSYS2或Unix环境，则可能需要阅读一些有关其工作原理的信息。在线上有很多关于此的文档。</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">如果你不确定操作系统的时间是否正确,为了安全起见,在启动Erlang运行系统之前,将其设置为一个保证比实际POSIX时间早的时间。</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">如果你只对所有名叫 &quot;Bryan &quot;的人的年龄感兴趣,那么:</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">如果你运行在支持HiPE的平台上,如果你没有禁用HiPE,你可以在Erlang shell中把一个模块编译成这样的本地代码。</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要测试分布式Erlang应用程序，则可能要在代码覆盖率分析中包含的代码在另一个Erlang节点上执行，而不是在运行&amp;ldquo; &lt;code&gt;Common Test&lt;/code&gt; 情况下。如果是这样，则必须在Cover Specification文件中指定这些其他节点，或将它们动态添加到节点的代码覆盖集。有关后者的详细信息，请参见模块 &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">如果你不确定自己是否正确释放了条款,可以使用以下函数查看固定条款分配器的状态。</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果可以编辑和重新编译源代码，则在要分析的代码之前和之后插入 &lt;code&gt;fprof:trace(start)&lt;/code&gt; 和 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 会很方便。还跟踪所有产生的过程。如果要使用默认 &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; 以外的其他文件名，请尝试fprof：trace（start，&amp;ldquo; my_fprof.trace&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">如果将此函数的捕获异常与 &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; 结合使用，以避免调用超时而导致调用进程死亡，则必须准备好处理较晚的答复。请注意，即使在出现网络问题的情况下，即使使用 &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; 或 &lt;code&gt;infinity&lt;/code&gt; ，也有可能获得延迟答复。那么，为什么不通过不捕获异常而让调用过程终止呢？</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">如果你的代码比较，你会看到有也是 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 被称为只能从 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 和本身，而只调用 &lt;code&gt;file:write/2&lt;/code&gt; ，注意呼叫的号码 &lt;code&gt;file:write/2&lt;/code&gt; 。但是在这里我们看到 &lt;code&gt;suspend&lt;/code&gt; 被调用了几次。这是一个伪函数，表示在 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 中执行时进程已挂起，并且由于代码中没有 &lt;code&gt;receive&lt;/code&gt; 或 &lt;code&gt;erlang:yield/0&lt;/code&gt; ，因此它必须是Erlang调度挂起，或者跟踪文件驱动程序正在补偿适用于大文件写入操作（这些被视为调度，然后是同一进程的调度）。</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">如果使用以下命令进行编译，则结果将是一个合并的模块 &lt;code&gt;MyModule.erl&lt;/code&gt; ，其中包含根据三个ASN.1规范生成的代码：</target>
        </trans-unit>
        <trans-unit id="229f423b538bb335420959949ffa6439771ff69b" translate="yes" xml:space="preserve">
          <source>If you compose your own &lt;code&gt;cipher_suites()&lt;/code&gt; make sure they are filtered for cryptolib support &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly the functions &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; also exist to help creating customized cipher suite lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2523acc9d9b699bb6e45fe3319252f79d5b73690" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">如果您决定根本不运行测试用例，请返回 &lt;code&gt;{skip,Reason}&lt;/code&gt; 。然后将 &lt;code&gt;Reason&lt;/code&gt; 打印在HTML结果页面上的字段 &lt;code&gt;Comment&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cc41ca02f8abc69bcba03c2039a4711eec766fcf" translate="yes" xml:space="preserve">
          <source>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">如果您开发链接驱动程序（共享库），则需要使用 &lt;code&gt;gcc&lt;/code&gt; 和标志 &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; 进行链接。编译时，还将在 &lt;code&gt;CFLAGS&lt;/code&gt; 中包括 &lt;code&gt;-fno-common&lt;/code&gt; 。使用 &lt;code&gt;.so&lt;/code&gt; 作为库后缀。</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">如果您没有文件内容的完整二进制文件，则可以对文件进行分块并进行逐部分检查。函数 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 的返回元组 &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; 很方便。从文件中读取的一个数据块的剩余部分不完整，将被添加到下一个块中，因此，当以UTF-8编码读取字节块时，我们避免了字符边界的问题：</target>
        </trans-unit>
        <trans-unit id="d69c0d8ff5a49420e5ccb90500698b1a5b852393" translate="yes" xml:space="preserve">
          <source>If you do not need the statistical quality of this function, there are faster algorithms in the &lt;code&gt;rand&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8d18a133f467591527f3dafe062626f3a3e3a8" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">如果您不需要在NIF调用之间重新分配数据或使数据保持活动状态，请考虑使用 &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; ,因为它会在可能的情况下在进程堆上分配小的二进制文件。</target>
        </trans-unit>
        <trans-unit id="0d84e01d642f906e2813071c9f195dfd3ff33506" translate="yes" xml:space="preserve">
          <source>If you do ordinary &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt; trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">如果你不使用X-windows,你可能想通过在控制台系统菜单中选择属性来设置Windows控制台窗口(窗口的左上角,标题栏中的Cygwin图标)。特别是设置一个较大的屏幕缓冲区大小(行)是很有用的,因为它可以让你得到一个滚动条,这样你就可以看到任何可能出现的错误信息。</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">如果您明确希望在参数向量中设置程序名称，则可以使用选项 &lt;code&gt;arg0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">如果在让仿真器线程脱离你的控制之前,你没有清除它的特定线程数据,你可能永远无法清除这些数据,以后系统的其他部分会因此出现意外错误。</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">如果您对环境和构建系统感到满意，并且拥有所有必需的工具，那么您就有很大的机会使Windows的Erlang / OTP发行版更好。请向 &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; 提交任何建议，并向 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; 提交补丁，以使他们找到进入下一版Erlang的方式。如果要对构建系统进行更改（例如makefile等），请记住，在Unix / VxWorks上使用了相同的makefile，以使您的更改不会破坏其他平台。当然，这也适用于C代码。系统特定的代码主要位于 &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; 和 &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; 目录中。在 &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; 目录是通用代码。</target>
        </trans-unit>
        <trans-unit id="c1e46734643c479e7f6063eb73e949cb06d69d85" translate="yes" xml:space="preserve">
          <source>If you find that some common Logger usage is missing from this guide, please open a pull request on github with the suggested addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">如果你经常对一个不是表的键的字段进行查找,那么使用 &quot;mnesia:select/match_object &quot;就会损失性能,因为这个函数会遍历整个表。你可以创建一个二级索引来代替,并使用 &quot;mnesia:index_read &quot;来获得更快的访问速度,然而这需要更多的内存。</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">如果获得了 &lt;code&gt;ssh_decode/2&lt;/code&gt; 返回的公共密钥 &lt;code&gt;PubKey&lt;/code&gt; 和相关的属性 &lt;code&gt;Attributes&lt;/code&gt; 列表，则可以创建一个新的SSH文件，例如：</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">如果您破解了模拟器，则可以通过站在 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; 来构建模拟器可执行文件，并执行一个简单的操作</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">如果您使用的是Xcode 4.3或更高版本,您还需要通过Xcode的下载偏好面板下载 &quot;命令行工具&quot;。</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">如果您有一个列表列表 &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; ，则可以将 &lt;code&gt;L&lt;/code&gt; 中所有字符串的长度求和，如下所示：</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">如上所述，如果已将声明 &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; 到模块中，则只需编译模块，然后运行自动导出的函数 &lt;code&gt;test()&lt;/code&gt; 即可。例如，如果您的模块名为 &lt;code&gt;m&lt;/code&gt; ，则调用 &lt;code&gt;m:test()&lt;/code&gt; 将在模块中定义的所有测试上运行EUnit。您无需为测试功能编写 &lt;code&gt;-export&lt;/code&gt; 声明。这一切都是由魔术完成的。</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">如果已使用 &lt;code&gt;install&lt;/code&gt; 目标安装了Erlang / OTP ，请使用 &lt;code&gt;install-docs&lt;/code&gt; 目标安装文档。将使用由 &lt;code&gt;configure&lt;/code&gt; 确定的安装位置。 &lt;code&gt;$DESTDIR&lt;/code&gt; 使用方式与 &lt;code&gt;make install&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">如果已使用 &lt;code&gt;release&lt;/code&gt; 目标安装了Erlang / OTP，则使用发行版 &lt;code&gt;release_docs&lt;/code&gt; 目标安装文档。通常，您希望使用与调用 &lt;code&gt;make release&lt;/code&gt; 相同的 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">如果你在OTP安装中安装了文档,也要建立文档。</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">如果您刚刚在当前源代码树中构建了Erlang / OTP，则您已经运行了 &lt;code&gt;configure&lt;/code&gt; ，因此无需再次执行此操作。否则，运行 &lt;code&gt;configure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">如果您在一个节点中有许多服务器，并且它们在生命周期中处于某些状态（可以预期服务器空闲一会儿），并且所有这些服务器所需的堆内存量是个问题，那么内存占用量可以通过 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 使其休眠，以最小化服务器的数量。</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">如果您有一个函数可以执行要分析的任务，并且该函数在分析应停止时返回，则可以使用 &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; 并将其用于跟踪步骤。</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">如果您具有公共密钥数据并想要创建PEM文件，则可以通过调用函数 &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; 和 &lt;code&gt;pem_encode/1&lt;/code&gt; 并将结果保存到文件中来完成。例如，假设您具有 &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; 。然后，您可以创建一个PEM-&amp;ldquo; RSA PUBLIC KEY&amp;rdquo;文件（ASN.1类型为 &lt;code&gt;'RSAPublicKey'&lt;/code&gt; RSAPublicKey&amp;rdquo;）或一个PEM-&amp;ldquo; PUBLIC KEY&amp;rdquo;文件（ &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1类型）。</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">如果您具有既不依赖于文件位置也不依赖于站点的系统配置数据，则尽早创建 &lt;code&gt;sys.config&lt;/code&gt; 可能很方便，因此它成为 &lt;code&gt;target_system:create/1&lt;/code&gt; 创建的目标系统tar文件的一部分。实际上，如果您在当前目录中不仅创建文件 &lt;code&gt;mysystem.rel&lt;/code&gt; ，还创建文件 &lt;code&gt;sys.config&lt;/code&gt; ，则将后一个文件默认放置在适当的目录中。</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">如果您在文件中具有交叉编译配置，请使用 &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; 命令行参数传递它。如果不是，请在命令行上使用 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 语法传递 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; ，-- &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 和配置变量（与（3）中相同）。注意， &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; 必须以一种方式传递。通过在配置文件中使用 &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; ，或使用 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 和 &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 命令行参数。</target>
        </trans-unit>
        <trans-unit id="496f196f55a6fe378376abb5b448050f783c1628" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another &lt;strong&gt;state callback&lt;/strong&gt; of yours, you have not done a &lt;strong&gt;state change&lt;/strong&gt; and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">例如，如果您使用 &lt;code&gt;gen_statem&lt;/code&gt; ，将一个事件推迟到一个状态，然后再调用您的另一个状态回调，则您尚未更改状态，因此不会重试被推迟的事件，这是合乎逻辑的，但可能会造成混淆。</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果您改为以字符串形式接收XML文档，则可以通过 &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; 对其进行解析。file / 2和string / 2都存在，其中第二个参数是解析器的选项列表，请参见 &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">如果您知道返回的二进制文件总是很小，建议您使用不需要预分配二进制文件的驱动程序API调用，例如使用 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 格式的 &lt;code&gt;driver_output()&lt;/code&gt; 或 &lt;code&gt;erl_drv_output_term()&lt;/code&gt; 来允许运行时构造一个堆二进制文件。</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">如果您知道 &lt;code&gt;escript&lt;/code&gt; 可执行文件的位置，则第一行可以直接提供 &lt;code&gt;escript&lt;/code&gt; 的路径，例如：</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">如果在让线程退出控件时将互斥锁锁定在仿真器线程中，则&lt;strong&gt;很可能会&lt;/strong&gt;死锁整个仿真器。</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">如果在让线程脱离控制时将rwlock锁定在仿真器线程中，则&lt;strong&gt;很可能会&lt;/strong&gt;死锁整个仿真器。</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">如果必须与USTAR tar格式保持兼容，则必须确保存储的文件路径总共少于255个字节，文件名组件的最大长度为100个字节。 USTAR除了名称字段外，还使用头字段（前缀），并将长度超过100字节的文件路径分为两部分。这种拆分是在目录边界上进行的，并且以充分利用这两个字段中可用空间的方式进行，但是实际上，这通常意味着路径少于255个字节。 &lt;code&gt;erl_tar&lt;/code&gt; 将自动将格式升级为PAX以处理更长的文件名，因此，仅当您需要使用较旧的 &lt;code&gt;erl_tar&lt;/code&gt; 或 &lt;code&gt;tar&lt;/code&gt; 实现提取档案文件时，这才是问题。不支持PAX。在这种情况下，PAX标头将被提取为常规文件，您将需要手动应用它们。</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">如果你需要所有存储在Ets表中的名为 &quot;Bryan &quot;的人的信息,那么:</target>
        </trans-unit>
        <trans-unit id="f37451567abb8a5fc173c77a71ec77e3d5bec387" translate="yes" xml:space="preserve">
          <source>If you need cryptographically strong random numbers use &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Alg =:= crypto&lt;/code&gt; or &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">如果您需要使用Erlang ODBC接口从erlang应用程序访问诸如 &lt;code&gt;sqlserver&lt;/code&gt; ， &lt;code&gt;mysql&lt;/code&gt; ， &lt;code&gt;postgres&lt;/code&gt; ， &lt;code&gt;oracle&lt;/code&gt; ， &lt;code&gt;cybase&lt;/code&gt; 等关系数据库，则是解决该问题的好方法。</target>
        </trans-unit>
        <trans-unit id="062952594b89959967de93ea3f7d77ceb7f51d4f" translate="yes" xml:space="preserve">
          <source>If you need to be able to repeat the sequence use this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">如果由于其他事件需要取消计时器，可以使用 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 。请注意，除非您之前已将超时消息推迟（请参阅下一节），否则超时消息将无法在此之后到达，因此请确保不要意外地推迟此类消息。还要注意，超时消息可能在取消之前就已到达，因此您可能必须根据 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 的返回值从进程邮箱中读取此类消息。</target>
        </trans-unit>
        <trans-unit id="c795f2c3cb53282059f2c8f8a7e14a7e129d266c" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that no time-out message will arrive after this (because the timer has been explicitly canceled), unless you have already postponed one earlier (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may arrive during a &lt;strong&gt;state callback&lt;/strong&gt; that is cancelling the timer, so you may have to read out such a message from the process mailbox, depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62eb303efefa39c68fc73abc117f5184daeab26" translate="yes" xml:space="preserve">
          <source>If you need to define a new function that does garbage collection, you should give it the prefix &lt;code&gt;erts_gc_&lt;/code&gt;. If that is not possible you should update the regular expression so that it will match your new function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">如果需要执行配置操作以运行测试，则可以在套件中实现配置功能。配置功能的结果是配置数据或 &lt;code&gt;Config&lt;/code&gt; 。这是键值元组的列表，这些键值元组从配置函数传递到测试用例（可能通过&amp;ldquo;较低级别&amp;rdquo;的配置函数）。数据流如下所示：</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">如果需要使用 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; Erlang代码，并且需要在更正OS系统时间之前启动Erlang运行时系统，则可能要使用单一时间扭曲模式。</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">如果你需要在仿真器线程中使用线程专用数据,只有在线程在你的控制下时才有线程专用数据集,在让线程脱离你的控制之前清除线程专用数据。</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">如果需要验证引导程序束文件是否与提供的源文件匹配，请使用 &lt;code&gt;./otp_build update_primary&lt;/code&gt; 创建一个包含差异（如果存在）的新提交。</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">如果您或您的系统有特殊要求，请阅读 &lt;code&gt;Makefile&lt;/code&gt; 以获取其他配置信息。</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">如果您打算在不重新启动系统的情况下更改代码，则必须使用外部fun（ &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ）作为 &lt;code&gt;Resolve&lt;/code&gt; 函数。如果您使用本地娱乐，则永远无法替换该娱乐所属模块的代码。</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 读回选项值，但未获取任何值，则该选项在主机操作系统中不存在。IPv6和IPv4套接字在同一端口上侦听的行为以及获取IPv4流量的IPv6套接字的行为不再可预测。</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">如果你真的,真的想,你可以叫它 &quot;英嘉&quot;。</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">如果设置了 &lt;code&gt;call&lt;/code&gt; 跟踪标志，则还必须为要&lt;strong&gt;跟踪&lt;/strong&gt;的功能设置&lt;strong&gt;跟踪模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">如果只想格式化纯文本的段落，则可能要使用 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 函数，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">如果使用 &lt;code&gt;code_lock:start([17])&lt;/code&gt; 启动此程序，则可以使用 &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt; 解锁。</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">如果您成功通过以下方式对XML文件进行了验证： &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; ,则您知道XML文档是有效的，并且具有符合DTD的结构。</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">如果你试图对另一个城市再次进行同样的操作,将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">如果您试图在注册表中存储一个对象,而现有的对象具有相同的键,则新的值将取代旧的对象。无论新对象和旧对象是否具有相同的类型,都会这样做,因此,例如,您可以用整数替换字符串。如果现有的值是字符串或二进制,那么在分配新的值之前,它将被释放。</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">如果您使用 &lt;code&gt;erl_connect_init()&lt;/code&gt; ，则您的节点将具有简称，即它不是完全合格的。如果需要使用完全限定的（长）名称，请改用 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;systools&lt;/code&gt; （用于打包代码的Erlang / OTP工具）（请参见 &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ），则每个应用程序的代码将按照预定义的 &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; 放在单独的目录中。</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">如果你使用的是一个老式的类似apace的配置文件。</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">如果使用多个CTH，则返回元组的第一部分用作下一个CTH的输入。因此，在前面的示例中，下一个CTH可以将 &lt;code&gt;{fail,Reason}&lt;/code&gt; 作为第二个参数。如果有多个CTH交互，请不要让每个CTH返回 &lt;code&gt;fail&lt;/code&gt; 或 &lt;code&gt;skip&lt;/code&gt; 。相反，通过 &lt;code&gt;Config&lt;/code&gt; 列表返回要执行的操作，并实现CTH，最后执行正确的操作。</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">如果您在基于POSIX线程或Solaris线程的线程应用程序中使用 &lt;code&gt;Erl_Interface&lt;/code&gt; 函数，则 &lt;code&gt;Erl_Interface&lt;/code&gt; 需要访问您的线程包中的某些同步工具。您必须指定额外的编译器标志，以指示您使用哪个软件包。定义 &lt;code&gt;_REENTRANT&lt;/code&gt; 以及 &lt;code&gt;STHREADS&lt;/code&gt; 或 &lt;code&gt;PTHREADS&lt;/code&gt; 。如果指定了 &lt;code&gt;_REENTRANT&lt;/code&gt; ,则默认值为使用POSIX线程。</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;ct_run&lt;/code&gt; 程序，则可以使用标志 &lt;code&gt;-shell&lt;/code&gt; 以及标志 &lt;code&gt;-config&lt;/code&gt; 和/或 &lt;code&gt;-userconfig&lt;/code&gt; 一次性启动Erlang Shell和 &lt;code&gt;Common Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3feb64f146fe919b2a69ce546c85439b7b8b28d7" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">如果您希望Erlang节点从一开始就激活一个远程作业（而不是默认的本地作业），请使用 &lt;code&gt;-remsh&lt;/code&gt; 标志启动Erlang ，例如， &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50de302c93e8bacbc69e071b7eec983f033e6a07" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e8ce10cfe9321c8cbd6786fc123b13ea0a780a" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f9444d15f637070cc1c5665eb79410298eb57c" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead. This also gives you the ability retrieve the results in other useful ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">如果只想将连接与 &lt;code&gt;Handle&lt;/code&gt; 关联（例如，如果您需要打开一个主机的多个连接），则使用 &lt;code&gt;Key&lt;/code&gt; （配置变量名称）来指定目标。请注意，没有关联目标名称的连接只能使用 &lt;code&gt;Handle&lt;/code&gt; 值关闭。</target>
        </trans-unit>
        <trans-unit id="9c1ebb966c6523b3c1b7beffcce3bfa9b40caeb1" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要使用与 &lt;code&gt;erlang:now/0&lt;/code&gt; 返回的格式相同的格式，请使用 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">如果你想在motorcycles.xml文档中添加2003年的黑色哈雷Davidsson 1200 cc Sportster摩托车的信息,它的形状和新的一样,你可以把数据放在一个简单形式的数据结构中,比如。</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">如果你想应用多个OTP应用程序的补丁,并驻留在不同的OTP版本中,你必须分步应用这些补丁。只有在同一个OTP版本中,才有可能一次应用多个OTP应用程序的补丁。</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">如果要构建 &lt;code&gt;wx&lt;/code&gt; 应用程序，则需要从 &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; 获得wxWidgets-3.0（ &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; 3.0.3.tar.bz2）或通过错误修复从github获取：</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">如果要在 &lt;code&gt;$PATH&lt;/code&gt; 使用兼容的Erlang / OTP系统进行构建，请跳至（3）。</target>
        </trans-unit>
        <trans-unit id="eb5df9d9054fc0c4d2d1fdf02282b9d140be554d" translate="yes" xml:space="preserve">
          <source>If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with &lt;code&gt;{source_name, SourceName}&lt;/code&gt;. If unset it will default to the name of the opened file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">如果你想把一个新建立的库(应用程序)复制到一个发布区,你可以像模拟器那样做。</target>
        </trans-unit>
        <trans-unit id="478802cbe47a5a6b031caf1a058324304adf72a9" translate="yes" xml:space="preserve">
          <source>If you want to do structured logging, but still want to have some control of how the final log message is formatted you can give a &lt;code&gt;report_cb&lt;/code&gt; as part of the metadata with your log event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">如果你想在模式中的某一点强制匹配失败,最方便的方法是用(?!),因为空字符串总是匹配。所以,一个要求不存在空字符串的断言必须总是失败。回溯控制动词(*FAIL)或(*F)是(?!)的同义词。</target>
        </trans-unit>
        <trans-unit id="b53c1301abde2142a7a519277a4e352002bba7dc" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after a &lt;strong&gt;state change&lt;/strong&gt;, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">如果要忽略当前状态下的特定事件并在将来的状态下处理该事件，则可以推迟该事件。状态更改（即， &lt;code&gt;OldState =/= NewState&lt;/code&gt; 更改后，重试延迟的事件。</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">如果要限制跟踪日志的大小，则可以使用自动换行日志。这几乎就像循环缓冲区一样工作。您可以指定二进制日志的最大数量以及每个日志的最大大小。 &lt;code&gt;ttb&lt;/code&gt; 然后在每次日志达到最大大小时创建一个新的二进制日志。当达到最大日志数时，将删除最早的日志，然后再创建新的日志。</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">如果要匹配典型的词组,模式必须忽略所有非单词字符,可以按以下方法进行。</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">如果你想只打印每个线程类型的运行时间,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">如果要输出XML元素或属性的内容，则可以通过 &lt;code&gt;value_of&lt;/code&gt; 函数将值作为字符串获取：</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">如果你想解析XML文件motorcycles.xml,你可以在Erlang shell中运行它,比如。</target>
        </trans-unit>
        <trans-unit id="6e509b56bd064c6196e8412d4a6710ea854feb39" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">如果你想传递一个二进制文件，还没有二进制的一个内容 &lt;code&gt;ErlDrvBinary&lt;/code&gt; ，您可以使用受益 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; ，而不是创建一个 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 然后通过传递二进制 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 。如果使用 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; ,则运行时系统通常会更智能地分配二进制文件。但是，如果要传递的二进制文件的内容已经位于 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 中，则通常最好使用所 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 和 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 传递二进制文件。</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">如果要将测试代码与常规代码分开（至少用于测试导出的函数），则可以简单地将测试函数编写在名为 &lt;code&gt;m_tests&lt;/code&gt; 的模块中（注意：不是 &lt;code&gt;m_test&lt;/code&gt; ）（如果模块名为 &lt;code&gt;m&lt;/code&gt; )。然后，每当您要求EUnit测试模块 &lt;code&gt;m&lt;/code&gt; 时，它也会寻找模块 &lt;code&gt;m_tests&lt;/code&gt; 并运行这些测试。有关详细信息，请参见&amp;ldquo;基 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分中的 &lt;code&gt;ModuleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">如果你想定制你的Erlang/OTP构建和安装,请继续阅读关于各个步骤的详细信息。</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">如果要跟踪函数调用（即，如果在任何进程上都设置了跟踪标志 &lt;code&gt;call&lt;/code&gt; ），则还必须使用 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; 在所需的函数上设置跟踪模式。/ 2,3,4。只有具有跟踪模式的函数才能被跟踪。跟踪模式指定如何使用匹配规范来跟踪功能。比赛规格在《 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 进行了描述。</target>
        </trans-unit>
        <trans-unit id="c40a044ef678327852ece515ee5ae9954050c2e8" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">如果要改为将系统日志打印到文件中，则必须配置默认处理程序来这样做。最简单的方法是在 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; 中包括以下内容：</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">如果您希望退出交互模式（例如，使用 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 启动自动化测试运行），请调用函数 &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; 。这将关闭正在运行的 &lt;code&gt;ct&lt;/code&gt; 应用程序。因此，将删除配置名称与使用 &lt;code&gt;require&lt;/code&gt; 创建的数据之间的关联。函数 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 将您带回到交互模式，但不会恢复以前的状态。</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">如果你希望一个任意指针存储在注册表中，指定 &lt;code&gt;size&lt;/code&gt; 的 &lt;code&gt;0&lt;/code&gt; 。在这种情况下，对象本身不会通过 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 操作进行传输，而仅通过指针值进行传输。</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">如果你无法在键盘上产生回拨,你可以使用ksh变体。</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">如果您使用的是MinGW的MSYS，则需要更改 &lt;code&gt;C_DRV&lt;/code&gt; 设置，其内容为：</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">如果您已使用补丁程序升级了源代码，则可能需要在新版本之前从以前的版本中清除。在进行 &lt;code&gt;make clean&lt;/code&gt; 之前，请确保阅读下面的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">如果您的应用程序有多个级别的监督,那么不要简单地将所有级别的重启强度设置为相同的值。请记住,重启的总次数(在顶层监督者放弃并终止应用程序之前)将是失败的子程序上面所有监督者的强度值的乘积。</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">如果你的驱动支持可滚动的光标,你就有更多的自由,可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">如果您的过程逻辑可以方便地描述为状态机，并且您想要以下任何 &lt;code&gt;gen_statem&lt;/code&gt; 关键功能，则：</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">如果您的测试代码写入标准输出，则可能会惊讶地发现，在运行测试时，文本未出现在控制台上。这是因为EUnit会捕获测试功能的所有标准输出（这也包括设置和清除功能，但不包括生成器功能），以便在发生错误时将其包含在测试报告中。要在测试过程中绕过EUnit并直接在控制台中打印文本，可以像 &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; 一样写入 &lt;code&gt;user&lt;/code&gt; 输出流。推荐的方法是使用EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; ，这使它更加简单。</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">例如，如果仅对源自UNIX内核的信息进行监督，则该行将从 &lt;code&gt;kern.LEVEL&lt;/code&gt; 开头。有关 &lt;code&gt;LEVEL&lt;/code&gt; 的可能值，请参见 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">但是，如果首选更残酷的变体，则可以仅使用单个升级指令 &lt;code&gt;restart_emulator&lt;/code&gt; 手写发行升级文件。与 &lt;code&gt;restart_new_emulator&lt;/code&gt; 相比，此指令使模拟器使用&lt;strong&gt;所有&lt;/strong&gt;应用程序的新版本重新启动。</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">但是,如果剖析时间很短,而主机操作系统又不支持高分辨率的cpu时间测量,一些少数操作系统的调度可能会出现实际上什么都不做的函数执行时间长得离谱的情况。曾见过一个例子,一个函数或多或少只是组成一个元组,执行时间是正常执行时间的100倍左右,当重复追踪时,执行时间变得正常。</target>
        </trans-unit>
        <trans-unit id="59b8380df4e4f344feb44d33018af07ce17468c9" translate="yes" xml:space="preserve">
          <source>Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">忽略下一届。</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igor将在编译选项中查找术语 &lt;code&gt;{igor, List}&lt;/code&gt; ，其中 &lt;code&gt;List&lt;/code&gt; 是Igor特定选项的列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">Igor:模块合并和重命名器。</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">非法使用记录</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">想象两个节点， &lt;code&gt;A&lt;/code&gt; 启动握手， &lt;code&gt;B&lt;/code&gt; 接受连接。</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;{addr,_}&lt;/code&gt; 之后紧随 &lt;code&gt;{netmask,_}&lt;/code&gt; 之后。</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">立即关闭一个或两个方向的插座。</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">如果&lt;strong&gt;未&lt;/strong&gt;设置标志 &lt;code&gt;broadcast&lt;/code&gt; 并且设置了标志 &lt;code&gt;pointtopoint&lt;/code&gt; &lt;strong&gt;则&lt;/strong&gt;此后紧跟 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb29b93b7dda93ac46a90e113b640a73b1abac2b" translate="yes" xml:space="preserve">
          <source>Immediately thereafter may &lt;code&gt;{broadaddr,_}&lt;/code&gt; follow if &lt;code&gt;broadcast&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; if &lt;code&gt;pointtopoint&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;. Both &lt;code&gt;{dstaddr,_}&lt;/code&gt; and &lt;code&gt;{broadaddr,_}&lt;/code&gt; does not occur for the same &lt;code&gt;{addr,_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="bc83afa84755c20a6573a25450865f22d16b7af9" translate="yes" xml:space="preserve">
          <source>Implement a User-Specific Handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">在驱动程序中实现 &lt;code&gt;outputv&lt;/code&gt; 回调（而不是 &lt;code&gt;output&lt;/code&gt; 回调）。如果驱动程序具有 &lt;code&gt;outputv&lt;/code&gt; 回调，则将在 &lt;code&gt;port_command/2&lt;/code&gt; 的 &lt;code&gt;Data&lt;/code&gt; 参数的iolist中传递的refc二进制文件作为对驱动程序的引用进行传递。</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">实施用户(的)。</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">实现。采用平衡二元搜索树。时间复杂度与对数N成正比,其中N是自由块的数量。</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">实现。采用平衡二元搜索树。时间复杂度与对数N成正比,其中N是自由块的大小数。</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">实现。采用平衡的二元搜索树。时间复杂度与对数N成正比,其中N是自由块的数量。</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">实施。检查自由列表中的第一个区块。如果它满足请求,则使用它,否则会创建一个新的载体。该实现的时间复杂度为常数。</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">实施：该实施使用最大块搜索深度（在每个列表中）的隔离的空闲列表来快速找到合适的对象。当最大块搜索深度较小时（默认为3），此实现的时间复杂度是恒定的。可以使用参数 &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; 来配置最大块搜索深度。</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">实现经理人的应用。</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">实施MIB可能是一项繁琐的任务。最有可能需要在实现所有表和变量之前测试代理。在这种情况下，默认的检测功能很有用。该工具包可以为变量以及表生成默认的检测功能。因此，无需任何编程即可生成可处理 &lt;code&gt;set&lt;/code&gt; ， &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;get-next&lt;/code&gt; 和表操作的运行中原型代理。</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">实现对Unicode字符集的支持是一个持续的过程。Erlang增强提案(EEP)10概述了支持Unicode的基础知识,并在二进制文件中指定了一个默认编码,所有具有Unicode意识的模块将来都要处理这个编码。</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">实施MIB</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">&lt;strong&gt;用promises&lt;/strong&gt;实现&lt;strong&gt;调用流，promise&lt;/strong&gt;是一种RPC，在结果完成之前不会挂起调用方。而是返回一个键，以后可以使用它来收集值。关键可以看作是提供答案的承诺。</target>
        </trans-unit>
        <trans-unit id="701e88bfb66430bf554605afebb5bc817eba6c88" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">实现内部CRL（证书吊销列表）缓存。除了实现 &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 行为外，还可以使用以下功能。</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">实现全局（重复）搜索（Perl中的标志 &lt;code&gt;g&lt;/code&gt; ）。每个匹配项都作为单独的 &lt;code&gt;list()&lt;/code&gt; 返回，该list（）包含特定匹配项和任何匹配的子表达式（或由option &lt;code&gt;capture&lt;/code&gt; 指定。因此，当指定此选项时，返回值的 &lt;code&gt;Captured&lt;/code&gt; 部分为 &lt;code&gt;list()&lt;/code&gt; 的 &lt;code&gt;list()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">在编译时实现转换。如果源文件中包含头文件 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，则编译器将调用此函数以进行源代码转换。</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">当从shell调用 &lt;code&gt;fun2ms/1&lt;/code&gt; 函数时，实现转换。在这种情况下，抽象形式是一种乐趣（由Erlang shell解析）。所有导入的变量都将在作为 &lt;code&gt;BoundEnvironment&lt;/code&gt; 传递的键值列表中。结果是一个标准化的术语，即不是抽象格式。</target>
        </trans-unit>
        <trans-unit id="5157539667ba028bf842cb4d314ce494573a8908" translate="yes" xml:space="preserve">
          <source>Implicitly when a specific instruction is defined. This is by far the most common way. Whenever a specific instruction is created, &lt;strong&gt;beam_makeops&lt;/strong&gt; automatically creates an internal generic instruction if it does not previously exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">导入配置数据（类似于 &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">导入的函数。可以像本地函数一样调用,也就是说,没有任何模块前缀。</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">从使用 &lt;code&gt;cover:export/1,2&lt;/code&gt; 创建的 &lt;code&gt;ExportFile&lt;/code&gt; 文件中导入coverage数据。此后执行的任何分析都将包括导入的数据。</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">使用不当会严重降低系统性能。</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">在.emacs中,斜杠字符&quot;/&quot;可以用作路径分隔符。但如果你决定使用反斜杠字符&quot;/&quot;,请不要使用双反斜杠,因为Emacs将其视为转义字符。</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">1994年，引入了全局标记模式 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 。通过将 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 放在模块头中，ASN.1编译器会在需要时自动添加标签。以下是&amp;ldquo; &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 模式下的相同规格：</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">在8位非UTF-8模式下，仅码点&amp;lt;256个字符的字符相关。</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">在 &lt;code&gt;$ERL_TOP&lt;/code&gt; ，有一个名为 &lt;code&gt;otp_build&lt;/code&gt; 的脚本。该脚本解决了提供所有正确的参数来 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 的麻烦，并且还可以帮助您设置正确的环境变量以与Cygwin / MSYS / MSYS2下的Erlang源一起使用。</target>
        </trans-unit>
        <trans-unit id="38e9bf33d69940366928f0c1e758698b02736bd6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under WSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ID&lt;/code&gt; 中，只有18位有效。在 &lt;code&gt;Creation&lt;/code&gt; 中，只有两位有效。其余为0。请参见 &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 中，表中的所有记录必须具有相同的名称。所有记录必须是相同记录类型的实例。但是，记录名称不一定必须与表名称相同，尽管在本《用户指南》的大多数示例中都是如此。如果创建的表没有属性 &lt;code&gt;record_name&lt;/code&gt; ，则以下代码确保该表中的所有记录都具有与该表相同的名称：</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">在 &lt;code&gt;Module:Name/Arity&lt;/code&gt; 中， &lt;code&gt;Module&lt;/code&gt; 和 &lt;code&gt;Name&lt;/code&gt; 是原子，而 &lt;code&gt;Arity&lt;/code&gt; 是整数。从Erlang / OTP R15开始， &lt;code&gt;Module&lt;/code&gt; ， &lt;code&gt;Name&lt;/code&gt; 和 &lt;code&gt;Arity&lt;/code&gt; 也可以是变量。以这种方式定义的乐趣是在模块 &lt;code&gt;Module&lt;/code&gt; 的&lt;strong&gt;最新&lt;/strong&gt;版本中引用具有 &lt;code&gt;Arity&lt;/code&gt; 的功能 &lt;code&gt;Name&lt;/code&gt; 。以这种方式定义的乐趣并不取决于定义它的模块的代码。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">在 &lt;code&gt;Name/Arity&lt;/code&gt; 中， &lt;code&gt;Name&lt;/code&gt; 是一个原子， &lt;code&gt;Arity&lt;/code&gt; 是一个整数。 &lt;code&gt;Name/Arity&lt;/code&gt; 必须指定一个现有的本地功能。该表达式是用于以下方面的语法糖：</target>
        </trans-unit>
        <trans-unit id="943fe69f8dfd82f02ed43163f6738a7b0394f445" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Type_List&lt;/code&gt; 中,描述了从顶部类型到每个未解码子组件的&amp;ldquo;路径&amp;rdquo;。路径的顶部类型是原子，即原子。 &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; 中的一个描述了随后对每个组件/类型的操作。</target>
        </trans-unit>
        <trans-unit id="893648209f7036a7f9ac95fdc3c4a7d64bef1838" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;allocate_heap&lt;/code&gt;, the last operand is the number of live registers. It will only be used if there is not enough heap space and a garbage collection must be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;attr&lt;/code&gt; 中，对象的属性存储为其类型（ &lt;code&gt;EI_INT&lt;/code&gt; ， &lt;code&gt;EI_FLT&lt;/code&gt; ， &lt;code&gt;EI_BIN&lt;/code&gt; 和 &lt;code&gt;EI_STR&lt;/code&gt; 之一）的逻辑&lt;strong&gt;或&lt;/strong&gt;，是否将其标记为删除（ &lt;code&gt;EI_DELET&lt;/code&gt; ），以及自从上次备份以来是否已对其进行了修改 &lt;code&gt;Mnesia&lt;/code&gt; （ &lt;code&gt;EI_DIRTY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">在上面的 &lt;code&gt;ch1.erl&lt;/code&gt; 和 &lt;code&gt;ch2.erl&lt;/code&gt; 中，有意地省略了 &lt;code&gt;channels/0&lt;/code&gt; ， &lt;code&gt;alloc/1&lt;/code&gt; 和 &lt;code&gt;free/2&lt;/code&gt; 的实现，因为它与示例无关。为了完整起见，下面给出了编写这些函数的一种方法。这仅是示例，现实的实现必须能够处理诸如用尽分配通道之类的情况。</target>
        </trans-unit>
        <trans-unit id="27aabe06bd512676435ef4845535c23e8c05bacb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions is given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">在 &lt;code&gt;ei_s_print_term()&lt;/code&gt; 中，参数 &lt;code&gt;s&lt;/code&gt; 指向 &lt;code&gt;BUFSIZ&lt;/code&gt; 字节的动态（malloc）分配字符串或 &lt;code&gt;NULL&lt;/code&gt; 指针。如果结果超过 &lt;code&gt;BUFSIZ&lt;/code&gt; 个字符，则可以使用此函数重新分配字符串（并且 &lt;code&gt;*s&lt;/code&gt; 可以更新）。返回的字符串以 &lt;code&gt;NULL&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;file_logger&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="7fbf17e1fc5bc4462fd00e9068033e131292be59" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;gen_statem&lt;/code&gt; we define a &lt;strong&gt;state change&lt;/strong&gt; as a &lt;strong&gt;state transition&lt;/strong&gt; in which the new state &lt;code&gt;S'&lt;/code&gt; is different from the current state &lt;code&gt;S&lt;/code&gt;, where &quot;different&quot; means Erlang's strict inequality: &lt;code&gt;=/=&lt;/code&gt; also known as &quot;does not match&quot;. &lt;code&gt;gen_statem&lt;/code&gt; does more things during &lt;strong&gt;state changes&lt;/strong&gt; than during other &lt;strong&gt;state transitions&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dd48fe409f725dfa23be2b6d97df3560da702c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;is_eq_exact&lt;/code&gt;, the failure address (the first operand) will only be used if the two register operands are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">在 &lt;code&gt;latin1&lt;/code&gt; 模式下，文件名按字节编码。这允许系统中所有文件名的列表表示。但是，名为&amp;ldquo;&amp;Ouml;stersund.txt&amp;rdquo;的 &lt;code&gt;file:list_dir/1&lt;/code&gt; 在文件：list_dir / 1中显示为&amp;ldquo;&amp;Ouml;stersund.txt&amp;rdquo;（如果文件名是由创建该文件的程序按字节ISO ISO Latin-1编码的），或者更可能显示为 &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; ，这是一个包含UTF-8字节的列表（不是您想要的）。如果在这样的系统上使用Unicode文件名转换，则诸如 &lt;code&gt;file:list_dir/1&lt;/code&gt; 之类的函数会忽略非UTF-8文件名。可以使用功能 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; 检索它们，但是编码错误的文件名显示为&amp;ldquo;原始文件名&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">在 &lt;code&gt;latin1&lt;/code&gt; 模式下，Erlang VM不会更改文件名的编码。在 &lt;code&gt;utf8&lt;/code&gt; 模式下，文件名可以包含大于255的Unicode字符，并且VM将文件名来回转换为本地文件名编码（通常为UTF-8，但在Windows上为UTF-16）。</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">在 &lt;code&gt;list_max/2&lt;/code&gt; ，你走在列表并使用 &lt;code&gt;Head&lt;/code&gt; ，而不是 &lt;code&gt;Result_so_far&lt;/code&gt; 当 &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;when&lt;/code&gt; 是在函数中的-&amp;gt;之前使用的特殊词，表示您仅在后面的测试为true时才使用函数的这一部分。这种测试称为&lt;strong&gt;警卫&lt;/strong&gt;。如果防护是错误的（即防护失败），则尝试功能的下一部分。在这种情况下，如果 &lt;code&gt;Head&lt;/code&gt; 不大于 &lt;code&gt;Result_so_far&lt;/code&gt; ，则它必须小于或等于它。这意味着不需要保护该功能的下一部分。</target>
        </trans-unit>
        <trans-unit id="5487ffcf59e4dcb4dda76a98d92b6b90dc718bb3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;macros.tab&lt;/code&gt;, there is a definition of &lt;code&gt;GC_REGEXP&lt;/code&gt;. It will be described in &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">在 &lt;code&gt;sort&lt;/code&gt; 的乐趣是使用：</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;terminal_logger&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">在 &lt;code&gt;unicode&lt;/code&gt; 模式下，反斜杠后只有ASCII数字和字母具有特殊含义。所有其他字符（尤其是那些代码点大于127的字符）都被视为文字。</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">在AEAD（具有关联数据的身份验证加密）模式下，根据 &lt;code&gt;Type&lt;/code&gt; 块密码解密 &lt;code&gt;CipherText&lt;/code&gt; ，并使用 &lt;code&gt;CipherTag&lt;/code&gt; 来检查 &lt;code&gt;PlainText&lt;/code&gt; 和 &lt;code&gt;AAD&lt;/code&gt; （关联的身份验证数据）的真实性。如果解密或验证失败，则可能返回 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">在AEAD（具有关联数据的身份验证加密）模式下，根据 &lt;code&gt;Type&lt;/code&gt; 块密码对 &lt;code&gt;PlainText&lt;/code&gt; 进行加密，并计算也对 &lt;code&gt;AAD&lt;/code&gt; （关联的身份验证数据）进行身份验证的 &lt;code&gt;CipherTag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">在ASN.1中,也可以有本身是结构类型的组件。例如,可以有以下几种类型:</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">在ASN.1中,可以有:</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">在ASN.1中， &lt;code&gt;BIT STRING&lt;/code&gt; 定义可以如下所示：</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">在Megaco/H.248规范(RFC 3525)的附录A中,有大约30条信息显示了一个有代表性的呼叫流程。我们还增加了一些额外的版本1、版本2和版本3的信息。我们使用这些信息作为我们测量的基础。我们的数字没有根据媒体网关与其控制器之间发送的不同种类的消息的频率进行加权。</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">在Erlang代码中,它可以如下所示。</target>
        </trans-unit>
        <trans-unit id="aba42f54367f97fea68495b7cac79db5d13869f6" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">在Erlang中，BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; 用于将术语转换为外部格式。要将二进制数据编码转换为术语，请使用BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">在Erlang中,可以应用以下内容。</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">在Erlang中,Bin用于构造二进制和匹配二进制模式。Bin的语法如下。</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">在Erlang中,字符串是整数的列表,在Erlang/OTP R13之前,字符串被定义为ISO Latin-1(ISO 8859-1)字符集,也就是一个个码点,Unicode字符集的子范围。在Erlang/OTP R13之前,字符串被定义为ISO Latin-1(ISO 8859-1)字符集的编码,也就是一个个码点,是Unicode字符集的子范围。</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">在Erlang中， &lt;code&gt;SET&lt;/code&gt; 类型与 &lt;code&gt;SEQUENCE&lt;/code&gt; 完全相同。请注意，如果使用BER或DER编码规则，则对 &lt;code&gt;SET&lt;/code&gt; 进行解码比对 &lt;code&gt;SEQUENCE&lt;/code&gt; 进行解码要慢，因为必须对组件进行排序。</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">在Erlang中，如果适用，则支持完整的UTF-16范围，例如 &lt;code&gt;unicode&lt;/code&gt; 模块和bit语法。</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">在Erlang中，没有接口来检索带有 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 的标记，因此只有次要目的与Erlang程序员有关。</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">在Erlang/OTP 17.0中,Erlang源文件的默认编码被改成了UTF-8。</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">在 Erlang/OTP 20.0 中,原子和函数可以包含 Unicode 字符。模块名称、应用程序名称和节点名称仍然被限制在ISO Latin-1范围内。</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">在Erlang / OTP 21.0中，添加了用于日志记录的新API。旧的 &lt;code&gt;error_logger&lt;/code&gt; 模块仍可用于旧代码，但日志事件将重定向到新的Logger API。新代码应直接使用Logger API。</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">在Erlang / OTP R16B中，Erlang令牌的语法已扩展为可处理Unicode。支持仅限于字符串文字和注释。有关在Erlang源文件中使用Unicode的更多信息，请参见 &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">在Erlang / OTP R5B和更高版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 目录位于 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 下，其中 &lt;code&gt;OTPROOT&lt;/code&gt; 是OTP安装的根目录（在最近的示例中为 &lt;code&gt;/usr/local/otp&lt;/code&gt; ）， &lt;code&gt;VSN&lt;/code&gt; 是Erl_Interface应用程序的版本（在最近的示例中为3.2.1）。</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">在Erlang / OTP R5B和更高版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 目录位于 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 下，其中 &lt;code&gt;OTPROOT&lt;/code&gt; 是OTP安装的根目录（在最近的示例中为 &lt;code&gt;/usr/local/otp&lt;/code&gt; ）， &lt;code&gt;VSN&lt;/code&gt; 是Erl_interface应用程序的版本（在最近的示例中为3.2.1）。</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">在Erlang / OTP R6B中，添加了一个类似于Java的Erl_Interface的库，称为&lt;strong&gt;jinterface&lt;/strong&gt;。它为Java程序提供了与Erlang节点进行通信的工具。</target>
        </trans-unit>
        <trans-unit id="1be37b0c5d13632dad76da8a59a995e7c35b67e8" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP SSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">在Erlang / OTP中，内核中的 &lt;code&gt;gen_tcp&lt;/code&gt; 和 &lt;code&gt;gen_udp&lt;/code&gt; 模块提供对TCP / IP和UDP套接字的访问。两者都易于使用，并且不需要有关套接字概念的详细知识。</target>
        </trans-unit>
        <trans-unit id="d098b9b5017423de630d21112a6b6fdc9450e7b2" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception &lt;code&gt;error:notsup&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">在FIPS模式下，所有不符合FIPS的算法均被禁用，并引发 &lt;code&gt;not_supported&lt;/code&gt; 异常。Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; 在FIPS模式下返回可用算法的受限列表。</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">在FIPS模式下,非验证的算法被禁用。这可能会在依赖加密技术的应用中引起一些意想不到的问题。</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">在德语中，字母&amp;ldquo;&amp;szlig;&amp;rdquo;（sharp s）为小写字母，但大写字母为&amp;ldquo; SS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">在希腊文中，字母&amp;ldquo;&amp;Sigma;&amp;rdquo;具有两种不同的小写形式，&amp;ldquo;-&amp;sigmaf;&amp;rdquo;处于字尾位置，&amp;ldquo;&amp;sigma;&amp;rdquo;位于其他位置。</target>
        </trans-unit>
        <trans-unit id="dbc72349c6922ca4db9e6cdf6ae70618450c536a" translate="yes" xml:space="preserve">
          <source>In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">在OTP 20中,最好删除所有使用rsa kexchange的密码套件(在21中从默认情况下删除)。</target>
        </trans-unit>
        <trans-unit id="7d0e8cf6bf94176944af04a938b90942b47513e4" translate="yes" xml:space="preserve">
          <source>In OTP 20.0 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e2f6c474b1b1d220a10a173940715aea514162" translate="yes" xml:space="preserve">
          <source>In OTP 22.1 time-out content &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; and explicit time-out &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622615c8bd1e5f7d554b06396b647aa8c7919009" translate="yes" xml:space="preserve">
          <source>In OTP 22.3 the possibility to change the callback module with actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dd0ef79035e7eb69969f59887721bb5f12a900" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All pids are now encoded using &lt;code&gt;NEW_PID_EXT&lt;/code&gt;, even external pids received as &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d163fad14d17015b8103733844b0e3f38ec8db" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All ports are now encoded using &lt;code&gt;NEW_PORT_EXT&lt;/code&gt;, even external ports received as &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5fb5345ccfcb78e9b4e7ee07de85592dd8a9f4" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All references are now encoded using &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt;, even external references received as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3265c64793aa53ad0a1577895b26f55843cba1fb" translate="yes" xml:space="preserve">
          <source>In OTP R16, modules are loaded without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire load operation. The code loading is carried out by a normal Erlang process that is scheduled like all the others. The load operation is completed by making the loaded code visible to all processes in a consistent way with one single atomic instruction. Non-blocking code loading will improve real-time characteristics when modules are loaded/upgraded on a running SMP system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e0125ea56af5dfd2fd2fd039ae24bfa32ef473" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, &lt;code&gt;uper&lt;/code&gt; or &lt;code&gt;jer&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">在OTP R16中，选项得到了简化。使用 &lt;code&gt;ber&lt;/code&gt; ， &lt;code&gt;per&lt;/code&gt; 或 &lt;code&gt;uper&lt;/code&gt; 选项之一选择后端。不再需要选项 &lt;code&gt;optimize&lt;/code&gt; ， &lt;code&gt;nif&lt;/code&gt; 和 &lt;code&gt;driver&lt;/code&gt; 选项（如果使用了ASN.1编译器，则会生成警告）。选项 &lt;code&gt;ber_bin&lt;/code&gt; ， &lt;code&gt;per_bin&lt;/code&gt; 和 &lt;code&gt;uper_bin&lt;/code&gt; 选项仍然有效，但是会生成警告。</target>
        </trans-unit>
        <trans-unit id="7beb2f37419ff75d8af6c1507fb66b318ae63c2b" translate="yes" xml:space="preserve">
          <source>In OTP R16, trace breakpoints are set in the code without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire operation. The same base technique is used as for code loading. A staging area of breakpoints is prepared and then made active with a single atomic operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">在R9C之前的OTP版本中，经过更多处理的抽象代码存储在Beam文件中。元组的第一个元素将是 &lt;code&gt;abstract_v1&lt;/code&gt; （在OTP R7B中）或 &lt;code&gt;abstract_v2&lt;/code&gt; （在OTP R8B中）。</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">在OTP中，&lt;strong&gt;应用程序&lt;/strong&gt;表示实现某些特定功能的组件，该组件可以作为一个单元启动和停止，并且可以在其他系统中重用。该模块与&lt;strong&gt;应用程序控制器&lt;/strong&gt;交互，该&lt;strong&gt;控制器&lt;/strong&gt;在每个Erlang运行时系统中启动。该模块包含用于控制应用程序的功能（例如，启动和停止应用程序），以及用于访问有关应用程序的信息的功能（例如，配置参数）。</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">在OTP中，&lt;strong&gt;事件管理器&lt;/strong&gt;是可以向其发送事件的命名对象。一个&lt;strong&gt;事件&lt;/strong&gt;可以是，例如，错误，警报，或一些信息，这些信息将被记录。</target>
        </trans-unit>
        <trans-unit id="457a0e3d6ddd599be8d5102b7c849920a5dc095d" translate="yes" xml:space="preserve">
          <source>In OTP-21 the default primary log level is &lt;code&gt;notice&lt;/code&gt;. The means that many log messages are by default not printed. This includes the progress reports of supervisors. In order to get progress reports you need to raise the primary log level to &lt;code&gt;info&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d287ac5001b044c81427ccf014f3ddfd35b4ee5b" translate="yes" xml:space="preserve">
          <source>In OpenSSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">在PCRE，一个子模式可以通过以下三种方式之一被命名为： &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 或 &lt;code&gt;(?'name'...)&lt;/code&gt; 在Perl或 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 作为蟒蛇。可以通过名称和编号来引用从模式的其他部分捕获括号的引用，例如反向引用，递归和条件。</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">在PCRE中,它与 &quot;bab &quot;匹配。第一组捕获括号匹配 &quot;b&quot;,然后在第二组中,当后引用/1未能匹配 &quot;b &quot;时,第二组选择匹配 &quot;a&quot;,然后递归。在递归过程中,\1现在确实匹配了 &quot;b&quot;,所以整个匹配成功了。在Perl中,模式失败是因为在递归调用中,\1不能访问外部设置的值。</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">在Perl中,字符串处理程序可以识别出序列\l、\L、\u和\U,并用于修改以下字符的情况。PCRE不支持这些转义序列。</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">在R4B和早期版本的OTP中， &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;lib&lt;/code&gt; 位于 &lt;code&gt;OTPROOT/usr&lt;/code&gt; 下。</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">在SNMP中， &lt;code&gt;set&lt;/code&gt; 操作是原子的。 &lt;code&gt;set&lt;/code&gt; 操作中指定的所有变量都将更改，或者不更改。因此， &lt;code&gt;set&lt;/code&gt; 操作分为两个阶段。在第一阶段，将根据MIB中变量的定义检查每个变量的新值。检查以下定义：</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">在SNMPv1和SNMPv2c中,消息中的社区字符串被用于(至少)三种不同的目的。</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">在SNMPv3中，每个使用区域都有其自己独特的机制。上下文由SNMP实体的名称 &lt;code&gt;contextEngineID&lt;/code&gt; 和上下文的名称 &lt;code&gt;contextName&lt;/code&gt; 标识。每个SNMPv3消息均包含这两个参数的值。</target>
        </trans-unit>
        <trans-unit id="c5e1bb8d75f3351aa564c900b00a6b87a8524ac7" translate="yes" xml:space="preserve">
          <source>In TLS 1.3 the session reuse is replaced by a new session tickets mechanism based on the pre shared key concept. This mechanism also obsoletes the session tickets from RFC5077, not implemented by this application. See also &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">在土耳其语中,有点和无点的 &quot;i &quot;都以小写和大写的形式存在。</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">在UTF-8模式下，值&amp;gt; 255（0xffff）的字符可以作为数据单元的文字字符串包含在类中，或者使用\ x {转义机制。</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Unicode文件名模式下，使用选项 &lt;code&gt;{spawn_executable,...}&lt;/code&gt; 指定给BIF &lt;code&gt;open_port/2&lt;/code&gt; 的文件名也被解释为Unicode。使用 &lt;code&gt;spawn_executable&lt;/code&gt; 时，选项 &lt;code&gt;args&lt;/code&gt; 中指定的参数列表也可用。使用二进制文件可以避免参数的UTF-8转换，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">在Unicode模式下,量化符适用于字符而不是单个数据单位。因此,例如,\x{100}{2}匹配两个字符,每个字符由UTF-8字符串中的一个2字节序列表示。同样,\X{3}匹配三个Unicode扩展字词簇,每个字词簇可以有很多数据单位长(而且它们可以有不同的长度)。</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">在Unicode模式下，又添加了两个代码点大于255的字符：LS（行分隔符，U + 2028）和PS（段分隔符，U + 2029）。不需要Unicode字符属性支持即可识别这些字符。</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">在Windows中,所有的目录分隔符都是正向斜杠,驱动器字母是小写的。</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Windows中，即使参数包含反斜杠，所有函数也仅返回带有正斜杠的文件名。要通过删除多余的目录分隔符来标准化文件名，请使用 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ef00d820ea8134fdb18c86e4ae50113bc762dcc" translate="yes" xml:space="preserve">
          <source>In a .config file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">在 CTH 中,行为可以在以下功能后挂入。</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">在 CTH 中,行为可以在以下函数前挂接。</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">在KDE环境中，选择&amp;ldquo; &lt;strong&gt;KDE控制中心（个人设置）&lt;/strong&gt; &amp;gt; &lt;strong&gt;区域和可访问性&lt;/strong&gt; &amp;gt; &lt;strong&gt;键盘布局&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5ff429dd35571b630c89a291b69ebf06abbcfc55" translate="yes" xml:space="preserve">
          <source>In a Supervision Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">在UTF模式下,PCRE不允许在lookbehind断言中出现\C转义(即使在UTF模式下也能匹配单个数据单元),因为这使得无法计算lookbehind的长度。\X和\R转义也不允许,它们可以匹配不同数量的数据单元。</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">在Unix (Bourne)shell中,它可以如下所示(换行符是为了便于阅读,打字时不需要)。</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">在黑盒测试方案中，基于 &lt;code&gt;Common Test&lt;/code&gt; 的测试程序通过标准O＆M和CLI协议连接到目标系统。 &lt;code&gt;Common Test&lt;/code&gt; 提供了其中一些协议的实现和包装器接口（其中大多数协议作为OTP中的独立组件和应用程序存在）。包装器简化了配置并添加了详细信息以进行日志记录。 &lt;code&gt;Common Test&lt;/code&gt; 通过有用的支持模块不断扩展。但是，请注意，使用任何Erlang / OTP组件通过 &lt;code&gt;Common Test&lt;/code&gt; 进行测试是一项简单的任务，而无需使用 &lt;code&gt;Common Test&lt;/code&gt; 包装器。就像调用Erlang函数一样简单。在以下版本中支持许多与目标无关的接口 &lt;code&gt;Common Test&lt;/code&gt; ，例如通用Telnet和FTP。这些可以是专门的，也可以直接用于控制仪表，交通负载生成器等。</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">在一个回调模块中。</target>
        </trans-unit>
        <trans-unit id="87ab655f4b96d81d49f137e06e1185ae6b220c3d" translate="yes" xml:space="preserve">
          <source>In a debug-compiled emulator, &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; makes sure that &lt;code&gt;next_pf&lt;/code&gt; is a valid instruction (that is, that it points within the &lt;code&gt;process_main()&lt;/code&gt; function in &lt;code&gt;beam_emu.c&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">在分布式Erlang系统中，有时连接到节点而不同时连接到所有其他节点很有用。一个示例是用于在不干扰系统状态的情况下检查系统状态的某种O＆M功能。为此，可以使用&lt;strong&gt;隐藏节点&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">在一个有多个Erlang节点的分布式系统中,可能需要以分布式的方式来控制应用程序。如果运行某个应用程序的节点宕机了,就要在另一个节点上重新启动应用程序。</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">在未来的Erlang/OTP版本中,可能会实现一种(可选择的)保留共享的方式。</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">在将来的版本中，参数 &lt;code&gt;Dir&lt;/code&gt; 的错误类型可能会生成异常。</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">在将来的版本中，参数 &lt;code&gt;Filename&lt;/code&gt; 的类型错误可能会生成异常。</target>
        </trans-unit>
        <trans-unit id="f07b31928724d837c06543b0d4ac70cbfb01f2cb" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在将来的版本中，此函数可能返回更多的值和范围。为了避免兼容性问题，建议使用 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">在一个较大的模式中,跟踪小括号的数字可能很棘手。通过使用相对引用可以使这一点变得更容易。在上面的模式中,你可以写(?1)来代替(?-2)来引用在递归之前最近打开的第二个小括号。也就是说,负数从遇到的点开始向左捕捉小括号算。</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">在一个更大的系统中,一个用户(这里是一个MGC)分布在几个Erlang节点上,它看起来有点不同。在这里,编码是在起源的Erlang节点(1)上进行的,二进制被转发到有物理网络接口的节点(2)上。当节点(2)的接口上收到潜在的消息回复时,会在那里进行解码,然后对消息中的每个事务采取不同的操作。交易回复将以其解码后的形式转发给发起节点(1),而其他类型的交易将在节点(2)上进行本地处理。</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">以类似于函数 &lt;code&gt;mnesia:index_read/3&lt;/code&gt; 的方式，尝试匹配记录时可以使用任何索引信息。该函数采用的模式遵循与 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 函数相同的规则，但该函数需要满足以下条件：</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">在一个单调递增的数值序列中,所有具有前级的数值都大于或等于其前级。</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">在该发行版的新版本中，应用程序 &lt;code&gt;ch_app&lt;/code&gt; 将包含在 &lt;code&gt;prim_app&lt;/code&gt; 中。也就是说，其最高主管 &lt;code&gt;ch_sup&lt;/code&gt; 将作为 &lt;code&gt;prim_sup&lt;/code&gt; 的子进程启动。</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">在一个模式匹配，一左手侧 &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 是针对右手侧匹配 &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; 。如果匹配成功，则模式中所有未绑定的变量都将被绑定。如果匹配失败，则会发生运行时错误。</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">在一个严格的单调递增的数值序列中,所有有前级的数值都比它的前级大。</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">在一棵监督树中,很多过程都有相似的结构,它们遵循相似的模式。例如,监督者的结构是相似的。它们之间唯一的区别是它们监督哪些子进程。许多工作者是服务器-客户关系中的服务器,有限状态机,或者是错误记录器等事件处理程序。</target>
        </trans-unit>
        <trans-unit id="3efaceff063003bf44950693b3f902b21784c28f" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">在系统中根据OTP设计原理，所有过程，除了系统进程和特殊工艺，驻留在行为之一实现 &lt;code&gt;supervisor&lt;/code&gt; ， &lt;code&gt;gen_server&lt;/code&gt; ， &lt;code&gt;gen_fsm&lt;/code&gt; ， &lt;code&gt;gen_statem&lt;/code&gt; 或 &lt;code&gt;gen_event&lt;/code&gt; 。这些属于STDLIB应用程序，升级/降级通常需要重新启动模拟器。</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">在 &lt;code&gt;Mnesia&lt;/code&gt; 节点的系统中，每个节点都知道所有表的当前位置。在此示例中，数据在两个节点上都被复制，并且可以在两个节点中的任何一个上执行操作表中数据的功能。无论数据位于何处，操纵 &lt;code&gt;Mnesia&lt;/code&gt; 数据的代码的行为都相同。</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">在根据OTP设计原则构造的系统中，任何流程都将是属于主管的子流程，请参阅&amp;ldquo; 更改主管&amp;rdquo;中的 &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">在使用相对较少的处理的系统中，性能&lt;strong&gt;可能&lt;/strong&gt;通过使用的增加最小堆大小来改善 &lt;code&gt;+h&lt;/code&gt; 为选项 &lt;code&gt;erl&lt;/code&gt; 或关于使用的处理的每次过程基础 &lt;code&gt;min_heap_size&lt;/code&gt; 为选项 &lt;code&gt;spawn_opt/4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">在基于TCP的分发系统中，此数据保存在&lt;strong&gt;Erlang端口映射器守护程序&lt;/strong&gt;（ &lt;code&gt;epmd&lt;/code&gt; ）中，当分布式节点启动时将与该&lt;strong&gt;守护程序&lt;/strong&gt;联系。使用此分发模块时，锁定文件和UDS侦听套接字名称的约定消除了对 &lt;code&gt;epmd&lt;/code&gt; 的需要。UDS始终限于一台主机，因此避免端口映射器很容易。</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">在SNMP监控的表中,所有元素必须是整数、字符串或整数列表。</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">在目标系统中，版本升级文件位于 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">在测试套件中，必须&lt;strong&gt;要求&lt;/strong&gt;存在配置变量（先前定义中为 &lt;code&gt;CfgVarName&lt;/code&gt; ），然后才能尝试在测试用例或配置函数中读取关联的值。</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">在元组 &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; 中，如果 &lt;code&gt;CSSFile&lt;/code&gt; 是用路径指定的，例如 &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; ，则使用此全名来查找文件。但是，如果仅指定文件名，例如 &lt;code&gt;categories.css&lt;/code&gt; ，则认为CSS文件位于套件的数据目录 &lt;code&gt;data_dir&lt;/code&gt; 中。推荐使用后者，因为与套件中的硬编码路径名相比，它是便携式的。</target>
        </trans-unit>
        <trans-unit id="1286250e203085fab759937a2009fa429066e481" translate="yes" xml:space="preserve">
          <source>In absence of spawn operation failures, atomically sets up a link between the calling process and the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7833417b997c143c87f40d58a519fc4541a0bf" translate="yes" xml:space="preserve">
          <source>In addition to specifying a type letter, the actual value for the type can be specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">除了为 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;{Item,Value}&lt;/code&gt; 对之外，还允许以下各项：</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">除了&amp;ldquo;调用图&amp;rdquo;之外，还有一个称为&amp;ldquo; &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&amp;rdquo;的图&lt;/strong&gt;。这是一个调用图（从，到），因此在调用图中有从从到到的调用链，每个从和到都是导出函数或未使用的局部函数。顶点与&amp;ldquo;调用图&amp;rdquo;相同。</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">除了由密码套件协商的用于密钥交换，有效负载加密，消息认证和伪随机计算的算法 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; 还可以使用RFC 5246中 TLS签名算法扩展第7.4.1.4.1节（从TLS 1.2开始）来协商哪个算法。 TLS握手期间使用的签名算法。如果不支持低于1.2的TLS版本，则客户端将使用此选项指定的算法发送TLS签名算法扩展。默认为</target>
        </trans-unit>
        <trans-unit id="8211e020ecaee607aa2a72d41a52382183c4a8b5" translate="yes" xml:space="preserve">
          <source>In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">除了这里的文档外,在最近的几本书中也有对Erlang的描述,比如。</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">除了之前的。</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">除了必需的回调函数 &lt;code&gt;log/2&lt;/code&gt; 之外，处理程序模块还可以导出可选的回调函数 &lt;code&gt;adding_handler/1&lt;/code&gt; ， &lt;code&gt;changing_config/2&lt;/code&gt; 和remove_handler &lt;code&gt;removing_handler/1&lt;/code&gt; 。有关这些功能的更多信息，请参见logger（3）手册页中的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="4485e35d13b31a5f17e0ec8540bc97bc5f63738e" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/3&lt;/code&gt;, &lt;code&gt;filter_config/1&lt;/code&gt;, and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">除了用于接收和发送文件的常规功能（请参见 &lt;code&gt;recv/2&lt;/code&gt; ， &lt;code&gt;recv/3&lt;/code&gt; ， &lt;code&gt;send/2&lt;/code&gt; 和 &lt;code&gt;send/3&lt;/code&gt; ）之外，还有一些功能可以将远程文件作为二进制文件接收（请参见 &lt;code&gt;recv_bin/2&lt;/code&gt; ）并将二进制文件发送到被存储为远程文件（请参见 &lt;code&gt;send_bin/3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">除了前面描述的表示形式之外，如果使用选项 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 编译了规范，则还可以使用以下不推荐使用的表示形式：</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">除了表单的表示形式之外，表示模块声明的列表（由 &lt;code&gt;epp(3)&lt;/code&gt; 和 &lt;code&gt;erl_parse(3)&lt;/code&gt; 中的函数返回）还可以包含以下内容：</target>
        </trans-unit>
        <trans-unit id="cd3b0823be609b58f269a346f9f2725dc8f84272" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">除了前面描述的标准Unicode属性外，PCRE还支持另外四个，可以转换传统的转义序列，例如\ w和\ s以使用Unicode属性。传递 &lt;code&gt;ucp&lt;/code&gt; 选项时，PCRE在内部使用这些非标准的非Perl属性。但是，它们也可以显式使用。属性如下：</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">除了静态监督树外,还可以通过以下调用将动态子进程添加到现有监督器中。</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">除了跟踪日志文件以外，在启动跟踪工具生成器时 &lt;code&gt;.ti&lt;/code&gt; 创建扩展名为.ti的文件。这是跟踪信息文件。它是一个二进制文件，其中包含进程信息，使用的跟踪标志，它所属的节点的名称以及所有使用 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 函数编写的信息。跟踪停止时， &lt;code&gt;.ti&lt;/code&gt; 文件始终与其他日志一起获取。</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">除这些选项外，还可以使用&lt;strong&gt;原始&lt;/strong&gt;选项规格。将原始选项指定为三元组的元组，以标记 &lt;code&gt;raw&lt;/code&gt; 开头，然后是协议级别，选项号和指定为二进制的选项值。这对应于C套接字API中 &lt;code&gt;setsockopt&lt;/code&gt; 调用的第二，第三和第四个参数。选项值必须以平台的本地字节序编码，并且，如果需要结构，则必须遵循特定平台上的结构对齐约定。</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">除此之外，Logger还将自动插入以下字段，这些值取自前两个参数的 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">除了本介绍性章节之外，《 &lt;code&gt;Event Tracers&lt;/code&gt; 跟踪程序用户指南》还包含以下章节：</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,Megaco用户指南还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,Reltool用户指南还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">除本介绍章节外,《SNMP用户指南》还包括以下章节。</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">另外， &lt;code&gt;#Record.Name&lt;/code&gt; 返回记录 &lt;code&gt;Record&lt;/code&gt; 的 &lt;code&gt;Name&lt;/code&gt; 的元组表示形式中的索引。</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">此外，EUnit还将寻找另一个名为 &lt;code&gt;ModuleName&lt;/code&gt; 加上后缀 &lt;code&gt;_tests&lt;/code&gt; 的模块，如果存在，还将添加该模块的所有测试。（如果 &lt;code&gt;ModuleName&lt;/code&gt; 已经包含后缀 &lt;code&gt;_tests&lt;/code&gt; ，则不会这样做。）例如，规范 &lt;code&gt;{module, mymodule}&lt;/code&gt; 将运行模块 &lt;code&gt;mymodule&lt;/code&gt; 和 &lt;code&gt;mymodule_tests&lt;/code&gt; 中的所有测试。通常， &lt;code&gt;_tests&lt;/code&gt; 模块应仅包含使用主模块的公共接口的测试用例（不得包含其他代码）。</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此外，可以设置和更改表属性。有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">此外,还存在以下三种内置类型,可以认为它们的定义如下,尽管严格来说,它们的 &quot;类型定义 &quot;根据上面定义的类型语言不是有效的语法。</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">此外,使用记录类型时,还可以通过添加字段的类型信息进一步指定记录字段,具体如下。</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">另外，您可能需要熟悉 &lt;code&gt;dbg&lt;/code&gt; 模块，也可能要熟悉 &lt;code&gt;seq_trace&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">在所有函数中，都可以引发 &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; 错误，其中 &lt;code&gt;Reason&lt;/code&gt; 描述了错误。</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">在所有这些情况下， &lt;code&gt;ReplyInfo&lt;/code&gt; 具有以下结构：</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">在所有其他情况下:</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">在所有其他意义上， &lt;code&gt;_tmo&lt;/code&gt; 函数都继承了不带 &lt;code&gt;_tmo&lt;/code&gt; 后缀的函数的所有返回值和语义。</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">在上面所有的例子中,对象必须存在,而且必须是指定操作的正确类型。如果你不知道一个对象的类型,你可以问。</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">在OTP源代码树中，可以从文本文件 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; 中读取OTP版本。可以通过调用 &lt;code&gt;filename:join([&lt;/code&gt; [ &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; 来构造文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">在此API的早期版本中， &lt;code&gt;lookup&lt;/code&gt; 函数收到两个参数，省略了 &lt;code&gt;Issuer&lt;/code&gt; 。为了兼容性，它仍然受支持：如果回调模块中没有 &lt;code&gt;lookup/3&lt;/code&gt; 函数，则改为调用 &lt;code&gt;lookup/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">在嵌入式系统中，通常没有交互式外壳。但是，操作员可以通过命令 &lt;code&gt;to_erl&lt;/code&gt; 连接到Erlang系统。然后，操作员将连接到Erlang外壳并可以发出普通的Erlang命令。通过此Shell与系统进行的所有交互都记录在一个特殊目录中。</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">在已安装的OTP开发系统中，可以从文本文件 &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; 。通过调用 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; 可以构造文件的绝对路径。</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">在交互式系统中，代码加载器提供需求驱动的代码加载，但是在嵌入式系统中，代码加载器立即加载所有代码。在两种情况下都使用相同版本的 &lt;code&gt;code&lt;/code&gt; 。代码服务器调用 &lt;code&gt;init:get_argument(mode)&lt;/code&gt; 以确定它是在需求模式还是非需求驱动模式下运行。</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">在这两种情况下,都会设置当前令牌。特别是,如果收到的消息的令牌是空的,则进程的当前令牌被设置为空。</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">在这两种情况下,应该返回表中第一个可访问的元素。由于关键列是不可访问的,这意味着第三列是第一行。</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">在上述两个示例中， &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; 都将在跟踪函数之后立即重置跟踪令牌，以避免由于Erlang Shell中的打印输出而产生许多跟踪消息。</target>
        </trans-unit>
        <trans-unit id="b04f25164a1486f33a08ec5a081e04f72ebc9e3b" translate="yes" xml:space="preserve">
          <source>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via &lt;code&gt; term_to_binary/1&lt;/code&gt;. The term may be optionally compressed when serialized. It must follow the type specification below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">简而言之， &lt;code&gt;Common Test&lt;/code&gt; 支持：</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">简而言之,CTH允许你做以下事情。</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">简而言之,CTH允许你。</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">简而言之，一个简单的测试对象由一个不带参数的函数组成（可能带有一些其他元数据，即行号）。通过返回某个值（被忽略）来对函数求值&lt;strong&gt;成功&lt;/strong&gt;，或者通过抛出异常而对函数求值&lt;strong&gt;失败&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="cf6c31b5ceac197ebb6de3ed74b4d965acf33272" translate="yes" xml:space="preserve">
          <source>In case of a &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; checking the user, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">在一个ReferenceID并从一个CN值之间的匹配操作的情况下 &lt;code&gt;Subject&lt;/code&gt; 字段中，第一个参数的乐趣是从ReferenceID所提取的主机名，并且所述第二参数是元组 &lt;code&gt;{cn, string()}&lt;/code&gt; 从所拍摄的 &lt;code&gt;Subject&lt;/code&gt; 领域。这样就可以从&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 字段和&amp;ldquo; &lt;code&gt;Subject Alternate Name&lt;/code&gt; 字段中为呈现的ID设置单独的匹配规则。</target>
        </trans-unit>
        <trans-unit id="14abcc78e4a8808dcb7c6c248f2d73041919e75b" translate="yes" xml:space="preserve">
          <source>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果发生错误（例如， &lt;code&gt;addr_unreachable&lt;/code&gt; ），则字段 &lt;code&gt;error&lt;/code&gt; 提供更多诊断信息。在这种情况下，事件 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 将自动转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。可以使用 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;error&lt;/code&gt; 字段值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">发生错误时，所有检测功能都可能返回SNMPv1或SNMPv2错误代码。如果它返回SNMPv2代码，则在将其发送到SNMPv1管理器之前，它将转换为SNMPv1代码。建议对所有检测功能使用SNMPv2错误代码，因为它们提供了更多详细信息。有关错误代码转换的说明，请参见 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53574543ae936142434ad121e0424851d134f56f" translate="yes" xml:space="preserve">
          <source>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">对于列表，只有百分比编码。但是，在二进制文件中，应同时考虑二进制编码和百分比编码。 &lt;code&gt;transcode/2&lt;/code&gt; 提供了一种在支持的编码之间进行转换的方法，它采用 &lt;code&gt;uri_string()&lt;/code&gt; 和指定入站和出站编码的选项列表。</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">在加载的情况下，监测可以&lt;strong&gt;不&lt;/strong&gt;只会收到使用选项触发 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; ，而且在特殊情况下，加载错误是短暂的。因此， &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 基本上将在&lt;strong&gt;所有&lt;/strong&gt;现实情况下使用。</target>
        </trans-unit>
        <trans-unit id="c09622d21ce9a9b2d2c2d392f9cbc9b05b57cfb1" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; is set, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8bc8abb7f5d55980d9c87519b99d19822bd2d" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; variant or no exec-option at all, all reads from &lt;code&gt;standard_input&lt;/code&gt; will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to &lt;code&gt;standard_output&lt;/code&gt; will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果从&amp;ldquo; &lt;code&gt;Subject&lt;/code&gt; 证书字段中获取&amp;ldquo;呈现的ID&amp;rdquo; ，则名称可能包含通配符。该函数 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 定义处理此问题。</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在OctetString（）和派生类型的string（）和binary（）类型之间进行选择，则表示形式取决于 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; 的值：service_opt（） &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">在已知主题字符串不包含换行符的情况下，值得设置 &lt;code&gt;dotall&lt;/code&gt; 以获得此优化，或者使用^来明确表示锚定。</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">如果要重定向标准输入和/或标准输出或在管道中使用Erlang，则 &lt;code&gt;werl&lt;/code&gt; 不适合，而应使用 &lt;code&gt;erl&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">在某些输出函数和shell中的返回值输出中,Erlang会尝试用启发式的方式检测列表和二进制文件中的字符串数据。通常你会在这样的情况下看到启发式检测。</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">在某些情况下，尤其是在重定向标准输出时，可以方便地访问特定于错误消息的I / O服务器。I / O设备 &lt;code&gt;standard_error&lt;/code&gt; 可用于将输出定向到当前操作系统认为适合用于错误输出的任何I / O设备。类似于Unix的操作系统上的示例：</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">与 &lt;code&gt;{locations, true}&lt;/code&gt; 结合使用时，此选项将打印锁定操作源文件和行号入口点以及每个入口的统计信息。</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 一起，为每个依赖项添加一个假目标。</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 结合使用，将发出的规则的名称更改为 &lt;code&gt;Target&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">与选项 &lt;code&gt;-M&lt;/code&gt; 或 &lt;code&gt;-MF&lt;/code&gt; 结合使用，会将丢失的标头视为生成的文件，并将其添加到依赖项中。</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">与RPC相比,多路调用是指从一个客户端并发发送到多个服务器的RPC。这对于收集一组节点的信息,或者在一组节点上调用一个函数来实现一些副作用是很有用的。它在语义上与在所有节点上反复进行一系列RPC是一样的,但多呼的速度更快,因为所有的请求都是同时发送的,并且在返回时逐一收集。</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">与大多数其他回调函数相比， &lt;code&gt;stop_select&lt;/code&gt; 的调用独立于任何端口。没有 &lt;code&gt;ErlDrvData&lt;/code&gt; 参数传递给该函数。不能保证持有任何驱动程序锁或端口锁。该端口称为 &lt;code&gt;driver_select&lt;/code&gt; 甚至在当时被关闭 &lt;code&gt;stop_select&lt;/code&gt; 被调用。但它也可以是案件 &lt;code&gt;stop_select&lt;/code&gt; 被直接调用 &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">与此相反,对编号子模式的子程序调用总是指模式中第一个给定编号的子模式。下面的模式符合 &quot;abcabc &quot;或 &quot;defabc&quot;。</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">在崩溃转储中,堆栈、消息和进程字典被省略。</target>
        </trans-unit>
        <trans-unit id="f5b30e844f19c774b16c52548000fcb4af87d281" translate="yes" xml:space="preserve">
          <source>In decryption, the &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; removes such padding, if present. The &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; is not removed - it has to be done elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">在肮脏的上下文中，即 &lt;code&gt;sync_dirty&lt;/code&gt; 或 &lt;code&gt;async_dirty&lt;/code&gt; ，修改后的记录不会存储在本地副本中。而是，每个记录分别更新。如果表在另一个节点上具有副本，则会产生大量网络流量，并且具有脏操作所具有的所有其他缺点。特别是对于命令 &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; ，与前面针对 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; 所述的缺点相同，即在迭代过程中无需写入表。</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">在每一个 &lt;code&gt;Viewer&lt;/code&gt; ，只有一个过滤器，是活动和全部跟踪 &lt;code&gt;Events&lt;/code&gt; 的 &lt;code&gt;Viewer&lt;/code&gt; 从得到 &lt;code&gt;Collector&lt;/code&gt; 将直通该过滤器。通过编写巧妙的过滤器，可以自定义 &lt;code&gt;Events&lt;/code&gt; 在查看器中的外观。 &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; 中的以下过滤器替换了角色名称 &lt;code&gt;mnesia_tm&lt;/code&gt; 和 &lt;code&gt;mnesia_locker&lt;/code&gt; ,并将其他所有内容保留在记录中：</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">在每次迭代中,二进制中的前8位将被跳过,而不是匹配出来。</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">在早期的Erlang / OTP版本中，对太大的二进制文件进行操作通常会失败或给出错误的结果。在将来的版本中，其他创建二进制文件的操作（例如 &lt;code&gt;list_to_binary/1&lt;/code&gt; ）也可能会实施相同的限制。</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">在这两种情况下，代理都不会执行任何操作，但会返回检索到的ManagerEngineID（有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; ），并可能继续进行发现过程的第二阶段。</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">在嵌入式模式下,所有的代码都是在系统启动时根据引导脚本加载的。(也可以通过明确地命令代码服务器在之后加载代码)。</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">在嵌入式模式下，首先加载所有模块。然后，将调用所有 &lt;code&gt;on_load&lt;/code&gt; 函数。除非所有 &lt;code&gt;on_load&lt;/code&gt; 函数都返回 &lt;code&gt;ok&lt;/code&gt; ,否则系统将终止。</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">在嵌入式模式下,模块不会自动加载。试图使用一个未加载的模块会导致错误。当启动脚本加载所有模块时,建议使用这种模式,因为通常在OTP版本中是这样做的。(以后仍然可以通过明确命令代码服务器加载代码)。</target>
        </trans-unit>
        <trans-unit id="a1f53217834ce9f061b0ce0f9fd6ed43fb29178a" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">在RAM数量有限且没有虚拟内存的嵌入式系统中，您可能希望通过将 &lt;code&gt;Number&lt;/code&gt; 设置为零来保留内存。（该值可以全局设置，请参见 &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">本质上，该函数执行与 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 相同的操作，但该函数期望使用指向字符指针（ &lt;code&gt;mbufp&lt;/code&gt; ）的指针，该字符指针指向由 &lt;code&gt;malloc&lt;/code&gt; 分配的存储区，而不是使用 &lt;code&gt;ei_x_buff&lt;/code&gt; 。参数 &lt;code&gt;bufsz&lt;/code&gt; 将是一个指向整数的指针，该整数包含内存区域的确切大小（以字节为单位）。该函数可以重新分配内存区域，在这种情况下，会将新大小放入 &lt;code&gt;*bufsz&lt;/code&gt; 并更新 &lt;code&gt;*mbufp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">用户可以在 &lt;code&gt;DocumentRoot&lt;/code&gt; 下或 &lt;code&gt;Alias&lt;/code&gt; 下的每个目录中放置一个访问文件。访问文件是纯文本文件，用于指定在Web服务器响应请求之前要考虑的限制。如果所请求资产的路径中有多个访问文件，那么将使用该资产中最靠近目录的访问文件中的指令。</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">其实由于随机数据是被缓存的,所以如果你尝试的话,一些数字可能会被复制,但这是不可预知的。</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">在幸运的情况下,不一致只在属于特定应用的表中可见。然而,如果一个模式事务因为强制事务恢复决定而不一致地恢复,那么不一致的影响可能是致命的。然而,如果更高的优先级是可用性而不是一致性,那么它可能值得冒这个风险。</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">通常，错误仅在最新 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; 修复，而新功能将在正在开发的即将发布的版本中引入。但是，当我们由于内部原因而修复较旧版本的错误时，这些错误也将发布并宣布。</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">通常，当 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;index&lt;/code&gt; 时，在匹配项中未分配值的子模式将作为元组 &lt;code&gt;{-1,0}&lt;/code&gt; 返回。对于其他返回类型，未分配的子模式分别作为空二进制或列表返回。考虑以下正则表达式：</target>
        </trans-unit>
        <trans-unit id="264b6524a328aed18af181468f92444ef5d0e1cd" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;ei&lt;/code&gt; library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the &lt;code&gt;ei&lt;/code&gt; library itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">一般来说,有比使用超时监督分布式Erlang系统的部分更好的方法。超时通常适用于监督外部事件,例如,如果你期望在指定的时间内从某个外部系统得到一条消息。例如,如果用户有十分钟没有访问Messenger系统,超时可以用来将其注销。</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">一般来说,在其他语言中使用 &quot;记录 &quot;或 &quot;结构 &quot;时,会使用tuple。另外,在表示大小不一的事物时,也就是在其他语言中使用链接列表时,也会使用列表。</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">通常，版本可以包含三个以上的部分。然后仅部分订购这些版本。此类版本仅在特殊情况下使用。将多余的部分（正常三部分中的一部分）添加到版本号后，将创建一个新的版本分支。新分支相对于基本版本具有线性顺序。但是，不同分支上的版本没有顺序，因此只能得出结论，它们都包含最接近的共同祖先中包含的内容。从同一基本版本多次分支时，将在基本版本和最低有效 &lt;code&gt;1&lt;/code&gt; 部分之间添加 &lt;code&gt;0&lt;/code&gt; 个部分，直到找到唯一的版本。具有订单的版本可以按照上一段所述进行比较。</target>
        </trans-unit>
        <trans-unit id="ba987c1f9181380720aed267fac74a6f9ee0f607" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used when branching off from another branch. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">在全局跟踪模式下,采集器会自动开始对所有连接的Erlang节点进行跟踪。当一个节点连接后,将在该节点上启动端口跟踪器,并在收集器节点上启动相应的跟踪客户端。</target>
        </trans-unit>
        <trans-unit id="f00745ad8caa1afca6bdd4f2b710aba925b97dcb" translate="yes" xml:space="preserve">
          <source>In instructions that will not always execute the next instruction. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">在交互模式下,代码在第一次引用时是动态加载的。当调用某个模块中的函数,而模块没有被加载时,代码服务器会搜索代码路径,将模块加载到系统中。</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">在交互模式下，代码服务器维护一个搜索路径，通常称为&lt;strong&gt;代码路径&lt;/strong&gt;，它由目录列表组成，在尝试加载模块时会顺序搜索该目录。</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">在交互模式下,也就是默认情况下,系统启动时只加载部分代码,基本上是运行时系统需要的模块。其他代码在第一次引用时,会被动态加载。当调用某个模块中的函数,而该模块没有被加载时,代码服务器会搜索并尝试加载该模块。</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">&lt;code&gt;match_spec&lt;/code&gt; 的最简单形式如下所示：</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">在本地模式下,代码只在当前节点解释。在全局模式下,代码在所有已知节点上进行解释。在其他节点上执行解释代码的进程会自动显示在Monitor窗口中,并且可以像其他调试进程一样被附加到。</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">在低内存系统（尤其是没有虚拟内存）中，将该值设置为 &lt;code&gt;0&lt;/code&gt; 可以帮助节省内存。</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">在许多应用中,处理事务的开销会导致性能的损失。脏操作是绕过大部分处理工作并提高事务速度的捷径。</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">在许多系统中，过载队列的瞬时状态是正常的。尽管此函数返回 &lt;code&gt;false&lt;/code&gt; 并不意味着保证另一个节点无响应，但它可能是暂时的重载。同样，返回值为 &lt;code&gt;true&lt;/code&gt; 只是意味着可以在（TCP）通道上发送消息而不会阻塞；不能保证该消息到达远程节点。对于断开连接的无响应节点，返回值为 &lt;code&gt;true&lt;/code&gt; （模拟operator &lt;code&gt;!&lt;/code&gt; 的行为）。函数返回 &lt;code&gt;false&lt;/code&gt; 时的预期行为和采取的措施是特定于应用程序和硬件的。</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">在匹配中,这个默认值只对最后一个元素有效。匹配中的所有其他位串或二进制元素必须有一个大小规格。</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">单位:微秒</target>
        </trans-unit>
        <trans-unit id="74df42bf134f27883f855d9ef2904cba9dbfb304" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;verify_none&lt;/code&gt; 模式下，默认行为是允许所有x509路径验证错误。另请参阅选项 &lt;code&gt;verify_fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">用更多的技术术语来说， &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 丢弃该进程的调用堆栈，然后垃圾收集该进程。此后，所有活动数据都位于一个连续的堆中。然后将堆压缩到与其所保存的实时数据完全相同的大小（即使该大小小于该进程的最小堆大小）。</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">在可以使用此地址族的大多数API函数中，端口号必须为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;RootDir&lt;/code&gt; 中参数应该被设置为一样的 &lt;code&gt;root_dir&lt;/code&gt; 在呼叫用于配置参数 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; （或 &lt;code&gt;code:root_dir()&lt;/code&gt; 如果配置参数没有被设置）。在某些情况下，针对不同的根目录评估相同的目标规范可能很有用。但是，应格外小心，因为它要求在所有根目录下都具有等效的文件结构。</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">在正常模式下，用户的击键由 &lt;code&gt;tty&lt;/code&gt; 收集和解释。支持大多数&lt;strong&gt;Emacs的&lt;/strong&gt;行编辑命令。以下是受支持的行编辑命令的完整列表。</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">在正常操作中， &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 调用几乎是免费的。需要跟踪时，可以显式激活这些功能上的跟踪。或者，您可以将 &lt;code&gt;trace_global&lt;/code&gt; 的用法与 &lt;code&gt;trace_pattern&lt;/code&gt; 的用法结合起来。设置后， &lt;code&gt;trace_pattern&lt;/code&gt; 将在所有连接的节点上自动激活。</target>
        </trans-unit>
        <trans-unit id="eae1f10c8b9d4c5e175d3fc8937d4ffde9c0f51a" translate="yes" xml:space="preserve">
          <source>In order for an &lt;code&gt;erpc&lt;/code&gt; operation to succeed, the remote node also needs to support &lt;code&gt;erpc&lt;/code&gt;. Typically only ordinary Erlang nodes as of OTP 23 have &lt;code&gt;erpc&lt;/code&gt; support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">为了使实施能够充分利用增强的SNMPv2错误代码,在发生错误时,仪器功能必须始终返回SNMPv2错误代码。如有必要,这些错误代码将由代理翻译成相应的SNMPv1错误代码。</target>
        </trans-unit>
        <trans-unit id="91f9f99c50f34dfe6347f220890a64d23f9ce151" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">为了使Erlang驱动程序线程API起作用，必须在运行时系统中启用线程支持。 Erlang驱动程序可以使用 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 检查是否启用了线程支持。请注意，只有在运行时系统具有SMP支持时，Erlang驱动程序API中的某些函数才是线程安全的，并且可以通过 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 检索此信息。还要注意，无论是否启用了SMP支持，Erlang驱动程序API中的许多功能&lt;strong&gt;都不是&lt;/strong&gt;线程安全的。如果某个函数未记录为线程安全的，则它&lt;strong&gt;不是&lt;/strong&gt;线程安全的。</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">为了使中断/继续功能起作用， &lt;code&gt;Common Test&lt;/code&gt; 必须释放控制 &lt;code&gt;stdin&lt;/code&gt; 的外壳程序。这是通过将启动选项 &lt;code&gt;release_shell&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来完成的。有关详细信息，请参阅《用户指南》中的 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e5ab42b46c29034052cc72be40b7ac14c2d1e1e" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt; +sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">为了使运行时系统能够绑定调度程序，必须知道CPU拓扑。如果运行系统无法自动检测到CPU拓扑，则可以对其进行定义。有关如何定义CPU拓扑的更多信息，请参见命令行标志 &lt;code&gt;+sct&lt;/code&gt; 在 &lt;code&gt;erl(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">为了使其正常工作,用户必须确保满足以下两个要求。</target>
        </trans-unit>
        <trans-unit id="7316234f8d0404e7bccb8d56aec4837d25e8e904" translate="yes" xml:space="preserve">
          <source>In order to allow minimizing the performance loss, the &lt;code&gt;file_check&lt;/code&gt; parameter can be set to a positive integer value, &lt;code&gt;N&lt;/code&gt;. The handler will then skip reading the file information prior to writing, as long as no more than &lt;code&gt;N&lt;/code&gt; milliseconds have passed since it was last read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">为了将这些数据追加到 motorcycles.xml 文档的结尾,你必须对文件进行解析,并将 Data 添加到根元素内容的结尾。</target>
        </trans-unit>
        <trans-unit id="1cc2af703c741622a9752f6130d1aed382c381ac" translate="yes" xml:space="preserve">
          <source>In order to avoid these situations we wanted to be able to do most of the fundamental operations on a process without having to acquire a lock on the process. Some examples of such fundamental operations are, moving a process between run queues, detecting if we need to insert it into a run queue or not, detecting if it is alive or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606b78a849c5b14fbde9a528c5423519c626033" translate="yes" xml:space="preserve">
          <source>In order to be able to decide which run queue to use without having to lock any run queues, we moved all fixed balancing information out of the run queues into a global memory block. That is, migration paths and run queue limits. Information that need to be frequently updated, like for example maximum run queue length, were kept in the run queue, but instead of operating on this information under locks we now use atomic memory operations when accessing this information. This made it possible to first determine which run queue to use, without locking any run queues, and when decided, lock the chosen run queue and insert the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9a3c32af1c0aebd8c724db9f1fd7c9cd27f7" translate="yes" xml:space="preserve">
          <source>In order to be able to detect when it is safe to deallocate a previously used process structure, reference counting of the structure was used. Also this was problematic, since simultaneous lookups needed to modify the reference counter which also caused contention on the cache line where the reference counter was located. This since all modifications needs to be communicated between all involved processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b6946fb3d78aedfd7eb1945dab3d08fcb73b1" translate="yes" xml:space="preserve">
          <source>In order to be able to determine when all managed threads have reached the states that we are interested in we need to communicate between all involved threads. We of course want to minimize this communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21c20f0ab3dedd86e0307763e8d967cc669941c" translate="yes" xml:space="preserve">
          <source>In order to be able to remove a carrier from one allocator instance and add it to another we need to be able to move references to the free blocks of the carrier between the allocator instances. The allocator instance specific data structure referring to the free blocks it manages often refers to the same carrier from multiple places. For example, when the address order best-fit strategy is used this data structure is a binary search tree spanning all carriers that the allocator instance manages. Free blocks in one specific carrier can be referred to from potentially every other carrier that is managed, and the amount of such references can be huge. That is, the work of removing the free blocks of such a carrier from the search tree will be huge. One way of solving this could be not to migrate carriers that contain lots of free blocks, but this would prevent us from migrating carriers that potentially need to be migrated in order to solve the problem we set out to solve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">为了编译Erlang代码，必须构建一个小的Erlang引导系统，或者必须在 &lt;code&gt;$PATH&lt;/code&gt; 提供与正在构建的版本相同版本的Erlang / OTP系统。将使用此Erlang系统以及提供的交叉编译工具来构建目标系统的Erlang / OTP。</target>
        </trans-unit>
        <trans-unit id="33c36db64d09c1349048183a11365e092986cc43" translate="yes" xml:space="preserve">
          <source>In order to determine when the events has happened we use a global counter that is incremented when all managed threads have called &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (or &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt;). This could naively be implemented using a &quot;thread confirmed&quot; counter. This would however cause an explosion of communication where all involved processors would need to communicate with each other at each update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8bd01b2e2143b89a5d070a42db3498a1a3a7f5" translate="yes" xml:space="preserve">
          <source>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbb01425e78fa9829f765ceacdcbc84ac1251f2" translate="yes" xml:space="preserve">
          <source>In order to fit better into your existing logging infrastructure Logger can format its logging messages any way you want to. Either you can use the built-in formatter, or you can build your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">为了充分理解内部形式,你必须掌握Megaco/H.248协议的ASN.1规范,并应用上述规则。请参阅Erlang/OTP中ASN.1编译器的文档,以了解ASN.1和相应内部形式之间的语义映射的更多细节。</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">为了进一步简化跟踪，可以使用 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 函数。当您的应用程序中需要突出显示有趣的 &lt;code&gt;Events&lt;/code&gt; 时，可以从其他应用程序调用这些功能。这些函数非常轻巧，因为它们除了返回原子之外什么也不做。这些功能是专门为跟踪而设计的。由于调用方显式提供了&amp;ldquo; &lt;code&gt;Event Record&lt;/code&gt; 字段的值，因此默认的 &lt;code&gt;Collector Filter&lt;/code&gt; 能够自动提供自定义的&amp;ldquo; &lt;code&gt;Event Record&lt;/code&gt; 而无需任何用户定义的过滤器功能。</target>
        </trans-unit>
        <trans-unit id="d72fdffcde207532623f4383c3bcc9252d8eb8ee" translate="yes" xml:space="preserve">
          <source>In order to implement delay of thread progress from unmanaged threads we use two reference counters. One being &lt;code&gt;current&lt;/code&gt; and one being &lt;code&gt;waiting&lt;/code&gt;. When an unmanaged thread wants to delay thread progress it increments &lt;code&gt;current&lt;/code&gt; and gets a handle back to the reference counter it incremented. When it later wants to enable continuation of thread progress it uses the handle to decrement the reference counter it previously incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fc72bd9eea1c19e5c0da63c18725fd1977b35e" translate="yes" xml:space="preserve">
          <source>In order to improve this, state information was re-organized in the port structer, so that we can access it using atomic memory operations. This together with the new port table implementation, enabled us to lookup the port and inspect the state before acquiring the port lock, which in turn made it possible to perform preparations of signal data before acquiring the port lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">为了使Xref易于使用,有一些预定义的分析来执行一些常见的任务。通常,一个模块或一个版本可以被检查是否有对未定义函数的调用。对于更高级的用户来说,有一种小型但相当灵活的语言,可以用来选择被分析系统的部分,并对选定的调用进行一些简单的图表分析。</target>
        </trans-unit>
        <trans-unit id="aea5444714eb91d126874c6a93a730087a09d9a5" translate="yes" xml:space="preserve">
          <source>In order to migrate carriers between allocator instances we move them through a pool of carriers. In order for a carrier migration to complete, one scheduler needs to move the carrier into the pool, and another scheduler needs to take the carrier out of the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">为了准备好MG发送初始消息(希望是服务变更请求),需要完成以下工作。</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">为了让MGC准备好接收最初的信息,希望是服务变更请求,需要完成以下工作。</target>
        </trans-unit>
        <trans-unit id="45fb88d2abad8087318cf9186878fe028a795bdf" translate="yes" xml:space="preserve">
          <source>In order to prevent multiple schedulers from trying to execute signals to/from the same port simultaneously, we need to be able to ensure that all signals to/from a port are executed in sequence on one scheduler. More or less, the only way to do this is to schedule all types of signals. Signals corresponding to a port can then be executed in sequence by one single scheduler thread. If only one thread tries to execute the port, no contention will appear on the port lock. Besides getting rid of the contention, processes sending signals to the port can also continue execution of their own Erlang code on other schedulers at the same time as the signaling code is executing on another scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403d69677374c07e6c15d9b1403b168e3385a4f8" translate="yes" xml:space="preserve">
          <source>In order to prevent scenarios like this we've implemented support for migration of multi-block carriers between allocator instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">为了提供MG和MGC的可扩展实现的解决方案,一个用户可以分布在几个Erlang节点上。其中一个Erlang节点连接到物理网络接口上,但消息可以从其他节点发送,并且回复会自动转发回发起节点。</target>
        </trans-unit>
        <trans-unit id="9b7d500551c4dcb114f3424b88510f43e715d2cf" translate="yes" xml:space="preserve">
          <source>In order to reduce contention due to locking of allocator instances we introduced completely lock free instances tied to each scheduler thread, and an extra locked instance for other threads. The scheduler threads in the system is expected to do the major part of the work. Other threads may still be needed but should not perform any major and/or time critical work. The limited amount of contention that appears on the locked allocator instance can more or less be disregarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f092b8785b0c724e3673cc03096bbd3fea047bff" translate="yes" xml:space="preserve">
          <source>In order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance to keep the client_random and various handshake secrets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">为了看到的细节问题细节 &lt;code&gt;Event&lt;/code&gt; ，你可以点击 &lt;code&gt;Event&lt;/code&gt; ，以启动 &lt;code&gt;Contents Viewer&lt;/code&gt; 为 &lt;code&gt;Event&lt;/code&gt; 。在 &lt;code&gt;Contents Viewer&lt;/code&gt; 中，还有一个过滤器菜单，该菜单允许从查看器中未选择的其他视图检查 &lt;code&gt;Event&lt;/code&gt; 。单击 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; 将导致一个 &lt;code&gt;Contents Viewer&lt;/code&gt; 窗口弹出，在 &lt;code&gt;mgr_actors&lt;/code&gt; 视图中显示该 &lt;code&gt;Event&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dbccfc8cfa22ee2e381053c5b4b92eaa192ba4f4" translate="yes" xml:space="preserve">
          <source>In order to set a different socket path the &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; option can be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ff9cab23ed1e1a7df0e6479aae0e38297e97c3" translate="yes" xml:space="preserve">
          <source>In order to solve this, we introduced a new busy feature, namely &quot;busy port queue&quot;. The port has a limit of &lt;code&gt;command&lt;/code&gt; data that is allowed to be enqueued in the task queue. When this limit is reached, the port will automatically enter a busy port queue state. When in this state, senders of &lt;code&gt;command&lt;/code&gt; signals will be suspended, but &lt;code&gt;command&lt;/code&gt; signals will still be delivered to the port unless it is also in a busy port state. This limit is known as the high limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e67fa06e1bd38aa13f81fc5e8041b9e05f7af4" translate="yes" xml:space="preserve">
          <source>In order to test modifications of the process table we ran a couple of benchmarks where lots of processes are spawned and terminated simultaneously, and got a speedup of between 150-200%. Running a similar benchmark but with ports we got a speedup of about 130%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">为了使用标签系统，必须创建一个名为 &lt;code&gt;TAGS&lt;/code&gt; 的文件。该文件可以看作是项目中所有文件中所有功能，记录和宏的数据库。该 &lt;code&gt;TAGS&lt;/code&gt; 文件可以使用Erlang的两种不同的方法来创建。第一个是标准的Emacs实用程序&amp;ldquo; etags&amp;rdquo;，第二个是通过使用Erlang模块 &lt;code&gt;tags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">在我们的测量中,我们看到ASN.1误码率和紧凑文本格式之间的消息大小没有显著差异。当使用漂亮的文本样式时,应该采取一些谨慎的态度(在协议规范中包含的所有例子中都使用了这种样式,并且在调试环节中更喜欢使用这种样式),因为这样的话,消息就会相当大。如果消息的大小真的是一个严重的问题,应该使用我们的per编码器,因为ASN.1 PER格式比所有其他的选择更加紧凑。它的主要缺点是它还没有被批准为有效的Megaco/H.248信息编码。</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">在实践中,对象集通常被声明为可扩展的,以便以后可以向对象集添加更多的对象。可扩展性表示如下:</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">在 &lt;code&gt;file&lt;/code&gt; 的早期版本中，将模式指定为 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;read_write&lt;/code&gt; 原子之一，而不是列表。出于向后兼容的原因，仍然允许这样做，但不得用于新代码。另请注意，模式列表中不允许 &lt;code&gt;read_write&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">原则上，此函数通过 &lt;code&gt;spawn&lt;/code&gt; 调用 &lt;code&gt;process_received_message/4&lt;/code&gt; 函数以执行实际处理。</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">在支持客户端启动的重新协商的协议中，服务器的这种操作的资源成本比客户端高。这可以充当拒绝服务攻击的媒介。SSL应用程序已采取措施来抵消此类尝试，但是可以通过将此选项设置为 &lt;code&gt;false&lt;/code&gt; 来严格禁用客户端启动的重新协商。默认值为 &lt;code&gt;true&lt;/code&gt; 。请注意，由于底层密码套件可以加密的消息数量受到限制，因此禁用重新协商可能会导致长期连接无法使用。</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">在极少数情况下,这个函数在Unix上可能会失败,如果当前目录的父目录不存在读取权限,就会出现这种情况。如果当前目录的父目录不存在读取权限,就会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">实际上，数据模型很少完全标准化。规范化数据库模型的现实替代方案是甚至不采用第一范式的数据模型。 &lt;code&gt;Mnesia&lt;/code&gt; 适用于电信等应用，因为它易于以灵活的方式组织数据。一个 &lt;code&gt;Mnesia&lt;/code&gt; 的数据库总是被组织为一组表。每个表都充满行，对象和记录。什么套 &lt;code&gt;Mnesia&lt;/code&gt; 的与众不同的是，在一个记录中的各个字段可以包含任何类型的化合物的数据结构。记录中的单个字段可以包含列表，元组，函数，甚至记录代码。</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">在方案1中，在 &lt;code&gt;case A&lt;/code&gt; 完成执行其测试代码而未检测到任何错误之后，测试案例过程通常终止。测试用例函数返回一个值， &lt;code&gt;Common Test&lt;/code&gt; 将测试用例记录为成功。</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">在方案2中，在测试用例 &lt;code&gt;case B&lt;/code&gt; 执行期间检测到错误。这导致测试用例 &lt;code&gt;case B&lt;/code&gt; 函数生成异常，结果，测试用例进程由于非正常原因退出。 &lt;code&gt;Common Test&lt;/code&gt; 将此记录为失败（失败）的测试用例。</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在有关神话的章节中，揭示了以下神话： &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">简而言之， &lt;code&gt;DebugType&lt;/code&gt; 仅用于调试。使用标准的Erlang测井工具可以更好地生产生产过程中的原木。</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">在某些应用程序中，忽略来自单个日志的答复可能是不可接受的。在这种情况下，一种替代方法是使用许多本地磁盘日志而不是一个分布式磁盘日志，并在不使用 &lt;code&gt;disk_log&lt;/code&gt; 模块的情况下实现分发。</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">在某些方面,Erlang MIB编译器没有完全遵循或实现SMI。以下是两者的区别。</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">在某些方面,代理没有完全实现SNMP。以下是两者的区别。</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">在某些情况下,Erlang的语法规则使得你无法直接将元变量放在你想要的地方。例如,你不能写。</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">在某些情况下，选择/匹配操作不需要扫描整个表。例如，如果在搜索 &lt;code&gt;ordered_set&lt;/code&gt; 表时绑定了键的一部分，或者该键是Mnesia表，并且选择/匹配的字段上存在辅助索引。如果键是完全绑定的，则没有必要进行选择/匹配，除非您有一个包表并且只对具有特定键的元素子集感兴趣。</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">在某些情况下，仅允许使用字符串或整数。例如，指令 &lt;code&gt;-file(Name, Line)&lt;/code&gt; 要求 &lt;code&gt;Name&lt;/code&gt; 是字符串文字，而 &lt;code&gt;Line&lt;/code&gt; 是整数文字：</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;locked&lt;/code&gt; 状态下，当按下按钮时，将使用最后按下的按钮收集该按钮，直到达到正确代码的长度，然后与正确代码进行比较。根据结果​​，门要么被解锁， &lt;code&gt;gen_statem&lt;/code&gt; 进入 &lt;code&gt;open&lt;/code&gt; 状态，要么门保持在 &lt;code&gt;locked&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">在状态 &lt;code&gt;open&lt;/code&gt; 中，按钮事件通过保持相同状态而被忽略。这也可以通过返回 &lt;code&gt;{keep_state, Data}&lt;/code&gt; 来完成，或者在这种情况下，因为 &lt;code&gt;Data&lt;/code&gt; 甚至可以通过返回 &lt;code&gt;keep_state_and_data&lt;/code&gt; 来保持不变。</target>
        </trans-unit>
        <trans-unit id="96ad0dfc8fa4580e2165853ef7429bd0d01832d6" translate="yes" xml:space="preserve">
          <source>In systems which create and delete &lt;strong&gt;many&lt;/strong&gt; sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">在具有多个进程的系统中，可以将运行时间短的计算任务派生到具有更高最小堆大小的新进程中。该过程完成后，它将计算结果发送到另一个过程并终止。如果正确计算了最小堆大小，则该过程可能根本不必进行任何垃圾收集。&lt;strong&gt;如果没有适当的测量，请勿尝试这种优化。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">在电信应用中,有不同于传统DBMS所提供的功能的需求。现在用Erlang实现的应用需要混合广泛的功能,而这些功能一般是传统DBMS无法满足的。Mnesia在设计时就考虑到了以下这样的需求。</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">在Erlang的32位实现中，536,870,911字节是可以使用位语法构造或匹配的最大二进制文件。在64位实现中，最大大小为2,305,843,009,213,693,951字节。如果超出了限制，则位语法构造会失败，并带有 &lt;code&gt;system_limit&lt;/code&gt; 异常，而任何尝试匹配太大的二进制文件的尝试都会失败。此限制从R11B-4开始实施。</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">在 &lt;code&gt;MatchBody&lt;/code&gt; 和 &lt;code&gt;MatchCondition&lt;/code&gt; 部分中，只能使用先前绑定的变量。</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">在 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 部分中，不允许使用未绑定的变量，因此 &lt;code&gt;'_'&lt;/code&gt; 被解释为本身（一个原子）。变量只能在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中绑定。</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">在 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 部分中，解释在某些方面有所不同。这些部分中的文字可以&amp;ldquo;按原样&amp;rdquo;编写，适用于除元组以外的所有文字，也可以使用特殊形式 &lt;code&gt;{const, T}&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是任何Erlang术语。</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中，所有文字（上面的变量除外）都按&amp;ldquo;原样&amp;rdquo;解释。</target>
        </trans-unit>
        <trans-unit id="62822ca5758004378978f550b70109b8f746b1ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;compiler&lt;/code&gt; application, in the file &lt;code&gt;genop.tab&lt;/code&gt;, there is the following line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;do_perm&lt;/code&gt; 中,我们对在 &lt;code&gt;output&lt;/code&gt; 中分配的结构进行操作。</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">在上面的 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 示例中，需要在源代码中包含 &lt;code&gt;ms_transform.hrl&lt;/code&gt; ，因为这会触发 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 调用对有效匹配规范的解析转换。这也意味着转换是在编译时完成的（从shell调用时除外），因此在运行时不占用任何资源。也就是说，尽管您使用了更直观的fun语法，但是它在运行时的效率与手工编写匹配规范一样有效。</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">在 &lt;code&gt;main&lt;/code&gt; 函数中，C程序将侦听来自Erlang的消息，并根据所选的编码/解码方案，使用第一个字节确定要调用的函数，并使用第二个字节作为该函数的参数。然后，调用该函数的结果将发送回Erlang：</target>
        </trans-unit>
        <trans-unit id="a69877ecee07d6d60ef5a7f12b95eb172cfc8ddd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;option&lt;/code&gt; info tuple are only the options included that differs from the default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">在 &lt;code&gt;ready_async&lt;/code&gt; 函数中，输出被发送回仿真器。我们使用驱动器术语格式而不是 &lt;code&gt;ei&lt;/code&gt; 。这是直接将Erlang术语直接发送到驱动程序，而无需使用Erlang代码来调用 &lt;code&gt;binary_to_term/1&lt;/code&gt; 的唯一方法。在简单的示例中，这很好用，我们不需要使用 &lt;code&gt;ei&lt;/code&gt; 来处理二进制术语格式。</target>
        </trans-unit>
        <trans-unit id="262d5d76fc96e92282d6cd6556cb095d00a57bcd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ssh.app&lt;/code&gt; file, in the &lt;code&gt;env&lt;/code&gt; part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">在Megaco的API中,用户可以明确地发送动作请求,但交易标识符的生成、编码和消息到远程用户的实际传输是由协议引擎根据实际连接配置自动处理的。Megaco的消息在API中并不暴露。</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">在Erlang运行时系统中，只有在有多个调度程序时，实体才并行运行。因此，在许多内核上使用许多调度程序的系统上， &lt;code&gt;lcnt&lt;/code&gt; 将显示更多争用点（因此会更有用）。</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">在内核应用中。</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">在Mnesia表中,两个键列以两个元素的元组形式存储。因此,该表的arity为3。</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">在4.4BSD Unix中包含的POSIX.2兼容库中，丑陋的语法[[：&amp;lt;：]]和[[：&amp;gt;：]]用于匹配&amp;ldquo;单词开头&amp;rdquo;和&amp;ldquo;单词结尾&amp;rdquo;。PCRE将这些项目处理如下：</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">在PRF(伪随机函数)中,在不使用PFS的密码套件中生成密钥材料。</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">在SSL应用程序中，可以使用一个额外的分发模块 &lt;code&gt;inet_tls_dist&lt;/code&gt; 作为替代。所有分发连接将使用TLS，并且分布式系统中的所有参与的Erlang节点必须使用此分发模块。</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">在STDLIB应用程序中。</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">在上面的示例中，首先创建了&amp;ldquo; pong&amp;rdquo;，以便在启动&amp;ldquo; ping&amp;rdquo;时能够给出&amp;ldquo; pong&amp;rdquo;的标识。也就是说，以某种方式&amp;ldquo; ping&amp;rdquo;必须能够知道&amp;ldquo; pong&amp;rdquo;的身份才能向其发送消息。有时需要彼此了解身份的过程是彼此独立地启动的。因此，Erlang提供了一种为进程指定名称的机制，以便这些名称可以用作标识而不是pid。这可以通过使用 &lt;code&gt;register&lt;/code&gt; BIF 来完成：</target>
        </trans-unit>
        <trans-unit id="e32e6dd34c52e0e8f5c4ffcf8e60b4a055b8ae5e" translate="yes" xml:space="preserve">
          <source>In the above example, the small binary &lt;code&gt;B&lt;/code&gt; was copied while the larger binary &lt;code&gt;C&lt;/code&gt; references binary &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd30adfebd9b33e07add4e9cc9b71db937dd48cf" translate="yes" xml:space="preserve">
          <source>In the absence of spawn operation failures, atomically sets up a monitor to the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. The &lt;code&gt;ReqId&lt;/code&gt; returned by &lt;code&gt;spawn_request()&lt;/code&gt; is also used as monitor reference as if it was returned from &lt;code&gt;monitor(process, Pid)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">在基本方案中,每个用户在开始使用驱动之前都会加载驱动,完成后再卸载驱动。参考计数会跟踪进程和每个进程的加载次数。这样驱动只有在没人要的时候才会被卸载(它没有用户)。驱动程序还跟踪对它开放的端口。这样就可以延迟卸载,直到所有端口都关闭,或者在卸载时杀死所有使用该驱动的端口。</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">在上面的例子中,该文件与Messenger例子中的所有其他文件一样,都是从同一个目录中获取的。(*manual*)。</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">在升级的情况下， &lt;code&gt;OldVsn&lt;/code&gt; 为 &lt;code&gt;Vsn&lt;/code&gt; ，在降级的情况下， &lt;code&gt;OldVsn&lt;/code&gt; 为 &lt;code&gt;{down,Vsn}&lt;/code&gt; 。 &lt;code&gt;Vsn&lt;/code&gt; 由旧版本的回调模块 &lt;code&gt;Module&lt;/code&gt; 的 &lt;code&gt;vsn&lt;/code&gt; 属性定义。如果未定义此类属性，则版本为BEAM文件的校验和。</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于回复，megaco将取消回复，并且其信息将通过调用回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 返回给用户。</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于请求，megaco将以与调用 &lt;code&gt;megaco:cancel&lt;/code&gt; 相同的方式取消消息（成功发送之后）。信息将根据发出请求的方式不同地传播回用户：对于使用 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 发出的请求，信息将以返回值的形式传递。对于使用 &lt;code&gt;megaco:cast&lt;/code&gt; 发出的请求，信息将通过调用回调函数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Destination&lt;/code&gt; 为 &lt;code&gt;File&lt;/code&gt; ，则可打印的megaco跟踪事件将使用普通 &lt;code&gt;io:format/2&lt;/code&gt; 打印到文件 &lt;code&gt;File&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Destination&lt;/code&gt; 为 &lt;code&gt;io&lt;/code&gt; 的情况下，可打印的megaco跟踪事件将使用普通 &lt;code&gt;io:format/2&lt;/code&gt; 打印在stdout上。</target>
        </trans-unit>
        <trans-unit id="8b3e58c5c2505dec49b18b9e8525ca602801333f" translate="yes" xml:space="preserve">
          <source>In the case when its not possible to immediately establish a connection, the function will return with the &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;, a subsequent call to connect will then establish the connection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">如果pdu类型为 &lt;code&gt;report&lt;/code&gt; ，则 &lt;code&gt;MsgData&lt;/code&gt; 可以为 &lt;code&gt;ok&lt;/code&gt; 或 &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c6fc4cd12daba8d11cdd4982445015e66db822" translate="yes" xml:space="preserve">
          <source>In the case when there is no connections waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when a client connects (a subsequent call to accept will then return the socket).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b308070b86e9f2f5cfb71e46c5c56ad9f43c5a" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recv will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c310b42286356d0fc14eede396b80bde97e8a3eb" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvfrom will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a9e35d675f34065de5084906faf62c1cb4d28b" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvmsg will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79128b360c469ba004c95bafdca01e1b34773296" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to send will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a00bf019c9ad7cc3ae0aa6563d03144ab91886" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendmsg will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67338ab252943970a15e1afbfd3aa9bc7bd17164" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendto will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">在本节开头的代码片段中，追加到 &lt;code&gt;Bin&lt;/code&gt; 将很便宜，而追加到 &lt;code&gt;Bin0&lt;/code&gt; 将强制创建新的二进制文件并复制 &lt;code&gt;Bin0&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="245dbc6eca2c173af60f0ff749e12a7fd20aabc1" translate="yes" xml:space="preserve">
          <source>In the configuration above we first raise the primary log level to max in order for the debug log events to get to the handlers. Then we configure the default handler to only log notice and below events, the default log level for a handler is &lt;code&gt;all&lt;/code&gt;. Then the debug handler is configured with a filter to stop any log message that is not a debug level message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">在封面规范文件中，您还可以指定所需的代码覆盖率分析级别；例如， &lt;code&gt;details&lt;/code&gt; 或 &lt;code&gt;overview&lt;/code&gt; 。在详细模式下，您会获得一个覆盖率概述页面，其中显示了每个模块和总覆盖率百分比。您还将为分析中包括的每个模块打印一个HTML文件，确切显示测试过程中已执行了哪些代码部分。在概述模式下，仅打印代码覆盖率概述页面。</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">在当前的 &lt;code&gt;Common Test&lt;/code&gt; 版本中， &lt;code&gt;silent_connections&lt;/code&gt; 功能仅适用于Telnet和SSH连接。将来的 &lt;code&gt;Common Test&lt;/code&gt; 版本中可以添加对其他连接类型的支持。</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Erlang / SCTP绑定的当前实现中，此事件在内部转换为 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;error&lt;/code&gt; 项。</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">在当前的实现中,每一次对象插入和查找操作都会产生一个对象的副本。</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">在当前版本的 &lt;code&gt;CurVsn&lt;/code&gt; 中， &lt;code&gt;myapp&lt;/code&gt; 的应用程序目录为 &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; 。一个新版本的 &lt;code&gt;NewVsn&lt;/code&gt; 在发布处理程序外部被解压缩，并通过如下调用通知发布处理程序：</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">在数据目录 &lt;code&gt;data_dir&lt;/code&gt; 中，测试模块具有自己的测试所需的文件。名称 &lt;code&gt;data_dir&lt;/code&gt; 是测试套件之后的名称 &lt;code&gt;&quot;_data&quot;&lt;/code&gt; 。例如， &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; 具有数据目录 &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; 。使用此目录可移植，即避免对套件中的目录名进行硬编码。由于数据目录与测试套件存储在同一目录中，因此即使测试套件目录的路径在测试套件实现和执行之间发生了变化，也可以在运行时依靠它的存在。</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">在后面的说明中,列出了用于更改默认值的形式。</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">在节点的详细信息窗口中，将显示原始节点和连接的节点上的进程之间的所有现有链接和监视器。&lt;strong&gt;Extra Info&lt;/strong&gt;可以包含调试信息（即，如果仿真器是调试编译的，则包含特殊信息）或错误信息。</target>
        </trans-unit>
        <trans-unit id="8ba5880443f43a3af428d4fbb8404826ac0d26fd" translate="yes" xml:space="preserve">
          <source>In the end, the C compiler will probably optimize this code to the same native code as the first version, but the first version is certainly much easier to read for human readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e4ef55ecc440a106bcf9a15acab47c72a79a18" translate="yes" xml:space="preserve">
          <source>In the erl command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe10364408e4f6b1e20c24b12efb18fb322cbcc9" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period are to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">在事件管理器中，安装了零个，一个或多个&lt;strong&gt;事件处理&lt;/strong&gt;程序。当事件管理器收到事件通知时，所有已安装的事件处理程序都会处理该事件。例如，默认情况下，用于处理错误的事件管理器可以安装处理程序，该处理程序将错误消息写入终端。如果一定时间内的错误消息也要保存到文件中，则用户将添加另一个执行此操作的事件处理程序。当不再需要记录到文件时，将删除此事件处理程序。</target>
        </trans-unit>
        <trans-unit id="8841b315d1e28c3d331ee376f7a7d69baa5c6c9d" translate="yes" xml:space="preserve">
          <source>In the example above the &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; directive is used get function &lt;code&gt;init&lt;/code&gt; called automatically when the module is loaded. Function &lt;code&gt;init&lt;/code&gt; in turn calls &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; which loads the NIF library and replaces the &lt;code&gt;hello&lt;/code&gt; function with its native implementation in C. Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">在上面的示例中，有效 &lt;code&gt;keys&lt;/code&gt; 可以是 &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; 和 &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; ，而 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; ， &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; 和 &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; 将无效。</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">在下面的例子中,第2,4,6,8和11行是可执行行。</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">在上一节的示例中，通过调用 &lt;code&gt;ch3:start_link()&lt;/code&gt; 来启动 &lt;code&gt;gen_server&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">在上一节的示例中， &lt;code&gt;gen_statem&lt;/code&gt; 通过调用 &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; 来启动：</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">在示例中，显示的ID为 &lt;code&gt;example.com&lt;/code&gt; 以及与 &lt;code&gt;*.example.com&lt;/code&gt; 匹配的主机名。例如 &lt;code&gt;foo.example.com&lt;/code&gt; 和 &lt;code&gt;bar.example.com&lt;/code&gt; 都匹配，但不匹配 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 。名称 &lt;code&gt;erlang.org&lt;/code&gt; 不匹配，因为它不是CN。</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">在示例中，为每个传入和传出消息调用 &lt;code&gt;handle_debug&lt;/code&gt; 。格式函数 &lt;code&gt;Func&lt;/code&gt; 是函数 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; ，它使用 &lt;code&gt;io:format/3&lt;/code&gt; 打印消息。</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在该示例中，选择了 &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; 中的第一个编码元素的组件 &lt;code&gt;number&lt;/code&gt; 。这适用于&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 部分中的ASN.1规范。</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">在该示例中，运算符 &lt;code&gt;==/2&lt;/code&gt; 的处理方式与 &lt;code&gt;=:=/2&lt;/code&gt; 的处理方式完全相同。但是，如果无法在编译时确定某个常量没有整数，并且在比较键是否相等时该表使用 &lt;code&gt;=:=/2&lt;/code&gt; （请参阅选项 &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;qlc&lt;/code&gt; 模块不会尝试查找该常量。 。原因是在通常情况下，可以比较的常量的键值数量没有上限。必须查询整数和浮点数的每种组合：</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">在该示例中，使用了同步启动。该过程通过调用 &lt;code&gt;ch4:start_link()&lt;/code&gt; 开始：</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">在此示例中，纯节点名称为 &lt;code&gt;c1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">在这个例子中:</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">在示例中，您可以看到默认的Erlang Shell仅将ISO Latin1范围内的字符解释为可打印，并且仅检测具有这些&amp;ldquo;可打印&amp;rdquo;字符的列表或二进制文件包含字符串数据。包含俄语单词&amp;ldquo;Юникод&amp;rdquo;的有效UTF-8二进制文件未打印为字符串。当使用所有可打印的Unicode字符（ &lt;code&gt;+pc unicode&lt;/code&gt; ）启动时，shell将包含可打印的Unicode数据（二进制，UTF-8或字节编码）的任何内容输出为字符串数据。</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">在提供非匿名PFS(完美前向保密)的密码套件中DH参数的交换中。</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">在函数调用的第一种形式 &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; 中， &lt;code&gt;ExprM&lt;/code&gt; 和 &lt;code&gt;ExprF&lt;/code&gt; 中的每一个都必须是原子或计算结果为原子的表达式。据说该函数是通过使用&lt;strong&gt;完全限定的函数名&lt;/strong&gt;来调用的。这通常称为&lt;strong&gt;远程&lt;/strong&gt;或&lt;strong&gt;外部函数调用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d99757df807bd06e120fa43c0767f20375e1c3" translate="yes" xml:space="preserve">
          <source>In the first section (&lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt;), actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that &lt;strong&gt;callback module&lt;/strong&gt;&lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">在第一部分中， &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; 动作是一般状态机模型的一部分。这些常规操作由回调模块 &lt;code&gt;gen_statem&lt;/code&gt; 在返回 &lt;code&gt;gen_statem&lt;/code&gt; 引擎之前在事件处理回调函数中执行的代码实现。</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">在 &lt;code&gt;ID&lt;/code&gt; 的第一个字（4个字节）中，只有18位有效，其余为0。在 &lt;code&gt;Creation&lt;/code&gt; 中，只有两位有效，其余为0。</target>
        </trans-unit>
        <trans-unit id="5e047fa558c6b3687797900dae4cc1f9d07908ea" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">在下面的描述中使用的词&lt;strong&gt;点&lt;/strong&gt;手段：&amp;ldquo;点可以被看作是所述光标的位置更精确地，该点两个字符之间的位置，而光标绘制在以下点处的字符。&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">在以下描述中，&lt;strong&gt;组节点&lt;/strong&gt;是与本地节点属于同一全局组的节点。</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">在以下描述中，如果未启动 &lt;code&gt;heart&lt;/code&gt; ，则所有功能都会失败，原因为 &lt;code&gt;badarg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">在以下示例中，已插入QLC &lt;code&gt;V2&lt;/code&gt; 以显示联接的生成器和选择的联接方法。查找联接使用约定：第一个生成器（ &lt;code&gt;G2&lt;/code&gt; ）被遍历，第二个生成器（ &lt;code&gt;G1&lt;/code&gt; ）是在其中查找常量的表。</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">在下面的示例中，对 &lt;code&gt;A&lt;/code&gt; 的每个值遍历合并联接的缓存结果。请注意，如果没有选项 &lt;code&gt;cache&lt;/code&gt; 则联接将执行3次，对于每个 &lt;code&gt;A&lt;/code&gt; 值一次。</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">在下面的例子中,创建了两个进程,它们互相发送了多次消息。</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">在以下示例中，仅插入两个简单的QLC来保存选项 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">在下面使用这个程序的例子中,节点是在四台不同的计算机上启动的。如果你的网络上没有那么多机器可用,你可以在同一台机器上启动几个节点。</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">在以下示例中， &lt;code&gt;Common Test&lt;/code&gt; 查找并执行了两个测试，一个测试从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 到 &lt;code&gt;sub21&lt;/code&gt; 的路径，另一个从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 到 &lt;code&gt;sub22&lt;/code&gt; 的路径：</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">在以下示例中， &lt;code&gt;{Pid, hello_world}&lt;/code&gt; 被发送到已注册的进程 &lt;code&gt;my_server&lt;/code&gt; 。该消息由 &lt;code&gt;erl_send()&lt;/code&gt; 编码：</target>
        </trans-unit>
        <trans-unit id="0b55abcde93dfcf59993923892aaa3fe74b62110" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">在以下示例中，通过指定唯一路径 &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; ，仅执行一个测试。从 &lt;code&gt;top2&lt;/code&gt; 到 &lt;code&gt;sub2X2&lt;/code&gt; 的第二条可能路径（来自前面的示例）被丢弃：</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">在以下示例中，函数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 用作顺序跟踪的触发器：</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">在下面的例子中,第2、4、6、8、11行是可执行行。</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">在以下示例中，使用模块 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">在下面的示例中，BIF &lt;code&gt;self()&lt;/code&gt; 返回调用过程的pid：</target>
        </trans-unit>
        <trans-unit id="5409dc0e8a019858263b90292ca1f90716b01a8e" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies as Erlang messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">在下面的例子中,Erlang shell是接收通道回复的客户端进程。</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">在下面的例子中,使用了这个ASN.1规范。</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">在以下示例中，安装了两个 &lt;code&gt;my_SUITE&lt;/code&gt; 测试事件处理程序：</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">在下面的示例中，使用 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 部分中的 &lt;code&gt;gb_table&lt;/code&gt; 模块，有六个要查找的键： &lt;code&gt;{1,a}&lt;/code&gt; ， &lt;code&gt;{1,b}&lt;/code&gt; ， &lt;code&gt;{1,c}&lt;/code&gt; ， &lt;code&gt;{2,a}&lt;/code&gt; ， &lt;code&gt;{2,b}&lt;/code&gt; 和 &lt;code&gt;{2,c}&lt;/code&gt; 。原因是键 &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; 的两个元素被分别比较。</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">在下面的例子中,我们使用XML文件 &quot;motorcycles.xml &quot;和相应的DTD &quot;motorcycles.dtd&quot;。motorcycles.xml的样子。</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">在下图中， &lt;code&gt;selected_decode_Window2&lt;/code&gt; 仅解码标记的元素：</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">下图中,方格代表主管,圆圈代表工人。</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">在下面的列表中，初始化标志被标记为&amp;ldquo;（初始化标志）&amp;rdquo;。除非另有说明，否则所有其他标志都是用户标志，可以通过调用 &lt;code&gt;init:get_argument/1&lt;/code&gt; 来获取其值。请注意，用户标志的列表并不详尽，可以有更多特定于应用程序的标志，而不是在相应的应用程序文档中进行描述。</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">以下各节将介绍这些专题。</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">在下面的章节中,我们已经尽可能地描述了所需工具的安装。一旦工具安装完毕,构建工作就相当容易了。我们也尽量使这些说明对于Unix经验有限的人来说是可以理解的。Cygwin/MSYS/MSYS2对一些Windows用户来说是一个全新的环境,为什么要对环境变量等进行仔细的解释呢?</target>
        </trans-unit>
        <trans-unit id="1fd2193cd39cfac6403a706b39a45fed6722ffda" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">在以下情况下，您可以轻松避免调用 &lt;code&gt;lists:flatten/1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">在以下示例表中， &lt;code&gt;Data&lt;/code&gt; 必须是I / O列表。I / O列表是二进制或（可能是较深的）二进制列表或整数列表（范围为0..255）：</target>
        </trans-unit>
        <trans-unit id="cded6a813afbe8a22f1a0d31c8b7cd61b0e5883b" translate="yes" xml:space="preserve">
          <source>In the following terms that may cause confusion are explained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">在下面定义的函数中,使用了以下类型。</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">将来，调试功能可能会与Erlang驱动程序线程API集成在一起。所有创建实体的函数都使用 &lt;code&gt;name&lt;/code&gt; 参数。当前， &lt;code&gt;name&lt;/code&gt; 参数尚未使用，但是在实现调试功能时将使用它。如果您命名创建良好的所有实体，则调试功能将能够为您提供更好的错误报告。</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">在生成的启动脚本中，所有应用程序目录的结构都为 &lt;code&gt;App-Vsn/ebin&lt;/code&gt; 。假定它们位于 &lt;code&gt;$ROOT/lib&lt;/code&gt; ，其中 &lt;code&gt;$ROOT&lt;/code&gt; 是已安装发行版的根目录。如果指定了选项 &lt;code&gt;local&lt;/code&gt; ，那么将使用在其中找到应用程序的实际目录。这是在本地测试生成的启动脚本的有用方法。</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">在最后一个示例中，要分析的模块作为 &lt;code&gt;m/1&lt;/code&gt; 的参数给出，并且代码路径（隐式地）用作 &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 。在此示例中，将使用 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; ，这使得分析应用程序和发行版以及明确选择库路径成为可能。</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">在最后一行中，请注意，元组{256,10，-2}是特殊符号中的实数2.56，其编码速度比简单地将数字表示为 &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; 快。三个三元组是 &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; ，即，尾数* Base ^ Exponent。</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">在针对两个方向（参见 &lt;code&gt;cipher&lt;/code&gt; ）一分为二的列表中，可以一次更改两个方向：</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">在针对两个方向（参见 &lt;code&gt;cipher&lt;/code&gt; ）一分为二的列表中，仅可以更改以下方向之一：</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">在处理请求的循环中,现在可以检测到发送超时。</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">在Messenger的例子中,没有假设发送的消息是什么。它可以是任何有效的Erlang术语。</target>
        </trans-unit>
        <trans-unit id="8edc784c5711aef4324569d61cb733c3b77cb091" translate="yes" xml:space="preserve">
          <source>In the modified lock free version of this approach we more or less do it the same way, but with some important modifications trying to avoid unnecessary contention when multiple schedulers create processes simultaneously. Since multiple threads might be trying to search for the next free slot at the same time from the same starting point we want subsequent slots to be located in different cache lines. Multiple schedulers simultaneously writing new pointers into the table are therefore very likely to write into adjacent slots. If adjacent slots are located in the same cache line all modification of this cache line needs to be communicated between all involved processors which will be very expensive and scale very poor. By locating adjacent slots in different cache lines only true conflicts will trigger communication between involved processors, i.e., avoiding false sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">监视消息中的 &lt;code&gt;MonitorRef&lt;/code&gt; 和 &lt;code&gt;Type&lt;/code&gt; 与前面所述相同，并且：</target>
        </trans-unit>
        <trans-unit id="6af58c3bd490620b572e86c6ee20f0568469a3cc" translate="yes" xml:space="preserve">
          <source>In the new design the old wheel was dropped and instead replaced by one struct (&lt;code&gt;GenericBp&lt;/code&gt;) to hold the data for all types of breakpoints for each instrumented function. A bit-flag field is used to indicate what different type of break actions that are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a775ef8f9dc8be5c9fdaee0cab605f0e25c280e" translate="yes" xml:space="preserve">
          <source>In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d0c33ad0d8698789ff1ce734a374e0b8dc46cb" translate="yes" xml:space="preserve">
          <source>In the next word the tagged atom &lt;code&gt;id&lt;/code&gt; is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">通常情况下，版本构造为 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; 是最重要的部分。</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">在存在字段初始值的情况下,必须在初始化后声明类型,如下所示。</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">在前面的示例中，没有指示期望使用哪些协议。因此，客户端无法指示它是连接到的Web服务器，ldap服务器还是sip服务器。证书中的某些字段可以表明这一点。更确切地说，rfc 在 &lt;code&gt;X509v3 extensions&lt;/code&gt; 字段中引入了 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 的用法：</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">在前面的示例中，&amp;ldquo; ping&amp;rdquo;和&amp;ldquo; pong&amp;rdquo;是从两个单独的Erlang节点的外壳开始的。 &lt;code&gt;spawn&lt;/code&gt; 还可以用于启动其他节点中的进程。</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">在上一个示例中，如果 &lt;code&gt;all/0&lt;/code&gt; 以 &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; 的顺序返回组名引用，则配置函数和测试用例的顺序如下（注意 &lt;code&gt;init_per_testcase/2&lt;/code&gt; 和 &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 总是被调用，但为简单起见，未包含在此示例中）：</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">在前面的示例中，主管通过调用 &lt;code&gt;ch_sup:start_link()&lt;/code&gt; 启动：</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">在前面的例子中，新的变量名称来代替再利用旧的，： &lt;code&gt;First&lt;/code&gt; ， &lt;code&gt;TheRest&lt;/code&gt; ， &lt;code&gt;E1&lt;/code&gt; ， &lt;code&gt;E2&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ，和 &lt;code&gt;C&lt;/code&gt; 。这样做的原因是，变量只能在其上下文（范围）中被赋值一次。稍后再详细介绍。</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">在具有SMP支持的运行时系统中，驱动程序被锁定在驱动程序级别或端口级别（驱动程序实例级别）上。默认情况下，将使用驱动程序级别锁定，也就是说，一次只有一个仿真器线程将在驱动程序中执行代码。如果使用端口级锁定，则多个仿真器线程可以同时在驱动程序中执行代码。但是，一次仅一个线程将调用对应于同一端口的驱动程序回调。要启用端口级别锁定，请在 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 使用的 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 中设置 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; 驱动程序标志。使用端口级别锁定时，驱动程序编写器负责同步对端口（驱动程序实例）共享的数据的所有访问。</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">在第二个示例中，我们使用默认的跟踪处理程序功能。该处理程序通过将IO请求发送到 &lt;code&gt;user&lt;/code&gt; 进程来打印到tty 。在旧模式下启动Erlang时，在此示例中，shell进程将以 &lt;code&gt;user&lt;/code&gt; 作为其组长，而跟踪程序进程也将以该组领导。由于 &lt;code&gt;user&lt;/code&gt; 调用 &lt;code&gt;lists&lt;/code&gt; 函数，因此一旦发送第一个IO请求，我们就会陷入死锁。</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">在第二种形式的函数调用 &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; 中， &lt;code&gt;ExprF&lt;/code&gt; 必须是一个原子或计算为一个乐趣。</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">在序列图中，参与者（象征性地执行 &lt;code&gt;Event&lt;/code&gt; ）显示为命名的竖线。可以通过拖动（在操作过程中按住鼠标按钮1的方式）演员的名称标签并将其拖放到其他位置来更改演员的顺序：</target>
        </trans-unit>
        <trans-unit id="7823fdfa2d6e99d8afc1d184adab525e34685552" translate="yes" xml:space="preserve">
          <source>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">在外壳中，如果使用Unicode输入设备，或者在存储在UTF-8中的源代码中，则 &lt;code&gt;$&lt;/code&gt; 后面可以直接跟一个产生整数的Unicode字符。在以下示例中，输出西里尔字母 &lt;code&gt;с&lt;/code&gt; 的代码点：</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">在一个节点失去了与全局组中其他节点的连接,但与其他全局组中的节点有连接的情况下,来自另一个全局组的请求可能会产生不正确或误导的结果。例如,被隔离的节点在其全局组中的注册名称信息可能不准确。</target>
        </trans-unit>
        <trans-unit id="45354ca6d5ea2475e4f281fd6c145d031cdf7187" translate="yes" xml:space="preserve">
          <source>In the supervisor &lt;code&gt;child specification&lt;/code&gt; there is a list of modules which is recommended to contain only the callback module. For a &lt;code&gt;gen_statem&lt;/code&gt; with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade &lt;strong&gt;that&lt;/strong&gt; module whenever a &lt;strong&gt;synchronized code replacement&lt;/strong&gt; is done. Then the release handler concludes that an upgrade that upgrades &lt;strong&gt;that&lt;/strong&gt; module needs to suspend, code change, and resume any server whose child specification declares that it is using &lt;strong&gt;that&lt;/strong&gt; module. And again; the &lt;strong&gt;current&lt;/strong&gt; callback module will get the &lt;code&gt;Module:code_change/4&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34787be2516bd25bc51ccdee0b0ac4c6d7eba78b" translate="yes" xml:space="preserve">
          <source>In the tail part of the data structure we find a pointer to the last element of the list, or at least something that is near the end of the list. In the uncontended case it will point to the end of the list, but when simultaneous insert operations are performed it will point to something near the end of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">在目标目录中，读取文件 &lt;code&gt;releases/start_erl.data&lt;/code&gt; 以查找Erlang运行时系统版本（&amp;ldquo; 5.10.4&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">在文本编码中,实现者可以选择混合使用长短关键词。也可以添加白色空间来提高可读性。我们使用 &quot;紧凑 &quot;一词来表示尽可能短的关键字和没有可选的空白的文本信息,使用 &quot;漂亮 &quot;一词来表示使用长关键字和像Megaco/H.248规范中的文本示例那样的缩进风格的良好文本格式)。)</target>
        </trans-unit>
        <trans-unit id="a5c95ea342ee7c08382d8806e33a6d11792130c7" translate="yes" xml:space="preserve">
          <source>In the traditional transport entries, when the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8436cdbd307ab8656dafbbaa0b4535513613e69" translate="yes" xml:space="preserve">
          <source>In the wake of this the function &lt;code&gt;sys:get_debug/3&lt;/code&gt; that returns data with undocumented and internal format (and therefore is practically useless) has been deprecated, and a new function &lt;code&gt;sys:get_log/1&lt;/code&gt; has been added, that hopefully does what the deprecated function was intended for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">在xmerl_xs函数中，可以提供select（String）调用，这是 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 功能。有关更多详细信息，请参见xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">在这些情况下,ProtocolVersion默认版本是从静态连接配置中获取的。</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">在此代理程序系统中，有两种方法可以动态安装管理信息。最常见的方法是将MIB加载到代理中。另一种方法是使用子代理，该子代理由应用程序控制并且能够注册和注销自身。子代理可以注册自身以管理子树（不要与 &lt;code&gt;erlang:register&lt;/code&gt; 混淆）。子树由对象标识符标识。注册子代理程序后，它将接收对该特定子树的所有请求，并负责回答这些请求。还应注意，子代理可以随时启动和停止。</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">在此调用中， &lt;code&gt;[1, 1]&lt;/code&gt; 是 &lt;code&gt;RowIndex&lt;/code&gt; ，其中键1的值为1，键2的值为1， &lt;code&gt;[3, 5]&lt;/code&gt; 是请求的列的列表。该函数现在应按字典顺序返回下一个元素：</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">在这种情况下，它具有一个新的分量 &lt;code&gt;b&lt;/code&gt; 。因此，被解码的传入消息可能比该消息具有更多或发烧成分。</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">在这种情况下，测试套件中的 &lt;code&gt;ct_hooks&lt;/code&gt; 语句可以如下所示：</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">在这种情况下,配置文件必须至少包含:</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">在这种情况下，将滤波器一次应用于 &lt;code&gt;QH1&lt;/code&gt; 和 &lt;code&gt;QH2&lt;/code&gt; 的每个可能的答案对。如果对 &lt;code&gt;QH1&lt;/code&gt; 有M个答案，对 &lt;code&gt;QH2&lt;/code&gt; 有 N个答案，则过滤器将运行M * N次。</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">在这种情况下， &lt;code&gt;CTH&lt;/code&gt; 可以只是CTH的模块名称，也可以是具有模块名称和初始参数的元组，还可以是CTH的挂接优先级。例如，以下之一：</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，可以使用编译器选项 &lt;code&gt;encrypt_debug_info&lt;/code&gt; ，请参阅 &lt;code&gt;compile(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">在这种情况下，除第一个参数外的所有参数都将被忽略，并且该函数将再次简单地返回内部状态。如果仅扩展了代码，这就足够了。如果改为更改内部状态（类似于 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 的示例），则在此函数中完成此操作并返回 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; 中的一个或多个可以是未绑定变量。</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">在这种情况下，简单的代码替换是不够的。在切换到新版本的回调模块之前，该进程必须使用回调函数 &lt;code&gt;code_change&lt;/code&gt; 显式转换其状态。因此，使用了同步代码替换。</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">在这种情况下,简单的代码替换是不够的。当加载一个特殊进程的新版本的居住模块时,该进程必须对其循环函数进行完全限定的调用,以切换到新的代码。因此,必须使用同步代码替换。</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">在这种情况下,调用进程是shell,所以收到了以下结果。</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">在这种情况下,该函数必须从相关模块导出。</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，将返回键 &lt;code&gt;Key&lt;/code&gt; ，该键可在随后的调用 &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; 中使用,以检索节点 &lt;code&gt;Node&lt;/code&gt; 上的评估 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">在这种情况下，新状态是可用频道 &lt;code&gt;Chs2&lt;/code&gt; 的更新列表。该 &lt;code&gt;gen_server&lt;/code&gt; 现在已经准备好了新的要求。</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">在这种情况下，无需指定 &lt;code&gt;.appup&lt;/code&gt; 文件，即可使用具有自动打包和解包发布软件包，自动路径更新等功能的发布处理程序框架。</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，答复是分配的信道 &lt;code&gt;Ch&lt;/code&gt; ，新状态是剩余可用信道 &lt;code&gt;Chs2&lt;/code&gt; 的集合。</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，主管未注册。而是必须使用其pid。可以通过调用 &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; 或 &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">在这种情况下，您可以分别释放两个术语。释放术语 &lt;code&gt;ep&lt;/code&gt; 和 &lt;code&gt;ep2&lt;/code&gt; 的顺序并不重要，因为 &lt;code&gt;Erl_Interface&lt;/code&gt; 库使用引用计数来确定何时安全地删除对象。</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">在这个例子中,考虑到你想检查XML文件中的一个特定数据的情况。例如,你想检查每辆摩托车被记录了多长时间。</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">在这个例子中,Pea应用程序已经被改变了,ERTS、Kernel、STDLIB和SASL等应用程序也被改变了。</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">在此示例中，数字是整数，并且代码 &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 中的函数中的参数称为变量。变量必须以大写字母开头（请参见 &lt;code&gt;Variables&lt;/code&gt; ）。变量的示例是 &lt;code&gt;Number&lt;/code&gt; ， &lt;code&gt;ShoeSize&lt;/code&gt; 和 &lt;code&gt;Age&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00141d9820384d0fe96047499c682c85df54a263" translate="yes" xml:space="preserve">
          <source>In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">在此示例中，您将遍历列表&amp;ldquo;携带&amp;rdquo;一个值，在本例中为 &lt;code&gt;Result_so_far&lt;/code&gt; 。 &lt;code&gt;list_max/1&lt;/code&gt; 只是假定列表的最大值是列表的开头，然后调用 &lt;code&gt;list_max/2&lt;/code&gt; 以及列表的其余部分和列表的开头的值。上面是 &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; 。如果您尝试将 &lt;code&gt;list_max/1&lt;/code&gt; 与一个空列表一起使用，或者尝试将其与完全不是列表的东西一起使用，则会导致错误。请注意，Erlang的原则不是在发生错误的函数中处理此类错误，而是在其他地方进行处理。稍后再详细介绍。</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">在此示例中， &lt;code&gt;suite/0&lt;/code&gt; 告诉 &lt;code&gt;Common Test&lt;/code&gt; 禁止Telnet和SSH连接打印输出。这对于所有测试用例均有效。但是， &lt;code&gt;my_testcase1/0&lt;/code&gt; 指定对于此测试用例，仅SSH将处于静默状态。结果是 &lt;code&gt;my_testcase1&lt;/code&gt; 获得了在日志中打印的Telnet信息（如果有），而不是SSH信息。 &lt;code&gt;my_testcase2&lt;/code&gt; 从打印的任何连接中均未获取任何信息。</target>
        </trans-unit>
        <trans-unit id="f2f906325545f1417f1e6e7ea85883ce6305f126" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">在此示例中，收到 &lt;code&gt;{Pid, Something}&lt;/code&gt; 。接收到的pid然后用于返回 &lt;code&gt;{goodbye,Pid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">在此示例中，从外部源接收到一系列字节，然后将这些字节解码为有效的Erlang术语。这是通过调用 &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; 实现的，它返回了ASN.1类型 &lt;code&gt;Person&lt;/code&gt; 的Erlang值。然后使用 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; 构造和编码答案，该答案采用已定义的ASN.1类型的实例，并根据BER或PER编码规则将其转换为二进制。</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">在此示例中，具有NIF后端的跟踪器模块为每个仅包含发送者和接收者的 &lt;code&gt;send&lt;/code&gt; 跟踪标签发送一条消息。使用此跟踪器模块，可以使用轻量级消息跟踪器，该跟踪器仅记录谁向谁发送了消息。</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">在此示例中，使用环境变量 &lt;code&gt;DISPLAY&lt;/code&gt; 设置为 &lt;code&gt;gin:0&lt;/code&gt; 来启动Erlang运行时系统。</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">在此示例中，尝试使用字符串格式指令 &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 〜s &amp;rdquo;输出单个字符65 。</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">在这个例子中,当io:format调用完成后,在调用过程中设置的任何用户标签都会被传播到I/O服务器上。</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">在这个例子中,每个运行时系统都有两个调度器在线,所有在线的调度器将运行在不同的内核上。如果我们将一个运行时系统改为一个调度器在线,另一个运行时系统改为三个调度器在线,那么所有在线的调度器仍然会运行在不同的内核上。</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">在此示例中，如果打开了门，则函数 &lt;code&gt;terminate/3&lt;/code&gt; 会将门锁定，因此，当监视树终止时，我们不会意外地使门保持打开状态：</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">在此示例中，如果第一个元素是键，则在 &lt;code&gt;MatchHead&lt;/code&gt; 部分中匹配该键比在 &lt;code&gt;MatchConditions&lt;/code&gt; 部分中匹配该键要有效得多。表的搜索空间在 &lt;code&gt;MatchHead&lt;/code&gt; 方面受到限制，因此仅搜索具有匹配键的对象。</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">在此示例中，我们可以将其推迟，然后将它们排队并在 &lt;code&gt;locked&lt;/code&gt; 状态下处理，而不是在 &lt;code&gt;open&lt;/code&gt; 状态下忽略按钮事件：</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">在本例中,执行以下操作。</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">在本示例中，使用了与&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 节中相同的ASN.1规范。以下是有效的选择性解码指令：</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">在这个例子中,文件 &quot;b.spec &quot;和 &quot;c.spec &quot;中定义的测试术语与源规范 &quot;a.spec &quot;中的术语(如果有的话)结合在一起。包含规格 &quot;d.spec &quot;和 &quot;e.spec &quot;的结果是两个单独和独立的测试运行(每个包含的规格都有一个)。</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">在此示例中，如果二进制文件引用的二进制文件大于我们要保留的数据大小的两倍，我们选择先复制二进制文件内容，然后再将其插入 &lt;code&gt;gb_sets:set()&lt;/code&gt; 。当然，复制到不同程序时将应用不同的规则。</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">在此示例中，我们首先将 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; -group1-sha1'放在首位，然后将'ecdh-sha2-nistp521'移至kex列表的末尾，即 &lt;code&gt;append&lt;/code&gt; 它。</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">在此示例中，我们同时使用了两个选项（ &lt;code&gt;preferred_algorithms&lt;/code&gt; 和 &lt;code&gt;modify_algorithms&lt;/code&gt; ），并且还尝试在不支持的算法之前添加前缀。任何不受支持的算法都会被悄悄删除。</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">在这个例子中,使用了以下ASN.1规范的定义。</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">在下面的示例中，密码为 &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">在这种模式下,可以进行以下操作。</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">在此模块中，V可以为空。这样获得的唯一有向图称为&lt;strong id=&quot;empty_digraph&quot;&gt;空有向图&lt;/strong&gt;。顶点和边均由唯一的Erlang术语表示。</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">在本模块中,只考虑了一些集X的子集的族;在下文中,&quot;族 &quot;这个词是用于这种子集的族。</target>
        </trans-unit>
        <trans-unit id="9df8795a77ab5095acba5e23497d16dae8d5c2f4" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the time-out since the time-out event is the only possible reason to do a &lt;strong&gt;state change&lt;/strong&gt; from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">在这种特殊情况下，我们不需要取消超时，因为超时事件是将状态从&amp;ldquo; &lt;code&gt;open&lt;/code&gt; 更改为&amp;ldquo; &lt;code&gt;locked&lt;/code&gt; 的唯一可能原因。</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">在这种特殊情况下，命令 &lt;code&gt;i&lt;/code&gt; （&amp;ldquo;中断&amp;rdquo;）终止循环程序，命令 &lt;code&gt;c&lt;/code&gt; 重新连接到外壳。由于该进程在终止之前在后台运行，因此在显示消息&amp;ldquo; &lt;code&gt;** exception exit: killed&lt;/code&gt; &amp;rdquo; 之前，会出现更多的打印输出。</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">在这种情况下，用于保护ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; 的锁已花费了大部分等待时间。在运行60秒的测试中，这是1.8秒。时间也分布在八个不同的调度程序线程上。</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">在此部分中，&amp;ldquo; &lt;code&gt;Domain&lt;/code&gt; 字段是传输域，即 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 之一，而 &lt;code&gt;Addr&lt;/code&gt; 字段是 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">在此部分中， &lt;code&gt;Address&lt;/code&gt; 字段是 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 元组，其中 &lt;code&gt;Domain&lt;/code&gt; 是 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 或 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; ，而 &lt;code&gt;Addr&lt;/code&gt; 是 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">在本节中,列出了所有有效的Erlang表达式。在编写Erlang程序时,也允许使用宏和记录表达式。但是,这些表达式在编译过程中会被展开,在这个意义上,它们不是真正的Erlang表达式。宏表达式和记录表达式将在单独的章节中介绍。</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">在本节中，假定用户名是 &lt;code&gt;otpuser&lt;/code&gt; ,并且该用户的主目录是：</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">在本节中,使用了以下术语:</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">在这种简单的情况下,就可读性而言,前一种表达方式可能更可取。</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">这样，您可以使用链接将事务中的所有流程连接在一起。如果其中一个进程异常退出，那么事务中的所有进程都会被杀死。由于经常需要创建一个流程并同时链接到该流程，因此有一个特殊的BIF &lt;code&gt;spawn_link&lt;/code&gt; 与 &lt;code&gt;spawn&lt;/code&gt; 一样，但是也创建了一个到生成的流程的链接。</target>
        </trans-unit>
        <trans-unit id="04cd30a6181cf29b11e39620fc1e71c03e622ab5" translate="yes" xml:space="preserve">
          <source>In those circumstances, &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; must be invoked to set up the pointer again. &lt;strong&gt;beam_makeops&lt;/strong&gt; will notice if there is a call to a function that does a garbage collection and &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12987c6a024d031823b3213c0fb06e759b8cd0bf" translate="yes" xml:space="preserve">
          <source>In those functions the internal crypto state is first created and initialized with the cipher type, the key and possibly other data. Then the single binary is encrypted or decrypted, the crypto state is de-allocated and the result of the crypto operation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">在传统的关系数据库术语中,这种操作称为选择,然后是投影。</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;StartMessage&lt;/code&gt; 类型中，字段 &lt;code&gt;content&lt;/code&gt; 后面的约束表明，在 &lt;code&gt;StartMessage&lt;/code&gt; 类型的值中，字段 &lt;code&gt;content&lt;/code&gt; 的值必须来自字段 &lt;code&gt;msgId&lt;/code&gt; 选择的同一对象。</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在megaco标准的版本3中，引入了Segmentation软件包。简而言之，此程序包定义了一个过程，用于在使用不会自动执行此操作的传输程序（例如UDP）时，分割megaco消息（事务答复）。另请参见 &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63b6f2d5cd37bdba6df81460e958046ee197cfa0" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard, the concept of &lt;code&gt;segmentation package&lt;/code&gt; was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; 引入了哪个OTP版本？</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">在您自己的跟踪处理程序函数中，调用 &lt;code&gt;erlang:display/1&lt;/code&gt; 而不是 &lt;code&gt;io&lt;/code&gt; 函数；或者，如果未将 &lt;code&gt;user&lt;/code&gt; 用作组长，则打印给 &lt;code&gt;user&lt;/code&gt; 而不是默认组长。示例： &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">Inband-Security-Id AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">Inband-Security-Id AVP(代码299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id默认为空列表,相当于一个只包含0(NO_INBAND_SECURITY)的列表。如果指定了1(TLS),那么如果从对等体收到的CER/CEA提供了TLS,那么就会选择TLS。</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">二进制文件中的入站二进制编码</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">列表和二进制中的入站百分比编码。</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">顺便说一句，当纠正了测试用例时，确实应该发现 &lt;code&gt;channel&lt;/code&gt; 的错误。</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">在Erlang路径中包含 &lt;code&gt;dir&lt;/code&gt; 。在分析具有 &lt;code&gt;-include_lib()&lt;/code&gt; 指令的文件时，这很有用。</target>
        </trans-unit>
        <trans-unit id="cae53151741eb56a1003fee69921d65824bcd040" translate="yes" xml:space="preserve">
          <source>Include Directories and Macro Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包含目录也可以在测试规范中指定，请参阅&amp;ldquo; &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">包含文件</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">包含文件通常用于由几个模块共享的记录和宏定义。建议对包含文件使用文件扩展名 &lt;code&gt;.hrl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ec71a4f09bb1029d3d4fb8244b9d00627d2bcc0" translate="yes" xml:space="preserve">
          <source>Include the correct tool's include file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">在标记注释中包含标记文本。文本是输入中与标记对应的部分。</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">包含对忽略结构化返回值或不与许多可能的返回值之一匹配的函数调用的警告。</target>
        </trans-unit>
        <trans-unit id="b72333c2c10be7a2ac2a052bd2a51691c99a5707" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return values. However, no warnings are included if the possible return values are a union of atoms or a union of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">为那些只通过异常返回的函数加入警告。</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">包括对可能的竞赛条件的警告。注意,发现数据竞赛的分析会执行程序内数据流分析,有时会及时爆炸。启用它,风险自负。</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">包括测试信息</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">包括一个包含所有呼叫统计的部分,无论进程如何,在分析中。</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中都包含时间戳记。时间戳（Ts）具有与 &lt;code&gt;erlang:now()&lt;/code&gt; 返回的形式相同的形式。</target>
        </trans-unit>
        <trans-unit id="c46ef04f4bea55e14a8a6db20798656add229d29" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中都包含一个 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 戳记。时间戳（Ts）与 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; 产生的格式和值相同。该标志覆盖标志 &lt;code&gt;cpu_timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="029776045f3168e0cc5e9e683547f1e18a0a84fc" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">在所有跟踪消息中包括一个时间戳，该时间戳由 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 和一个单调递增的整数组成。时间戳（Ts）与 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;,&lt;/code&gt; erlang：unique_integer（[monotonic]） &lt;code&gt;}&lt;/code&gt; 产生的格式和值相同。该标志覆盖标志 &lt;code&gt;cpu_timestamp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">包括以的形式自定义调试信息 &lt;code&gt;Backend&lt;/code&gt; 模块与定制 &lt;code&gt;Data&lt;/code&gt; 编译光束模块中。给定的模块必须实现一个 &lt;code&gt;debug_info/4&lt;/code&gt; 的功能和负责生成不同的代码表示，如在所描述的 &lt;code&gt;debug_info&lt;/code&gt; 下 &lt;code&gt;beam_lib(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09654fa1bf12f6550a22d7f012f2848d49adaf98" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt; Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">在已编译Beam模块的 &lt;code&gt;debug_info&lt;/code&gt; 块中以 &lt;code&gt;Erlang Abstract Format&lt;/code&gt; 的形式包含调试信息。诸如Debugger，Xref和Cover之类的工具需要包含调试信息。</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">包括调试信息，但会对其进行加密，以便在不提供密钥的情况下无法对其进行访问。（也可以提供 &lt;code&gt;debug_info&lt;/code&gt; 选项，但不是必须的。）使用此选项是一种在测试过程中始终使调试信息可用且保护源代码的好方法。</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">包括属性 &lt;code&gt;{role, client | server}&lt;/code&gt; 。当前，这是唯一的预定义属性，也可以有用户定义的属性。另请参见应用程序环境变量 &lt;code&gt;session_cb_init_args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3537d431c47b4e76cf518f3b56096886e6209c2b" translate="yes" xml:space="preserve">
          <source>Including Literal Strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">传入连接</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">传入的Diameter消息在被传递给 &lt;code&gt;diameter_app(3)&lt;/code&gt; 回调之前，从binary（）进行解码。同样，传出的Diameter消息在传递到适当的 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 模块进行传输之前，被编码为binary（）。此处记录的功能实现默认的编码/解码。</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">收到的消息由megaco:receive_message/4传递,通常会成功解码。但是如果解码失败,这个函数被调用,以决定发信人是否应该收到回复信息(reply),或者是否应该默默地丢弃回复信息(no_reply)。</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">传入的消息由megaco:receive_message/4传递并成功解码。通常消息中包含一个事务列表,这个函数会对消息中的每个事务请求进行调用。</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">收到的消息由megaco:receive_message/4传送并成功解码。通常一条消息包含一个交易列表,但也可能在消息的顶层包含一个ErrorDescriptor。</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">不同版本之间可能会发生不兼容的变化。</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">流状态不一致。</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">UTF编码不正确。</target>
        </trans-unit>
        <trans-unit id="845a0fc6405933efbba9490c6fc4f32adaee1aa6" translate="yes" xml:space="preserve">
          <source>Incr :: integer()) -&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">增加了暂停对标识的进程数 &lt;code&gt;Suspendee&lt;/code&gt; 并把它处于暂停状态，如果它不是已经在该州。在恢复进程之前，不会安排已挂起的进程执行。</target>
        </trans-unit>
        <trans-unit id="360be904729f90e5380efbfa1ebc525a6bb6168c" translate="yes" xml:space="preserve">
          <source>Increasingly bad performance of mmap/munmap as the number of mmap'ed areas grow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">当对Erlang运行时系统进行NIF库不兼容的更改时，此值增加。通常，当 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 更改时，足以重新编译NIF库，但是在极少数情况下，这意味着必须对NIF库进行略微修改。如果是这样，当然会记录在案。</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">在增加新功能时增加。运行时系统使用次要版本来决定使用什么功能。</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">用 &lt;code&gt;N&lt;/code&gt; 递增MIB中的变量，如果未指定 &lt;code&gt;N&lt;/code&gt; 则递增1 。</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">增加映射迭代器,指向下一个键值条目。</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">增加作为参数（ &lt;code&gt;pdl&lt;/code&gt; ）传递的端口数据锁的引用计数。</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">递增 &lt;code&gt;bin&lt;/code&gt; 上的引用计数，并返回递增后达到的引用计数。</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">递增与丢弃的pdu相关的变量。当net_if过程接收，可以使用此功能 &lt;code&gt;discarded_pdu&lt;/code&gt; 从代理消息。</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">在文档的右边缩进多个字符位置。请注意， &lt;code&gt;N&lt;/code&gt; 可以为负，可以将文本向左移动或为零，在这种情况下， &lt;code&gt;D&lt;/code&gt; 将保持不变。</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">索引不是免费的。它们占用的空间与表的大小成正比,而且它们会导致插入表的速度稍慢。</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">表中的索引必须是对象,而不是类型(仅与SMIv1有所偏离)。</target>
        </trans-unit>
        <trans-unit id="41fd24de9543beb15639d7be950596afb05d2918" translate="yes" xml:space="preserve">
          <source>Indexes into atomic arrays are one-based. An atomic array of arity N contains N atomics with index from 1 to N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1276b938031e0556a12602f87fa510de52c86d9" translate="yes" xml:space="preserve">
          <source>Indexes into counter arrays are one-based. A counter array of size N contains N counters with index from 1 to N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="617aa3438335193f784faa90321050a9a7e9ecfd" translate="yes" xml:space="preserve">
          <source>Indicate if the elements of the array will be treated as signed or unsigned integers. Default is &lt;code&gt;true&lt;/code&gt; (signed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">表示断开的链接。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 和 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 包含链接进程的pid。</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">指示用户可能要使用的自定义序言文件，而不是默认文件 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; ，否则该文件将包含在结果解析器文件的开头。&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;Includefile&lt;/code&gt; 是按原样包含在解析器文件中的，因此它必须没有自己的模块声明，也不应编译。但是，它必须包含必要的出口声明。默认值由 &lt;code&gt;&quot;&quot;&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">指示在关联 &lt;code&gt;assoc_id&lt;/code&gt; 中由 &lt;code&gt;addr&lt;/code&gt; 指定的对等方的IP地址状态的更改。 &lt;code&gt;state&lt;/code&gt; 可能值（主要是不言自明的）包括：</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">表示字符范围</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指示是要更新所有应用程序代码路径（ &lt;code&gt;Bool==true&lt;/code&gt; ），还是仅要更新已修改应用程序的代码路径（ &lt;code&gt;Bool==false&lt;/code&gt; ，默认值）。这个选项只对其他应用程序目录比默认的效果 &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; ，即在参数中指定的应用程序目录 &lt;code&gt;AppDirs&lt;/code&gt; 在一个呼叫 &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
