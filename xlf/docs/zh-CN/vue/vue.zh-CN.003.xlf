<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3018c9188b3b3d4a23f0075a78973fd85df51141" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;app.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">但是，如果您需要使用&lt;strong&gt;模块系统&lt;/strong&gt;（例如，通过Webpack或Browserify）来导入/导入组件，则会收到错误消息：</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，如果您排除了上述情况，却发现自己不得不手动强制执行更新，则可以使用&lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d036c8bdba9e735ef24169304153c34c8f3b798" translate="yes" xml:space="preserve">
          <source>However, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/instance-methods#forceupdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3610b4f1219dad3d7eab3e3d1d0df611f8efc2" translate="yes" xml:space="preserve">
          <source>However, in Vue 3, the performance of stateful components has improved to the point that the difference is negligible. In addition, stateful components now also include the ability to return multiple root nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">但是，在某些情况下，您可能希望两者都位于同一元素上，例如，具有由Vue触发的CSS动画以及对悬停的CSS过渡效果。在这些情况下，您将必须在 &lt;code&gt;type&lt;/code&gt; 属性中明确声明要Vue关注的类型，其值可以是 &lt;code&gt;animation&lt;/code&gt; 或 &lt;code&gt;transition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">然而,就像其他指令一样,只有在提供了参数的情况下,该速记才可用。这意味着下面的语法是无效的。</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">但是，并非每个人都希望使用TypeScript。在许多较小规模的用例中，引入类型系统可能会导致比生产率提高更多的开销。在这些情况下，最好改用Vue，因为在没有TypeScript的情况下使用Angular可能会遇到挑战。</target>
        </trans-unit>
        <trans-unit id="73e089bb95641b06647f01ce72a8df5b24a857f3" translate="yes" xml:space="preserve">
          <source>However, sometimes a part of a component's template belongs to this component logically, while from a technical point of view, it would be preferable to move this part of the template somewhere else in the DOM, outside of the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a38a0e30cb26490e5f05809a78f3a4c9e4964e" translate="yes" xml:space="preserve">
          <source>However, that level of flexibility is usually not required. It's often possible to replace &lt;code&gt;resolveDynamicComponent&lt;/code&gt; with a more direct alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">但是，依赖项注入存在缺点。它将应用程序中的组件与当前的组织方式耦合在一起，从而使重构更加困难。提供的属性也不具有反应性。这是设计使然，因为使用它们创建中央数据存储的伸缩性与&lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;使用 &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt;达到相同目的的伸缩性一样差。如果您要共享的属性是特定于您的应用程序的，而不是通用的，或者您曾经想更新祖先内部提供的数据，则表明您可能需要像&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;这样的真实状态管理解决方案。</target>
        </trans-unit>
        <trans-unit id="2a5d7767d7e276c46e20eda1a815bca70a1441e7" translate="yes" xml:space="preserve">
          <source>However, there are times where we need to update the data inside of the component where the data is injected. In this scenario, we recommend providing a method that is responsible for mutating the reactive property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eff740b8e2a37ddfa14b1eb95316301f5907a17" translate="yes" xml:space="preserve">
          <source>However, this approach is potentially problematic for components that are reused because they'll all share the same debounced function. To keep the component instances independent from each other, we can add the debounced function in the &lt;code&gt;created&lt;/code&gt; lifecycle hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">但是，如果您有多个条件类，这可能会有点冗长。这就是为什么还可以在数组语法中使用对象语法的原因：</target>
        </trans-unit>
        <trans-unit id="85cd8c9d4719bfdd0176caad9283969d3ff23830" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">但是，这不会自动将任何数据传递给组件，因为组件具有各自独立的作用域。为了将迭代的数据传递到组件中，我们还应该使用道具：</target>
        </trans-unit>
        <trans-unit id="fc101cca76508ab598f5b4b585c1e6780fad8310" translate="yes" xml:space="preserve">
          <source>However, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0c334fd910aa57b2a33967cd21852214b1f058" translate="yes" xml:space="preserve">
          <source>However, this won't work if we try to provide some component instance property here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004b32fe588f88c41b42b4992994b442c861a69c" translate="yes" xml:space="preserve">
          <source>However, watching a reactive object or array will always return a reference to the current value of that object for both the current and previous value of the state. To fully watch deeply nested objects and arrays, a deep copy of values may be required. This can be achieved with a utility such as &lt;a href=&quot;https://lodash.com/docs/4.17.15#cloneDeep&quot;&gt;lodash.cloneDeep (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">但是，在远方的后代/祖先之间进行通信时， &lt;code&gt;$emit&lt;/code&gt; 不会帮助您。相反，最简单的升级方法是使用集中式事件中心。这具有额外的好处，无论您在组件树中的哪个位置，都可以在它们之间进行通信，甚至在兄弟姐妹之间也可以通信！由于Vue实例实现了事件发射器接口，因此您实际上可以为此使用一个空的Vue实例。</target>
        </trans-unit>
        <trans-unit id="a6f9aa6296c86949de208bc5300b04f5bbd8e693" translate="yes" xml:space="preserve">
          <source>However, when using the composition API to explicitly create reactive objects, the best practice is to never hold a reference to the original raw object and only work with the reactive version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">但是，如果您希望明确，仍可以将默认的插槽内容包装在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="29e3b3dcfde111c535bca8f3776cc120ca6d19c2" translate="yes" xml:space="preserve">
          <source>Hybrid-App Development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">我希望现在，您正在使用自己喜欢的语言阅读这句话。如果没有，您想帮助我们到达那里吗？</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">我很高兴你问！答案是不。大约90％的API是相同的，核心概念没有改变。长期以来，我们喜欢提供非常详细的说明并包括许多示例。请放心，&lt;strong&gt;这不是您必须自上而下阅读的内容！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc4427647cd69fcbdf57ea287139ca162e4fbe9" translate="yes" xml:space="preserve">
          <source>IDE Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615578cf02895b5ceadb54ba5821d7c10372fcdc" translate="yes" xml:space="preserve">
          <source>IDL attr &amp;amp; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb8f6c14252759cd8673c61a24376d32e17b93a" translate="yes" xml:space="preserve">
          <source>Icons</source>
          <target state="translated">Icons</target>
        </trans-unit>
        <trans-unit id="31aa3a07a8b9c23bb9e5b73c71b5e12fcbbbc57f" translate="yes" xml:space="preserve">
          <source>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 的模板&lt;strong&gt;不&lt;/strong&gt;包含 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素，则其开始标记和结束标记之间提供的任何内容都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="74b581a78f3cd91716bbaddac8b29eb9776b03b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; contains a Vue component, it will remain a logical child component of the &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt;'s parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b06f1fcb96eb40ac85f5cac5c66c2b155891fcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;todo-button&amp;gt;&lt;/code&gt;'s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201ba7f76ed37c8b5c2f564825de9c9ebb281704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;config.isCustomElement&lt;/code&gt; is assigned to when using a runtime-only build, a warning will be emitted instructing the user to pass the option in the build setup instead;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">如果未提供 &lt;code&gt;elementOrSelector&lt;/code&gt; 参数，则该模板将呈现为文档外元素，并且您将必须使用本机DOM API自己将其插入文档中。</target>
        </trans-unit>
        <trans-unit id="0b1be49ac332b8febaafa2d94f48398afa699acf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flush&lt;/code&gt; is set to &lt;code&gt;'sync'&lt;/code&gt;, the callback will be called synchronously, as soon as the value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">如果 &lt;code&gt;isButtonDisabled&lt;/code&gt; 的值为 &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;disabled&lt;/code&gt; 属性甚至不会包含在呈现的 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="fe1c53b1161887bd5b64d08a53a8b025bd8d8769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object can be accessed in the component's template, as well as the properties of the &lt;code&gt;props&lt;/code&gt; passed into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72354f5499649f8d82fce993f6a021a2603b963e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object will be merged on to the render context for the component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eb06e2e36786f2679f43f6de53626bf2d00da9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;title&lt;/code&gt; is an optional prop, it could be missing from &lt;code&gt;props&lt;/code&gt;. In that case, &lt;code&gt;toRefs&lt;/code&gt; won't create a ref for &lt;code&gt;title&lt;/code&gt;. Instead you'd need to use &lt;code&gt;toRef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">如果我升级到Vue 2,是否也要升级Vuex和Vue Router?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">如果Vue没有此规则，则单击一个按钮将影响&lt;em&gt;所有其他实例&lt;/em&gt;的数据，如下所示：</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">如果Vue实例在实例化时未收到 &lt;code&gt;el&lt;/code&gt; 选项，则它将处于&amp;ldquo;已卸载&amp;rdquo;状态，而没有关联的DOM元素。 &lt;code&gt;vm.$mount()&lt;/code&gt; 可用于手动启动未安装的Vue实例的安装。</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">如果一个组件只有在单个父组件的上下文中才有意义,那么这种关系应该在它的名称中得到体现。由于编辑器通常按字母顺序组织文件,这也使这些相关的文件彼此相邻。</target>
        </trans-unit>
        <trans-unit id="d6080ced28d2ad5267aab8c60cb9e3ee41fcc9d3" translate="yes" xml:space="preserve">
          <source>If a component receives slots from its parent, they can be passed on directly to a child component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed6b31ac8ff605e55f7cdbf21aabd756efc8bb1" translate="yes" xml:space="preserve">
          <source>If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">如果在渲染组件时发生运行时错误，则将其传递给全局 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 配置函数（如果已设置）。最好将此钩子与错误跟踪服务（例如&lt;a href=&quot;https://sentry.io&quot;&gt;Sentry）&lt;/a&gt;一起使用，该服务为Vue 提供&lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;了官方集成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="642e3ac102c57674c11d312a80ed33358ce20b95" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component's render, it will be passed to the global &lt;code&gt;app.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry (opens new window)&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration (opens new window)&lt;/a&gt; for Vue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec559a16f0238f7c29fe23c19c2dec1b891987a" translate="yes" xml:space="preserve">
          <source>If an object is assigned as a ref's value, the object is made deeply reactive by the &lt;a href=&quot;basic-reactivity#reactive&quot;&gt;reactive&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">如果同时给出了事件和回调,则只删除该特定回调的监听器。</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">如果相反，您的目的是有条件地跳过循环执行，则可以将 &lt;code&gt;v-if&lt;/code&gt; 放置在包装器元素（或&lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt;）上。例如：</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">如果需要从具有不同名称的属性中注入，请使用 &lt;code&gt;from&lt;/code&gt; 表示源属性：</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">如果组件的继承链或父链上存在多个 &lt;code&gt;errorCaptured&lt;/code&gt; 挂钩，则将在相同的错误上调用所有它们。</target>
        </trans-unit>
        <trans-unit id="9f4ae8d54b54e963413f7f1cfbf43652de62cd55" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">如果既没有 &lt;code&gt;render&lt;/code&gt; 功能也没有 &lt;code&gt;template&lt;/code&gt; 选项，则将安装DOM元素的in-DOM HTML提取为模板。在这种情况下，应使用Vue的Runtime + Compiler构建。</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">如果未检测到CSS过渡/动画并且未提供JavaScript钩子，则用于插入和/或移除的DOM操作将在下一帧立即执行（注意：这是浏览器动画帧，与Vue的 &lt;code&gt;nextTick&lt;/code&gt; 概念不同）。</target>
        </trans-unit>
        <trans-unit id="b064733da54289be43813af974ffc4066d5f06c7" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue's concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">如果没有提供参数,则删除所有事件监听器。</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">如果只提供事件,则删除该事件的所有监听器。</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">如果Vue选项中存在渲染功能,则模板将被忽略。</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">如果需要，可以通过将 &lt;code&gt;vm.$data&lt;/code&gt; 通过 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; 传递来获得原始对象的深层克隆。</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">如果是这样，请随时为&lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;这些文档&lt;/a&gt;或任何其他官方维护的文档创建存储库，然后开始翻译。一旦取得了一些进展，请在主存储库中打开问题或请求请求，我们将召集更多的贡献者来帮助您。</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;errorCaptured&lt;/code&gt; 挂钩本身抛出错误，则此错误和原始捕获的错误都将发送到全局 &lt;code&gt;config.errorHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="009579549300fafa52dbcc22a4317c4e5cd4cffe" translate="yes" xml:space="preserve">
          <source>If the VNode is always an HTML element then we can pass its name directly to &lt;code&gt;h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20828a01491d3d176994e014e8243f15e5cec364" translate="yes" xml:space="preserve">
          <source>If the bound value is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; then the attribute will not be included on the rendered element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">如果组件是功能组件，则渲染功能还将接收一个额外的参数 &lt;code&gt;context&lt;/code&gt; ，因为功能组件是无实例的，因此可以访问上下文数据。</target>
        </trans-unit>
        <trans-unit id="778a0693bfbcff846a92b8e406613e51b0ccd2e7" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &quot;unselected&quot; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">如果 &lt;code&gt;v-model&lt;/code&gt; 表达式的初始值与任何选项都不匹配，则 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 元素将呈&amp;ldquo;未选中&amp;rdquo;状态。在iOS上，这将导致用户无法选择第一项，因为在这种情况下，iOS不会触发更改事件。因此，如上例所示，建议提供一个具有空值的禁用选项。</target>
        </trans-unit>
        <trans-unit id="e40b666fff5068ba41fcb1fb1d0acd4ce7a992d8" translate="yes" xml:space="preserve">
          <source>If the methods &lt;code&gt;toTitleDate&lt;/code&gt; or &lt;code&gt;formatDate&lt;/code&gt; access any reactive data then it will be tracked as a rendering dependency, just as if it had been used in the template directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c148d9a336221fd54485bc5ad61e9a1e229c73a" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a &lt;code&gt;querySelector&lt;/code&gt; and use the selected element's innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">如果字符串以 &lt;code&gt;#&lt;/code&gt; 开头，它将用作querySelector并将所选元素的innerHTML用作模板字符串。这允许使用常见的 &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; 技巧来包含模板。</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">如果过渡组件提供了&lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;，则会在适当的时间调用这些钩子。</target>
        </trans-unit>
        <trans-unit id="2ecd8a7c716c95da925d56a24dbff68dbe3cb732" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#javascript-hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db2c73fe7d859c72406458c11b699f22e3d0c62" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0743f97ca671f5c9ea8b899455cd80afbfe69b8a" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b75b60aea9cf846f97bdc9f59bd5b35161f3f" translate="yes" xml:space="preserve">
          <source>If there are no props then the children can usually be passed as the second argument. In cases where that would be ambiguous, &lt;code&gt;null&lt;/code&gt; can be passed as the second argument to keep the children as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">如果您喜欢使用第三方路由器，例如&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt;或&lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;，则集成&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;同样容易&lt;/a&gt;。这是使用Page.js 的&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;完整示例。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a4deb4463100ef774d066f03629b21cdc02fb26" translate="yes" xml:space="preserve">
          <source>If there's a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js (opens new window)&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director (opens new window)&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly straightforward (opens new window)&lt;/a&gt;. Here's a &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/tree/pagejs&quot;&gt;complete example (opens new window)&lt;/a&gt; using Page.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c1c9810ed91033d943c8c7395ef1ff554427a5" translate="yes" xml:space="preserve">
          <source>If this component received an &lt;code&gt;id&lt;/code&gt; attribute and a &lt;code&gt;v-on:close&lt;/code&gt; listener, the &lt;code&gt;$attrs&lt;/code&gt; object will now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">如果此选项在实例化时可用，则实例将立即进入编译；否则，实例将立即进入编译。否则，用户将必须显式调用 &lt;code&gt;vm.$mount()&lt;/code&gt; 来手动启动编译。</target>
        </trans-unit>
        <trans-unit id="31295f224ed5601010e4bf662145dc4776218b9c" translate="yes" xml:space="preserve">
          <source>If using a build step: pass the &lt;code&gt;isCustomElement&lt;/code&gt; option to the Vue template compiler. If using &lt;code&gt;vue-loader&lt;/code&gt;, this should be passed via &lt;code&gt;vue-loader&lt;/code&gt;'s &lt;code&gt;compilerOptions&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a7080e683c7a64c86aa780d504104684e2c8cf" translate="yes" xml:space="preserve">
          <source>If using on-the-fly template compilation, pass it via &lt;code&gt;app.config.isCustomElement&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330f73efd7b8fa6913e10b944928e9083afdfa3e" translate="yes" xml:space="preserve">
          <source>If using string keys or non-typed symbols, the type of the injected value will need to be explicitly declared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cd39cc6503370abf981fdea53d1f2a726cdba6" translate="yes" xml:space="preserve">
          <source>If we need to resolve a component by name then we can call &lt;code&gt;resolveComponent&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8df13c30163597104a70bd9ea70be42706e226" translate="yes" xml:space="preserve">
          <source>If we need to update the list items, we do so in JavaScript, using the reactivity we mentioned earlier. We then make all the changes to the JavaScript copy, the virtual DOM, and perform a diff between this and the actual DOM. Only then do we make our updates to just what has changed. The Virtual DOM allows us to make performant updates to our UIs!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46541c29071775d267576f2d4f8b07035cf486fe" translate="yes" xml:space="preserve">
          <source>If we update the first value, the sum is not adjusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf205117227a86a1eb58ae18d3718adb780a6c9" translate="yes" xml:space="preserve">
          <source>If we want to add a custom element defined outside of Vue (e.g. using the Web Components API), we need to 'instruct' Vue to treat it as a custom element. Let's use the following template as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fcea7a8afcf7157ecc5757dd89328f51812842" translate="yes" xml:space="preserve">
          <source>If we want to pass the length of todo-items directly to &lt;code&gt;TodoListStatistics&lt;/code&gt;, we would pass the prop down the hierarchy: &lt;code&gt;TodoList&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListFooter&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListStatistics&lt;/code&gt;. With provide/inject approach, we can do this directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb928534fcb45cb1f88d282a370e12143b6fe8" translate="yes" xml:space="preserve">
          <source>If we wanted to change prop or event names to something different, we would need to add a &lt;code&gt;model&lt;/code&gt; option to &lt;code&gt;ChildComponent&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150e823a3a8131b7c978145134a1ff444cb639e" translate="yes" xml:space="preserve">
          <source>If we were to apply these states to a transition, it would look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498688a211069d7a5c4191f5c3fef214e9f67f92" translate="yes" xml:space="preserve">
          <source>If we're writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2fb212b41d06f075a5186ea4df933d818c54bc" translate="yes" xml:space="preserve">
          <source>If you already have the &lt;code&gt;tag&lt;/code&gt; prop defined in your Vue 2 code, like in the example above, everything will work as before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">如果还希望在节点的初始渲染上应用过渡，则可以添加 &lt;code&gt;appear&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">如果您是CSS-in-JS的粉丝，那么许多流行的CSS-in-JS库都支持Vue（例如，&lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt;和&lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;）。React和Vue之间的主要区别在于，Vue中的默认样式设置方法是通过&lt;a href=&quot;single-file-components&quot;&gt;单个文件组件中&lt;/a&gt;更熟悉的 &lt;code&gt;style&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">如果您是经验丰富的前端开发人员，并且想知道Vue与其他库/框架的&lt;a href=&quot;guide/comparison&quot;&gt;比较情况&lt;/a&gt;，请查看与其他框架的比较。</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">如果您正在开发一个大型项目,与其他开发人员合作,或者有时包含第三方HTML/CSS(例如来自Auth0),一致的范围将确保您的样式只适用于它们所要的组件。</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">如果您熟悉Virtual DOM概念并且更喜欢JavaScript的原始功能，则还可以&lt;a href=&quot;render-function&quot;&gt;直接&lt;/a&gt;使用可选的JSX支持来编写渲染函数而不是模板。</target>
        </trans-unit>
        <trans-unit id="4e11ad49faa82bff233bacdfdaea43495b37d7cb" translate="yes" xml:space="preserve">
          <source>If you are relying on this override functionality for &lt;code&gt;v-bind&lt;/code&gt;, we currently recommend ensuring that your &lt;code&gt;v-bind&lt;/code&gt; attribute is defined before individual properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f259b9cb4dd6eabd10bd96771a986250a3f5c4" translate="yes" xml:space="preserve">
          <source>If you are using Vue 2.x and below, you may be interested in some of the change detection caveats that exist for those versions, &lt;a href=&quot;change-detection&quot;&gt;explored in more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa108116f2ee5b4db44f6418ab708557dafa0b" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader (opens new window)&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">如果您使用的是Webpack，并且希望将JavaScript文件和模板文件分开，则可以使用&lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;，它还会在构建步骤中将模板文件转换为JavaScript渲染函数。</target>
        </trans-unit>
        <trans-unit id="b51a0d95775f6901a19eb4a518eb8294d6f3dd90" translate="yes" xml:space="preserve">
          <source>If you are using a custom Webpack configuration &lt;code&gt;ts-loader&lt;/code&gt; needs to be configured to parse &lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;/code&gt; blocks in &lt;code&gt;.vue&lt;/code&gt; files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9339c27c9dc6e2ed60dd362c87632e60f6c3e6b" translate="yes" xml:space="preserve">
          <source>If you are using filters that were globally registered and then used throughout your app, it's likely not convenient to replace them with computed properties or methods in each individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">如果您使用的是原生ES模块,也有一个ES模块兼容的构建。</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">如果使用基于模板的功能组件，则还必须手动添加属性和侦听器。由于我们可以访问各个上下文内容，因此可以使用 &lt;code&gt;data.attrs&lt;/code&gt; 传递任何HTML属性，并使用 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;（ &lt;code&gt;data.on&lt;/code&gt; 的别名）&lt;/em&gt;传递任何事件侦听器。</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是完整版本，即通过脚本标签直接包含Vue而没有构建工具，请确保使用 &lt;code&gt;vue.min.js&lt;/code&gt; 版本（vue.min.js）进行生产。可以在《&lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;安装指南》中&lt;/a&gt;找到这两个版本。</target>
        </trans-unit>
        <trans-unit id="5a4b189cf522ce6e29c54b33668d5386275afda1" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version for production. This can be found in the &lt;a href=&quot;../installation#cdn&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b60cd1fba6c46a688fbdbb235e044cb83c5b7b5" translate="yes" xml:space="preserve">
          <source>If you are using third party plugins such as &lt;code&gt;Vuex&lt;/code&gt; or &lt;code&gt;Vue Router&lt;/code&gt;, always check the documentation to know what that particular plugin expects to receive as a second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e4fd881ce2746ee5cbf62bd67517fc2f4914a1" translate="yes" xml:space="preserve">
          <source>If you bundle your app with webpack with &lt;code&gt;target: 'node'&lt;/code&gt; and properly externalize &lt;code&gt;vue&lt;/code&gt;, this is the build that will be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2fe8b591e825c2bd65db72f8f115e0c3a56502" translate="yes" xml:space="preserve">
          <source>If you didn't have one defined &lt;em&gt;and&lt;/em&gt; your styling or other behaviors relied on the presence of the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; root element to work properly, simply add &lt;code&gt;tag=&quot;span&quot;&lt;/code&gt; to the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb198153df2b83a6a3a26e2ebd225100fb4f2173" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want a component to automatically inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component's options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">如果您&lt;strong&gt;不&lt;/strong&gt;希望组件的根元素继承属性，则可以在组件的选项中设置 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">如果您未在data选项中声明 &lt;code&gt;message&lt;/code&gt; ，Vue将警告您渲染函数正在尝试访问不存在的属性。</target>
        </trans-unit>
        <trans-unit id="16f2472fe4831b78a6cfd9861a2ec950de0ec835" translate="yes" xml:space="preserve">
          <source>If you don't declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">如果您发现类型推断或成员完成不起作用，则注释某些方法可能有助于解决这些问题。使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 选项将帮助找到许多这些未注释的方法。</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">如果发现自己需要在Vue中强制进行更新，那么在99.99％的情况下，您在某个地方犯了一个错误。</target>
        </trans-unit>
        <trans-unit id="69e34e7997217094f6f692152e0f58e36b5ef7b7" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere. For example, you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt; property added after component creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">如果您碰巧在应用程序的性能至关重要的部分中使用了局部&lt;a href=&quot;render-function#Functional-Components&quot;&gt;函数&lt;/a&gt;，则应升级到功能组件。它们必须在普通的JS / JSX文件中（而不是在 &lt;code&gt;.vue&lt;/code&gt; 文件中），并且是无状态和无实例的，就像局部文件一样。这使得渲染非常快。</target>
        </trans-unit>
        <trans-unit id="a40b516039aedc82e1c9170530033902c12726ed" translate="yes" xml:space="preserve">
          <source>If you have a complex type or interface, you can cast it using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions&quot;&gt;type assertion (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">如果您对如何更好地参与当地的Vue社区有任何疑问，请访问&lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">如果您有任何测试，请运行它们，看看仍然失败。如果您没有测试，只需在浏览器中打开应用程序，并在浏览时注意警告或错误。</target>
        </trans-unit>
        <trans-unit id="96e155ed303418e4faa49bd76ee26339a7c63a25" translate="yes" xml:space="preserve">
          <source>If you inspect this element in your chrome developer tools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">如果你需要多个别名,你也可以使用数组语法。</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">如果您需要在实例化路由器后添加新路由，则可以用包含您要添加的路由的新路由替换匹配器：</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">如果您需要在客户端上编译模板（例如，将字符串传递给 &lt;code&gt;template&lt;/code&gt; 选项，或使用其in-DOM HTML作为模板安装到元素），则需要编译器，并因此需要完整的构建：</target>
        </trans-unit>
        <trans-unit id="ff7acc8749dfed6e4ff7f305eea543f1d2a84302" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the template option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c99f87095091faefdae01d0f1c8e79606b30cab" translate="yes" xml:space="preserve">
          <source>If you need to destructure your props, you can do this by utilizing the &lt;a href=&quot;reactivity-fundamentals#destructuring-reactive-state&quot;&gt;toRefs&lt;/a&gt; inside of the &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">如果您需要在启动应用程序时以编程方式生成路由,您可以通过动态推送定义到路由数组来实现。例如</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">如果需要错开列表过渡，则可以通过设置和访问元素上的 &lt;code&gt;data-index&lt;/code&gt; （或类似属性）来控制时序。&lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;在这里&lt;/a&gt;查看示例。</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">如果你只需要非常简单的路由,而不希望涉及到一个功能齐全的路由器库,你可以通过动态渲染一个像这样的页面级组件来实现。</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">如果再次打开JavaScript控制台并输入 &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; ，您将再次看到绑定的HTML（在本例中为 &lt;code&gt;title&lt;/code&gt; 属性）已更新。</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">如果在声明组件时更喜欢基于类的API，则可以使用正式维护的&lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt;装饰器：</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">如果您喜欢更具交互性的内容，还可以查看&lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;Scrimba上的本系列教程&lt;/a&gt;，其中提供了截屏视频和代码游乐场的组合，您可以随时暂停播放。</target>
        </trans-unit>
        <trans-unit id="026a80f81fcc351d7fe1000884a4c6e0166e6fc9" translate="yes" xml:space="preserve">
          <source>If you put the number two in the first cell, and the number 3 in the second and asked for the SUM, the spreadsheet would give it to you. No surprises there. But if you update that first number, the SUM automagically updates too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">如果确实需要重写另一个 &lt;code&gt;!important&lt;/code&gt; ，则必须使用字符串语法：</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">如果你真的想多次重复同一个元素/组件,你可以用工厂函数来实现。例如,下面的渲染函数是渲染20个相同段落的一个完全有效的方法。</target>
        </trans-unit>
        <trans-unit id="82b8fa8fd3b7f04299490484030ca94869913190" translate="yes" xml:space="preserve">
          <source>If you rely on watching array mutations, add the &lt;code&gt;deep&lt;/code&gt; property to ensure that your callback is triggered correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">如果你还想在回调里面调用一个unwatch函数,你应该先检查它的可用性。</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">但是，如果您在模板中尝试此操作，则Vue将显示错误，并解释&lt;strong&gt;每个组件必须具有单个root元素&lt;/strong&gt;。您可以通过将模板包装在父元素中来解决此错误，例如：</target>
        </trans-unit>
        <trans-unit id="14259c72550c39ee6e4f5a0f4cc02294d8e66215" translate="yes" xml:space="preserve">
          <source>If you use a module bundle like webpack, this may cause Vue&amp;rsquo;s source code to be bundled into the plugin, and more often than not that&amp;rsquo;s not what you'd expect. A common practice to prevent this from happening is to configure the module bundler to exclude Vue from the final bundle. In webpack's case, you can use the &lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot;&gt;&lt;code&gt;externals&lt;/code&gt; (opens new window)&lt;/a&gt; configuration option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">如果你在你的模板中使用了任何非Vue的自定义元素,比如一个网页组件,PascalCase可以确保你的Vue组件保持明显的可见性。</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">如果你想胁迫一个道具,可以根据它设置一个本地计算值来代替。例如,代替。</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">如果您想直接进入并开始使用单文件组件，请在CodeSandbox上查看&lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;这个简单的待办事项应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19c4d2e8e9b44f23f256752921c6f56b3515e01e" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/vue-todo-list-app-with-single-file-component-vzkl3?file=/src/App.vue&quot;&gt;this simple todo app (opens new window)&lt;/a&gt; on CodeSandbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221bedd32adb2426b2b5127135897cde8d509422" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">如果你想传递一个对象作为道具的所有属性，可以使用 &lt;code&gt;v-bind&lt;/code&gt; 不带参数（ &lt;code&gt;v-bind&lt;/code&gt; ，而不是 &lt;code&gt;v-bind:prop-name&lt;/code&gt; ）。例如，给定一个 &lt;code&gt;post&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">如果要改为在本地注册指令，则组件也可以接受 &lt;code&gt;directives&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">如果希望用户输入自动以数字形式转换，则可以将 &lt;code&gt;number&lt;/code&gt; 修饰符添加到 &lt;code&gt;v-model&lt;/code&gt; 托管输入中：</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">如果要自动修剪用户输入中的空格，可以将 &lt;code&gt;trim&lt;/code&gt; 修饰符添加到 &lt;code&gt;v-model&lt;/code&gt; 管理的输入中：</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">如果以前在组件更新后依靠 &lt;code&gt;vm.$watch&lt;/code&gt; 对DOM进行操作，则可以在 &lt;code&gt;updated&lt;/code&gt; 生命周期挂钩中执行。</target>
        </trans-unit>
        <trans-unit id="43daed9c097353737805c1bf2ab9ef52cfa52fb5" translate="yes" xml:space="preserve">
          <source>If you wish to hardware-accelerate an element, you can apply any of these properties (not all are necessary, only one):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">如果你想在列表中有条件地切换一个类,你可以用三元表达式来实现。</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">如果您想在潜水之前了解有关Vue的更多信息，我们创建了一段视频，介绍了核心原则和示例项目。</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">如果您是想要使用异步组件的&lt;strong&gt;Browserify&lt;/strong&gt;用户，那么不幸的&lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;是&lt;/a&gt;，其创建者已经明确表明异步加载&amp;ldquo;不是Browserify永远不会支持的东西&amp;rdquo;。至少在官方上。 Browserify社区发现了&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;一些变通办法&lt;/a&gt;，这可能对现有和复杂的应用程序有所帮​​助。对于所有其他情况，我们建议使用Webpack以获得内置的一流的异步支持。</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">如果您来自React，那么您可能想知道vuex与该生态系统中最流行的Flux实现&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;相比如何。Redux实际上是与视图层无关的，因此可以通过&lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;简单的绑定&lt;/a&gt;轻松地与Vue一起使用。Vuex的不同之处在于它&lt;em&gt;知道&lt;/em&gt;它在Vue应用程序中。这使它可以更好地与Vue集成，从而提供更直观的API和改进的开发体验。</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">如果您不小心，则递归组件也可能导致无限循环：</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">如果您不使用带有 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; 的模块系统，则可能现在可以跳过本节。如果您是，我们将为您提供一些特殊的说明和提示。</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">如果您还不熟悉Vue的组件，则可以暂时跳过此步骤。</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">如果您仍然在这里，则可能是您正在使用模块系统，例如Babel和Webpack。在这些情况下，我们建议创建一个 &lt;code&gt;components&lt;/code&gt; 目录，每个组件都在其自己的文件中。</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">如果您要编写很多 &lt;code&gt;render&lt;/code&gt; 函数，那么编写如下代码可能会很痛苦：</target>
        </trans-unit>
        <trans-unit id="609a6f861acf12bf2b5f3b2a6f3ec765be8efafd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever had to manually manipulate DOM in Vue, you might have come across this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ecc2bc675d03a98476e9bf350d5918a55d45a0" translate="yes" xml:space="preserve">
          <source>If you're coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux (opens new window)&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings (opens new window)&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4383a33376cb43b8f9f3a34ad4ebc3a22a32fdbb" translate="yes" xml:space="preserve">
          <source>If you're not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d391b26209861300899a2add1af08ef09f4194f8" translate="yes" xml:space="preserve">
          <source>If you're not yet familiar with Vue's components, you can skip this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913e0a49efe5be77ae2656044ce4cc773b612ae8" translate="yes" xml:space="preserve">
          <source>If you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f123dacf3d9e21f599eddd3ec553d8bc240c00ee" translate="yes" xml:space="preserve">
          <source>If you're using a &lt;a href=&quot;../installation#cdn&quot;&gt;CDN&lt;/a&gt; build of Vue then &lt;code&gt;createApp&lt;/code&gt; is exposed via the global &lt;code&gt;Vue&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256d7614924d2b75c2300fd933e837e95c0b7657" translate="yes" xml:space="preserve">
          <source>If your component has multiple root elements, you would need to define which component will receive this class. You can do this using &lt;code&gt;$attrs&lt;/code&gt; component property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">如果你的指令需要多个值,你也可以传入一个JavaScript对象文字。记住,指令可以采用任何有效的JavaScript表达式。</target>
        </trans-unit>
        <trans-unit id="242aaacd829f9f99856dd2793dfdfc9507666410" translate="yes" xml:space="preserve">
          <source>If your module bundler of choice happens to be &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup (opens new window)&lt;/a&gt;, you basically get the same effect for free, as by default Rollup will treat absolute module IDs (&lt;code&gt;'vue'&lt;/code&gt; in our case) as external dependencies and not include them in the final bundle. During bundling though, it might emit a &lt;a href=&quot;https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency&quot;&gt;&amp;ldquo;Treating vue as external dependency&amp;rdquo; (opens new window)&lt;/a&gt; warning, which can be suppressed with the &lt;code&gt;external&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a721aa3beb5717086550f15e05596fdcd9ca355" translate="yes" xml:space="preserve">
          <source>If your plugin relies on an affected Vue 2.x global API, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8119918563dea634ba032ddd3981c094251dbb90" translate="yes" xml:space="preserve">
          <source>Imagine the case where we have a standalone primitive value (for example, a string) and we want to make it reactive. Of course, we could make an object with a single property equal to our string, and pass it to &lt;code&gt;reactive&lt;/code&gt;. Vue has a method that will do the same for us - it's a &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">想象一下，这是 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 的模板：</target>
        </trans-unit>
        <trans-unit id="b5a9cca298c2ad31236d51c99a03c78bea9e1757" translate="yes" xml:space="preserve">
          <source>Implementation-wise &lt;code&gt;defineComponent&lt;/code&gt; does nothing but return the object passed to it. However, in terms of typing, the returned value has a synthetic type of a constructor for manual render function, TSX and IDE tooling support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">亲子间的隐性沟通</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;谨慎使用&lt;/sup&gt;隐式的亲子沟通&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="28826b0d2e02701105ec50963d8f7e90554a6576" translate="yes" xml:space="preserve">
          <source>Import it as a &lt;a href=&quot;#cdn&quot;&gt;CDN package&lt;/a&gt; on the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9992581d590be676f25bb4ed76a8393ef92057e" translate="yes" xml:space="preserve">
          <source>Imported dependencies are also esm-bundler builds and will in turn import their dependencies (e.g. @vue/runtime-core imports @vue/reactivity)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836e63c09fd6ddabcf1825ec759e9e296d10a1ec" translate="yes" xml:space="preserve">
          <source>Imports dependencies (e.g. &lt;code&gt;@vue/runtime-core&lt;/code&gt;, &lt;code&gt;@vue/runtime-compiler&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5200b178a45fe7d68a514c32e5d600863251de0" translate="yes" xml:space="preserve">
          <source>In 2.2 we introduced the &lt;code&gt;model&lt;/code&gt; component option that allows the component to customize the prop and event to use for &lt;code&gt;v-model&lt;/code&gt;. However, this still only allowed a single &lt;code&gt;v-model&lt;/code&gt; to be used on the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">在2.2.0+及更高版本中， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 树中的所有嵌套组件都将 &lt;code&gt;activated&lt;/code&gt; 和 &lt;code&gt;deactivated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">在2.2.0+中，此挂钩还捕获组件生命周期挂钩中的错误。另外，当此钩子 &lt;code&gt;undefined&lt;/code&gt; ，捕获的错误将通过 &lt;code&gt;console.error&lt;/code&gt; 记录下来，而不是使应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">在2.2.0+中，当 &lt;code&gt;v-for&lt;/code&gt; 组件使用v-for时，现在需要一个&lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">在2.4.0+中,这个钩子还可以捕获Vue自定义事件处理程序中抛出的错误。</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">在2.5.0+中,注入可以是可选的,默认值。</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">在2.5.0+中，如果使用&lt;a href=&quot;single-file-components&quot;&gt;单文件组件&lt;/a&gt;，则可以使用以下方法声明基于模板的功能组件：</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">在2.6+中， &lt;code&gt;v-for&lt;/code&gt; 也可以处理实现&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol的&lt;/a&gt;值，包括本地 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 。但是，应注意，Vue 2.x当前不支持对 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 值的反应性，因此无法自动检测更改。</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">在2.6.0+中，此挂钩还捕获了 &lt;code&gt;v-on&lt;/code&gt; DOM侦听器内部引发的错误。此外，如果任何涵盖的钩子或处理程序返回了Promise链（例如，异步函数），则该Promise链中的错误也将得到处理。</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">在2.6.0中，我们为命名插槽和作用域插槽引入了新的统一语法（ &lt;code&gt;v-slot&lt;/code&gt; 指令）。它取代了 &lt;code&gt;slot&lt;/code&gt; 和 &lt;code&gt;slot-scope&lt;/code&gt; 属性，这些属性现在已经过时，但都&lt;em&gt;没有&lt;/em&gt;被删除，仍然记录&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;在这里&lt;/a&gt;。在此&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC中&lt;/a&gt;介绍了引入新语法的原理。</target>
        </trans-unit>
        <trans-unit id="256728aff9fb16c0f4d2df842f2c3e5ad55c5e9b" translate="yes" xml:space="preserve">
          <source>In 2.x, &lt;code&gt;domProps&lt;/code&gt; contained a nested list within the VNode props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ccc8617c6c0b63bdc2bf15b8a89fb2407da706" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue instance could be used to trigger handlers attached imperatively via the event emitter API (&lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt;). This was used to create &lt;em&gt;event hubs&lt;/em&gt; to create global event listeners used across the whole application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dd1fdaef79b3831922864fd8d39f0ad9deb676" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue provided the &lt;code&gt;inline-template&lt;/code&gt; attribute on child components to use its inner content as its template instead of treating it as distributed content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2328f43db77fe0efd8f47e998984f47eac46ba" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could access direct child components of the current instance with &lt;code&gt;this.$children&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9424ae231a6fda6ed873b7a8e6ae8e39088d9d" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could define the &lt;code&gt;data&lt;/code&gt; option with either an &lt;code&gt;object&lt;/code&gt; or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dd71f6a7a373cd112dab134b7ff3db3d648f20" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could use filters in order to apply common text formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7063d13de2f5ae058926813bdf953c4a105676c" translate="yes" xml:space="preserve">
          <source>In 2.x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the individual property would always overwrite bindings in the &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea559fa1a9771817cc8e8333085080656e09848" translate="yes" xml:space="preserve">
          <source>In 2.x, invalid values were coerced to &lt;code&gt;'true'&lt;/code&gt; for enumerated attributes. This was usually unintended and unlikely to be relied upon on a large scale. In 3.x &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;'true'&lt;/code&gt; should be explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69daab13ee1934deef652bdaaf6f2e3de088df88" translate="yes" xml:space="preserve">
          <source>In 2.x, multi-root components were not supported and would emit a warning when a user accidentally created one. As a result, many components are wrapped in a single &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in order to fix this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd9ee258c65347ba2ff8b78a2b85cee0fc8e414" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function automatically received arguments such as &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d01321951def977b78828f17cb248ccea9ad7" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function would automatically receive the &lt;code&gt;h&lt;/code&gt; function (which is a conventional alias for &lt;code&gt;createElement&lt;/code&gt;) as an argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9729a27f715ad913ceb2a7d973c83313e4f3c50f" translate="yes" xml:space="preserve">
          <source>In 2.x, using a &lt;code&gt;v-model&lt;/code&gt; on a component was an equivalent of passing a &lt;code&gt;value&lt;/code&gt; prop and emitting an &lt;code&gt;input&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46afcbced92e335f7123d55a58b836b7295afd1d" translate="yes" xml:space="preserve">
          <source>In 2.x, we had the following strategies for coercing &lt;code&gt;v-bind&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5a25ed12428fc14990ccb2e9c191fa49adb981" translate="yes" xml:space="preserve">
          <source>In 2.x, when a component has been registered, the render function would work well when passing the component's name as a string to the first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe8f6026316d3a73f1bd42ee8c89d43dee6ad5b" translate="yes" xml:space="preserve">
          <source>In 2.x, when using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; on the same element, &lt;code&gt;v-for&lt;/code&gt; would take precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2fe7a68d07b5928c0025bf237e90e00d49b1ff" translate="yes" xml:space="preserve">
          <source>In 3.0, the result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d272f52a84ee8fe9eda14c5af6c7e7e9aea55cf" translate="yes" xml:space="preserve">
          <source>In 3.0, we are limiting Vue's special treatment of the &lt;code&gt;is&lt;/code&gt; prop to the &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03706ae0b18cf04d0e1184566cc22dd43bd8796" translate="yes" xml:space="preserve">
          <source>In 3.x &lt;code&gt;v-model&lt;/code&gt; on the custom component is an equivalent of passing a &lt;code&gt;modelValue&lt;/code&gt; prop and emitting an &lt;code&gt;update:modelValue&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaffa537c62e5c878c892ad624027bd74bf34114" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;h&lt;/code&gt; is now globally imported instead of being automatically passed as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cbfb34fe6f9b877113b6bdc0dd73e927141d87" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; should be used to explicitly remove an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bef6847fad523068826498b632dcae11c29c52" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;v-if&lt;/code&gt; will always have the higher precedence than &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c1b7ac08bfa5b7cc8606dcd35f2331e4abc8e3" translate="yes" xml:space="preserve">
          <source>In 3.x, components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af3acd686b51e5d6705eac439e47596866c1ce8" translate="yes" xml:space="preserve">
          <source>In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53eba82a86ea2e9f0b2f6f6cfedb74733b2d04f" translate="yes" xml:space="preserve">
          <source>In 3.x, since the &lt;code&gt;render&lt;/code&gt; function no longer receives any arguments, it will primarily be used inside of the &lt;code&gt;setup()&lt;/code&gt; function. This has the added benefit of gaining access to reactive state and functions declared in scope, as well as the arguments passed to &lt;code&gt;setup()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46410326ff00ce7f5b9a576648a6b047f922589a" translate="yes" xml:space="preserve">
          <source>In 3.x, slots are defined as children of the current node as an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a39c3c93b98afd50fbd7886344976a75f0114a1" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;$children&lt;/code&gt; property is removed and no longer supported. Instead, if you need to access a child component instance, we recommend using &lt;a href=&quot;../component-template-refs#template-refs&quot;&gt;$refs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4eb8d2b66bb84443ed0a747129452a3b8f78766" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;data&lt;/code&gt; option has been standardized to only accept a &lt;code&gt;function&lt;/code&gt; that returns an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0577d8ad30ab5a25ec81d48069dddfe6636d8797" translate="yes" xml:space="preserve">
          <source>In 3.x, the entire VNode props structure is flattened. Using the example from above, here is what it would look like now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c698a95795682a639eda0b4dab592ffcd0ccbfd" translate="yes" xml:space="preserve">
          <source>In 3.x, the performance difference between stateful and functional components has been drastically reduced and will be insignificant in most use cases. As a result, the migration path for developers using &lt;code&gt;functional&lt;/code&gt; on SFCs is to remove the attribute and rename all references of &lt;code&gt;props&lt;/code&gt; to &lt;code&gt;$props&lt;/code&gt; and &lt;code&gt;attrs&lt;/code&gt; to &lt;code&gt;$attrs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b6c70c99847e99bd40a423d7f7e30f14d0d1e" translate="yes" xml:space="preserve">
          <source>In 3.x, with VNodes being context-free, we can no longer use a string ID to implicitly lookup registered components. Instead, we need to use an imported &lt;code&gt;resolveComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1649eb8974b30107ef48d872705e3f78ccfacc0f" translate="yes" xml:space="preserve">
          <source>In 3x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the order of how the bindings are declared determines how they are merged. In other words, rather than assuming developers want the individual property to always override what is defined in the &lt;code&gt;object&lt;/code&gt;, developers now have more control over the desired merging behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feb4596eedd196dbf2408c8aca99b22823b66c2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue's template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">在&lt;a href=&quot;../guide/single-file-components&quot;&gt;单文件组件中&lt;/a&gt;， &lt;code&gt;scoped&lt;/code&gt; 样式将不适用于 &lt;code&gt;v-html&lt;/code&gt; 内的内容，因为Vue的模板编译器不会处理HTML。如果要使用范围限定的CSS 定位 &lt;code&gt;v-html&lt;/code&gt; 内容，则可以改用&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS模块&lt;/a&gt;或其他具有手动作用域策略（例如BEM）的全局 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">在JavaScript中,PascalCase是类和原型构造函数的惯例--本质上,任何可以有不同实例的东西。Vue组件也有实例,所以使用PascalCase也是有意义的。另外一个好处是,在JSX(和模板)中使用PascalCase可以让代码的读者更容易区分组件和HTML元素。</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">在JavaScript中，将具有多个属性的对象拆分为多行被广泛认为是一个好习惯，因为它更容易阅读。我们的模板和&lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt;应该得到同样的考虑。</target>
        </trans-unit>
        <trans-unit id="c13d73a2ddf37e7463ec10f8ded7afc62e432e0e" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#jsx&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1511320f9fca1ecdb726d3628235620054c333a" translate="yes" xml:space="preserve">
          <source>In Object-based syntax, the value of each property can either be &lt;code&gt;null&lt;/code&gt; or a validator function. The validation function will receive the additional arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call. For example, if &lt;code&gt;this.$emit('foo', 1)&lt;/code&gt; is called, the corresponding validator for &lt;code&gt;foo&lt;/code&gt; will receive the argument &lt;code&gt;1&lt;/code&gt;. The validator function should return a boolean to indicate whether the event arguments are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">在Polymer中,为了弥补性能的不足,团队还将其数据绑定系统做了非常大的限制。例如,Polymer模板中支持的表达式只有布尔否定和单方法调用。其计算属性的实现也不是很灵活。</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">在React中,所有组件都在渲染函数中使用JSX表达其UI,JSX是一种类似XML的声明式语法,在JavaScript中工作。</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">在React中,一切都只是JavaScript。不仅HTML结构通过JSX来表达,最近的趋势也倾向于把CSS管理也放在JavaScript里面。这种方法有其自身的好处,但也有各种权衡,似乎并不是每个开发者都值得。</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">在React中，当组件的状态改变时，它会触发整个组件子树的重新渲染，从该组件的根目录开始。为了避免不必要地重新渲染子组件，您需要尽可能使用 &lt;code&gt;PureComponent&lt;/code&gt; 或实现 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 。您可能还需要使用不可变的数据结构，以使状态更改更加优化。但是，在某些情况下，您可能无法依靠这种优化，因为 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; 假定整个子树的渲染输出由当前组件的属性决定。如果不是这种情况，那么这种优化可能会导致DOM状态不一致。</target>
        </trans-unit>
        <trans-unit id="2cfb65095765445c51ed3990754a7aea8c4e09af" translate="yes" xml:space="preserve">
          <source>In Vue 2 we recommended working around with these restrictions by using the &lt;code&gt;is&lt;/code&gt; prop on a native tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d17b0d924f04ce8ace3de17c7feceb2d55c631" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;, like other custom components, needed a root element, which by default was a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; but was customizable via the &lt;code&gt;tag&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eee5e53bb1e22d2f1df0e9f8eff653441f88183" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;Vue.prototype&lt;/code&gt; was commonly used to add properties that would be accessible in all components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623539054d5afbfeafa88a7593570669aa7a26b8" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;keyCodes&lt;/code&gt; were supported as a way to modify a &lt;code&gt;v-on&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714deb450dd9f768ce9fb1850ea76c03a9c0b8ff" translate="yes" xml:space="preserve">
          <source>In Vue 2, custom directives were created by using the hooks listed below to target an element&amp;rsquo;s lifecycle, all of which are optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427f3cc45180bf04421bacb75902b51bf88d889a" translate="yes" xml:space="preserve">
          <source>In Vue 2, functional components had two primary use cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4027dc7058f32b3afa9b989de298f0e1274c6387" translate="yes" xml:space="preserve">
          <source>In Vue 2, mixins were the primary tool to abstract parts of component logic into reusable chunks. However, they have a few issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49b054972b109d8d92e090576574f314196d960" translate="yes" xml:space="preserve">
          <source>In Vue 2, the component instance had to be accessed through the &lt;code&gt;vnode&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf60ceefe843452e7ace61c7f5d7fb5a10e2c5" translate="yes" xml:space="preserve">
          <source>In Vue 2, using the &lt;code&gt;ref&lt;/code&gt; attribute inside &lt;code&gt;v-for&lt;/code&gt; will populate the corresponding &lt;code&gt;$refs&lt;/code&gt; property with an array of refs. This behavior becomes ambiguous and inefficient when there are nested &lt;code&gt;v-for&lt;/code&gt;s present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a36b69d1b9520442812684a11396300f78b7ba" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can access attributes passed to your components with &lt;code&gt;this.$attrs&lt;/code&gt;, and event listeners with &lt;code&gt;this.$listeners&lt;/code&gt;. In combination with &lt;code&gt;inheritAttrs: false&lt;/code&gt;, they allow the developer to apply these attributes and listeners to some other element instead of the root element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d3795b44e395241dad3f754562828449a79603" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can define the props that a component receives, but you can't declare which events it can emit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">在Vue 2.x中， &lt;code&gt;Vue.observable&lt;/code&gt; 直接更改传递给它的对象，因此它等效于返回的对象，如此处&lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;所示&lt;/a&gt;。在Vue 3.x中，将改为返回反应式代理，如果直接突变，则使原始对象不反应。因此，为了将来的兼容性，建议始终使用 &lt;code&gt;Vue.observable&lt;/code&gt; 返回的对象，而不是最初传递给它的对象。</target>
        </trans-unit>
        <trans-unit id="04a1b8d86ca382e0241c1abe50e3ee3fb8996f94" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag could not have a &lt;code&gt;key&lt;/code&gt;. Instead, you could place the &lt;code&gt;key&lt;/code&gt;s on each of its children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cb196394bb87ca2a8e06b2510d6358e84a7776" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, application root container's &lt;code&gt;outerHTML&lt;/code&gt; is replaced with root component template (or eventually compiled to a template, if root component has no template/render option). Vue 3.x now uses application container's &lt;code&gt;innerHTML&lt;/code&gt; instead - this means the container itself is no longer considered part of the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ecd8d4cc17aab927b205f633e4d33dda883445" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, it was recommended to use &lt;code&gt;key&lt;/code&gt;s on &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d36ea70a8bf1cfdc715d58ac1911e3fd754fa1" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, the resulting &lt;code&gt;$data&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61abdd8d6816689fd4d5efd6b7f0f6d0421fa89e" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, whitelisting tags as custom elements was done via &lt;code&gt;Vue.config.ignoredElements&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a2d802b261d3390a36b39b1e88da6952ae1bfe" translate="yes" xml:space="preserve">
          <source>In Vue 3's virtual DOM, event listeners are now just attributes, prefixed with &lt;code&gt;on&lt;/code&gt;, and as such are part of the &lt;code&gt;$attrs&lt;/code&gt; object, so &lt;code&gt;$listeners&lt;/code&gt; has been removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8ffd46210564bab462dab866e0a61658c85fd" translate="yes" xml:space="preserve">
          <source>In Vue 3, APIs that globally mutate Vue's behavior are now moved to application instances created by the new &lt;code&gt;createApp&lt;/code&gt; method. In addition, their effects are now scoped to that specific application's instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724f98bfd4825d659b3ef73bec24c9d1b1bd8450" translate="yes" xml:space="preserve">
          <source>In Vue 3, components now have official support for multi-root node components, i.e., fragments!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3d29f7ef97ea630c136e861259ef7779f3f469" translate="yes" xml:space="preserve">
          <source>In Vue 3, however, we&amp;rsquo;ve created a more cohesive API for custom directives. As you can see, they differ greatly from our component lifecycle methods even though we&amp;rsquo;re hooking into similar events. We&amp;rsquo;ve now unified them like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6331f262fcf12a91763745c6aeed71d9b733b3c" translate="yes" xml:space="preserve">
          <source>In Vue 3, such usage will no longer automatically create an array in &lt;code&gt;$refs&lt;/code&gt;. To retrieve multiple refs from a single binding, bind &lt;code&gt;ref&lt;/code&gt; to a function which provides more flexibility (this is a new feature):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ecfbda9c9364a4d1cfde77270eb84b68591725" translate="yes" xml:space="preserve">
          <source>In Vue 3, the check of whether an element is a component or not has been moved to the template compilation phase, therefore this config option is only respected when using the runtime compiler. If you are using the runtime-only build, &lt;code&gt;isCustomElement&lt;/code&gt; must be passed to &lt;code&gt;@vue/compiler-dom&lt;/code&gt; in the build setup instead - for example, via the &lt;a href=&quot;https://vue-loader.vuejs.org/options.html#compileroptions&quot;&gt;&lt;code&gt;compilerOptions&lt;/code&gt; option in vue-loader (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b845930e81b44f047a329d5c6204f7f931bd74" translate="yes" xml:space="preserve">
          <source>In Vue 3, the global and internal APIs have been restructured with tree-shaking support in mind. As a result, the global APIs can now only be accessed as named exports for the ES Modules build. For example, our previous snippets should now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e9367bc712cd5e99e214445d49ec8f87dc977" translate="yes" xml:space="preserve">
          <source>In Vue 3, the instance is now part of the &lt;code&gt;binding&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73645e0f3791358bf3f0d6ad20122b90a31ffd47" translate="yes" xml:space="preserve">
          <source>In Vue 3, we have &lt;a href=&quot;fragments&quot;&gt;fragment support&lt;/a&gt;, so components no longer &lt;em&gt;need&lt;/em&gt; a root node. Consequently, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; no longer renders one by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7bdcdf994f4cc1a00dd74f8f22ad2f859a405b" translate="yes" xml:space="preserve">
          <source>In Vue 3, you&amp;rsquo;ll have to import it explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2bc8b0bef1be017e069553012e806d6ad3eeb6" translate="yes" xml:space="preserve">
          <source>In Vue 3.0 we can make any variable reactive anywhere with a new &lt;code&gt;ref&lt;/code&gt; function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1261249a8779a24fb5636b8856b66bfb7e4d50aa" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &quot;use production build&quot; tip will only show up when using the &quot;dev + full build&quot; (the build that includes the runtime compiler and has warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9927c60d35977a34e50e99413e889e84532170" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &lt;code&gt;key&lt;/code&gt; should be placed on the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">在Vue中,一个组件本质上是一个具有预定义选项的Vue实例。在Vue中注册一个组件是很直接的。</target>
        </trans-unit>
        <trans-unit id="9c55128700791de0665f1315237d38efdb9e6612" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially an instance with pre-defined options. Registering a component in Vue is straightforward: we create a component object as we did with &lt;code&gt;App&lt;/code&gt; objects and we define it in parent's &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">在Vue中，在渲染过程中会自动跟踪组件的依赖关系，因此系统可以准确地知道状态更改时实际需要重新渲染哪些组件。可以认为每个组件都为您自动实现了 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ，而没有嵌套的组件警告。</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">在Vue中，我们还具有&lt;a href=&quot;render-function&quot;&gt;渲染功能&lt;/a&gt;，甚至还&lt;a href=&quot;render-function#JSX&quot;&gt;支持JSX&lt;/a&gt;，因为有时您确实需要这种功能。但是，作为默认体验，我们提供模板作为更简单的选择。任何有效的HTML也是有效的Vue模板，这将带来其自身的一些优点：</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">在Webpack 4+中，可以使用 &lt;code&gt;mode&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="d4f0bbfd3f2e8bb6462aabfac3883c560be6e8a5" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/component-basics&quot;&gt;later in the guide&lt;/a&gt;, but here's an (imaginary) example of what an app's template might look like with components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">在大型应用程序中，有必要将整个应用程序划分为多个组件以使开发易于管理。我们将&lt;a href=&quot;guide/components&quot;&gt;在本指南的后面&lt;/a&gt;部分讨论有关组件的更多信息，但这是一个（虚构的）示例，该示例显示了应用程序模板与组件的外观：</target>
        </trans-unit>
        <trans-unit id="cce007380584fe599b155e880cbf38a37b8c5865" translate="yes" xml:space="preserve">
          <source>In a template it can be useful to use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag to hold a &lt;code&gt;v-if&lt;/code&gt; or &lt;code&gt;v-for&lt;/code&gt; directive. When migrating to a &lt;code&gt;render&lt;/code&gt; function, the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag is no longer required and can be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">但是，在典型的应用中， &lt;code&gt;data&lt;/code&gt; 可能会有一系列的帖子：</target>
        </trans-unit>
        <trans-unit id="1f0341aaa53b971cc7f7cd6eab8ea717e277b0a1" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you'll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8dde57e2c8045db642f017abe87ff72fbc20c" translate="yes" xml:space="preserve">
          <source>In addition to 2.x hard-coded &lt;code&gt;v-model&lt;/code&gt; modifiers like &lt;code&gt;.trim&lt;/code&gt;, now 3.x supports custom modifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">除了数据属性外，Vue实例还公开了许多有用的实例属性和方法。它们以 &lt;code&gt;$&lt;/code&gt; 开头，以区别于用户定义的属性。例如：</target>
        </trans-unit>
        <trans-unit id="30b7afc0333bb298c35216e487d1e9e77e4192ca" translate="yes" xml:space="preserve">
          <source>In addition to public APIs, many of the internal components/helpers are now exported as named exports as well. This allows the compiler to output code that only imports features when they are used. For example the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">除了文本插值,我们还可以这样绑定元素属性。</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">除了 &lt;code&gt;watch&lt;/code&gt; 选项之外，您还可以使用命令&lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm。$ watch API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5150e3e352b277b1ba1aa7eeef457bb44d050905" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/instance-methods#watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">除了核心附带的默认指令集（ &lt;code&gt;v-model&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; ）之外，Vue还允许您注册自己的自定义指令。请注意，在Vue 2.0中，代码重用和抽象的主要形式是组件-但是，在某些情况下，您可能需要在普通元素上进行一些低级DOM访问，而这正是自定义指令仍然有用的地方。一个示例将重点放在输入元素上，例如：</target>
        </trans-unit>
        <trans-unit id="0565e3d1e3c82f3b31c0ab6ec47170e5dc305765" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (like &lt;code&gt;v-model&lt;/code&gt; or &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue, the primary form of code reuse and abstraction is components - however, there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">另外， &lt;code&gt;type&lt;/code&gt; 也可以是自定义构造函数，并且断言将通过 &lt;code&gt;instanceof&lt;/code&gt; 检查来进行。例如，假设存在以下构造函数：</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">此外,每个实例/组件仍然可以拥有和管理自己的私有状态。</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">此外，每次更新父组件时，子组件中的所有道具都会以最新值刷新。这意味着你应该&lt;strong&gt;不是&lt;/strong&gt;试图突变子组件内的道具。如果您这样做，Vue将在控制台中警告您。</target>
        </trans-unit>
        <trans-unit id="b81d142d3c922310cfbb8a89684dac0a487a2272" translate="yes" xml:space="preserve">
          <source>In addition, rather than implicitly provide &lt;code&gt;h&lt;/code&gt; in a &lt;code&gt;render&lt;/code&gt; function, &lt;code&gt;h&lt;/code&gt; is now imported globally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85215d9d308bd40086a0e1662ab21ebbec8c5c6d" translate="yes" xml:space="preserve">
          <source>In addition, since the &lt;code&gt;createApp&lt;/code&gt; method returns the application instance itself, you can chain other methods after it which can be found in the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65713f74baf60786834c58f72d45052056f1fa2d" translate="yes" xml:space="preserve">
          <source>In addition, unlike 2.x, the loader function no longer receives the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must always return a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21451e63b33f7fd3f9f0613a2eed3c9fd082315c" translate="yes" xml:space="preserve">
          <source>In addition, when &lt;code&gt;data()&lt;/code&gt; from a component and its mixins or extends base are merged, the merge is now performed &lt;em&gt;shallowly&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3636deb3b0c4953ecaa1f52798bd8dc37c3b5533" translate="yes" xml:space="preserve">
          <source>In addition, when referencing scoped slots, they could be referenced using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5985a88954adf2a60500ab64ac8c41d6f599d628" translate="yes" xml:space="preserve">
          <source>In addition, you could define your own aliases via the global &lt;code&gt;config.keyCodes&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">万一您还没有注意到，Vue &lt;strong&gt;异步&lt;/strong&gt;执行DOM更新。每当观察到数据更改时，它将打开队列并缓冲在同一事件循环中发生的所有数据更改。如果多次触发同一观察者，则它将仅被推入队列一次。这种缓冲的重复数据删除对于避免不必要的计算和DOM操作非常重要。然后，在下一个事件循环&amp;ldquo;滴答&amp;rdquo;中，Vue刷新队列并执行实际的（已删除重复数据）工作。 Vue在内部尝试使用本机 &lt;code&gt;Promise.then&lt;/code&gt; ， &lt;code&gt;MutationObserver&lt;/code&gt; 和 &lt;code&gt;setImmediate&lt;/code&gt; 进行异步排队，然后回退到 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="613464b2036a68a6ebb2b0e396760bb7f079d24b" translate="yes" xml:space="preserve">
          <source>In case you haven't noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &quot;tick&quot;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cd65af0c1ac7f1a471b3ebe14997d44c5a24c9" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader (opens new window)&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;webpack learning academy (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">如果您希望从头开始设置自己的构建设置，则需要使用&lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;手动配置webpack 。要了解有关webpack本身的更多信息，请查看&lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;其官方文档&lt;/a&gt;和&lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">在上述情况下，当&lt;em&gt;仅&lt;/em&gt;提供默认插槽的内容时，组件的标签可以用作插槽的模板。这使我们可以直接在组件上使用 &lt;code&gt;v-slot&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="afdc559a28e8fc0df8af77b29c0a99f33040dfa0" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">在这样的情况下，我们可以标记组件 &lt;code&gt;functional&lt;/code&gt; ，这意味着它们是无状态（无&lt;a href=&quot;../api/index#Options-Data&quot;&gt;反应数据&lt;/a&gt;）和instanceless（没有 &lt;code&gt;this&lt;/code&gt; 方面）。一个&lt;strong&gt;功能组件&lt;/strong&gt;如下所示：</target>
        </trans-unit>
        <trans-unit id="fa13d1c0d73e56359fd93a07fd88a5c686b9d9da" translate="yes" xml:space="preserve">
          <source>In cases where a component is only used once, the debouncing can be applied directly within &lt;code&gt;methods&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afbf4c975278f424bbb47c6b13d6c21a3be2dbb" translate="yes" xml:space="preserve">
          <source>In cases where a watcher effect needs to be re-run &lt;strong&gt;after&lt;/strong&gt; component updates (i.e. when working with &lt;a href=&quot;composition-api-template-refs#watching-template-refs&quot;&gt;Template Refs&lt;/a&gt;), we can pass an additional &lt;code&gt;options&lt;/code&gt; object with the &lt;code&gt;flush&lt;/code&gt; option (default is &lt;code&gt;'pre'&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">在提交的代码中,道具定义应该尽可能详细,至少要指定类型。</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">相比之下， &lt;code&gt;v-show&lt;/code&gt; 要简单得多-不论初始条件如何，都始终使用基于CSS的切换来呈现元素。</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">相比之下，每当重新渲染发生时，方法调用将&lt;strong&gt;始终&lt;/strong&gt;运行该函数。</target>
        </trans-unit>
        <trans-unit id="bb1736ea3b5962d2582e096afba361a049ac9d2c" translate="yes" xml:space="preserve">
          <source>In components that use &lt;code&gt;inheritAttrs: false&lt;/code&gt;, make sure that styling still works as intended. If you previously relied on the special behavior of &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, some visuals might be broken as these attributes might now be applied to another element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">在开发过程中,如果一个组件曾经被提供了不正确的格式化道具,Vue会向你发出警告,帮助你发现潜在的错误来源。</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">在 &lt;code&gt;new Vue&lt;/code&gt; 实例的每个子组件中，都可以使用 &lt;code&gt;$root&lt;/code&gt; 属性访问此根实例。例如，在此根实例中：</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">实际上，您可以将依赖项注入视为一种&amp;ldquo;远程支持&amp;rdquo;，除了：</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">通常，只要能用普通的JavaScript实现某些功能，我们就希望避免引入诸如过滤器之类的特殊语法来处理相同的问题。这是替换Vue内置指令过滤器的方法：</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">在大型应用程序中，我们可能需要将应用程序分成较小的块，并仅在需要时才从服务器加载组件。为了简化操作，Vue允许您将组件定义为异步解析组件定义的工厂函数。Vue仅在需要渲染组件时才触发工厂功能，并将缓存结果以供将来重新渲染。例如：</target>
        </trans-unit>
        <trans-unit id="0e1a8f47d0de2c3d5f962fb51601c60c71a4205c" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a &lt;code&gt;defineAsyncComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">在许多Vue项目中，将使用 &lt;code&gt;Vue.component&lt;/code&gt; 定义全局组件，然后使用 &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; container '}）来定义每个页面正文中的容器元素。</target>
        </trans-unit>
        <trans-unit id="46c352f653c2ccd99c8d1eeb1bac3b46074aed40" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;app.component()&lt;/code&gt;, followed by &lt;code&gt;app.mount('#app')&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">但是，在许多情况下，您仍然会遇到奇怪的行为（例如 &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; 会四舍五入为 &lt;code&gt;0.04&lt;/code&gt; ，但是 &lt;code&gt;0.045&lt;/code&gt; 会四舍五入为 &lt;code&gt;0.04&lt;/code&gt; ）。若要解决这些问题，您可以使用&lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt;库来更可靠地设置货币格式。</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">在许多情况下，您可能希望在 &lt;code&gt;bind&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 上具有相同的行为，但不必关心其他挂钩。例如：</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">在大多数情况下，Vue可以自动找出过渡完成的时间。默认情况下，Vue等待根过渡元素上的第一个 &lt;code&gt;transitionend&lt;/code&gt; 或 &lt;code&gt;animationend&lt;/code&gt; 事件。但是，这可能并不总是希望的-例如，我们可能具有经过编排的过渡序列，其中某些嵌套的内部元素比根过渡元素具有延迟的过渡或更长的过渡持续时间。</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">在大多数情况下，最好避免进入其他组件实例或手动操作DOM元素。但是，在某些情况下可能适当。</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">在大多数情况下,伸入父体会使你的应用程序更难调试和理解,特别是当你在父体中突变数据时。当以后再看那个组件时,将很难弄清楚这个突变来自哪里。</target>
        </trans-unit>
        <trans-unit id="d68b5e8d96b9910b923cbe675afd9e3c75b80ac2" translate="yes" xml:space="preserve">
          <source>In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">在自然英语中,形容词和其他描述词通常会出现在名词之前,而例外情况则需要连接词。例如:</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">在正常使用情况下，您不必自己调用此方法。首选使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 以数据驱动的方式控制子组件的生命周期。</target>
        </trans-unit>
        <trans-unit id="9689e82d55bf91d0bdb0a6e4890e0cb8c481ba5f" translate="yes" xml:space="preserve">
          <source>In order to be more explicit and legible, we have now renamed these initial state classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7967705f3df6230388a8007a18675ebf06f8935f" translate="yes" xml:space="preserve">
          <source>In order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays &lt;code&gt;i18n&lt;/code&gt; ready strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f3b2527a93cc83ec0b5cf78ef1f46a48fed02f" translate="yes" xml:space="preserve">
          <source>In other cases, it returns a stop handle which can be called to explicitly stop the watcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3930e2dc2ac43f310bce905c8d03f08738173196" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;ref&lt;/code&gt; creates a &lt;strong&gt;Reactive Reference&lt;/strong&gt; to our value. The concept of working with &lt;strong&gt;References&lt;/strong&gt; will be used often throughout the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26030f8aadd2fe6b946e53d81af4d02ba1edcf5f" translate="yes" xml:space="preserve">
          <source>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b63ec681a094ed6d524d075cda699de0092770" translate="yes" xml:space="preserve">
          <source>In other words, you &lt;strong&gt;will not have access&lt;/strong&gt; to the following component options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">在我们的例子中，让我们指出 &lt;code&gt;tree-folder&lt;/code&gt; 组件。我们知道创建悖论的孩子是 &lt;code&gt;tree-folder-contents&lt;/code&gt; 组件，因此我们将等到 &lt;code&gt;beforeCreate&lt;/code&gt; 生命周期钩子将其注册：</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">根据我们的经验，最好&lt;em&gt;总是&lt;/em&gt;添加一个唯一的密钥，这样您和您的团队就不必担心这些极端情况。然后，在不需要对象恒定性的罕见的，对性能至关重要的场景中，您可以做出有意识的例外。</target>
        </trans-unit>
        <trans-unit id="78698544f2ebea81bf74621176fba4067b232946" translate="yes" xml:space="preserve">
          <source>In our experience, it's better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9363da25541b78e6af0972c3f9bb895597ac0" translate="yes" xml:space="preserve">
          <source>In previous example, you may want the same behavior on &lt;code&gt;mounted&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt;, but don't care about the other hooks. You can do it by passing the callback to directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">在计算属性不可行的情况下（例如在嵌套的 &lt;code&gt;v-for&lt;/code&gt; 循环内），可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">在某些情况下，我们可能需要对道具进行&amp;ldquo;双向绑定&amp;rdquo;。不幸的是，真正的双向绑定会产生维护问题，因为子组件可以使父项发生变异，而在父项和子项中均不明显该变异的来源。</target>
        </trans-unit>
        <trans-unit id="d3a61aecf34702fc3ac15dbd55af0193cd0d21b7" translate="yes" xml:space="preserve">
          <source>In some cases, we might need &quot;two-way binding&quot; for a prop (sometimes in addition to existing &lt;code&gt;v-model&lt;/code&gt; for the different prop). To do so, we recommended emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, for &lt;code&gt;ChildComponent&lt;/code&gt; from the previous example with the &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">在这种情况下，您可以使用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 组件上的 &lt;code&gt;duration&lt;/code&gt; 属性指定一个明确的过渡持续时间（以毫秒为单位）：</target>
        </trans-unit>
        <trans-unit id="5a26c3605ae94474098786b85b0faf6c2e5c873c" translate="yes" xml:space="preserve">
          <source>In terms of what has changed, at a high level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">在这种情况下，父级中的 &lt;code&gt;.native&lt;/code&gt; 侦听器将默默中断。不会有任何错误，但是在我们期望的时候不会调用 &lt;code&gt;onFocus&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">在&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPM软件包&lt;/a&gt;的 &lt;code&gt;dist/&lt;/code&gt; 目录中，您会找到许多不同的Vue.js版本。以下是它们之间的区别的概述：</target>
        </trans-unit>
        <trans-unit id="096cc70c4fb5904b4142f8704ac2119fe695246e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the npm package (opens new window)&lt;/a&gt; you will find many different builds of Vue.js. Here is an overview of which &lt;code&gt;dist&lt;/code&gt; file should be used depending on the use-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅在 &lt;code&gt;$event.key&lt;/code&gt; 等于 &lt;code&gt;'PageDown'&lt;/code&gt; 时才调用处理程序。</target>
        </trans-unit>
        <trans-unit id="a3446d8a02b83d478e2220ffc2e826c8e079f0f9" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">在布尔属性的情况下，仅它们的存在就意味着 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;v-bind&lt;/code&gt; 的工作方式略有不同。在此示例中：</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">在控制台中，输入 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; 。您应该看到一个新项目附加到列表中。</target>
        </trans-unit>
        <trans-unit id="baf8e367f46b7e0b83ce3e0f831c56fb3167cb4c" translate="yes" xml:space="preserve">
          <source>In the event we need to define the status of the date-picker component via a &lt;code&gt;data-status&lt;/code&gt; property, it will be applied to the root node (i.e., &lt;code&gt;div.date-picker&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;currentTabComponent&lt;/code&gt; 可以包含以下任意一个：</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;appear&lt;/code&gt; 属性或 &lt;code&gt;v-on:appear&lt;/code&gt; 挂钩都会导致出现过渡。</target>
        </trans-unit>
        <trans-unit id="483be1a650754b9854fa661d0a114900f298cd73" translate="yes" xml:space="preserve">
          <source>In the example above, if we change the list of &lt;code&gt;todos&lt;/code&gt;, this change won't be reflected in the injected &lt;code&gt;todoLength&lt;/code&gt; property. This is because &lt;code&gt;provide/inject&lt;/code&gt; bindings are &lt;em&gt;not&lt;/em&gt; reactive by default. We can change this behavior by passing a &lt;code&gt;ref&lt;/code&gt; property or &lt;code&gt;reactive&lt;/code&gt; object to &lt;code&gt;provide&lt;/code&gt;. In our case, if we wanted to react to changes in the ancestor component, we would need to assign a Composition API &lt;code&gt;computed&lt;/code&gt; property to our provided &lt;code&gt;todoLength&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2def93c9e7b3255befa3e7efa09f860a33357348" translate="yes" xml:space="preserve">
          <source>In the example above, the method &lt;code&gt;increment&lt;/code&gt; will be called when the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">将来，您可以查阅&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API参考&lt;/a&gt;以获取实例属性和方法的完整列表。</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">在父级中，我们可以通过添加 &lt;code&gt;postFontSize&lt;/code&gt; 数据属性来支持此功能：</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">在上面的两个示例中，我们碰巧传递了字符串值，但是实际上可以将&lt;em&gt;任何&lt;/em&gt;类型的值传递给prop。</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">在这些情况下，还可以使用 &lt;code&gt;key&lt;/code&gt; 属性在同一元素的不同状态之间转换。代替使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-else&lt;/code&gt; ，上述示例可以重写为：</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">在这些情况下,你可以将你的组件定义为普通的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="ba09958fde7b27bfaf33999c7469e63cc8666df2" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;change&lt;/code&gt; event listener is passed from the parent component to the child and it will be triggered on native &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;code&gt;change&lt;/code&gt; event. We won't need to emit an event from the &lt;code&gt;date-picker&lt;/code&gt; explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">在这种情况下， &lt;code&gt;filterA&lt;/code&gt; ，带一个参数定义，将获得的值 &lt;code&gt;message&lt;/code&gt; ，然后 &lt;code&gt;filterB&lt;/code&gt; 功能将与的结果被称为 &lt;code&gt;filterA&lt;/code&gt; 送入 &lt;code&gt;filterB&lt;/code&gt; 的单个参数。</target>
        </trans-unit>
        <trans-unit id="b094d0f631f3cc4f6960b2f03d3f031dd3ba5545" translate="yes" xml:space="preserve">
          <source>In this case, child component will expect a &lt;code&gt;title&lt;/code&gt; prop and emits &lt;code&gt;update:title&lt;/code&gt; event to sync:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87475fd1d00b371cef287b525052f62f24411b8f" translate="yes" xml:space="preserve">
          <source>In this case, even when &lt;code&gt;child-component&lt;/code&gt; is rendered in the different place, it will remain a child of &lt;code&gt;parent-component&lt;/code&gt; and will receive a &lt;code&gt;name&lt;/code&gt; prop from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">在这种情况下，为 &lt;code&gt;class&lt;/code&gt; 定义了两个不同的值：</target>
        </trans-unit>
        <trans-unit id="35bd1cc27abd4ba52e44235a43fbbdc36c5c6e07" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API) and sets a condition for performing this operation. None of that would be possible with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">在这种情况下，使用 &lt;code&gt;watch&lt;/code&gt; 选项可以使我们执行异步操作（访问API），限制执行该操作的频率，并设置中介状态，直到获得最终答案。使用计算属性，这一切都不可能。</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">在此组件中， &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 的所有后代都需要访问 &lt;code&gt;getMap&lt;/code&gt; 方法，以便知道要与之交互的地图。不幸的是，使用 &lt;code&gt;$parent&lt;/code&gt; 属性无法很好地扩展到更深层嵌套的组件。那就是使用两个新的实例选项在依赖注入中有用的地方： &lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f4bcb81fce1b99e6d7bcbd862cd7e2191686fff" translate="yes" xml:space="preserve">
          <source>In this example, we are creating animation through the use of interpolation, attached to the mouse movement. The CSS transition is applied to the element as well, to let the element know what kind of easing to use while it's updating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">在此示例中，我们选择命名包含所有插槽道具 &lt;code&gt;slotProps&lt;/code&gt; 的对象，但您可以使用任何喜欢的名称。</target>
        </trans-unit>
        <trans-unit id="b16da33edc850538e8b64bc474cfc99b18b1ed65" translate="yes" xml:space="preserve">
          <source>In this example, we've chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">在此示例中，当 &lt;code&gt;eventName&lt;/code&gt; 的值为 &lt;code&gt;&quot;focus&quot;&lt;/code&gt; ， &lt;code&gt;v-on:[eventName]&lt;/code&gt; 将等效于 &lt;code&gt;v-on:focus&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ee4d6d04f3346c2de61ff6305b7eecf8246b8e0" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;'s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301b4eda5dbc41617be06964e971e23018f19d78" translate="yes" xml:space="preserve">
          <source>In this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e78735239ecbe7e73bb9d8e2936f204860e9c" translate="yes" xml:space="preserve">
          <source>In this next section, we'll go over some web animation and transitions basics, and link off to some resources for further exploration. If you're already familiar with web animation and how those principles might work with some of Vue's directives, feel free to skip this next section. For anyone else looking to learn a little more about web animation basics before diving in, read on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90fada6407b38a0e73129e45014412d2857eb5" translate="yes" xml:space="preserve">
          <source>In this, any change to &lt;code&gt;todos.length&lt;/code&gt; will be reflected correctly in the components, where &lt;code&gt;todoLength&lt;/code&gt; is injected. Read more about &lt;code&gt;computed&lt;/code&gt; in the &lt;a href=&quot;reactivity-computed-watchers#computed-values&quot;&gt;Computed and Watch section&lt;/a&gt; and &lt;code&gt;reactive&lt;/code&gt; provide/inject in the &lt;a href=&quot;composition-api-provide-inject#reactivity&quot;&gt;Composition API section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83141900cc37f0045fe7fc8eeac34df78525c24e" translate="yes" xml:space="preserve">
          <source>In v2.1.8, we introduced &lt;code&gt;v-enter-to&lt;/code&gt; to address the timing gap between enter/leave transitions. However, for backward compatibility, the &lt;code&gt;v-enter&lt;/code&gt; name was untouched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a932790edae9a805888ba88043f905fae94eda92" translate="yes" xml:space="preserve">
          <source>In-browser Sandbox on &lt;a href=&quot;https://v3.vue.new&quot;&gt;CodeSandbox (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18af7a938545bae476e6597aaaf4d9729f2bb10a" translate="yes" xml:space="preserve">
          <source>In-browser playground on &lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot;&gt;Codepen (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b54df78801726764e7a6e4a3da6b7ab270929d" translate="yes" xml:space="preserve">
          <source>In-browser template compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb555d4f2dd9b0c24bb7bd03390992336ca209c" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">模板内表达式非常方便,但它们是为了简单的操作。在你的模板中放入过多的逻辑会使模板变得臃肿,难以维护。比如说</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">单个节点</target>
        </trans-unit>
        <trans-unit id="8a0e39acb1c9c6d6a7975a0cc9ac25b374494a2e" translate="yes" xml:space="preserve">
          <source>Information about the parent document: footnotes/copyrights/links to privacy statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7754e67b3434e8bddbe642373114506a298fbefb" translate="yes" xml:space="preserve">
          <source>Information and the operation of user interface must be understandable to all users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">React开发人员的信息</target>
        </trans-unit>
        <trans-unit id="f7fe66c9daa7dc6cfca9b6a287a3553348c8c87d" translate="yes" xml:space="preserve">
          <source>Injecting a property into the root component, with a value provided by the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bfac40439f515d418c73435ab088df8607873d" translate="yes" xml:space="preserve">
          <source>Injections can be optional with default value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55df74fbab3d4d77132f63aeb4395de7ec9a282" translate="yes" xml:space="preserve">
          <source>Inline Template Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">内联模板</target>
        </trans-unit>
        <trans-unit id="b59e8ce6b81b97e1c066f696c45f14d51b2387b4" translate="yes" xml:space="preserve">
          <source>Inline templates attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351cce80f83cbfe40944664026f6d9aab7cb539" translate="yes" xml:space="preserve">
          <source>Inlines all Vue core internal packages - i.e. it's a single file with no dependencies on other files. This means you must import everything from this file and this file only to ensure you are getting the same instance of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef635bdfe6ae64380c953e554f1a2566d43a6f8" translate="yes" xml:space="preserve">
          <source>Input fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">在 &lt;code&gt;v-for&lt;/code&gt; 块中，我们可以完全访问父范围属性。 &lt;code&gt;v-for&lt;/code&gt; 还为当前项目的索引支持可选的第二个参数。</target>
        </trans-unit>
        <trans-unit id="916038a23e13909a2f75bbe445827872088c10bc" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">安装Vue.js插件。如果插件是对象，则必须公开 &lt;code&gt;install&lt;/code&gt; 方法。如果它本身是一个函数，它将被视为安装方法。将以Vue作为参数调用install方法。</target>
        </trans-unit>
        <trans-unit id="d8a20feef8f2799f45b48c087bb1f2c9b59bf8bd" translate="yes" xml:space="preserve">
          <source>Install it using &lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d6d358674017f8697b8b19f7ff45ce7429f3312b" translate="yes" xml:space="preserve">
          <source>Installing Rollup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">实例DOM选项</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">实例生命周期钩子</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">实例方法/数据</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">实例方法/事件</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">实例方法/生命周期</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">实例属性</target>
        </trans-unit>
        <trans-unit id="8e111ccced14747a0574e33ed0b08f79642573af" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;author.books&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;publishedBooksMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">代替计算属性，我们可以定义与方法相同的函数。对于最终结果，这两种方法确实完全相同。但是，不同之处在于，已&lt;strong&gt;计算的属性基于其反应性依赖关系进行缓存。&lt;/strong&gt;计算属性仅在其某些反应相关性已更改时才会重新评估。这意味着只要 &lt;code&gt;message&lt;/code&gt; 未更改，对 &lt;code&gt;reversedMessage&lt;/code&gt; 计算属性的多次访问将立即返回之前的计算结果，而无需再次运行该函数。</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">我们也可以在一个内联JavaScript语句中使用方法,而不是直接与方法名绑定。</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">不用对每个待办事项的内容进行硬编码，我们可以通过使每个待办事项都成为一个插槽，然后将 &lt;code&gt;todo&lt;/code&gt; 绑定为一个插槽道具，来让父组件来控制：</target>
        </trans-unit>
        <trans-unit id="4b69ebfba064bf598fe0cf47768da6d783b96402" translate="yes" xml:space="preserve">
          <source>Instead of using filters, we recommend replacing them with computed properties or methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">而不是使用此接口来监视商店本身发出的事件（例如， &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; ）， &lt;code&gt;store.subscribe&lt;/code&gt; 引入了一种新的方法store.subscribe。插件内部的典型用法是：</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">相反，&lt;strong&gt;组件的 &lt;code&gt;data&lt;/code&gt; 选项必须是function&lt;/strong&gt;，以便每个实例都可以维护返回数据对象的独立副本：</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">而是直接检索反应性数据。</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">相反，我们建议将这两个前缀组合到 &lt;code&gt;$_&lt;/code&gt; ，以作为用户定义的私有属性的约定，以保证与Vue不冲突。</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">相反,我们希望每个组件实例只管理自己的数据。要做到这一点,每个实例必须生成一个唯一的数据对象。在JavaScript中,这可以通过在函数中返回对象来实现。</target>
        </trans-unit>
        <trans-unit id="96b563c3c711449585b436481ceb793428c3903f" translate="yes" xml:space="preserve">
          <source>Instead, you can make your global filters available to all components through &lt;a href=&quot;../../api/application-config#globalproperties&quot;&gt;globalProperties&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">相反,如果你想使用速记,你必须始终指定槽的名称。</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">相反，您应该使用&lt;strong&gt;对象&lt;/strong&gt;数组，以便 &lt;code&gt;v-model&lt;/code&gt; 可以更新对象上的字段。例如：</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">集成第三方路由器</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">有趣的是,Angular和Vue在解决这些AngularJS问题上有不少相似之处。</target>
        </trans-unit>
        <trans-unit id="99dbe2588887c00092f294adc50297fc9daf034b" translate="yes" xml:space="preserve">
          <source>Interface forms, controls, and navigation are operable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd4997099c9dd515cd8fce4f842d086b138a78e" translate="yes" xml:space="preserve">
          <source>Internal Helpers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">在内部,scoped slots的工作方式是将你的slot内容包装在一个传递给你的单一参数的函数中。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">无法对textareas（ &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; ）进行插值。请改用 &lt;code&gt;v-model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="722656fd1f60b606e49464736f37b7a9d40935be" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">属性内插值&lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">属性内插值不再有效。例如:</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="9ac25b7dbef348b38cd7447ba00e5e06fcb8b0d0" translate="yes" xml:space="preserve">
          <source>It also automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">这也使得设计师和经验较少的开发人员更容易解析和贡献代码库。</target>
        </trans-unit>
        <trans-unit id="a407600c5553a0b6afce3b2e7009380cff190cf2" translate="yes" xml:space="preserve">
          <source>It also makes it possible to use values other than &lt;code&gt;'true'&lt;/code&gt; and &lt;code&gt;'false'&lt;/code&gt;, or even keywords yet to come, for attributes like &lt;code&gt;contenteditable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50744937982614ead76f6bef3b2eb792cfd3c531" translate="yes" xml:space="preserve">
          <source>It also returns &lt;code&gt;true&lt;/code&gt; if the proxy is created by &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, but is wrapping another proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">它也可以用来强制替换一个元素/组件,而不是重复使用它。当您想:</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">它不能从用户构建的&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;预设&lt;/a&gt;生成项目，这对于具有预先建立的约定的企业环境特别有用。</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">这取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">它不允许在项目生成期间进行任何配置，而Vue CLI在可升级的运行时依赖项之上运行，该依赖项可以通过&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">与在单个 &lt;code&gt;components&lt;/code&gt; 目录中滚动相比，浏览嵌套子目录通常需要更多时间。</target>
        </trans-unit>
        <trans-unit id="338465a67b58e6eaa9650c8e5d83c288832f2b5a" translate="yes" xml:space="preserve">
          <source>It is a common practice for plugin authors to install the plugins automatically in their UMD builds using &lt;code&gt;Vue.use&lt;/code&gt;. For instance, this is how the official &lt;code&gt;vue-router&lt;/code&gt; plugin installs itself in a browser environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">在事件处理程序中调用 &lt;code&gt;event.preventDefault()&lt;/code&gt; 或 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 是非常常见的需求。尽管我们可以轻松地在方法内部执行此操作，但最好是这些方法可以纯粹与数据逻辑有关，而不是必须处理DOM事件详细信息。</target>
        </trans-unit>
        <trans-unit id="b9b82ff6a9ecc8371804166f686dd29269fd8e00" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &quot;else block&quot; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">也可以用 &lt;code&gt;v-else&lt;/code&gt; 添加一个&amp;ldquo; else块&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="2528b05b485478cec60d8b3a4617e597495c046e" translate="yes" xml:space="preserve">
          <source>It is also possible to call a method directly from a template. As we'll see shortly, it's usually better to use a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; instead. However, using a method can be useful in scenarios where computed properties aren't a viable option. You can call a method anywhere that a template supports JavaScript expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821ab047e92b1bb797a359c27dd615c7dcb8237f" translate="yes" xml:space="preserve">
          <source>It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11aad10ac88ab1f4f9941c1804dfd826b7419eb" translate="yes" xml:space="preserve">
          <source>It is best to provide all the information the user needs to fill out forms outside any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c0231656f976858a53174ef4b684db8fe6384f" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you document all of the events emitted by each of your components using &lt;code&gt;emits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">在同一模板中不再支持具有相同名称的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 。渲染插槽后，它将被&amp;ldquo;用完&amp;rdquo;，并且无法在同一渲染树中的其他位置进行渲染。如果必须在多个地方渲染相同的内容，请将该内容作为道具传递。</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">现在禁止替换组件实例的根$ data。这样可以防止在反应性系统中出现一些极端情况，并使组件状态更加可预测（尤其是在类型检查系统中）。</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">通常情况下,直接绑定到样式对象是个不错的主意,这样模板会更简洁。</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">人们常常忽略了Vue应用程序中真相的来源是原始 &lt;code&gt;data&lt;/code&gt; 对象-Vue实例仅代理对其的访问。因此，如果您有一个状态应该由多个实例共享，则可以通过标识共享它：</target>
        </trans-unit>
        <trans-unit id="bc0742430bf64e7ed852fa2fe5b348a0bbd7e7ff" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the reactive &lt;code&gt;data&lt;/code&gt; object - a component instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can use a &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; method to make an object reactive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5941b8bede80f37fd666d64ae0a8585594d8e00a" translate="yes" xml:space="preserve">
          <source>It is possible to add a new property directly to the component instance without including it in &lt;code&gt;data&lt;/code&gt;. However, because this property isn't backed by the reactive &lt;code&gt;$data&lt;/code&gt; object, it won't automatically be tracked by &lt;a href=&quot;reactivity&quot;&gt;Vue's reactivity system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37285a48f031be7bbbf86e2ffcd3313292517a4b" translate="yes" xml:space="preserve">
          <source>It is recommended to avoid using both on the same element due to the syntax ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751efadc9528a2e4327d95ba9475fe587b4ec316" translate="yes" xml:space="preserve">
          <source>It is recommended to define all emitted events in order to better document how a component should work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">建议尽可能在 &lt;code&gt;v-for&lt;/code&gt; 中提供 &lt;code&gt;key&lt;/code&gt; 属性，除非迭代的DOM内容很简单，或者您有意依赖默认行为来获得性能。</target>
        </trans-unit>
        <trans-unit id="9f05d3baca3585e87a234c817a735dc07843bbe4" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode (opens new window)&lt;/a&gt; with our official extension &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=octref.vetur&quot;&gt;Vetur (opens new window)&lt;/a&gt;, which provides comprehensive IDE support for Vue 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7779dc053f2ed486b907c53be703697ec71f15b" translate="yes" xml:space="preserve">
          <source>It is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy &lt;a href=&quot;https://caniuse.com/#feat=html5semantic&quot;&gt;browsers that don&amp;rsquo;t support HTML5 semantic elements (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">它通常工作良好，但延迟的状态更新可能会导致奇怪的行为。例如，单击&amp;ldquo; &lt;code&gt;Result&lt;/code&gt; 选项卡，然后尝试在这些输入之一中输入 &lt;code&gt;9.999&lt;/code&gt; 。当输入失去焦点时，其值将更新为 &lt;code&gt;$10.00&lt;/code&gt; 。但是，在查看计算出的总数时，您会看到 &lt;code&gt;9.999&lt;/code&gt; 是存储在我们的数据中的内容。用户看到的现实版本不同步！</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">它仅提供一个模板（假定您正在构建单页应用程序），而Vue提供了多种用于各种目的和构建系统的默认选项。</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">当可能只有生命周期挂钩需要访问 &lt;code&gt;picker&lt;/code&gt; ，它需要将选择器保存到组件实例。这并不可怕，但是可以认为它很杂乱。</target>
        </trans-unit>
        <trans-unit id="4498754208578dfe241aa59ce513436b21cdefe3" translate="yes" xml:space="preserve">
          <source>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c27ec712f1c3f7f2e2036cb2ee97cb69409b690" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;these limitations do &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">应当指出的是，&lt;strong&gt;这种限制并&lt;em&gt;没有&lt;/em&gt;，如果你正在使用字符串模板从下列来源之一适用&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">它将呈现。</target>
        </trans-unit>
        <trans-unit id="13566b680265d72cb595dc1be3858a3b3f978e1f" translate="yes" xml:space="preserve">
          <source>It would be much nicer if we could collocate code related to the same logical concern. And this is exactly what the Composition API enables us to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">实际上，可以通过使用多个 &lt;code&gt;v-if&lt;/code&gt; 或将单个元素绑定到动态属性在任意数量的元素之间进行转换。例如：</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">为纯JavaScript转换显式添加 &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; 也是一个好主意，以便Vue可以跳过CSS检测。这还可以防止CSS规则意外干扰过渡。</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">将应用程序组织成嵌套的组件树是很常见的：</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">通过浏览HTML模板，可以更轻松地在JS代码中找到处理函数的实现。</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">同样，切换元素的存在也很容易：</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">需要特别注意的是，这些限制中的许多是由create-react-app团队故意设计的决策，它们确实有其优势。例如，只要您的项目需求非常简单，并且您无需&amp;ldquo;退出&amp;rdquo;以定制您的构建过程，就可以将其作为依赖项进行更新。您可以&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;在此处&lt;/a&gt;详细了解不同的哲学。</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">重要的是要注意，您切勿在操作中替换原始状态对象-组件和存储区需要共享对同一对象的引用才能观察到突变。</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">很少会在JavaScript中引用全局组件，因此遵循JavaScript约定没有意义。</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">建议将所有内容包装在一个新元素中，如下所示：</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">在事件中发出特定的值有时很有用。例如，我们可能希望 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 组件负责将文本放大多少。在这种情况下，我们可以使用 &lt;code&gt;$emit&lt;/code&gt; 的第二个参数来提供此值：</target>
        </trans-unit>
        <trans-unit id="8852ff75403c297afd1a8a3cdb0552cf73fe06bf" translate="yes" xml:space="preserve">
          <source>It's actually possible to transition between any number of elements, either by using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt; or binding a single element to a dynamic property. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad47c16fba81b79a86241bf8888fad85c94ce363" translate="yes" xml:space="preserve">
          <source>It's common for an app to be organized into a tree of nested components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af319375896cfcb2ac29299a5aeee693d621695" translate="yes" xml:space="preserve">
          <source>It's easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17ba0c11ce9ca8328a5aebef189aaa88d9ead34" translate="yes" xml:space="preserve">
          <source>It's easy to toggle the presence of an element, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cd7c29493393f218043384194d7b5510c8dde1" translate="yes" xml:space="preserve">
          <source>It's generally recommended to keep directives independent of the component instance they are used in. Accessing the instance from within a custom directive is often a sign that the directive should rather be a component itself. However, there are situations where this actually makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f29b81017a607c886e9905a378f2d9bd55f8c75" translate="yes" xml:space="preserve">
          <source>It's important to note the runtime config only affects runtime template compilation - it won't affect pre-compiled templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd4ae770137b3e9b3a6d876b8827f3129a2fcc" translate="yes" xml:space="preserve">
          <source>It's much more common for a component to use &lt;code&gt;props&lt;/code&gt; than the other properties, and very often a component uses only &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebac3eeeb53ba07a891673ff03acf90d6ccc73e" translate="yes" xml:space="preserve">
          <source>It's now much clearer what the difference between these states is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a696ed981dd37807dbf8cb59239f76cfd4a209" translate="yes" xml:space="preserve">
          <source>It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320f04e4adc498746e8285c25d0174bb0a242c0d" translate="yes" xml:space="preserve">
          <source>It's sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can pass a second parameter to &lt;code&gt;$emit&lt;/code&gt; to provide this value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7d46141f064bc144bcd65cad47e0b1500c6ec5" translate="yes" xml:space="preserve">
          <source>Iteration &amp;amp; Communication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab84ddacf62192827bb778b54f0d73df28c81a56" translate="yes" xml:space="preserve">
          <source>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cc248e464b2aea646387386136d3ee2f3468fd" translate="yes" xml:space="preserve">
          <source>JAWS (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX与模板</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScript 钩子</target>
        </trans-unit>
        <trans-unit id="6cea98e1f2bba3a82d53ff16b1849c803f2e2665" translate="yes" xml:space="preserve">
          <source>JavaScript doesn&amp;rsquo;t usually work like this -- If we were to write something comparable in JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">JavaScript的本机 &lt;code&gt;.filter&lt;/code&gt; 也可以管理更复杂的过滤操作，因为您可以在计算属性中访问JavaScript的全部功能。例如，如果您要查找所有活动用户，并且不区分大小写地将其名称和电子邮件匹配：</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="a46d5413cffceb72c83f4112df056475b52ee003" translate="yes" xml:space="preserve">
          <source>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">加入Vue.js社区</target>
        </trans-unit>
        <trans-unit id="b05d0122984642cf7090c52ffdac8dd94d5f6d18" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;resolveDynamicComponent&lt;/code&gt; supports passing a component name, an HTML element name, or a component options object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b48b329205efd9bbd9fce3544a036c29c0a8fa" translate="yes" xml:space="preserve">
          <source>Just like all other properties of the component instance, the &lt;code&gt;methods&lt;/code&gt; are accessible from within the component's template. Inside a template they are most commonly used as event listeners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa1596972789e18182ccfc21abdfcfd9e0ff36e" translate="yes" xml:space="preserve">
          <source>Just like how we set up a watcher on the &lt;code&gt;user&lt;/code&gt; property inside our component using the &lt;code&gt;watch&lt;/code&gt; option, we can do the same using the &lt;code&gt;watch&lt;/code&gt; function imported from Vue. It accepts 3 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">就像HTML元素一样，将内容传递到组件通常很有用，如下所示：</target>
        </trans-unit>
        <trans-unit id="a98b5180199c5ab496bb93100cd4afe9c3a4168f" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it's often useful to be able to pass content to a component, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">只是为了支持模板中相对较少的标记。</target>
        </trans-unit>
        <trans-unit id="ba65d86ead17c56d628584a8788a419c56876378" translate="yes" xml:space="preserve">
          <source>Keep in mind that we've only scratched the surface of Composition API and what it allows us to do. To learn more about it, refer to the in-depth guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">但是请记住，使用此模式构建的组件本质上仍是易碎的。例如，假设我们添加了一个新的 &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; 组件，并且当其中出现 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 时，它仅应呈现属于该区域的标记：</target>
        </trans-unit>
        <trans-unit id="467e7f276ee2b9a2f53b3949e288efde8bd26ea9" translate="yes" xml:space="preserve">
          <source>Key Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">关键代码</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">关键修改器</target>
        </trans-unit>
        <trans-unit id="6c5f93229012cbadeede1c515b6352e435db9e2b" translate="yes" xml:space="preserve">
          <source>KeyCode Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">键控 &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;必备&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">键控v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">Knockout是MVVM和相关性跟踪空间的先驱，其反应系统与Vue的非常相似。考虑到它所做的一切，它的&lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;浏览器支持&lt;/a&gt;也非常令人印象深刻，并且支持IE6！另一方面，Vue仅支持IE9 +。</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="e61cef41ba854e90306988f5c1e5bd34137d6595" translate="yes" xml:space="preserve">
          <source>Labels are typically placed on top or to the left of the form fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24edb29b6ba5554a247bb7953f4370fb8f7aae0" translate="yes" xml:space="preserve">
          <source>Landmark Purpose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626b6c1d454d11a862220dbe8b7b34d0bcd6de9d" translate="yes" xml:space="preserve">
          <source>Landmarks</source>
          <target state="translated">Landmarks</target>
        </trans-unit>
        <trans-unit id="ec1be2a3865871adce929dfefc2959c96918a558" translate="yes" xml:space="preserve">
          <source>Landmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles&quot;&gt;ARIA roles (opens new window)&lt;/a&gt; to help you achieve this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">大型应用程序的复杂性通常会增加，这是因为分散在许多组件之间的多个状态及其之间的交互。为了解决这个问题，Vue提供了&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;：我们自己的Elm风格的状态管理库。它甚至集成到&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools中&lt;/a&gt;，提供零设置访问&lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;时间旅行调试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af32dbeca45c38e1ab5bbca67861fc2b513411a7" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://next.vuex.vuejs.org/&quot;&gt;Vuex (opens new window)&lt;/a&gt;, our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (opens new window)&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">最后，Vue单文件组件的样式非常灵活。通过&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;，您可以在 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 元素内使用任何预处理器，后处理器，甚至与&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS模块进行&lt;/a&gt;深度集成。</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">最新稳定版本:2.6.10</target>
        </trans-unit>
        <trans-unit id="25f41560444b01511b3f085284b9287b245c68e3" translate="yes" xml:space="preserve">
          <source>Latest version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc4535d8b22b1a2065eb7b3e8da9f8806324bc4" translate="yes" xml:space="preserve">
          <source>Learn how to use teleport with a free lesson on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../api/index#provide-inject&quot;&gt;API文档中&lt;/a&gt;了解有关依赖项注入的更多信息。</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">学习曲线</target>
        </trans-unit>
        <trans-unit id="c8de89461bb526135e97877a49d087c4f8f53917" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV guards&lt;/code&gt; (must be replaced by bundler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fa6a52f9f95d2228d742b21a7f9256e534287a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add &lt;code&gt;setup&lt;/code&gt; to our component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d915f196841018fe83a9580c35cc5af5850df5c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add it to our &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">让我们看一个简单的示例，其中的 &lt;code&gt;render&lt;/code&gt; 功能将是实用的。假设您要生成锚定标题：</target>
        </trans-unit>
        <trans-unit id="17834c351c272bdff2a7fbc013f9102fea710211" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that in our app, we have a view to show a list of repositories of a certain user. On top of that, we want to apply search and filter capabilities. Our component handling this view could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97599b335f4e992e78c12be5dd024497eba4df8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move our search functionality into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">假设您有一个待办事项清单：</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">假设您要创建一个自定义指令，该指令允许您使用固定位置将元素固定到页面。我们可以创建一个自定义指令，其中值更新像素的垂直位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">假设您正在构建文件目录树，例如在Finder或File Explorer中。您可能有一个带有此模板的 &lt;code&gt;tree-folder&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="6c99d3d3fdfa8bd3e1baa14373a303cb25022aea" translate="yes" xml:space="preserve">
          <source>Let's assume that we want to rewrite the following code, which contains a &lt;code&gt;MyMap&lt;/code&gt; component that provides a &lt;code&gt;MyMarker&lt;/code&gt; component with the user's location, using the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad199543d13fb602b1787ea12617af19cdac14b3" translate="yes" xml:space="preserve">
          <source>Let's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a4107dc8befffcdc08d9bfc4c038af7438f2a1" translate="yes" xml:space="preserve">
          <source>Let's create an example custom modifier, &lt;code&gt;capitalize&lt;/code&gt;, that capitalizes the first letter of the string provided by the &lt;code&gt;v-model&lt;/code&gt; binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efaf7a4338ac2db9e77c15bcbe109038634f1e0" translate="yes" xml:space="preserve">
          <source>Let's dive deeper into how each argument can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965ee87d9a7fdfe5a2fefa407fc1fd4f95ef4d94" translate="yes" xml:space="preserve">
          <source>Let's dive into an example where a &lt;code&gt;render()&lt;/code&gt; function would be practical. Say we want to generate anchored headings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f68db1406bc20e0022ac27f2ee63637a48856" translate="yes" xml:space="preserve">
          <source>Let's look at this search field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b719b12c1068d11a2e6d04fa1b3077e20bd35b" translate="yes" xml:space="preserve">
          <source>Let's modify our &lt;code&gt;modal-button&lt;/code&gt; to use &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; and tell Vue &quot;&lt;strong&gt;teleport&lt;/strong&gt; this HTML &lt;strong&gt;to&lt;/strong&gt; the &quot;&lt;strong&gt;body&lt;/strong&gt;&quot; tag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098aabc545a2bc27663da4a434b6c0b7fe35c63e" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of todos:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3669759690ca7d10550e7dab45e8ba8a6d06189" translate="yes" xml:space="preserve">
          <source>Let's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16967b5d529c071e7c31b4b0d1d25c9f1bdbe5b1" translate="yes" xml:space="preserve">
          <source>Let's take a look at &lt;code&gt;modal-button&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67530659cbfc12250ac15b4825a7142987ed4730" translate="yes" xml:space="preserve">
          <source>Library Authors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">生命周期图</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">生命周期事件(按其名称顺序排列)</target>
        </trans-unit>
        <trans-unit id="e15c95b3b57b4bc9945881310c2f7fa52f895a6d" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Registration Inside &lt;code&gt;setup&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">生命周期挂钩</target>
        </trans-unit>
        <trans-unit id="37857eb2e2aa8efab7a0ac716f62d18f83e34871" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76af71af244f2f6db8f83760d5be272f79f446b" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks can be registered with directly-imported &lt;code&gt;onX&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260f808c2d6d1ca9299afb5f45b0231a77889ebf" translate="yes" xml:space="preserve">
          <source>Lighthouse (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47cbdd94a999f599791f292c086fca7922c6de4" translate="yes" xml:space="preserve">
          <source>Like components and props, event names provide an automatic case transformation. If you emit an event from the child component in camel case, you will be able to add a kebab-cased listener in the parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aded01a7c9673b7fc6a79a471f805a19e31546" translate="yes" xml:space="preserve">
          <source>Likewise for &lt;code&gt;altKey&lt;/code&gt;, &lt;code&gt;shiftKey&lt;/code&gt;, and &lt;code&gt;metaKey&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df77b1e0de2b6983ce6696ce595e7de4eec752e" translate="yes" xml:space="preserve">
          <source>Line Highlighting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">列表进入/离开转换</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">列表移动转换</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">列表渲染</target>
        </trans-unit>
        <trans-unit id="7a1568935f8a040f0ddeb7118a253e76a0ba1ee0" translate="yes" xml:space="preserve">
          <source>List Rendering - &lt;code&gt;v-for&lt;/code&gt; with &lt;code&gt;v-if&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b44b03037bd0f155ca305c63ebd74b1d0758424" translate="yes" xml:space="preserve">
          <source>List Rendering - Displaying Filtered/Sorted Results</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014a81574bf11dd8c3a37e832221bd011f6da627" translate="yes" xml:space="preserve">
          <source>List Rendering: Maintaining State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">列表转换</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">在当前虚拟机上监听自定义事件。可以由 &lt;code&gt;vm.$emit&lt;/code&gt; 触发事件。回调将接收传递给这些事件触发方法的所有其他参数。</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">侦听一个自定义事件,但只能一次。一旦第一次触发,监听器将被删除。</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; 仅侦听一次事件</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; 监听事件</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">监听的组件内置事件与 &lt;code&gt;v-on&lt;/code&gt; &lt;sup&gt;改变&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">监听子组件事件</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">聆听事件</target>
        </trans-unit>
        <trans-unit id="a5bab41dbcd17d889c6e2f819506e9dcf076f282" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &quot;my-event&quot; is emitted on the child):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">侦听子组件上的自定义事件（在子组件上发出&amp;ldquo; my-event&amp;rdquo;时调用处理程序）：</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">听了烤肉盒版的就没有影响了。</target>
        </trans-unit>
        <trans-unit id="6674c82db55a9741fe74df825e79591da8cece35" translate="yes" xml:space="preserve">
          <source>Loader function does not inherently receive &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must return a Promise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">本地注册</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">模块系统中的本地注册</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">现在逻辑与表现层解耦,使得维护(更改/扩展逻辑)变得更加容易。</target>
        </trans-unit>
        <trans-unit id="972ab90613dd62fd50f5c7d4e44d82a2703fc0da" translate="yes" xml:space="preserve">
          <source>MAGic (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9061dc1c4c01489f1dced5faf2e16a1e14bb1c24" translate="yes" xml:space="preserve">
          <source>Magnifier (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">维持国家</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">使Vue忽略在Vue之外定义的自定义元素（例如，使用Web组件API）。否则，如果您忘记注册全局组件或拼写错误的组件名称，则会引发有关 &lt;code&gt;Unknown custom element&lt;/code&gt; 的警告。</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">使对象具有反应性。在内部，Vue在由 &lt;code&gt;data&lt;/code&gt; 函数返回的对象上使用它。</target>
        </trans-unit>
        <trans-unit id="7801d7d110e57ae1f3c6effb3b2240aea5dc9f4f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;script&lt;/code&gt; part of the component has TypeScript set as a language:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">请务必阅读有关&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;的不同构建Vue公司的&lt;/a&gt;，并使用&lt;strong&gt;生产&lt;br/&gt;版本&lt;/strong&gt;在发布的站点，更换 &lt;code&gt;vue.js&lt;/code&gt; 与 &lt;code&gt;vue.min.js&lt;/code&gt; 。这是针对速度而不是开发经验进行了优化的较小版本。</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">管理许多状态转换会迅速增加Vue实例或组件的复杂性。幸运的是，可以将许多动画提取到专用的子组件中。让我们使用前面示例中的动画整数来做到这一点：</target>
        </trans-unit>
        <trans-unit id="6d84634068387565bc44457e74c1fb936b41ea6b" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a component instance. Fortunately, many animations can be extracted out into dedicated child components. Let's do this with the animated integer from our earlier example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">在非常简单的情况下，在 &lt;code&gt;this.$root&lt;/code&gt; 和/或使用&lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;全局事件总线&lt;/a&gt;上管理状态可能很方便，但不适用于大多数应用程序。Vuex不仅提供了一个状态管理中心，还提供了用于组织，跟踪和调试状态更改的工具。</target>
        </trans-unit>
        <trans-unit id="345f632fb618327d0737b3e43648e569b92b65d3" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a global event bus can be convenient for very simple cases, but it is not appropriate for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">在将子组件、道具或数据传递给子组件之前,先对它们进行操作。</target>
        </trans-unit>
        <trans-unit id="ef483ab0b23465192e501c234b66b1aaf6d75a30" translate="yes" xml:space="preserve">
          <source>Many JS libraries like GreenSock will assume you want hardware acceleration and will apply them by default, so you do not need to set them manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">许多文件名称相似,使得代码编辑器中的文件快速切换更加困难。</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">许多嵌套的子目录，这增加了浏览编辑器侧边栏中的组件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="16185e750a239f48af50dd807d021ebe27373d96" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">您的许多组件都是相对通用的，可能只包装诸如输入或按钮之类的元素。有时我们将它们称为&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本组件，&lt;/a&gt;并且它们在您的组件中往往会经常使用。</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;v-for&lt;/code&gt; 将数组映射到元素</target>
        </trans-unit>
        <trans-unit id="985fac5003727ca9f43295099936da1f418deb05" translate="yes" xml:space="preserve">
          <source>Marks an object so that it will never be converted to a proxy. Returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">元实例方法</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">方法事件处理程序</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d7d319f93f2d93a0aa10747398e65d855aff93ad" translate="yes" xml:space="preserve">
          <source>Methods called from a template should not have any side effects, such as changing data or triggering asynchronous processes. If you find yourself tempted to do that you should probably use a &lt;a href=&quot;instance#lifecycle-hooks&quot;&gt;lifecycle hook&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">内联处理程序中的方法</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">要混合到Vue实例中的方法。您可以直接在VM实例上访问这些方法，也可以在指令表达式中使用它们。所有方法都将有自己的 &lt;code&gt;this&lt;/code&gt; 背景下自动绑定到Vue的实例。</target>
        </trans-unit>
        <trans-unit id="6fde24be2acb622eb42db4cc92f8e9d97e13fc25" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the component instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;替换&lt;/sup&gt;中间件&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">中间件被插件所取代。插件是一个接收存储作为唯一参数的函数,可以监听存储上的突变事件。</target>
        </trans-unit>
        <trans-unit id="a6b3e991aad9c53aed3b0912de764a87bdc4c052" translate="yes" xml:space="preserve">
          <source>Migration Strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">从Vue 1.x迁移</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">从Vue Router 0.7.x迁移到Vue Router 0.7.x。</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">从Vuex 0.6.x到1.0的迁移。</target>
        </trans-unit>
        <trans-unit id="27e6c208056129d07214b4839a815039f22c4fbb" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt; includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7041841fb6a16a593419ba9210aa34bce92e8" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt;includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c410c172a6db22b44797723b74a9f97cbe8cbd47" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$listeners&lt;/code&gt; removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635802e8d697afd466dea0285928d4c2564eeacf" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;.native&lt;/code&gt; modifier removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0b41dde0e20543a039acd14df0e338cbee9d6" translate="yes" xml:space="preserve">
          <source>Migration guide - Changes in the Render Functions API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5be8322a9bb8f637fd7d36053e4e1060c3e536" translate="yes" xml:space="preserve">
          <source>Migration guide - New Emits Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2363ce7759901b489bcaeaac53540d1809dbe21" translate="yes" xml:space="preserve">
          <source>Migration: Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="01468459ec2045f5366f9299c5e3667f7a39c98e" translate="yes" xml:space="preserve">
          <source>Mixin Merge Behavior Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Mixin挂钩按其提供的顺序调用，并在组件自己的挂钩之前调用。</target>
        </trans-unit>
        <trans-unit id="696c1c53029e4a11c64d6af9a07cc08ca71e59d3" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component's own hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Mixins是为Vue组件分发可重用功能的灵活方法。mixin对象可以包含任何组件选项。当组件使用混入时，混入中的所有选项都将被&amp;ldquo;混入&amp;rdquo;到组件自己的选项中。</target>
        </trans-unit>
        <trans-unit id="41c21dcea103087b7aa285323c1c82e7014cf7e0" translate="yes" xml:space="preserve">
          <source>Mixins are conflict-prone: Since properties from each feature are merged into the same component, you still have to know about every other feature to avoid property name conflicts and for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f849d0cf8da656a7c4361043b523a5ce2e1fc1e" translate="yes" xml:space="preserve">
          <source>Mixins distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &quot;mixed&quot; into the component's own options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX已在React社区中变得非常流行，并且实际上使用了与Vue几乎相同的反应系统。在一定程度上，React + MobX工作流可以被认为是更冗长的Vue，因此，如果您正在使用该组合并很喜欢它，那么进入Vue可能是下一个合乎逻辑的步骤。</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="814d5c9075ac58da08deb4e3d88f6089a78f380d" translate="yes" xml:space="preserve">
          <source>Mocha</source>
          <target state="translated">Mocha</target>
        </trans-unit>
        <trans-unit id="20716d7589116671fbeb6c4a74532bdfef915478" translate="yes" xml:space="preserve">
          <source>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f243cbe64caef0641a9876a4078a94f8defc16" translate="yes" xml:space="preserve">
          <source>Modifier Keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">修改器键。</target>
        </trans-unit>
        <trans-unit id="42425619360ca471965f2dfefff097e5132ba384" translate="yes" xml:space="preserve">
          <source>Modifiers added to a component &lt;code&gt;v-model&lt;/code&gt; will be provided to the component via the &lt;code&gt;modelModifiers&lt;/code&gt; prop. In the below example, we have created a component that contains a &lt;code&gt;modelModifiers&lt;/code&gt; prop that defaults to an empty object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">修饰符是用点表示的特殊后缀，表示应以某种特殊方式绑定指令。例如， &lt;code&gt;.prevent&lt;/code&gt; 修饰符告诉 &lt;code&gt;v-on&lt;/code&gt; 指令在触发的事件上调用 &lt;code&gt;event.preventDefault()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">模块系统</target>
        </trans-unit>
        <trans-unit id="2333c18157c24df8052238f52f365426ca0dbb73" translate="yes" xml:space="preserve">
          <source>Module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack (opens new window)&lt;/a&gt; support &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree-shaking (opens new window)&lt;/a&gt;, which is a fancy term for &amp;ldquo;dead code elimination.&amp;rdquo; Unfortunately, due to how the code is written in previous Vue versions, global APIs like &lt;code&gt;Vue.nextTick()&lt;/code&gt; are not tree-shakeable and will be included in the final bundle regardless of where they are actually used or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">更成熟的工具支持。Vue为&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt;和&lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;提供官方支持，而Riot依靠社区对构建系统集成的支持。</target>
        </trans-unit>
        <trans-unit id="bd951adc5c3182ed45f637e554b6230120cad548" translate="yes" xml:space="preserve">
          <source>Most of the methods exposed by the application instance return that same instance, allowing for chaining:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51829624f8ae979b2184273f19ad9bb547f0cb2e" translate="yes" xml:space="preserve">
          <source>Most of the time when developing a third-party library we want to build it in a way that allows the consumers of the library to &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree shake (opens new window)&lt;/a&gt; it. To enable tree-shaking we need to build &lt;code&gt;esm&lt;/code&gt; modules. Since webpack and, in turn, vue-cli do not support building &lt;code&gt;esm&lt;/code&gt; modules we need to rely on &lt;a href=&quot;https://rollupjs.org/&quot;&gt;rollup (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd700564f82afc8781e8c7bd3517f4f9cfa75b4" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI (opens new window)&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;，则默认情况下会启用以下大多数提示。仅当您使用自定义构建设置时，此部分才有意义。</target>
        </trans-unit>
        <trans-unit id="5e26a19f206db5f80980c1565b38336a5204a51f" translate="yes" xml:space="preserve">
          <source>Most of the use cases for &lt;code&gt;inline-template&lt;/code&gt; assumes a no-build-tool setup, where all templates are written directly inside the HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">大多数突变道具的用例都可以用这些选项之一来代替。</target>
        </trans-unit>
        <trans-unit id="2c94530449d59bc0026f72f09d5cab721902ce23" translate="yes" xml:space="preserve">
          <source>Mounting App Instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f67e8c3b01357d6a48d990b7305e54d0bf81af" translate="yes" xml:space="preserve">
          <source>Mounts a root component of the application instance on the provided DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">鼠标按钮修改器</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">好多了，不是吗？</target>
        </trans-unit>
        <trans-unit id="47ce4ea06250a3aebfb8fdef175fa9bb75c62c5f" translate="yes" xml:space="preserve">
          <source>Much better, isn't it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f57c7776187e52ab80734a4cd047017fdbc252" translate="yes" xml:space="preserve">
          <source>Much like a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag, a &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag is only required in templates as a syntactical placeholder and should be discarded when migrating to a &lt;code&gt;render&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">简单得多！有点。代码更短，但也需要更熟悉Vue实例属性。在这种情况下，您必须知道，当您将没有 &lt;code&gt;v-slot&lt;/code&gt; 指令的子代传递到组件中时，例如 &lt;code&gt;Hello world!&lt;/code&gt; 在 &lt;code&gt;anchored-heading&lt;/code&gt; ，这些子项存储在 &lt;code&gt;$slots.default&lt;/code&gt; 的组件实例上。如果还没有的话，&lt;strong&gt;建议在进入渲染功能之前通读&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;实例属性API&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">多属性元素</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;多属性元素&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">多字组件名称</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">多词组件名称&lt;sup&gt;必不可少&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">多行文字</target>
        </trans-unit>
        <trans-unit id="9a85758f90e2757c68d0fceaab52f21c4531a196" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;v-model&lt;/code&gt; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4871212ed8d1d6698fc58f7b90833df012ebc65c" translate="yes" xml:space="preserve">
          <source>Multiple Event Handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df30563657ae4c69b0249bc2ce91dacff84cf5a3" translate="yes" xml:space="preserve">
          <source>Multiple Sections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">多值</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">多个复选框,绑定到同一个阵列。</target>
        </trans-unit>
        <trans-unit id="ec5f3b4f279a5fac1d619ddd625a66c322263084" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">多节点,一次只渲染一个节点。</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">多重选择(绑定到阵列)。</target>
        </trans-unit>
        <trans-unit id="ba3eb3692fb6af84e61cce398babaf5e0445cbe0" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to array):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0467cdaf45c60b95eca56ed7e05421c4b98185" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/directives#v-bind&quot;&gt;&lt;code&gt;v-bind&lt;/code&gt; directive&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">在HTML属性内不能使用胡须。而是使用&lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind指令&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="678c5ab9e821362e494de6bbb3ed5d891d1e67f1" translate="yes" xml:space="preserve">
          <source>Mutating Reactive Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">现在将局部 &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 道具视为反模式，例如，声明道具然后在组件中设置this.myProp ='someOtherValue'。由于采用了新的渲染机制，每当父组件重新渲染时，子组件的本地更改都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">突变方法</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">顾名思义，变异方法会变异调用它们的原始数组。相比之下，还有一些非变异方法，例如 &lt;code&gt;filter()&lt;/code&gt; ， &lt;code&gt;concat()&lt;/code&gt; 和 &lt;code&gt;slice()&lt;/code&gt; ，它们不会变异原始数组，但&lt;strong&gt;总是返回一个新数组&lt;/strong&gt;。使用非突变方法时，可以将旧数组替换为新数组：</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">使用Vue构建大型应用程序时，建议使用NPM安装方法。它与诸如&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;或&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify之&lt;/a&gt;类的模块捆绑器很好地配对。Vue还提供了用于创作&lt;a href=&quot;single-file-components&quot;&gt;单一文件组件的&lt;/a&gt;随附工具。</target>
        </trans-unit>
        <trans-unit id="69a28f26a2d6401b08eedd57c6a1a5681efe2332" translate="yes" xml:space="preserve">
          <source>NVDA (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">壳体名称</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">名称冲突（例如，多个 &lt;code&gt;ButtonDelete.vue&lt;/code&gt; 组件）使在代码编辑器中快速导航到特定组件变得更加困难。</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">名义老虎机</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">名义老虎机速记</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">具有 &lt;code&gt;slot&lt;/code&gt; 属性的命名插槽</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">本地渲染</target>
        </trans-unit>
        <trans-unit id="26068455a90075c00bf4839b741d52af3487813b" translate="yes" xml:space="preserve">
          <source>NativeScript</source>
          <target state="translated">NativeScript</target>
        </trans-unit>
        <trans-unit id="1877cf043460c0f80e9625a96954e7851b08330d" translate="yes" xml:space="preserve">
          <source>NativeScript + Vue.js Guide (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f940a2947c24bf59462a669f4fe8ca87501b7ae3" translate="yes" xml:space="preserve">
          <source>NerdeFocus (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826fdcb80bf0630de536146d505abc527b2a01df" translate="yes" xml:space="preserve">
          <source>Nest headings in their ranking order: &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248d641e1dd50d8e9bc4a5ff4268e7392bab4e5d" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper method that explicitly defines async components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0+中的新增功能：如果未提供回调且执行环境中支持Promise，则返回Promise。请注意，Vue不带有Promise polyfill，因此，如果您定位的浏览器本身不支持Promises（IE，则是您），则您必须自己提供一个polyfill。</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+中的新功能</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0中的新功能</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="be41335dc7a0ff9171513e80c9b33fbd4144bd7a" translate="yes" xml:space="preserve">
          <source>New to Vue.js? Check out our &lt;a href=&quot;../../index&quot;&gt;Essentials Guide&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1bc63fa69d5b8906a90d616cc23894236797b1" translate="yes" xml:space="preserve">
          <source>Nightwatch's Official Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce8836503e7153aa1a402805b5adb8e46245b8f" translate="yes" xml:space="preserve">
          <source>Nightwatch.js</source>
          <target state="translated">Nightwatch.js</target>
        </trans-unit>
        <trans-unit id="7fa11e6f2aa3af114b0e34eb2cd5e3891fde04fd" translate="yes" xml:space="preserve">
          <source>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">不再需要了,因为现在默认情况下,警告会带有堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">没有实际用途。如果您确实碰巧以某种方式依赖此功能，并且不确定如何解决该功能，请在&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;论坛&lt;/a&gt;上发布想法。</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">节点、树和虚拟 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">非道具属性</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">非流动状态管理</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">非通量状态管理&lt;sup&gt;谨慎使用&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7522eb1254b40f819eb00d0f412303761a8a0ac4" translate="yes" xml:space="preserve">
          <source>Not needed*</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63d0df42b260685a2a9914a2f95611f71b33e28" translate="yes" xml:space="preserve">
          <source>Notable New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 中的每个孩子都必须&lt;strong&gt;唯一地设置关键帧&lt;/strong&gt;，动画才能正常工作。</target>
        </trans-unit>
        <trans-unit id="ca49da0909b8a4408a3a2c4586e5b1467d69929a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../api/refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are &lt;a href=&quot;reactivity-fundamentals#ref-unwrapping&quot;&gt;automatically unwrapped&lt;/a&gt; when accessed in the template so you shouldn't use &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc23cd0cef0d3813fd341bfd31bf6563a5bf5c6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are automatically unwrapped when accessed in the template so there's no need for &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 要求使用组件上的 &lt;code&gt;name&lt;/code&gt; 选项或通过本地/全局注册将组件之间切换为全部具有名称。</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">需要注意的是 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 选项并&lt;strong&gt;不会&lt;/strong&gt;影响 &lt;code&gt;style&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 绑定。</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;mounted&lt;/code&gt; 并&lt;strong&gt;不能&lt;/strong&gt;保证所有的子组件也已安装。如果你想等到整个图已经呈现，您可以使用&lt;a href=&quot;#vm-nextTick&quot;&gt;虚拟机$ nextTick。&lt;/a&gt;里面 &lt;code&gt;mounted&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb05a4351598578542e96c7b1ebb606ca8a12371" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 上不支持 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; ，因此，如果需要在新选项卡中打开链接，则必须使用 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;updated&lt;/code&gt; 并&lt;strong&gt;不能&lt;/strong&gt;保证所有子组件也都已重新呈现。如果你想等到整个视图已经重新呈现，你可以使用&lt;a href=&quot;#vm-nextTick&quot;&gt;虚拟机$ nextTick。&lt;/a&gt;内 &lt;code&gt;updated&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="736452a7cde671c4028bd0f51d1cfa315c95c76a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;v-bind&lt;/code&gt; 与 &lt;code&gt;.sync&lt;/code&gt; 修改器&lt;strong&gt;不&lt;/strong&gt;使用表达式的工作（如 &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 是无效的）。相反，您必须仅提供要绑定的属性的名称，类似于 &lt;code&gt;v-model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;v-show&lt;/code&gt; 不支持 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素，也不与 &lt;code&gt;v-else&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="8b9184088f073256f499eaedf7653670276bb736" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;you should not use an arrow function to define a watcher&lt;/em&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; 只能添加到 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt;（&lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;一个例外&lt;/a&gt;），与不推荐使用的&lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; 属性不同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da6d6a25d31f792c92e4d4f94e109dce6aa1ce03" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#abbreviated-syntax-for-lone-default-slots&quot;&gt;one exception&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">注意，&lt;strong&gt;本地注册的组件在子组件中&lt;em&gt;也不&lt;/em&gt;可用&lt;/strong&gt;。例如，如果希望 &lt;code&gt;ComponentA&lt;/code&gt; 在 &lt;code&gt;ComponentB&lt;/code&gt; 中可用，则必须使用：</target>
        </trans-unit>
        <trans-unit id="bf48dec89b052e2c67a866740d5df77b8220622a" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you'd have to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">请注意，&lt;strong&gt;您不应使用箭头函数定义方法&lt;/strong&gt;（例如 &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ）。原因是箭头函数绑定了父上下文，因此 &lt;code&gt;this&lt;/code&gt; 将不是您期望的Vue实例，并且 &lt;code&gt;this.a&lt;/code&gt; 将是未定义的。</target>
        </trans-unit>
        <trans-unit id="641353cb3566fc5149312b741e1f12c37e6b249c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">请注意，&lt;strong&gt;您不应使用箭头函数来定义观察者&lt;/strong&gt;（例如 &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ）。原因是箭头函数绑定了父上下文，因此 &lt;code&gt;this&lt;/code&gt; 将不是您期望的Vue实例，并且 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; 将是未定义的。</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">请注意，Vue的事件系统不同于浏览器的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;。虽然他们的工作同样， &lt;code&gt;$emit&lt;/code&gt; ， &lt;code&gt;$on&lt;/code&gt; ，和 &lt;code&gt;$off&lt;/code&gt; 是&lt;strong&gt;不是&lt;/strong&gt;对的别名 &lt;code&gt;dispatchEvent&lt;/code&gt; ， &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;removeEventListener&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="081986e34f15d320aaefef70aa73f69abdde7609" translate="yes" xml:space="preserve">
          <source>Note that all native HTML and SVG tags don't need to be matched in this function - Vue parser performs this check automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34975db8bc1ca3043980cfeb4c62b733ac3c9bed" translate="yes" xml:space="preserve">
          <source>Note that every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;a href=&quot;special-attributes#key&quot;&gt;&lt;strong&gt;uniquely keyed&lt;/strong&gt;&lt;/a&gt; for the animations to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">请注意，对于其他指令（例如 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; ），JavaScript的正常真实性仍然适用。</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">请注意，如果您使用箭头功能与计算性能， &lt;code&gt;this&lt;/code&gt; 不会是组件的实例，但你仍然可以访问实例作为函数的第一个参数：</target>
        </trans-unit>
        <trans-unit id="56e9ff50c8f4d3af5530daf6166e647efccff678" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">请注意，如果您使用箭头功能与 &lt;code&gt;data&lt;/code&gt; 属性， &lt;code&gt;this&lt;/code&gt; 不会是组件的实例，但你仍然可以访问实例作为函数的第一个参数：</target>
        </trans-unit>
        <trans-unit id="b844a1894b3639cf8e6947f52c1732f36fa3f2ea" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">请注意，在ES2015 +中，将像 &lt;code&gt;ComponentA&lt;/code&gt; 这样的变量名放在对象内是 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 简写，这意味着变量的名称是两个：</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">请注意,在这个方法中,我们在不接触DOM的情况下更新应用的状态--所有的DOM操作都由Vue来处理,你写的代码集中在底层逻辑上。</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">请注意，&lt;strong&gt;不&lt;/strong&gt;建议同时使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;样式指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="faa9c0503d39b650734e81c8480f148f8158dc6a" translate="yes" xml:space="preserve">
          <source>Note that it's &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">需要注意的是修饰键从常规按键不同，与使用时 &lt;code&gt;keyup&lt;/code&gt; 事件，他们有当发出该事件被按下。换句话说， &lt;code&gt;keyup.ctrl&lt;/code&gt; 仅在按住 &lt;code&gt;ctrl&lt;/code&gt; 的同时释放键时才会触发。如果仅释放 &lt;code&gt;ctrl&lt;/code&gt; 键，则不会触发。如果你想这样的行为，使用 &lt;code&gt;keyCode&lt;/code&gt; 为 &lt;code&gt;ctrl&lt;/code&gt; 改为： &lt;code&gt;keyup.17&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a575c0c184061dc0e5bebafa17e97ed49b8df32d" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won't trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">请注意，JavaScript中的对象和数组是通过引用传递的，因此，如果prop是数组或对象，则在子组件内部对对象或数组本身进行更改&lt;strong&gt;将&lt;/strong&gt;影响父状态。</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">请注意，&lt;strong&gt;在&lt;/strong&gt;创建组件实例&lt;strong&gt;之前先&lt;/strong&gt;对props进行了验证，因此实例属性（例如 &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;computed&lt;/code&gt; 等）在 &lt;code&gt;default&lt;/code&gt; 或 &lt;code&gt;validator&lt;/code&gt; 函数中将不可用。</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 元素仍然有效地重复使用，因为它们没有 &lt;code&gt;key&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">请注意，默认槽位的缩写语法&lt;strong&gt;不能&lt;/strong&gt;与命名槽位混合使用，因为这会导致范围模糊：</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">请注意，在 &lt;code&gt;Vue.extend()&lt;/code&gt; 中使用了相同的合并策略。</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">请注意，使用 &lt;code&gt;immediate&lt;/code&gt; 选项，您将无法在第一个回调调用中取消监视给定的属性。</target>
        </trans-unit>
        <trans-unit id="a7894715668a9552d744e1da5cfc8208dcef0a9e" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won't be able to unwatch the given property on the first callback call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d1222c87974bff7446442d086ef17e96241dd6" translate="yes" xml:space="preserve">
          <source>Note that with this approach, you can only use methods, not computed properties, as the latter only make sense when defined in the context of an individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">请注意，必须在组件方法中包括 &lt;code&gt;strict: true&lt;/code&gt; （或至少 &lt;code&gt;noImplicitThis: true&lt;/code&gt; ，它是 &lt;code&gt;strict&lt;/code&gt; 标志的一部分），以利用 &lt;code&gt;this&lt;/code&gt; 类型的检查，否则始终将其视为 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">请注意，如果您希望对路由组件使用上述语法，则必须使用&lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+。</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">请注意，您仍然必须在组件的 &lt;code&gt;props&lt;/code&gt; 选项中声明 &lt;code&gt;checked&lt;/code&gt; prop 。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">注意 &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 属性。这在DOM模板中是必需的，因为在 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 中只有 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 元素有效。它的作用与 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 相同，但可以解决潜在的浏览器解析错误。请参阅&lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM模板解析警告&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="dd73b9ea52e1db8097dc7a516386c176573e1dbe" translate="yes" xml:space="preserve">
          <source>Note this &lt;code&gt;props&lt;/code&gt; object is reactive - i.e. it is updated when new props are passed in, and can be observed and reacted upon using &lt;code&gt;watchEffect&lt;/code&gt; or &lt;code&gt;watch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">注意， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 是为其中一个直接子组件被切换的情况而设计的。如果内部有 &lt;code&gt;v-for&lt;/code&gt; ，则无法使用。如上所述，当有多个有条件的子代时， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 要求一次仅渲染一个子代。</target>
        </trans-unit>
        <trans-unit id="da58435f34b35b1887295eb16c900d592e7442c7" translate="yes" xml:space="preserve">
          <source>Note: In 3.x, slots can be rendered as the root with native &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; support!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">注意：在Macintosh键盘上，meta是命令键（⌘）。在Windows键盘上，meta是Windows键（⊞）。在Sun Microsystems键盘上，meta被标记为实心菱形（◆）。在某些键盘上，特别是MIT和Lisp机器键盘以及后继键盘（例如Knight键盘，太空学员键盘），meta标记为&amp;ldquo; META&amp;rdquo;。在Symbolics键盘上，meta标记为&amp;ldquo; META&amp;rdquo;或&amp;ldquo; Meta&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">注意：在2.3.0之前的版本中，如果您希望在功能组件中接受props，则需要 &lt;code&gt;props&lt;/code&gt; 选项。在2.3.0+中，您可以省略 &lt;code&gt;props&lt;/code&gt; 选项，并且在组件节点上找到的所有属性都将隐式提取为props。</target>
        </trans-unit>
        <trans-unit id="334bf93841cedfd326dcac54017cd67d04bd2494" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">注： &lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 绑定没有反应。这是故意的。但是，如果向下传递观察到的对象，则该对象的属性确实保持反应性。</target>
        </trans-unit>
        <trans-unit id="0908b002b159b7c5ec7a450ce89576a7ca8ba515" translate="yes" xml:space="preserve">
          <source>Note: the beta channel may conflict with the stable version of devtools so you may need to temporarily disable the stable version for the beta channel to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">注：该选项并&lt;strong&gt;不会&lt;/strong&gt;影响到 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; 的绑定。</target>
        </trans-unit>
        <trans-unit id="08b75004d7b0e0a6d3825e3c52c9e938d2e8a019" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6381b17960004aa9578834992d92eb41037168d9" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML. When using in-DOM templates, the template is subject to native HTML parsing rules. Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">注意：变异（而不是替换）对象或数组时，旧值将与新值相同，因为它们引用相同的对象/数组。Vue不会保留突变前值的副本。</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">请注意，所有改变商店状态的操作都放在商店本身内部。这种类型的集中状态管理可以更轻松地了解可能发生什么类型的突变以及如何触发它们。现在，当出现问题时，我们还将获得导致该错误的事件日志。</target>
        </trans-unit>
        <trans-unit id="571333a47c31bbee3623511f092d63b988f1b343" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd794a6843de7d3ad1a1df1f2c8c06559b41eae" translate="yes" xml:space="preserve">
          <source>Notice how you can include &lt;code&gt;autocomplete='on'&lt;/code&gt; on the form element and it will apply to all inputs in your form. You can also set different &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete&quot;&gt;values for autocomplete attribute (opens new window)&lt;/a&gt; for each input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73647a8d9626dfeb015e786688a6df3934b4f805" translate="yes" xml:space="preserve">
          <source>Notice that this will move the actual DOM nodes instead of being destroyed and recreated, and it will keep any component instances alive as well. All stateful HTML elements (i.e. a playing video) will keep their state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">请注意，单击按钮时，每个按钮都会维护自己的单独 &lt;code&gt;count&lt;/code&gt; 。这是因为每次使用组件时，都会创建该组件的新&lt;strong&gt;实例&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6d30d0e0ff05d60e422be32271f1e21965033ef6" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That's because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc80ae205fd608099bd57a38126221c490c9a421" translate="yes" xml:space="preserve">
          <source>Notice that when the component's &lt;code&gt;created&lt;/code&gt; lifecycle hook triggers, the &lt;code&gt;modelModifiers&lt;/code&gt; prop contains &lt;code&gt;capitalize&lt;/code&gt; and its value is &lt;code&gt;true&lt;/code&gt; - due to it being set on the &lt;code&gt;v-model&lt;/code&gt; binding &lt;code&gt;v-model.capitalize=&quot;myText&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">现在， &lt;code&gt;v-model&lt;/code&gt; 应该可以与该组件完美配合：</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">现在，可以在 &lt;code&gt;ComponentB&lt;/code&gt; 的模板中使用 &lt;code&gt;ComponentA&lt;/code&gt; 和 &lt;code&gt;ComponentC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d88909194979ead139b391709a958720c86553b7" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;'s template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caffa3b79738c5125111f76c75b50ac902d4aecd" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">现在， &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素内的所有内容都将传递到相应的插槽。假定未将任何未包装在使用 &lt;code&gt;v-slot&lt;/code&gt; 的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的内容用于默认插槽。</target>
        </trans-unit>
        <trans-unit id="3e4140c0dde663257b36afdec9358a935995f01d" translate="yes" xml:space="preserve">
          <source>Now in Vue 3, all functional components are created with a plain function. In other words, there is no need to define the &lt;code&gt;{ functional: true }&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">现在，在定义了这个 &lt;code&gt;ref&lt;/code&gt; 的组件中，您可以使用：</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">现在是时候进行深入研究了！Vue最独特的功能之一是不引人注目的反应系统。模型只是普通的JavaScript对象。修改它们时，视图将更新。它使状态管理变得简单而直观，但是了解它如何工作来避免一些常见问题也很重要。在本节中，我们将深入研究Vue反应系统的一些底层细节。</target>
        </trans-unit>
        <trans-unit id="416cefac38d5a91dc03601ff2321b1747824eafd" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are proxied JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">现在，让我们在每个帖子的内容之前添加一个按钮来放大文本：</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">现在让我们来看一个示例，使用我们之前使用的相同CSS类转换进入和离开：</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">现在让我们来看一个例子。这是使用Velocity.js的JavaScript过渡：</target>
        </trans-unit>
        <trans-unit id="88e72442353d1cc70a649bbfb7fde5fcd5a0942a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start with extracting the first logical concern (marked as &quot;1&quot; in the original snippet).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">现在，让我们使用 &lt;code&gt;out-in&lt;/code&gt; 更新开/关按钮的过渡：</target>
        </trans-unit>
        <trans-unit id="61d7e41c0d0afefd3a6e0b42734a3aa3ca5ebe0d" translate="yes" xml:space="preserve">
          <source>Now let's add a button to enlarge the text right before the content of every post:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56027a462aa3978a9b96d4374ca36d15fa649ef8" translate="yes" xml:space="preserve">
          <source>Now let's build the directive that accomplishes this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f599733aef531ac3cec8a9e1bc4b342515b0f147" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example, transitioning entering and leaving using the same CSS classes we've used previously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3324adaea061622687d6176489328922e25a0701" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example. Here's a JavaScript transition using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f77a5a07be37fa843c2b64e4b6651919be0542c" translate="yes" xml:space="preserve">
          <source>Now let's extend our directive logic to recalculate the distance to pin on component update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b244b43642c6b5693f8cc0207f277488e09d82e" translate="yes" xml:space="preserve">
          <source>Now let's update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b586c00a91f7688367b4cacd0212bee0c1ca54f" translate="yes" xml:space="preserve">
          <source>Now that the custom directive lifecycle hooks mirror those of the components themselves, they become easier to reason about and remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aacb98515307b9797f4efe520f56ffcc9d7f5e" translate="yes" xml:space="preserve">
          <source>Now that we have our prop set up, we can check the &lt;code&gt;modelModifiers&lt;/code&gt; object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; element fires an &lt;code&gt;input&lt;/code&gt; event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf65b7d19a965e9b08bfa030c0b0ce8f415f6a3" translate="yes" xml:space="preserve">
          <source>Now that we know how watchers are updating the components, you might ask how those changes eventually make it to the DOM! Perhaps you&amp;rsquo;ve heard of the Virtual DOM before, many frameworks including Vue use this paradigm to make sure our interfaces reflect the changes we&amp;rsquo;re updating in JavaScript effectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f0e4739b10c5c53576af812b04069f5b1133df" translate="yes" xml:space="preserve">
          <source>Now that we know the &lt;strong&gt;why&lt;/strong&gt; we can get to the &lt;strong&gt;how&lt;/strong&gt;. To start working with the Composition API we first need a place where we can actually use it. In a Vue component, we call this place the &lt;code&gt;setup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">现在， &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 组件是一个&lt;strong&gt;完全透明的包装器&lt;/strong&gt;，这意味着它可以像普通的 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素一样完全使用：所有相同的属性和侦听器都可以使用，而无需 &lt;code&gt;.native&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="5577e953820ec1b24aed02306173d947e4a546b7" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;focus&lt;/code&gt; directive will be available in both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; instances and their descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">现在，即使未呈现，&amp;ldquo; &lt;em&gt;帖子&amp;rdquo;&lt;/em&gt;选项卡仍保持其状态（选定的帖子）。有关完整的代码，请参&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;见此小提琴&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa9b9e0ccefb495f319a6491a7e676d9dacfb2b2" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it's not rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">现在,这些输入将在你每次切换时从头呈现。你自己看看吧。</target>
        </trans-unit>
        <trans-unit id="0c9d8ea18bd7c1be0ebb6900315a3a7aaedea656" translate="yes" xml:space="preserve">
          <source>Now we can compose multiple states with these child components. It's exciting- we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue's &lt;a href=&quot;transitions-enterleave&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">现在我们可以使用 &lt;code&gt;v-bind&lt;/code&gt; 将待办事项传递到每个重复的组件中：</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">现在我们得到。</target>
        </trans-unit>
        <trans-unit id="3ca602ef2620d2d54650ef4ef89bcc645f4b53a2" translate="yes" xml:space="preserve">
          <source>Now we need to react to the changes made to the &lt;code&gt;user&lt;/code&gt; prop. For that we will use the standalone &lt;code&gt;watch&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">现在，我们将回答社区可以为您做些什么以及您可以为社区做些什么。</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">现在，在此组件上使用 &lt;code&gt;v-model&lt;/code&gt; 时：</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">现在，当我们在父组件中使用 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 时，不提供该插槽的任何内容：</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">现在，当我们使用 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 组件时，我们可以有选择地为待办事项定义一个替代的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; ，但是可以从子级访问数据：</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">现在，当您运行 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; ，将调用setter 并 &lt;code&gt;vm.lastName&lt;/code&gt; 地更新 &lt;code&gt;vm.firstName&lt;/code&gt; 和vm.lastName。</target>
        </trans-unit>
        <trans-unit id="99a7fc3db6e58b44e0a648173eebd65a414924c6" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;appA&lt;/code&gt; and &lt;code&gt;appB&lt;/code&gt; will update their views automatically. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">现在，只要对 &lt;code&gt;sourceOfTruth&lt;/code&gt; 进行了 &lt;code&gt;vmA&lt;/code&gt; ，vmA和 &lt;code&gt;vmB&lt;/code&gt; 都将自动更新其视图。每个实例中的子组件也可以通过 &lt;code&gt;this.$root.$data&lt;/code&gt; 。现在我们只有一个事实来源，但是调试将是一场噩梦。应用程序的任何部分都可以随时更改任何数据，而不会留下任何痕迹。</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">现在，您可以在另一个组件的模板中编写它：</target>
        </trans-unit>
        <trans-unit id="a045cd84f5be21505ce08157ae51e1f45c687302" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1476c1cb56c53ca2f243a141ad4a636da2115a2b" translate="yes" xml:space="preserve">
          <source>Now, if anything changes in either property, the &lt;code&gt;MyMarker&lt;/code&gt; component will automatically be updated as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93161c9554bdbf350b67c1c62a2064b5a47aa2d" translate="yes" xml:space="preserve">
          <source>Now, in Vue 3, since functional components are defined as pure functions, async components definitions need to be explicitly defined by wrapping it in a new &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，只要将新属性添加到 &lt;code&gt;post&lt;/code&gt; 对象中，它就会自动在 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 内部可用。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">对象变更检测的注意事项</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">对象文字</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">对象语法</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">国家预防机制包中的正式声明</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">正式的类通量实施</target>
        </trans-unit>
        <trans-unit id="253fefc301bfd7132218b7557a6391250b616a46" translate="yes" xml:space="preserve">
          <source>Official Jest Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e814049718b1d932cec7462837ebe879f922b" translate="yes" xml:space="preserve">
          <source>Official Mocha Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">官方路由器</target>
        </trans-unit>
        <trans-unit id="25d0bd72df27202461d0c5f9c7e08418ec21f91d" translate="yes" xml:space="preserve">
          <source>Official Vue 2 CLI Plugin - Jest (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b102013e2e4e3b2a122cd90521f7abb18b815e29" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Cypress Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4283002bfc2991c088ab89cd2443eafba975ab6b" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Nightwatch Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e38d4cb7819fb2b7ca582192edc9ff4825e473e" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Plugin - Mocha (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5bc6dab6176b349e0ef77df3008fa9ea3cb2b1" translate="yes" xml:space="preserve">
          <source>Official Vue Test Utils Documentation (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e4e38b0d8be787a92f6532c519c8963542cb77" translate="yes" xml:space="preserve">
          <source>Official Vue Testing Library Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fafe60967df029303e74079e269747316a51820" translate="yes" xml:space="preserve">
          <source>Ok, so far, we&amp;rsquo;re just wrapping that object and returning it. Cool, but not that useful yet. But watch this, we can also intercept this object while we wrap it in the Proxy. This interception is called a trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5c4c2f29b26dd8b70d7595e8bde56c7c36488" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit an &lt;code&gt;update:modelValue&lt;/code&gt; event with the new value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">在 &lt;code&gt;input&lt;/code&gt; ，发出自己的定制 &lt;code&gt;input&lt;/code&gt; 事件与新价值</target>
        </trans-unit>
        <trans-unit id="8353eb035df2b7f6ca17019debdf96a3f22eb88a" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;setup()&lt;/code&gt; function, you don't need to pass a typing to &lt;code&gt;props&lt;/code&gt; parameter as it will infer types from &lt;code&gt;props&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf41ca9bc7d54b6c5ac4b857c3027240934a3189" translate="yes" xml:space="preserve">
          <source>On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">在更高的层次上,我们可以将组件分为两类:呈现性的和逻辑性的。我们推荐使用模板来处理演示性组件,而使用渲染函数/JSX来处理逻辑性组件。这些组件的比例取决于你正在构建的应用程序的类型,但一般来说,我们发现呈现性的组件更为常见。</target>
        </trans-unit>
        <trans-unit id="6c3d3824299b5122ad70d07d38a8fd8a0336c35b" translate="yes" xml:space="preserve">
          <source>On conditional branches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">在普通组件上，未定义为prop的属性会自动添加到组件的根元素中，从而替换或&lt;a href=&quot;class-and-style&quot;&gt;智能合并&lt;/a&gt;任何同名的现有属性。</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">在根Vue实例（即使用 &lt;code&gt;new Vue({ ... })&lt;/code&gt; 创建的实例）上，必须使用 &lt;code&gt;propsData&lt;/code&gt; 而不是 &lt;code&gt;props&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">另一方面， &lt;code&gt;$refs&lt;/code&gt; 主要设计用于JavaScript中的编程访问-不建议在模板中依赖它们，因为这将意味着引用不属于实例本身的状态。这将违反Vue的数据驱动视图模型。</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">另一方面，仅运行时版本完全符合CSP。当通过&lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt;或&lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;使用仅限运行时的版本时，您的模板将被预编译为 &lt;code&gt;render&lt;/code&gt; 功能，这些功能可以在CSP环境中完美运行。</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">在此页面上，我们仅介绍进入，离开和列出转换，但是您可以在下一节中了解如何&lt;a href=&quot;transitioning-state&quot;&gt;管理状态转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4cdb09dd5b26c91e66320cefa8ce757b9de6879" translate="yes" xml:space="preserve">
          <source>On this page, we'll only cover entering, and leaving, but you can see the next sections for &lt;a href=&quot;transitions-list&quot;&gt;list transitions&lt;/a&gt; and &lt;a href=&quot;transitions-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">一旦一个道具被注册,你可以将数据作为一个自定义属性传递给它,就像这样。</target>
        </trans-unit>
        <trans-unit id="d2e7a62de13ea6daf472e90fd22d2267995fceed" translate="yes" xml:space="preserve">
          <source>Once a user changes route, bring focus back to the skip link. This can be achieved by calling focus to the &lt;code&gt;ref&lt;/code&gt; provided below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">再次尝试不要过度使用此模式。尽管在少数情况下必须渲染大量静态内容很方便，但是除非您实际上注意到渲染速度很慢，否则根本没有必要，而且在以后可能会引起很多混乱。例如，想象另一个不熟悉 &lt;code&gt;v-once&lt;/code&gt; 或只是在模板中错过了它的开发人员。他们可能会花费数小时来试图弄清为什么模板未正确更新。</target>
        </trans-unit>
        <trans-unit id="e74c60c8736c1be5dff55d13ab945f687b554058" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering - plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167f3f5ddd7e9428d499efaab9f381bdb3ed2c55" translate="yes" xml:space="preserve">
          <source>Once from &lt;code&gt;$emit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c922783f828b42530826b639b30161731661fae" translate="yes" xml:space="preserve">
          <source>Once from a native event listener applied to the root element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">一旦被观察到,你就不能再向根数据对象添加反应式属性。因此,建议在创建实例之前,预先声明所有根级反应式属性。</target>
        </trans-unit>
        <trans-unit id="e8b9b74226ba51585f69fe08ce0443127353058d" translate="yes" xml:space="preserve">
          <source>Once the file is created we will need to open it with our editor of choice and add the following code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">一旦您对刚学过的知识感到满意，我们建议您重新阅读有关&amp;ldquo; &lt;a href=&quot;components-dynamic-async&quot;&gt;动态和异步组件&amp;rdquo;&lt;/a&gt;的完整指南，以及侧栏的&amp;ldquo;组件深度&amp;rdquo;部分中的其他页面。</target>
        </trans-unit>
        <trans-unit id="60acc179819cc9885eb67653fbd8f4d03d08954a" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on &lt;a href=&quot;component-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">重要的注意事项是，这些FLIP过渡不适用于设置为 &lt;code&gt;display: inline&lt;/code&gt; 元素：inline。或者，您可以使用 &lt;code&gt;display: inline-block&lt;/code&gt; 或将元素放置在flex上下文中。</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">要注意的一件事是，&lt;strong&gt;关注点的分离不等于文件类型的分离。&lt;/strong&gt;在现代UI开发中，我们发现，将代码库分为松散耦合的组件并组成它们，这比将代码库分为相互交织的三大层更有意义。在组件内部，其模板，逻辑和样式固有地耦合在一起，并且将它们并置实际上会使组件更具凝聚力和可维护性。</target>
        </trans-unit>
        <trans-unit id="b2c093743cd92f3eef8061e180eeec927b862729" translate="yes" xml:space="preserve">
          <source>One of the issues with placeholders is that they don't meet the &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html&quot;&gt;color contrast criteria (opens new window)&lt;/a&gt; by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">最常见的过渡类型之一是CSS过渡。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="f3084514831f9a3660901b496859b78c114ded95" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">这些方法最常见的用途之一是在父母与其直系子女之间进行交流。在这些情况下，您实际上可以&lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;使用&lt;/a&gt; &lt;code&gt;v-on&lt;/code&gt; 听孩子的 &lt;code&gt;$emit&lt;/code&gt; 。这使您可以通过增加明确性来保持事件的便利性。</target>
        </trans-unit>
        <trans-unit id="f582da9a59b59f7794fc88389aa5092b1a4c440b" translate="yes" xml:space="preserve">
          <source>One of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5441c2b16e737c07dfa65dd03fc760dc9068959" translate="yes" xml:space="preserve">
          <source>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1aa62162a2a83d170cfdbdcd416abaeb0b419" translate="yes" xml:space="preserve">
          <source>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">一个或多个命名参数已&lt;sup&gt;更改&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">需要注意的一件事：类似于 &lt;code&gt;v-bind:class&lt;/code&gt; 和 &lt;code&gt;v-bind:style&lt;/code&gt; 在模板中有特殊处理的方式，它们在VNode数据对象中有自己的顶级字段。此对象还允许您绑定普通的HTML属性以及DOM属性（例如 &lt;code&gt;innerHTML&lt;/code&gt; )（这将替换 &lt;code&gt;v-html&lt;/code&gt; 指令）：</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">一次绑定（ &lt;code&gt;{{* foo }}&lt;/code&gt; ）已被新的&lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; 指令&lt;/a&gt;替换。</target>
        </trans-unit>
        <trans-unit id="b15ca056f8f4ec061aff57aa3f191e7c02753b7c" translate="yes" xml:space="preserve">
          <source>One way to share configurations e.g. components or directives among apps is to create a factory function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">一次性绑定已&lt;sup&gt;替换&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">单向数据流</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">只有UMD构建可以从Bower那里获得。</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">只有Vue Router 2与Vue 2兼容，因此，如果要更新Vue，则还必须更新Vue Router。这就是为什么我们在主要文档中此处包含有关迁移路径的详细信息的原因。有关使用新Vue路由器的完整指南，请参阅&lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue路由器文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">只有Vue Router 2与Vue 2兼容，因此，是的，您还必须遵循&lt;a href=&quot;migration-vue-router&quot;&gt;Vue Router&lt;/a&gt;的迁移路径。幸运的是，大多数应用程序没有很多路由器代码，因此这可能不会花费一个多小时。</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">仅在2.2.0+中:也适用于Array+index。</target>
        </trans-unit>
        <trans-unit id="1c17fd71b6108eae91a98b2783d1ada7a72eca67" translate="yes" xml:space="preserve">
          <source>Opacity behaves similarly. Thus, they are ideal candidates for movement on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c41eb847c8622b8581eed87c208351ff18e6769" translate="yes" xml:space="preserve">
          <source>Operable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caec8acecc60ba151e62b5850f83574dfd99c0d7" translate="yes" xml:space="preserve">
          <source>Optimal compatibility with the Vue ecosystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">优化工作</target>
        </trans-unit>
        <trans-unit id="e4b9f85b5d7b01dca8287331249e33d3c5156887" translate="yes" xml:space="preserve">
          <source>Option #1: Use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6301bb50d7829f5c1bc253cc74ede56ad6a957e0" translate="yes" xml:space="preserve">
          <source>Option #2: Default Slot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">合并选项</target>
        </trans-unit>
        <trans-unit id="f674131a41d74d291985eeac34569e45a2796480" translate="yes" xml:space="preserve">
          <source>Optional configuration options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">期权/资产</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">选项/组成</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">选项/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">选项/数据</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">选项/生命周期挂钩</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">选项/其他</target>
        </trans-unit>
        <trans-unit id="b30e44ad585ea6e546f21a0445864b10944795c8" translate="yes" xml:space="preserve">
          <source>Options / Misc - inheritAttrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474ba12c459599d7f3d05d19597c94aa345c6ae6" translate="yes" xml:space="preserve">
          <source>Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">诸如 &lt;code&gt;acceptStatement&lt;/code&gt; ， &lt;code&gt;deep&lt;/code&gt; ， &lt;code&gt;priority&lt;/code&gt; 等的选项已全部删除。要替换 &lt;code&gt;twoWay&lt;/code&gt; 指令，请参见&lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;以下示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">期望对象值的选项，例如 &lt;code&gt;methods&lt;/code&gt; ， &lt;code&gt;components&lt;/code&gt; 和 &lt;code&gt;directives&lt;/code&gt; ，将被合并到同一对象中。当这些对象中的键冲突时，将优先使用组件的选项：</target>
        </trans-unit>
        <trans-unit id="2cf7aafc0cf21a0635200b597f31b1c9a97361eb" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cccb1cf88b26495b712b582b1851dcc7cb203e2" translate="yes" xml:space="preserve">
          <source>Or a &lt;code&gt;setup&lt;/code&gt; function, function name will be used as component name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">或者是一个数据/计算的属性。</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">或渲染功能。</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">或者，可以在本地注册组件时使用Webpack的异步 &lt;code&gt;import&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">或者更好的是,将移除方法传递一个索引。</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">甚至其他组件。</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">或者，如果 &lt;code&gt;myElement&lt;/code&gt; 是最后一个孩子：</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">或者，如果您正在使用ES2015模块（例如通过Babel和Webpack），则可能看起来更像：</target>
        </trans-unit>
        <trans-unit id="b481ed2ba5dbbc7e0f7386d267111e8bdfabf1ae" translate="yes" xml:space="preserve">
          <source>Or if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8ab6aa568615f78c04477ef62787486065b5dc" translate="yes" xml:space="preserve">
          <source>Or in a render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4959514a6e663f87294927771d85f57df1ba3c86" translate="yes" xml:space="preserve">
          <source>Or with Yarn:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">或者用渲染功能。</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">或者用组件方法。</target>
        </trans-unit>
        <trans-unit id="af14db0c16953bef3557a6e30a1aace5e18d1edd" translate="yes" xml:space="preserve">
          <source>Or, for the more advanced component syntax with options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e16431e1f0d282812696aa421107f6f8ecec16e" translate="yes" xml:space="preserve">
          <source>Or, for those who preferred the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; in a single-file component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">或者,如果事件处理程序是一个方法。</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">或者，如果您使用的是仅运行时的Vue版本：</target>
        </trans-unit>
        <trans-unit id="1ce87eef2b959ce134a14284177345e12a8eb332" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve been unit-testing an application involving &lt;a href=&quot;../component-dynamic-async&quot;&gt;async components&lt;/a&gt;, chances are you&amp;rsquo;ve written something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">或者， &lt;code&gt;slot&lt;/code&gt; 属性也可以直接在普通元素上使用：</target>
        </trans-unit>
        <trans-unit id="2ab1ce11bd9c8abf32d55c7982f3dae620e8cb0a" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c548ba963676210f5bfb2bdd1152c86a09840f88" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Gulp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">或者，通过&lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt&lt;/a&gt;和grunt- &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;browserify&lt;/a&gt;使用envify：</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">或者，在Gulp中使用&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f1956be0d3870d999ee378a0178cc016dd3ada0f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;@click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;@click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">使用修饰符时顺序很重要，因为相关代码以相同顺序生成。因此，使用 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; 将阻止&lt;strong&gt;所有单击，&lt;/strong&gt;而 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; 将仅防止单击元素本身。</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">组成部分名称中的词序</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;组件名称中的单词顺序&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">组织组件</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">将过渡组织成组成部分</target>
        </trans-unit>
        <trans-unit id="360d7d42956f7872b9ede3cea3c30a3ba0acec02" translate="yes" xml:space="preserve">
          <source>Organizing logics with component's options (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;) works in most cases. However, when our components get bigger, the list of &lt;strong&gt;logical concerns&lt;/strong&gt; also grows. This can lead to components that are hard to read and understand, especially for people who didn't write them in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">其他例子</target>
        </trans-unit>
        <trans-unit id="c3d0ce766708c752c9789d75994b0abdc210827b" translate="yes" xml:space="preserve">
          <source>Other Helpful Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f144ccf73f0c206f299610267139c1512e90bc" translate="yes" xml:space="preserve">
          <source>Other Minor Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12ddde082114607d0effddf28c1425f7adad67d" translate="yes" xml:space="preserve">
          <source>Other Projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8096cf3d3237b4ba8c7121f2a65c1398f3cfa1d7" translate="yes" xml:space="preserve">
          <source>Other non-boolean attrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">我们的&lt;a href=&quot;https://vuejs.org/coc&quot;&gt;《行为准则》&lt;/a&gt;是一项指南，旨在使我们所有人和我们所参与的技术社区变得更加容易。</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">我们的自定义指令现在足够灵活,可以支持一些不同的用例。</target>
        </trans-unit>
        <trans-unit id="6914ca8cedbdd86cdefec4f8279bb23f3c749797" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases. To make it even more dynamic, we can also allow to modify a bound value. Let's create an additional property &lt;code&gt;pinPadding&lt;/code&gt; and bind it to the &lt;code&gt;&amp;lt;input type=&quot;range&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">我们的设置代码与我们的清理代码是分开的,这使得我们设置的任何东西在程序上清理起来更加困难。</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">但是随着时间的流逝，淘汰赛的发展已经放慢了脚步，并且开始显示出它的年龄。例如，其组件系统缺少完整的生命周期挂钩，尽管这是一个非常常见的用例，但与&lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt;相比，将孩子传递到组件的界面感觉有些笨拙。</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">总体而言，这消除了开发人员对整体性能优化的需求，使他们可以在扩展应用程序时更加专注于构建应用程序本身。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">部分部分已被删除，以便使用prop支持组件之间更明确的数据流。除非您在性能至关重要的区域中使用局部部件，否则建议您改用&lt;a href=&quot;components&quot;&gt;普通组件&lt;/a&gt;。如果要动态绑定部分的 &lt;code&gt;name&lt;/code&gt; ，则可以使用&lt;a href=&quot;components#Dynamic-Components&quot;&gt;动态组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCase比起kebab-case有一些优势。</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase与代码编辑器中的自动完成功能配合使用效果最佳，因为它与我们尽可能引用JS（X）和模板中的组件的方式一致。但是，大小写混合的文件名有时会在不区分大小写的文件系统上产生问题，这就是为什么kebab-case也完全可以接受的原因。</target>
        </trans-unit>
        <trans-unit id="030bc27225285970757d5743a8972ff008b358d3" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">在创建实例时将道具传递给实例。这主要是为了使单元测试更容易。</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">将属性和事件传递给子元素/组件。</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">使用道具将数据传递给子组件</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">传递静态或动态道具</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">传递一个布尔值</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">传递数字</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">传递一个数组</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">传递对象</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">在选项中传递 &lt;code&gt;immediate: true&lt;/code&gt; 将立即使用表达式的当前值触发回调：</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">传递对象的属性</target>
        </trans-unit>
        <trans-unit id="c6e21e8099f57238a0c9760ebd07a5a614584331" translate="yes" xml:space="preserve">
          <source>People need to feel safe asking questions when contributing/reviewing content. Here's how you can do that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e116a18efa00a0e0767d89a0a941c40133b88a" translate="yes" xml:space="preserve">
          <source>Perceivable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf952b12947766273332fa80b06a64c003fbf12" translate="yes" xml:space="preserve">
          <source>Perform the side effect lazily;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="93bd1b9f8459e0acda65f78340bb55e6188adccd" translate="yes" xml:space="preserve">
          <source>Performance gains from 2.x for functional components are now negligible in 3.x, so we recommend just using stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">在性能方面，即使在Ember 3.x中更新了最新的Glimmer引擎之后，Vue仍比Ember表现&lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;出相当大的优势&lt;/a&gt;。Vue自动批处理更新，而在Ember中，您需要在性能关键的情况下手动管理运行循环。</target>
        </trans-unit>
        <trans-unit id="ed212fa164b940b935ec0a25b32878a0917c7268" translate="yes" xml:space="preserve">
          <source>Placeholder</source>
          <target state="translated">Placeholder</target>
        </trans-unit>
        <trans-unit id="11275f5de90c26fd6cc8ef9a7af920c6f1101f2b" translate="yes" xml:space="preserve">
          <source>Please note we used &lt;code&gt;model-value&lt;/code&gt; with kebab-case here because we are working with in-DOM templates. You can find a detailed explanation on kebab-cased vs camelCased attributes in the &lt;a href=&quot;#dom-template-parsing-caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">请参考&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode类声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">请参考&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer软件包文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1dadf730922f5cc0e3cc5b34354923331bd7cd59" translate="yes" xml:space="preserve">
          <source>Plugin users will now be able to &lt;code&gt;inject['i18n']&lt;/code&gt; into their components and access the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="a39e5a3d43de88abead0db5ad2318b757a0d742a" translate="yes" xml:space="preserve">
          <source>Plugins also allow us to use &lt;code&gt;inject&lt;/code&gt; to provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the &lt;code&gt;options&lt;/code&gt; parameter to be able to use the translations object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd12b92cd6c82b740fa6a101861368f2df9e451" translate="yes" xml:space="preserve">
          <source>Plugins are self-contained code that usually add global-level functionality to Vue. It is either an &lt;code&gt;object&lt;/code&gt; that exposes an &lt;code&gt;install()&lt;/code&gt; method, or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">插件可能会添加到Vue的全局/实例属性和组件选项。在这些情况下，需要使用类型声明来使插件在TypeScript中编译。幸运的是，有一个TypeScript功能可以扩展现有的类型，称为&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;模块扩充&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">插件通常为Vue添加全局级功能。一个插件没有严格定义的范围--通常有几种类型的插件。</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer是Google赞助的另一个项目，实际上也是Vue的灵感来源。Vue的组件可以与Polymer的自定义元素进行比较，并且两者都提供非常相似的开发风格。最大的不同是，Polymer是基于最新的Web组件功能构建的，并且要求非平凡的polyfill才能在本身不支持这些功能的浏览器中工作（性能下降）。相比之下，Vue可以在没有任何依赖项的情况下工作，也不会填充到IE9。</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">预编译模板</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Preact和其他类似React的图书馆</target>
        </trans-unit>
        <trans-unit id="8329b838710df96576166a6b1eb910a04281650a" translate="yes" xml:space="preserve">
          <source>Precautions</source>
          <target state="translated">Precautions</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">在 &lt;code&gt;scoped&lt;/code&gt; 样式中，类选择器优先于元素选择器，因为大量的元素选择器比较慢。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">很酷吧?</target>
        </trans-unit>
        <trans-unit id="1f991a95af1936160af34e1fab9584d14813afc2" translate="yes" xml:space="preserve">
          <source>Prevent Mutating Reactive Objects with &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">以前，将 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; 与 &lt;code&gt;v-for&lt;/code&gt; 结合使用会生成元素/组件数组，因为无法为每个项目赋予唯一的名称。您仍然可以通过为每个项目提供相同的 &lt;code&gt;ref&lt;/code&gt; 来实现此行为：</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">此前， &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; 将具有 &lt;code&gt;number&lt;/code&gt; 从0开始，并在结束9.现在开始于1，并在10结束。</target>
        </trans-unit>
        <trans-unit id="23b9c4376379f9e662432b9880582c302a480f64" translate="yes" xml:space="preserve">
          <source>Previously, async components were created by simply defining a component as a function that returned a promise, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">主要用于保存组件状态或避免重新渲染。</target>
        </trans-unit>
        <trans-unit id="dcdf83698ed6217a7ad9789255b8e995292e5ef5" translate="yes" xml:space="preserve">
          <source>Prime heading: title of the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">优先A规则。(防错)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">优先事项A:基本要素</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">优先B规则。强烈建议(提高可读性)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">优先事项B:强烈建议</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">C优先规则。建议(尽量减少任意选择和认知开销)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">优先事项C:建议</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">D优先规则。谨慎使用(潜在危险模式)</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">优先级D。谨慎使用</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">私人财产名称</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">私有财产名称&lt;sup&gt;必不可少&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">问题解决了!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">生产部署</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">程序化事件监听器</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">程序化导航</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">程式化地选择其他几个组件中的一个来委托给</target>
        </trans-unit>
        <trans-unit id="f6f4da8d93e88a08220e03b7810451d3ba540a34" translate="yes" xml:space="preserve">
          <source>Project</source>
          <target state="translated">Project</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">项目创建</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">道具箱(骆驼箱与烤肉箱)。</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">道具突变&lt;sup&gt;已弃用&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
