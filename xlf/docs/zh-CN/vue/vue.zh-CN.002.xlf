<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="686299f7711a328af7f7ede481ecd878f135b9f6" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;code&gt;v-if&lt;/code&gt; has higher toggle costs while &lt;code&gt;v-show&lt;/code&gt; has higher initial render costs. So prefer &lt;code&gt;v-show&lt;/code&gt; if you need to toggle something very often, and prefer &lt;code&gt;v-if&lt;/code&gt; if the condition is unlikely to change at runtime.</source>
          <target state="translated">一般来说， &lt;code&gt;v-if&lt;/code&gt; 的切换成本较高，而 &lt;code&gt;v-show&lt;/code&gt; 的初始渲染成本较高。所以喜欢 &lt;code&gt;v-show&lt;/code&gt; ，如果你需要切换的东西，很多时候，和喜欢 &lt;code&gt;v-if&lt;/code&gt; 如果条件不太可能在运行时改变。</target>
        </trans-unit>
        <trans-unit id="54c5f98c2534a5664e54bdf67174809b2a27c8a3" translate="yes" xml:space="preserve">
          <source>Get Support</source>
          <target state="translated">获得支持</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="4687f4eea959b8d3a7678579930ba86b60298a4b" translate="yes" xml:space="preserve">
          <source>Global API</source>
          <target state="translated">全球API</target>
        </trans-unit>
        <trans-unit id="d99de9060d9d291cf15a1d729547287918e216dc" translate="yes" xml:space="preserve">
          <source>Global Config</source>
          <target state="translated">全局配置</target>
        </trans-unit>
        <trans-unit id="a87e1f8386cdfab8951563f9287ce245995f5751" translate="yes" xml:space="preserve">
          <source>Global Mixin</source>
          <target state="translated">全球搅拌器</target>
        </trans-unit>
        <trans-unit id="12acfdfcb7281091faacdbe76162537707d677a4" translate="yes" xml:space="preserve">
          <source>Global Registration</source>
          <target state="translated">全球注册</target>
        </trans-unit>
        <trans-unit id="d23476cf27dc98d9e3173cbdb68ad4566d7bbe61" translate="yes" xml:space="preserve">
          <source>Global registration often isn&amp;rsquo;t ideal. For example, if you&amp;rsquo;re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">全球注册通常不理想。例如，如果您使用的是Webpack之类的构建系统，则全局注册所有组件意味着即使您停止使用某个组件，它也仍然可以包含在最终构建中。这不必要地增加了用户必须下载的JavaScript数量。</target>
        </trans-unit>
        <trans-unit id="e2b51a4acf3ac2ad46709058f4a65e88a724bd55" translate="yes" xml:space="preserve">
          <source>Global state management</source>
          <target state="translated">全球国家管理</target>
        </trans-unit>
        <trans-unit id="d2cdbb9287a2eee1e29278ad1a52afa18af50490" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created afterwards &amp;ndash; and even inside all subcomponents of that Vue instance&amp;rsquo;s component tree.</source>
          <target state="translated">全局注册的组件可以在之后创建的任何根Vue实例（ &lt;code&gt;new Vue&lt;/code&gt; ）的模板中使用，甚至可以在该Vue实例的组件树的所有子组件内使用。</target>
        </trans-unit>
        <trans-unit id="9d53a8dc9787d0f1938039b6b2df16c89e2967b1" translate="yes" xml:space="preserve">
          <source>Go ahead and enter &lt;code&gt;app3.seen = false&lt;/code&gt; in the console. You should see the message disappear.</source>
          <target state="translated">继续，在控制台中输入 &lt;code&gt;app3.seen = false&lt;/code&gt; 。您应该看到该消息消失。</target>
        </trans-unit>
        <trans-unit id="61dedcf053ff33692baacbf7789c5d7195d9acbe" translate="yes" xml:space="preserve">
          <source>Good</source>
          <target state="translated">Good</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="613dffa8c694c4b79227626375484864e1cbb5bc" translate="yes" xml:space="preserve">
          <source>HTML &amp;amp; CSS</source>
          <target state="translated">HTML和CSS</target>
        </trans-unit>
        <trans-unit id="ecb5ae374f41987062d1edb5a439c141fbcfee47" translate="yes" xml:space="preserve">
          <source>HTML Interpolation &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">HTML插值&lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="61152bedc285b45e3443132c85b9e9eab87b1c71" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">HTML属性名称不区分大小写，因此浏览器会将所有大写字符解释为小写。这意味着当您使用in-DOM模板时，骆驼式道具名称需要使用kebab大小写（用连字符分隔）：</target>
        </trans-unit>
        <trans-unit id="206317f92c61c3721e7b0ef393e74b50f2adc608" translate="yes" xml:space="preserve">
          <source>HTML elements,</source>
          <target state="translated">HTML元素。</target>
        </trans-unit>
        <trans-unit id="b7d20a95e49462d14a4c08f7dda3686750b36c96" translate="yes" xml:space="preserve">
          <source>HTML interpolation has been &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;removed in favor of &lt;code&gt;v-html&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTML插值已被&lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;删除，转而支持 &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b1c56685d95ab775546bda4c6e1ef23eea39b81" translate="yes" xml:space="preserve">
          <source>HTML interpolations (&lt;code&gt;{{{ foo }}}&lt;/code&gt;) have been removed in favor of the &lt;a href=&quot;../api/index#v-html&quot;&gt;&lt;code&gt;v-html&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">HTML插值（ &lt;code&gt;{{{ foo }}}&lt;/code&gt; ）已被删除，以支持&lt;a href=&quot;../api/index#v-html&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; 指令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec5f7d68ba95b6c2f0128818861a5fb3a7ce41b3" translate="yes" xml:space="preserve">
          <source>HTML&amp;rsquo;s built-in input types won&amp;rsquo;t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">HTML的内置输入类型不能总是满足您的需求。幸运的是，Vue组件允许您以完全自定义的行为构建可重用的输入。这些输入甚至可以与 &lt;code&gt;v-model&lt;/code&gt; ！要了解更多信息，请阅读《组件指南》中有关&lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;自定义输入&lt;/a&gt;的信息。</target>
        </trans-unit>
        <trans-unit id="69b83e92529f5151314d046d862c4a9c77d93516" translate="yes" xml:space="preserve">
          <source>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue&amp;rsquo;s reactivity features.</source>
          <target state="translated">基于HTML的模板使逐步迁移现有应用程序变得更加容易，以利用Vue的反应性功能。</target>
        </trans-unit>
        <trans-unit id="5e6fab8d8bdb45dbc0c724b264884e741a1423d5" translate="yes" xml:space="preserve">
          <source>Handling Edge Cases</source>
          <target state="translated">处理边缘案例</target>
        </trans-unit>
        <trans-unit id="0c27db799f42037e36231e8871e3549a290cef26" translate="yes" xml:space="preserve">
          <source>Handling Loading State</source>
          <target state="translated">处理加载状态</target>
        </trans-unit>
        <trans-unit id="f70e7e4e8994ebaac734eaf505f7cb87f5015b0f" translate="yes" xml:space="preserve">
          <source>Handling User Input</source>
          <target state="translated">处理用户输入</target>
        </trans-unit>
        <trans-unit id="553c9fd444b729d939071ffd415fb951213f90a4" translate="yes" xml:space="preserve">
          <source>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</source>
          <target state="translated">Hashbangs不再是Google抓取URL的必要条件,所以它们不再是Hash策略的默认(甚至是一个选项)。</target>
        </trans-unit>
        <trans-unit id="a8d68b23680238f325efc34072a89db096cd1404" translate="yes" xml:space="preserve">
          <source>Having this validator extracted out, we&amp;rsquo;ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it&amp;rsquo;s actually impossible for users to enter anything wrong, similar to what the browser&amp;rsquo;s native number input tries to do.</source>
          <target state="translated">提取出该验证器后，我们还可以更轻松地将其构建为更强大的解决方案。状态怪癖已被消除，用户实际上不可能输入任何错误，类似于浏览器的本机数字输入尝试执行的操作。</target>
        </trans-unit>
        <trans-unit id="5d3e638fd34dc7467faa0ba823b8497588b5815b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;attributeName&lt;/code&gt; 将作为JavaScript表达式动态求值，并且其求值将用作参数的最终值。例如，如果您的Vue实例具有数据属性 &lt;code&gt;attributeName&lt;/code&gt; ，其值为 &lt;code&gt;&quot;href&quot;&lt;/code&gt; ，则此绑定将等效于 &lt;code&gt;v-bind:href&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89a97b67c98ddcf2e842f6272379190e542a3a62" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;filterA&lt;/code&gt; is defined as a function taking three arguments. The value of &lt;code&gt;message&lt;/code&gt; will be passed into the first argument. The plain string &lt;code&gt;'arg1'&lt;/code&gt; will be passed into the &lt;code&gt;filterA&lt;/code&gt; as its second argument, and the value of expression &lt;code&gt;arg2&lt;/code&gt; will be evaluated and passed in as the third argument.</source>
          <target state="translated">这里 &lt;code&gt;filterA&lt;/code&gt; 被定义为一个带有三个参数的函数。 &lt;code&gt;message&lt;/code&gt; 的值将传递到第一个参数。纯字符串 &lt;code&gt;'arg1'&lt;/code&gt; 将作为其第二个参数传递到 &lt;code&gt;filterA&lt;/code&gt; 中，表达式 &lt;code&gt;arg2&lt;/code&gt; 的值将被求值并作为第三个参数传递。</target>
        </trans-unit>
        <trans-unit id="b533c1b3a997459bdeab6c6103d2b8341430c012" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">这里的 &lt;code&gt;href&lt;/code&gt; 是参数，它告诉 &lt;code&gt;v-bind&lt;/code&gt; 指令将元素的 &lt;code&gt;href&lt;/code&gt; 属性绑定到表达式 &lt;code&gt;url&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e8a2ad49522f0c5140bd579d6e3f6cc63de82a9e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; can be omitted as it is implied:</source>
          <target state="translated">此处可以省略 &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; 因为它暗含了：</target>
        </trans-unit>
        <trans-unit id="a5a992eb5c40fb541d26012305484c0906879154" translate="yes" xml:space="preserve">
          <source>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</source>
          <target state="translated">这里的参数是要监听的事件名称。我们也会更详细地讨论事件处理。</target>
        </trans-unit>
        <trans-unit id="f407b88178ffc4e03f9f78c8af7c050fb1a05bb8" translate="yes" xml:space="preserve">
          <source>Here we are encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you are seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &amp;ldquo;keep this element&amp;rsquo;s &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the Vue instance.&amp;rdquo;</source>
          <target state="translated">在这里，我们遇到了新的事物。您看到的 &lt;code&gt;v-bind&lt;/code&gt; 属性称为&lt;strong&gt;指令&lt;/strong&gt;。指令以 &lt;code&gt;v-&lt;/code&gt; 前缀表示它们是Vue提供的特殊属性，并且您可能已经猜到了，它们将特殊的反应性行为应用于呈现的DOM。在这里，基本上是说&amp;ldquo;保持该元素的 &lt;code&gt;title&lt;/code&gt; 属性与Vue实例上的 &lt;code&gt;message&lt;/code&gt; 属性保持最新。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="20439924cb310f6e6ebea9dce4e509745f1d1bb0" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;reversedMessage&lt;/code&gt;. The function we provided will be used as the getter function for the property &lt;code&gt;vm.reversedMessage&lt;/code&gt;:</source>
          <target state="translated">在这里，我们声明了一个计算属性 &lt;code&gt;reversedMessage&lt;/code&gt; 。我们提供的函数将用作属性 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的getter函数：</target>
        </trans-unit>
        <trans-unit id="41a58605aec4adfd7f18a1d980084fe022c01384" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete example of a simple todo list:</source>
          <target state="translated">这是一个简单的待办事项清单的完整示例：</target>
        </trans-unit>
        <trans-unit id="e6deaab1ac1757bb576b7c7fb31ce01f23836233" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a &lt;code&gt;smart-list&lt;/code&gt; component that delegates to more specific components, depending on the props passed to it:</source>
          <target state="translated">这是一个 &lt;code&gt;smart-list&lt;/code&gt; 组件的示例，该组件根据传递给它的道具委托给更特定的组件：</target>
        </trans-unit>
        <trans-unit id="8edc36b060f6cabd0970dde81f8964d59b6e1225" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a Vue component:</source>
          <target state="translated">这是Vue组件的示例：</target>
        </trans-unit>
        <trans-unit id="b31be59658661ba4e66f41944f3554b7a0be5398" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a file we&amp;rsquo;ll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">这是我们称为 &lt;code&gt;Hello.vue&lt;/code&gt; 的文件的示例：</target>
        </trans-unit>
        <trans-unit id="b33ffef562696923d8035d66d6b00e446f9c5cd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example using a template component:</source>
          <target state="translated">这是使用模板组件的示例：</target>
        </trans-unit>
        <trans-unit id="99ff339aed17c551cb54d5842ca9646f53c8ed64" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with all of these modifiers used together:</source>
          <target state="translated">这是所有这些修饰符一起使用的示例：</target>
        </trans-unit>
        <trans-unit id="18a91a386128ffc554ca249fb0825499466cf9d3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">这是一个示例，为了简洁起见，省略了前缀CSS规则：</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">这是一个例子：</target>
        </trans-unit>
        <trans-unit id="f7ffc75a586e32509010b20213e0f4e623c0e848" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s that in action:</source>
          <target state="translated">实际情况如下：</target>
        </trans-unit>
        <trans-unit id="9a829483e3b314613758a5a663c73e6905d5701b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;slot-scope&lt;/code&gt; declares the received props object as the &lt;code&gt;slotProps&lt;/code&gt; variable, and makes it available inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; scope. You can name &lt;code&gt;slotProps&lt;/code&gt; anything you like similar to naming function arguments in JavaScript.</source>
          <target state="translated">在这里， &lt;code&gt;slot-scope&lt;/code&gt; 将接收到的props对象声明为 &lt;code&gt;slotProps&lt;/code&gt; 变量，并使其在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 范围内可用。您可以将 &lt;code&gt;slotProps&lt;/code&gt; 命名为任何喜欢的名称，类似于在JavaScript中命名函数参数。</target>
        </trans-unit>
        <trans-unit id="f68e5bf516c14d7636dc7e787f07b009104eba6f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;v-if&lt;/code&gt; directive would remove/insert the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element based on the truthiness of the value of the expression &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;v-if&lt;/code&gt; 指令将根据 &lt;code&gt;seen&lt;/code&gt; 表达式的值的真实性删除/插入 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8e26e3e40dfd6774d32a14ec704c7c19bb0bf799" translate="yes" xml:space="preserve">
          <source>Hook Functions</source>
          <target state="translated">钩子功能</target>
        </trans-unit>
        <trans-unit id="d2bdd950b4b524b4faf0540c42b846e440d3ebd2" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component&amp;rsquo;s own hooks.</source>
          <target state="translated">具有相同名称的挂钩函数将合并到一个数组中，以便将全部调用它们。Mixin挂钩将在组件自己的挂钩&lt;strong&gt;之前&lt;/strong&gt;被调用。</target>
        </trans-unit>
        <trans-unit id="656dedbf5301c31ed9bdf32f2a451638643101f3" translate="yes" xml:space="preserve">
          <source>How Changes Are Tracked</source>
          <target state="translated">如何跟踪变化</target>
        </trans-unit>
        <trans-unit id="a056aea1f6dc2d57c44eacd2de4c8078611a80e1" translate="yes" xml:space="preserve">
          <source>How long will it take to migrate a Vue 1.x app to 2.0?</source>
          <target state="translated">将Vue 1.x应用迁移到2.0需要多长时间?</target>
        </trans-unit>
        <trans-unit id="a173386c8ab0ffd650a7e5d8b6fb73ce6260ce4e" translate="yes" xml:space="preserve">
          <source>How many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!</source>
          <target state="translated">多少次你分心了,开始玩一个很酷的新功能,&quot;■▄▄■▓,不是评判,我们在建设2.0的时候也发生过这样的事情!</target>
        </trans-unit>
        <trans-unit id="5b51fcd95b1bb4c1d0a2feadea82b32351c13de4" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;inline-template&lt;/code&gt; makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the &lt;code&gt;template&lt;/code&gt; option or in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element in a &lt;code&gt;.vue&lt;/code&gt; file.</source>
          <target state="translated">但是， &lt;code&gt;inline-template&lt;/code&gt; 使您难以推断模板的范围。最佳做法是，最好使用 &lt;code&gt;template&lt;/code&gt; 选项或 &lt;code&gt;.vue&lt;/code&gt; 文件中的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素在组件内部定义模板。</target>
        </trans-unit>
        <trans-unit id="42d602a14282520e03f05621c18e657389b28401" translate="yes" xml:space="preserve">
          <source>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;, &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;, and &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;.</source>
          <target state="translated">但是，即使这样也勉强划伤了适用范围的插槽的功能。有关作用域插槽用法的真实示例，建议浏览诸如&lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;，&lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;和&lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue之类的库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e377ccc91063a19e1128087c043b05ac14bc27fd" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;Vue.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">但是，对于&lt;strong&gt;仅&lt;/strong&gt;通过 &lt;code&gt;Vue.component&lt;/code&gt; 使用全局组件定义的应用程序，我们建议改用kebab -case。原因如下：</target>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">但是，如果您需要使用&lt;strong&gt;模块系统&lt;/strong&gt;（例如，通过Webpack或Browserify）来导入/导入组件，则会收到错误消息：</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，如果您排除了上述情况，却发现自己不得不手动强制执行更新，则可以使用&lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">但是，在某些情况下，您可能希望两者都位于同一元素上，例如，具有由Vue触发的CSS动画以及对悬停的CSS过渡效果。在这些情况下，您将必须在 &lt;code&gt;type&lt;/code&gt; 属性中明确声明要Vue关注的类型，其值可以是 &lt;code&gt;animation&lt;/code&gt; 或 &lt;code&gt;transition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">然而,就像其他指令一样,只有在提供了参数的情况下,该速记才可用。这意味着下面的语法是无效的。</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">但是，并非每个人都希望使用TypeScript。在许多较小规模的用例中，引入类型系统可能会导致比生产率提高更多的开销。在这些情况下，最好改用Vue，因为在没有TypeScript的情况下使用Angular可能会遇到挑战。</target>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">但是，依赖项注入存在缺点。它将应用程序中的组件与当前的组织方式耦合在一起，从而使重构更加困难。提供的属性也不具有反应性。这是设计使然，因为使用它们创建中央数据存储的伸缩性与&lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;使用 &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt;达到相同目的的伸缩性一样差。如果您要共享的属性是特定于您的应用程序的，而不是通用的，或者您曾经想更新祖先内部提供的数据，则表明您可能需要像&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;这样的真实状态管理解决方案。</target>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">但是，如果您有多个条件类，这可能会有点冗长。这就是为什么还可以在数组语法中使用对象语法的原因：</target>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">但是，这不会自动将任何数据传递给组件，因为组件具有各自独立的作用域。为了将迭代的数据传递到组件中，我们还应该使用道具：</target>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">但是，在远方的后代/祖先之间进行通信时， &lt;code&gt;$emit&lt;/code&gt; 不会帮助您。相反，最简单的升级方法是使用集中式事件中心。这具有额外的好处，无论您在组件树中的哪个位置，都可以在它们之间进行通信，甚至在兄弟姐妹之间也可以通信！由于Vue实例实现了事件发射器接口，因此您实际上可以为此使用一个空的Vue实例。</target>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">但是，如果您希望明确，仍可以将默认的插槽内容包装在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">我希望现在，您正在使用自己喜欢的语言阅读这句话。如果没有，您想帮助我们到达那里吗？</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">我很高兴你问！答案是不。大约90％的API是相同的，核心概念没有改变。长期以来，我们喜欢提供非常详细的说明并包括许多示例。请放心，&lt;strong&gt;这不是您必须自上而下阅读的内容！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 的模板&lt;strong&gt;不&lt;/strong&gt;包含 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素，则其开始标记和结束标记之间提供的任何内容都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">如果未提供 &lt;code&gt;elementOrSelector&lt;/code&gt; 参数，则该模板将呈现为文档外元素，并且您将必须使用本机DOM API自己将其插入文档中。</target>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">如果 &lt;code&gt;isButtonDisabled&lt;/code&gt; 的值为 &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;disabled&lt;/code&gt; 属性甚至不会包含在呈现的 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">如果我升级到Vue 2,是否也要升级Vuex和Vue Router?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">如果Vue没有此规则，则单击一个按钮将影响&lt;em&gt;所有其他实例&lt;/em&gt;的数据，如下所示：</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">如果Vue实例在实例化时未收到 &lt;code&gt;el&lt;/code&gt; 选项，则它将处于&amp;ldquo;已卸载&amp;rdquo;状态，而没有关联的DOM元素。 &lt;code&gt;vm.$mount()&lt;/code&gt; 可用于手动启动未安装的Vue实例的安装。</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">如果一个组件只有在单个父组件的上下文中才有意义,那么这种关系应该在它的名称中得到体现。由于编辑器通常按字母顺序组织文件,这也使这些相关的文件彼此相邻。</target>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">如果在渲染组件时发生运行时错误，则将其传递给全局 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 配置函数（如果已设置）。最好将此钩子与错误跟踪服务（例如&lt;a href=&quot;https://sentry.io&quot;&gt;Sentry）&lt;/a&gt;一起使用，该服务为Vue 提供&lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;了官方集成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">如果同时给出了事件和回调,则只删除该特定回调的监听器。</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">如果相反，您的目的是有条件地跳过循环执行，则可以将 &lt;code&gt;v-if&lt;/code&gt; 放置在包装器元素（或&lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt;）上。例如：</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">如果需要从具有不同名称的属性中注入，请使用 &lt;code&gt;from&lt;/code&gt; 表示源属性：</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">如果组件的继承链或父链上存在多个 &lt;code&gt;errorCaptured&lt;/code&gt; 挂钩，则将在相同的错误上调用所有它们。</target>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">如果既没有 &lt;code&gt;render&lt;/code&gt; 功能也没有 &lt;code&gt;template&lt;/code&gt; 选项，则将安装DOM元素的in-DOM HTML提取为模板。在这种情况下，应使用Vue的Runtime + Compiler构建。</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">如果未检测到CSS过渡/动画并且未提供JavaScript钩子，则用于插入和/或移除的DOM操作将在下一帧立即执行（注意：这是浏览器动画帧，与Vue的 &lt;code&gt;nextTick&lt;/code&gt; 概念不同）。</target>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">如果没有提供参数,则删除所有事件监听器。</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">如果只提供事件,则删除该事件的所有监听器。</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">如果Vue选项中存在渲染功能,则模板将被忽略。</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">如果需要，可以通过将 &lt;code&gt;vm.$data&lt;/code&gt; 通过 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; 传递来获得原始对象的深层克隆。</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">如果是这样，请随时为&lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;这些文档&lt;/a&gt;或任何其他官方维护的文档创建存储库，然后开始翻译。一旦取得了一些进展，请在主存储库中打开问题或请求请求，我们将召集更多的贡献者来帮助您。</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;errorCaptured&lt;/code&gt; 挂钩本身抛出错误，则此错误和原始捕获的错误都将发送到全局 &lt;code&gt;config.errorHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">如果组件是功能组件，则渲染功能还将接收一个额外的参数 &lt;code&gt;context&lt;/code&gt; ，因为功能组件是无实例的，因此可以访问上下文数据。</target>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">如果 &lt;code&gt;v-model&lt;/code&gt; 表达式的初始值与任何选项都不匹配，则 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 元素将呈&amp;ldquo;未选中&amp;rdquo;状态。在iOS上，这将导致用户无法选择第一项，因为在这种情况下，iOS不会触发更改事件。因此，如上例所示，建议提供一个具有空值的禁用选项。</target>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">如果字符串以 &lt;code&gt;#&lt;/code&gt; 开头，它将用作querySelector并将所选元素的innerHTML用作模板字符串。这允许使用常见的 &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; 技巧来包含模板。</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">如果过渡组件提供了&lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;，则会在适当的时间调用这些钩子。</target>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">如果您喜欢使用第三方路由器，例如&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt;或&lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;，则集成&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;同样容易&lt;/a&gt;。这是使用Page.js 的&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;完整示例。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">如果此选项在实例化时可用，则实例将立即进入编译；否则，实例将立即进入编译。否则，用户将必须显式调用 &lt;code&gt;vm.$mount()&lt;/code&gt; 来手动启动编译。</target>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">如果还希望在节点的初始渲染上应用过渡，则可以添加 &lt;code&gt;appear&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">如果您是CSS-in-JS的粉丝，那么许多流行的CSS-in-JS库都支持Vue（例如，&lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt;和&lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;）。React和Vue之间的主要区别在于，Vue中的默认样式设置方法是通过&lt;a href=&quot;single-file-components&quot;&gt;单个文件组件中&lt;/a&gt;更熟悉的 &lt;code&gt;style&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">如果您是经验丰富的前端开发人员，并且想知道Vue与其他库/框架的&lt;a href=&quot;guide/comparison&quot;&gt;比较情况&lt;/a&gt;，请查看与其他框架的比较。</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">如果您正在开发一个大型项目,与其他开发人员合作,或者有时包含第三方HTML/CSS(例如来自Auth0),一致的范围将确保您的样式只适用于它们所要的组件。</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">如果您熟悉Virtual DOM概念并且更喜欢JavaScript的原始功能，则还可以&lt;a href=&quot;render-function&quot;&gt;直接&lt;/a&gt;使用可选的JSX支持来编写渲染函数而不是模板。</target>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">如果您使用的是Webpack，并且希望将JavaScript文件和模板文件分开，则可以使用&lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;，它还会在构建步骤中将模板文件转换为JavaScript渲染函数。</target>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">如果您使用的是原生ES模块,也有一个ES模块兼容的构建。</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">如果使用基于模板的功能组件，则还必须手动添加属性和侦听器。由于我们可以访问各个上下文内容，因此可以使用 &lt;code&gt;data.attrs&lt;/code&gt; 传递任何HTML属性，并使用 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;（ &lt;code&gt;data.on&lt;/code&gt; 的别名）&lt;/em&gt;传递任何事件侦听器。</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是完整版本，即通过脚本标签直接包含Vue而没有构建工具，请确保使用 &lt;code&gt;vue.min.js&lt;/code&gt; 版本（vue.min.js）进行生产。可以在《&lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;安装指南》中&lt;/a&gt;找到这两个版本。</target>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">如果您&lt;strong&gt;不&lt;/strong&gt;希望组件的根元素继承属性，则可以在组件的选项中设置 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">如果您未在data选项中声明 &lt;code&gt;message&lt;/code&gt; ，Vue将警告您渲染函数正在尝试访问不存在的属性。</target>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">如果您发现类型推断或成员完成不起作用，则注释某些方法可能有助于解决这些问题。使用 &lt;code&gt;--noImplicitAny&lt;/code&gt; 选项将帮助找到许多这些未注释的方法。</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">如果发现自己需要在Vue中强制进行更新，那么在99.99％的情况下，您在某个地方犯了一个错误。</target>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">如果您碰巧在应用程序的性能至关重要的部分中使用了局部&lt;a href=&quot;render-function#Functional-Components&quot;&gt;函数&lt;/a&gt;，则应升级到功能组件。它们必须在普通的JS / JSX文件中（而不是在 &lt;code&gt;.vue&lt;/code&gt; 文件中），并且是无状态和无实例的，就像局部文件一样。这使得渲染非常快。</target>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">如果您对如何更好地参与当地的Vue社区有任何疑问，请访问&lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">如果您有任何测试，请运行它们，看看仍然失败。如果您没有测试，只需在浏览器中打开应用程序，并在浏览时注意警告或错误。</target>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">如果你需要多个别名,你也可以使用数组语法。</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">如果您需要在实例化路由器后添加新路由，则可以用包含您要添加的路由的新路由替换匹配器：</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">如果您需要在客户端上编译模板（例如，将字符串传递给 &lt;code&gt;template&lt;/code&gt; 选项，或使用其in-DOM HTML作为模板安装到元素），则需要编译器，并因此需要完整的构建：</target>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">如果您需要在启动应用程序时以编程方式生成路由,您可以通过动态推送定义到路由数组来实现。例如</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">如果需要错开列表过渡，则可以通过设置和访问元素上的 &lt;code&gt;data-index&lt;/code&gt; （或类似属性）来控制时序。&lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;在这里&lt;/a&gt;查看示例。</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">如果你只需要非常简单的路由,而不希望涉及到一个功能齐全的路由器库,你可以通过动态渲染一个像这样的页面级组件来实现。</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">如果再次打开JavaScript控制台并输入 &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; ，您将再次看到绑定的HTML（在本例中为 &lt;code&gt;title&lt;/code&gt; 属性）已更新。</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">如果在声明组件时更喜欢基于类的API，则可以使用正式维护的&lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt;装饰器：</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">如果您喜欢更具交互性的内容，还可以查看&lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;Scrimba上的本系列教程&lt;/a&gt;，其中提供了截屏视频和代码游乐场的组合，您可以随时暂停播放。</target>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">如果确实需要重写另一个 &lt;code&gt;!important&lt;/code&gt; ，则必须使用字符串语法：</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">如果你真的想多次重复同一个元素/组件,你可以用工厂函数来实现。例如,下面的渲染函数是渲染20个相同段落的一个完全有效的方法。</target>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">如果你还想在回调里面调用一个unwatch函数,你应该先检查它的可用性。</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">但是，如果您在模板中尝试此操作，则Vue将显示错误，并解释&lt;strong&gt;每个组件必须具有单个root元素&lt;/strong&gt;。您可以通过将模板包装在父元素中来解决此错误，例如：</target>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">如果你在你的模板中使用了任何非Vue的自定义元素,比如一个网页组件,PascalCase可以确保你的Vue组件保持明显的可见性。</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">如果你想胁迫一个道具,可以根据它设置一个本地计算值来代替。例如,代替。</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">如果您想直接进入并开始使用单文件组件，请在CodeSandbox上查看&lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;这个简单的待办事项应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">如果你想传递一个对象作为道具的所有属性，可以使用 &lt;code&gt;v-bind&lt;/code&gt; 不带参数（ &lt;code&gt;v-bind&lt;/code&gt; ，而不是 &lt;code&gt;v-bind:prop-name&lt;/code&gt; ）。例如，给定一个 &lt;code&gt;post&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">如果要改为在本地注册指令，则组件也可以接受 &lt;code&gt;directives&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">如果希望用户输入自动以数字形式转换，则可以将 &lt;code&gt;number&lt;/code&gt; 修饰符添加到 &lt;code&gt;v-model&lt;/code&gt; 托管输入中：</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">如果要自动修剪用户输入中的空格，可以将 &lt;code&gt;trim&lt;/code&gt; 修饰符添加到 &lt;code&gt;v-model&lt;/code&gt; 管理的输入中：</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">如果以前在组件更新后依靠 &lt;code&gt;vm.$watch&lt;/code&gt; 对DOM进行操作，则可以在 &lt;code&gt;updated&lt;/code&gt; 生命周期挂钩中执行。</target>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">如果你想在列表中有条件地切换一个类,你可以用三元表达式来实现。</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">如果您想在潜水之前了解有关Vue的更多信息，我们创建了一段视频，介绍了核心原则和示例项目。</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">如果您是想要使用异步组件的&lt;strong&gt;Browserify&lt;/strong&gt;用户，那么不幸的&lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;是&lt;/a&gt;，其创建者已经明确表明异步加载&amp;ldquo;不是Browserify永远不会支持的东西&amp;rdquo;。至少在官方上。 Browserify社区发现了&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;一些变通办法&lt;/a&gt;，这可能对现有和复杂的应用程序有所帮​​助。对于所有其他情况，我们建议使用Webpack以获得内置的一流的异步支持。</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">如果您来自React，那么您可能想知道vuex与该生态系统中最流行的Flux实现&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;相比如何。Redux实际上是与视图层无关的，因此可以通过&lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;简单的绑定&lt;/a&gt;轻松地与Vue一起使用。Vuex的不同之处在于它&lt;em&gt;知道&lt;/em&gt;它在Vue应用程序中。这使它可以更好地与Vue集成，从而提供更直观的API和改进的开发体验。</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">如果您不小心，则递归组件也可能导致无限循环：</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">如果您不使用带有 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; 的模块系统，则可能现在可以跳过本节。如果您是，我们将为您提供一些特殊的说明和提示。</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">如果您还不熟悉Vue的组件，则可以暂时跳过此步骤。</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">如果您仍然在这里，则可能是您正在使用模块系统，例如Babel和Webpack。在这些情况下，我们建议创建一个 &lt;code&gt;components&lt;/code&gt; 目录，每个组件都在其自己的文件中。</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">如果您要编写很多 &lt;code&gt;render&lt;/code&gt; 函数，那么编写如下代码可能会很痛苦：</target>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">如果你的指令需要多个值,你也可以传入一个JavaScript对象文字。记住,指令可以采用任何有效的JavaScript表达式。</target>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">想象一下，这是 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 的模板：</target>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">亲子间的隐性沟通</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;谨慎使用&lt;/sup&gt;隐式的亲子沟通&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">在2.2.0+及更高版本中， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 树中的所有嵌套组件都将 &lt;code&gt;activated&lt;/code&gt; 和 &lt;code&gt;deactivated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">在2.2.0+中，此挂钩还捕获组件生命周期挂钩中的错误。另外，当此钩子 &lt;code&gt;undefined&lt;/code&gt; ，捕获的错误将通过 &lt;code&gt;console.error&lt;/code&gt; 记录下来，而不是使应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">在2.2.0+中，当 &lt;code&gt;v-for&lt;/code&gt; 组件使用v-for时，现在需要一个&lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">在2.4.0+中,这个钩子还可以捕获Vue自定义事件处理程序中抛出的错误。</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">在2.5.0+中,注入可以是可选的,默认值。</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">在2.5.0+中，如果使用&lt;a href=&quot;single-file-components&quot;&gt;单文件组件&lt;/a&gt;，则可以使用以下方法声明基于模板的功能组件：</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">在2.6+中， &lt;code&gt;v-for&lt;/code&gt; 也可以处理实现&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol的&lt;/a&gt;值，包括本地 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 。但是，应注意，Vue 2.x当前不支持对 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 值的反应性，因此无法自动检测更改。</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">在2.6.0+中，此挂钩还捕获了 &lt;code&gt;v-on&lt;/code&gt; DOM侦听器内部引发的错误。此外，如果任何涵盖的钩子或处理程序返回了Promise链（例如，异步函数），则该Promise链中的错误也将得到处理。</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">在2.6.0中，我们为命名插槽和作用域插槽引入了新的统一语法（ &lt;code&gt;v-slot&lt;/code&gt; 指令）。它取代了 &lt;code&gt;slot&lt;/code&gt; 和 &lt;code&gt;slot-scope&lt;/code&gt; 属性，这些属性现在已经过时，但都&lt;em&gt;没有&lt;/em&gt;被删除，仍然记录&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;在这里&lt;/a&gt;。在此&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC中&lt;/a&gt;介绍了引入新语法的原理。</target>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">在&lt;a href=&quot;../guide/single-file-components&quot;&gt;单文件组件中&lt;/a&gt;， &lt;code&gt;scoped&lt;/code&gt; 样式将不适用于 &lt;code&gt;v-html&lt;/code&gt; 内的内容，因为Vue的模板编译器不会处理HTML。如果要使用范围限定的CSS 定位 &lt;code&gt;v-html&lt;/code&gt; 内容，则可以改用&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS模块&lt;/a&gt;或其他具有手动作用域策略（例如BEM）的全局 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">在JavaScript中,PascalCase是类和原型构造函数的惯例--本质上,任何可以有不同实例的东西。Vue组件也有实例,所以使用PascalCase也是有意义的。另外一个好处是,在JSX(和模板)中使用PascalCase可以让代码的读者更容易区分组件和HTML元素。</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">在JavaScript中，将具有多个属性的对象拆分为多行被广泛认为是一个好习惯，因为它更容易阅读。我们的模板和&lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt;应该得到同样的考虑。</target>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">在Polymer中,为了弥补性能的不足,团队还将其数据绑定系统做了非常大的限制。例如,Polymer模板中支持的表达式只有布尔否定和单方法调用。其计算属性的实现也不是很灵活。</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">在React中,所有组件都在渲染函数中使用JSX表达其UI,JSX是一种类似XML的声明式语法,在JavaScript中工作。</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">在React中,一切都只是JavaScript。不仅HTML结构通过JSX来表达,最近的趋势也倾向于把CSS管理也放在JavaScript里面。这种方法有其自身的好处,但也有各种权衡,似乎并不是每个开发者都值得。</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">在React中，当组件的状态改变时，它会触发整个组件子树的重新渲染，从该组件的根目录开始。为了避免不必要地重新渲染子组件，您需要尽可能使用 &lt;code&gt;PureComponent&lt;/code&gt; 或实现 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 。您可能还需要使用不可变的数据结构，以使状态更改更加优化。但是，在某些情况下，您可能无法依靠这种优化，因为 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; 假定整个子树的渲染输出由当前组件的属性决定。如果不是这种情况，那么这种优化可能会导致DOM状态不一致。</target>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">在Vue 2.x中， &lt;code&gt;Vue.observable&lt;/code&gt; 直接更改传递给它的对象，因此它等效于返回的对象，如此处&lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;所示&lt;/a&gt;。在Vue 3.x中，将改为返回反应式代理，如果直接突变，则使原始对象不反应。因此，为了将来的兼容性，建议始终使用 &lt;code&gt;Vue.observable&lt;/code&gt; 返回的对象，而不是最初传递给它的对象。</target>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">在Vue中,一个组件本质上是一个具有预定义选项的Vue实例。在Vue中注册一个组件是很直接的。</target>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">在Vue中，在渲染过程中会自动跟踪组件的依赖关系，因此系统可以准确地知道状态更改时实际需要重新渲染哪些组件。可以认为每个组件都为您自动实现了 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ，而没有嵌套的组件警告。</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">在Vue中，我们还具有&lt;a href=&quot;render-function&quot;&gt;渲染功能&lt;/a&gt;，甚至还&lt;a href=&quot;render-function#JSX&quot;&gt;支持JSX&lt;/a&gt;，因为有时您确实需要这种功能。但是，作为默认体验，我们提供模板作为更简单的选择。任何有效的HTML也是有效的Vue模板，这将带来其自身的一些优点：</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">在Webpack 4+中，可以使用 &lt;code&gt;mode&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">在大型应用程序中，有必要将整个应用程序划分为多个组件以使开发易于管理。我们将&lt;a href=&quot;guide/components&quot;&gt;在本指南的后面&lt;/a&gt;部分讨论有关组件的更多信息，但这是一个（虚构的）示例，该示例显示了应用程序模板与组件的外观：</target>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">但是，在典型的应用中， &lt;code&gt;data&lt;/code&gt; 可能会有一系列的帖子：</target>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">除了数据属性外，Vue实例还公开了许多有用的实例属性和方法。它们以 &lt;code&gt;$&lt;/code&gt; 开头，以区别于用户定义的属性。例如：</target>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">除了文本插值,我们还可以这样绑定元素属性。</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">除了 &lt;code&gt;watch&lt;/code&gt; 选项之外，您还可以使用命令&lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm。$ watch API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">除了核心附带的默认指令集（ &lt;code&gt;v-model&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; ）之外，Vue还允许您注册自己的自定义指令。请注意，在Vue 2.0中，代码重用和抽象的主要形式是组件-但是，在某些情况下，您可能需要在普通元素上进行一些低级DOM访问，而这正是自定义指令仍然有用的地方。一个示例将重点放在输入元素上，例如：</target>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">另外， &lt;code&gt;type&lt;/code&gt; 也可以是自定义构造函数，并且断言将通过 &lt;code&gt;instanceof&lt;/code&gt; 检查来进行。例如，假设存在以下构造函数：</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">此外,每个实例/组件仍然可以拥有和管理自己的私有状态。</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">此外，每次更新父组件时，子组件中的所有道具都会以最新值刷新。这意味着你应该&lt;strong&gt;不是&lt;/strong&gt;试图突变子组件内的道具。如果您这样做，Vue将在控制台中警告您。</target>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">万一您还没有注意到，Vue &lt;strong&gt;异步&lt;/strong&gt;执行DOM更新。每当观察到数据更改时，它将打开队列并缓冲在同一事件循环中发生的所有数据更改。如果多次触发同一观察者，则它将仅被推入队列一次。这种缓冲的重复数据删除对于避免不必要的计算和DOM操作非常重要。然后，在下一个事件循环&amp;ldquo;滴答&amp;rdquo;中，Vue刷新队列并执行实际的（已删除重复数据）工作。 Vue在内部尝试使用本机 &lt;code&gt;Promise.then&lt;/code&gt; ， &lt;code&gt;MutationObserver&lt;/code&gt; 和 &lt;code&gt;setImmediate&lt;/code&gt; 进行异步排队，然后回退到 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">如果您希望从头开始设置自己的构建设置，则需要使用&lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;手动配置webpack 。要了解有关webpack本身的更多信息，请查看&lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;其官方文档&lt;/a&gt;和&lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">在上述情况下，当&lt;em&gt;仅&lt;/em&gt;提供默认插槽的内容时，组件的标签可以用作插槽的模板。这使我们可以直接在组件上使用 &lt;code&gt;v-slot&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">在这样的情况下，我们可以标记组件 &lt;code&gt;functional&lt;/code&gt; ，这意味着它们是无状态（无&lt;a href=&quot;../api/index#Options-Data&quot;&gt;反应数据&lt;/a&gt;）和instanceless（没有 &lt;code&gt;this&lt;/code&gt; 方面）。一个&lt;strong&gt;功能组件&lt;/strong&gt;如下所示：</target>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">在提交的代码中,道具定义应该尽可能详细,至少要指定类型。</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">相比之下， &lt;code&gt;v-show&lt;/code&gt; 要简单得多-不论初始条件如何，都始终使用基于CSS的切换来呈现元素。</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">相比之下，每当重新渲染发生时，方法调用将&lt;strong&gt;始终&lt;/strong&gt;运行该函数。</target>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">在开发过程中,如果一个组件曾经被提供了不正确的格式化道具,Vue会向你发出警告,帮助你发现潜在的错误来源。</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">在 &lt;code&gt;new Vue&lt;/code&gt; 实例的每个子组件中，都可以使用 &lt;code&gt;$root&lt;/code&gt; 属性访问此根实例。例如，在此根实例中：</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">实际上，您可以将依赖项注入视为一种&amp;ldquo;远程支持&amp;rdquo;，除了：</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">通常，只要能用普通的JavaScript实现某些功能，我们就希望避免引入诸如过滤器之类的特殊语法来处理相同的问题。这是替换Vue内置指令过滤器的方法：</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">在大型应用程序中，我们可能需要将应用程序分成较小的块，并仅在需要时才从服务器加载组件。为了简化操作，Vue允许您将组件定义为异步解析组件定义的工厂函数。Vue仅在需要渲染组件时才触发工厂功能，并将缓存结果以供将来重新渲染。例如：</target>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">在许多Vue项目中，将使用 &lt;code&gt;Vue.component&lt;/code&gt; 定义全局组件，然后使用 &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; container '}）来定义每个页面正文中的容器元素。</target>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">但是，在许多情况下，您仍然会遇到奇怪的行为（例如 &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; 会四舍五入为 &lt;code&gt;0.04&lt;/code&gt; ，但是 &lt;code&gt;0.045&lt;/code&gt; 会四舍五入为 &lt;code&gt;0.04&lt;/code&gt; ）。若要解决这些问题，您可以使用&lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt;库来更可靠地设置货币格式。</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">在许多情况下，您可能希望在 &lt;code&gt;bind&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 上具有相同的行为，但不必关心其他挂钩。例如：</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">在大多数情况下，Vue可以自动找出过渡完成的时间。默认情况下，Vue等待根过渡元素上的第一个 &lt;code&gt;transitionend&lt;/code&gt; 或 &lt;code&gt;animationend&lt;/code&gt; 事件。但是，这可能并不总是希望的-例如，我们可能具有经过编排的过渡序列，其中某些嵌套的内部元素比根过渡元素具有延迟的过渡或更长的过渡持续时间。</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">在大多数情况下，最好避免进入其他组件实例或手动操作DOM元素。但是，在某些情况下可能适当。</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">在大多数情况下,伸入父体会使你的应用程序更难调试和理解,特别是当你在父体中突变数据时。当以后再看那个组件时,将很难弄清楚这个突变来自哪里。</target>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">在自然英语中,形容词和其他描述词通常会出现在名词之前,而例外情况则需要连接词。例如:</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">在正常使用情况下，您不必自己调用此方法。首选使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 以数据驱动的方式控制子组件的生命周期。</target>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">在我们的例子中，让我们指出 &lt;code&gt;tree-folder&lt;/code&gt; 组件。我们知道创建悖论的孩子是 &lt;code&gt;tree-folder-contents&lt;/code&gt; 组件，因此我们将等到 &lt;code&gt;beforeCreate&lt;/code&gt; 生命周期钩子将其注册：</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">根据我们的经验，最好&lt;em&gt;总是&lt;/em&gt;添加一个唯一的密钥，这样您和您的团队就不必担心这些极端情况。然后，在不需要对象恒定性的罕见的，对性能至关重要的场景中，您可以做出有意识的例外。</target>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">在计算属性不可行的情况下（例如在嵌套的 &lt;code&gt;v-for&lt;/code&gt; 循环内），可以使用以下方法：</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">在某些情况下，我们可能需要对道具进行&amp;ldquo;双向绑定&amp;rdquo;。不幸的是，真正的双向绑定会产生维护问题，因为子组件可以使父项发生变异，而在父项和子项中均不明显该变异的来源。</target>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">在这种情况下，您可以使用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 组件上的 &lt;code&gt;duration&lt;/code&gt; 属性指定一个明确的过渡持续时间（以毫秒为单位）：</target>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">在这种情况下，父级中的 &lt;code&gt;.native&lt;/code&gt; 侦听器将默默中断。不会有任何错误，但是在我们期望的时候不会调用 &lt;code&gt;onFocus&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">在&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPM软件包&lt;/a&gt;的 &lt;code&gt;dist/&lt;/code&gt; 目录中，您会找到许多不同的Vue.js版本。以下是它们之间的区别的概述：</target>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅在 &lt;code&gt;$event.key&lt;/code&gt; 等于 &lt;code&gt;'PageDown'&lt;/code&gt; 时才调用处理程序。</target>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">在布尔属性的情况下，仅它们的存在就意味着 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;v-bind&lt;/code&gt; 的工作方式略有不同。在此示例中：</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">在控制台中，输入 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; 。您应该看到一个新项目附加到列表中。</target>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;currentTabComponent&lt;/code&gt; 可以包含以下任意一个：</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;appear&lt;/code&gt; 属性或 &lt;code&gt;v-on:appear&lt;/code&gt; 挂钩都会导致出现过渡。</target>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">将来，您可以查阅&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API参考&lt;/a&gt;以获取实例属性和方法的完整列表。</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">在父级中，我们可以通过添加 &lt;code&gt;postFontSize&lt;/code&gt; 数据属性来支持此功能：</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">在上面的两个示例中，我们碰巧传递了字符串值，但是实际上可以将&lt;em&gt;任何&lt;/em&gt;类型的值传递给prop。</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">在这些情况下，还可以使用 &lt;code&gt;key&lt;/code&gt; 属性在同一元素的不同状态之间转换。代替使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-else&lt;/code&gt; ，上述示例可以重写为：</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">在这些情况下,你可以将你的组件定义为普通的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">在这种情况下， &lt;code&gt;filterA&lt;/code&gt; ，带一个参数定义，将获得的值 &lt;code&gt;message&lt;/code&gt; ，然后 &lt;code&gt;filterB&lt;/code&gt; 功能将与的结果被称为 &lt;code&gt;filterA&lt;/code&gt; 送入 &lt;code&gt;filterB&lt;/code&gt; 的单个参数。</target>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">在这种情况下，为 &lt;code&gt;class&lt;/code&gt; 定义了两个不同的值：</target>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">在这种情况下，使用 &lt;code&gt;watch&lt;/code&gt; 选项可以使我们执行异步操作（访问API），限制执行该操作的频率，并设置中介状态，直到获得最终答案。使用计算属性，这一切都不可能。</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">在此组件中， &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 的所有后代都需要访问 &lt;code&gt;getMap&lt;/code&gt; 方法，以便知道要与之交互的地图。不幸的是，使用 &lt;code&gt;$parent&lt;/code&gt; 属性无法很好地扩展到更深层嵌套的组件。那就是使用两个新的实例选项在依赖注入中有用的地方： &lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">在此示例中，我们选择命名包含所有插槽道具 &lt;code&gt;slotProps&lt;/code&gt; 的对象，但您可以使用任何喜欢的名称。</target>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">在此示例中，当 &lt;code&gt;eventName&lt;/code&gt; 的值为 &lt;code&gt;&quot;focus&quot;&lt;/code&gt; ， &lt;code&gt;v-on:[eventName]&lt;/code&gt; 将等效于 &lt;code&gt;v-on:focus&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">模板内表达式非常方便,但它们是为了简单的操作。在你的模板中放入过多的逻辑会使模板变得臃肿,难以维护。比如说</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">单个节点</target>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">React开发人员的信息</target>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">内联模板</target>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">在 &lt;code&gt;v-for&lt;/code&gt; 块中，我们可以完全访问父范围属性。 &lt;code&gt;v-for&lt;/code&gt; 还为当前项目的索引支持可选的第二个参数。</target>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">安装Vue.js插件。如果插件是对象，则必须公开 &lt;code&gt;install&lt;/code&gt; 方法。如果它本身是一个函数，它将被视为安装方法。将以Vue作为参数调用install方法。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">实例DOM选项</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">实例生命周期钩子</target>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">实例方法/数据</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">实例方法/事件</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">实例方法/生命周期</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">实例属性</target>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">代替计算属性，我们可以定义与方法相同的函数。对于最终结果，这两种方法确实完全相同。但是，不同之处在于，已&lt;strong&gt;计算的属性基于其反应性依赖关系进行缓存。&lt;/strong&gt;计算属性仅在其某些反应相关性已更改时才会重新评估。这意味着只要 &lt;code&gt;message&lt;/code&gt; 未更改，对 &lt;code&gt;reversedMessage&lt;/code&gt; 计算属性的多次访问将立即返回之前的计算结果，而无需再次运行该函数。</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">我们也可以在一个内联JavaScript语句中使用方法,而不是直接与方法名绑定。</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">不用对每个待办事项的内容进行硬编码，我们可以通过使每个待办事项都成为一个插槽，然后将 &lt;code&gt;todo&lt;/code&gt; 绑定为一个插槽道具，来让父组件来控制：</target>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">而不是使用此接口来监视商店本身发出的事件（例如， &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; ）， &lt;code&gt;store.subscribe&lt;/code&gt; 引入了一种新的方法store.subscribe。插件内部的典型用法是：</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">相反，&lt;strong&gt;组件的 &lt;code&gt;data&lt;/code&gt; 选项必须是function&lt;/strong&gt;，以便每个实例都可以维护返回数据对象的独立副本：</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">而是直接检索反应性数据。</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">相反，我们建议将这两个前缀组合到 &lt;code&gt;$_&lt;/code&gt; ，以作为用户定义的私有属性的约定，以保证与Vue不冲突。</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">相反,我们希望每个组件实例只管理自己的数据。要做到这一点,每个实例必须生成一个唯一的数据对象。在JavaScript中,这可以通过在函数中返回对象来实现。</target>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">相反,如果你想使用速记,你必须始终指定槽的名称。</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">相反，您应该使用&lt;strong&gt;对象&lt;/strong&gt;数组，以便 &lt;code&gt;v-model&lt;/code&gt; 可以更新对象上的字段。例如：</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">集成第三方路由器</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">有趣的是,Angular和Vue在解决这些AngularJS问题上有不少相似之处。</target>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">在内部,scoped slots的工作方式是将你的slot内容包装在一个传递给你的单一参数的函数中。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">无法对textareas（ &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; ）进行插值。请改用 &lt;code&gt;v-model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">属性内插值&lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">属性内插值不再有效。例如:</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">这也使得设计师和经验较少的开发人员更容易解析和贡献代码库。</target>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">它也可以用来强制替换一个元素/组件,而不是重复使用它。当您想:</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">它不能从用户构建的&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;预设&lt;/a&gt;生成项目，这对于具有预先建立的约定的企业环境特别有用。</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">这取决于几个因素。</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">它不允许在项目生成期间进行任何配置，而Vue CLI在可升级的运行时依赖项之上运行，该依赖项可以通过&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">与在单个 &lt;code&gt;components&lt;/code&gt; 目录中滚动相比，浏览嵌套子目录通常需要更多时间。</target>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">在事件处理程序中调用 &lt;code&gt;event.preventDefault()&lt;/code&gt; 或 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 是非常常见的需求。尽管我们可以轻松地在方法内部执行此操作，但最好是这些方法可以纯粹与数据逻辑有关，而不是必须处理DOM事件详细信息。</target>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">也可以用 &lt;code&gt;v-else&lt;/code&gt; 添加一个&amp;ldquo; else块&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">在同一模板中不再支持具有相同名称的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 。渲染插槽后，它将被&amp;ldquo;用完&amp;rdquo;，并且无法在同一渲染树中的其他位置进行渲染。如果必须在多个地方渲染相同的内容，请将该内容作为道具传递。</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">现在禁止替换组件实例的根$ data。这样可以防止在反应性系统中出现一些极端情况，并使组件状态更加可预测（尤其是在类型检查系统中）。</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">通常情况下,直接绑定到样式对象是个不错的主意,这样模板会更简洁。</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">人们常常忽略了Vue应用程序中真相的来源是原始 &lt;code&gt;data&lt;/code&gt; 对象-Vue实例仅代理对其的访问。因此，如果您有一个状态应该由多个实例共享，则可以通过标识共享它：</target>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">建议尽可能在 &lt;code&gt;v-for&lt;/code&gt; 中提供 &lt;code&gt;key&lt;/code&gt; 属性，除非迭代的DOM内容很简单，或者您有意依赖默认行为来获得性能。</target>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">它通常工作良好，但延迟的状态更新可能会导致奇怪的行为。例如，单击&amp;ldquo; &lt;code&gt;Result&lt;/code&gt; 选项卡，然后尝试在这些输入之一中输入 &lt;code&gt;9.999&lt;/code&gt; 。当输入失去焦点时，其值将更新为 &lt;code&gt;$10.00&lt;/code&gt; 。但是，在查看计算出的总数时，您会看到 &lt;code&gt;9.999&lt;/code&gt; 是存储在我们的数据中的内容。用户看到的现实版本不同步！</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">它仅提供一个模板（假定您正在构建单页应用程序），而Vue提供了多种用于各种目的和构建系统的默认选项。</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">当可能只有生命周期挂钩需要访问 &lt;code&gt;picker&lt;/code&gt; ，它需要将选择器保存到组件实例。这并不可怕，但是可以认为它很杂乱。</target>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">应当指出的是，&lt;strong&gt;这种限制并&lt;em&gt;没有&lt;/em&gt;，如果你正在使用字符串模板从下列来源之一适用&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">它将呈现。</target>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">实际上，可以通过使用多个 &lt;code&gt;v-if&lt;/code&gt; 或将单个元素绑定到动态属性在任意数量的元素之间进行转换。例如：</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">为纯JavaScript转换显式添加 &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; 也是一个好主意，以便Vue可以跳过CSS检测。这还可以防止CSS规则意外干扰过渡。</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">将应用程序组织成嵌套的组件树是很常见的：</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">通过浏览HTML模板，可以更轻松地在JS代码中找到处理函数的实现。</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">同样，切换元素的存在也很容易：</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">需要特别注意的是，这些限制中的许多是由create-react-app团队故意设计的决策，它们确实有其优势。例如，只要您的项目需求非常简单，并且您无需&amp;ldquo;退出&amp;rdquo;以定制您的构建过程，就可以将其作为依赖项进行更新。您可以&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;在此处&lt;/a&gt;详细了解不同的哲学。</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">重要的是要注意，您切勿在操作中替换原始状态对象-组件和存储区需要共享对同一对象的引用才能观察到突变。</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">很少会在JavaScript中引用全局组件，因此遵循JavaScript约定没有意义。</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">建议将所有内容包装在一个新元素中，如下所示：</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">在事件中发出特定的值有时很有用。例如，我们可能希望 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 组件负责将文本放大多少。在这种情况下，我们可以使用 &lt;code&gt;$emit&lt;/code&gt; 的第二个参数来提供此值：</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX与模板</target>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScript 钩子</target>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">JavaScript的本机 &lt;code&gt;.filter&lt;/code&gt; 也可以管理更复杂的过滤操作，因为您可以在计算属性中访问JavaScript的全部功能。例如，如果您要查找所有活动用户，并且不区分大小写地将其名称和电子邮件匹配：</target>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">加入Vue.js社区</target>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">就像HTML元素一样，将内容传递到组件通常很有用，如下所示：</target>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">只是为了支持模板中相对较少的标记。</target>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">但是请记住，使用此模式构建的组件本质上仍是易碎的。例如，假设我们添加了一个新的 &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; 组件，并且当其中出现 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 时，它仅应呈现属于该区域的标记：</target>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">关键代码</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">关键修改器</target>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">键控 &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;必备&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">键控v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">Knockout是MVVM和相关性跟踪空间的先驱，其反应系统与Vue的非常相似。考虑到它所做的一切，它的&lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;浏览器支持&lt;/a&gt;也非常令人印象深刻，并且支持IE6！另一方面，Vue仅支持IE9 +。</target>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">大型应用程序的复杂性通常会增加，这是因为分散在许多组件之间的多个状态及其之间的交互。为了解决这个问题，Vue提供了&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;：我们自己的Elm风格的状态管理库。它甚至集成到&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools中&lt;/a&gt;，提供零设置访问&lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;时间旅行调试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">最后，Vue单文件组件的样式非常灵活。通过&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;，您可以在 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 元素内使用任何预处理器，后处理器，甚至与&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS模块进行&lt;/a&gt;深度集成。</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">最新稳定版本:2.6.10</target>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../api/index#provide-inject&quot;&gt;API文档中&lt;/a&gt;了解有关依赖项注入的更多信息。</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">学习曲线</target>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">让我们看一个简单的示例，其中的 &lt;code&gt;render&lt;/code&gt; 功能将是实用的。假设您要生成锚定标题：</target>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">假设您有一个待办事项清单：</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">假设您要创建一个自定义指令，该指令允许您使用固定位置将元素固定到页面。我们可以创建一个自定义指令，其中值更新像素的垂直位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">假设您正在构建文件目录树，例如在Finder或File Explorer中。您可能有一个带有此模板的 &lt;code&gt;tree-folder&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">生命周期图</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">生命周期事件(按其名称顺序排列)</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">生命周期挂钩</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">列表进入/离开转换</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">列表移动转换</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">列表渲染</target>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">列表转换</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">在当前虚拟机上监听自定义事件。可以由 &lt;code&gt;vm.$emit&lt;/code&gt; 触发事件。回调将接收传递给这些事件触发方法的所有其他参数。</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">侦听一个自定义事件,但只能一次。一旦第一次触发,监听器将被删除。</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; 仅侦听一次事件</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; 监听事件</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">监听的组件内置事件与 &lt;code&gt;v-on&lt;/code&gt; &lt;sup&gt;改变&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">监听子组件事件</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">聆听事件</target>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">侦听子组件上的自定义事件（在子组件上发出&amp;ldquo; my-event&amp;rdquo;时调用处理程序）：</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">听了烤肉盒版的就没有影响了。</target>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">本地注册</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">模块系统中的本地注册</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">现在逻辑与表现层解耦,使得维护(更改/扩展逻辑)变得更加容易。</target>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">维持国家</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">使Vue忽略在Vue之外定义的自定义元素（例如，使用Web组件API）。否则，如果您忘记注册全局组件或拼写错误的组件名称，则会引发有关 &lt;code&gt;Unknown custom element&lt;/code&gt; 的警告。</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">使对象具有反应性。在内部，Vue在由 &lt;code&gt;data&lt;/code&gt; 函数返回的对象上使用它。</target>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">请务必阅读有关&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;的不同构建Vue公司的&lt;/a&gt;，并使用&lt;strong&gt;生产&lt;br/&gt;版本&lt;/strong&gt;在发布的站点，更换 &lt;code&gt;vue.js&lt;/code&gt; 与 &lt;code&gt;vue.min.js&lt;/code&gt; 。这是针对速度而不是开发经验进行了优化的较小版本。</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">管理许多状态转换会迅速增加Vue实例或组件的复杂性。幸运的是，可以将许多动画提取到专用的子组件中。让我们使用前面示例中的动画整数来做到这一点：</target>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">在非常简单的情况下，在 &lt;code&gt;this.$root&lt;/code&gt; 和/或使用&lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;全局事件总线&lt;/a&gt;上管理状态可能很方便，但不适用于大多数应用程序。Vuex不仅提供了一个状态管理中心，还提供了用于组织，跟踪和调试状态更改的工具。</target>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">在将子组件、道具或数据传递给子组件之前,先对它们进行操作。</target>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">许多文件名称相似,使得代码编辑器中的文件快速切换更加困难。</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">许多嵌套的子目录，这增加了浏览编辑器侧边栏中的组件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">您的许多组件都是相对通用的，可能只包装诸如输入或按钮之类的元素。有时我们将它们称为&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本组件，&lt;/a&gt;并且它们在您的组件中往往会经常使用。</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;v-for&lt;/code&gt; 将数组映射到元素</target>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">元实例方法</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">方法事件处理程序</target>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">内联处理程序中的方法</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">要混合到Vue实例中的方法。您可以直接在VM实例上访问这些方法，也可以在指令表达式中使用它们。所有方法都将有自己的 &lt;code&gt;this&lt;/code&gt; 背景下自动绑定到Vue的实例。</target>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;替换&lt;/sup&gt;中间件&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">中间件被插件所取代。插件是一个接收存储作为唯一参数的函数,可以监听存储上的突变事件。</target>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">从Vue 1.x迁移</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">从Vue Router 0.7.x迁移到Vue Router 0.7.x。</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">从Vuex 0.6.x到1.0的迁移。</target>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Mixin挂钩按其提供的顺序调用，并在组件自己的挂钩之前调用。</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Mixins是为Vue组件分发可重用功能的灵活方法。mixin对象可以包含任何组件选项。当组件使用混入时，混入中的所有选项都将被&amp;ldquo;混入&amp;rdquo;到组件自己的选项中。</target>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX已在React社区中变得非常流行，并且实际上使用了与Vue几乎相同的反应系统。在一定程度上，React + MobX工作流可以被认为是更冗长的Vue，因此，如果您正在使用该组合并很喜欢它，那么进入Vue可能是下一个合乎逻辑的步骤。</target>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">修改器键。</target>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">修饰符是用点表示的特殊后缀，表示应以某种特殊方式绑定指令。例如， &lt;code&gt;.prevent&lt;/code&gt; 修饰符告诉 &lt;code&gt;v-on&lt;/code&gt; 指令在触发的事件上调用 &lt;code&gt;event.preventDefault()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">模块系统</target>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">更成熟的工具支持。Vue为&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt;和&lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;提供官方支持，而Riot依靠社区对构建系统集成的支持。</target>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;，则默认情况下会启用以下大多数提示。仅当您使用自定义构建设置时，此部分才有意义。</target>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">大多数突变道具的用例都可以用这些选项之一来代替。</target>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">鼠标按钮修改器</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">好多了，不是吗？</target>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">简单得多！有点。代码更短，但也需要更熟悉Vue实例属性。在这种情况下，您必须知道，当您将没有 &lt;code&gt;v-slot&lt;/code&gt; 指令的子代传递到组件中时，例如 &lt;code&gt;Hello world!&lt;/code&gt; 在 &lt;code&gt;anchored-heading&lt;/code&gt; ，这些子项存储在 &lt;code&gt;$slots.default&lt;/code&gt; 的组件实例上。如果还没有的话，&lt;strong&gt;建议在进入渲染功能之前通读&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;实例属性API&lt;/a&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">多属性元素</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;多属性元素&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">多字组件名称</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">多词组件名称&lt;sup&gt;必不可少&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">多行文字</target>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">多值</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">多个复选框,绑定到同一个阵列。</target>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">多节点,一次只渲染一个节点。</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">多重选择(绑定到阵列)。</target>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">在HTML属性内不能使用胡须。而是使用&lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind指令&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">现在将局部 &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 道具视为反模式，例如，声明道具然后在组件中设置this.myProp ='someOtherValue'。由于采用了新的渲染机制，每当父组件重新渲染时，子组件的本地更改都将被覆盖。</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">突变方法</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">顾名思义，变异方法会变异调用它们的原始数组。相比之下，还有一些非变异方法，例如 &lt;code&gt;filter()&lt;/code&gt; ， &lt;code&gt;concat()&lt;/code&gt; 和 &lt;code&gt;slice()&lt;/code&gt; ，它们不会变异原始数组，但&lt;strong&gt;总是返回一个新数组&lt;/strong&gt;。使用非突变方法时，可以将旧数组替换为新数组：</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">使用Vue构建大型应用程序时，建议使用NPM安装方法。它与诸如&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;或&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify之&lt;/a&gt;类的模块捆绑器很好地配对。Vue还提供了用于创作&lt;a href=&quot;single-file-components&quot;&gt;单一文件组件的&lt;/a&gt;随附工具。</target>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">壳体名称</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">名称冲突（例如，多个 &lt;code&gt;ButtonDelete.vue&lt;/code&gt; 组件）使在代码编辑器中快速导航到特定组件变得更加困难。</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">名义老虎机</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">名义老虎机速记</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">具有 &lt;code&gt;slot&lt;/code&gt; 属性的命名插槽</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">本地渲染</target>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0+中的新增功能：如果未提供回调且执行环境中支持Promise，则返回Promise。请注意，Vue不带有Promise polyfill，因此，如果您定位的浏览器本身不支持Promises（IE，则是您），则您必须自己提供一个polyfill。</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+中的新功能</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0中的新功能</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+中的新功能</target>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">不再需要了,因为现在默认情况下,警告会带有堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">没有实际用途。如果您确实碰巧以某种方式依赖此功能，并且不确定如何解决该功能，请在&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;论坛&lt;/a&gt;上发布想法。</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">节点、树和虚拟 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">非道具属性</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">非流动状态管理</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">非通量状态管理&lt;sup&gt;谨慎使用&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 中的每个孩子都必须&lt;strong&gt;唯一地设置关键帧&lt;/strong&gt;，动画才能正常工作。</target>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 要求使用组件上的 &lt;code&gt;name&lt;/code&gt; 选项或通过本地/全局注册将组件之间切换为全部具有名称。</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">需要注意的是 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 选项并&lt;strong&gt;不会&lt;/strong&gt;影响 &lt;code&gt;style&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 绑定。</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;mounted&lt;/code&gt; 并&lt;strong&gt;不能&lt;/strong&gt;保证所有的子组件也已安装。如果你想等到整个图已经呈现，您可以使用&lt;a href=&quot;#vm-nextTick&quot;&gt;虚拟机$ nextTick。&lt;/a&gt;里面 &lt;code&gt;mounted&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 上不支持 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; ，因此，如果需要在新选项卡中打开链接，则必须使用 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">请注意， &lt;code&gt;updated&lt;/code&gt; 并&lt;strong&gt;不能&lt;/strong&gt;保证所有子组件也都已重新呈现。如果你想等到整个视图已经重新呈现，你可以使用&lt;a href=&quot;#vm-nextTick&quot;&gt;虚拟机$ nextTick。&lt;/a&gt;内 &lt;code&gt;updated&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;v-bind&lt;/code&gt; 与 &lt;code&gt;.sync&lt;/code&gt; 修改器&lt;strong&gt;不&lt;/strong&gt;使用表达式的工作（如 &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 是无效的）。相反，您必须仅提供要绑定的属性的名称，类似于 &lt;code&gt;v-model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;v-show&lt;/code&gt; 不支持 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素，也不与 &lt;code&gt;v-else&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; 只能添加到 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt;（&lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;一个例外&lt;/a&gt;），与不推荐使用的&lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; 属性不同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">注意，&lt;strong&gt;本地注册的组件在子组件中&lt;em&gt;也不&lt;/em&gt;可用&lt;/strong&gt;。例如，如果希望 &lt;code&gt;ComponentA&lt;/code&gt; 在 &lt;code&gt;ComponentB&lt;/code&gt; 中可用，则必须使用：</target>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">请注意，&lt;strong&gt;您不应使用箭头函数定义方法&lt;/strong&gt;（例如 &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ）。原因是箭头函数绑定了父上下文，因此 &lt;code&gt;this&lt;/code&gt; 将不是您期望的Vue实例，并且 &lt;code&gt;this.a&lt;/code&gt; 将是未定义的。</target>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">请注意，&lt;strong&gt;您不应使用箭头函数来定义观察者&lt;/strong&gt;（例如 &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ）。原因是箭头函数绑定了父上下文，因此 &lt;code&gt;this&lt;/code&gt; 将不是您期望的Vue实例，并且 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; 将是未定义的。</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">请注意，Vue的事件系统不同于浏览器的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;。虽然他们的工作同样， &lt;code&gt;$emit&lt;/code&gt; ， &lt;code&gt;$on&lt;/code&gt; ，和 &lt;code&gt;$off&lt;/code&gt; 是&lt;strong&gt;不是&lt;/strong&gt;对的别名 &lt;code&gt;dispatchEvent&lt;/code&gt; ， &lt;code&gt;addEventListener&lt;/code&gt; 和 &lt;code&gt;removeEventListener&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">请注意，对于其他指令（例如 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; ），JavaScript的正常真实性仍然适用。</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">请注意，如果您使用箭头功能与计算性能， &lt;code&gt;this&lt;/code&gt; 不会是组件的实例，但你仍然可以访问实例作为函数的第一个参数：</target>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">请注意，如果您使用箭头功能与 &lt;code&gt;data&lt;/code&gt; 属性， &lt;code&gt;this&lt;/code&gt; 不会是组件的实例，但你仍然可以访问实例作为函数的第一个参数：</target>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">请注意，在ES2015 +中，将像 &lt;code&gt;ComponentA&lt;/code&gt; 这样的变量名放在对象内是 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 简写，这意味着变量的名称是两个：</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">请注意,在这个方法中,我们在不接触DOM的情况下更新应用的状态--所有的DOM操作都由Vue来处理,你写的代码集中在底层逻辑上。</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">请注意，&lt;strong&gt;不&lt;/strong&gt;建议同时使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;样式指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">需要注意的是修饰键从常规按键不同，与使用时 &lt;code&gt;keyup&lt;/code&gt; 事件，他们有当发出该事件被按下。换句话说， &lt;code&gt;keyup.ctrl&lt;/code&gt; 仅在按住 &lt;code&gt;ctrl&lt;/code&gt; 的同时释放键时才会触发。如果仅释放 &lt;code&gt;ctrl&lt;/code&gt; 键，则不会触发。如果你想这样的行为，使用 &lt;code&gt;keyCode&lt;/code&gt; 为 &lt;code&gt;ctrl&lt;/code&gt; 改为： &lt;code&gt;keyup.17&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">请注意，JavaScript中的对象和数组是通过引用传递的，因此，如果prop是数组或对象，则在子组件内部对对象或数组本身进行更改&lt;strong&gt;将&lt;/strong&gt;影响父状态。</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">请注意，&lt;strong&gt;在&lt;/strong&gt;创建组件实例&lt;strong&gt;之前先&lt;/strong&gt;对props进行了验证，因此实例属性（例如 &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;computed&lt;/code&gt; 等）在 &lt;code&gt;default&lt;/code&gt; 或 &lt;code&gt;validator&lt;/code&gt; 函数中将不可用。</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">请注意， &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 元素仍然有效地重复使用，因为它们没有 &lt;code&gt;key&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">请注意，默认槽位的缩写语法&lt;strong&gt;不能&lt;/strong&gt;与命名槽位混合使用，因为这会导致范围模糊：</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">请注意，在 &lt;code&gt;Vue.extend()&lt;/code&gt; 中使用了相同的合并策略。</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">请注意，使用 &lt;code&gt;immediate&lt;/code&gt; 选项，您将无法在第一个回调调用中取消监视给定的属性。</target>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">请注意，必须在组件方法中包括 &lt;code&gt;strict: true&lt;/code&gt; （或至少 &lt;code&gt;noImplicitThis: true&lt;/code&gt; ，它是 &lt;code&gt;strict&lt;/code&gt; 标志的一部分），以利用 &lt;code&gt;this&lt;/code&gt; 类型的检查，否则始终将其视为 &lt;code&gt;any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">请注意，如果您希望对路由组件使用上述语法，则必须使用&lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+。</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">请注意，您仍然必须在组件的 &lt;code&gt;props&lt;/code&gt; 选项中声明 &lt;code&gt;checked&lt;/code&gt; prop 。</target>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">注意 &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 属性。这在DOM模板中是必需的，因为在 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 中只有 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 元素有效。它的作用与 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 相同，但可以解决潜在的浏览器解析错误。请参阅&lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM模板解析警告&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">注意， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 是为其中一个直接子组件被切换的情况而设计的。如果内部有 &lt;code&gt;v-for&lt;/code&gt; ，则无法使用。如上所述，当有多个有条件的子代时， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 要求一次仅渲染一个子代。</target>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">注意：在Macintosh键盘上，meta是命令键（⌘）。在Windows键盘上，meta是Windows键（⊞）。在Sun Microsystems键盘上，meta被标记为实心菱形（◆）。在某些键盘上，特别是MIT和Lisp机器键盘以及后继键盘（例如Knight键盘，太空学员键盘），meta标记为&amp;ldquo; META&amp;rdquo;。在Symbolics键盘上，meta标记为&amp;ldquo; META&amp;rdquo;或&amp;ldquo; Meta&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">注意：在2.3.0之前的版本中，如果您希望在功能组件中接受props，则需要 &lt;code&gt;props&lt;/code&gt; 选项。在2.3.0+中，您可以省略 &lt;code&gt;props&lt;/code&gt; 选项，并且在组件节点上找到的所有属性都将隐式提取为props。</target>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">注： &lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 绑定没有反应。这是故意的。但是，如果向下传递观察到的对象，则该对象的属性确实保持反应性。</target>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">注：该选项并&lt;strong&gt;不会&lt;/strong&gt;影响到 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; 的绑定。</target>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">注意：变异（而不是替换）对象或数组时，旧值将与新值相同，因为它们引用相同的对象/数组。Vue不会保留突变前值的副本。</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">请注意，所有改变商店状态的操作都放在商店本身内部。这种类型的集中状态管理可以更轻松地了解可能发生什么类型的突变以及如何触发它们。现在，当出现问题时，我们还将获得导致该错误的事件日志。</target>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">请注意，单击按钮时，每个按钮都会维护自己的单独 &lt;code&gt;count&lt;/code&gt; 。这是因为每次使用组件时，都会创建该组件的新&lt;strong&gt;实例&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">现在， &lt;code&gt;v-model&lt;/code&gt; 应该可以与该组件完美配合：</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">现在，可以在 &lt;code&gt;ComponentB&lt;/code&gt; 的模板中使用 &lt;code&gt;ComponentA&lt;/code&gt; 和 &lt;code&gt;ComponentC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">现在， &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素内的所有内容都将传递到相应的插槽。假定未将任何未包装在使用 &lt;code&gt;v-slot&lt;/code&gt; 的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 中的内容用于默认插槽。</target>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">现在，在定义了这个 &lt;code&gt;ref&lt;/code&gt; 的组件中，您可以使用：</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">现在是时候进行深入研究了！Vue最独特的功能之一是不引人注目的反应系统。模型只是普通的JavaScript对象。修改它们时，视图将更新。它使状态管理变得简单而直观，但是了解它如何工作来避免一些常见问题也很重要。在本节中，我们将深入研究Vue反应系统的一些底层细节。</target>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">现在，让我们在每个帖子的内容之前添加一个按钮来放大文本：</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">现在让我们来看一个示例，使用我们之前使用的相同CSS类转换进入和离开：</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">现在让我们来看一个例子。这是使用Velocity.js的JavaScript过渡：</target>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">现在，让我们使用 &lt;code&gt;out-in&lt;/code&gt; 更新开/关按钮的过渡：</target>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">现在， &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 组件是一个&lt;strong&gt;完全透明的包装器&lt;/strong&gt;，这意味着它可以像普通的 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素一样完全使用：所有相同的属性和侦听器都可以使用，而无需 &lt;code&gt;.native&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">现在，即使未呈现，&amp;ldquo; &lt;em&gt;帖子&amp;rdquo;&lt;/em&gt;选项卡仍保持其状态（选定的帖子）。有关完整的代码，请参&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;见此小提琴&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">现在,这些输入将在你每次切换时从头呈现。你自己看看吧。</target>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">现在我们可以使用 &lt;code&gt;v-bind&lt;/code&gt; 将待办事项传递到每个重复的组件中：</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">现在我们得到。</target>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">现在，我们将回答社区可以为您做些什么以及您可以为社区做些什么。</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">现在，在此组件上使用 &lt;code&gt;v-model&lt;/code&gt; 时：</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">现在，当我们在父组件中使用 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 时，不提供该插槽的任何内容：</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">现在，当我们使用 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 组件时，我们可以有选择地为待办事项定义一个替代的 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; ，但是可以从子级访问数据：</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">现在，当您运行 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; ，将调用setter 并 &lt;code&gt;vm.lastName&lt;/code&gt; 地更新 &lt;code&gt;vm.firstName&lt;/code&gt; 和vm.lastName。</target>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">现在，只要对 &lt;code&gt;sourceOfTruth&lt;/code&gt; 进行了 &lt;code&gt;vmA&lt;/code&gt; ，vmA和 &lt;code&gt;vmB&lt;/code&gt; 都将自动更新其视图。每个实例中的子组件也可以通过 &lt;code&gt;this.$root.$data&lt;/code&gt; 。现在我们只有一个事实来源，但是调试将是一场噩梦。应用程序的任何部分都可以随时更改任何数据，而不会留下任何痕迹。</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">现在，您可以在另一个组件的模板中编写它：</target>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，只要将新属性添加到 &lt;code&gt;post&lt;/code&gt; 对象中，它就会自动在 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 内部可用。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">对象变更检测的注意事项</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">对象文字</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">对象语法</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">国家预防机制包中的正式声明</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">正式的类通量实施</target>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">官方路由器</target>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">在 &lt;code&gt;input&lt;/code&gt; ，发出自己的定制 &lt;code&gt;input&lt;/code&gt; 事件与新价值</target>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">在更高的层次上,我们可以将组件分为两类:呈现性的和逻辑性的。我们推荐使用模板来处理演示性组件,而使用渲染函数/JSX来处理逻辑性组件。这些组件的比例取决于你正在构建的应用程序的类型,但一般来说,我们发现呈现性的组件更为常见。</target>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">在普通组件上，未定义为prop的属性会自动添加到组件的根元素中，从而替换或&lt;a href=&quot;class-and-style&quot;&gt;智能合并&lt;/a&gt;任何同名的现有属性。</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">在根Vue实例（即使用 &lt;code&gt;new Vue({ ... })&lt;/code&gt; 创建的实例）上，必须使用 &lt;code&gt;propsData&lt;/code&gt; 而不是 &lt;code&gt;props&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">另一方面， &lt;code&gt;$refs&lt;/code&gt; 主要设计用于JavaScript中的编程访问-不建议在模板中依赖它们，因为这将意味着引用不属于实例本身的状态。这将违反Vue的数据驱动视图模型。</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">另一方面，仅运行时版本完全符合CSP。当通过&lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt;或&lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;使用仅限运行时的版本时，您的模板将被预编译为 &lt;code&gt;render&lt;/code&gt; 功能，这些功能可以在CSP环境中完美运行。</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">在此页面上，我们仅介绍进入，离开和列出转换，但是您可以在下一节中了解如何&lt;a href=&quot;transitioning-state&quot;&gt;管理状态转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">一旦一个道具被注册,你可以将数据作为一个自定义属性传递给它,就像这样。</target>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">再次尝试不要过度使用此模式。尽管在少数情况下必须渲染大量静态内容很方便，但是除非您实际上注意到渲染速度很慢，否则根本没有必要，而且在以后可能会引起很多混乱。例如，想象另一个不熟悉 &lt;code&gt;v-once&lt;/code&gt; 或只是在模板中错过了它的开发人员。他们可能会花费数小时来试图弄清为什么模板未正确更新。</target>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">一旦被观察到,你就不能再向根数据对象添加反应式属性。因此,建议在创建实例之前,预先声明所有根级反应式属性。</target>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">一旦您对刚学过的知识感到满意，我们建议您重新阅读有关&amp;ldquo; &lt;a href=&quot;components-dynamic-async&quot;&gt;动态和异步组件&amp;rdquo;&lt;/a&gt;的完整指南，以及侧栏的&amp;ldquo;组件深度&amp;rdquo;部分中的其他页面。</target>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">重要的注意事项是，这些FLIP过渡不适用于设置为 &lt;code&gt;display: inline&lt;/code&gt; 元素：inline。或者，您可以使用 &lt;code&gt;display: inline-block&lt;/code&gt; 或将元素放置在flex上下文中。</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">要注意的一件事是，&lt;strong&gt;关注点的分离不等于文件类型的分离。&lt;/strong&gt;在现代UI开发中，我们发现，将代码库分为松散耦合的组件并组成它们，这比将代码库分为相互交织的三大层更有意义。在组件内部，其模板，逻辑和样式固有地耦合在一起，并且将它们并置实际上会使组件更具凝聚力和可维护性。</target>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">最常见的过渡类型之一是CSS过渡。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">这些方法最常见的用途之一是在父母与其直系子女之间进行交流。在这些情况下，您实际上可以&lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;使用&lt;/a&gt; &lt;code&gt;v-on&lt;/code&gt; 听孩子的 &lt;code&gt;$emit&lt;/code&gt; 。这使您可以通过增加明确性来保持事件的便利性。</target>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">一个或多个命名参数已&lt;sup&gt;更改&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">需要注意的一件事：类似于 &lt;code&gt;v-bind:class&lt;/code&gt; 和 &lt;code&gt;v-bind:style&lt;/code&gt; 在模板中有特殊处理的方式，它们在VNode数据对象中有自己的顶级字段。此对象还允许您绑定普通的HTML属性以及DOM属性（例如 &lt;code&gt;innerHTML&lt;/code&gt; )（这将替换 &lt;code&gt;v-html&lt;/code&gt; 指令）：</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">一次绑定（ &lt;code&gt;{{* foo }}&lt;/code&gt; ）已被新的&lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; 指令&lt;/a&gt;替换。</target>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">一次性绑定已&lt;sup&gt;替换&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">单向数据流</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">只有UMD构建可以从Bower那里获得。</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">只有Vue Router 2与Vue 2兼容，因此，如果要更新Vue，则还必须更新Vue Router。这就是为什么我们在主要文档中此处包含有关迁移路径的详细信息的原因。有关使用新Vue路由器的完整指南，请参阅&lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue路由器文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">只有Vue Router 2与Vue 2兼容，因此，是的，您还必须遵循&lt;a href=&quot;migration-vue-router&quot;&gt;Vue Router&lt;/a&gt;的迁移路径。幸运的是，大多数应用程序没有很多路由器代码，因此这可能不会花费一个多小时。</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">仅在2.2.0+中:也适用于Array+index。</target>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">优化工作</target>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">合并选项</target>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">期权/资产</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">选项/组成</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">选项/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">选项/数据</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">选项/生命周期挂钩</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">选项/其他</target>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">诸如 &lt;code&gt;acceptStatement&lt;/code&gt; ， &lt;code&gt;deep&lt;/code&gt; ， &lt;code&gt;priority&lt;/code&gt; 等的选项已全部删除。要替换 &lt;code&gt;twoWay&lt;/code&gt; 指令，请参见&lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;以下示例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">期望对象值的选项，例如 &lt;code&gt;methods&lt;/code&gt; ， &lt;code&gt;components&lt;/code&gt; 和 &lt;code&gt;directives&lt;/code&gt; ，将被合并到同一对象中。当这些对象中的键冲突时，将优先使用组件的选项：</target>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">或者是一个数据/计算的属性。</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">或渲染功能。</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">或者，可以在本地注册组件时使用Webpack的异步 &lt;code&gt;import&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">或者更好的是,将移除方法传递一个索引。</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">甚至其他组件。</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">或者，如果 &lt;code&gt;myElement&lt;/code&gt; 是最后一个孩子：</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">或者，如果您正在使用ES2015模块（例如通过Babel和Webpack），则可能看起来更像：</target>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">或者用渲染功能。</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">或者用组件方法。</target>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">或者,如果事件处理程序是一个方法。</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">或者，如果您使用的是仅运行时的Vue版本：</target>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">或者， &lt;code&gt;slot&lt;/code&gt; 属性也可以直接在普通元素上使用：</target>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">或者，通过&lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt&lt;/a&gt;和grunt- &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;browserify&lt;/a&gt;使用envify：</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">或者，在Gulp中使用&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">使用修饰符时顺序很重要，因为相关代码以相同顺序生成。因此，使用 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; 将阻止&lt;strong&gt;所有单击，&lt;/strong&gt;而 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; 将仅防止单击元素本身。</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">组成部分名称中的词序</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;组件名称中的单词顺序&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">组织组件</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">将过渡组织成组成部分</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">其他例子</target>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">我们的&lt;a href=&quot;https://vuejs.org/coc&quot;&gt;《行为准则》&lt;/a&gt;是一项指南，旨在使我们所有人和我们所参与的技术社区变得更加容易。</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">我们的自定义指令现在足够灵活,可以支持一些不同的用例。</target>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">我们的设置代码与我们的清理代码是分开的,这使得我们设置的任何东西在程序上清理起来更加困难。</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">但是随着时间的流逝，淘汰赛的发展已经放慢了脚步，并且开始显示出它的年龄。例如，其组件系统缺少完整的生命周期挂钩，尽管这是一个非常常见的用例，但与&lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt;相比，将孩子传递到组件的界面感觉有些笨拙。</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">总体而言，这消除了开发人员对整体性能优化的需求，使他们可以在扩展应用程序时更加专注于构建应用程序本身。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">部分部分已被删除，以便使用prop支持组件之间更明确的数据流。除非您在性能至关重要的区域中使用局部部件，否则建议您改用&lt;a href=&quot;components&quot;&gt;普通组件&lt;/a&gt;。如果要动态绑定部分的 &lt;code&gt;name&lt;/code&gt; ，则可以使用&lt;a href=&quot;components#Dynamic-Components&quot;&gt;动态组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCase比起kebab-case有一些优势。</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase与代码编辑器中的自动完成功能配合使用效果最佳，因为它与我们尽可能引用JS（X）和模板中的组件的方式一致。但是，大小写混合的文件名有时会在不区分大小写的文件系统上产生问题，这就是为什么kebab-case也完全可以接受的原因。</target>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">在创建实例时将道具传递给实例。这主要是为了使单元测试更容易。</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">将属性和事件传递给子元素/组件。</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">使用道具将数据传递给子组件</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">传递静态或动态道具</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">传递一个布尔值</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">传递数字</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">传递一个数组</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">传递对象</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">在选项中传递 &lt;code&gt;immediate: true&lt;/code&gt; 将立即使用表达式的当前值触发回调：</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">传递对象的属性</target>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">在性能方面，即使在Ember 3.x中更新了最新的Glimmer引擎之后，Vue仍比Ember表现&lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;出相当大的优势&lt;/a&gt;。Vue自动批处理更新，而在Ember中，您需要在性能关键的情况下手动管理运行循环。</target>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">请参考&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode类声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">请参考&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer软件包文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">插件可能会添加到Vue的全局/实例属性和组件选项。在这些情况下，需要使用类型声明来使插件在TypeScript中编译。幸运的是，有一个TypeScript功能可以扩展现有的类型，称为&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;模块扩充&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">插件通常为Vue添加全局级功能。一个插件没有严格定义的范围--通常有几种类型的插件。</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer是Google赞助的另一个项目，实际上也是Vue的灵感来源。Vue的组件可以与Polymer的自定义元素进行比较，并且两者都提供非常相似的开发风格。最大的不同是，Polymer是基于最新的Web组件功能构建的，并且要求非平凡的polyfill才能在本身不支持这些功能的浏览器中工作（性能下降）。相比之下，Vue可以在没有任何依赖项的情况下工作，也不会填充到IE9。</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">预编译模板</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Preact和其他类似React的图书馆</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">在 &lt;code&gt;scoped&lt;/code&gt; 样式中，类选择器优先于元素选择器，因为大量的元素选择器比较慢。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">很酷吧?</target>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">以前，将 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; 与 &lt;code&gt;v-for&lt;/code&gt; 结合使用会生成元素/组件数组，因为无法为每个项目赋予唯一的名称。您仍然可以通过为每个项目提供相同的 &lt;code&gt;ref&lt;/code&gt; 来实现此行为：</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">此前， &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; 将具有 &lt;code&gt;number&lt;/code&gt; 从0开始，并在结束9.现在开始于1，并在10结束。</target>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">主要用于保存组件状态或避免重新渲染。</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">优先A规则。(防错)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">优先事项A:基本要素</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">优先B规则。强烈建议(提高可读性)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">优先事项B:强烈建议</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">C优先规则。建议(尽量减少任意选择和认知开销)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">优先事项C:建议</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">D优先规则。谨慎使用(潜在危险模式)</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">优先级D。谨慎使用</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">私人财产名称</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">私有财产名称&lt;sup&gt;必不可少&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">问题解决了!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">生产部署</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">程序化事件监听器</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">程序化导航</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">程式化地选择其他几个组件中的一个来委托给</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">项目创建</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">道具箱(骆驼箱与烤肉箱)。</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">道具突变&lt;sup&gt;已弃用&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="23ca9a44a1ade4d87027ae10b8309bece2e74a54" translate="yes" xml:space="preserve">
          <source>Prop Types</source>
          <target state="translated">道具类型</target>
        </trans-unit>
        <trans-unit id="0d718a828e84189a6c1ea77a0099a78e06d7d7c9" translate="yes" xml:space="preserve">
          <source>Prop Validation</source>
          <target state="translated">道具验证</target>
        </trans-unit>
        <trans-unit id="3ad34219a208945c8ea06d8eb918df83f7e61456" translate="yes" xml:space="preserve">
          <source>Prop definitions</source>
          <target state="translated">道具定义</target>
        </trans-unit>
        <trans-unit id="e2f4b4fdf875186ea4cf16dbb812dbea30216d87" translate="yes" xml:space="preserve">
          <source>Prop definitions &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">道具定义&lt;sup&gt;必不可少&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="895e352dc19c97709d5567c55fe72b1a6d482c35" translate="yes" xml:space="preserve">
          <source>Prop name casing</source>
          <target state="translated">道具名称外壳</target>
        </trans-unit>
        <trans-unit id="b90f11ae0da8cbfe0b2f736a16886c055d6bffd1" translate="yes" xml:space="preserve">
          <source>Prop name casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;道具名称框&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="66e61e4c98d3b3a635091c842dada04fef1b9143" translate="yes" xml:space="preserve">
          <source>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt;. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.</source>
          <target state="translated">正确配置生产就绪的服务器渲染的应用程序的所有讨论方面可能是一项艰巨的任务。幸运的是，有一个出色的社区项目旨在使所有这些变得更容易：&lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt;。Nuxt.js是基于Vue生态系统构建的高级框架，该框架为编写通用Vue应用程序提供了极其简化的开发体验。更好的是，您甚至可以将其用作静态站点生成器（页面被编写为单文件Vue组件）！我们强烈建议您尝试一下。</target>
        </trans-unit>
        <trans-unit id="fc7c765b5dbb95f7134159f12c7f78946b944760" translate="yes" xml:space="preserve">
          <source>Properly trigger lifecycle hooks of a component</source>
          <target state="translated">正确触发组件的生命周期钩子。</target>
        </trans-unit>
        <trans-unit id="e9f3056a7ba256cf707e7dce02bf806a8e3e1baf" translate="yes" xml:space="preserve">
          <source>Properties that start with &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; be proxied on the Vue instance because they may conflict with Vue&amp;rsquo;s internal properties and API methods. You will have to access them as &lt;code&gt;vm.$data._property&lt;/code&gt;.</source>
          <target state="translated">与启动性能 &lt;code&gt;_&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 将&lt;strong&gt;不会&lt;/strong&gt;在Vue公司的实例来代理，因为它们可能与Vue公司的内部属性和API方法相冲突。您将必须以 &lt;code&gt;vm.$data._property&lt;/code&gt; 身份访问它们。</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="824b655ece5f935a9f95c151296cb1d2ff2e73ec" translate="yes" xml:space="preserve">
          <source>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a &lt;code&gt;props&lt;/code&gt; option:</source>
          <target state="translated">道具是可以在组件上注册的自定义属性。将值传递给prop属性时，它将成为该组件实例的属性。要将标题传递给博客文章组件，我们可以使用 &lt;code&gt;props&lt;/code&gt; 选项将其包括在该组件接受的道具列表中：</target>
        </trans-unit>
        <trans-unit id="02635ba77eef9661786c01a78d90b7501db1be4e" translate="yes" xml:space="preserve">
          <source>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</source>
          <target state="translated">道具现在总是单向下降。要在父作用域中产生副作用,组件需要显式地发出一个事件,而不是依赖隐式绑定。更多信息,请参见。</target>
        </trans-unit>
        <trans-unit id="f6122d047108de3e0837cf3e23276a8775fc2406" translate="yes" xml:space="preserve">
          <source>Props on a Root Instance &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">根实例上的道具已&lt;sup&gt;替换&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="877adb56a197e1259015de3210d87c2e790b7975" translate="yes" xml:space="preserve">
          <source>Provide an alternative render output when the default &lt;code&gt;render&lt;/code&gt; function encounters an error. The error will be passed to &lt;code&gt;renderError&lt;/code&gt; as the second argument. This is particularly useful when used together with hot-reload.</source>
          <target state="translated">当默认 &lt;code&gt;render&lt;/code&gt; 功能遇到错误时，提供备用渲染输出。该错误将作为第二个参数传递给 &lt;code&gt;renderError&lt;/code&gt; 。与热重装一起使用时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="02efa133aeef7a133aefd2f252af936a5cccad26" translate="yes" xml:space="preserve">
          <source>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</source>
          <target state="translated">为Vue实例提供一个现有的DOM元素来挂载。它可以是一个CSS选择器字符串或一个实际的HTMLElement。</target>
        </trans-unit>
        <trans-unit id="dcf49ab626c30fff5ed5ee4dbe07721b4605c56b" translate="yes" xml:space="preserve">
          <source>Quasar Framework SSR + PWA</source>
          <target state="translated">Quasar Framework SSR+PWA</target>
        </trans-unit>
        <trans-unit id="282e30765bd347047d1a351ac3b6f1cf18becd81" translate="yes" xml:space="preserve">
          <source>Quoted attribute values</source>
          <target state="translated">被引用的属性值</target>
        </trans-unit>
        <trans-unit id="683b9e103293a057ef4362aa5bc974a4f8bd8131" translate="yes" xml:space="preserve">
          <source>Quoted attribute values &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈推荐带&lt;/sup&gt;引号的属性值&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ed1e44a4093ca562205b72061c34f1507e70c015" translate="yes" xml:space="preserve">
          <source>RFC-0001</source>
          <target state="translated">RFC-0001</target>
        </trans-unit>
        <trans-unit id="b11bf19e3f65b4a1ada383e41f26dab5c503940e" translate="yes" xml:space="preserve">
          <source>Radio</source>
          <target state="translated">Radio</target>
        </trans-unit>
        <trans-unit id="76550ff95e4521edf8dc9e8329b78993dc047414" translate="yes" xml:space="preserve">
          <source>Raw HTML</source>
          <target state="translated">原始HTML</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b183e9aafa930f129da2c452cc641903b8199bea" translate="yes" xml:space="preserve">
          <source>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!</source>
          <target state="translated">React Native使您可以使用相同的React组件模型编写适用于iOS和Android的本机渲染应用程序。这样做的好处是，作为开发人员，您可以在多个平台上应用框架知识。在这方面，Vue与&lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;正式合作，Weex是由阿里巴巴集团创建并由Apache软件基金会（ASF）孵化的跨平台UI框架。 Weex允许您使用相同的Vue组件语法来创作组件，这些组件不仅可以在浏览器中呈现，而且可以在iOS和Android上原生呈现！</target>
        </trans-unit>
        <trans-unit id="ee4366331847de86650378c9e4041dac06218df0" translate="yes" xml:space="preserve">
          <source>React and Vue share many similarities. They both:</source>
          <target state="translated">React和Vue有很多相似之处。它们都。</target>
        </trans-unit>
        <trans-unit id="bb65ef679dc307f628a20a0b729cd808d18c5ac0" translate="yes" xml:space="preserve">
          <source>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React&amp;rsquo;s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it&amp;rsquo;s absolutely not suitable for production.</source>
          <target state="translated">React以其陡峭的学习曲线而闻名。在真正开始之前，您需要了解JSX以及ES2015 +，因为许多示例都使用React的类语法。您还必须了解构建系统，因为尽管从技术上讲，您可以使用Babel Standalone在浏览器中实时编译代码，但它绝对不适合生产。</target>
        </trans-unit>
        <trans-unit id="bb1b40c27f9e4939cf3ff484fca2a9371f8d3b42" translate="yes" xml:space="preserve">
          <source>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.</source>
          <target state="translated">类似React的库通常会尽量与React共享其API和生态系统,这是可行的。出于这个原因,上面的绝大多数比较也将适用于它们。主要的区别通常会是与React相比,生态系统减少了,通常是显著减少。由于这些库不可能100%兼容React生态系统中的一切,因此一些工具和配套库可能无法使用。或者说,即使它们看起来可以使用,也可能随时崩溃,除非你的特定React类库得到官方与React同等的支持。</target>
        </trans-unit>
        <trans-unit id="96578d9c2e6eaee240051ff91e83f741cc87e93b" translate="yes" xml:space="preserve">
          <source>Reactivity</source>
          <target state="translated">Reactivity</target>
        </trans-unit>
        <trans-unit id="38be1878e88addc141471e2ac5be059c49256537" translate="yes" xml:space="preserve">
          <source>Reactivity in Depth</source>
          <target state="translated">深度反应性</target>
        </trans-unit>
        <trans-unit id="446d7c237336d575135ddcd7063341761426b025" translate="yes" xml:space="preserve">
          <source>Ready for More?</source>
          <target state="translated">准备好接受更多的挑战了吗?</target>
        </trans-unit>
        <trans-unit id="40fe62216df511ee5c87bc8e026789c819f7b21e" translate="yes" xml:space="preserve">
          <source>Really though, any transition attribute can be dynamically bound. And it&amp;rsquo;s not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.</source>
          <target state="translated">实际上，任何过渡属性都可以动态绑定。这不仅是属性。由于事件挂钩是方法，因此它们可以访问上下文中的任何数据。这意味着，取决于组件的状态，您的JavaScript转换可能会表现不同。</target>
        </trans-unit>
        <trans-unit id="cdb5994a5662a9b7831e2e56b44ea27b6edb5bab" translate="yes" xml:space="preserve">
          <source>Recent versions of Angular, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT compilation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;tree-shaking&lt;/a&gt;, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by &lt;code&gt;angular-cli&lt;/code&gt; (~65KB gzipped).</source>
          <target state="translated">带有&lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT编译&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;摇树功能&lt;/a&gt;的Angular的最新版本已经能够大大减小其尺寸。但是，包含Vuex + Vue Router的功能齐全的Vue 2项目（约30KB压缩）仍然比 &lt;code&gt;angular-cli&lt;/code&gt; 生成的即用型 AOT编译应用程序（约65KB压缩）轻得多。</target>
        </trans-unit>
        <trans-unit id="3f99a56b4630f2ac18091fad78531d1626d4dac4" translate="yes" xml:space="preserve">
          <source>Recommended Configuration</source>
          <target state="translated">推荐配置</target>
        </trans-unit>
        <trans-unit id="f9d18b779732cc0ea4b60f929feea8a7c40df5fc" translate="yes" xml:space="preserve">
          <source>Recreating dynamic components is normally useful behavior, but in this case, we&amp;rsquo;d really like those tab component instances to be cached once they&amp;rsquo;re created for the first time. To solve this problem, we can wrap our dynamic component with a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">重新创建动态组件通常是有用的行为，但是在这种情况下，我们真的希望这些选项卡组件实例在首次创建后就被缓存。为了解决这个问题，我们可以用 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 元素包装动态组件：</target>
        </trans-unit>
        <trans-unit id="25c0556aa6352203342eea1a65c58a623378dbcc" translate="yes" xml:space="preserve">
          <source>Recursive Components</source>
          <target state="translated">递归组件</target>
        </trans-unit>
        <trans-unit id="46819d95829c2f8ee915e7d271f512463387fc11" translate="yes" xml:space="preserve">
          <source>Refactoring becomes more difficult, because find-and-replace often isn&amp;rsquo;t sufficient to update relative references to a moved component.</source>
          <target state="translated">重构变得更加困难，因为查找和替换通常不足以更新对已移动组件的相对引用。</target>
        </trans-unit>
        <trans-unit id="f4234eefb475a2340f218d9e7a7e6c874a82a6fa" translate="yes" xml:space="preserve">
          <source>Refer to the respective build tool documentations to see how it&amp;rsquo;s done:</source>
          <target state="translated">请参阅各自的构建工具文档，以了解其完成方式：</target>
        </trans-unit>
        <trans-unit id="8d8b1f50199fd6cb6ab6141f41a87fd8dae1f00d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global component. Registration also automatically sets the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; with the given &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">注册或检索全局组件。注册还会自动使用给定的 &lt;code&gt;id&lt;/code&gt; 设置组件的 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0168019975e7b996b73bc3be3562ac476872545c" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global directive.</source>
          <target state="translated">注册或检索一个全局指令。</target>
        </trans-unit>
        <trans-unit id="13bd6c258247a18188a7e24270fbc9f007d7c82d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global filter.</source>
          <target state="translated">注册或检索一个全局过滤器。</target>
        </trans-unit>
        <trans-unit id="76de89743a325c94ab024ae33f08812f80d685bb" translate="yes" xml:space="preserve">
          <source>Relation to Custom Elements</source>
          <target state="translated">与自定义元素的关系</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">发行说明</target>
        </trans-unit>
        <trans-unit id="d92abdf653f23351eb7a0ab4d23290ee1313902d" translate="yes" xml:space="preserve">
          <source>Remember that &lt;strong&gt;global registration must take place before the root Vue instance is created (with &lt;code&gt;new Vue&lt;/code&gt;)&lt;/strong&gt;. &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;Here&amp;rsquo;s an example&lt;/a&gt; of this pattern in a real project context.</source>
          <target state="translated">请记住，&lt;strong&gt;全局注册必须在创建根Vue实例（使用 &lt;code&gt;new Vue&lt;/code&gt; ）之前进行&lt;/strong&gt;。&lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;这是&lt;/a&gt;在实际项目环境中这种模式的示例。</target>
        </trans-unit>
        <trans-unit id="73942b04c7d6e9cc0cafd922223a9eab5438c235" translate="yes" xml:space="preserve">
          <source>Remove custom event listener(s).</source>
          <target state="translated">移除自定义事件监听器。</target>
        </trans-unit>
        <trans-unit id="25c548f4a7b9b6ef1cfbffbca926739476b1c4e2" translate="yes" xml:space="preserve">
          <source>Removed due to hooks simplification. If you really must suppress transition errors, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt;&lt;code&gt;try&lt;/code&gt;&amp;hellip;&lt;code&gt;catch&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">由于简化了挂钩，因此已删除。如果确实必须抑制转换错误，则可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt; &lt;code&gt;try&lt;/code&gt; &amp;hellip; &lt;code&gt;catch&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="e7f3ed71f5d7421b91e0c25cc42984adb65b4fdd" translate="yes" xml:space="preserve">
          <source>Renamed to &lt;code&gt;base&lt;/code&gt; for consistency with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;the HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</source>
          <target state="translated">重命名为 &lt;code&gt;base&lt;/code&gt; 以与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 元素&lt;/a&gt;保持一致。</target>
        </trans-unit>
        <trans-unit id="3aa893c2a6ebe75166762d5109366b728fa5dc54" translate="yes" xml:space="preserve">
          <source>Render Functions &amp;amp; JSX</source>
          <target state="translated">渲染功能和JSX</target>
        </trans-unit>
        <trans-unit id="f54e5429aec68f05a2b3b43a85ee9662c29159d7" translate="yes" xml:space="preserve">
          <source>Render Functions - Slots</source>
          <target state="translated">渲染功能-插槽</target>
        </trans-unit>
        <trans-unit id="aeac0239d7806a13c73e4eacbb8e89032112b08f" translate="yes" xml:space="preserve">
          <source>Render functions with JSX have a few advantages:</source>
          <target state="translated">使用JSX的渲染功能有一些优势。</target>
        </trans-unit>
        <trans-unit id="c0f479c7d13498bbd2aa42eae8f88242964120b5" translate="yes" xml:space="preserve">
          <source>Render the element and component &lt;strong&gt;once&lt;/strong&gt; only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</source>
          <target state="translated">仅渲染&lt;strong&gt;一次&lt;/strong&gt;元素和组件。在后续重新渲染时，元素/组件及其所有子元素将被视为静态内容并被跳过。这可以用来优化更新性能。</target>
        </trans-unit>
        <trans-unit id="1c510f643528b3292df74bbcf70195487418102f" translate="yes" xml:space="preserve">
          <source>Render the element or template block multiple times based on the source data. The directive&amp;rsquo;s value must use the special syntax &lt;code&gt;alias in expression&lt;/code&gt; to provide an alias for the current element being iterated on:</source>
          <target state="translated">根据源数据多次渲染元素或模板块。指令的值必须 &lt;code&gt;alias in expression&lt;/code&gt; 使用特殊的语法别名，以为正在迭代的当前元素提供别名：</target>
        </trans-unit>
        <trans-unit id="9647e21c53c63f65c167aa12298837e080c17cb0" translate="yes" xml:space="preserve">
          <source>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains &lt;strong&gt;a lot&lt;/strong&gt; of static content. In these cases, you can ensure that it&amp;rsquo;s only evaluated once and then cached by adding the &lt;code&gt;v-once&lt;/code&gt; directive to the root element, like this:</source>
          <target state="translated">在Vue中，呈现纯HTML元素的速度非常快，但是有时您可能会拥有一个包含&lt;strong&gt;大量&lt;/strong&gt;静态内容的组件。在这些情况下，可以通过将 &lt;code&gt;v-once&lt;/code&gt; 指令添加到根元素来确保仅对它进行一次评估，然后对其进行缓存，如下所示：</target>
        </trans-unit>
        <trans-unit id="9a09ee1cf84326d5d5b1fbbb8dcaca046fb652f2" translate="yes" xml:space="preserve">
          <source>Replacing &lt;code&gt;vm.$data&lt;/code&gt;&lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">替换 &lt;code&gt;vm.$data&lt;/code&gt; &lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6336d2b4c545bfdb0a2c2e6130a2fe522bc117ed" translate="yes" xml:space="preserve">
          <source>Replacing Template Features with Plain JavaScript</source>
          <target state="translated">用普通的JavaScript替换模板功能。</target>
        </trans-unit>
        <trans-unit id="3694e119ff9868c46a5da68ac50107adb0cd0254" translate="yes" xml:space="preserve">
          <source>Replacing an Array</source>
          <target state="translated">替换一个阵列</target>
        </trans-unit>
        <trans-unit id="448ceec811e5cd1612b41b145f75a74425a6d60a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;capitalize&lt;/code&gt; Filter</source>
          <target state="translated">更换大 &lt;code&gt;capitalize&lt;/code&gt; 滤器</target>
        </trans-unit>
        <trans-unit id="8ebc9242fd66a164fb0466c94c267b085022f523" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;currency&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;currency&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="6e8e54f171683ed43699d784bb3a20daa786f68a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;debounce&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;debounce&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="bc05ccbf460e1bee1b220a363cd9b366122fc62c" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;filterBy&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;filterBy&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="5aadbac5cc6d5572fbf9f02300727b922b52477f" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;json&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;json&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="5af22200afbbae6350485e71f8a0930a62620a3b" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;limitBy&lt;/code&gt; Filter</source>
          <target state="translated">通过过滤器替换 &lt;code&gt;limitBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63239b2dfa73a07907b85e48d0e4e3d07aa51efd" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;lowercase&lt;/code&gt; Filter</source>
          <target state="translated">更换小 &lt;code&gt;lowercase&lt;/code&gt; 滤器</target>
        </trans-unit>
        <trans-unit id="307535ec9952915e10873762b9b0a59ea99d17d1" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;orderBy&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;orderBy&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="5a0b57fe75978a4fde52508fa6b11e6a9fcbade8" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;pluralize&lt;/code&gt; Filter</source>
          <target state="translated">更换 &lt;code&gt;pluralize&lt;/code&gt; 过滤器</target>
        </trans-unit>
        <trans-unit id="5895ba028c303252e37b6295f10778b7ca351267" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;uppercase&lt;/code&gt; Filter</source>
          <target state="translated">更换大 &lt;code&gt;uppercase&lt;/code&gt; 滤器</target>
        </trans-unit>
        <trans-unit id="c183ebe6cda4d505c2e49d3160c8367d36be5b90" translate="yes" xml:space="preserve">
          <source>Replacing/Merging with Existing Attributes</source>
          <target state="translated">替换/合并现有的属性。</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="1f5b54bbca313ab53947ed8a4f97b16e01f729d9" translate="yes" xml:space="preserve">
          <source>Reusable Transitions</source>
          <target state="translated">可重复使用的过渡</target>
        </trans-unit>
        <trans-unit id="a48bbafb258bfc790b66aec7d45e0a6a8fa1cd83" translate="yes" xml:space="preserve">
          <source>Reusing Components</source>
          <target state="translated">重复使用组件</target>
        </trans-unit>
        <trans-unit id="b836c4c63ed0b1bed339e82e9c78c2b817e6736c" translate="yes" xml:space="preserve">
          <source>Riot</source>
          <target state="translated">Riot</target>
        </trans-unit>
        <trans-unit id="6e85617241bed85b4dcd2ae064b3025078b134e9" translate="yes" xml:space="preserve">
          <source>Riot 3.0 provides a similar component-based development model (which is called a &amp;ldquo;tag&amp;rdquo; in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:</source>
          <target state="translated">Riot 3.0提供了一个类似的基于组件的开发模型（在Riot中称为&amp;ldquo;标签&amp;rdquo;），具有最小化且设计精美的API。Riot和Vue在设计理念上可能有很多共同点。但是，尽管比Riot重一点，但Vue确实提供了一些重要的优势：</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="8e4ecad6a05d926091d335638bbc9859c1de1f8b" translate="yes" xml:space="preserve">
          <source>Rollup + rollup-plugin-vue</source>
          <target state="translated">滾動+滾動-plugin-vue。</target>
        </trans-unit>
        <trans-unit id="42ec7ccbef29d0422b242b5178f06191bc8484d0" translate="yes" xml:space="preserve">
          <source>Route Definitions</source>
          <target state="translated">航线定义</target>
        </trans-unit>
        <trans-unit id="6e3b967c60ba49b0f518c43998cb2dc91dd2134c" translate="yes" xml:space="preserve">
          <source>Route Hooks</source>
          <target state="translated">路线钩</target>
        </trans-unit>
        <trans-unit id="2b73a7098cbf7da1b1613b48acc5eb7c6f35331c" translate="yes" xml:space="preserve">
          <source>Route Matching</source>
          <target state="translated">路线匹配</target>
        </trans-unit>
        <trans-unit id="18febd25894978ca61139fd68c461cb521819d89" translate="yes" xml:space="preserve">
          <source>Route Options: Misc</source>
          <target state="translated">路线选择。其他</target>
        </trans-unit>
        <trans-unit id="f0865cca790a39153b3f106f9c19244b4f157bd4" translate="yes" xml:space="preserve">
          <source>Route matching now uses &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; under the hood, making it much more flexible than previously.</source>
          <target state="translated">路由匹配现在&lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;在后台&lt;/a&gt;使用了路径到正则表达式，从而使其比以前更加灵活。</target>
        </trans-unit>
        <trans-unit id="32027b0a6491682801317490f82d9b553e764f1b" translate="yes" xml:space="preserve">
          <source>Router Initialization</source>
          <target state="translated">路由器初始化</target>
        </trans-unit>
        <trans-unit id="1b4778ead27c045154fa8a8032dcbf9b6b10e64f" translate="yes" xml:space="preserve">
          <source>Router Options: Modes</source>
          <target state="translated">路由器选项。模式</target>
        </trans-unit>
        <trans-unit id="9add2b84e8289fb0ea9dcb2637e5d5907ca4d748" translate="yes" xml:space="preserve">
          <source>Routes are now defined as an array on a &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt;&lt;code&gt;routes&lt;/code&gt; option&lt;/a&gt; at router instantiation. So these routes for example:</source>
          <target state="translated">现在，在路由器实例化时，将&lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt; &lt;code&gt;routes&lt;/code&gt; &lt;/a&gt;定义为路由选项上的数组。因此，这些路线例如：</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="d670f1115ef0c3c29b2d47e241e7dd62eafb1e11" translate="yes" xml:space="preserve">
          <source>Rule Categories</source>
          <target state="translated">规则类别</target>
        </trans-unit>
        <trans-unit id="91ba54d8bd5025bb2cb3e7a4cd0c0785af90a756" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find &lt;code&gt;keep-alive&lt;/code&gt; attributes.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找 &lt;code&gt;keep-alive&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="6d2ac67778b450ed0b9659002961f8409d707930" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find CSS selectors targeting named slots (e.g. &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt;).</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助&lt;/a&gt;器，以找到针对命名插槽的CSS选择器（例如 &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fb8ef12ba88bdd9ea8d64f474b58bd5f002af15c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find HTML interpolations.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;以查找HTML插值。</target>
        </trans-unit>
        <trans-unit id="e29967481758c6af408495a286989e2f4b3a4403" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find all examples of this hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到此挂钩的所有示例。</target>
        </trans-unit>
        <trans-unit id="131ad91eddecfe4bcd3aa1d2c3dae1e7c9a6d28b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;$dispatch&lt;/code&gt; 和 &lt;code&gt;$broadcast&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="b5547bdef16b43ebf6aa5572275c3effebf29215" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$remove&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以在数组上查找 &lt;code&gt;.$remove&lt;/code&gt; 示例。如果您错过了任何方法，则应该从缺少的方法中看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4d1a3ee9aa64afee960f48bf970646ff2ca1516a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$set&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以在数组上查找 &lt;code&gt;.$set&lt;/code&gt; 示例。如果您错过了任何方法，则应该从缺少的方法中看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f7cf2f519c21c26383d689b999383e7f48c8daeb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.async&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找 &lt;code&gt;Vue.config.async&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="adba4cc2d78c532c252af8489b44bb0c82a60071" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.debug&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;Vue.config.debug&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="842114654af7636636f5d0ca2790f492b054f6ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.delimiters&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;Vue.config.delimiters&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="56d3c94b1fca7d1fecbd0be685fc6a65bfb4e3ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt;. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt; 的示例。此后，帮助程序还将找到HTML插值的实例，以便您可以将它们替换为&amp;ldquo; v-html&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7abfe983d07d10f68fd1a923086c66cfb28e6a0a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.elementDirective&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;以查找 &lt;code&gt;Vue.elementDirective&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="0cbd833dba88270b867f404265f89cd61957dd9e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.partial&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找 &lt;code&gt;Vue.partial&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="2be876bb1c3f71e3306a218289a786bebe66e6ac" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.set&lt;/code&gt; or &lt;code&gt;Vue.delete&lt;/code&gt; on a Vue instance. If you miss any, they'll trigger &lt;strong&gt;console warnings&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以在Vue实例上查找 &lt;code&gt;Vue.set&lt;/code&gt; 或 &lt;code&gt;Vue.delete&lt;/code&gt; 的示例。如果您错过任何机会，它们都会触发&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b9c98c79eef3d7a23f61df5ef62ac7e471ae74fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.transition&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;以查找 &lt;code&gt;Vue.transition&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="3cd48bf0c847ee511a1c8d066fdfbdc6f4f6ffc4" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;replace: false&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;replace: false&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="bc77c164d9ea83ca27d60242ad248d1e7b987f0e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.alias&lt;/code&gt; being called.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找被称为 &lt;code&gt;router.alias&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="7cf69302085bdd68f35cf86d99ec675583acea23" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.go&lt;/code&gt; being used where &lt;code&gt;router.push&lt;/code&gt; should be used instead.</source>
          <target state="translated">运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;在你的代码库找到的例子 &lt;code&gt;router.go&lt;/code&gt; 被用在 &lt;code&gt;router.push&lt;/code&gt; 应改为使用。</target>
        </trans-unit>
        <trans-unit id="e39b23f840933b639f0659fde34e12f635127e7f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.map&lt;/code&gt; being called.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找被称为 &lt;code&gt;router.map&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="b828dfd9e2d7bcae2364000145b56e764e6ebe03" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.on&lt;/code&gt; being called.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找被称为 &lt;code&gt;router.on&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="f9a6975194aa0ce1b5cad1c6626af7c35453fcd0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.redirect&lt;/code&gt; being called.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找被称为 &lt;code&gt;router.redirect&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="cc5f2a33706f0e2d3f4cdbd090a5e649c5b6ae0f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.start&lt;/code&gt; being called.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找名为 &lt;code&gt;router.start&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="f5f2fbe802e2c06eba8dee0a46275f8ee4460bc0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.on&lt;/code&gt;, &lt;code&gt;store.off&lt;/code&gt;, and &lt;code&gt;store.emit&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;store.on&lt;/code&gt; ， &lt;code&gt;store.off&lt;/code&gt; 和 &lt;code&gt;store.emit&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="00ad6c9fe856a5b4567b7a4dab60a0fe45a37f40" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.watch&lt;/code&gt; with a string as the first argument.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找以字符串为第一个参数的 &lt;code&gt;store.watch&lt;/code&gt; 示例。</target>
        </trans-unit>
        <trans-unit id="4f47a47355d74434a753364a679e2f4c9a402ae5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;track-by&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;track-by&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="da0f85cb5aa67bdac2ea466f36918db2fcd36b05" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;v-el&lt;/code&gt; and &lt;code&gt;v-ref&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;v-el&lt;/code&gt; 和 &lt;code&gt;v-ref&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="7aa5783c6df3a82bb69131d32c3850e7f84cfda7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$after&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$after&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="09e7d78d817c1fd2a45c3cf9b9c21a2069c4fd37" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$appendTo&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$appendTo&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d7350cc4e203e91682eee37d60894b3e1314af48" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$before&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找 &lt;code&gt;vm.$before&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c4f878eaed231fe0dbb2225df03cd65dc84e13" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$eval&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$eval&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3f8e856f05355ed8982ce86f4336ff6eacabf3e2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$get&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$get&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bd0dd654ce3404b139a97c6070c1ea80255ce0fd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$interpolate&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$interpolate&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="81bbbda8f1ba1322792aa46e4294439738bc392f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$log&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;vm.$log&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="381f44de62059e317b1f31d7ce9b3541555d602b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$remove&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找 &lt;code&gt;vm.$remove&lt;/code&gt; 示例。如果您错过了任何内容，则会看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b874a37ca4886af9d3b7780e6010cf89d9c7f988" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of arbitrary route properties not scoped under meta.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找不在meta范围内的任意路由属性的示例。</target>
        </trans-unit>
        <trans-unit id="1fa158cea69bdd4c40bd2a48988a099538d4dc5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找已定义指令的示例。该助手将标记所有这些对象，因为在大多数情况下，您可能希望将其重构为组件。</target>
        </trans-unit>
        <trans-unit id="979e6458f784d896c90752c57e560652f6c8525d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters being used inside directives. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找伪指令中使用的过滤器示例。如果您有任何遗漏，还应该看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="801a0e4488b5e174aaaa485bb9fbdd0fb7f5b389" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters used in directives like &lt;code&gt;v-model&lt;/code&gt;. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;v-model&lt;/code&gt; 等指令中使用的过滤器示例。如果您有任何遗漏，还应该看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="83b833ef69efe1e17f7ef29c061f04dea5876bad" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of interpolation used within attributes.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找属性内使用的插值示例。</target>
        </trans-unit>
        <trans-unit id="9bb76b174b8438ba3c0f4ba54b4026ce44dd98ca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of overwriting &lt;code&gt;vm.$data&lt;/code&gt;. If you miss any, &lt;strong&gt;console warnings&lt;/strong&gt; will be emitted.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找覆盖 &lt;code&gt;vm.$data&lt;/code&gt; 示例。如果您错过任何机会，将发出&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8dbff7c8c83dec265171807e5ec5ea40ea988ad1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of style bindings with &lt;code&gt;!important&lt;/code&gt; in objects.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找对象中带有 &lt;code&gt;!important&lt;/code&gt; 的样式绑定示例。</target>
        </trans-unit>
        <trans-unit id="93ebbb2019ca1300c683d3ae1afb72a96650f915" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;$loadingRouteData&lt;/code&gt; meta property.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;$loadingRouteData&lt;/code&gt; 元属性的示例。</target>
        </trans-unit>
        <trans-unit id="52407d926e2b5716bf90f4cb35758896e87892ed" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;.once&lt;/code&gt; and &lt;code&gt;.sync&lt;/code&gt; modifiers.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;.once&lt;/code&gt; 和 &lt;code&gt;.sync&lt;/code&gt; 修饰符的示例。</target>
        </trans-unit>
        <trans-unit id="2c8ce2853d843c2c72201a428aaae4467ceec09d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;abstract: true&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;abstract: true&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="2258f58c39858d2874ac267df312bf5774d76c18" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;activate&lt;/code&gt; hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以找到 &lt;code&gt;activate&lt;/code&gt; 钩子的示例。</target>
        </trans-unit>
        <trans-unit id="0d2dd196d33a6838401706a980c174ba91eb1c6e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;cache: false&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;以查找 &lt;code&gt;cache: false&lt;/code&gt; 示例：false选项。</target>
        </trans-unit>
        <trans-unit id="635b9a1176068b8a0020a01c4f47cb421d064226" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canActivate&lt;/code&gt; hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;canActivate&lt;/code&gt; 挂钩的示例。</target>
        </trans-unit>
        <trans-unit id="1ef7f740384cd3cfdf159ef6085f2faaac1ec88f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canDeactivate&lt;/code&gt; hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;canDeactivate&lt;/code&gt; 挂钩的示例。</target>
        </trans-unit>
        <trans-unit id="416c87ed212eefdaa2ddbf02f6a0ba2e74d86959" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canReuse: false&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;canReuse: false&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="ce44d3b81054ffa59cb49fd62f006c1d791e2ab0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;coerce&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以找到 &lt;code&gt;coerce&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="61fdd38d446cfe928998b1181aa744e45596c1c5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;data&lt;/code&gt; hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;data&lt;/code&gt; 挂钩的示例。</target>
        </trans-unit>
        <trans-unit id="eeb9b18e06a447d16bfa196a854b2eb06f05360a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;deactivate&lt;/code&gt; hook.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;deactivate&lt;/code&gt; 挂钩的示例。</target>
        </trans-unit>
        <trans-unit id="f483517518991a282467c00ae1cad300e136b269" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;debounce&lt;/code&gt; attribute.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;debounce&lt;/code&gt; 属性的示例。</target>
        </trans-unit>
        <trans-unit id="b65067f3a77b357e086f22629678c364185b2ab2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;hashbang: false&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;hashbang: false&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="8a2e5b8abfbc6295fa11dd1caccde1ae7c3d69af" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;history: true&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;history: true&lt;/code&gt; 示例：true选项。</target>
        </trans-unit>
        <trans-unit id="452c89b5559555a477ca0eb92f956476ce00d5cd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;middlewares&lt;/code&gt; option on a store.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以在商店中找到 &lt;code&gt;middlewares&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="6faa58ba44b5eb605740b8397f8693bbaaa6f840" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;root&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;root&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="ab45ded99a30a006bddeceb3fd6aa38bb6c3d9c6" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;saveScrollPosition: true&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;saveScrollPosition: true&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="6ec2df901f80374c6ff66f398825204e5f18d423" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;subRoutes&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;subRoutes&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="7178b2cc5e9e2a36383d9e60b9eea90fb3bcb121" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;suppressTransitionError: true&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;suppressTransitionError: true&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="4e988285e061dd6f2c40c32cddfbc676c1aab12a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;transition&lt;/code&gt; 属性的示例。</target>
        </trans-unit>
        <trans-unit id="c5f2b82da8cac7dc4262de8c7c93d4a46587dbca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;transition&lt;/code&gt; 属性的示例。在更新过程中，您也可以过渡（非常有针对性）到新的交错策略。</target>
        </trans-unit>
        <trans-unit id="34922f45eeac604f53b4193f84913c2beb89b350" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transitionOnLoad: true&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;transitionOnLoad: true&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="c9c97a1b14162dd07775888af56118c3a3370301" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;twoWay&lt;/code&gt; option.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到 &lt;code&gt;twoWay&lt;/code&gt; 选项的示例。</target>
        </trans-unit>
        <trans-unit id="cb3445799897bdc7ce3106b11c9b2c1f1d554568" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-else&lt;/code&gt; with &lt;code&gt;v-show&lt;/code&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以使用 &lt;code&gt;v-show&lt;/code&gt; 查找 &lt;code&gt;v-else&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="bccc02e6c6793423ef659db42169cb5afa5716d0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link-active&lt;/code&gt; directive.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;v-link-active&lt;/code&gt; 指令的示例。</target>
        </trans-unit>
        <trans-unit id="ea921119a7e1635ac4e5a00b3d8a84491101f3fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link&lt;/code&gt; directive.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找 &lt;code&gt;v-link&lt;/code&gt; 指令的示例。</target>
        </trans-unit>
        <trans-unit id="a825bdc145076ec6a6e4b0c215f030aa3ba79b85" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the `.literal` modifier on a directive.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助&lt;/a&gt;器，以在指令上找到`.literal`修饰符的示例。</target>
        </trans-unit>
        <trans-unit id="733bb79e129d2dca49869269db0a3698c6f65fa8" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like &lt;code&gt;position&lt;/code&gt; or &lt;code&gt;num&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找过时的参数顺序的示例。请注意，如果您为索引参数命名时使用诸如 &lt;code&gt;position&lt;/code&gt; 或 &lt;code&gt;num&lt;/code&gt; 之类的异常名称，则助手将不会对其进行标记。</target>
        </trans-unit>
        <trans-unit id="da725380e126a62727af458ad28bac7c6524d798" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;property&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找过时的参数顺序的示例。请注意，如果您将关键参数 &lt;code&gt;name&lt;/code&gt; 或 &lt;code&gt;property&lt;/code&gt; ，则助手将不会对其进行标记。</target>
        </trans-unit>
        <trans-unit id="f1e1035d99ed76f7515df578e692ff719107895a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete route syntax.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找过时的路由语法的示例。</target>
        </trans-unit>
        <trans-unit id="142bb71333ac86e488c9aacc373010de66e961e1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete text filters. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找过时的文本过滤器的示例。如果您有任何遗漏，还应该看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="397d5ab0302428112127147010f4482ef9051b5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete usage.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移助手&lt;/a&gt;，以查找过时用法的示例。</target>
        </trans-unit>
        <trans-unit id="c1aa36c4bb555ce2607bb2d08c4631182d133d50" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the old filter syntax. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找旧过滤器语法的示例。如果您有任何遗漏，还应该看到&lt;strong&gt;控制台错误&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="20564b7f4450c4fa59c4a3ba6fa87121c27fe89f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the the old &lt;code&gt;keyCode&lt;/code&gt; configuration syntax.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找旧的 &lt;code&gt;keyCode&lt;/code&gt; 配置语法的示例。</target>
        </trans-unit>
        <trans-unit id="cc0976e79e68e3874825b8d9309f7bc3cf13503f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the these param attributes.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以找到这些param属性的示例。</target>
        </trans-unit>
        <trans-unit id="4a53e2c9b9e1ccea5753bf6c5b26aa93f8d31041" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of these removed variables. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt; such as: &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;，以查找这些已删除变量的示例。如果错过任何内容，您还应该看到&lt;strong&gt;控制台错误，&lt;/strong&gt;例如： &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0ae781de5086e5c0e4123dc4514d344522a5237" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find one-time bindings.</source>
          <target state="translated">在您的代码库上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;以查找一次性绑定。</target>
        </trans-unit>
        <trans-unit id="2c800955474c5ae66271d1f51e3a706afff6e929" translate="yes" xml:space="preserve">
          <source>Run your bundling command with the actual &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable set to &lt;code&gt;&quot;production&quot;&lt;/code&gt;. This tells &lt;code&gt;vueify&lt;/code&gt; to avoid including hot-reload and development related code.</source>
          <target state="translated">在实际的 &lt;code&gt;NODE_ENV&lt;/code&gt; 环境变量设置为 &lt;code&gt;&quot;production&quot;&lt;/code&gt; 运行捆绑命令。这告诉 &lt;code&gt;vueify&lt;/code&gt; 避免包含热重载和开发相关的代码。</target>
        </trans-unit>
        <trans-unit id="65124f23df07644ee66ed5e04606bd6c7b54318b" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about duplicate slots &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">升级后运行端到端测试套件或应用程序，并查找有关重复插槽 &lt;code&gt;v-model&lt;/code&gt; 的&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0276baa533bc89d334fafab4aee362813fb56fba" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about inline value attributes with &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">升级后运行端到端测试套件或应用程序，并查找有关带有 &lt;code&gt;v-model&lt;/code&gt; 的内联值属性的&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b9168febc3cd9fb510564d5d619d53cfceebc829" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about multiple root elements in a template.</source>
          <target state="translated">升级后运行端到端测试套件或应用程序，并查找有关模板中多个根元素的&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6cd905d20455b18138224bc59c413711a6de22a2" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about prop mutations.</source>
          <target state="translated">升级后运行端到端测试套件或应用程序，并查找有关道具突变的&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7da416f4436591687e3ea5cf9d579fb6711b7dbd" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about the &lt;code&gt;el&lt;/code&gt; option with &lt;code&gt;Vue.extend&lt;/code&gt;.</source>
          <target state="translated">升级后运行端到端测试套件或应用程序，并通过 &lt;code&gt;Vue.extend&lt;/code&gt; 查找有关 &lt;code&gt;el&lt;/code&gt; 选项的&lt;strong&gt;控制台警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="de5aa3b1e8bcd9a2e9b6648cc6da29ebd7c682fa" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">如果有，请运行您的端到端测试套件。在&lt;strong&gt;失败的测试&lt;/strong&gt;应该提醒您注意可能会受到这一更改的影响你的应用程序的任何部分。</target>
        </trans-unit>
        <trans-unit id="25b0475e8303e55dc27cdda9bbd8ef8c1c492011" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that a watcher was relying on the old behavior.</source>
          <target state="translated">如果有，请运行您的端到端测试套件。在&lt;strong&gt;失败的测试&lt;/strong&gt;应提醒你一个事实，即观察者是依靠旧的行为。</target>
        </trans-unit>
        <trans-unit id="3925b4e9140324a46bda954fa3ba6a11551d44d8" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that props passed to root instances are no longer working.</source>
          <target state="translated">如果有，请运行您的端到端测试套件。在&lt;strong&gt;失败的测试&lt;/strong&gt;应提醒你一个事实，即传递到根实例道具不再工作。</target>
        </trans-unit>
        <trans-unit id="c7a107bdb49919e8c77ec76a87618731104be368" translate="yes" xml:space="preserve">
          <source>Run your test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">运行测试套件（如果有）。在&lt;strong&gt;失败的测试&lt;/strong&gt;应该提醒您注意可能会受到这一更改的影响你的应用程序的任何部分。</target>
        </trans-unit>
        <trans-unit id="13285023695c206297d4666f3184c48b775d9ec3" translate="yes" xml:space="preserve">
          <source>Runtime + Compiler vs. Runtime-only</source>
          <target state="translated">运行时+编译器与仅运行时的对比</target>
        </trans-unit>
        <trans-unit id="ce3caf82d6dc4282305777c04d22cb7e32e8739f" translate="yes" xml:space="preserve">
          <source>Runtime Performance</source>
          <target state="translated">运行时性能</target>
        </trans-unit>
        <trans-unit id="0ab3eee80056a96ec147159fe704ef0b8dcd1e74" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#slot-scope&quot;&gt;&lt;code&gt;slot-scope&lt;/code&gt;&lt;/a&gt; except that &lt;code&gt;scope&lt;/code&gt; can only be used on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">与&lt;a href=&quot;#slot-scope&quot;&gt; &lt;code&gt;slot-scope&lt;/code&gt; &lt;/a&gt;相同，除了 &lt;code&gt;scope&lt;/code&gt; 只能用于 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="c41f297530a1a4027d4fe5146dc89421c3603b93" translate="yes" xml:space="preserve">
          <source>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:</source>
          <target state="translated">Sarah Drasner在下面的演示中演示了这一点,使用定时和交互性驱动的状态变化相结合。</target>
        </trans-unit>
        <trans-unit id="a29f0256272e79ca91a1c4e608f09a6264397d12" translate="yes" xml:space="preserve">
          <source>Scale</source>
          <target state="translated">Scale</target>
        </trans-unit>
        <trans-unit id="88011a37856972ada6fede54fa2220927bfb5ac0" translate="yes" xml:space="preserve">
          <source>Scaling Down</source>
          <target state="translated">缩小规模</target>
        </trans-unit>
        <trans-unit id="2d20a53538fb773c0616dc1ef8c4f21c2ceb637d" translate="yes" xml:space="preserve">
          <source>Scaling Up</source>
          <target state="translated">扩大规模</target>
        </trans-unit>
        <trans-unit id="bf1e630e7268556a0635e37341aa31c69f284094" translate="yes" xml:space="preserve">
          <source>Scoped Slots</source>
          <target state="translated">范围老虎机</target>
        </trans-unit>
        <trans-unit id="c891d436871bb971da8c2ff8081958bff3ddb19a" translate="yes" xml:space="preserve">
          <source>Scoped Slots with the &lt;code&gt;slot-scope&lt;/code&gt; Attribute</source>
          <target state="translated">具有 &lt;code&gt;slot-scope&lt;/code&gt; 属性的作用域插槽</target>
        </trans-unit>
        <trans-unit id="6aa971b69d2fe9a8fec7d58fa039f9aafe0f8da1" translate="yes" xml:space="preserve">
          <source>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">现在，保证作用域的插槽函数将返回VNode数组，除非返回值无效，在这种情况下，该函数将返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfa277d957af13fbcf610edac48d6ff9d1d53991" translate="yes" xml:space="preserve">
          <source>Search your codebase for the regex &lt;code&gt;/\w+ in \d+/&lt;/code&gt;. Wherever it appears in a &lt;code&gt;v-for&lt;/code&gt;, check to see if you may be affected.</source>
          <target state="translated">在您的代码库中搜索 &lt;code&gt;/\w+ in \d+/&lt;/code&gt; 的正则表达式/ \ w +。在 &lt;code&gt;v-for&lt;/code&gt; 中出现的任何地方，请检查是否可能受到影响。</target>
        </trans-unit>
        <trans-unit id="0d4f1b3e1926d0de28455af2f7b050061aa08a61" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;this fiddle&lt;/a&gt; for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we&amp;rsquo;d recommend creating a reusable &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">有关完整代码，请参&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;见此小提琴&lt;/a&gt;。但是请注意，如果您发现自己必须在单个组件中进行大量设置和清理，最好的解决方案通常是创建更多的模块化组件。在这种情况下，我们建议创建一个可重用的 &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="04b10db48b879dd4894715118934c8f16e790244" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;this fiddle&lt;/a&gt; for the complete code behind the above demo.</source>
          <target state="translated">有关上述演示背后的完整代码，请参&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;见此提琴&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="030b52b1aecbbfd160c5986ee59275d22c9f7672" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;this fiddle&lt;/a&gt; to experiment with the full code, or &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;this version&lt;/a&gt; for an example binding to a component&amp;rsquo;s options object, instead of its registered name.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;此小提琴&lt;/a&gt;以尝试完整的代码，或查看&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;此版本&lt;/a&gt;以获取绑定到组件的options对象而不是其注册名称的示例。</target>
        </trans-unit>
        <trans-unit id="bc6fd808ffb90ac93f1cb9d312e01c08b9a59bf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript compiler options docs&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript编译器选项文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f4b188488a5cff189e4cfc9d54ff0931435281a" translate="yes" xml:space="preserve">
          <source>See example &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;the plugins docs&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见示例&lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;插件文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7cdc723bd45704f63d3132765b8411da257e1bf" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue-controlled Wall-E&lt;/a&gt; by Sarah Drasner (&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">见笔&lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue公司控制的长城-E&lt;/a&gt;萨拉Drasner（&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;）上&lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="d84be9de2f9e35e379e0e4f6e0bb2340cf1b2d0b" translate="yes" xml:space="preserve">
          <source>Select Options</source>
          <target state="translated">选择选项</target>
        </trans-unit>
        <trans-unit id="33e3b8ff7914aff97145e0add0103e5154bdde21" translate="yes" xml:space="preserve">
          <source>Self-closing components</source>
          <target state="translated">自闭部件</target>
        </trans-unit>
        <trans-unit id="8aa1710830cfa45dfe404022342d5aade64a9767" translate="yes" xml:space="preserve">
          <source>Self-closing components &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈推荐&lt;/sup&gt;自闭合组件&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">服务器端渲染</target>
        </trans-unit>
        <trans-unit id="d986e7075907e08286bd92c14ff694e5215b1ede" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;false&lt;/code&gt; to prevent the production tip on Vue startup.</source>
          <target state="translated">将此设置为 &lt;code&gt;false&lt;/code&gt; 可以防止Vue启动时出现生产提示。</target>
        </trans-unit>
        <trans-unit id="0322b76a288cd27bf5d650f3c073fe32426bc786" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API.</source>
          <target state="translated">将其设置为 &lt;code&gt;true&lt;/code&gt; 可在浏览器devtool性能/时间线面板中启用组件初始化，编译，渲染和补丁性能跟踪。仅在开发模式和支持&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;Performance.mark&lt;/a&gt; API的浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="97f2f59947f62c014c5d7c2a4de9191db27303ae" translate="yes" xml:space="preserve">
          <source>Share (and Build) Your Experience</source>
          <target state="translated">分享(和建立)您的经验</target>
        </trans-unit>
        <trans-unit id="89dd25c3e7bb9f776951ef9ad74e60a7d6dd05bb" translate="yes" xml:space="preserve">
          <source>Shorthands</source>
          <target state="translated">Shorthands</target>
        </trans-unit>
        <trans-unit id="1ae7276e79db945fd551dc9db134399c32bb6984" translate="yes" xml:space="preserve">
          <source>Should either be updated to use an inline expression:</source>
          <target state="translated">应该或者更新为使用内联表达式。</target>
        </trans-unit>
        <trans-unit id="b0a3536bb7788ee14bd41892adba577744a1012d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;$root&lt;/code&gt;, the &lt;code&gt;$parent&lt;/code&gt; property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</source>
          <target state="translated">与 &lt;code&gt;$root&lt;/code&gt; 相似， &lt;code&gt;$parent&lt;/code&gt; 属性可用于从子级访问父实例。作为使用prop传递数据的一种懒惰替代，这可能很诱人。</target>
        </trans-unit>
        <trans-unit id="dadac4906f4bc6e4a81d9058bdcbf1bbcb397f71" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-else&lt;/code&gt;, a &lt;code&gt;v-else-if&lt;/code&gt; element must immediately follow a &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-else-if&lt;/code&gt; element.</source>
          <target state="translated">与 &lt;code&gt;v-else&lt;/code&gt; 相似， &lt;code&gt;v-else-if&lt;/code&gt; 元素必须紧随 &lt;code&gt;v-if&lt;/code&gt; 或 &lt;code&gt;v-else-if&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="af9b7b6d2657eb7de92b424e723e1ce34e27dd45" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-on&lt;/code&gt; and &lt;code&gt;v-bind&lt;/code&gt;, &lt;code&gt;v-slot&lt;/code&gt; also has a shorthand, replacing everything before the argument (&lt;code&gt;v-slot:&lt;/code&gt;) with the special symbol &lt;code&gt;#&lt;/code&gt;. For example, &lt;code&gt;v-slot:header&lt;/code&gt; can be rewritten as &lt;code&gt;#header&lt;/code&gt;:</source>
          <target state="translated">与 &lt;code&gt;v-on&lt;/code&gt; 和 &lt;code&gt;v-bind&lt;/code&gt; 相似， &lt;code&gt;v-slot&lt;/code&gt; 也有一个简写形式，用特殊符号 &lt;code&gt;#&lt;/code&gt; 替换参数（ &lt;code&gt;v-slot:&lt;/code&gt; ：）之前的所有内容。例如， &lt;code&gt;v-slot:header&lt;/code&gt; 可以重写为 &lt;code&gt;#header&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="110921f9f16f79ec9020d42a774f85de76c9358e" translate="yes" xml:space="preserve">
          <source>Similar to prop defaults, you need to use a factory function for non primitive values:</source>
          <target state="translated">与道具默认值类似,你需要为非基元值使用工厂函数。</target>
        </trans-unit>
        <trans-unit id="3115d0b13d887f54dba012634384e7c25cfdf659" translate="yes" xml:space="preserve">
          <source>Similar to template &lt;code&gt;v-if&lt;/code&gt;, you can also use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag with &lt;code&gt;v-for&lt;/code&gt; to render a block of multiple elements. For example:</source>
          <target state="translated">与模板 &lt;code&gt;v-if&lt;/code&gt; 相似，您也可以将 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 标记与 &lt;code&gt;v-for&lt;/code&gt; 一起使用以呈现多个元素的块。例如：</target>
        </trans-unit>
        <trans-unit id="9032b6dd131e5bdf77e7f1e8c9ad6ef9e98b4db4" translate="yes" xml:space="preserve">
          <source>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</source>
          <target state="translated">同样,你可以使用动态参数将处理程序绑定到动态事件名上。</target>
        </trans-unit>
        <trans-unit id="e756f11c70f78a0ba1866d4795579c59fa6d1833" translate="yes" xml:space="preserve">
          <source>Simple Assertions</source>
          <target state="translated">简单断言</target>
        </trans-unit>
        <trans-unit id="bbba1d068bf49ca0e64f1e344f51043367c2266d" translate="yes" xml:space="preserve">
          <source>Simple Routing From Scratch</source>
          <target state="translated">从零开始的简单路由</target>
        </trans-unit>
        <trans-unit id="4e794aae53f27e868a697d7573dd5ec04e937e2a" translate="yes" xml:space="preserve">
          <source>Simple State Management from Scratch</source>
          <target state="translated">从零开始的简单状态管理</target>
        </trans-unit>
        <trans-unit id="7a423acd4331de7d207764fc94ba09543c17ef88" translate="yes" xml:space="preserve">
          <source>Simple computed properties</source>
          <target state="translated">简单的计算属性</target>
        </trans-unit>
        <trans-unit id="28fbbfbd1e3c5e7641094f470de044776bb5ad02" translate="yes" xml:space="preserve">
          <source>Simple computed properties &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;简单的计算属性&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="37761f78a8d655b3953b071e198e22dcd5a02587" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates</source>
          <target state="translated">模板中的简单表达式</target>
        </trans-unit>
        <trans-unit id="fcf7b67ac329ddfb22fdf3fbec785727bf9bf466" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;模板中的简单表达式&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="211d49f995dbe282f57faa15874e031ac53eeff7" translate="yes" xml:space="preserve">
          <source>Simpler, well-named computed properties are:</source>
          <target state="translated">更简单的、命名明确的计算属性有:</target>
        </trans-unit>
        <trans-unit id="63a2bccabf19824dace120aef2460e5986003d8a" translate="yes" xml:space="preserve">
          <source>Simplifying computed properties forces you to give each value a descriptive name, even if it&amp;rsquo;s not reused. This makes it much easier for other developers (and future you) to focus in on the code they care about and figure out what&amp;rsquo;s going on.</source>
          <target state="translated">简化计算属性会迫使您为每个值指定一个描述性名称，即使该名称未重复使用也是如此。这使其他开发人员（和您将来的开发人员）更容易专注于他们关心的代码并弄清楚发生了什么。</target>
        </trans-unit>
        <trans-unit id="5fd1e98b263d4df6091312537a5b1fb83da16e24" translate="yes" xml:space="preserve">
          <source>Simply download and include with a script tag. &lt;code&gt;Vue&lt;/code&gt; will be registered as a global variable.</source>
          <target state="translated">只需下载并包含脚本标签即可。 &lt;code&gt;Vue&lt;/code&gt; 将被注册为全局变量。</target>
        </trans-unit>
        <trans-unit id="d5938f34f8624b63802c3118f180d5e293766247" translate="yes" xml:space="preserve">
          <source>Simultaneous entering and leaving transitions aren&amp;rsquo;t always desirable though, so Vue offers some alternative &lt;strong&gt;transition modes&lt;/strong&gt;:</source>
          <target state="translated">虽然并不总是需要同时进入和离开过渡，所以Vue提供了一些替代&lt;strong&gt;过渡模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="6a69d78f54bcf8ac6e1f4a3963e04cee33a026d0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;$nextTick()&lt;/code&gt; returns a promise, you can achieve the same as the above using the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 async/await&lt;/a&gt; syntax:</source>
          <target state="translated">由于 &lt;code&gt;$nextTick()&lt;/code&gt; 返回一个promise，因此可以使用新的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 async / await&lt;/a&gt;语法实现与上述相同的效果：</target>
        </trans-unit>
        <trans-unit id="10a777de149e5a77b75501c009eb466a9bc93514" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v-ref&lt;/code&gt; is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with &lt;code&gt;v-for&lt;/code&gt;. For example:</source>
          <target state="translated">由于 &lt;code&gt;v-ref&lt;/code&gt; 不再是指令，而是特殊属性，因此也可以动态定义它。与 &lt;code&gt;v-for&lt;/code&gt; 结合使用时特别有用。例如：</target>
        </trans-unit>
        <trans-unit id="9de3c1e0a71e1edcdc7ffbc2b45060ebfe43b095" translate="yes" xml:space="preserve">
          <source>Since Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;performs DOM updates asynchronously&lt;/a&gt;, assertions on DOM updates resulting from state change will have to be made in a &lt;code&gt;Vue.nextTick&lt;/code&gt; callback:</source>
          <target state="translated">由于Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;异步执行DOM更新&lt;/a&gt;，因此必须在 &lt;code&gt;Vue.nextTick&lt;/code&gt; 回调中对因状态更改而导致的DOM更新进行断言：</target>
        </trans-unit>
        <trans-unit id="a6f5eaf2601394efec9f1b3f5eff696573b84807" translate="yes" xml:space="preserve">
          <source>Since Vue doesn&amp;rsquo;t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</source>
          <target state="translated">由于Vue不允许动态添加根级反应性属性，因此您必须通过预先声明所有根级反应性数据属性（即使值为空）来初始化Vue实例：</target>
        </trans-unit>
        <trans-unit id="17a485dec90726f134aafab30671454807556666" translate="yes" xml:space="preserve">
          <source>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. &lt;code&gt;MyButton&lt;/code&gt;, &lt;code&gt;VueButton&lt;/code&gt;).</source>
          <target state="translated">由于组件名称应始终为多字，因此此约定使您不必为简单的组件包装程序（例如 &lt;code&gt;MyButton&lt;/code&gt; ， &lt;code&gt;VueButton&lt;/code&gt; ）选择任意前缀。</target>
        </trans-unit>
        <trans-unit id="ba2168060abb1674449c97121137c7602377ef42" translate="yes" xml:space="preserve">
          <source>Since components are reusable Vue instances, they accept the same options as &lt;code&gt;new Vue&lt;/code&gt;, such as &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, and lifecycle hooks. The only exceptions are a few root-specific options like &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">由于组件是可重用的Vue实例，因此它们接受与 &lt;code&gt;new Vue&lt;/code&gt; 相同的选项，例如 &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;computed&lt;/code&gt; ， &lt;code&gt;watch&lt;/code&gt; ， &lt;code&gt;methods&lt;/code&gt; 和生命周期挂钩。唯一的例外是一些特定于root的选项，例如 &lt;code&gt;el&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b68173db2c99b86c3a75462f226a7b75ff0f1d5" translate="yes" xml:space="preserve">
          <source>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</source>
          <target state="translated">由于编辑器通常按字母顺序组织文件,现在所有组件之间的重要关系都一目了然。</target>
        </trans-unit>
        <trans-unit id="ef79f75d79e817472bd0ed5aad52845e59dbf2e4" translate="yes" xml:space="preserve">
          <source>Since functional components are just functions, they&amp;rsquo;re much cheaper to render.</source>
          <target state="translated">由于功能组件只是功能，因此渲染起来便宜得多。</target>
        </trans-unit>
        <trans-unit id="5ca066badcd55a6324af0033eddd42706cb8d9c3" translate="yes" xml:space="preserve">
          <source>Since it&amp;rsquo;s a generic mechanism for Vue to identify nodes, the &lt;code&gt;key&lt;/code&gt; also has other uses that are not specifically tied to &lt;code&gt;v-for&lt;/code&gt;, as we will see later in the guide.</source>
          <target state="translated">由于这是Vue识别节点的通用机制，因此该 &lt;code&gt;key&lt;/code&gt; 还具有其他用途，这些用途并不专门与 &lt;code&gt;v-for&lt;/code&gt; 绑定，我们将在本指南的后面部分看到。</target>
        </trans-unit>
        <trans-unit id="c460325ca52e3630249720f5552ae7b020e4765a" translate="yes" xml:space="preserve">
          <source>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</source>
          <target state="translated">由于仅运行时的构建体比完整构建体轻了大约 30%,所以你应该尽可能地使用它。如果你仍然希望使用完整构建,你需要在你的捆绑程序中配置一个别名。</target>
        </trans-unit>
        <trans-unit id="e62e1d6e39e14f551529b609a48c6fb619bb1df6" translate="yes" xml:space="preserve">
          <source>Since these are &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;published on NPM&lt;/a&gt;, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don&amp;rsquo;t need any additional tooling to use TypeScript with Vue.</source>
          <target state="translated">由于这些文件&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;在NPM&lt;/a&gt;上发布，并且最新的TypeScript知道如何解析NPM软件包中的类型声明，因此，通过NPM安装时，不需要任何其他工具即可将TypeScript与Vue一起使用。</target>
        </trans-unit>
        <trans-unit id="4ea3d2ff946bc5b79835d964012d367a993b9ca6" translate="yes" xml:space="preserve">
          <source>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</source>
          <target state="translated">由于这些组件的使用频率很高,你可能想简单地将它们做成全局的,而不是到处导入。在Webpack中,一个前缀使这成为可能。</target>
        </trans-unit>
        <trans-unit id="796906cd98540356e295c43d625d24ed68862aac" translate="yes" xml:space="preserve">
          <source>Since we&amp;rsquo;re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</source>
          <target state="translated">由于我们不再使用需要返回值的过滤器选项，因此我们的货币工作实际上可以异步完成。这意味着，如果我们有很多必须使用货币的应用程序，我们可以轻松地将此逻辑重构为共享的微服务。</target>
        </trans-unit>
        <trans-unit id="a31aa77b805847e93b5d67d3ae054b43de8ddfb3" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</source>
          <target state="translated">由于您不必在JS中手动附加事件侦听器，因此您的ViewModel代码可以是纯逻辑且无DOM。这使测试更加容易。</target>
        </trans-unit>
        <trans-unit id="59debd2931aa770a2b0975329d41213dcd9c5d88" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; to learn enough to build non-trivial applications.</source>
          <target state="translated">由于您无需了解JSX，ES2015或构建系统即可开始使用Vue，因此开发人员通常也可以花不到一天的时间阅读&lt;a href=&quot;../index&quot;&gt;该指南，&lt;/a&gt;以学习足够的知识来构建非平凡的应用程序。</target>
        </trans-unit>
        <trans-unit id="4a6e205b866dd29d282ce270191d3645216b482d" translate="yes" xml:space="preserve">
          <source>Single File Components</source>
          <target state="translated">单一文件组件</target>
        </trans-unit>
        <trans-unit id="5e7f1d7d63552994a465b38c32202f3620abe335" translate="yes" xml:space="preserve">
          <source>Single checkbox, boolean value:</source>
          <target state="translated">单个复选框,布林值。</target>
        </trans-unit>
        <trans-unit id="040f06c8b02b9ecd8ce3bcc463d52f44ab71de30" translate="yes" xml:space="preserve">
          <source>Single select:</source>
          <target state="translated">单选。</target>
        </trans-unit>
        <trans-unit id="95ef58f9b3d77202b180ce829f19b7953db91e4d" translate="yes" xml:space="preserve">
          <source>Single-file (&lt;code&gt;.vue&lt;/code&gt;) components</source>
          <target state="translated">单文件（ &lt;code&gt;.vue&lt;/code&gt; ）组件</target>
        </trans-unit>
        <trans-unit id="a0fcc7019dc5bbeb59c13b0247440b91dff10e8e" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing</source>
          <target state="translated">单文件组件文件名套管</target>
        </trans-unit>
        <trans-unit id="093c716d53dd968ee64e9ba688e8285861d21500" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;单文件组件的文件名大小写&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="aad2c1946beed7073bd3f80b10b836af1bd801c0" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order</source>
          <target state="translated">单文件组件顶层元素顺序</target>
        </trans-unit>
        <trans-unit id="369e619c0ac6b0e41c0c5e5672725a1dad22811c" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">单文件组件顶级元素的顺序&lt;sup&gt;推荐&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e5ab16f7ba44150cac61508afe92cbd1d1dd294b" translate="yes" xml:space="preserve">
          <source>Single-instance component names</source>
          <target state="translated">单体组件名称</target>
        </trans-unit>
        <trans-unit id="801a9b431b0affdfa69d3dd93084d1b29dae9cb0" translate="yes" xml:space="preserve">
          <source>Single-instance component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议&lt;/sup&gt;单实例组件名称&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="896ccfe8515d070b5a15610d907daecc5196a888" translate="yes" xml:space="preserve">
          <source>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</source>
          <target state="translated">跳过对该元素及其所有子元素的编译。你可以用它来显示原始的胡子标签。跳过大量没有指令的节点也可以加快编译速度。</target>
        </trans-unit>
        <trans-unit id="083d20797ac518ecfd2d5802f11e56f053d9b2a3" translate="yes" xml:space="preserve">
          <source>Slot Content</source>
          <target state="translated">老虎机内容</target>
        </trans-unit>
        <trans-unit id="0c1a16e17517d5db584e59f03e5701a1df0aec29" translate="yes" xml:space="preserve">
          <source>Slots</source>
          <target state="translated">Slots</target>
        </trans-unit>
        <trans-unit id="0c05d5215c9958f423cfa89492ade3561c496be1" translate="yes" xml:space="preserve">
          <source>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</source>
          <target state="translated">小型的、集中的计算属性对信息的使用方式做了较少的假设,因此随着需求的变化,需要重构的程度较低。</target>
        </trans-unit>
        <trans-unit id="270782c16d7dfcd9bacc30c93f3205da13a192a6" translate="yes" xml:space="preserve">
          <source>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</source>
          <target state="translated">因此,即使我们只渲染一小部分用户的元素,我们每次重新渲染时都要对整个列表进行迭代,不管活跃用户的集合是否发生了变化。</target>
        </trans-unit>
        <trans-unit id="9efa5f0263f4584699ee25a6ef7cd96b38af2cbd" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</source>
          <target state="translated">到目前为止，我们仅绑定到模板中的简单属性键。但是Vue.js实际上支持所有数据绑定中JavaScript表达式的全部功能：</target>
        </trans-unit>
        <trans-unit id="fc43cc8fe805d607917adfb57b267a4c1e366e21" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve managed transitions for:</source>
          <target state="translated">到目前为止，我们已经管理了以下方面的过渡：</target>
        </trans-unit>
        <trans-unit id="9990ce27d68bc258ecfe618b1e117aba2e010d2d" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only created components using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">到目前为止，我们仅使用 &lt;code&gt;Vue.component&lt;/code&gt; 创建了组件：</target>
        </trans-unit>
        <trans-unit id="67796fb098e807812b451996ffa7c37901a92525" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only seen props listed as an array of strings:</source>
          <target state="translated">到目前为止，我们只看到道具以字符串数组的形式列出：</target>
        </trans-unit>
        <trans-unit id="bcb7e6dc22797e50c31c81c6ca57f0d64cd4b40a" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen props passed a static value, like in:</source>
          <target state="translated">到目前为止，您已经看到道具传递了一个静态值，例如：</target>
        </trans-unit>
        <trans-unit id="bf5ea7f867584dc6f766ba242591c6f576f49d80" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen uses of &lt;code&gt;$emit&lt;/code&gt;, listened to with &lt;code&gt;v-on&lt;/code&gt;, but Vue instances also offer other methods in its events interface. We can:</source>
          <target state="translated">到目前为止，您已经看到 &lt;code&gt;$emit&lt;/code&gt; 用法，通过 &lt;code&gt;v-on&lt;/code&gt; 进行了监听，但是Vue实例在其事件接口中还提供了其他方法。我们可以：</target>
        </trans-unit>
        <trans-unit id="8d84a44b86d81a516326f9813e2b3977e997a457" translate="yes" xml:space="preserve">
          <source>So this might be a good time to refactor the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to accept a single &lt;code&gt;post&lt;/code&gt; prop instead:</source>
          <target state="translated">因此，这可能是重构 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 组件以接受单个 &lt;code&gt;post&lt;/code&gt; 道具的好时机：</target>
        </trans-unit>
        <trans-unit id="d6aa2762b60d0919d3cc5d125c99532a28d73b78" translate="yes" xml:space="preserve">
          <source>So what about for when we have a whole list of items we want to render simultaneously, for example with &lt;code&gt;v-for&lt;/code&gt;? In this case, we&amp;rsquo;ll use the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component. Before we dive into an example though, there are a few things that are important to know about this component:</source>
          <target state="translated">那么，当我们拥有要同时渲染的全部项目列表时（例如使用 &lt;code&gt;v-for&lt;/code&gt; ),该怎么办？在这种情况下，我们将使用 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 组件。在进入示例之前，需要了解一些有关此组件的重要信息：</target>
        </trans-unit>
        <trans-unit id="147f6354f521a67959c12f2f8261d77ce2bb9c39" translate="yes" xml:space="preserve">
          <source>Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="translated">某些HTML元素（例如 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; )对其中可以显示哪些元素有限制，而某些元素（例如 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; )只能出现在某些其他元素内。</target>
        </trans-unit>
        <trans-unit id="9c0790e8dcd7f3a0c69aa32f511de55c1f1ea0e6" translate="yes" xml:space="preserve">
          <source>Some advantages of this convention:</source>
          <target state="translated">这一惯例的一些优点。</target>
        </trans-unit>
        <trans-unit id="2108424fbba417074fadf0d75a3e1edc693ebce6" translate="yes" xml:space="preserve">
          <source>Some argue that you&amp;rsquo;d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn&amp;rsquo;t mean the user doesn&amp;rsquo;t need to learn anything - it&amp;rsquo;s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it&amp;rsquo;s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. &lt;code&gt;v-on&lt;/code&gt; modifiers). The same task can involve a lot more code when using plain JSX or render functions.</source>
          <target state="translated">有人认为您需要学习一种额外的DSL（特定于域的语言）才能编写模板-我们认为这种区别充其量只是表面上的。首先，JSX并不意味着用户不需要学习任何东西-它是普通JavaScript之上的附加语法，因此熟悉JavaScript的人可以很容易地学习，但是说它本质上是免费的具有误导性。同样，模板只是普通HTML之上的附加语法，因此对于那些已经熟悉HTML的人来说，学习成本非常低。使用DSL，我们还可以帮助用户以更少的代码完成更多工作（例如 &lt;code&gt;v-on&lt;/code&gt; 修饰符）。使用纯JSX或渲染函数时，同一任务可能涉及更多代码。</target>
        </trans-unit>
        <trans-unit id="a9ef7770ac385e4eae53d066a2f3c10a8b6c4ab6" translate="yes" xml:space="preserve">
          <source>Some directives can take an &amp;ldquo;argument&amp;rdquo;, denoted by a colon after the directive name. For example, the &lt;code&gt;v-bind&lt;/code&gt; directive is used to reactively update an HTML attribute:</source>
          <target state="translated">某些指令可以带有一个&amp;ldquo;参数&amp;rdquo;，在指令名称后用冒号表示。例如， &lt;code&gt;v-bind&lt;/code&gt; 指令用于反应性地更新HTML属性：</target>
        </trans-unit>
        <trans-unit id="09428a807ec781f76bc254d725a9a4e0a2df7f8b" translate="yes" xml:space="preserve">
          <source>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of &lt;code&gt;new Function()&lt;/code&gt; for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</source>
          <target state="translated">某些环境（例如Google Chrome Apps）强制执行内容安全政策（CSP），该政策禁止使用 &lt;code&gt;new Function()&lt;/code&gt; 来评估表达式。完整版本取决于此功能来编译模板，因此在这些环境中不可用。</target>
        </trans-unit>
        <trans-unit id="5a2e23d7e711dac515b3913d004594ddb71e0888" translate="yes" xml:space="preserve">
          <source>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</source>
          <target state="translated">Vue 的一些功能是为了适应罕见的边缘情况或更平滑地从旧代码库迁移而存在的。然而,当过度使用时,它们会使您的代码更难维护,甚至成为错误的来源。这些规则揭示了潜在的风险特性,描述了什么时候以及为什么应该避免使用它们。</target>
        </trans-unit>
        <trans-unit id="d10fd1239637017ec222f508352aa84bee00680a" translate="yes" xml:space="preserve">
          <source>Some of Vue&amp;rsquo;s syntax will look very similar to AngularJS (e.g. &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt;). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.</source>
          <target state="translated">Vue的某些语法看起来与AngularJS非常相似（例如 &lt;code&gt;v-if&lt;/code&gt; 与 &lt;code&gt;ng-if&lt;/code&gt; ）。这是因为AngularJS在很多方面都做对了，这些都是Vue早期开发的灵感。但是，AngularJS也有很多麻烦，Vue试图在其中进行重大改进。</target>
        </trans-unit>
        <trans-unit id="ba632b521cfadde631ed92ffd03194fe0b0a9806" translate="yes" xml:space="preserve">
          <source>Some of the current hooks have different behavior and there are also a couple new hooks.</source>
          <target state="translated">目前的一些钩子有不同的行为,也有一些新的钩子。</target>
        </trans-unit>
        <trans-unit id="823d42c9ef6472009b44bd254d2588f2ed0ae4c8" translate="yes" xml:space="preserve">
          <source>Some of the most notable differences include:</source>
          <target state="translated">一些最显著的区别包括:</target>
        </trans-unit>
        <trans-unit id="85976567c84aab5c4b5906f9117b4275cd11d741" translate="yes" xml:space="preserve">
          <source>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.</source>
          <target state="translated">由于React 16+最近的更新,下面的一些部分也可能略显过时,我们正计划与React社区合作,在不久的将来对这个部分进行改造。</target>
        </trans-unit>
        <trans-unit id="e66b9d4602dcda92a8811e8379102ad854fa4037" translate="yes" xml:space="preserve">
          <source>Some plugins provided by Vue.js official plugins such as &lt;code&gt;vue-router&lt;/code&gt; automatically calls &lt;code&gt;Vue.use()&lt;/code&gt; if &lt;code&gt;Vue&lt;/code&gt; is available as a global variable. However in a module environment such as CommonJS, you always need to call &lt;code&gt;Vue.use()&lt;/code&gt; explicitly:</source>
          <target state="translated">如果 &lt;code&gt;Vue&lt;/code&gt; 可用作全局变量，则Vue.js官方插件提供的某些插件（例如 &lt;code&gt;vue-router&lt;/code&gt; )会自动调用 &lt;code&gt;Vue.use()&lt;/code&gt; 。但是，在诸如CommonJS之类的模块环境中，您始终需要显式调用 &lt;code&gt;Vue.use()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9fe62eac7aa92f9e248fd4f6cf8a8c9817319b5d" translate="yes" xml:space="preserve">
          <source>Some users have enjoyed using two-way filters with &lt;code&gt;v-model&lt;/code&gt; to create interesting inputs with very little code. While &lt;em&gt;seemingly&lt;/em&gt; simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</source>
          <target state="translated">一些用户喜欢使用带有 &lt;code&gt;v-model&lt;/code&gt; 的双向滤波器来创建很少的代码即可产生有趣的输入。然而，尽管&lt;em&gt;看似&lt;/em&gt;简单，但是双向滤波器也可以隐藏很多复杂性-甚至通过延迟状态更新来鼓励不良的UX。相反，建议使用包装输入的组件作为创建自定义输入的更明确和功能更丰富的方式。</target>
        </trans-unit>
        <trans-unit id="a20659b05e332a0ae32621debfebacc5d1ababa5" translate="yes" xml:space="preserve">
          <source>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</source>
          <target state="translated">有时这很好用,比如当过渡项目绝对定位在彼此之上时。</target>
        </trans-unit>
        <trans-unit id="f26fd8bf6b50010b5da928fa27ec1a70c263cd9c" translate="yes" xml:space="preserve">
          <source>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special &lt;code&gt;$event&lt;/code&gt; variable:</source>
          <target state="translated">有时我们还需要在内联语句处理程序中访问原始DOM事件。您可以使用特殊的 &lt;code&gt;$event&lt;/code&gt; 变量将其传递给方法：</target>
        </trans-unit>
        <trans-unit id="a58007ff3d542a5e64e8ab0473747490736edba5" translate="yes" xml:space="preserve">
          <source>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</source>
          <target state="translated">有时我们想显示一个数组的过滤或排序版本,而不实际突变或重置原始数据。在这种情况下,你可以创建一个计算属性来返回经过过滤或排序的数组。</target>
        </trans-unit>
        <trans-unit id="bb4776e0f84b8cab0978edcc2a16ccf37eb32d43" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of new properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. In such cases, you should create a fresh object with properties from both objects. So instead of:</source>
          <target state="translated">有时您可能想为现有对象分配许多新属性，例如使用 &lt;code&gt;Object.assign()&lt;/code&gt; 或 &lt;code&gt;_.extend()&lt;/code&gt; 。在这种情况下，您应该使用两个对象的属性创建一个新鲜的对象。所以代替：</target>
        </trans-unit>
        <trans-unit id="4216179a7f142347ead5e8b4c8a44ddd1938267a" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</source>
          <target state="translated">有时，您可能想为现有对象分配许多属性，例如使用 &lt;code&gt;Object.assign()&lt;/code&gt; 或 &lt;code&gt;_.extend()&lt;/code&gt; 。但是，添加到对象的新属性不会触发更改。在这种情况下，请使用原始对象和mixin对象的属性创建一个新鲜的对象：</target>
        </trans-unit>
        <trans-unit id="4a3e5c479936fa0c0c3ae63c92af5bdeccbe0976" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful for slot content to have access to data only available in the child component. For example, imagine a &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">有时，对于插槽内容访问仅在子组件中可用的数据很有用。例如，想象一个具有以下模板的 &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="d2dd5e9a7fd5d98bf25e0a4d4fb18f9f4c3db2f1" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to dynamically switch between components, like in a tabbed interface:</source>
          <target state="translated">有时，在选项卡式界面中动态切换组件非常有用：</target>
        </trans-unit>
        <trans-unit id="878866be830f3d4c0492c7b15ce7d3313f921fc8" translate="yes" xml:space="preserve">
          <source>Soup &lt;em&gt;of the&lt;/em&gt; day</source>
          <target state="translated">汤&lt;em&gt;中的&lt;/em&gt;一天</target>
        </trans-unit>
        <trans-unit id="9898b37c34a88e00f23e82b5e3dc9a1701903a0c" translate="yes" xml:space="preserve">
          <source>Special Attributes</source>
          <target state="translated">特殊属性</target>
        </trans-unit>
        <trans-unit id="c1844df643c3c6b29d9ebd395e5456144c913b68" translate="yes" xml:space="preserve">
          <source>Special Attributes - ref</source>
          <target state="translated">特殊属性----参考</target>
        </trans-unit>
        <trans-unit id="7f375124a7e84608fdea56b183bf085ef84dd0dd" translate="yes" xml:space="preserve">
          <source>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</source>
          <target state="translated">为该道具指定一个默认值。如果没有传递该道具,将使用该值。对象或数组的默认值必须由工厂函数返回。</target>
        </trans-unit>
        <trans-unit id="3d419b352796d39146919ef5966306201da0baac" translate="yes" xml:space="preserve">
          <source>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as &lt;code&gt;this.$parent&lt;/code&gt; for the child, and the child will be pushed into the parent&amp;rsquo;s &lt;code&gt;$children&lt;/code&gt; array.</source>
          <target state="translated">为要创建的实例指定父实例。在两者之间建立父子关系。父级将以孩子的 &lt;code&gt;this.$parent&lt;/code&gt; 形式访问，并且子级将被推入父级的 &lt;code&gt;$children&lt;/code&gt; 数组中。</target>
        </trans-unit>
        <trans-unit id="e4de7be6dcaca74a1df3b6f74eed72c7caf49130" translate="yes" xml:space="preserve">
          <source>Staggering List Transitions</source>
          <target state="translated">交错式列表转换</target>
        </trans-unit>
        <trans-unit id="5ba91e4b27bd154b6feecd545db4023c8e7c12d0" translate="yes" xml:space="preserve">
          <source>Start by running the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on a current project. We&amp;rsquo;ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they&amp;rsquo;ll let you know, offer suggestions, and provide links to more info.</source>
          <target state="translated">首先在当前项目上运行&lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;迁移帮助器&lt;/a&gt;。我们已经精心压缩了小型Vue开发人员并将其压缩到一个简单的命令行界面中。每当他们发现过时的功能时，就会通知您，提供建议并提供指向更多信息的链接。</target>
        </trans-unit>
        <trans-unit id="5fcf8af955dfbcfec984375c6e8f6a528e65233d" translate="yes" xml:space="preserve">
          <source>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="translated">从2.3.0+开始,你可以为一个样式属性提供一个包含多个(前缀)值的数组,例如。</target>
        </trans-unit>
        <trans-unit id="9ba53e05f135de31a97be4f79621e7c2bfae116b" translate="yes" xml:space="preserve">
          <source>Starting in 2.4.0+, &lt;code&gt;v-on&lt;/code&gt; also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</source>
          <target state="translated">从2.4.0+开始， &lt;code&gt;v-on&lt;/code&gt; 还支持绑定到没有参数的事件/侦听器对对象。请注意，使用对象语法时，它不支持任何修饰符。</target>
        </trans-unit>
        <trans-unit id="9b9230ebf8a27183774b5eb88b79650092ee23d2" translate="yes" xml:space="preserve">
          <source>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="translated">从2.6.0版本开始,也可以在指令参数中使用JavaScript表达式,用方括号包装。</target>
        </trans-unit>
        <trans-unit id="bfa146787ba4b5ec0af7e28c9b9db98dcdf2cd1c" translate="yes" xml:space="preserve">
          <source>State Management</source>
          <target state="translated">国家管理</target>
        </trans-unit>
        <trans-unit id="d5d64221ddf91f88df67cce91813f4262eb7edaf" translate="yes" xml:space="preserve">
          <source>State Transitions</source>
          <target state="translated">状态转换</target>
        </trans-unit>
        <trans-unit id="a872ca8fe22c7e62b5337472cd220dc9385362c8" translate="yes" xml:space="preserve">
          <source>Stop listening for an event with &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">停止使用 &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt; 监听事件</target>
        </trans-unit>
        <trans-unit id="a59e5fba28ea5c4503821b338479233b19afe716" translate="yes" xml:space="preserve">
          <source>Store&amp;rsquo;s Event Emitter &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">商店的事件发射器&lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="91315c1968e95b4caef2bb0299209f84b45e1fa3" translate="yes" xml:space="preserve">
          <source>String templates (e.g. &lt;code&gt;template: '...'&lt;/code&gt;)</source>
          <target state="translated">字符串模板（例如 &lt;code&gt;template: '...'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="74b4f2ed89813f9a73f7270d61c097ff9c059dd6" translate="yes" xml:space="preserve">
          <source>Style Guide</source>
          <target state="translated">风格指南</target>
        </trans-unit>
        <trans-unit id="93b9066aa73ddae63c26874719afa6da8fe21b7f" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority A: Essential</source>
          <target state="translated">风格指南。优先事项A:基本要素</target>
        </trans-unit>
        <trans-unit id="43212530e7b38b61ce475ee08dd6944866d5239c" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority B: Strongly Recommended</source>
          <target state="translated">风格指南。优先级B:强烈建议</target>
        </trans-unit>
        <trans-unit id="dc97fc3044903277305bdcda1967fb4d1dab822e" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority C: Recommended</source>
          <target state="translated">风格指南。优先级C:建议</target>
        </trans-unit>
        <trans-unit id="b9a479a71d55ce0478bf03634c2c6dce93bce7d7" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority D: Use with Caution</source>
          <target state="translated">风格指南。优先级D。谨慎使用</target>
        </trans-unit>
        <trans-unit id="d999535d9e96f490d6db66310b5ab700b8118ee7" translate="yes" xml:space="preserve">
          <source>Style Guide: Rule Categories</source>
          <target state="translated">风格指南。规则类别</target>
        </trans-unit>
        <trans-unit id="fbbf610d0cedad761fd69b3fc9625e259e3102c5" translate="yes" xml:space="preserve">
          <source>Suppress all Vue logs and warnings.</source>
          <target state="translated">压制所有Vue日志和警告。</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ed4b8354b13fc6485ba3014a73af2e474df2ab5c" translate="yes" xml:space="preserve">
          <source>System Modifier Keys</source>
          <target state="translated">系统修改键</target>
        </trans-unit>
        <trans-unit id="d3c9825399d84e5c262586eb382db07595391d25" translate="yes" xml:space="preserve">
          <source>Template Compilation</source>
          <target state="translated">模板汇编</target>
        </trans-unit>
        <trans-unit id="efb3147068725b40c3436e7283942bba6c112bbf" translate="yes" xml:space="preserve">
          <source>Template Syntax</source>
          <target state="translated">模板语法</target>
        </trans-unit>
        <trans-unit id="a60e21f3a907038b2e4d24850447a7990f71ed0d" translate="yes" xml:space="preserve">
          <source>Template expressions are sandboxed and only have access to a &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;whitelist of globals&lt;/a&gt; such as &lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;Date&lt;/code&gt;. You should not attempt to access user defined globals in template expressions.</source>
          <target state="translated">模板表达式是沙盒化的，只能访问诸如 &lt;code&gt;Math&lt;/code&gt; 和 &lt;code&gt;Date&lt;/code&gt; 之类&lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;的全局白名单&lt;/a&gt;。您不应尝试在模板表达式中访问用户定义的全局变量。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="03aaa3887a5a2deee792941da96ae7dda7d74089" translate="yes" xml:space="preserve">
          <source>Thanks to Vue&amp;rsquo;s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</source>
          <target state="translated">借助Vue的反应系统，它始终可以知道何时进行更新（如果正确使用的话）。但是，在某些情况下，尽管没有任何反应性数据发生更改，但您可能仍要强制进行更新。然后，在其他情况下，您可能希望防止不必要的更新。</target>
        </trans-unit>
        <trans-unit id="b5627556ef42d923efe566603e16cd6d339c54b6" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; listener, the parent will receive the event and update &lt;code&gt;postFontSize&lt;/code&gt; value.</source>
          <target state="translated">感谢 &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; 侦听器，父级将收到事件并更新 &lt;code&gt;postFontSize&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="36e5dbb5155a7f2f18ff2f7f92eeacd1bc83b650" translate="yes" xml:space="preserve">
          <source>That means the value of &lt;code&gt;v-slot&lt;/code&gt; can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;), you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; to pull out specific slot props, like so:</source>
          <target state="translated">这意味着 &lt;code&gt;v-slot&lt;/code&gt; 的值实际上可以接受可以出现在函数定义的参数位置中的任何有效JavaScript表达式。因此，在受支持的环境（&lt;a href=&quot;single-file-components&quot;&gt;单文件组件&lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;现代浏览器&lt;/a&gt;）中，您还可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015解构&lt;/a&gt;来提取特定的插槽道具，如下所示：</target>
        </trans-unit>
        <trans-unit id="bcb7688f15ef595e1970dc731883ce107eed33d5" translate="yes" xml:space="preserve">
          <source>That means this element:</source>
          <target state="translated">也就是说,这个要素。</target>
        </trans-unit>
        <trans-unit id="e26ac9d99d2de3a31a44d33d135f52e40dec965b" translate="yes" xml:space="preserve">
          <source>That said, it would probably make a better comparison between Vue core and Ember&amp;rsquo;s &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;templating&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;object model&lt;/a&gt; layers:</source>
          <target state="translated">也就是说，这可能会在Vue核心与Ember的&lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;模板&lt;/a&gt;层和&lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;对象模型&lt;/a&gt;层之间进行更好的比较：</target>
        </trans-unit>
        <trans-unit id="fd91ee6e59ac928406a857815fec4a8fd6adac41" translate="yes" xml:space="preserve">
          <source>That slot has access to the same instance properties (i.e. the same &amp;ldquo;scope&amp;rdquo;) as the rest of the template. The slot does &lt;strong&gt;not&lt;/strong&gt; have access to &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s scope. For example, trying to access &lt;code&gt;url&lt;/code&gt; would not work:</source>
          <target state="translated">该插槽可以访问与模板其余部分相同的实例属性（即相同的&amp;ldquo;作用域&amp;rdquo;）。该插槽&lt;strong&gt;无权&lt;/strong&gt;访问 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 的范围。例如，尝试访问 &lt;code&gt;url&lt;/code&gt; 无效：</target>
        </trans-unit>
        <trans-unit id="459dd83f2362d8a07c853704c9fdaa721e9d7d51" translate="yes" xml:space="preserve">
          <source>That template doesn&amp;rsquo;t feel great. It&amp;rsquo;s not only verbose, but we&amp;rsquo;re duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level and will have to do the same when we add the anchor element.</source>
          <target state="translated">该模板感觉不太好。这不仅冗长，而且我们在每个标题级别都复制了 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; ，并且在添加anchor元素时也必须这样做。</target>
        </trans-unit>
        <trans-unit id="f0e76918c986bcb84adf08fee89b468d3a1fda00" translate="yes" xml:space="preserve">
          <source>That won&amp;rsquo;t work, however, because only the &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component has access to the &lt;code&gt;user&lt;/code&gt; and the content we&amp;rsquo;re providing is rendered in the parent.</source>
          <target state="translated">但是，这是行不通的，因为只有 &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; 组件有权访问 &lt;code&gt;user&lt;/code&gt; ，而我们提供的内容在父级中呈现。</target>
        </trans-unit>
        <trans-unit id="f7e6eaf815a0b389b506fd9203ee98688ac385cc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about DOM template parsing caveats for now &amp;ndash; and actually, the end of Vue&amp;rsquo;s &lt;em&gt;Essentials&lt;/em&gt;. Congratulations! There&amp;rsquo;s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</source>
          <target state="translated">到目前为止，您只需要了解有关DOM模板解析警告的全部信息，实际上，这就是Vue &lt;em&gt;Essentials&lt;/em&gt;的结尾。恭喜你！还有更多的东西要学习，但是首先，我们建议您休息一下，自己动手玩Vue并创造一些有趣的东西。</target>
        </trans-unit>
        <trans-unit id="e65f913a2b8930db25e11b615901938e35677612" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about custom component events for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-custom-events&quot;&gt;Custom Events&lt;/a&gt;.</source>
          <target state="translated">到目前为止，您只需要了解有关自定义组件事件的全部信息，但是一旦您阅读完该页面并对其内容感到满意后，我们建议稍后再阅读以阅读有关&lt;a href=&quot;components-custom-events&quot;&gt;自定义事件&lt;/a&gt;的完整指南。</target>
        </trans-unit>
        <trans-unit id="814dc84544fcf8f9ba3af47bc369c70717b8fdfa" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about dynamic components for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;.</source>
          <target state="translated">到目前为止，您只需要了解有关动态组件的全部信息，但是一旦您阅读完该页面并且对它的内容感到满意之后，我们建议稍后再回来阅读有关&lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic＆Async Components&lt;/a&gt;的完整指南。</target>
        </trans-unit>
        <trans-unit id="1370785d9557daacd2793450c22d6061fa0adbc6" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about props for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-props&quot;&gt;Props&lt;/a&gt;.</source>
          <target state="translated">到目前为止，您只需要了解有关道具的全部信息，但是一旦阅读完此页并对其内容感到满意后，我们建议稍后再回来阅读有关&lt;a href=&quot;components-props&quot;&gt;道具&lt;/a&gt;的完整指南。</target>
        </trans-unit>
        <trans-unit id="1e701db7e6d05f9288626f8d97a85fc554f9593e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about registration for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-registration&quot;&gt;Component Registration&lt;/a&gt;.</source>
          <target state="translated">到目前为止，您只需要了解有关注册的全部信息，但是一旦您阅读完本页面并对其内容感到满意后，我们建议稍后再阅读有关&lt;a href=&quot;components-registration&quot;&gt;组件注册&lt;/a&gt;的完整指南。</target>
        </trans-unit>
        <trans-unit id="8e7ac0de9bc7b2393fad83ed8e57aa35094e7cc2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about slots for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-slots&quot;&gt;Slots&lt;/a&gt;.</source>
          <target state="translated">到目前为止，您只需要了解有关插槽的全部信息即可，但是一旦您阅读完此页并对其内容感到满意后，我们建议稍后再阅读以阅读有关&lt;a href=&quot;components-slots&quot;&gt;插槽&lt;/a&gt;的完整指南。</target>
        </trans-unit>
        <trans-unit id="6f39b1bdd26be7312e776a774c103e8b83e7cb1a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why for any complex logic, you should use a &lt;strong&gt;computed property&lt;/strong&gt;.</source>
          <target state="translated">这就是为什么对于任何复杂的逻辑，都应该使用&lt;strong&gt;计算属性&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3b16487797e90834fa5c92964e14dabbe10606c8" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why instead, we recommend emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, in a hypothetical component with a &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="translated">因此，我们建议使用 &lt;code&gt;update:myPropName&lt;/code&gt; 模式发出事件。例如，在一个带有 &lt;code&gt;title&lt;/code&gt; 属性的假想组件中，我们可以通过以下方式传达分配新值的意图：</target>
        </trans-unit>
        <trans-unit id="996c0c7a918cb9833eb237973fce54baee6b3199" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why there&amp;rsquo;s a &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel plugin&lt;/a&gt; to use JSX with Vue, getting us back to a syntax that&amp;rsquo;s closer to templates:</source>
          <target state="translated">这就是为什么有一个&lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel插件&lt;/a&gt;在Vue中使用JSX 的原因，使我们回到了更接近模板的语法：</target>
        </trans-unit>
        <trans-unit id="ad7c55b719b44c49b49edeaa4e2789ec22bd2ca2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why we offer a full system for rapid Vue.js development. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.</source>
          <target state="translated">这就是为什么我们提供用于快速Vue.js开发的完整系统的原因。&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI的&lt;/a&gt;目标是成为Vue生态系统的标准工具基线。它可确保各种构建工具与合理的默认设置一起顺利运行，因此您可以专注于编写应用程序，而不必花费大量时间进行配置。同时，它仍然提供了灵活性，可以根据特定需要调整每个工具的配置。</target>
        </trans-unit>
        <trans-unit id="e8054cccceec827f8cba34b7a1b6bd02a65cd67d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;guide/installation&quot;&gt;Installation&lt;/a&gt; page provides more options of installing Vue. Note: We &lt;strong&gt;do not&lt;/strong&gt; recommend that beginners start with &lt;code&gt;vue-cli&lt;/code&gt;, especially if you are not yet familiar with Node.js-based build tools.</source>
          <target state="translated">在&lt;a href=&quot;guide/installation&quot;&gt;安装&lt;/a&gt;页面提供安装Vue公司的更多选择。注意：我们&lt;strong&gt;不&lt;/strong&gt;建议初学者以 &lt;code&gt;vue-cli&lt;/code&gt; 开头，尤其是在您尚未熟悉基于Node.js的构建工具的情况下。</target>
        </trans-unit>
        <trans-unit id="a5ab4cb7708169e37819b6bac8b1dd32c12097a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;pluralize&lt;/a&gt; package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like &lt;code&gt;0&lt;/code&gt;, then you can also easily define your own pluralize functions. For example:</source>
          <target state="translated">NPM上的&lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;pluralize&lt;/a&gt;软件包很好地满足了此目的，但是如果您只想对特定单词进行复数处理，或者想为 &lt;code&gt;0&lt;/code&gt; 等情况提供特殊的输出，那么您也可以轻松定义自己的复数函数。例如：</target>
        </trans-unit>
        <trans-unit id="05878157178d05a4e01a1c89173d306a9458b9ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$route&lt;/code&gt; property is now reactive, so you can use a watcher to react to route changes, like this:</source>
          <target state="translated">在 &lt;code&gt;$route&lt;/code&gt; 属性现在被动的，所以你可以使用一个观察者反应路由变化，就像这样：</target>
        </trans-unit>
        <trans-unit id="26e5d2730ae73e0e0de2df953cf2ee3a5fad3d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; will be the actual link (and will get the correct href), but the active class will be applied to the outer &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 将实际的链接（和将获得正确的HREF），但活性的类将被施加到外 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1c768384d9ec752c708894881ada4881202a8fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will not be visible until the compilation is done.</source>
          <target state="translated">该 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ，直到编译完成将不可见。</target>
        </trans-unit>
        <trans-unit id="6726c886cd7d1313872ea34b72b56e9373d396cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; component might define a &lt;code&gt;map&lt;/code&gt; property that all subcomponents need access to. In this case &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; might want to access that map with something like &lt;code&gt;this.$parent.getMap&lt;/code&gt;, in order to add a set of markers to it. You can see this pattern &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;in action here&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 组分可以定义一个 &lt;code&gt;map&lt;/code&gt; 属性，所有子组件需要访问。在这种情况下， &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 可能希望使用 &lt;code&gt;this.$parent.getMap&lt;/code&gt; 类的内容访问该地图，以便向其添加一组标记。您可以&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;在这里&lt;/a&gt;看到这种模式的作用。</target>
        </trans-unit>
        <trans-unit id="780604d1e5198fdcc94939f3a317c58b142346c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of &lt;strong&gt;the &lt;code&gt;v-move&lt;/code&gt; class&lt;/strong&gt;, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided &lt;code&gt;name&lt;/code&gt; attribute and you can also manually specify a class with the &lt;code&gt;move-class&lt;/code&gt; attribute.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 部件具有另一特技了它的袖子。它不仅可以动画进入和离开，还可以改变位置。使用此功能所需了解的唯一新概念是添加&lt;strong&gt;了 &lt;code&gt;v-move&lt;/code&gt; 类&lt;/strong&gt;，&lt;strong&gt;该类&lt;/strong&gt;在项目更改位置时添加。与其他类一样，其前缀将与提供的 &lt;code&gt;name&lt;/code&gt; 属性的值匹配，并且您也可以使用 &lt;code&gt;move-class&lt;/code&gt; 属性手动指定一个类。</target>
        </trans-unit>
        <trans-unit id="606648505385790cf915adeb72e619634753fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.camel&lt;/code&gt; modifier allows camelizing a &lt;code&gt;v-bind&lt;/code&gt; attribute name when using in-DOM templates, e.g. the SVG &lt;code&gt;viewBox&lt;/code&gt; attribute:</source>
          <target state="translated">该 &lt;code&gt;.camel&lt;/code&gt; 修饰符允许骆驼源一个 &lt;code&gt;v-bind&lt;/code&gt; 属性名称使用-DOM模板时，如SVG &lt;code&gt;viewBox&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="b9f947cb89a1b3d04c28ecc1fa1b5146bc308109" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.exact&lt;/code&gt; modifier allows control of the exact combination of system modifiers needed to trigger an event.</source>
          <target state="translated">所述 &lt;code&gt;.exact&lt;/code&gt; 修饰符允许触发一个事件所需的系统改性剂的确切组合的控制。</target>
        </trans-unit>
        <trans-unit id="71dc161e02d764cb61bccce7f7216e558eea41ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.literal&lt;/code&gt; modifier has been removed, as the same can be easily achieved by providing a string literal as the value.</source>
          <target state="translated">所述 &lt;code&gt;.literal&lt;/code&gt; 改性剂已被去除，如同样可以通过提供一个字符串作为值可以容易地实现。</target>
        </trans-unit>
        <trans-unit id="447f18c9c1ff6544a5bf8da7ab660de9c45d00c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.passive&lt;/code&gt; modifier is especially useful for improving performance on mobile devices.</source>
          <target state="translated">该 &lt;code&gt;.passive&lt;/code&gt; 改性剂对提高移动设备的性能特别有用。</target>
        </trans-unit>
        <trans-unit id="21fd043aec56c5be7446f861bc772ebd8e753810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sync&lt;/code&gt; modifier can also be used with &lt;code&gt;v-bind&lt;/code&gt; when using an object to set multiple props at once:</source>
          <target state="translated">使用对象一次设置多个道具时， &lt;code&gt;.sync&lt;/code&gt; 修饰符还可与 &lt;code&gt;v-bind&lt;/code&gt; 一起使用：</target>
        </trans-unit>
        <trans-unit id="c3321d11e9ef44eba8d358a3614e37323b934b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;events&lt;/code&gt; option has been removed. Event handlers should now be registered in the &lt;code&gt;created&lt;/code&gt; hook instead. Check out the &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt;&lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; migration guide&lt;/a&gt; for a detailed example.</source>
          <target state="translated">该 &lt;code&gt;events&lt;/code&gt; 选项已被删除。现在应将事件处理程序注册在 &lt;code&gt;created&lt;/code&gt; 钩子中。查看&lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt; &lt;code&gt;$dispatch&lt;/code&gt; 和 &lt;code&gt;$broadcast&lt;/code&gt; 迁移指南&lt;/a&gt;中的详细示例。</target>
        </trans-unit>
        <trans-unit id="2b7c4b5febaa054c2d70f2972911d81840dc234e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-out&lt;/code&gt; mode isn&amp;rsquo;t used as often, but can sometimes be useful for a slightly different transition effect. Let&amp;rsquo;s try combining it with the slide-fade transition we worked on earlier:</source>
          <target state="translated">的 &lt;code&gt;in-out&lt;/code&gt; 模式没有用作经常，但有时可以用于略微不同的过渡效果是有用的。让我们尝试将其与我们之前进行的幻灯片淡入淡出过渡结合起来：</target>
        </trans-unit>
        <trans-unit id="7bb2562df8be00932287fedd76a233d44e708651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</source>
          <target state="translated">该 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 道具允许组件有条件缓存。这两个道具可以是逗号分隔的字符串，RegExp或数组：</target>
        </trans-unit>
        <trans-unit id="4cd088c8b9dd70d20f540d863e4827655ef4afc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; option should be either:</source>
          <target state="translated">该 &lt;code&gt;inject&lt;/code&gt; 的选择应该是：</target>
        </trans-unit>
        <trans-unit id="582a8cbd2aa999f85f97f4835ddb07fec729cd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; special attribute is primarily used as a hint for Vue&amp;rsquo;s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</source>
          <target state="translated">在 &lt;code&gt;key&lt;/code&gt; 特殊属性主要用作Vue公司的虚拟DOM算法的提示版本比较不服老的列表中节点的新列表时识别虚拟节点。在没有键的情况下，Vue使用的算法可最大程度地减少元素移动，并尝试尽可能地就地修补/重复使用相同类型的元素。使用键，它将根据键的顺序更改对元素进行重新排序，并且不再具有键的元素将始终被删除/销毁。</target>
        </trans-unit>
        <trans-unit id="dc118214d9d96bdcdab86a3dcf6dbc36ea6680a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt; param attributes are now modifiers, to make it more clear what That means instead of:</source>
          <target state="translated">现在， &lt;code&gt;lazy&lt;/code&gt; 和 &lt;code&gt;number&lt;/code&gt; 参数属性是修饰符，以便更清楚地表示其含义，而不是：</target>
        </trans-unit>
        <trans-unit id="cb26d534e1e0fd7dab034b343fe732f25ec4cdc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mixins&lt;/code&gt; option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in &lt;code&gt;Vue.extend()&lt;/code&gt;. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</source>
          <target state="translated">的 &lt;code&gt;mixins&lt;/code&gt; 选项接受混入对象的数组。这些mixin对象可以包含类似于普通实例对象的实例选项，并且它们将使用 &lt;code&gt;Vue.extend()&lt;/code&gt; 中相同的选项合并逻辑与最终选项进行合并。例如，如果您的mixin包含一个已创建的钩子，并且组件本身也有一个钩子，则将调用这两个函数。</target>
        </trans-unit>
        <trans-unit id="a26f8d5002e995f88abd483d65f2b8981c550aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Reflect.ownKeys&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;provide&lt;/code&gt; 选项应该是一个对象或一个函数返回一个对象。该对象包含可用于注入其子代的属性。您可以将ES2015符号用作此对象中的键，但只能在本机支持 &lt;code&gt;Symbol&lt;/code&gt; 和 &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 的环境中使用。</target>
        </trans-unit>
        <trans-unit id="1df98a28e225ea8d4b071027515cc8bf9c095a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; options allows us to specify the data/methods we want to &lt;strong&gt;provide&lt;/strong&gt; to descendent components. In this case, that&amp;rsquo;s the &lt;code&gt;getMap&lt;/code&gt; method inside &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;provide&lt;/code&gt; 的选项允许我们指定我们希望将数据/方法&lt;strong&gt;提供&lt;/strong&gt;给后代组件。在这种情况下，这就是 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;getMap&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="e89e752e4e0ad59fc71d8c42dbb8b140ac0a0a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; function has priority over the render function compiled from &lt;code&gt;template&lt;/code&gt; option or in-DOM HTML template of the mounting element which is specified by the &lt;code&gt;el&lt;/code&gt; option.</source>
          <target state="translated">该 &lt;code&gt;render&lt;/code&gt; 功能拥有从编译渲染功能的优先级 &lt;code&gt;template&lt;/code&gt; 选项或-DOM HTML这是由指定的安装元件的模板 &lt;code&gt;el&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="2f312c98cab71695e7dd222c575b78b0d13a0c64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;slot-scope&lt;/code&gt; attribute can also be used directly on a non-&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element (including components):</source>
          <target state="translated">所述 &lt;code&gt;slot-scope&lt;/code&gt; 属性也可以直接使用的非对 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元件（包括部件）：</target>
        </trans-unit>
        <trans-unit id="955152ea21b24fdf404e6e6a60a1465f0de55be9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;true-value&lt;/code&gt; and &lt;code&gt;false-value&lt;/code&gt; attributes don&amp;rsquo;t affect the input&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; attribute, because browsers don&amp;rsquo;t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. &amp;ldquo;yes&amp;rdquo; or &amp;ldquo;no&amp;rdquo;), use radio inputs instead.</source>
          <target state="translated">在 &lt;code&gt;true-value&lt;/code&gt; 和 &lt;code&gt;false-value&lt;/code&gt; 属性不影响输入的 &lt;code&gt;value&lt;/code&gt; 属性，因为浏览器不包含在表单提交选中框。为了确保以表格形式（例如&amp;ldquo;是&amp;rdquo;或&amp;ldquo;否&amp;rdquo;）提交两个值之一，请改用无线电输入。</target>
        </trans-unit>
        <trans-unit id="e182f837614c4a38080aad510dbbf2060bfc370d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; can be one of the following native constructors:</source>
          <target state="translated">该 &lt;code&gt;type&lt;/code&gt; 可以是以下本机构造函数之一：</target>
        </trans-unit>
        <trans-unit id="e190ce9f5befbb3426f06af3ed96f5a8aa0969e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-&lt;/code&gt; prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the &lt;code&gt;v-&lt;/code&gt; prefix becomes less important when you are building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, &lt;code&gt;v-bind&lt;/code&gt; and &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;v-&lt;/code&gt; 前缀充当在模板识别Vue的特定属性的视觉线索。当您使用Vue.js将动态行为应用于某些现有标记时非常有用，但对于某些常用指令可能会感到冗长。同时，在构建&lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;时，对 &lt;code&gt;v-&lt;/code&gt; 前缀的需求变得不那么重要了，Vue负责管理每个模板。因此，Vue为两个最常用的指令 &lt;code&gt;v-bind&lt;/code&gt; 和 &lt;code&gt;v-on&lt;/code&gt; 提供了特殊的缩写：</target>
        </trans-unit>
        <trans-unit id="cd8461a9f091788550d2bcfcb0e99f3643c233d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-else-if&lt;/code&gt;, as the name suggests, serves as an &amp;ldquo;else if block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;. It can also be chained multiple times:</source>
          <target state="translated">在 &lt;code&gt;v-else-if&lt;/code&gt; ，顾名思义，可以充当一个&amp;ldquo;否则，如果块&amp;rdquo;为 &lt;code&gt;v-if&lt;/code&gt; 。它也可以链接多次：</target>
        </trans-unit>
        <trans-unit id="0f6244029a3dc18b6cba09b3e6e0a940180e13b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link-active&lt;/code&gt; directive has also been replaced by the &lt;code&gt;tag&lt;/code&gt; attribute on &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;the &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;. So for example, you&amp;rsquo;ll update this:</source>
          <target state="translated">的 &lt;code&gt;v-link-active&lt;/code&gt; 指令也被替换由 &lt;code&gt;tag&lt;/code&gt; 上属性&lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;的 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 组分&lt;/a&gt;。因此，例如，您将更新此内容：</target>
        </trans-unit>
        <trans-unit id="83d24c44d5fff24f0114d4c306087248f718b001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link&lt;/code&gt; directive has been replaced with a new &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:</source>
          <target state="translated">在 &lt;code&gt;v-link&lt;/code&gt; 指令已被替换为新的&lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 组件&lt;/a&gt;，因为这种工作的，现在仅仅是中Vue公司2组件的责任认定时，无论你有这样的链接方式：</target>
        </trans-unit>
        <trans-unit id="913c16238f6be321d10c7aa5ede9be4e8848de68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-slot&lt;/code&gt; directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes. The full rationale for introducing &lt;code&gt;v-slot&lt;/code&gt; is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;. The &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</source>
          <target state="translated">的 &lt;code&gt;v-slot&lt;/code&gt; 指令在Vue的2.6.0引入，将提供一种改进的，可选的API到静止支撑 &lt;code&gt;slot&lt;/code&gt; 和 &lt;code&gt;slot-scope&lt;/code&gt; 的属性。在此&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC中&lt;/a&gt;描述了引入 &lt;code&gt;v-slot&lt;/code&gt; 的完整原理。所有未来的2.x发行版都将继续支持 &lt;code&gt;slot&lt;/code&gt; 和 &lt;code&gt;slot-scope&lt;/code&gt; 属性，但正式弃用了该属性，最终将在Vue 3中将其删除。</target>
        </trans-unit>
        <trans-unit id="f371f3394ccbbd9c9c7339bc5a079bc98cf103c4" translate="yes" xml:space="preserve">
          <source>The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; without any build tools before using the CLI.</source>
          <target state="translated">CLI假定您具有Node.js和相关构建工具的先验知识。如果你是新来的Vue或前端构建工具，我们强烈建议通过去&lt;a href=&quot;../index&quot;&gt;引导&lt;/a&gt;使用CLI之前没有任何的构建工具。</target>
        </trans-unit>
        <trans-unit id="431e39681a2982cceb38425ec480f7e168f10ba0" translate="yes" xml:space="preserve">
          <source>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;config options&lt;/a&gt;.</source>
          <target state="translated">CLI为您处理了大多数工具配置，但也允许通过其自己的&lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;config选项&lt;/a&gt;进行细粒度的自定义。</target>
        </trans-unit>
        <trans-unit id="37e9961ffd2140433ee6300b4c25596bb92249ae" translate="yes" xml:space="preserve">
          <source>The Complete SSR Guide</source>
          <target state="translated">SSR完全指南</target>
        </trans-unit>
        <trans-unit id="eb35b5bf284498fbba8e557432a08e707e7edef3" translate="yes" xml:space="preserve">
          <source>The Data Object In-Depth</source>
          <target state="translated">深入了解数据对象</target>
        </trans-unit>
        <trans-unit id="3c531607ce360cbb5aec13ac8c3438a41dc5f330" translate="yes" xml:space="preserve">
          <source>The Virtual DOM</source>
          <target state="translated">虚拟DOM</target>
        </trans-unit>
        <trans-unit id="babecbcffc795b2e20d9189e575e0bb731f8cd62" translate="yes" xml:space="preserve">
          <source>The Vue Instance</source>
          <target state="translated">Vue实例</target>
        </trans-unit>
        <trans-unit id="be83ced5c720e31f43242c0f5e365ad3f2da0751" translate="yes" xml:space="preserve">
          <source>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don&amp;rsquo;t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</source>
          <target state="translated">Web组件规范已完成，但并非在每个浏览器中都以本地方式实现。Safari 10.1 +，Chrome 54+和Firefox 63+本机支持Web组件。相比之下，Vue组件不需要任何填充，并且可以在所有受支持的浏览器（IE9及更高版本）中一致地工作。必要时，Vue组件也可以包装在本地自定义元素中。</target>
        </trans-unit>
        <trans-unit id="0a28d4802ae8f29af4f28a606d7b55fd498ccb1b" translate="yes" xml:space="preserve">
          <source>The above code is imperative and repetitive. Compare it with a computed property version:</source>
          <target state="translated">上面的代码是命令式的,而且是重复的。将其与计算属性版本进行比较。</target>
        </trans-unit>
        <trans-unit id="bb879e483c23bffcd30b4eb818c6b264dd8b31d3" translate="yes" xml:space="preserve">
          <source>The above declarations allow the following code to be compiled:</source>
          <target state="translated">上述声明允许编译以下代码。</target>
        </trans-unit>
        <trans-unit id="f57aa3ad596a32aa0ee96ea34ada406c21b66366" translate="yes" xml:space="preserve">
          <source>The above example and some future ones use JavaScript&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template literal&lt;/a&gt; to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;newline escapes&lt;/a&gt; instead.</source>
          <target state="translated">上面的示例以及以后的示例使用JavaScript的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;模板文字&lt;/a&gt;来使多行模板更具可读性。Internet Explorer（IE）不支持这些功能，因此，如果您必须支持IE并且未进行转码（例如，使用Babel或TypeScript），请改用&lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;换行符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99a5b0f10fab94bdbe6947c371a61fc4c4300760" translate="yes" xml:space="preserve">
          <source>The above is made possible by Vue&amp;rsquo;s &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; element with the &lt;code&gt;is&lt;/code&gt; special attribute:</source>
          <target state="translated">以上是由Vue公司的成为可能 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 与元件 &lt;code&gt;is&lt;/code&gt; 特殊的属性：</target>
        </trans-unit>
        <trans-unit id="b7374ad3f755708e5dc13a8b4b98839ff8d234e1" translate="yes" xml:space="preserve">
          <source>The above only renders the todos that are not complete.</source>
          <target state="translated">以上只演绎了未完成的todos。</target>
        </trans-unit>
        <trans-unit id="4af7e3e4b79fac718e6fd64e5702254c69dcf11f" translate="yes" xml:space="preserve">
          <source>The above syntax means the presence of the &lt;code&gt;active&lt;/code&gt; class will be determined by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthiness&lt;/a&gt; of the data property &lt;code&gt;isActive&lt;/code&gt;.</source>
          <target state="translated">上面的语法意味着 &lt;code&gt;active&lt;/code&gt; 类的存在将由数据属性 &lt;code&gt;isActive&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;真实性&lt;/a&gt;确定。</target>
        </trans-unit>
        <trans-unit id="aeec69d6935039bffd444e21fbd1ed7763a7edf9" translate="yes" xml:space="preserve">
          <source>The above will be equivalent to:</source>
          <target state="translated">以上将相当于:</target>
        </trans-unit>
        <trans-unit id="bc22dad858f565e9beeefc992c5465134124606c" translate="yes" xml:space="preserve">
          <source>The anchored heading component we created earlier is relatively simple. It doesn&amp;rsquo;t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it&amp;rsquo;s only a function with some props.</source>
          <target state="translated">我们之前创建的锚定标题组件相对简单。它不管理任何状态，监视传递给它的任何状态，并且没有生命周期方法。确实，这只是带有一些道具的功能。</target>
        </trans-unit>
        <trans-unit id="87b9709d9cefabc9cccc6ad0b23e243c50a3cb35" translate="yes" xml:space="preserve">
          <source>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.</source>
          <target state="translated">数组语法允许更可预测的路径匹配,因为在对象上迭代不能保证在不同的浏览器中使用相同的属性顺序。</target>
        </trans-unit>
        <trans-unit id="da3ddd2386065d734a4382298ee4c3e11da253a3" translate="yes" xml:space="preserve">
          <source>The array syntax for &lt;code&gt;v-bind:style&lt;/code&gt; allows you to apply multiple style objects to the same element:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 的数组语法允许您将多个样式对象应用于同一元素：</target>
        </trans-unit>
        <trans-unit id="e823b9beb8c48498f2cf709b4d0756d4d1fc6465" translate="yes" xml:space="preserve">
          <source>The async component factory can also return an object of the following format:</source>
          <target state="translated">async组件工厂也可以返回一个如下格式的对象。</target>
        </trans-unit>
        <trans-unit id="ba11fc067d05679fdd5921eda5ec20ebd31b1c5d" translate="yes" xml:space="preserve">
          <source>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</source>
          <target state="translated">编辑器中的自动完成功能使得编写较长的名称的成本非常低,而它们所提供的清晰度是非常宝贵的。尤其是不常见的缩写,应始终避免使用。</target>
        </trans-unit>
        <trans-unit id="8c22ef1ce4c22f9fdb3192ace8ea666bf31d6a91" translate="yes" xml:space="preserve">
          <source>The bound object doesn&amp;rsquo;t have to be inline:</source>
          <target state="translated">绑定的对象不必是内联的：</target>
        </trans-unit>
        <trans-unit id="c473e09bb4188e420d79ebd60ee46d8c65246cf3" translate="yes" xml:space="preserve">
          <source>The component system is another important concept in Vue, because it&amp;rsquo;s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</source>
          <target state="translated">组件系统是Vue中另一个重要的概念，因为它是一种抽象，它使我们能够构建由小型，独立且经常可重用的组件组成的大规模应用程序。如果我们考虑一下，几乎任何类型的应用程序接口都可以抽象为组件树：</target>
        </trans-unit>
        <trans-unit id="e2a227479dfaa2ebe9e09278b1482fab712cafda" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it&amp;rsquo;s usually better to use a &lt;a href=&quot;#computed&quot;&gt;computed property&lt;/a&gt; or &lt;a href=&quot;#watch&quot;&gt;watcher&lt;/a&gt; instead.</source>
          <target state="translated">调用此挂钩时，组件的DOM将已更新，因此您可以在此处执行与DOM相关的操作。但是，在大多数情况下，应避免更改挂钩内的状态。为了对状态更改做出反应，通常最好使用&lt;a href=&quot;#computed&quot;&gt;计算属性&lt;/a&gt;或&lt;a href=&quot;#watch&quot;&gt;观察程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33a9c37f2f9908b2ff6754fe4ced3a3b882e927a" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s name is the first argument of &lt;code&gt;Vue.component&lt;/code&gt;.</source>
          <target state="translated">组件的名称是 &lt;code&gt;Vue.component&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="6c50d6a412a378e537c001610ef774aa9ae31afc" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;span&lt;/code&gt; will be replaced with the value of the &lt;code&gt;rawHtml&lt;/code&gt; property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use &lt;code&gt;v-html&lt;/code&gt; to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</source>
          <target state="translated">在内容 &lt;code&gt;span&lt;/code&gt; 将与中值替换 &lt;code&gt;rawHtml&lt;/code&gt; 财产，解释为纯HTML -数据绑定被忽略。请注意，由于Vue不是基于字符串的模板引擎，因此无法使用 &lt;code&gt;v-html&lt;/code&gt; 来组成模板部分。取而代之的是，组件是UI重用和合成的基本单位。</target>
        </trans-unit>
        <trans-unit id="0aabf5563ee74ceaaa562a702ba84f4906e6efaf" translate="yes" xml:space="preserve">
          <source>The custom component &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the &lt;code&gt;is&lt;/code&gt; special attribute offers a workaround:</source>
          <target state="translated">自定义组件 &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; 将作为无效内容悬挂，导致最终呈现的输出中出现错误。幸运的是， &lt;code&gt;is&lt;/code&gt; 特殊属性提供了一种解决方法：</target>
        </trans-unit>
        <trans-unit id="773dcdb0e4554ae71591d98763ca297e3e508d9e" translate="yes" xml:space="preserve">
          <source>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it &amp;ldquo;reactive&amp;rdquo;. &lt;strong&gt;The object must be plain&lt;/strong&gt;: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</source>
          <target state="translated">Vue实例的数据对象。Vue将以递归方式将其属性转换为getter / setter，以使其&amp;ldquo;具有反应性&amp;rdquo;。&lt;strong&gt;该对象必须是普通&lt;/strong&gt;对象：诸如浏览器API对象和原型属性之类的本机对象将被忽略。一条经验法则是，数据应仅是数据-不建议观察具有自身状态行为的对象。</target>
        </trans-unit>
        <trans-unit id="f249c1e096e4760333b8a1a164e494b46a537f23" translate="yes" xml:space="preserve">
          <source>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</source>
          <target state="translated">Vue 实例正在观察的数据对象。Vue 实例代理访问其数据对象上的属性。</target>
        </trans-unit>
        <trans-unit id="536204b9289a091fc1bfb216ea4a0b6805215f8d" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;v-for&lt;/code&gt; will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the &lt;code&gt;key&lt;/code&gt; special attribute:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 的默认行为将尝试在不移动元素的情况下对元素进行修补。要强制其对元素重新排序，您需要提供带有 &lt;code&gt;key&lt;/code&gt; 特殊属性的排序提示：</target>
        </trans-unit>
        <trans-unit id="d129c09e272230c72d4816c9cf37d602f78c6b98" translate="yes" xml:space="preserve">
          <source>The detailed usage for &lt;code&gt;v-for&lt;/code&gt; is explained in the guide section linked below.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 的详细用法在下面链接的指南部分中说明。</target>
        </trans-unit>
        <trans-unit id="fcb2400b62e62455e5be23679bc16dcd684f0e97" translate="yes" xml:space="preserve">
          <source>The difference is that an element with &lt;code&gt;v-show&lt;/code&gt; will always be rendered and remain in the DOM; &lt;code&gt;v-show&lt;/code&gt; only toggles the &lt;code&gt;display&lt;/code&gt; CSS property of the element.</source>
          <target state="translated">不同之处在于带有 &lt;code&gt;v-show&lt;/code&gt; 的元素将始终被渲染并保留在DOM中； &lt;code&gt;v-show&lt;/code&gt; 仅切换元素的 &lt;code&gt;display&lt;/code&gt; CSS属性。</target>
        </trans-unit>
        <trans-unit id="9beac5c57d068b893c427afee540acec4a448457" translate="yes" xml:space="preserve">
          <source>The direct child components of the current instance. &lt;strong&gt;Note there&amp;rsquo;s no order guarantee for &lt;code&gt;$children&lt;/code&gt;, and it is not reactive.&lt;/strong&gt; If you find yourself trying to use &lt;code&gt;$children&lt;/code&gt; for data binding, consider using an Array and &lt;code&gt;v-for&lt;/code&gt; to generate child components, and use the Array as the source of truth.</source>
          <target state="translated">当前实例的直接子组件。&lt;strong&gt;请注意，没有 &lt;code&gt;$children&lt;/code&gt; 订单保证，并且它不是被动的。&lt;/strong&gt;如果发现自己试图使用 &lt;code&gt;$children&lt;/code&gt; 进行数据绑定，请考虑使用Array和 &lt;code&gt;v-for&lt;/code&gt; 生成子组件，然后将Array用作真相来源。</target>
        </trans-unit>
        <trans-unit id="8966ad2384af724eb5afaebd84955178e2bef331" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;v-if&lt;/code&gt; is used to conditionally render a block. The block will only be rendered if the directive&amp;rsquo;s expression returns a truthy value.</source>
          <target state="translated">指令 &lt;code&gt;v-if&lt;/code&gt; 用于有条件地渲染块。仅当指令的表达式返回真实值时，才会渲染该块。</target>
        </trans-unit>
        <trans-unit id="a9e1b62f46f6347c3255105bf2f7f7bb4beb980e" translate="yes" xml:space="preserve">
          <source>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the &lt;code&gt;v-html&lt;/code&gt; directive:</source>
          <target state="translated">双胡须将数据解释为纯文本，而不是HTML。为了输出实际的HTML，您将需要使用 &lt;code&gt;v-html&lt;/code&gt; 指令：</target>
        </trans-unit>
        <trans-unit id="cdf9489100840a3b7f6fc331943b5d3351ce62f0" translate="yes" xml:space="preserve">
          <source>The easiest way to pre-compile templates is using &lt;a href=&quot;single-file-components&quot;&gt;Single-File Components&lt;/a&gt; - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</source>
          <target state="translated">预编译模板的最简单方法是使用&amp;ldquo; &lt;a href=&quot;single-file-components&quot;&gt;单个文件组件&amp;rdquo;&lt;/a&gt; -关联的构建设置会自动为您执行预编译，因此，已构建的代码包含已编译的渲染函数，而不是原始模板字符串。</target>
        </trans-unit>
        <trans-unit id="75f9865708d8a06fa846e682702658bdabd9c8e0" translate="yes" xml:space="preserve">
          <source>The easiest way to try out Vue.js is using the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World example&lt;/a&gt;. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;create an &lt;code&gt;index.html&lt;/code&gt; file&lt;/a&gt; and include Vue with:</source>
          <target state="translated">试用Vue.js的最简单方法是使用&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World示例&lt;/a&gt;。随意在另一个选项卡中打开它，然后按照一些基本示例进行操作。或者，您可以&lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;创建一个 &lt;code&gt;index.html&lt;/code&gt; 文件，&lt;/a&gt;并在Vue中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="847757f66edc351ea14e3e7f70aa130ed1b67ad7" translate="yes" xml:space="preserve">
          <source>The el option can no longer be used in &lt;code&gt;Vue.extend&lt;/code&gt;. It&amp;rsquo;s only valid as an instance creation option.</source>
          <target state="translated">el选项不能再在 &lt;code&gt;Vue.extend&lt;/code&gt; 中使用。仅作为实例创建选项有效。</target>
        </trans-unit>
        <trans-unit id="14ff2ebab179926c1bba713b3418f8fa507384ca" translate="yes" xml:space="preserve">
          <source>The filter&amp;rsquo;s function always receives the expression&amp;rsquo;s value (the result of the former chain) as its first argument. In the above example, the &lt;code&gt;capitalize&lt;/code&gt; filter function will receive the value of &lt;code&gt;message&lt;/code&gt; as its argument.</source>
          <target state="translated">过滤器的功能始终将表达式的值（前一个链的结果）作为其第一个参数。在上面的示例中，大 &lt;code&gt;capitalize&lt;/code&gt; 滤器函数将接收 &lt;code&gt;message&lt;/code&gt; 的值作为其参数。</target>
        </trans-unit>
        <trans-unit id="25978631002a6e912099e352f219ba34c4dc10cb" translate="yes" xml:space="preserve">
          <source>The filtered list will &lt;em&gt;only&lt;/em&gt; be re-evaluated if there are relevant changes to the &lt;code&gt;users&lt;/code&gt; array, making filtering much more efficient.</source>
          <target state="translated">&lt;em&gt;仅&lt;/em&gt;当 &lt;code&gt;users&lt;/code&gt; 数组有相关更改时，&lt;em&gt;才会&lt;/em&gt;重新评估过滤后的列表，从而使过滤更加有效。</target>
        </trans-unit>
        <trans-unit id="b5951356bec324133fa39def8def2ef7e47b05c1" translate="yes" xml:space="preserve">
          <source>The following template:</source>
          <target state="translated">以下模板:</target>
        </trans-unit>
        <trans-unit id="6e4a514c82bb3b7baff7919684302ede3370a422" translate="yes" xml:space="preserve">
          <source>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; for a more inspection-friendly interface.</source>
          <target state="translated">该getter / setter对用户是不可见的，但是在内部，它们使Vue在访问或修改属性时能够执行依赖项跟踪和更改通知。一个警告是浏览器控制台在记录转换后的数据对象时格式化getter / setter的方式不同，因此您可能希望安装&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;以提供更友好的检查界面。</target>
        </trans-unit>
        <trans-unit id="8cd9d811837e0eecf0a4df368877b6262fe04425" translate="yes" xml:space="preserve">
          <source>The implicitly assigned &lt;code&gt;$index&lt;/code&gt; and &lt;code&gt;$key&lt;/code&gt; variables have been removed in favor of explicitly defining them in &lt;code&gt;v-for&lt;/code&gt;. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.</source>
          <target state="translated">删除了隐式分配的 &lt;code&gt;$index&lt;/code&gt; 和 &lt;code&gt;$key&lt;/code&gt; 变量，以便在 &lt;code&gt;v-for&lt;/code&gt; 中显式定义它们。对于那些对Vue缺乏经验的开发人员来说，这使代码更易于阅读，并且在处理嵌套循环时还可以使行为更清晰。</target>
        </trans-unit>
        <trans-unit id="cd591127230d8deaf3a79ff7072473dcdfb326ef" translate="yes" xml:space="preserve">
          <source>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</source>
          <target state="translated">用于当前Vue实例的实例化选项。当您想在选项中包含自定义属性时,这很有用。</target>
        </trans-unit>
        <trans-unit id="6507e95ac3123f38dc39170ae522dfbce1786b53" translate="yes" xml:space="preserve">
          <source>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the &lt;code&gt;v-on&lt;/code&gt; attribute isn&amp;rsquo;t feasible. That&amp;rsquo;s why &lt;code&gt;v-on&lt;/code&gt; can also accept the name of a method you&amp;rsquo;d like to call.</source>
          <target state="translated">但是，许多事件处理程序的逻辑将更加复杂，因此将JavaScript保持在 &lt;code&gt;v-on&lt;/code&gt; 属性的值中是不可行的。这就是为什么 &lt;code&gt;v-on&lt;/code&gt; 也可以接受您要调用的方法的名称的原因。</target>
        </trans-unit>
        <trans-unit id="a7dfd0134284048bc632e36141f4ea3e7333c213" translate="yes" xml:space="preserve">
          <source>The match is first checked on the component&amp;rsquo;s own &lt;code&gt;name&lt;/code&gt; option, then its local registration name (the key in the parent&amp;rsquo;s &lt;code&gt;components&lt;/code&gt; option) if the &lt;code&gt;name&lt;/code&gt; option is not available. Anonymous components cannot be matched against.</source>
          <target state="translated">首先在组件自己的 &lt;code&gt;name&lt;/code&gt; 选项上检查匹配项，然后在 &lt;code&gt;name&lt;/code&gt; 选项不可用时检查其本地注册名称（父项 &lt;code&gt;components&lt;/code&gt; 选项中的键）。匿名组件无法匹配。</target>
        </trans-unit>
        <trans-unit id="a6157926048113f46fe23ee578e48fe424291d8e" translate="yes" xml:space="preserve">
          <source>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</source>
          <target state="translated">缓存的组件实例的最大数量。一旦达到这个数量,在创建新的实例之前,最近访问最少的缓存组件实例将被销毁。</target>
        </trans-unit>
        <trans-unit id="8bf10a52fb597971ee2811a4b6daca68eb87e10e" translate="yes" xml:space="preserve">
          <source>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</source>
          <target state="translated">合并策略分别接收在父实例和子实例上定义的那个选项的值作为第一个和第二个参数。上下文Vue实例作为第三个参数传递。</target>
        </trans-unit>
        <trans-unit id="7f5a003cef802af9e91a6f9747fac2e515359d41" translate="yes" xml:space="preserve">
          <source>The method returns the instance itself so you can chain other instance methods after it.</source>
          <target state="translated">该方法返回实例本身,所以你可以在它之后连锁其他实例方法。</target>
        </trans-unit>
        <trans-unit id="46eb4e33843509639b8c44662beadd21ed8310ed" translate="yes" xml:space="preserve">
          <source>The most basic form of data binding is text interpolation using the &amp;ldquo;Mustache&amp;rdquo; syntax (double curly braces):</source>
          <target state="translated">数据绑定的最基本形式是使用&amp;ldquo; Mustache&amp;rdquo;语法（双花括号）的文本插值：</target>
        </trans-unit>
        <trans-unit id="bd564c73b6d49eec1b2c8919fa49f3bc33098a11" translate="yes" xml:space="preserve">
          <source>The most common use case is combined with &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">最常见的用例是与 &lt;code&gt;v-for&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="c379b64d918d58c59f406c013a50f15fd94aaa4c" translate="yes" xml:space="preserve">
          <source>The mustache tag will be replaced with the value of the &lt;code&gt;msg&lt;/code&gt; property on the corresponding data object. It will also be updated whenever the data object&amp;rsquo;s &lt;code&gt;msg&lt;/code&gt; property changes.</source>
          <target state="translated">小胡子标记将替换为相应数据对象上的 &lt;code&gt;msg&lt;/code&gt; 属性的值。每当数据对象的 &lt;code&gt;msg&lt;/code&gt; 属性更改时，它也会被更新。</target>
        </trans-unit>
        <trans-unit id="37afbe4bcd06f0f0be230e6d8e06d5f57d026a3e" translate="yes" xml:space="preserve">
          <source>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or &lt;a href=&quot;single-file-components&quot;&gt;single-file component&lt;/a&gt;), we strongly recommend following the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C rules&lt;/a&gt; for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</source>
          <target state="translated">您给组件指定的名称可能取决于您打算在哪里使用它。当直接在DOM中使用组件（而不是在字符串模板或&lt;a href=&quot;single-file-components&quot;&gt;单一文件组件中&lt;/a&gt;）时，我们强烈建议您遵循&lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C规则&lt;/a&gt;中的自定义标记名称（全部小写，必须包含连字符）。这有助于您避免与当前和将来的HTML元素冲突。</target>
        </trans-unit>
        <trans-unit id="49544b57b4faf031cbd490df14c62342f8913c7c" translate="yes" xml:space="preserve">
          <source>The new, more concise way to configure &lt;code&gt;keyCodes&lt;/code&gt; is through &lt;code&gt;Vue.config.keyCodes&lt;/code&gt;. For example:</source>
          <target state="translated">新的，更简洁的配置 &lt;code&gt;keyCodes&lt;/code&gt; 的方法是通过 &lt;code&gt;Vue.config.keyCodes&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="1ba4a8191026a27a782703cf2cb8992c45a25eab" translate="yes" xml:space="preserve">
          <source>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the &lt;code&gt;props&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt; initialization.</source>
          <target state="translated">接下来的2个示例适用于Vue 2.2.1+。在该版本以下，在 &lt;code&gt;props&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 初始化之后解析注入的值。</target>
        </trans-unit>
        <trans-unit id="c4e0ddfdd8217a03837dee9d518c520c1cff551b" translate="yes" xml:space="preserve">
          <source>The next thing you&amp;rsquo;ll have to become familiar with is how to use template features in the &lt;code&gt;createElement&lt;/code&gt; function. Here are the arguments that &lt;code&gt;createElement&lt;/code&gt; accepts:</source>
          <target state="translated">您必须熟悉的下一件事是如何在 &lt;code&gt;createElement&lt;/code&gt; 函数中使用模板功能。以下是 &lt;code&gt;createElement&lt;/code&gt; 接受的参数：</target>
        </trans-unit>
        <trans-unit id="a93809e131de1acb92c27480b98ade7c8b177368" translate="yes" xml:space="preserve">
          <source>The object syntax for &lt;code&gt;v-bind:style&lt;/code&gt; is pretty straightforward - it looks almost like CSS, except it&amp;rsquo;s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 的对象语法非常简单-看起来几乎像CSS，只是它是一个JavaScript对象。您可以使用camelCase或kebab-case（在kebab-case中使用引号）作为CSS属性名称：</target>
        </trans-unit>
        <trans-unit id="f804d7c199bb60087ee99a4d2ed2841ff111fad8" translate="yes" xml:space="preserve">
          <source>The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</source>
          <target state="translated">官方指南假设你具备HTML、CSS和JavaScript的中级知识。如果你是一个完全陌生的前端开发,那么直接跳进一个框架作为你的第一步可能不是最好的主意--先掌握基础知识,然后再回来。有其他框架的经验会有帮助,但不是必须的。</target>
        </trans-unit>
        <trans-unit id="cdcd3cc5d3cb2f01160d1290fc4a6159e0dddd79" translate="yes" xml:space="preserve">
          <source>The only exception to this being the use of &lt;code&gt;Object.freeze()&lt;/code&gt;, which prevents existing properties from being changed, which also means the reactivity system can&amp;rsquo;t &lt;em&gt;track&lt;/em&gt; changes.</source>
          <target state="translated">唯一的例外是使用 &lt;code&gt;Object.freeze()&lt;/code&gt; ，它可以防止更改现有属性，这也意味着反应系统无法&lt;em&gt;跟踪&lt;/em&gt;更改。</target>
        </trans-unit>
        <trans-unit id="8eb7f5feed0a750d304ea8614d2edca774bd3f41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;scoped&lt;/code&gt; attribute automatically scopes this CSS to your component by adding a unique attribute (such as &lt;code&gt;data-v-21e5b78&lt;/code&gt;) to elements and compiling &lt;code&gt;.list-container:hover&lt;/code&gt; to something like &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;scoped&lt;/code&gt; 属性通过在元素上添加唯一属性（例如 &lt;code&gt;data-v-21e5b78&lt;/code&gt; ）并将 &lt;code&gt;.list-container:hover&lt;/code&gt; 编译为 &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt; 类的元素，从而自动将CSS的范围限制在您的组件上：悬停。</target>
        </trans-unit>
        <trans-unit id="8f86e91201591c3c1631acf2b2475e6e451afce5" translate="yes" xml:space="preserve">
          <source>The parent instance, if the current instance has one.</source>
          <target state="translated">父实例,如果当前实例有的话。</target>
        </trans-unit>
        <trans-unit id="a213359cc7f926ecae5256c14d1f382a33b06e44" translate="yes" xml:space="preserve">
          <source>The problem is event flows that depend on a component&amp;rsquo;s tree structure can be hard to reason about and are very brittle when the tree becomes large. They don&amp;rsquo;t scale well and only set you up for pain later. &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; also do not solve communication between sibling components.</source>
          <target state="translated">问题在于依赖于组件树结构的事件流很难推理，并且当树变大时会变得非常脆弱。他们的伸缩性不好，只会在以后让您痛苦。 &lt;code&gt;$dispatch&lt;/code&gt; 和 &lt;code&gt;$broadcast&lt;/code&gt; 也不能解决同级组件之间的通信。</target>
        </trans-unit>
        <trans-unit id="98399a72800d5002678971cac53da1533e26a6d2" translate="yes" xml:space="preserve">
          <source>The problem is that large numbers of &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;element-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;) will be considerably slower than &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;class-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt;), so class selectors should be preferred whenever possible.</source>
          <target state="translated">问题在于大量的&lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;元素属性选择器&lt;/a&gt;（例如 &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ）比&lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;类属性选择器&lt;/a&gt;（例如 &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt; ）要慢得多，因此类选择器应该尽可能被优先使用。</target>
        </trans-unit>
        <trans-unit id="3bc4b51815e1ca75817d438f9a75b79de4143526" translate="yes" xml:space="preserve">
          <source>The problem is, there are also many &lt;em&gt;simple&lt;/em&gt; cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</source>
          <target state="translated">问题是，在许多&lt;em&gt;简单的&lt;/em&gt;情况下，这些模式可能会带来便利。当心：不要为了短期的方便（编写更少的代码）而陷入交易简单（能够理解您的状态流程）。</target>
        </trans-unit>
        <trans-unit id="690eaa8b769a27585770a32b044820cae46112dd" translate="yes" xml:space="preserve">
          <source>The problem is, there are cases where it&amp;rsquo;s important not to delete elements that will remain in the DOM. For example, you may want to use &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; to animate list sorting, or maintain focus if the rendered element is an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In these cases, adding a unique key for each item (e.g. &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt;) will tell Vue how to behave more predictably.</source>
          <target state="translated">问题是，在某些情况下，重要的是不要删除将保留在DOM中的元素。例如，您可能想使用 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 来动画列表排序，或者如果呈现的元素是 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 则保持焦点。在这些情况下，为每个项目添加唯一键（例如 &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt; ）将告诉Vue如何更可预测地表现。</target>
        </trans-unit>
        <trans-unit id="35549fb2854bdbc4b65652d62df1f1ddfa7a99ea" translate="yes" xml:space="preserve">
          <source>The problem is, this button doesn&amp;rsquo;t do anything:</source>
          <target state="translated">问题是，此按钮不执行任何操作：</target>
        </trans-unit>
        <trans-unit id="361cd98689630fb5a124f5e83b5f388af1b8a1f3" translate="yes" xml:space="preserve">
          <source>The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所提供的元件仅用作安装点。与Vue 1.x不同，在所有情况下，已安装的元素都将被Vue生成的DOM替换。因此，不建议将根实例安装到 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34592f5fd4a2054ce0011f9d4e26a9c654b6f7b5" translate="yes" xml:space="preserve">
          <source>The reason for not automatically injecting &lt;code&gt;item&lt;/code&gt; into the component is because that makes the component tightly coupled to how &lt;code&gt;v-for&lt;/code&gt; works. Being explicit about where its data comes from makes the component reusable in other situations.</source>
          <target state="translated">不自动将 &lt;code&gt;item&lt;/code&gt; 注入组件的原因是，这使组件与 &lt;code&gt;v-for&lt;/code&gt; 的工作方式紧密相关。明确说明其数据来自何处使得该组件可在其他情况下重用。</target>
        </trans-unit>
        <trans-unit id="c532c908704eacdd705ddb6c7847a0bd40253f67" translate="yes" xml:space="preserve">
          <source>The reason is this is the equivalent JavaScript that the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; would compile to:</source>
          <target state="translated">原因是这是 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 编译为的等效JavaScript ：</target>
        </trans-unit>
        <trans-unit id="78702fdec5c6b73fa78a98283262c3e3a610ea89" translate="yes" xml:space="preserve">
          <source>The reference will be HTMLElement when used with functional components because they&amp;rsquo;re stateless and instanceless.</source>
          <target state="translated">与功能组件一起使用时，该引用将为HTMLElement，因为它们是无状态且无实例的。</target>
        </trans-unit>
        <trans-unit id="c0c42bbffd6116ac9f9aa2c29f718360da13a0c7" translate="yes" xml:space="preserve">
          <source>The rendered HTML will be:</source>
          <target state="translated">呈现的HTML将是:</target>
        </trans-unit>
        <trans-unit id="a426ede2112c009fbf616db449e0c6e3bc884e8e" translate="yes" xml:space="preserve">
          <source>The result is that many components may include long lists of base components:</source>
          <target state="translated">其结果是,许多组件可能包括长长的基础组件列表。</target>
        </trans-unit>
        <trans-unit id="0894c1243efd2b6757cc56c901b4af230a9aac04" translate="yes" xml:space="preserve">
          <source>The returned object can be used directly inside &lt;a href=&quot;../guide/render-function&quot;&gt;render functions&lt;/a&gt; and &lt;a href=&quot;../guide/computed&quot;&gt;computed properties&lt;/a&gt;, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</source>
          <target state="translated">返回的对象可以直接在&lt;a href=&quot;../guide/render-function&quot;&gt;渲染函数&lt;/a&gt;和&lt;a href=&quot;../guide/computed&quot;&gt;计算的属性中使用&lt;/a&gt;，并且在发生突变时将触发适当的更新。对于简单的情况，它也可以用作最小的跨组件状态存储：</target>
        </trans-unit>
        <trans-unit id="f5f2182d5b9e1141097f081f69203ed474e7f51a" translate="yes" xml:space="preserve">
          <source>The root DOM element that the Vue instance is managing.</source>
          <target state="translated">Vue实例管理的根DOM元素。</target>
        </trans-unit>
        <trans-unit id="1fb1fe84422a22a87a20ac9a9db7f5aca1ce36fc" translate="yes" xml:space="preserve">
          <source>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</source>
          <target state="translated">当前组件树的根Vue实例。如果当前实例没有父类,那么这个值就是它自己。</target>
        </trans-unit>
        <trans-unit id="7b232ff8c5c18691a5df8efcbaf774a1cbaab836" translate="yes" xml:space="preserve">
          <source>The same is true for class bindings:</source>
          <target state="translated">对于类绑定也是如此。</target>
        </trans-unit>
        <trans-unit id="dd2c503caba50c997d7446df74ac0da742e9b8eb" translate="yes" xml:space="preserve">
          <source>The size of your app (small to medium-sized apps will probably be less than a day)</source>
          <target state="translated">你的应用程序的大小(中小型应用程序可能会少于一天的时间</target>
        </trans-unit>
        <trans-unit id="71c2733bfb43f78b87500262cd44c42870815508" translate="yes" xml:space="preserve">
          <source>The special case to note here is the &lt;code&gt;data&lt;/code&gt; option - it must be a function when used with &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">这里要注意的特殊情况是 &lt;code&gt;data&lt;/code&gt; 选项-与 &lt;code&gt;Vue.extend()&lt;/code&gt; 一起使用时，它必须是一个函数。</target>
        </trans-unit>
        <trans-unit id="572f57cb3c88ad0c0b5d74b281c1e800b18bf5b8" translate="yes" xml:space="preserve">
          <source>The store instance no longer exposes the event emitter interface (&lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;emit&lt;/code&gt;). If you were previously using the store as a global event bus, &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;see this section&lt;/a&gt; for migration instructions.</source>
          <target state="translated">store实例不再公开事件发射器接口（ &lt;code&gt;on&lt;/code&gt; ， &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;emit&lt;/code&gt; ）。如果您以前将商店用作全局事件总线，&lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;请参阅本节&lt;/a&gt;中的迁移说明。</target>
        </trans-unit>
        <trans-unit id="77d67a6f8225d0df00a5fc5a901f8f424ef25e4a" translate="yes" xml:space="preserve">
          <source>The syntax has changed slightly, so &lt;code&gt;/category/*tags&lt;/code&gt; for example, should be updated to &lt;code&gt;/category/:tags+&lt;/code&gt;.</source>
          <target state="translated">语法稍有变化，因此 &lt;code&gt;/category/*tags&lt;/code&gt; 应该更新为 &lt;code&gt;/category/:tags+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="908884184f3cb4e8612386879bc128af52d0df9c" translate="yes" xml:space="preserve">
          <source>The target object cannot be a Vue instance, or the root data object of a Vue instance.</source>
          <target state="translated">目标对象不能是Vue实例,或者是Vue实例的根数据对象。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
