<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="be3c142060e44ba8c62b670b8883bcca7cd5a4cc" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read &lt;a href=&quot;component-provide-inject&quot;&gt;Provide / Inject&lt;/a&gt;, &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt;, and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b0a231c686d6b708f4d2d26c98389f653ba04e" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt; and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;. Read that first if you are new to Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a1f77be28de1f8cd112541c8e445f32b88426b" translate="yes" xml:space="preserve">
          <source>This guide is primarily for users with prior Vue 2 experience who want to learn about the new features and changes in Vue 3. &lt;strong&gt;This is not something you have to read from top to bottom before trying out Vue 3.&lt;/strong&gt; While it looks like a lot has changed, a lot of what you know and love about Vue is still the same; but we wanted to be as thorough as possible and provide detailed explanations and examples for every documented change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029497cad2c3a227399525b3094cb469885f9f59" translate="yes" xml:space="preserve">
          <source>This guide will provide an overview of different design elements that are available for your use in creating documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">它已被接受函数的&lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; 选项&lt;/a&gt;所代替，因此滚动行为是完全可自定义的-即使是按路线也是如此。这带来了许多新的可能性，但可以复制以下行为：</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">这已作为&lt;a href=&quot;../api/index#delimiters&quot;&gt;组件级选项&lt;/a&gt;进行了重新设计。这样，您就可以在应用程序内使用其他分隔符，而不会破坏第三方组件。</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">这很快就失控了。这就是为什么要向后代组件任意深度提供上下文信息的原因，我们建议使用&lt;a href=&quot;#Dependency-Injection&quot;&gt;依赖项注入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">这有两个潜在的问题。</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">这可以帮助你在需要编辑一个组件或回顾如何使用它时更快地找到它。</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">这种模块化程度的提高不仅使其更容易迁移到Vue 2,而且还可以使货币解析和格式化。</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">这是一个人为的示例，但是我们设法将我们的应用程序分成两个较小的单元，并且通过props接口将子级与父级很好地分离。现在，我们可以使用更复杂的模板和逻辑进一步改进 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 组件，而不会影响父应用程序。</target>
        </trans-unit>
        <trans-unit id="0656ba279b49d46a5cdfd7935d734273e07a9de6" translate="yes" xml:space="preserve">
          <source>This is a great tip to remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e19f220c4bd03c63d74d3c19c553f790da9b66d" translate="yes" xml:space="preserve">
          <source>This is a low-level internal API change and does not affect most developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">这绝对是指南中最难写的页面，但我们确实认为它很重要。奇怪的是，您遇到了要解决的问题，并且使用了另一个库来解决它们。您之所以在这里，是因为您想知道Vue是否可以更好地解决您的特定问题。这就是我们希望为您解答的。</target>
        </trans-unit>
        <trans-unit id="ac302dcb2061f99b9d2af5d1c922a8db1ee40057" translate="yes" xml:space="preserve">
          <source>This is especially important because of &lt;a href=&quot;v-on-native-modifier-removed&quot;&gt;the removal of the &lt;code&gt;.native&lt;/code&gt; modifier&lt;/a&gt;. Any listeners for events that aren't declared with &lt;code&gt;emits&lt;/code&gt; will now be included in the component's &lt;code&gt;$attrs&lt;/code&gt;, which by default will be bound to the component's root node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">现在，这是&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;路线定义&lt;/a&gt;的选项。因此，例如，您将更新：</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">现在，这是您要为其别名&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;的路由的定义选项&lt;/a&gt;。因此，例如，您将更新：</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">这通常很有用，因为即使使用 &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; ，HTML输入元素的值也始终返回字符串。如果无法使用 &lt;code&gt;parseFloat()&lt;/code&gt; 解析该值，则返回原始值。</target>
        </trans-unit>
        <trans-unit id="a70c72c5011c169a2c1648b6eacd7fc7b9c7fc32" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute (opens new window)&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM (opens new window)&lt;/a&gt;, or another library/convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">这仅与&lt;a href=&quot;../guide/single-file-components&quot;&gt;单文件组件有关&lt;/a&gt;。它&lt;em&gt;不&lt;/em&gt;要求该&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; 属性&lt;/a&gt;中。可以通过&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS模块&lt;/a&gt;，基于类的策略（例如&lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;）或其他库/约定来进行作用域设置。</target>
        </trans-unit>
        <trans-unit id="e3ecbb65364f0fdf669d68bae076b4de3385cb21" translate="yes" xml:space="preserve">
          <source>This is our starting point, except it's not working yet because our &lt;code&gt;repositories&lt;/code&gt; variable is not reactive. This means from a user's perspective, the repository list would remain empty. Let's fix that!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">这类似于 &lt;code&gt;mixins&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d606ea96e61ab331639ff4a07074c626da1c5c" translate="yes" xml:space="preserve">
          <source>This is something to be cautious of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1427909eab695a82c73616bf6ca58eaea604e27" translate="yes" xml:space="preserve">
          <source>This is something we do not recommend. Use at your own risk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">这是全局 &lt;code&gt;Vue.delete&lt;/code&gt; 的&lt;strong&gt;别名&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">这是全局 &lt;code&gt;Vue.set&lt;/code&gt; 的&lt;strong&gt;别名&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">这是进入较低级别的成本，但是与 &lt;code&gt;v-model&lt;/code&gt; 相比，它还使您可以更好地控制交互细节。</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">这是我们为组件选项推荐的默认顺序。它们分为几类，因此您将知道在何处添加自定义属性和指令。</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">这是我们为组件选项推荐的默认顺序。它们分为几类，因此您将知道在哪里可以从插件添加新属性。</target>
        </trans-unit>
        <trans-unit id="7a7f1cb949f47a835f88db5681466149b0c54598" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f223c43426961a4fb3c1457dda5eadb68ad78" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">这是Vue特定代码的官方样式指南。如果您在项目中使用Vue，这对于避免错误，自行车脱落和反模式很有用。但是，我们不认为任何样式指南都适合所有团队或项目，因此，基于过去的经验，周围的技术栈和个人价值观，鼓励谨慎的偏离。</target>
        </trans-unit>
        <trans-unit id="260db489520475eb4d9d940e59e1b8c6d90f9b1c" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dc851eaa2d4a0946dac12cbc41fef4c40d2c4e" translate="yes" xml:space="preserve">
          <source>This is the very essence of Vue's reactivity system. When you return an object from &lt;code&gt;data()&lt;/code&gt; in a component, it is internally made reactive by &lt;code&gt;reactive()&lt;/code&gt;. The template is compiled into a &lt;a href=&quot;render-function&quot;&gt;render function&lt;/a&gt; that makes use of these reactive properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">这就是一个例子的实际情况。</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">不过，这并不总是可取的，因此Vue为您提供了一种方式，您可以说：&amp;ldquo;这两个元素是完全分开的-不要重复使用它们。&amp;rdquo; 添加具有唯一值的 &lt;code&gt;key&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">不建议这样做，因为它会导致：</target>
        </trans-unit>
        <trans-unit id="82d553ff76c7a0d3860ad174bd983d0f26df9bc2" translate="yes" xml:space="preserve">
          <source>This isn't recommended, as it results in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">这样就可以对多个条件子项使用 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">这样就可以轻松重写内部样式，因为人类可读的类名虽然没有太高的特异性，但仍然不太可能导致冲突。</target>
        </trans-unit>
        <trans-unit id="6039ba72679e27c3de3fe59517757185e2ef8639" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5bca688970af00ecf6916734fc1be51e2996ec" translate="yes" xml:space="preserve">
          <source>This may be useful when you want to, for example, programmatically focus this input on component mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbccff00d4246ffaab0d554ac15f4da6d514888" translate="yes" xml:space="preserve">
          <source>This means you &lt;strong&gt;can&lt;/strong&gt; install/import these deps individually without ending up with different instances of these dependencies, but you must make sure they all resolve to the same version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">在调用 &lt;code&gt;new Vue()&lt;/code&gt; 之前必须调用此方法</target>
        </trans-unit>
        <trans-unit id="d0ddd876bb6fb1b94f32ad08f1b3a4e6d7b7cb98" translate="yes" xml:space="preserve">
          <source>This method should not be confused with the &lt;a href=&quot;options-composition#provide-inject&quot;&gt;provide component option&lt;/a&gt; or the &lt;a href=&quot;composition-api#provide-inject&quot;&gt;provide function&lt;/a&gt; in the composition API. While those are also part of the same &lt;code&gt;provide&lt;/code&gt;/&lt;code&gt;inject&lt;/code&gt; mechanism, they are used to configure values provided by a component rather than an application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbaf50c98606e0673b924b093900524e24db8aeb" translate="yes" xml:space="preserve">
          <source>This might be helpful when we have an HTML element with &lt;code&gt;change&lt;/code&gt; event as a root element of &lt;code&gt;date-picker&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90aee8ca6c8b63ccbcb1d903920d255bfac3961" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP (opens new window)&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">这看起来像是魔术，但在幕后，Vue正在使用一种称为&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt;的动画技术，通过变换将元素从旧位置平滑过渡到新位置。</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">这不仅会记录您的组件，而且还会在用户传递错误的类型时在浏览器的JavaScript控制台中警告用户。您将在此页面的后面进一步了解&lt;a href=&quot;#Prop-Validation&quot;&gt;类型检查和其他prop验证&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2eede98c99888e9e8fb70ceb48eb9cdf213e42e5" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about &lt;a href=&quot;#prop-validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">由于Vue的过渡系统具有显式的&lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; 过渡控制&lt;/a&gt;，因此不再需要此选项。</target>
        </trans-unit>
        <trans-unit id="dda8e2bba6581f8fe39ba87ae1f467605782e672" translate="yes" xml:space="preserve">
          <source>This page applies only to Vue 2.x and below, and assumes you've already read the &lt;a href=&quot;reactivity&quot;&gt;Reactivity Section&lt;/a&gt;. Please read that section first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">该页面假定您已经阅读了&lt;a href=&quot;components&quot;&gt;组件基础知识&lt;/a&gt;。如果您不熟悉组件，请先阅读该内容。</target>
        </trans-unit>
        <trans-unit id="2f257c4f8981d39250383dd3af755f3faa35ddba" translate="yes" xml:space="preserve">
          <source>This page assumes you've already read the &lt;a href=&quot;component-basics&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e672f7510e855eb83e9a420fd1aab887fa1937" translate="yes" xml:space="preserve">
          <source>This page is not required reading in order to learn how to use Vue well, but it provides more information, should you be curious how rendering works under the hood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">这对选项一起使用，以使祖先组件可以用作其所有后代的依赖项注入器，而不管组件层次结构有多深，只要它们在同一父链中即可。如果您熟悉React，这与React的上下文功能非常相似。</target>
        </trans-unit>
        <trans-unit id="2a14bf9014246214857ff883acbf4909435d0e01" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's &lt;code&gt;context&lt;/code&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">这会将 &lt;code&gt;doc&lt;/code&gt; 对象中的每个属性（例如 &lt;code&gt;title&lt;/code&gt; ）作为一个单独的属性传递，然后为每个属性添加 &lt;code&gt;v-on&lt;/code&gt; 更新侦听器。</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">这种模式允许你使用基础组件,更像原始的HTML元素,而不必关心哪个元素实际上是它的根。</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">在简单的情况下，该模式可以代替 &lt;code&gt;$dispatch&lt;/code&gt; 和 &lt;code&gt;$broadcast&lt;/code&gt; ，但是对于更复杂的情况，建议使用专用的状态管理层，例如&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3bcacf748b9af6a54554db3c2d36be4ed02362a9" translate="yes" xml:space="preserve">
          <source>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5586c0722db91f034d221a64e55d5829bf071baf" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c88f592f793e32dd9e76308d4a6ba8bd42fb51" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">本部分假定您具有&lt;a href=&quot;components&quot;&gt;Components的&lt;/a&gt;知识。随时跳过它，稍后再回来。</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">本部分假定您了解&lt;a href=&quot;components&quot;&gt;Vue组件&lt;/a&gt;。随时跳过它，稍后再回来。</target>
        </trans-unit>
        <trans-unit id="fb5b15406f75921e192409d91ff1b17d27fd994a" translate="yes" xml:space="preserve">
          <source>This section contains the search functionality for the application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b7709525d03239edb056d669680878e9735ae" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd61b2e32ea112a3e4dcdeb333fabe9dfc18a2f7" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f775635fcd735f353cd0996d158644d66269c8fe" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; and makes outputting &lt;code&gt;aria-*&lt;/code&gt; attributes easier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df51509bdf6631bdbd029391b7a92d14a5f11a4f" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between normal non-boolean attributes and &amp;ldquo;enumerated attributes&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34f69dcd5eb3d4acee6efe3176754e358fc43d6" translate="yes" xml:space="preserve">
          <source>This template doesn't feel great. It's not only verbose, but we're duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level. And when we add the anchor element, we have to again duplicate it in every &lt;code&gt;v-if/v-else-if&lt;/code&gt; branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2671e140fbe7037587dd494d52b8c4c16af6fa" translate="yes" xml:space="preserve">
          <source>This term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it&amp;rsquo;s a great one, is an Excel spreadsheet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da345bd2efafe0aab297aeb02da75f10e9617d3e" translate="yes" xml:space="preserve">
          <source>This will allow you to check all the events that a component emits and optionally &lt;a href=&quot;component-custom-events#validate-emitted-events&quot;&gt;validate them&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cf660900b36fb7082d6da4112e034f7880c495" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but &lt;code&gt;activeClass&lt;/code&gt; will only be applied when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">这将始终适用 &lt;code&gt;errorClass&lt;/code&gt; ，但只适用 &lt;code&gt;activeClass&lt;/code&gt; 当 &lt;code&gt;isActive&lt;/code&gt; 是truthy。</target>
        </trans-unit>
        <trans-unit id="c7c41413208280e0438efd8becdf4788ac79009e" translate="yes" xml:space="preserve">
          <source>This will be a new top-level option in the Vue CLI config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">这将导致在使用具有这种限制的元素的组件时出现问题。例如:</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">这样就不行了。</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">这只会呈现浏览器支持的数组中的最后一个值。在此示例中，它将显示 &lt;code&gt;display: flex&lt;/code&gt; 用于支持非前缀版本的flexbox的浏览器。</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">这将呈现相同的结果。我们还可以绑定到返回对象的&lt;a href=&quot;computed&quot;&gt;计算属性&lt;/a&gt;。这是一种常见而强大的模式：</target>
        </trans-unit>
        <trans-unit id="d7b864922bd15ed63c01468766857939d0bedd4b" translate="yes" xml:space="preserve">
          <source>This will tell webpack to treat the Vue module as an external library and not bundle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">这很好用，但是需要注意以下几点：</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">这会将元素固定在页面顶部200px处。但是，如果遇到需要从左而不是从顶部固定元素的情况，会发生什么情况？在这里，可以根据每个组件实例更新的动态参数非常方便：</target>
        </trans-unit>
        <trans-unit id="3e3f2385e5295eb0996806c6e44de1cd3bf29c86" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af979b8150c4855a484c40f48bb6c2a78e8cf7" translate="yes" xml:space="preserve">
          <source>Though the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component can be wonderful for components entering and leaving, you can also activate an animation without mounting a component, by adding a conditional class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de901ca4a37c13bd513536f6104058a8ebeab4" translate="yes" xml:space="preserve">
          <source>Though this provided some convenience in terms of root instances having a shared state, this has led to confusion due to the fact that its only possible on the root instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e255605141c6fd6ae34a1f00f4a710389219fe6" translate="yes" xml:space="preserve">
          <source>Though you can achieve great effects for simple animation with the two handles the cubic-bezier ease offers, JavaScript allows multiple handles, and therefore, allows for much more variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3296891d857a3b88e24b3a8f562ed3941e52be8" translate="yes" xml:space="preserve">
          <source>Though you might have seen labels wrapping the input fields like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">因此，允许父组件将输入集中在 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 内部：</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">紧密耦合的组件名称</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;强烈建议使用&lt;/sup&gt;紧密耦合的组件名称&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="098024dc5537ca3623978ac7c0a6140ce39062b8" translate="yes" xml:space="preserve">
          <source>Timing</source>
          <target state="translated">Timing</target>
        </trans-unit>
        <trans-unit id="40b635fbbc82098772ee7e3177e62a9c14ea2014" translate="yes" xml:space="preserve">
          <source>Tips, Callouts, Alerts, and Line Highlights</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881f5e312126d5e8ea790db899552b0144c3c571" translate="yes" xml:space="preserve">
          <source>To access component instance properties, we need to convert &lt;code&gt;provide&lt;/code&gt; to be a function returning an object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19f5499c85a1ceeb0b480c98eff4e4346929cd2" translate="yes" xml:space="preserve">
          <source>To add line highlighting to your code blocks, you need to append the line number in curly braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddd888c6582ef9d6fa2ab28bf309c8d36b0be42" translate="yes" xml:space="preserve">
          <source>To add methods to a component instance we use the &lt;code&gt;methods&lt;/code&gt; option. This should be an object containing the desired methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20869228946fc9bfb3ec15b09cdff057ca44c507" translate="yes" xml:space="preserve">
          <source>To add reactivity between provided and injected values, we can use a &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;ref&lt;/a&gt; or &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; when providing a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0cfd696ee7275a932682ace8d519ee632cc69c" translate="yes" xml:space="preserve">
          <source>To add validation, the event is assigned a function that receives the arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call and returns a boolean to indicate whether the event is valid or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788042730e582de0e5c9cadbed06a9452fa7048a" translate="yes" xml:space="preserve">
          <source>To address these issues, we added a new way to organize code by logical concerns: the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">为了解决这个问题，Vue 为 &lt;code&gt;v-on&lt;/code&gt; 提供了&lt;strong&gt;事件修饰符&lt;/strong&gt;。回想一下修饰符是用点表示的指令后缀。</target>
        </trans-unit>
        <trans-unit id="1f82c84ad360cae69c196ca0363ef72d7d1df639" translate="yes" xml:space="preserve">
          <source>To also build &lt;code&gt;umd&lt;/code&gt; and &lt;code&gt;cjs&lt;/code&gt; modules we can simply add a few lines of configuration to our &lt;code&gt;rollup.config.js&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">要还检测对象内部的嵌套值更改，您需要在options参数中传递 &lt;code&gt;deep: true&lt;/code&gt; 。请注意，您无需这样做即可侦听Array突变。</target>
        </trans-unit>
        <trans-unit id="cce00248496d96a2067177aed26ff61ce35a2340" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don't need to do so to listen for array mutations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">从一个定义上来说，赋予生命的动画意味着栩栩如生。不幸的是，当设计师创建图标，徽标和吉祥物时，它们通常以图像或静态SVG的形式提供。因此，尽管GitHub的octocat，Twitter的鸟和许多其他徽标都类似于活物，但它们似乎并没有真正活着。</target>
        </trans-unit>
        <trans-unit id="8a3a9f59e5420390dc20b2d39b4aad21d989a106" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they're usually delivered as images or static SVGs. So although GitHub's octocat, Twitter's bird, and many other logos resemble living creatures, they don't really seem alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b12f0b2b03b56612ac89d3a0da0c957181b463" translate="yes" xml:space="preserve">
          <source>To apply and &lt;em&gt;automatically re-apply&lt;/em&gt; a side effect based on reactive state, we can use the &lt;code&gt;watchEffect&lt;/code&gt; method. It runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">为了避免呈现列表（如果应将其隐藏）（例如， &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ）。在这些情况下，将 &lt;code&gt;v-if&lt;/code&gt; 移动到容器元素（例如 &lt;code&gt;ul&lt;/code&gt; ， &lt;code&gt;ol&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11af8c48788875166f2c82baaf2047c13709005d" translate="yes" xml:space="preserve">
          <source>To avoid these problems, in Vue 3 we introduce&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f959a2209cc4ae6dde0fc52d270647a756227800" translate="yes" xml:space="preserve">
          <source>To change a model name, instead of a &lt;code&gt;model&lt;/code&gt; component option, now we can pass an &lt;em&gt;argument&lt;/em&gt; to &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f16b9b50a22626214a8a2ce30432a9dda3b421" translate="yes" xml:space="preserve">
          <source>To configure our build with Rollup we will need to create a &lt;code&gt;rollup.config.js&lt;/code&gt; file in the root of our project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f956073caa60e7478f9715ae3f9c555d2f8969" translate="yes" xml:space="preserve">
          <source>To create a VNode for a component, the first argument passed to &lt;code&gt;h&lt;/code&gt; should be the component itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a4ddff02308f2d46c7bfb2cc80ec93a6254881" translate="yes" xml:space="preserve">
          <source>To create a reactive state from a JavaScript object, we can use a &lt;code&gt;reactive&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">要处理警告2，可以使用 &lt;code&gt;splice&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">为了解释正在发生的事情，我们将我们的组件称为A和B。模块系统认为它需要A，但是首先A需要B，但是B需要A，但是A需要B，依此类推。它陷入了一个循环，不知道如何完全解决任何一个问题，而无需先解决另一个问题。要解决此问题，我们需要给模块系统一个可以说&amp;ldquo; A &lt;em&gt;最终&lt;/em&gt;需要B ，但不需要先解决B&amp;rdquo;的点。</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">过滤列表中的项目（例如 &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ）。在这些情况下，请用新的计算属性替换 &lt;code&gt;users&lt;/code&gt; ，该属性将返回您的过滤列表（例如 &lt;code&gt;activeUsers&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">要开始使用Vue，您需要熟悉HTML和ES5 JavaScript（即纯JavaScript）。借助这些基本技能，您可以在阅读&lt;a href=&quot;../index&quot;&gt;指南的&lt;/a&gt;不到一天的时间内开始构建非平凡的应用程序。</target>
        </trans-unit>
        <trans-unit id="776030a16d16967752ee7198797ade27b5d2a7fc" translate="yes" xml:space="preserve">
          <source>To get type inference for the arguments passed to &lt;code&gt;setup()&lt;/code&gt;, the use of &lt;a href=&quot;global-api#definecomponent&quot;&gt;defineComponent&lt;/a&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">为了给Vue一个提示，使其可以跟踪每个节点的身份，从而重用和重新排列现有元素，您需要为每个项目提供唯一的 &lt;code&gt;key&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="5fcb75ebf027b9d0a0175ff64ac67858b09230bc" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">为了帮助解决此问题，我们可以采用一种&lt;strong&gt;存储模式&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="6bab7ec362c384e83157e34842533353476c5f9b" translate="yes" xml:space="preserve">
          <source>To hide the link unless it is focused, you can add the following style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08b3c5e2c296cf501fe81d8b1fdad39e5bceb5" translate="yes" xml:space="preserve">
          <source>To keep the old behavior work, and as we will be coercing &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;'false'&lt;/code&gt;, in 3.x Vue developers need to make &lt;code&gt;v-bind&lt;/code&gt; expression resolve to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'false'&lt;/code&gt; for &lt;code&gt;contenteditable&lt;/code&gt; and &lt;code&gt;spellcheck&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">要了解有关程序化侦听器的更多信息，请查看&lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;事件实例方法&lt;/a&gt;的API 。</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">为了让TypeScript正确推断Vue组件选项中的类型，您需要使用 &lt;code&gt;Vue.component&lt;/code&gt; 或 &lt;code&gt;Vue.extend&lt;/code&gt; 定义组件：</target>
        </trans-unit>
        <trans-unit id="d5a0debe65b75107b626e13146620736020251e6" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;defineComponent&lt;/code&gt; global method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">为了让用户与您的应用进行交互，我们可以使用 &lt;code&gt;v-on&lt;/code&gt; 指令来附加事件侦听器，以在我们的Vue实例上调用方法：</target>
        </trans-unit>
        <trans-unit id="d33212d2502112422cf740d702a092d37f765943" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b795d5e4656eb47b1b382ba73bb73ecac50f9c6e" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;item&lt;/code&gt; available to the slot content provided by the parent, we can add a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element and bind it as an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">为了使 &lt;code&gt;user&lt;/code&gt; 可以访问父级中的广告位内容，我们可以将 &lt;code&gt;user&lt;/code&gt; 作为属性绑定到 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素：</target>
        </trans-unit>
        <trans-unit id="8d5ee521751945f607f368f2972a7a5e30916787" translate="yes" xml:space="preserve">
          <source>To make Composition API feature-complete compared to Options API, we also need a way to register lifecycle hooks inside &lt;code&gt;setup&lt;/code&gt;. This is possible thanks to several new functions exported from Vue. Lifecycle hooks on composition API have the same name as for Options API but are prefixed with &lt;code&gt;on&lt;/code&gt;: i.e. &lt;code&gt;mounted&lt;/code&gt; would look like &lt;code&gt;onMounted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">为了克服警告1，以下两项都将与 &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; ，但也会触发反应性系统中的状态更新：</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">要将内容从父级传递到命名插槽，请使用 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 上的特殊 &lt;code&gt;slot&lt;/code&gt; 属性（使用&lt;a href=&quot;#Named-Slots&quot;&gt;此处&lt;/a&gt;描述的 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 组件作为示例）：</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">若要使用渲染功能将范围化的插槽传递给子组件，请使用VNode数据中的 &lt;code&gt;scopedSlots&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">为了向命名插槽提供内容，我们可以在 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 上使用 &lt;code&gt;v-slot&lt;/code&gt; 指令，提供插槽名称作为 &lt;code&gt;v-slot&lt;/code&gt; 的参数：</target>
        </trans-unit>
        <trans-unit id="71b95472ceb5c02875dbc3b9d728b462388305b4" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we need to use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;'s argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">要接收传递到插槽的道具，父组件可以将 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 与 &lt;code&gt;slot-scope&lt;/code&gt; 属性一起使用（使用&lt;a href=&quot;#Scoped-Slots&quot;&gt;此处&lt;/a&gt;描述的 &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; 作为示例）：</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">对于范围样式，Vue向组件元素（例如 &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; )添加了唯一属性。然后修改选择器，以便仅选择具有此属性的匹配元素（例如 &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">为了解决此问题，Vue提供了 &lt;code&gt;$listeners&lt;/code&gt; 属性，其中包含在组件上使用的侦听器对象。例如：</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">要为我们的日期选择器插件指定一个主题,我们可能需要添加一个特定的类,就像这样。</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">要指定道具验证，您可以向对象提供对 &lt;code&gt;props&lt;/code&gt; 值的验证要求，而不是字符串数组。例如：</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">为了开始使用Vue 2.0向更强大的解决方案过渡，我们首先将这个过滤器包装在一个新的 &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; 组件中：</target>
        </trans-unit>
        <trans-unit id="69b37bec21337bb3fab748d90757734b339759ac" translate="yes" xml:space="preserve">
          <source>To take advantage of our newly created &lt;code&gt;esm&lt;/code&gt; module we need to add a few fields in our &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceeb4fc5def0e78eb9b247f42dfe35a650c1ee1" translate="yes" xml:space="preserve">
          <source>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">要在模板中使用这些组件，必须对其进行注册，以便Vue知道它们。组件注册有两种类型：&lt;strong&gt;global&lt;/strong&gt;和&lt;strong&gt;local&lt;/strong&gt;。到目前为止，我们仅使用 &lt;code&gt;Vue.component&lt;/code&gt; 在全球范围内注册了组件：</target>
        </trans-unit>
        <trans-unit id="c646dfddede1e8b816398b2a45bcbd049b84852a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we've only registered components globally, using the &lt;code&gt;component&lt;/code&gt; method of our app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">根据表达式值的真实性切换元素的 &lt;code&gt;display&lt;/code&gt; CSS属性。</target>
        </trans-unit>
        <trans-unit id="c759e0477d126a03e9d103eb8525e47fab0be4d4" translate="yes" xml:space="preserve">
          <source>Toggles the element's &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2062eeee29d80bbd790b6b1c6949a13f04e9706" translate="yes" xml:space="preserve">
          <source>Track the function that changes it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">跟踪运行时错误</target>
        </trans-unit>
        <trans-unit id="a176cdd957b46dda003cee3ad2c254dd6615b0eb" translate="yes" xml:space="preserve">
          <source>Transform and Opacity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">过渡 &lt;code&gt;stagger&lt;/code&gt; 属性&lt;sup&gt;已删除&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="da0592cf78795180a4901cee778a25e6a87d50a4" translate="yes" xml:space="preserve">
          <source>Transition Class Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">过渡类</target>
        </trans-unit>
        <trans-unit id="e11311738d4c6ffea274c409ecdda9e0756654ab" translate="yes" xml:space="preserve">
          <source>Transition Group Root Element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">过渡模式</target>
        </trans-unit>
        <trans-unit id="c63dd8b039c9bc74f39dc660f1a5dd0332bdb933" translate="yes" xml:space="preserve">
          <source>Transition Modes so that you can orchestrate ordering during a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">组件之间的过渡</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">元素之间的过渡</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">过渡性单一元素/组件</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">组件之间的转换更加简单-我们甚至不需要 &lt;code&gt;key&lt;/code&gt; 属性。相反，我们包装了一个&lt;a href=&quot;components#Dynamic-Components&quot;&gt;动态组件&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3ebf68016515c38ab5d5bb14e02906e976906a37" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don't even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;component-basics#dynamic-components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e93cce4e6bbda7187841b2d8bb8c9ea9bb591d" translate="yes" xml:space="preserve">
          <source>Transitioning different states in an application, with &lt;code&gt;watchers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">转换可以通过Vue的组件系统重复使用。要创建可重用的过渡，您要做的就是在根目录下放置 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 组件，然后将任何子代传递到该过渡组件中。</target>
        </trans-unit>
        <trans-unit id="3389419ab0dc8619c42e92046a205d6cbaad10df" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue's component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">初始渲染的过渡</target>
        </trans-unit>
        <trans-unit id="ea9b9a14750b0c53f7e4ae9826cc61972586d91e" translate="yes" xml:space="preserve">
          <source>Transitions with Style Bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">翻译文件</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">在当前实例上触发事件。任何其他参数都将传递到侦听器的回调函数中。</target>
        </trans-unit>
        <trans-unit id="ff7ce3c92d4d6dbb6b2b78de21280fe459138d0f" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc40b121c3b5e2b8c970420d2e421c9a7ed7cd" translate="yes" xml:space="preserve">
          <source>Trigger the function so it can update the final value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">触发转换</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">触发 &lt;code&gt;beforeDestroy&lt;/code&gt; 和 &lt;code&gt;destroyed&lt;/code&gt; 钩子。</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 真实性/虚假性已&lt;sup&gt;更改&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">试试这个关于Scrimba的课程</target>
        </trans-unit>
        <trans-unit id="32ae11a86cc97e517601b6c7e4ad185de28233ca" translate="yes" xml:space="preserve">
          <source>Try to change the value of &lt;code&gt;books&lt;/code&gt; array in the application &lt;code&gt;data&lt;/code&gt; and you will see how &lt;code&gt;publishedBooksMessage&lt;/code&gt; is changing accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">开启生产模式</target>
        </trans-unit>
        <trans-unit id="6ad6b070d8858ef9034c2b27714131daa17dc2f1" translate="yes" xml:space="preserve">
          <source>Two of the most commonly used directives in Vue.js are &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;. So it's no surprise that there comes a time when developers want to use both together. While this is not a recommended practice, there may be times when this is necessary, so we wanted to provide guidance for how it works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">双向过滤器已&lt;sup&gt;更换&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">类型检查</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">支持TypeScript</target>
        </trans-unit>
        <trans-unit id="8170f1ce20dc21f163cf51322861b52a4e97389f" translate="yes" xml:space="preserve">
          <source>TypeScript should be able to infer most of the types without defining types explicitly. For example, if you have a component with a number &lt;code&gt;count&lt;/code&gt; property, you will have an error if you try to call a string-specific method on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55ceb4ee3907ab73fac7e8e26ce07c11d3e0af7" translate="yes" xml:space="preserve">
          <source>Typically this is done on the top of &lt;code&gt;App.vue&lt;/code&gt; as it will be the first focusable element on all your pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c49cff5528c3adc7123ea4b4bd10c092f423a6" translate="yes" xml:space="preserve">
          <source>Typically this is used to avoid conflicting with server-side frameworks that also use mustache syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5614fd83d7c12176ea9d23d0a9a55af15cb1297f" translate="yes" xml:space="preserve">
          <source>Typing</source>
          <target state="translated">Typing</target>
        </trans-unit>
        <trans-unit id="008b2efd937ff1c3483ebcd86c95416cf9a4fc6a" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;computed&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b08374e53ad50d899f5b39f4b437e0d89dd152" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;reactive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78cd4e8a3266b63fc59c7788f1a2d9d235e682" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;refs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="57c74547c7338aa72bc084a3800f580c969f4939" translate="yes" xml:space="preserve">
          <source>Under no circumstances should 2 alerts be used next to one another, it's a sign that we're not able to explain context well enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">引擎盖下,Vue将模板编译成虚拟DOM渲染函数。结合反应性系统,Vue能够在应用状态发生变化时,智能地计算出需要重新渲染的最小数量的组件,并应用最小数量的DOM操作。</target>
        </trans-unit>
        <trans-unit id="1a1ce3521c0de87c0b96c0765bcfe6f68f1f6e9e" translate="yes" xml:space="preserve">
          <source>Understandable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">不幸的是，HTML不允许自定义元素是自动关闭的，只能是&lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;官方的&amp;ldquo; void&amp;rdquo;元素&lt;/a&gt;。这就是为什么只有在Vue的模板编译器可以在DOM之前到达模板然后提供DOM规范兼容的HTML时，才可以采用该策略的原因。</target>
        </trans-unit>
        <trans-unit id="98c83482c6886ad1473a05cf5f78dcfee5bc89dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn't allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &quot;void&quot; elements (opens new window)&lt;/a&gt;. That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">不幸的是，由于HTML不区分大小写，因此DOM模板仍必须使用kebab-case。</target>
        </trans-unit>
        <trans-unit id="b10a452c474e61495690e111a7011d55f17f26b9" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5fadc81ad6c9be68633a21c0b94f28044dc294" translate="yes" xml:space="preserve">
          <source>Unfortunately, with such a destructuring the reactivity for both properties would be lost. For such a case, we need to convert our reactive object to a set of refs. These refs will retain the reactive connection to the source object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="fa4ba8e0a89b5b3663d1a20fd16ffec2b04f9510" translate="yes" xml:space="preserve">
          <source>Unit testing a Vue application does not significantly differ from testing other types of applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fab82db2414bfb4495b150b0fb016a74e7217d8" translate="yes" xml:space="preserve">
          <source>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">除非您将组件散布到多个文件中（例如，使用&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;），否则React中的CSS作用域通常是通过CSS-in-JS解决方案（例如，&lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;样式组件&lt;/a&gt;，&lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;和&lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;情感&lt;/a&gt;）来完成的。这引入了一个新的面向组件的样式范例，该样式范例不同于常规的CSS创作过程。另外，尽管支持在构建时将CSS提取到单个样式表中，但是仍然普遍需要将运行时包含在捆绑软件中以使样式正常工作。虽然在构造样式时可以访问JavaScript的动态性，但折衷通常是增加包大小和运行时成本。</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">与 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 不同，它呈现一个实际元素：默认情况下为 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 。您可以更改使用 &lt;code&gt;tag&lt;/code&gt; 属性呈现的元素。</target>
        </trans-unit>
        <trans-unit id="a6acb74ac65b8a5066968b3279fd2e776accbabb" translate="yes" xml:space="preserve">
          <source>Unlike attributes, directives can't be passed to a different element with &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">与组件和道具不同，事件名称不提供任何自动大小写转换。而是，发出的事件的名称必须与用于侦听该事件的名称完全匹配。例如，如果发出一个camelCased事件名称：</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">与组件和道具不同，事件名称永远不会在JavaScript中用作变量或属性名称，因此没有理由使用camelCase或PascalCase。此外，DOM模板中的 &lt;code&gt;v-on&lt;/code&gt; 事件侦听器将自动转换为小写字母（由于HTML不区分大小写），因此 &lt;code&gt;v-on:myEvent&lt;/code&gt; 将变为 &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash;使 &lt;code&gt;myEvent&lt;/code&gt; 无法收听。</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">与1.x不同，这些 &lt;code&gt;$refs&lt;/code&gt; 是无反应的，因为它们是在渲染过程本身中注册/更新的。使它们具有反应性，每次更改都需要重复渲染。</target>
        </trans-unit>
        <trans-unit id="fcbebe457290f0fc4402b0c59876bcbdda0f2d4e" translate="yes" xml:space="preserve">
          <source>Unlike most of the application methods, &lt;code&gt;mount&lt;/code&gt; does not return the application. Instead it returns the root component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2884ecb559d2fe9248396c1892b61a7ac7c3279" translate="yes" xml:space="preserve">
          <source>Unlike single root node components, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If &lt;code&gt;$attrs&lt;/code&gt; are not bound explicitly, a runtime warning will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a11b676273740dcc6b273657283a0efe154b9e" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;component-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven't read about components yet, don't worry about this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">与其他修饰符（本机DOM事件专用）不同， &lt;code&gt;.once&lt;/code&gt; 修饰符也可以用于&lt;a href=&quot;components-custom-events&quot;&gt;组件事件&lt;/a&gt;。如果您尚未阅读有关组件的信息，那么现在就不必担心。</target>
        </trans-unit>
        <trans-unit id="d465ac61f7785357bc3939f874106ce910c0065e" translate="yes" xml:space="preserve">
          <source>Unmounts a root component of the application instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">在2.6.0+中更新。&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;有关&lt;/a&gt;使用 &lt;code&gt;slot-scope&lt;/code&gt; 属性的不赞成使用的语法，请参见此处。</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">在2.6.0+中更新。&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;有关&lt;/a&gt;使用 &lt;code&gt;slot&lt;/code&gt; 属性的不赞成使用的语法，请参见此处。</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">更新元素的 &lt;code&gt;innerHTML&lt;/code&gt; 。&lt;strong&gt;请注意，内容以纯HTML格式插入-不会被编译为Vue模板&lt;/strong&gt;。如果您发现自己尝试使用 &lt;code&gt;v-html&lt;/code&gt; 编写模板，请尝试通过使用组件来重新考虑解决方案。</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">更新元素的 &lt;code&gt;textContent&lt;/code&gt; 。如果需要更新 &lt;code&gt;textContent&lt;/code&gt; 的一部分，则应使用 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 插值。</target>
        </trans-unit>
        <trans-unit id="c0dca31a6bb9b094601cb2bf5c3fb308c6b17b07" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML (opens new window)&lt;/a&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56a36977305fbcc90290b7281ac8a8f0c3bd604" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent&quot;&gt;textContent (opens new window)&lt;/a&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;a href=&quot;../guide/template-syntax#text&quot;&gt;mustache interpolations&lt;/a&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c47365d1a0fe7112a5f7aa0465ebbfe1515656" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, we never have to do it manually. Instead, we tell Vue what HTML we want on the page, in a template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">有效地更新所有这些节点可能是很困难的,但值得庆幸的是,你永远不必手动操作。相反,你可以在一个模板中告诉Vue你想在页面上使用什么HTML。</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">升级路径</target>
        </trans-unit>
        <trans-unit id="ec1b871568c8f9b96404fba4999e4bb30bebeba0" translate="yes" xml:space="preserve">
          <source>Usage in Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4904a06bbdeb879018def05329454362a6b30d64" translate="yes" xml:space="preserve">
          <source>Usage inside &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a7118317b50bdd15b995e3d624b912b5b2b04f" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e644418d310386dee848ceb934d28e9af6afeacb" translate="yes" xml:space="preserve">
          <source>Usage on Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f552ba1fe9fac09e7847e64d87dc1587fbb26d11" translate="yes" xml:space="preserve">
          <source>Usage with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba388099a4f8ff3ba8295c16666928b0c410e2" translate="yes" xml:space="preserve">
          <source>Usage with Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74099084c0693149248e8ca16d0bd6b67bb5c59" translate="yes" xml:space="preserve">
          <source>Usage with Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ee016fea5ce9a71d77f20f1124659e54e0db2b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/plugins/tree/master/packages/replace&quot;&gt;@rollup/plugin-replace (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">使用&lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash的 &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt;（或可能使用&lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt;）可以直接限制调用昂贵的方法。您可以像上面这样实现：</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">在计算属性中使用&lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash的 &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt;（或可能是&lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">在组件中使用&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">在组件中使用&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">在路由中使用&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">谨慎使用 &lt;code&gt;$parent&lt;/code&gt; 和 &lt;code&gt;$children&lt;/code&gt; 它们主要用作逃生舱口盖。首选使用道具和事件进行亲子沟通。</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">请改用 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">请改用 &lt;code&gt;Vue.set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">在计算属性中使用JavaScript的内置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; 方法&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">在计算属性中使用JavaScript的内置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; 方法&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">在其他钩子中使用自定义的in-DOM检查。例如,要替换。</target>
        </trans-unit>
        <trans-unit id="181538426a8718fe366424835db6e5717dd50aee" translate="yes" xml:space="preserve">
          <source>Use actual heading tags instead of styling text to give the visual appearance of headings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">用组件代替。</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">谨慎使用全局混合器，因为它会影响创建的每个Vue实例，包括第三方组件。在大多数情况下，仅应将其用于自定义选项处理，如上例所示。最好将它们作为&lt;a href=&quot;plugins&quot;&gt;插件发布&lt;/a&gt;以避免重复应用。</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">通过调用 &lt;code&gt;Vue.use()&lt;/code&gt; 全局方法来使用插件。必须在通过调用 &lt;code&gt;new Vue()&lt;/code&gt; 启动应用程序之前完成此操作：</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;获得最佳调试体验。</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">请改用 &lt;code&gt;created&lt;/code&gt; 钩子。</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">请改用组件的&lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt;或已&lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt;钩子。</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">使用原生DOM API。</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">使用新的 &lt;code&gt;beforeCreate&lt;/code&gt; 钩子，这基本上是相同的。为了与其他生命周期方法保持一致，已将其重命名。</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">请改用新 &lt;code&gt;mounted&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">请改用新 &lt;code&gt;mounted&lt;/code&gt; 挂钩。应该注意的是，使用 &lt;code&gt;mounted&lt;/code&gt; ，并不能保证文档中的内容。为此，还包括 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="b4605b49670d374a5aa51ee71b7ef52006c5d7a3" translate="yes" xml:space="preserve">
          <source>Use the official &lt;a href=&quot;#cli&quot;&gt;CLI&lt;/a&gt; to scaffold a project, which provides batteries-included build setups for a modern frontend workflow (e.g., hot-reload, lint-on-save, and much more)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160b6d69d6038c85412ab8171ce4aea2da0fb502" translate="yes" xml:space="preserve">
          <source>Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; component instance created afterwards in the given app (for example, child components):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f909c50760bc08f177877869663a7491252c658f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;dynamic components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;动态组件&lt;/a&gt;并解决&lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;in-DOM模板的局限性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">用于插入到子组件中的内容,以指示内容属于哪个命名槽。</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">用于将 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 元素表示为作用域插槽。</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">用于将元素或组件表示为作用域插槽。该属性的值应该是一个有效的JavaScript表达式，该表达式可以出现在函数签名的参数位置。这意味着在受支持的环境中，您还可以在表达式中使用ES2015解构。用作2.5.0+中&lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt;的替代品。</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">用于以编程方式访问&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;作用域内的插槽&lt;/a&gt;。对于每个插槽（包括 &lt;code&gt;default&lt;/code&gt; 插槽），该对象均包含一个返回VNodes的对应函数。</target>
        </trans-unit>
        <trans-unit id="76072ee6b19562b61739da43c75a8552a434c5d4" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/component-basics#content-distribution-with-slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/component-slots#named-slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;this.$slots.foo()&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">用于以编程方式访问&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;插槽分配的&lt;/a&gt;内容。每个&lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;命名的插槽&lt;/a&gt;都有自己的对应属性（例如， &lt;code&gt;v-slot:foo&lt;/code&gt; 的内容可以在 &lt;code&gt;vm.$slots.foo&lt;/code&gt; ）。该 &lt;code&gt;default&lt;/code&gt; 属性包含任何节点不包含在一个名为插槽或内容的 &lt;code&gt;v-slot:default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e6bf115dec713a7c40e6db8b7a9b940453656d5" translate="yes" xml:space="preserve">
          <source>User Agent Accessibility Guidelines (UAAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="88c450bf7dc4b899fc608077fc184ec1727d8b1a" translate="yes" xml:space="preserve">
          <source>Users can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2aa5abde13c9a2b4d796246137c973fbb88554" translate="yes" xml:space="preserve">
          <source>Users must be able to access the content as technologies advance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a271e1f44586e5083fc1918fdaffbb8a054342" translate="yes" xml:space="preserve">
          <source>Users must be able to perceive the information being presented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589f322b8166b58e4896f447ee126a460ba0bbe3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt; is similar to &lt;code&gt;aria-label&lt;/code&gt; expect it is used if the label text is visible on screen. It is paired to other elements by their &lt;code&gt;id&lt;/code&gt; and you can link multiple &lt;code&gt;id&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">将 &lt;code&gt;$emit&lt;/code&gt; 与其他参数一起使用：</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">仅将 &lt;code&gt;$emit&lt;/code&gt; 与事件名称一起使用：</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">也允许使用 &lt;code&gt;keyCode&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="08b4f74f4b29aefd57fecf9253958e21fc91a467" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; (discussed &lt;a href=&quot;#provide-inject&quot;&gt;below&lt;/a&gt;) should also be considered as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d71127137c4c4cd4e9d9a52e044f00ece5fd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; is especially useful when writing a plugin, as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86076651686c0fbe2de9bc0df0db687049714e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">将 &lt;code&gt;v-bind.sync&lt;/code&gt; 与文字对象一起使用，例如在 &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; ，将不起作用，因为在解析这样的复杂表达式时要考虑的边缘情况太多。</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">使用 &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; ，我们&lt;em&gt;仅&lt;/em&gt;在渲染过程中迭代活动用户，从而使渲染效率更高。</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;strong&gt;不建议&lt;/strong&gt;同时使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;样式指南&lt;/a&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e65c164b999421d82c5e3d232a414fe76b72cd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">在组件上使用 &lt;code&gt;v-model&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61103105b06a8a12d7a44547eb3823dbfa7110a6" translate="yes" xml:space="preserve">
          <source>Using Inject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">使用JavaScript表达式</target>
        </trans-unit>
        <trans-unit id="132307a32976d23c3e63eb2beb64895a6f3b8113" translate="yes" xml:space="preserve">
          <source>Using Provide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">共同使用过渡和动画</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">使用插件</target>
        </trans-unit>
        <trans-unit id="9cf1549aea5e4ae2e67b0407f6b2344a0f1eb294" translate="yes" xml:space="preserve">
          <source>Using a watcher to compare values of an array or object that are reactive requires that it has a copy made of just the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">使用注入值作为数据输入。</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">将注入的值作为道具的默认值。</target>
        </trans-unit>
        <trans-unit id="cadb29867f8bf5340110eea6965faf58a3f6b48a" translate="yes" xml:space="preserve">
          <source>Using multiple teleports on the same target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e60545192243d051978512aa4ed96cc42d4d52" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; example from before, here is how it would look now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59268f2ba7d914bcab2c86e53d4606060ae7fc63" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our code can be updated as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc842072bfc033f9a866308b4dcf7050475c4957" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our provided values can be refactored as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e1a63d9acef5fd371c928b3e6b7280614408e1" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMarker&lt;/code&gt; component, we can refactor it with the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86942fa2e2d5d629468c3dd32e1a6910c8344b97" translate="yes" xml:space="preserve">
          <source>Using our date-picker component example from the &lt;a href=&quot;#attribute-inheritance&quot;&gt;previous section&lt;/a&gt;, in the event we need to apply all non-prop attributes to the &lt;code&gt;input&lt;/code&gt; element rather than the root &lt;code&gt;div&lt;/code&gt; element, this can be accomplished by using the &lt;code&gt;v-bind&lt;/code&gt; shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">使用 &lt;code&gt;$listeners&lt;/code&gt; 属性，您可以使用 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; 将组件上的所有事件侦听器转发到特定的子元素。对于像 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 这样的元素，您也想使用 &lt;code&gt;v-model&lt;/code&gt; ，通常为侦听器创建一个新的计算属性，例如下面的 &lt;code&gt;inputListeners&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a02a4af8d1e455a687fdc66fdceb59a54e15b8f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, which is responsible for rendering out the appropriate heading (i.e., &lt;code&gt;h1&lt;/code&gt;, &lt;code&gt;h2&lt;/code&gt;, &lt;code&gt;h3&lt;/code&gt;, etc.), this could have been written as a single-file component in 2.x as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">以&lt;a href=&quot;#Other-Examples&quot;&gt;此处&lt;/a&gt;描述的 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 为例，这是使用 &lt;code&gt;slot-scope&lt;/code&gt; 的等效用法：</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">使用 &lt;code&gt;debounce&lt;/code&gt; 属性，由于我们无法访问输入的实时状态，因此无法检测&amp;ldquo;打字&amp;rdquo;状态。通过将去抖动功能与Vue解耦，我们可以仅去抖动想要限制的操作，从而消除了我们可以开发的功能的限制：</target>
        </trans-unit>
        <trans-unit id="a87de46920f91d20c4a8374d7b0a5c7e603757dc" translate="yes" xml:space="preserve">
          <source>Using the example above, here is one example of how it could be implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3341dcb36ab8af8d89b35f44cc440d1a7d17430" translate="yes" xml:space="preserve">
          <source>Using the example above, there would only be one possible implementation of the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d5a2cbab66f55349694e4719943675255a69f1" translate="yes" xml:space="preserve">
          <source>Using the previously mentioned example of a &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, here is how it looks now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">使用这种策略,我们甚至可以在使用Pikaday时使用多个输入元素,每个新实例都会自动清理。</target>
        </trans-unit>
        <trans-unit id="420b1d24b2826ff84b27e5503c9d5fa275794cf8" translate="yes" xml:space="preserve">
          <source>Using with Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c2de355d1860ca4480d839a4fbef456709fc8" translate="yes" xml:space="preserve">
          <source>Using with Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1305a554f414402ea39d6c0eec337641f1f80daa" translate="yes" xml:space="preserve">
          <source>Using with Suspense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e76ca31176d1fccdd6bf8f9d90b0ddb005901f" translate="yes" xml:space="preserve">
          <source>Using with Vue components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceea66ab4211a7caa0a8bc0030f6869c29b5f77" translate="yes" xml:space="preserve">
          <source>Usually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">通常，尽管如此，您会希望每个道具都是一种特定的价值类型。在这些情况下，您可以将props列为一个对象，其中属性的名称和值分别包含prop名称和类型：</target>
        </trans-unit>
        <trans-unit id="2c03a1928d0df3b20ddcf6357f95f4926b46174c" translate="yes" xml:space="preserve">
          <source>Usually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f363e5aa689f12e08f65b4262f0add9ceb5a0b70" translate="yes" xml:space="preserve">
          <source>Usually, when we need to pass data from the parent to child component, we use &lt;a href=&quot;component-props&quot;&gt;props&lt;/a&gt;. Imagine the structure where you have some deeply nested components and you only need something from the parent component in the deep nested child. In this case, you still need to pass the prop down the whole component chain which might be annoying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">VNode接口</target>
        </trans-unit>
        <trans-unit id="d7fdca34045c394bdf9bbb0a0408e559b64e8a0a" translate="yes" xml:space="preserve">
          <source>VNode Props Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodes必须是独一无二的</target>
        </trans-unit>
        <trans-unit id="49ce46f211c09d9aa88ca4b4b3542fca5ed37ba1" translate="yes" xml:space="preserve">
          <source>VNodes now have a flat props structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084ea9ddae2c0ecd015b716116978e8325213232" translate="yes" xml:space="preserve">
          <source>Validate Emitted Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">价值绑定</target>
        </trans-unit>
        <trans-unit id="942a2054dbdb4f692ee9d24cdf0ad9184052d0e9" translate="yes" xml:space="preserve">
          <source>Via CDN: &lt;code&gt;&amp;lt;script src=&quot;https://unpkg.com/vue@next&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32f685e7efba1be35060ac9fdaec19c6efdb60f" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery的&lt;/a&gt;视频。观看Vue Mastery的免费&lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Vue入门课程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cab0d7e1c96c3ea19c16733af4fdea5420773df9" translate="yes" xml:space="preserve">
          <source>Virtual DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4ad933224c9c018075556e20e9443504c60df4" translate="yes" xml:space="preserve">
          <source>Visibility in headless mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">游客&lt;em&gt;到&lt;/em&gt;博物馆</target>
        </trans-unit>
        <trans-unit id="47e69e75f6b5116df912c06bde68d77a66e8ffd9" translate="yes" xml:space="preserve">
          <source>Vite</source>
          <target state="translated">Vite</target>
        </trans-unit>
        <trans-unit id="3dee610647aa7d97b936e215cc6e8fa092669039" translate="yes" xml:space="preserve">
          <source>VoiceOver (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df144818169dcae305b2c6ce5856caa779bc88c2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-component&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue（发音为/vjuː/，类似于&lt;strong&gt;view&lt;/strong&gt;）是用于构建用户界面的&lt;strong&gt;渐进框架&lt;/strong&gt;。与其他整体框架不同，Vue从头开始设计以逐渐采用。核心库仅集中在视图层，并且易于拾取并与其他库或现有项目集成。另一方面，当与&lt;a href=&quot;guide/single-file-components&quot;&gt;现代工具&lt;/a&gt;和&lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;支持库&lt;/a&gt;结合使用时，Vue也完全有能力为复杂的单页应用程序提供支持。</target>
        </trans-unit>
        <trans-unit id="dd79eece92c5ffe4c720051711e0f90d551d945b" translate="yes" xml:space="preserve">
          <source>Vue 2.x has a number of global APIs and configurations that globally mutate Vue&amp;rsquo;s behavior. For instance, to register a global component, you would use the &lt;code&gt;Vue.component&lt;/code&gt; API like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893d303c551ebb9fe5672e80454924e163f7fe29" translate="yes" xml:space="preserve">
          <source>Vue 3 now offers an &lt;code&gt;emits&lt;/code&gt; option, similar to the existing &lt;code&gt;props&lt;/code&gt; option. This option can be used to define the events that a component can emit to its parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7940d725dbd937d9de670c4768fc0ccd47788f" translate="yes" xml:space="preserve">
          <source>Vue CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="9b4162890a260c6325ca0e85fd029f15d2319406" translate="yes" xml:space="preserve">
          <source>Vue Docs Writing Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf53a6c36521f7bfb85181c1e488fc3bdefe2160" translate="yes" xml:space="preserve">
          <source>Vue Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1581d8a5ef292e49547c61633956998a288fd6aa" translate="yes" xml:space="preserve">
          <source>Vue Router 4.0 provides Vue 3 support and has a number of breaking changes of its own. Check out its &lt;a href=&quot;https://next.router.vuejs.org/guide/migration/&quot;&gt;migration guide (opens new window)&lt;/a&gt; for full details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e18b7a4f3086a13d2a0b9179ebded28163c885" translate="yes" xml:space="preserve">
          <source>Vue Test Utils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d1880504f36bb5a94fba498a0a0cfb67577f83" translate="yes" xml:space="preserve">
          <source>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d701148514b6b1195422aa314e247a9c6ce4ed" translate="yes" xml:space="preserve">
          <source>Vue Testing Library (@testing-library/vue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d00cb6f0b01ec3c037dd727f0b00f8ee2ebbd46" translate="yes" xml:space="preserve">
          <source>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue通过构建&lt;strong&gt;虚拟DOM&lt;/strong&gt;来跟踪它需要对真实DOM进行的更改来实现此目的。仔细看看这一行：</target>
        </trans-unit>
        <trans-unit id="3c67c991de8300834c38a25c1ca2498be450c64f" translate="yes" xml:space="preserve">
          <source>Vue also exposes some built-in properties via the component instance, such as &lt;code&gt;$attrs&lt;/code&gt; and &lt;code&gt;$emit&lt;/code&gt;. These properties all have a &lt;code&gt;$&lt;/code&gt; prefix to avoid conflicting with user-defined property names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vue还提供了 &lt;code&gt;.passive&lt;/code&gt; 修饰符，与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; 的 &lt;code&gt;passive&lt;/code&gt; 选项&lt;/a&gt;相对应。</target>
        </trans-unit>
        <trans-unit id="adf689defceb2bc071b35560777fed6fba514f1f" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;'s &lt;code&gt;passive&lt;/code&gt; option (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vue还提供了 &lt;code&gt;v-model&lt;/code&gt; 指令，使表单输入和应用状态之间的双向绑定变得轻而易举：</target>
        </trans-unit>
        <trans-unit id="885b8f9999638cb0ba7b84d6b1e20f2e73c6af0f" translate="yes" xml:space="preserve">
          <source>Vue automatically binds the &lt;code&gt;this&lt;/code&gt; value for &lt;code&gt;methods&lt;/code&gt; so that it always refers to the component instance. This ensures that a method retains the correct &lt;code&gt;this&lt;/code&gt; value if it's used as an event listener or callback. You should avoid using arrow functions when defining &lt;code&gt;methods&lt;/code&gt;, as that prevents Vue from binding the appropriate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vue可以帮助我们。由于SVG只是数据,我们只需要举例说明这些生物在兴奋、思考或报警时的样子。然后,Vue可以帮助在这些状态之间进行过渡,使您的欢迎页面、加载指示器和通知在情感上更有吸引力。</target>
        </trans-unit>
        <trans-unit id="f789efe555358e086dec2286a04d16497d60bbf4" translate="yes" xml:space="preserve">
          <source>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the &lt;code&gt;data&lt;/code&gt; object in order for Vue to convert it and make it reactive. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76acf301d7c1d195a8e6c80016f7abf03185310" translate="yes" xml:space="preserve">
          <source>Vue cannot detect the following changes to an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vue组件提供了普通自定义元素所不具备的重要功能,最主要的是跨组件数据流、自定义事件通信和构建工具集成。</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vue公司并&lt;strong&gt;没有&lt;/strong&gt;支持IE8及以下，因为它使用的ECMAScript 5个功能，是未shimmable在IE8。但是，它支持所有&lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;符合ECMAScript 5的浏览器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcde1702db5cf00f14ae819af084b9d5e13e847d" translate="yes" xml:space="preserve">
          <source>Vue does a runtime validation on props with a &lt;code&gt;type&lt;/code&gt; defined. To provide these types to TypeScript, we need to cast the constructor with &lt;code&gt;PropType&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vue不允许将新的根级别反应性属性动态添加到已创建的实例中。但是，可以使用 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 方法将反应性属性添加到嵌套对象中。例如，给定：</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vue不允许将新的根级别反应性属性动态添加到已创建的实例中。但是，可以使用 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 方法将反应性属性添加到嵌套对象中：</target>
        </trans-unit>
        <trans-unit id="343af74f45c6d504ae330328dd8b0a9201ec2a40" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vue确实提供了一种更通用的方法来观察Vue实例上的数据并对其做出反应：&lt;strong&gt;watch properties&lt;/strong&gt;。当您有一些需要根据其他数据进行更改的数据时，很容易过度使用 &lt;code&gt;watch&lt;/code&gt; ，特别是如果您来自AngularJS背景。但是，使用计算属性而不是命令式 &lt;code&gt;watch&lt;/code&gt; 回调通常是一个更好的主意。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="c5264d84d3913aaee37aae0efaf21239b2f1ce3b" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a current active instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vue完全不受此困扰，因为它使用了具有异步排队的透明依赖关系跟踪观察系统-所有更改都独立触发，除非它们具有明确的依赖关系。</target>
        </trans-unit>
        <trans-unit id="3b2be91f79d826fa58f7ebe4ed4e0d032247230c" translate="yes" xml:space="preserve">
          <source>Vue doesn't include built-in support for debouncing or throttling but it can be implemented using libraries such as &lt;a href=&quot;https://lodash.com/&quot;&gt;Lodash (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vue包含经典的Web技术，并在它们之上构建。为了向您展示这意味着什么，我们将深入一些示例。</target>
        </trans-unit>
        <trans-unit id="a951ea402d433567bd65b048725a50d77f19283f" translate="yes" xml:space="preserve">
          <source>Vue encourages us to build our UIs by encapsulating UI and related behavior into components. We can nest them inside one another to build a tree that makes up an application UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue在指令和组件之间有一个更清晰的分离,指令只是为了封装DOM操作,而组件则是自成一体的单元,有自己的视图和数据逻辑。指令只是为了封装DOM操作,而组件是自成一体的单元,有自己的视图和数据逻辑。在AngularJS中,指令是做一切的,而组件只是一种特定的指令。</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vue已经遍及全球，甚至核心团队都在至少六个时区。&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;该论坛&lt;/a&gt;包含7种语言并在不断增加，我们的许多文档都&lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;积极维护翻译&lt;/a&gt;。我们为Vue的国际影响力感到自豪，但我们可以做得更好。</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vue具有更好的性能，并且非常容易优化，因为它不使用脏检查。当有许多观察者时，AngularJS会变慢，因为每次范围中的任何更改时，都需要重新评估所有这些观察者。此外，如果某些观察者触发另一个更新，则摘要循环可能必须运行多次才能&amp;ldquo;稳定&amp;rdquo;。AngularJS用户常常不得不采用深奥的技术来解决摘要循环，在某些情况下，无法通过许多观察者来优化作用域。</target>
        </trans-unit>
        <trans-unit id="2605f10b94203eb3d7c6121d24fd706b16d41799" translate="yes" xml:space="preserve">
          <source>Vue has spread across the globe, with the core team being in at least half a dozen different timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum (opens new window)&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;q=vuejs.org&quot;&gt;actively-maintained translations (opens new window)&lt;/a&gt;. We're very proud of Vue's international reach, but we can do even better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c550aa4342c74e83ae493691c6ae0befcbbd2d7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft (opens new window)&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue 使用 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素作为内容的分发渠道，实现了受&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web组件规范草案&lt;/a&gt;启发的内容分发API 。</target>
        </trans-unit>
        <trans-unit id="3a793e8d661b43bbe34ed4b73bb734bc567f99e0" translate="yes" xml:space="preserve">
          <source>Vue internally tracks all objects that have been made reactive, so it always returns the same proxy for the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vue在&lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt;和&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt;上也可用（cdnjs需要一些时间来同步，因此最新版本可能尚不可用）。</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue的意见比Angular小得多,它为各种构建系统提供官方支持,对你如何构建应用没有任何限制。许多开发者享受这种自由度,而有些人则喜欢只用一种Right Way来构建任何应用。</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vue比AngularJS简单得多,无论是API还是设计。学会足够的知识来构建非平凡的应用,一般不需要一天的时间,而AngularJS则不然。</target>
        </trans-unit>
        <trans-unit id="cffec81f79bb5fd465edfb05ca6c6a20e73cd65d" translate="yes" xml:space="preserve">
          <source>Vue keeps the page updated by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vue需要附加事件侦听器，以便知道过渡何时结束。它可以是 &lt;code&gt;transitionend&lt;/code&gt; 或 &lt;code&gt;animationend&lt;/code&gt; ，具体取决于所应用的CSS规则的类型。如果仅使用一种，则Vue可以自动检测正确的类型。</target>
        </trans-unit>
        <trans-unit id="365212719322a63f4e306455d5f27b8a3966dc5d" translate="yes" xml:space="preserve">
          <source>Vue offers some abstractions that can help work with transitions and animations, particularly in response to something changing. Some of these abstractions include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abff090748f024b1aa003637a4b72dd4dc06e5f" translate="yes" xml:space="preserve">
          <source>Vue projects can quickly be set up with Vite by running the following commands in your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vue提供了一个 &lt;code&gt;transition&lt;/code&gt; 包装器组件，允许您在以下上下文中为任何元素或组件添加输入/离开转换：</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue提供了多种方法来应用过渡效果,当项目从DOM中插入、更新或删除时。这包括以下工具:</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue提供了最常用的密钥代码的别名,当需要传统浏览器支持时。</target>
        </trans-unit>
        <trans-unit id="c90e634ab0c74f1d079a1c75ea53bce697797633" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a311fa8fbae830ba1eadba1b420d03469cdf2806" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI (opens new window)&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs (opens new window)&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vue提供了一个&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;官方CLI，可&lt;/a&gt;用于快速搭建雄心勃勃的Single Page Applications。它为现代的前端工作流提供了包括电池在内的构建设置。使用热重载，保存时不掉毛和可用于生产的构建，只需几分钟就可以启动并运行。有关更多详细信息，请参见&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="198884e2076bf367c22dbd13bc52339d681396a7" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;code&gt;InjectionKey&lt;/code&gt; interface which is a generic type that extends &lt;code&gt;Symbol&lt;/code&gt;. It can be used to sync the type of the injected value between the provider and the consumer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue在普通的JavaScript对象上提供了不显眼的反应性和全自动的计算属性。在Ember中,你需要把所有的东西都包裹在Ember对象中,并且手动声明计算属性的依赖关系。</target>
        </trans-unit>
        <trans-unit id="5a53f20609320f4a24cb94f7b4da549347f4bbbd" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the &lt;strong&gt;render function&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vue建议在大多数情况下使用模板来构建HTML。但是，在某些情况下，您确实需要JavaScript的全部编程功能。在这里，您可以使用&lt;strong&gt;render函数&lt;/strong&gt;，它是模板的更接近编译器的替代方法。</target>
        </trans-unit>
        <trans-unit id="8156b77f1cb02753b763c4feb44d817ea36bfdc0" translate="yes" xml:space="preserve">
          <source>Vue should not be bundled into the library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue 试图尽可能高效地渲染元素,经常重复使用它们,而不是从头开始渲染。除了帮助Vue变得非常快之外,这还能带来一些有用的优势。例如,如果你允许用户在多种登录类型之间切换。</target>
        </trans-unit>
        <trans-unit id="1bfea290ac9ffe33c850d1b0a939949cd7dfe376" translate="yes" xml:space="preserve">
          <source>Vue uses a &lt;code&gt;$&lt;/code&gt; prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix &lt;code&gt;_&lt;/code&gt; for internal properties. You should avoid using names for top-level &lt;code&gt;data&lt;/code&gt; properties that start with either of these characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vue使用 &lt;code&gt;_&lt;/code&gt; 前缀定义自己的私有属性，因此使用相同的前缀（例如 &lt;code&gt;_update&lt;/code&gt; ）可能会覆盖实例属性。即使您检查并且Vue当前未使用特定的属性名称，也不能保证在更高版本中不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="85dd560a9154cd8cc040ca30f4c194c517655b32" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue会自动嗅探目标元素是否有CSS过渡或动画应用。如果有,CSS过渡类将在适当的时机被添加/删除。</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue包装了观察到的数组的变异方法，因此它们也将触发视图更新。包装的方法是：</target>
        </trans-unit>
        <trans-unit id="052994ca379981542bf778170c739a04a769c1d8" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vue的社区正在以惊人的速度增长，如果您正在阅读本文，那么很有可能已经准备好加入。所以...欢迎您！</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vue的模板语法充分利用了JavaScript表达式的功能，而相比之下，Handlebars的表达式和助手语法则受到很大限制。</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vue的过渡系统已经发生了巨大变化，现在使用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 包装器元素，而不是 &lt;code&gt;transition&lt;/code&gt; 属性。建议阅读新的《&lt;a href=&quot;transitions&quot;&gt;过渡指南》&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vue的过渡系统提供了许多简单的方法来动画输入，离开和列表，但是如何对数据本身进行动画处理呢？例如：</target>
        </trans-unit>
        <trans-unit id="b31ca06d3a5f393764ec4e9c8ef653d752ddc802" translate="yes" xml:space="preserve">
          <source>Vue's reactivity system buffers invalidated effects and flushes them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same &quot;tick&quot;. Internally, a component's &lt;code&gt;update&lt;/code&gt; function is also a watched effect. When a user effect is queued, it is by default invoked &lt;strong&gt;before&lt;/strong&gt; all component &lt;code&gt;update&lt;/code&gt; effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a97b271690906d44d32706aa7062d75c719e21d" translate="yes" xml:space="preserve">
          <source>Vue's transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49720efe6c6aa6c85c1ae9a211e82f72036b89c2" translate="yes" xml:space="preserve">
          <source>Vue's usage of the &lt;code&gt;is&lt;/code&gt; special prop was simulating what the native attribute does before it was made universally available in browsers. However, in 2.x it was interpreted as rendering a Vue component with the name &lt;code&gt;plastic-button&lt;/code&gt;. This blocks the native usage of Customized Built-in Element mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile(模板 )</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="b7ea66a12347f6ffc2b94442e80c35d15d597413" translate="yes" xml:space="preserve">
          <source>Vue.component</source>
          <target state="translated">Vue.component</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component(id,[define])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="fa7c2ad2da40c783fe07fb4836f3bda4a2b8cf11" translate="yes" xml:space="preserve">
          <source>Vue.config</source>
          <target state="translated">Vue.config</target>
        </trans-unit>
        <trans-unit id="fbf8d19b7eb0ae647266f2c96abf99945277ea9e" translate="yes" xml:space="preserve">
          <source>Vue.config.ignoredElements</source>
          <target state="translated">Vue.config.ignoredElements</target>
        </trans-unit>
        <trans-unit id="5b4f8634a75bc7bfd88be1dd891c9ea29cfa97f5" translate="yes" xml:space="preserve">
          <source>Vue.config.productionTip</source>
          <target state="translated">Vue.config.productionTip</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete(target,propertyName/index )</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="580b85815fc398d542e95ec7b5e861e1e012763f" translate="yes" xml:space="preserve">
          <source>Vue.directive</source>
          <target state="translated">Vue.directive</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive(id,[definence])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extension(选项 )</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter(id,[define])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.js允许您定义可用于应用常见文本格式的过滤器。过滤器在两个地方可用：&lt;strong&gt;小胡子插值和 &lt;code&gt;v-bind&lt;/code&gt; 表达式&lt;/strong&gt;（2.1.0+支持后者）。过滤器应附加在JavaScript表达式的末尾，以&amp;ldquo;竖线&amp;rdquo;符号表示：</target>
        </trans-unit>
        <trans-unit id="9050802f5567e26ffa96732c93096ee9dcffa91f" translate="yes" xml:space="preserve">
          <source>Vue.js is built by design to be incrementally adoptable. This means that it can be integrated into a project multiple ways depending on the requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js使用基于HTML的模板语法，该语法允许您以声明方式将渲染的DOM绑定到基础Vue实例的数据。所有Vue.js模板都是有效的HTML，可以通过符合规范的浏览器和HTML解析器进行解析。</target>
        </trans-unit>
        <trans-unit id="89a8a92dc46a36b0e2b8305728a1f8aaf8a88b78" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42311314f611dc7df4fd1777e98448bb4c96ecdb" translate="yes" xml:space="preserve">
          <source>Vue.mixin</source>
          <target state="translated">Vue.mixin</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin(mixin )</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick([callback,context])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable(object )</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="7ea3574e637178c673386a1b01019ea3760cf139" translate="yes" xml:space="preserve">
          <source>Vue.prototype</source>
          <target state="translated">Vue.prototype</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set(target,propertyName/index,value )</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="5a623310c41e9f9c01feb186a71709087e21e7da" translate="yes" xml:space="preserve">
          <source>Vue.use</source>
          <target state="translated">Vue.use</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">View.use(插件 )</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="58df3887d367d6a05cae0279723a97a86100bfeb" translate="yes" xml:space="preserve">
          <source>VuePress provides a custom container plugin to create alert boxes. There are four types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fde70f98c4cbf6a7b48ee19696e129152a7fb55" translate="yes" xml:space="preserve">
          <source>VuePress uses Prism to provide language syntax highlighting by appending the language to the beginning backticks of a code block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0已发布，但本指南仅涵盖向1.0的迁移？那是错字吗？而且，看起来Vuex 1.0和2.0是同时发布的。这是怎么回事？我应该使用哪一种，什么与Vue 2.0兼容？</target>
        </trans-unit>
        <trans-unit id="c8b618e05a2594cc2596f0d284d48d16432c525a" translate="yes" xml:space="preserve">
          <source>Vuex 4.0 provides Vue 3 support with largely the same API as 3.x. The only breaking change is &lt;a href=&quot;https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html#breaking-changes&quot;&gt;how the plugin is installed (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd40be6d96cb39a60cc6c39b8ea11e9937c18f8" translate="yes" xml:space="preserve">
          <source>Vuex is the &lt;a href=&quot;../guide/state-management#official-flux-like-implementation&quot;&gt;official flux-like implementation&lt;/a&gt; for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full &lt;a href=&quot;../guide/installation#vue-devtools&quot;&gt;Vue DevTools&lt;/a&gt; support).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d11819e7a1d9589b690ec06234450093f24c627" translate="yes" xml:space="preserve">
          <source>W3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066e0172350e0754c39de0933398067fbaebdf66" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices 1.2 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45649ea79803ea52f28827ee4e547e4085b9b0c5" translate="yes" xml:space="preserve">
          <source>WAVE (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43059526c7805cadcc812c12f2c0f217edb0caf4" translate="yes" xml:space="preserve">
          <source>WCAG 2.0 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7254fa8467e45dc2111643677937dc826c7381" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bd5df2f8313fd0f66a6834ec679fec70aa231e" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">观看Vue学校的免费课程</target>
        </trans-unit>
        <trans-unit id="62e0a695e7ccab369a0f49419284d104f98c2575" translate="yes" xml:space="preserve">
          <source>Watch a free video about Lifecycle Hooks on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e7187cdc04cab3317a2d6229024de7b88422b" translate="yes" xml:space="preserve">
          <source>Watch a free video about the Composition API on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">观看关于Vue Mastery的免费视频课程。</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">观看Vue学校的免费视频课程</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">观看Vue学校的免费视频课程</target>
        </trans-unit>
        <trans-unit id="0b642e69ff5dd94afbc4e677ac7245afd2b75050" translate="yes" xml:space="preserve">
          <source>Watch a free video on Reactivity in Depth on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2a20165ccd85b019b022c5d12f356aa7e7ddb2" translate="yes" xml:space="preserve">
          <source>Watch a free video on how to define custom events on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ef5fd200efa5ea9f0c8791591c28f563aa2607" translate="yes" xml:space="preserve">
          <source>Watch a free video on setup on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a603438f7073cd71b9f2b8f7c700ac8737ed9345" translate="yes" xml:space="preserve">
          <source>Watch a reactive property or a computed function on the component instance for changes. The callback gets called with the new value and the old value for the given property. We can only pass top-level &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, or &lt;code&gt;computed&lt;/code&gt; property name as a string. For more complex expressions or nested properties, use a function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">观看Vue Mastery的视频说明</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">在Vue实例上观察一个表达式或计算函数的变化。回调会以新值和旧值被调用。表达式只接受点分隔的路径。对于更复杂的表达式,请使用函数来代替。</target>
        </trans-unit>
        <trans-unit id="aa35ca415d20b9f4a53f5d20f60b4e2506e17dc4" translate="yes" xml:space="preserve">
          <source>Watch on Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a37889e8f85fb3cc8ac5b854d904e40ddf13894" translate="yes" xml:space="preserve">
          <source>Watcher Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">观察者允许我们将任何数字属性的变化动画化为另一个属性。从抽象&lt;a href=&quot;https://greensock.com/&quot;&gt;上看&lt;/a&gt;，这听起来可能很复杂，所以让我们深入了解一下使用GreenSock的示例：</target>
        </trans-unit>
        <trans-unit id="3e3b9441a3e5ab81aea2316854b5cd4f81568ab3" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let's dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">通过 &lt;code&gt;vm.$watch&lt;/code&gt; 创建的观察者现在在关联的组件重新释放之前被触发。这使您有机会在组件重新呈现之前进一步更新状态，从而避免了不必要的更新。例如，您可以观看组件属性并在属性更改时更新组件自己的数据。</target>
        </trans-unit>
        <trans-unit id="9c56f7248c60849f85774dec247f8195050af1aa" translate="yes" xml:space="preserve">
          <source>Watching Multiple Sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059a180684023e522c315cea524c6d4c3c650aaf" translate="yes" xml:space="preserve">
          <source>Watching Reactive Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8debcbf1f849cc32580625667ebbdeef8f8eeb6a" translate="yes" xml:space="preserve">
          <source>Watching Template Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bace31b55ee998845b6d5b8e3891e59a6675d64c" translate="yes" xml:space="preserve">
          <source>Watching a Single Source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d17151eadf5c934a94706826860753d855216f0" translate="yes" xml:space="preserve">
          <source>Watching a template ref for changes can be an alternative to the use of lifecycle hooks that was demonstrated in the previous examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">我们也尽力避免偏见。作为核心团队，我们显然很喜欢Vue。我们认为有些问题比其他解决方案更好。如果我们不相信这一点，那么我们就不会继续努力。我们确实希望做到公平准确。在其他库提供显着优势的地方，例如React庞大的替代渲染器生态系统或Knockout对IE6的浏览器支持，我们也尝试列出这些库。</target>
        </trans-unit>
        <trans-unit id="145d670173003080c2dd95e109d6624af3091f7c" translate="yes" xml:space="preserve">
          <source>We appreciate small, focused PRs. If you'd like to make an extremely large change, please communicate with team members prior to a pull request. Here's a &lt;a href=&quot;https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/&quot;&gt;writeup that details why this is so critical (opens new window)&lt;/a&gt; for us to work well on this team. Please understand that though we always appreciate contributions, ultimately we have to prioritize what works best for the project as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ddf11e5b6912a4511915ec63b40d6843a024e4" translate="yes" xml:space="preserve">
          <source>We are registering the invalidation callback via a passed-in function instead of returning it from the callback because the return value is important for async error handling. It is very common for the effect function to be an async function when performing data fetching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf15350412bdd57a1ba478919853106222c77d2" translate="yes" xml:space="preserve">
          <source>We are still working on a dedicated Migration Build of Vue 3 with Vue 2 compatible behavior and runtime warnings of incompatible usage. If you are planning to migrate a non-trivial Vue 2 app, we strongly recommend waiting for the Migration Build for a smoother experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b413666b6609e2e923f9dac7f2dbb73deb11598" translate="yes" xml:space="preserve">
          <source>We are working on a new version of the Devtools with a new UI and refactored internals to support multiple Vue versions. The new version is currently in beta and only supports Vue 3 (for now). Vuex and Router integration is also work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4590c53baf3d1bcb7b3f91125ba505380d0c3454" translate="yes" xml:space="preserve">
          <source>We can access slot contents as arrays of VNodes from &lt;a href=&quot;../api/instance-properties#slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19325bef373c7011977b1dc1240632398096e83b" translate="yes" xml:space="preserve">
          <source>We can annotate a payload for the emitted event. Also, all non-declared emitted events will throw a type error when called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded0fe3886c210ed1f69601603a576fff08f9afa" translate="yes" xml:space="preserve">
          <source>We can check resources like &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS-Triggers (opens new window)&lt;/a&gt; to see which properties will trigger repaints if we animate them. Here, if you look under &lt;code&gt;transform&lt;/code&gt;, you will see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">我们可以将这一技术与我们之前的实现结合起来,对我们列表的每一个可能的变化进行动画。</target>
        </trans-unit>
        <trans-unit id="cd1d61172e00dd1e1c488b575a87db8e2cda970e" translate="yes" xml:space="preserve">
          <source>We can create extremely smooth animations on the web by being aware of performance. We want to hardware accelerate elements when we can, and use properties that don't trigger repaints. Let's go over some of how we can accomplish this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b738e997b0df8d616d9cdb2cc5977352977ba792" translate="yes" xml:space="preserve">
          <source>We can do this because the search button will help visual users identify the purpose of the input field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ccaba9c04ab4407d0e1982d8ccf1d0a6b7d5a" translate="yes" xml:space="preserve">
          <source>We can list emitted events in the component's &lt;code&gt;emits&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">现在，我们可以直接在自定义输入上使用 &lt;code&gt;v-model&lt;/code&gt; ，这不仅与常规输入更加一致，而且意味着我们的组件对Vuex友好。</target>
        </trans-unit>
        <trans-unit id="8e665af7b29d480225aa1952784d4bbf8b4eb21b" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">我们可以将数组传递给 &lt;code&gt;v-bind:class&lt;/code&gt; 以应用类列表：</target>
        </trans-unit>
        <trans-unit id="406b9892cf3e59eeb19dc1064b0235c19adccc7c" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;:class&lt;/code&gt; (short for &lt;code&gt;v-bind:class&lt;/code&gt;) to dynamically toggle classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">我们可以将一个对象传递给 &lt;code&gt;v-bind:class&lt;/code&gt; 来动态切换类：</target>
        </trans-unit>
        <trans-unit id="977e7623c17ea7ebe75cd4f565824983dde786be" translate="yes" xml:space="preserve">
          <source>We can see from the table above, current implementation coerces &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;'true'&lt;/code&gt; but removes the attribute if it's &lt;code&gt;false&lt;/code&gt;. This also led to inconsistency and required users to manually coerce boolean values to string in very common use cases like &lt;code&gt;aria-*&lt;/code&gt; attributes like &lt;code&gt;aria-selected&lt;/code&gt;, &lt;code&gt;aria-hidden&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4415051c820f469ebda2e174386196145ce7433" translate="yes" xml:space="preserve">
          <source>We can use &lt;a href=&quot;component-provide-inject&quot;&gt;provide / inject&lt;/a&gt; with the Composition API as well. Both can only be called during &lt;a href=&quot;composition-api-setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; with a current active instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df72788c45d87bd5e47825b2ad8e91055d4e9ce1" translate="yes" xml:space="preserve">
          <source>We can use CSS to visually hide elements but keep them available for assistive technology:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">我们可以使用 &lt;code&gt;v-for&lt;/code&gt; 指令基于数组呈现项目列表。该 &lt;code&gt;v-for&lt;/code&gt; 指令要求的形式一个特殊语法 &lt;code&gt;item in items&lt;/code&gt; ，其中 &lt;code&gt;items&lt;/code&gt; 是源数据阵列和 &lt;code&gt;item&lt;/code&gt; 是一个&lt;strong&gt;别名&lt;/strong&gt;的数组元素上被迭代：</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">我们可以使用 &lt;code&gt;v-on&lt;/code&gt; 指令侦听DOM事件并在触发它们时运行一些JavaScript。</target>
        </trans-unit>
        <trans-unit id="99b3e0b88025a1cd9dd1aa491f0dd2bc179180f4" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive, which we typically shorten to the &lt;code&gt;@&lt;/code&gt; symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be &lt;code&gt;v-on:click=&quot;methodName&quot;&lt;/code&gt; or with the shortcut, &lt;code&gt;@click=&quot;methodName&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b6da1cf882bfbaa28b18476abab8f6ff6b7b6e" translate="yes" xml:space="preserve">
          <source>We can use this to coordinate more expressive movement, such as a folding card, as demonstrated below. It's actually two elements transitioning between each other, but since the beginning and end states are scaling the same: horizontally to 0, it appears like one fluid movement. This type of sleight-of-hand can be very useful for realistic UI microinteractions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817f50bdc2a016379b436c13b4b442890443585f" translate="yes" xml:space="preserve">
          <source>We could do the same for other &lt;strong&gt;logical concerns&lt;/strong&gt; but you might be already asking the question &amp;ndash; &lt;em&gt;Isn&amp;rsquo;t this just moving the code to the &lt;code&gt;setup&lt;/code&gt; option and making it extremely big?&lt;/em&gt; Well, that&amp;rsquo;s true. That&amp;rsquo;s why before moving on with the other responsibilities, we will first extract the above code into a standalone &lt;strong&gt;composition function&lt;/strong&gt;. Let's start with creating &lt;code&gt;useUserRepositories&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">我们可以通过这个单一的事件中心来管理组件之间的通信。</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">我们稍后将讨论&lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;组件之间的转换&lt;/a&gt;，但是您也可以使用 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; 在原始元素之间转换。最常见的两元素转换之一是在列表容器和描述空列表的消息之间：</target>
        </trans-unit>
        <trans-unit id="e2e7b18ff8837f7d2c779646a84e95769cc3303b" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#transitioning-between-components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">我们从更新中得到类似的好处。</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">我们得到以下好处:</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">我们为新的Angular单独开辟了一个章节,因为它确实是一个与AngularJS完全不同的框架。比如说,它的特点是采用了一流的组件系统,很多实现细节完全重写,API也有相当大的变化。</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">我们已经创建了第一个Vue应用程序！这看起来与呈现字符串模板非常相似，但是Vue在后台做了很多工作。数据和DOM现在已链接，并且所有内容现在都是&lt;strong&gt;反应性的&lt;/strong&gt;。我们怎么知道？打开浏览器的JavaScript控制台（现在，在此页面上），然后将 &lt;code&gt;app.message&lt;/code&gt; 设置为其他值。您应该看到上面呈现的示例已相应更新。</target>
        </trans-unit>
        <trans-unit id="a3de3e0ebfec380551325c5d2024c30336332771" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Take a look at the example below where &lt;code&gt;counter&lt;/code&gt; property increments every second and you will see how rendered DOM changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9882cb189eb18be1f8b18353e20480e68691217f" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">我们创建了一个独立的指南，用于创建服务器渲染的Vue应用程序。对于那些已经熟悉客户端Vue开发，服务器端Node.js开发和Webpack的人来说，这是非常深入的指南。在&lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org上进行&lt;/a&gt;检查。</target>
        </trans-unit>
        <trans-unit id="5e2d326202574eaf0a4b0a6f118cf078e50093fa" translate="yes" xml:space="preserve">
          <source>We have moved several pieces of our first logical concern into the &lt;code&gt;setup&lt;/code&gt; method, nicely put close to each other. What&amp;rsquo;s left is calling &lt;code&gt;getUserRepositories&lt;/code&gt; in the &lt;code&gt;mounted&lt;/code&gt; hook and setting up a watcher to do that whenever the &lt;code&gt;user&lt;/code&gt; prop changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f49be9e4b4a0bd2cc13f3ef887bdbb56e8ea881" translate="yes" xml:space="preserve">
          <source>We have some dedicated styles to denote something that's worth highlighting in a particular way. These are captured &lt;a href=&quot;../doc-style-guide#alerts&quot;&gt;on this page (opens new window)&lt;/a&gt;. &lt;strong&gt;They are to be used sparingly.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2365bbdeaabeff7b76c97dd6062eceb546eae44b" translate="yes" xml:space="preserve">
          <source>We have to provide a proper prop name for the event handler, e.g., to handle &lt;code&gt;click&lt;/code&gt; events, the prop name would be &lt;code&gt;onClick&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b667182eef0a9564fcc136526a19be6641183fb" translate="yes" xml:space="preserve">
          <source>We intend to drop this internal concept of &quot;enumerated attributes&quot; and treat them as normal non-boolean HTML attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3eea1c16de0a8e9cf42e189bd675df96a77366" translate="yes" xml:space="preserve">
          <source>We make a copy of the DOM in JavaScript called the Virtual DOM, we do this because touching the DOM with JavaScript is computationally expensive. While performing updates in JavaScript is cheap, finding the required DOM nodes and updating them with JavaScript is expensive. So we batch calls, and change the DOM all at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a6f46a302366b1b4d268e8a2baf4204e756c65" translate="yes" xml:space="preserve">
          <source>We mentioned before that in order to have an API that updates a final value when something changes, we&amp;rsquo;re going to have to set new values when something changes. We do this in the handler, in a function called &lt;code&gt;track&lt;/code&gt;, where we pass in the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd40e61c317c21b5589b1855722a4f76630a6a7" translate="yes" xml:space="preserve">
          <source>We might want the text &quot;Submit&quot; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &quot;Submit&quot; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">我们可能希望大部分时间在&amp;ldquo; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; &amp;rdquo;内部呈现&amp;ldquo; Submit&amp;rdquo;文本。为了使&amp;ldquo;提交&amp;rdquo;备用内容，我们可以将其放置在 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 标签之间：</target>
        </trans-unit>
        <trans-unit id="7ea4d2b2947c843536ed2a98837450506cc32476" translate="yes" xml:space="preserve">
          <source>We might want to replace the &lt;code&gt;{{ item }}&lt;/code&gt; with a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; to customize it on parent component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">我们可能希望替换此后备内容以显示用户的名字，而不是姓氏，如下所示：</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">我们可能想重用此组件，从而允许用户维护多个列表（例如，购物，愿望清单，日常杂务等）。不过有一个问题。由于组件的每个实例都引用相同的数据对象，因此更改一个列表的标题也将更改所有其他列表的标题。添加/编辑/删除待办事项也是如此。</target>
        </trans-unit>
        <trans-unit id="d78b76b13dec2d9479f1cfb4f190e2eb6e217389" translate="yes" xml:space="preserve">
          <source>We recommend replacing any complex expressions with a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt;, one of the most fundamental pieces of Vue, which we'll cover shortly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b734f82d47813efa3a6806ce727611d03115657d" translate="yes" xml:space="preserve">
          <source>We recommend:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9d55967630e0ffef70ef9b3f460a567135d1e5" translate="yes" xml:space="preserve">
          <source>We removed &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt; methods from the instance completely. &lt;code&gt;$emit&lt;/code&gt; is still a part of the existing API as it's used to trigger event handlers declaratively attached by a parent component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">我们用括号包围参数,用逗号限定参数。</target>
        </trans-unit>
        <trans-unit id="3f6388f12bd97827e87f720eb7e6528b0cdd918b" translate="yes" xml:space="preserve">
          <source>We use it like this: &lt;code&gt;new Proxy(target, handler)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866e301e87de4875c510e32c3de7ad212732a107" translate="yes" xml:space="preserve">
          <source>We want to make a function to translate keys available to the whole application, so we will expose it using &lt;code&gt;app.config.globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bb8d549018405cd3717be9cfc0482cf533a00b" translate="yes" xml:space="preserve">
          <source>We will assume that our users will pass in an object containing the translated keys in the &lt;code&gt;options&lt;/code&gt; parameter when they use the plugin. Our &lt;code&gt;$translate&lt;/code&gt; function will take a string such as &lt;code&gt;greetings.hello&lt;/code&gt;, look inside the user provided configuration and return the translated value - in this case, &lt;code&gt;Bonjour!&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2d79d26a57c657532cfa93323b5aa7856a950f" translate="yes" xml:space="preserve">
          <source>We will cover all of these and more in the next three sections in this Guide. However, aside from these useful API offerings, it's worth mentioning that the class and style declarations we covered earlier can be used to apply animations and transitions as well, for more simple use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0330d8076787db736d1163a550844572651d3ec8" translate="yes" xml:space="preserve">
          <source>We will need to install Rollup and a few dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9990a125d88c5ba238d041e04854bb4b051a20bc" translate="yes" xml:space="preserve">
          <source>We will start with the lifecycle hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bee3c68a3f59f9dbc34ec660b948ec6a34b4f2" translate="yes" xml:space="preserve">
          <source>We will start with the most obvious parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34746e60611d8ce199ba5e1744dcd31fcb6189c0" translate="yes" xml:space="preserve">
          <source>We will use the &lt;code&gt;i18nPlugin&lt;/code&gt; we created in the &lt;a href=&quot;#writing-a-plugin&quot;&gt;Writing a Plugin&lt;/a&gt; section for demo purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">我们也希望&lt;strong&gt;您能&lt;/strong&gt;帮助&lt;strong&gt;您&lt;/strong&gt;保持此文档的最新状态，因为JavaScript世界发展很快！如果您发现不正确的地方或看起来不太正确的地方，请&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;打开一个问题&lt;/a&gt;让我们知道。</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">当我们讨论&lt;a href=&quot;render-function&quot;&gt;渲染功能&lt;/a&gt;时，我们将在&lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;以后&lt;/a&gt;更详细地介绍VNode 。</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">在下一节中，我们将探讨传递给这些挂钩的参数（即 &lt;code&gt;el&lt;/code&gt; ， &lt;code&gt;binding&lt;/code&gt; ， &lt;code&gt;vnode&lt;/code&gt; 和 &lt;code&gt;oldVnode&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">稍后我们将详细讨论&lt;a href=&quot;components&quot;&gt;组件系统&lt;/a&gt;。现在，只知道所有Vue组件也是Vue实例，因此接受相同的options对象（除了一些特定于root的选项）。</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">我们只是在遵循每种语言的约定。在JavaScript中，camelCase更自然。在HTML中，kebab-case是。</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">但是，我们仍然受到过滤器和Vue 1.0的限制，所以让我们完成对Vue 2.0的升级：</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">我们已经简要介绍了Vue.js核心的最基本功能-本指南的其余部分将详细介绍它们以及其他高级功能，因此请务必通读所有内容！</target>
        </trans-unit>
        <trans-unit id="eb8b82ed49a41a1aeaad51c988296a83c46302ad" translate="yes" xml:space="preserve">
          <source>We'll be using GreenSock in some of the examples in the sections following. They have a great &lt;a href=&quot;https://greensock.com/ease-visualizer&quot;&gt;ease visualizer (opens new window)&lt;/a&gt; that will help you build nicely crafted eases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abdbdf8ec29be45ff4f5a54f8824c87ed93395f" translate="yes" xml:space="preserve">
          <source>We'll cover VNodes in more detail &lt;a href=&quot;render-function#the-virtual-dom-tree&quot;&gt;later&lt;/a&gt;, when we discuss render functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11cb422fd9a8827a4bee9296e2eefeb8799791f" translate="yes" xml:space="preserve">
          <source>We'll talk about &lt;a href=&quot;component-basics&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just be aware that the root component isn't really any different from any other component. The configuration options are the same, as is the behavior of the corresponding component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4763cc35fb84a23678cf26a9f7a29bb762c52dee" translate="yes" xml:space="preserve">
          <source>We're showing you a simple example here, but in a typical Vue application we use Single File Components instead of a string template. You can find more information about them &lt;a href=&quot;single-file-component&quot;&gt;in this section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902ee1e6bc3aa622843aa289195cfdd213ac8ef1" translate="yes" xml:space="preserve">
          <source>We're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3ca188b1df773cfd1eeb0376541bfa59686bfe" translate="yes" xml:space="preserve">
          <source>We've briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96cc25eb05f1274ae7b9eebefd157220abac3ca" translate="yes" xml:space="preserve">
          <source>Web Accessibility Initiative &amp;ndash; Accessible Rich Internet Applications (WAI-ARIA)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf30cbd1ee6db2c9121250baf622ac22c881128" translate="yes" xml:space="preserve">
          <source>Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff265f994041ba5e431f8222c5c1ba6691182894" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83aec0744d18b3272452883bc73b55a421d84c62" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279f4a441a4b12f3b9de64ff7f0e63d1f6fc5d06" translate="yes" xml:space="preserve">
          <source>Web accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone &amp;mdash; be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8917af5cf347fb6a6fe194798f4f56a85c811a01" translate="yes" xml:space="preserve">
          <source>WebAim Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca0768e3dfd8cfbe2c2bff1e16645bb18dbfe9b" translate="yes" xml:space="preserve">
          <source>WebAim Link Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="b0f63abab58780fc9096086a11d8c4fd44969c50" translate="yes" xml:space="preserve">
          <source>Webpack Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">顾虑分离怎么办?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">您可以做什么</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">什么是 &lt;code&gt;createElement&lt;/code&gt; 实际上返回？这不&lt;em&gt;正是&lt;/em&gt;一个真正的DOM元素。它可能更准确地命名为 &lt;code&gt;createNodeDescription&lt;/code&gt; ，因为它包含向Vue描述应该在页面上呈现哪种节点的信息，包括任何子节点的描述。我们将此节点描述称为&amp;ldquo;虚拟节点&amp;rdquo;，通常缩写为&lt;strong&gt;VNode&lt;/strong&gt;。&amp;ldquo;虚拟DOM&amp;rdquo;是我们所说的由Vue组件树构建的整个VNode树。</target>
        </trans-unit>
        <trans-unit id="c23944cd8d26c2cb26b60dd0d1caadba140c80c6" translate="yes" xml:space="preserve">
          <source>What is Reactivity?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">什么是Vue.js?</target>
        </trans-unit>
        <trans-unit id="6762984b105eb8b517b607b726e8ea600efa2e2a" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;h()&lt;/code&gt; function returning? It's not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It returns a plain object which contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &quot;virtual node&quot;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &quot;Virtual DOM&quot; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">当 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 有多个孩子时，他们最终应评估为一个孩子。除第一个孩子以外的任何孩子都将被忽略。</target>
        </trans-unit>
        <trans-unit id="4fa4fac2c46b4a9cb5fd7f97a6be2dad1bbe60c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is mutated, the callback will be called &lt;strong&gt;before&lt;/strong&gt; the component has updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">当 &lt;code&gt;isActive&lt;/code&gt; 为真时，呈现的HTML将为：</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;isActive&lt;/code&gt; 或 &lt;code&gt;hasError&lt;/code&gt; 更改时，类列表将相应更新。例如，如果 &lt;code&gt;hasError&lt;/code&gt; 变为 &lt;code&gt;true&lt;/code&gt; ，则类列表将变为 &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">当 &lt;code&gt;ref&lt;/code&gt; 与 &lt;code&gt;v-for&lt;/code&gt; 一起使用时，您获得的ref将是一个包含镜像数据源的子组件的数组。</target>
        </trans-unit>
        <trans-unit id="68799a9bc72bc5436c612e032f0302797e50e850" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setup&lt;/code&gt; is executed, the component instance has not been created yet. As a result, you will only be able to access the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">当 &lt;code&gt;text&lt;/code&gt; 更改时， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 将始终被替换而不是打补丁，因此将触发过渡。</target>
        </trans-unit>
        <trans-unit id="e9a272c5ffb0265f805ce14ec56031bc1589886c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; are both used on the same element, &lt;code&gt;v-if&lt;/code&gt; will be evaluated first. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc1cc0e7f7cb99eda1ea39c8e59b8e52d17b215" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;watchEffect&lt;/code&gt; is called during a component's &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt; function or &lt;a href=&quot;composition-api-lifecycle-hooks&quot;&gt;lifecycle hooks&lt;/a&gt;, the watcher is linked to the component's lifecycle and will be automatically stopped when the component is unmounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6c45281f0e9295693c785e9c077ccf9de2ef90" translate="yes" xml:space="preserve">
          <source>When Vue 2.0 was released, the &lt;code&gt;v-model&lt;/code&gt; directive required developers to always use the &lt;code&gt;value&lt;/code&gt; prop. And if developers required different props for different purposes, they would have to resort to using &lt;code&gt;v-bind.sync&lt;/code&gt;. In addition, this hard-coded relationship between &lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; led to issues with how native elements and custom elements were handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c133285af76b6277f0041e5a1b902c2f3bc7a50" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &quot;in-place patch&quot; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">当Vue更新使用 &lt;code&gt;v-for&lt;/code&gt; 渲染的元素列表时，默认情况下它使用&amp;ldquo;就地补丁&amp;rdquo;策略。如果数据项的顺序已更改，则Vue不会移动DOM元素以使其与项的顺序匹配，而是会在适当位置修补每个元素，并确保它反映了应在该特定索引处呈现的内容。这类似于Vue 1.x 中 &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">当Vue处理指令时， &lt;code&gt;v-for&lt;/code&gt; 的优先级高于 &lt;code&gt;v-if&lt;/code&gt; ，因此该模板：</target>
        </trans-unit>
        <trans-unit id="b259e9996f2602892d2efd59722e6bdb4ae4ddf9" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;, so that this template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee4a8778693915a3019bc1ea6f3a54f6005a00f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ref&lt;/code&gt; is accessed or mutated as a property of a reactive object, it automatically unwraps to the inner value so it behaves like a normal property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">销毁ViewModel时，将自动删除所有事件侦听器。您无需担心自己进行清理。</target>
        </trans-unit>
        <trans-unit id="ea83eee9db8590cd8fc96e20bb41e31cb11921cd" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">创建Vue实例后，它将在其 &lt;code&gt;data&lt;/code&gt; 对象中找到的所有属性添加到Vue的&lt;strong&gt;反应系统中&lt;/strong&gt;。当这些属性的值更改时，视图将&amp;ldquo;反应&amp;rdquo;，更新以匹配新值。</target>
        </trans-unit>
        <trans-unit id="e10ac371624472fea62e8a9b8d7a32ccc5fd883e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &quot;DOM nodes&quot; (opens new window)&lt;/a&gt; to help it keep track of everything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">当浏览器读取此代码时，它会构建一个&lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;&amp;ldquo; DOM节点&amp;rdquo;树&lt;/a&gt;来帮助它跟踪所有内容，就像您可能会构建一个家族树来跟踪您的大家族一样。</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 内部切换组件时，将相应地调用其 &lt;code&gt;activated&lt;/code&gt; 和 &lt;code&gt;deactivated&lt;/code&gt; 生命周期挂钩。</target>
        </trans-unit>
        <trans-unit id="421b8a98b1760ead672f1b77216c67fcc30374a6" translate="yes" xml:space="preserve">
          <source>When a component returns a single root node, non-prop attributes will automatically be added to the root node's attributes. For example, in the instance of a date-picker component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4093e40e3a7a628dc648fbb3e9f015f5439f571" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &quot;merged&quot; using appropriate strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">当mixin和组件本身包含重叠选项时，将使用适当的策略将它们&amp;ldquo;合并&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="15a4799ba709de314050c2aeb417d1c062407080" translate="yes" xml:space="preserve">
          <source>When a native event (e.g., &lt;code&gt;click&lt;/code&gt;) is defined in the &lt;code&gt;emits&lt;/code&gt; option, the component event will be used &lt;strong&gt;instead&lt;/strong&gt; of a native event listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f72c8ed98813c97629aa3dff3ba23fdf14af142" translate="yes" xml:space="preserve">
          <source>When a nested object is accessed from a reactive proxy, that object is &lt;em&gt;also&lt;/em&gt; converted into a proxy before being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db172a75e05ba77d82b2612c1d789b4232b4b0f" translate="yes" xml:space="preserve">
          <source>When a parent listens for the &lt;code&gt;click&lt;/code&gt; event on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0801ddea4aa0f45998c371d842fd8cd4d1bfcbd5" translate="yes" xml:space="preserve">
          <source>When a ref is returned as a property on the render context (the object returned from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;) and accessed in the template, it automatically unwraps to the inner value. There is no need to append &lt;code&gt;.value&lt;/code&gt; in the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00843c9d85b596ab87a52656147b09febbd8f473" translate="yes" xml:space="preserve">
          <source>When a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template, just like any other component property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c053395d17d13ce80a0364c9ff5e250131f80f75" translate="yes" xml:space="preserve">
          <source>When adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt;. This allows for more flexible design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">当插入或删除包含在 &lt;code&gt;transition&lt;/code&gt; 组件中的元素时，将发生以下情况：</target>
        </trans-unit>
        <trans-unit id="a6231838dcc377e59b6f7a45b72b3be9da61805a" translate="yes" xml:space="preserve">
          <source>When assigning a &lt;a href=&quot;refs-api#ref&quot;&gt;ref&lt;/a&gt; to a &lt;code&gt;reactive&lt;/code&gt; property, that ref will be automatically unwrapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">构建 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 组件时，模板最终将不仅包含标题，而且还包含更多内容：</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">当组件开始感到拥挤或难以阅读时,在多行属性之间添加空格可以使它们更容易再次浏览。在一些编辑器中,如Vim,这样的格式化选项也可以使它们更容易用键盘浏览。</target>
        </trans-unit>
        <trans-unit id="309c2a92544230a15a51f890171560d2c2b0da32" translate="yes" xml:space="preserve">
          <source>When creating a form, you can use the following elements: &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">合并自定义选项时，它们将使用默认策略来覆盖现有值。如果要使用自定义逻辑合并自定义选项，则需要将一个函数附加到 &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a48b042d07d089f8ac425b2bfbb816b814258e35" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;app.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">定义&lt;strong&gt;component时&lt;/strong&gt;，必须将 &lt;code&gt;data&lt;/code&gt; 声明为返回初始数据对象的函数，因为将使用相同的定义创建许多实例。如果我们将普通对象用于 &lt;code&gt;data&lt;/code&gt; ，则该对象将在创建的所有实例之间&lt;strong&gt;通过引用共享&lt;/strong&gt;！通过提供 &lt;code&gt;data&lt;/code&gt; 功能，每次创建新实例时，我们都可以调用它以返回初始数据的新副本。</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">使用PascalCase定义组件时，在引用其自定义元素时可以使用任何一种情况。这意味着 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; 都是可以接受的。但是请注意，只有kebab-case名称直接在DOM中有效（即非字符串模板）。</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">使用kebab-case定义组件时，在引用其自定义元素（例如 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 中)时，还必须使用kebab-case 。</target>
        </trans-unit>
        <trans-unit id="8b21b5775a35c4109c91409425882806e5dcafab" translate="yes" xml:space="preserve">
          <source>When defining components in a string template or a single-file component, you have two options when defining component names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066a19ef89f904a34f15aab25b5aa44f5d2acef0" translate="yes" xml:space="preserve">
          <source>When dynamically binding attributes on an element, a common scenario involves using both the &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; syntax as well as individual properties in the same element. However, this raises questions as far as the priority of merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">当每个计算的属性仅包含一个非常简单的表达式，并且具有很少的依赖关系时，编写确认其正确工作的测试要容易得多。</target>
        </trans-unit>
        <trans-unit id="7941adba64b48e32e845c4386f579d258e69a4db" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df23522a9402466e18df90100856fe06a436e73c" translate="yes" xml:space="preserve">
          <source>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">当包含属性名称/键时，对象的参数顺序以前是 &lt;code&gt;(name, value)&lt;/code&gt; 。现在 &lt;code&gt;(value, name)&lt;/code&gt; 与诸如lodash的常见对象迭代器更加一致。</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;index&lt;/code&gt; ，数组的参数顺序通常为 &lt;code&gt;(index, value)&lt;/code&gt; 。现在 &lt;code&gt;(value, index)&lt;/code&gt; 它（值，索引）与JavaScript的本机数组方法（例如 &lt;code&gt;forEach&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; ）更加一致。</target>
        </trans-unit>
        <trans-unit id="c307aa08a2101632c0ad4b3a6317b17bab92e104" translate="yes" xml:space="preserve">
          <source>When it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">在对象上进行迭代时，该顺序基于 &lt;code&gt;Object.keys()&lt;/code&gt; 的枚举顺序，这&lt;strong&gt;不能&lt;/strong&gt;保证在JavaScript引擎实现之间是一致的。</target>
        </trans-unit>
        <trans-unit id="fab3293fcdc1fc50ed0d6ad7581641eed28e2498" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which isn't guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230ed0a7a0be6695cb0d232f9093b7cd6c4fcf5a" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; when listening for key events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">监听键盘事件时，我们通常需要检查特定的键。Vue允许在侦听关键事件时为 &lt;code&gt;v-on&lt;/code&gt; 添加关键修饰符：</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">侦听本机DOM事件时，该方法将本机事件作为唯一参数。如果使用内联语句，则该语句可以访问特殊的 &lt;code&gt;$event&lt;/code&gt; 属性： &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">在编辑器中按字母顺序组织时，应用程序的基本组件都一起列出，从而使它们更易于识别。</target>
        </trans-unit>
        <trans-unit id="74937f5b6caa6e834c6f6b061e657dfd695c54c2" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">当将数组传递给查询参数时，QueryString语法不再是 &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; ，而是新语法是 &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; 。在内部， &lt;code&gt;$route.query.users&lt;/code&gt; 仍然是一个Array，但是如果查询中只有一个参数： &lt;code&gt;/foo?users=Tom&lt;/code&gt; ，当直接访问此路由时，路由器将无法知道我们是否期望 &lt;code&gt;users&lt;/code&gt; 成为一个数组。因此，请考虑添加一个计算属性，并用它替换 &lt;code&gt;$route.query.users&lt;/code&gt; 每个引用：</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">当道具验证失败时,Vue会产生一个控制台警告(如果使用开发版)。</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">注册组件时，将始终为其指定一个名称。例如，到目前为止，在全球注册中，我们已经看到：</target>
        </trans-unit>
        <trans-unit id="23d3b8893cae1a97943ce59e8f17a3cc54c4a8d8" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we've seen so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">设置为 &lt;code&gt;true&lt;/code&gt; 时，将保留并呈现模板中找到的HTML注释。默认行为是丢弃它们。</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">但是，当在这些组件之间切换时，出于性能原因，有时您会想要维护它们的状态或避免重新渲染。例如，当稍微扩展我们的选项卡式界面时：</target>
        </trans-unit>
        <trans-unit id="651beb4b3e6f062a8bc7db612ca2ba6b3d198430" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d915145995bbbbc905958405c390550f8e65e" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746d16bd5abc3a9c7e4d55d39555ad4b65929566" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">当子组件上存在 &lt;code&gt;inline-template&lt;/code&gt; 特殊属性时，该组件将使用其内部内容作为其模板，而不是将其视为分布式内容。这允许更灵活的模板创作。</target>
        </trans-unit>
        <trans-unit id="5c0db747b0eba54fa03d888a984d7c54baac77f8" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &quot;Add Todo&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">渲染组件后， &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; 将被&amp;ldquo;您的配置文件&amp;rdquo;替换。插槽可以包含任何模板代码，包括HTML：</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">当全局过滤器与本地过滤器名称相同时,将优先选择本地过滤器。</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">页面加载后，该元素将获得焦点（注意： &lt;code&gt;autofocus&lt;/code&gt; 在移动Safari上不起作用）。实际上，如果自访问此页面以来您未单击其他任何内容，那么上面的输入现在应该重点关注。现在，让我们构建完成此任务的指令：</target>
        </trans-unit>
        <trans-unit id="53fa055e2ff552cf0106e82aee9a9ceb3b099fb5" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Also, you can click on the &lt;code&gt;Rerun&lt;/code&gt; button and input will be focused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">当 &lt;code&gt;data&lt;/code&gt; 的值是一个对象时，它将在组件的所有实例之间共享。想象一下，例如，一个 &lt;code&gt;TodoList&lt;/code&gt; 组件具有以下数据：</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">当它们存在于同一节点上时， &lt;code&gt;v-for&lt;/code&gt; 的优先级高于 &lt;code&gt;v-if&lt;/code&gt; 。这意味着 &lt;code&gt;v-if&lt;/code&gt; 将分别在循环的每次迭代中运行。当您只想为&lt;em&gt;某些&lt;/em&gt;项目渲染节点时，这将非常有用，如下所示：</target>
        </trans-unit>
        <trans-unit id="4b3806336239800c5ec794a9d3907163b07e9915" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; condition will not have access to variables from the scope of the &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">当此数据更改时，视图将重新呈现。应该注意的是， &lt;code&gt;data&lt;/code&gt; 中的属性仅在创建实例时存在时才是&lt;strong&gt;反应性的&lt;/strong&gt;。这意味着如果您添加一个新属性，例如：</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">当此方法在同一个插件上被多次调用时,该插件将只被安装一次。</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">在具有&lt;strong&gt;相同标签名称的&lt;/strong&gt;元素之间切换时，必须通过给Vue提供唯一的 &lt;code&gt;key&lt;/code&gt; 属性来告诉它们是不同的元素。否则，Vue的编译器将仅替换元素的内容以提高效率。即使在技术上不必要的情况下，&lt;strong&gt;始终在 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 组件中键入多个项目也被认为是一种好习惯。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd996911a0f54f846028a84e8762021497009a" translate="yes" xml:space="preserve">
          <source>When typing a &lt;code&gt;reactive&lt;/code&gt; property, we can use interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">当用于道具绑定时,必须在子组件中正确声明该道具。</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">在组件上使用 &lt;code&gt;v-model&lt;/code&gt; 它会执行以下操作：</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">当在组件上使用时， &lt;code&gt;v-on&lt;/code&gt; 现在仅侦听该组件 &lt;code&gt;$emit&lt;/code&gt; 自定义事件。要在根元素上侦听本地DOM事件，可以使用 &lt;code&gt;.native&lt;/code&gt; 修饰符。例如：</target>
        </trans-unit>
        <trans-unit id="39c2818e21858b65998b9cb9c792d34b526f9165" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt; (opens new window)&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">当用于普通元素时，它仅侦听&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;本地DOM事件&lt;/strong&gt;&lt;/a&gt;。当在自定义元素组件上使用时，它将侦听在该子组件上发出的&lt;strong&gt;自定义事件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7424a99bcccbebcb1704239527c00d6ecfad0963" translate="yes" xml:space="preserve">
          <source>When used on components, custom directive will always apply to component's root node, similarly to &lt;a href=&quot;component-attrs&quot;&gt;non-prop attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">在带有 &lt;code&gt;v-for&lt;/code&gt; 的元素/组件上使用时，注册的引用将是一个包含DOM节点或组件实例的Array。</target>
        </trans-unit>
        <trans-unit id="f4a7dad4c6cfc5b01fc8733a0ec4ecb22ab51d3e" translate="yes" xml:space="preserve">
          <source>When used on normal components, it will behave like a normal prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e732a1c52ca8cf754429434fdc2c9d76e59a40b" translate="yes" xml:space="preserve">
          <source>When used on plain elements, it will be passed to the &lt;code&gt;createElement&lt;/code&gt; call as the &lt;code&gt;is&lt;/code&gt; option, and also rendered as a native attribute. This supports the usage of customized built-in elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351a36d6e4d3bd7a9ce7236de933a0d2d3934ac" translate="yes" xml:space="preserve">
          <source>When used on the reserved &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag, it will behave exactly the same as in 2.x;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">当用于绑定 &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;style&lt;/code&gt; 属性时，它支持其他值类型，例如Array或Objects。有关更多详细信息，请参见下面的链接指南部分。</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">与 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 一起使用时，请确保将其嵌套在其中：</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">与 &lt;code&gt;v-if&lt;/code&gt; 一起使用时， &lt;code&gt;v-for&lt;/code&gt; 的优先级高于 &lt;code&gt;v-if&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;list#v-for-with-v-if&quot;&gt;列表渲染指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">与v-if一起使用时，v-for的优先级高于v-if。有关详细信息，请参见&lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;列表渲染指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5bb95376e672859dca4d4310ff771e83f090090" translate="yes" xml:space="preserve">
          <source>When used together, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. We don't recommend using these two directives together on one element &amp;mdash; see the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;v-bind&lt;/code&gt; 一起使用时，现在只有假值： &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。这意味着 &lt;code&gt;0&lt;/code&gt; 和空字符串将呈现为真。因此，例如， &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; 将呈现为 &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">当不带参数使用时，可用于绑定包含属性名称-值对的对象。请注意，在这种模式下， &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; 不支持Array或Objects。</target>
        </trans-unit>
        <trans-unit id="c92b86613bb50d0d3909045ae62372cbd0ba73dc" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../api/options-data#watch&quot;&gt;the &lt;code&gt;watch&lt;/code&gt; option&lt;/a&gt; to watch an array, the callback will only trigger when the array is replaced. In other words, the watch callback will no longer be triggered on array mutation. To trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37ce001f85a01806e0a868532afd28214a23c8d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../guide/component-registration#local-registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;本地注册时&lt;/a&gt;，您还可以直接提供一个返回 &lt;code&gt;Promise&lt;/code&gt; 的函数：</target>
        </trans-unit>
        <trans-unit id="155dd72290bb5a75b47cd1b727e2637716b8c1c8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;inject&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we also need to explicitly import it from &lt;code&gt;vue&lt;/code&gt;. Once we do so, this allows us to invoke it to define how we want to expose it to our component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71dd171ffdf07ffc560f972b60c7a451789477b7" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;provide&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we start by explicitly importing the method from &lt;code&gt;vue&lt;/code&gt;. This allows us to define each property with its own invocation of &lt;code&gt;provide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">使用 &lt;code&gt;vue-loader&lt;/code&gt; 或 &lt;code&gt;vueify&lt;/code&gt; 时， &lt;code&gt;*.vue&lt;/code&gt; 文件中的模板会在构建时预先编译到JavaScript中。您实际上并不需要最终捆绑包中的编译器，因此可以使用仅运行时构建。</target>
        </trans-unit>
        <trans-unit id="49fe6055e1baf5ecb1fa9c79e5109c02c820ea28" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">当使用JavaScript的过渡只，&lt;strong&gt;在 &lt;code&gt;done&lt;/code&gt; 都需要回调 &lt;code&gt;enter&lt;/code&gt; 和 &lt;code&gt;leave&lt;/code&gt; 挂钩&lt;/strong&gt;。否则，挂钩将被同步调用，并且转换将立即完成。</target>
        </trans-unit>
        <trans-unit id="492a825e70975417fd58f060648eb43809c5835c" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately. Adding &lt;code&gt;:css=&quot;false&quot;&lt;/code&gt; will also let Vue know to skip CSS detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8e11afcc19c58163c7f043d414ef7a0a2eb199" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &quot;flash of unstyled content&quot;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">使用单文件组件时，组件内部的CSS 通过JavaScript 作为 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签动态注入。这样的运行时成本很小，如果您使用服务器端渲染，将导致&amp;ldquo;未样式化内容的闪烁&amp;rdquo;。将所有组件中的CSS提取到同一文件中将避免这些问题，并且还可以实现更好的CSS缩小和缓存。</target>
        </trans-unit>
        <trans-unit id="6ae9007703022fa5cb7c0cd322bf3a50ec4cecf4" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools (opens new window)&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">使用Vue时，我们还建议您在浏览器中安装&lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;，使您可以在更加用户友好的界面中检查和调试Vue应用程序。</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">使用Webpack或Browserify之类的构建工具时，生产模式将由Vue源代码中的 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 确定，默认情况下处于开发模式。两种构建工具均提供了覆盖此变量以启用Vue生产模式的方法，并且在构建过程中，警告信息将被压缩程序清除。所有 &lt;code&gt;vue-cli&lt;/code&gt; 模板均已为您预先配置了这些模板，但是了解如何完成将是有益的：</target>
        </trans-unit>
        <trans-unit id="73ab3894a5373b24631fe2355bde56549085fb2c" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. Vue CLI has this pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feb3981a84943e5fbab5765c5ec53aded8a95c4" translate="yes" xml:space="preserve">
          <source>When using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">在使用in-DOM模板(直接在HTML文件中编写的模板)时,你还应该避免用大写字符来命名键,因为浏览器会强制将属性名改为小写。</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">当使用in-DOM模板或in-JavaScript模板字符串时,模板到渲染函数的编译是在飞行中进行的。在大多数情况下,这通常是足够快的,但如果你的应用程序对性能敏感,最好避免这样做。</target>
        </trans-unit>
        <trans-unit id="52a194f1e41a6a5db000b3e319f51a2d953f4422" translate="yes" xml:space="preserve">
          <source>When using outside of &lt;a href=&quot;#setup&quot;&gt;setup&lt;/a&gt; or &lt;a href=&quot;#lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt;, please call &lt;code&gt;getCurrentInstance()&lt;/code&gt; on &lt;code&gt;setup&lt;/code&gt; and use the instance instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8268513fd3714a6bb1e18655deb42d64d8195501" translate="yes" xml:space="preserve">
          <source>When using reactive provide / inject values, &lt;strong&gt;it is recommended to keep any mutations to reactive properties inside of the &lt;em&gt;provider&lt;/em&gt; whenever possible&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">在组件上使用 &lt;code&gt;data&lt;/code&gt; 属性时（即 &lt;code&gt;new Vue&lt;/code&gt; 以外的任何地方），该值必须是返回对象的函数。</target>
        </trans-unit>
        <trans-unit id="29cfa5029bb45e9515038e53406ba42c15ddb95c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;setup&lt;/code&gt; function, it will take two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe17ea531d76bcff516416b2c63a3806ff1db39b" translate="yes" xml:space="preserve">
          <source>When using the Composition API, the concept of &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;reactive refs&lt;/a&gt; and &lt;a href=&quot;component-template-refs&quot;&gt;template refs&lt;/a&gt; are unified. In order to obtain a reference to an in-template element or component instance, we can declare a ref as usual and return it from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2325636eb7899967fe90bf565cfdf8509e2423d9" translate="yes" xml:space="preserve">
          <source>When using the render function, i.e., &lt;code&gt;h&lt;/code&gt;, 2.x used to define the &lt;code&gt;slot&lt;/code&gt; data property on the content nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b53ab6a7a09c723aad6b1a3af71ea61e4b6a3b8" translate="yes" xml:space="preserve">
          <source>When using this component inside the initial HTML structure, we can see a problem - the modal is being rendered inside the deeply nested &lt;code&gt;div&lt;/code&gt; and the &lt;code&gt;position: absolute&lt;/code&gt; of the modal takes the parent relatively positioned &lt;code&gt;div&lt;/code&gt; as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b443edf845e80ba0a827955e7f9e75dfd908e2cd" translate="yes" xml:space="preserve">
          <source>When watched value is an object or array, any changes to its properties or elements won't trigger the watcher because they reference the same object/array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3115fa755473f700797db8a3eaa25ac70279399a" translate="yes" xml:space="preserve">
          <source>When watching an array, the callback will only trigger when the array is replaced. If you need to trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">当我们点击按钮时，我们需要与家长沟通，它应该放大所有帖子的文本。幸运的是，Vue实例提供了一个自定义事件系统来解决此问题。父级可以选择使用 &lt;code&gt;v-on&lt;/code&gt; 侦听子组件实例上的任何事件，就像我们处理本机DOM事件一样：</target>
        </trans-unit>
        <trans-unit id="56b6480e99f62d0b0a2594baeb4025339f0556be" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. To solve this problem, component instances provide a custom events system. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">当我们定义 &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; 组件时，您可能已经注意到 &lt;code&gt;data&lt;/code&gt; 不是直接提供给对象的，如下所示：</target>
        </trans-unit>
        <trans-unit id="07b462f32af9d739921941c237aa3a2d6e82914c" translate="yes" xml:space="preserve">
          <source>When we want to use a few properties of the large reactive object, it could be tempting to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring (opens new window)&lt;/a&gt; to get properties we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25563d9cbbe500885b8017f11094dbe20ce5416" translate="yes" xml:space="preserve">
          <source>When we were learning about form input bindings, we saw that &lt;code&gt;v-model&lt;/code&gt; has &lt;a href=&quot;forms#modifiers&quot;&gt;built-in modifiers&lt;/a&gt; - &lt;code&gt;.trim&lt;/code&gt;, &lt;code&gt;.number&lt;/code&gt; and &lt;code&gt;.lazy&lt;/code&gt;. In some cases, however, you might also want to add your own custom modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">当包裹在动态组件周围时， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 会缓存不活动的组件实例而不会破坏它们。类似于 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 是一个抽象组件：它不呈现DOM元素本身，也不显示在组件父链中。</target>
        </trans-unit>
        <trans-unit id="6024fe4000d9406c04c3b8e635b2733012f8d604" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">创建Vue实例时，您会传入&lt;strong&gt;options对象&lt;/strong&gt;。本指南的大部分内容介绍了如何使用这些选项来创建所需的行为。作为参考，您也可以浏览&lt;a href=&quot;../api/index#Options-Data&quot;&gt;API参考中&lt;/a&gt;的完整选项列表。</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">直接使用索引设置项目时，例如 &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">当您开始使用仅基于 &lt;code&gt;level&lt;/code&gt; 属性生成标题的组件时，您很快就会得出以下结论：</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">当您仔细观察时，您会发现这些组件实际上是渲染树中彼此的后代&lt;em&gt;和&lt;/em&gt;祖先-这是一个悖论！在 &lt;code&gt;Vue.component&lt;/code&gt; 全局注册组件时，此矛盾会自动为您解决。如果是这样，您可以在这里停止阅读。</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">修改数组的长度时，例如 &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">当您将纯JavaScript对象作为 &lt;code&gt;data&lt;/code&gt; 选项传递给Vue实例时，Vue将遍历其所有属性，并使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt;将它们转换为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter / setter&lt;/a&gt;。这是仅ES5且不可调整的功能，这就是Vue不支持IE8及以下版本的原因。</target>
        </trans-unit>
        <trans-unit id="933b3b1c3bc981ed309ab3c1c26b343f83550c6c" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to an application or component instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;Proxies (opens new window)&lt;/a&gt; using a handler with getters and setters. This is an ES6-only feature, but we offer a version of Vue 3 that uses the older &lt;code&gt;Object.defineProperty&lt;/code&gt; to support IE browsers. Both have the same surface API, but the Proxy version is slimmer and offers improved performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc08c055658d2907306b28227fc08089b9c9d0b" translate="yes" xml:space="preserve">
          <source>When you pass an object to a component instance as data, Vue converts it to a proxy. This proxy enables Vue to perform dependency-tracking and change-notification when properties are accessed or modified. Each property is considered a dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">使用 &lt;code&gt;Vue.component&lt;/code&gt; 在全局范围内注册组件时，全局ID将自动设置为组件的 &lt;code&gt;name&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="3a59415917e0f7bce0c1e1ce588bc65642dde4e2" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">更新数字时，更改会在输入下方显示动画。这使演示变得不错，但是那些不直接存储为数字的东西呢，例如任何有效的CSS颜色呢？这是我们可以使用&lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt;和&lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;完成的方法：</target>
        </trans-unit>
        <trans-unit id="e0e5cc8bd4dbd3f0f73f17bc44dd88fc965b701e" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes (opens new window)&lt;/a&gt; in &lt;code&gt;:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">当您使用需要一个CSS属性&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;供应商前缀&lt;/a&gt;的 &lt;code&gt;v-bind:style&lt;/code&gt; ，比如 &lt;code&gt;transform&lt;/code&gt; ，Vue公司会自动检测并添加适当的前缀到应用的样式。</target>
        </trans-unit>
        <trans-unit id="6b1215d8f619fb72cc267754d02609941e493e8b" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component with a single root element, those classes will be added to this element. Existing classes on this element will not be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">在自定义组件上使用 &lt;code&gt;class&lt;/code&gt; 属性时，这些类将被添加到组件的根元素中。此元素上的现有类不会被覆盖。</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">当你想使用槽内的数据时,如在。</target>
        </trans-unit>
        <trans-unit id="5224afaf87d02d75b63b7c58580593c3450a4bdb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;counter&lt;/code&gt; is modified, for example &lt;code&gt;counter.value = 5&lt;/code&gt;, the watch will trigger and execute the callback (second argument) which in this case will log &lt;code&gt;'The new counter value is: 5'&lt;/code&gt; into our console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">只要有多个插槽，就对&lt;em&gt;所有&lt;/em&gt;插槽使用完整的基于 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 的语法：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c59757a70411453c39e9877f5bd40fa36fe8fd5" translate="yes" xml:space="preserve">
          <source>Whenever this plugin is added to an application, the &lt;code&gt;install&lt;/code&gt; method will be called if it is an object. If it is a &lt;code&gt;function&lt;/code&gt;, the function itself will be called. In both cases, it will receive two parameters - the &lt;code&gt;app&lt;/code&gt; object resulting from Vue's &lt;code&gt;createApp&lt;/code&gt;, and the options passed in by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">如果存在多个同样好的选择，则可以做出任意选择以确保一致性。在这些规则中，我们描述了每个可接受的选项并建议一个默认选项。这意味着，只要您保持一致并有充分的理由，就可以在自己的代码库中做出其他选择。不过请有充分的理由！通过适应社区标准，您将：</target>
        </trans-unit>
        <trans-unit id="40389be7b40b64109eb2a221c81a64962b25ce29" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">迁移应该从哪里开始?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">只要可以用普通的JavaScript轻松完成某些任务，Vue渲染函数就不会提供专有的替代方法。例如，在使用 &lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-for&lt;/code&gt; 的模板中：</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">当前Vue实例是否在服务器上运行。</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">可以在模板中使用,控制所有博客文章的字体大小。</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">也可以写成:</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">可能会出现这样的情况:</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">您正在使用哪些过时的功能。大多数都可以通过查找和替换进行升级，但是其他一些可能需要几分钟。如果您当前未遵循最佳做法，Vue 2.0也会更加努力地强迫您这样做。从长远来看，这是一件好事，但也可能意味着重大的重构（尽管可能过期）。</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">这将使。</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">Vue的缩放比例与React一样，但它的缩放比例与jQuery一样。没错-首先，您只需将一个脚本标签放入页面即可：</target>
        </trans-unit>
        <trans-unit id="67526a3ad5381ad5a3d17e38178b4ebbd75ccade" translate="yes" xml:space="preserve">
          <source>While Vue.js does not natively support mobile app development, there are a number of solutions for creating native iOS and Android apps with Vue.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d93357bd259acbade7c18b02dac0a7c343f7e5" translate="yes" xml:space="preserve">
          <source>While all the examples on this page only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">虽然不需要任何空格的属性值都不需要在HTML中带有引号，但是这种做法通常会导致&lt;em&gt;避免使用&lt;/em&gt;空格，从而使属性值的可读性降低。</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">尽管计算的属性在大多数情况下更合适，但有时还是需要自定义观察程序。这就是为什么Vue提供了一种更通用的方式来通过 &lt;code&gt;watch&lt;/code&gt; 选项对数据更改做出反应。当您要执行异步或昂贵的操作以响应更改的数据时，此功能非常有用。</target>
        </trans-unit>
        <trans-unit id="fd4fac6fce5850105ed2b54389e0980507751bfb" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58ceb4be486c0d3bcb8a6914f2874907486034f" translate="yes" xml:space="preserve">
          <source>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd77b96c3d24d46385ee19732ac45b61f33bee8a" translate="yes" xml:space="preserve">
          <source>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">尽管最好使用显式定义的props将信息传递给子组件，但是组件库的作者并不总是能预见可能使用其组件的上下文。这就是组件可以接受任意属性的原因，这些属性被添加到组件的根元素中。</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">尽管模板对大多数组件都适用，但很明显，模板不是其中之一。因此，让我们尝试使用 &lt;code&gt;render&lt;/code&gt; 函数重写它：</target>
        </trans-unit>
        <trans-unit id="dccd95c62bd449380bb4f7810be214fe6f2cc294" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a &lt;code&gt;render()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f53a61720d34f8deb200583fb4293a0b28f026" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4a80a732fb32a76bcecd383d1d0a7ebd43cd2" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d958d9d37ed58a5f1f97ee679c1620d781626e" translate="yes" xml:space="preserve">
          <source>While this approach is convenient, it leads to a couple of problems. Technically, Vue 2 doesn't have a concept of an &quot;app&quot;. What we define as an app is simply a root Vue instance created via &lt;code&gt;new Vue()&lt;/code&gt;. Every root instance created from the same Vue constructor &lt;strong&gt;shares the same global configuration&lt;/strong&gt;. As a result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26388458f8fca7cd6a63de038df2a21f485dd436" translate="yes" xml:space="preserve">
          <source>While this seems like a convenience, it requires a custom syntax that breaks the assumption of expressions inside of curly braces being &quot;just JavaScript,&quot; which has both learning and implementation costs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaa3f23ca2ee3059b2128051891a6ae3197f8a2" translate="yes" xml:space="preserve">
          <source>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008a9bd1fd351881294a8ab7c58eff00ecd921e6" translate="yes" xml:space="preserve">
          <source>Why Composition API?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">为什么要在HTML中使用监听器?</target>
        </trans-unit>
        <trans-unit id="d05a9a10126e300cca0827aed2703aed49fcd394" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;code&gt;list&lt;/code&gt;, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;code&gt;list&lt;/code&gt;. Without caching, we would be executing &lt;code&gt;list&lt;/code&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a &lt;code&gt;method&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">为什么我们需要缓存？想象一下，我们有一个昂贵的计算属性&lt;strong&gt;A&lt;/strong&gt;，它需要遍历巨大的Array并进行大量计算。然后，我们可以有其他的计算性能，在又取决于&lt;strong&gt;一个&lt;/strong&gt;。如果不进行缓存，我们执行&lt;strong&gt;A&lt;/strong&gt;的getter的次数将超过必要次数！如果您不想缓存，请改用一种方法。</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">将相当于。</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">将被评价为类似于:</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">将改用定义。</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">将导致。</target>
        </trans-unit>
        <trans-unit id="5bcd42cce76c522e00acc375bb83a386e44895e9" translate="yes" xml:space="preserve">
          <source>Will throw an error, because the &lt;code&gt;v-if&lt;/code&gt; directive will be evaluated first and the iteration variable &lt;code&gt;user&lt;/code&gt; does not exist at this moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b523d2bcf5fca866ffcaea5c846072e6f454e3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2972362a724a19189b0c528b9c31cb4d552d316e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;migration/fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root nodes. When applied to a multi-root component, directive will be ignored and the warning will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3c68936845bcadd633acd3c5e92f54a35dd57a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&amp;lt;template v-for&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">借助 &lt;code&gt;.vue&lt;/code&gt; 组件，我们进入了高级JavaScript应用程序领域。这意味着您还需要学习使用一些其他工具：</target>
        </trans-unit>
        <trans-unit id="e3840f18f3809fb17a5fc20b99dd0f910da3163d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">使用 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 和 &lt;code&gt;$attrs&lt;/code&gt; ，您可以手动决定要将属性转发到哪个元素，这对于&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本组件&lt;/a&gt;通常是理想的：</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">使用构建工具</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">带组件</target>
        </trans-unit>
        <trans-unit id="e94afd24abb64d9b90f7248caba76323b7bd6df5" translate="yes" xml:space="preserve">
          <source>With Composition API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">使用ES2015 Symbols，功能 &lt;code&gt;provide&lt;/code&gt; 和对象 &lt;code&gt;inject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">使用MobX</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">在基于对象的语法中,你可以使用以下选项。</target>
        </trans-unit>
        <trans-unit id="0ddaa6dc6d7bbbc58f451bb92e742747f8a0ad5d" translate="yes" xml:space="preserve">
          <source>With Options API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">使用PascalCase</target>
        </trans-unit>
        <trans-unit id="8e3c02906d7a5cad13118eea9109a6e2b7c11fa1" translate="yes" xml:space="preserve">
          <source>With Vue 3, the API for two-way data binding is being standardized in order to reduce confusion and to allow developers more flexibility with the &lt;code&gt;v-model&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6e8d5c594ae0eeedbf57f7bb713ef9a3488318" translate="yes" xml:space="preserve">
          <source>With a Bundler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c796447490b9562e329b4eb4f3c1a45c3a13ab" translate="yes" xml:space="preserve">
          <source>With all these changes, the component and directive we have at the beginning of the guide will be rewritten into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f67259032ce5e6a9b51cd6c8ee262fb5c3605c" translate="yes" xml:space="preserve">
          <source>With global tree-shaking, the user only &amp;ldquo;pay&amp;rdquo; for the features they actually use. Even better, knowing that optional features won't increase the bundle size for applications not using them, framework size has become much less a concern for additional core features in the future, if at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">带烤肉盒</target>
        </trans-unit>
        <trans-unit id="5262fdf2404668ac87ace7bc5320c88ae3fec32d" translate="yes" xml:space="preserve">
          <source>With npm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">通过添加一个属性，我们修复了原始过渡，而无需添加任何特殊样式。</target>
        </trans-unit>
        <trans-unit id="689393a6c1bd0377fbe965e3cad93231017b2f2b" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we've fixed that original transition without having to add any special styling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36361bcb7732d5e11757dbbeec045c06c4c7e7ac" translate="yes" xml:space="preserve">
          <source>With render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">话虽如此，对于某些React用户来说，这种比较不可避免地会偏向于Vue，因为所探讨的许多主题在某种程度上都是主观的。我们承认存在不同的技术品味，此比较的主要目的是概述如果您的偏爱恰好与我们的偏好相符，Vue可能更适合的原因。</target>
        </trans-unit>
        <trans-unit id="74293b552f92b191f072c0da0451d95393b6de4a" translate="yes" xml:space="preserve">
          <source>With the behavior change of &lt;code&gt;is&lt;/code&gt;, we introduce a new directive &lt;code&gt;v-is&lt;/code&gt; for working around these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">借助新的转换系统，您现在可以&lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;将组件用于可重复使用的转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3828ac5cca844bde7e12cdc97494a2e145077de0" translate="yes" xml:space="preserve">
          <source>With the second parameter, we can pass root props to the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d2800ca9c44c02e89db888766c57a4c894655" translate="yes" xml:space="preserve">
          <source>With the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5db4b3ecbbcef145192161b4e8a9adf72f34af" translate="yes" xml:space="preserve">
          <source>With this change, provided the module bundler supports tree-shaking, global APIs that are not used in a Vue application will be eliminated from the final bundle, resulting in an optimal file size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">有了这些知识,我们现在可以完成我们开始的组件。</target>
        </trans-unit>
        <trans-unit id="c0b51b14ed767e15b6133cfad9870cba3b70f4a4" translate="yes" xml:space="preserve">
          <source>With this new configuration, our &lt;code&gt;data-status&lt;/code&gt; attribute will be applied to our &lt;code&gt;input&lt;/code&gt; element!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d064e70d3aeb0eac7d3ba972b7156b0acdc5ed48" translate="yes" xml:space="preserve">
          <source>With those changes in place, we've just moved the whole first logical concern into a single place. We can now do the same with the second concern &amp;ndash; filtering based on &lt;code&gt;searchQuery&lt;/code&gt;, this time with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">在子组件中，我们可以使用此页面上介绍的过渡策略的任意组合，以及Vue &lt;a href=&quot;transitions&quot;&gt;内置的过渡系统提供的策略&lt;/a&gt;。总之，可以完成的工作几乎没有限制。</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">没有构建工具</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">哇-这是一本超长的页面！这是否意味着2.0完全不同，我将不得不重新学习基础知识，并且迁移几乎是不可能的？</target>
        </trans-unit>
        <trans-unit id="c9e02cb643a613f1c79faab9079d2f3e58edae60" translate="yes" xml:space="preserve">
          <source>Working with reactivity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3413e9fc86a733fea321b8d4f5dce2cd96c7c946" translate="yes" xml:space="preserve">
          <source>Wrapping values inside an object might seem unnecessary but is required to keep the behavior unified across different data types in JavaScript. That&amp;rsquo;s because in JavaScript, primitive types like &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; are passed by value, not by reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357865535aa2a476144e9beb3464ba1cbdbcf27" translate="yes" xml:space="preserve">
          <source>Writing &amp;amp; Grammar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">编写可测试组件</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">编写一个插件</target>
        </trans-unit>
        <trans-unit id="4835d6c16769322c715842b97457649636213963" translate="yes" xml:space="preserve">
          <source>Writing documentation is an exercise in empathy. We're not describing an objective reality - the source code already does that. Our job is to help shape the relationship between users and the Vue ecosystem. This ever-evolving guide provides some rules and recommendations on how to do that consistently within the Vue ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="3da53c899f2de058d0a78dc035fc82fa4168e261" translate="yes" xml:space="preserve">
          <source>Yes! We are ready for translation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">是的，即使Vue中的转换也是由数据驱动的！动态转换的最基本示例将 &lt;code&gt;name&lt;/code&gt; 属性绑定到动态属性。</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">实际上，您不再需要进行调试，因为Vue会自动为您格式化输出格式，无论是字符串，数字，数组还是普通对象。但是，如果您想要与JavaScript的 &lt;code&gt;JSON.stringify&lt;/code&gt; 完全相同的功能，则可以在方法或计算属性中使用它。</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">你不得不更加明确,给你的胁迫值取一个与道具中传递的值相区别的名字。</target>
        </trans-unit>
        <trans-unit id="259bd96ca0effe183387e9e5f024f56b5205a591" translate="yes" xml:space="preserve">
          <source>You can access a component's lifecycle hook by prefixing the lifecycle hook with &quot;on&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">您可以从&lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt;中将静态插槽内容作为VNode数组访问：</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">您还&lt;a href=&quot;../api/index#keyCodes&quot;&gt;可以&lt;/a&gt;通过全局 &lt;code&gt;config.keyCodes&lt;/code&gt; 对象定义自定义按键修饰符别名：</target>
        </trans-unit>
        <trans-unit id="1813d70fbaf8bba2c2a5a3785639129921bc5052" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally for a Vue application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">您也可以全局应用mixin。请谨慎使用！一旦全局应用了mixin，它将影响之后创建的&lt;strong&gt;每个&lt;/strong&gt; Vue实例。如果使用得当，则可用于为自定义选项注入处理逻辑：</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">您还可以声明额外的全局属性和组件选项。</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">你也可以在属性中定义JavaScript钩子。</target>
        </trans-unit>
        <trans-unit id="beebaf9986e9097a2444f204aa81ae1c568b7cbd" translate="yes" xml:space="preserve">
          <source>You can also give the input an accessible name with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute&quot;&gt;&lt;code&gt;aria-label&lt;/code&gt; (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503a3e28cf5a8489e2b8f7a242ab27389b2b6691" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/directives#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;../api/index#v-once&quot;&gt;v-once指令&lt;/a&gt;执行一次性插值，该插值不会随着数据更改而更新，但是请记住，这也会影响同一节点上的任何其他绑定：</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">您还可以为属性名称（又称键）提供第二个参数：</target>
        </trans-unit>
        <trans-unit id="7e590ee53b15356b15c6804307c06fa95680eb6f" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property's name (a.k.a. key):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">您还可以在工厂函数中返回 &lt;code&gt;Promise&lt;/code&gt; ，因此使用Webpack 2和ES2015语法可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2f9cab99bb92ad04f5fd1ef133a533bca320077d" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 or later and ES2015 syntax you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">您也可以通过提供以下属性来指定自定义过渡类。</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">您还可以为进入和离开的持续时间分别指定数值。</target>
        </trans-unit>
        <trans-unit id="b708002bf5e4f269767c152c0103659f003ed958" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;defineAsyncComponent&lt;/code&gt; when &lt;a href=&quot;component-registration#local-registration&quot;&gt;registering a component locally&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">您也可以使用 &lt;code&gt;of&lt;/code&gt; 作为分隔符，而不是 &lt;code&gt;in&lt;/code&gt; ，以便它更接近JavaScript迭代器的语法：</target>
        </trans-unit>
        <trans-unit id="56680b86213ebfab218348e1f259349ba40ffdea" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript's syntax for iterators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">您也可以使用 &lt;code&gt;v-for&lt;/code&gt; 遍历对象的属性。</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt;实例方法，该方法是全局 &lt;code&gt;Vue.set&lt;/code&gt; 的别名：</target>
        </trans-unit>
        <trans-unit id="caa2f5e4a5e7cb8569f06fc887bf75bbeb1e905a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://vuejs.org/v2/api/#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt; (opens new window)&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7016af3cddf281827fcb1fb635902cd99d67f65c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;is&lt;/code&gt; attribute to create regular HTML elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">您还可以使用 &lt;code&gt;vm.$set&lt;/code&gt; 实例方法，该方法是全局 &lt;code&gt;Vue.set&lt;/code&gt; 的别名：</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">您还可以使用 &lt;code&gt;vm.$set&lt;/code&gt; 实例方法，该方法是全局 &lt;code&gt;Vue.set&lt;/code&gt; 的别名：</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">您可以使用 &lt;code&gt;propsData&lt;/code&gt; 选项使用不同的props声明其渲染输出：</target>
        </trans-unit>
        <trans-unit id="a1723b0ed33c8953b91ffd8fc42e598875ee5aa7" translate="yes" xml:space="preserve">
          <source>You can bind as many attributes to the &lt;code&gt;slot&lt;/code&gt; as you need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9450a9423cc08d4d6f86fddb51f97f1895339a" translate="yes" xml:space="preserve">
          <source>You can browse the full application API in the &lt;a href=&quot;../api/application-api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;浏览NPM软件包的源代码。</target>
        </trans-unit>
        <trans-unit id="3a50584cf2f28b29d5933a7806dfd6c8fe93a173" translate="yes" xml:space="preserve">
          <source>You can chain other methods after &lt;code&gt;createApp&lt;/code&gt;, they can be found in &lt;a href=&quot;application-api&quot;&gt;Application API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a108d1490b085325e471f3c57d3e9dc0f3ae2bc3" translate="yes" xml:space="preserve">
          <source>You can change &lt;code&gt;seen&lt;/code&gt; from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the sandbox below to check the effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb59a77a247c2d91532f11b2a60d478be4cab66" translate="yes" xml:space="preserve">
          <source>You can check &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; component options in the &lt;a href=&quot;../api/built-in-components#teleport&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48aa82a368ad205d3da3994cb186cdc0a22d46d8" translate="yes" xml:space="preserve">
          <source>You can check the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;prevVnode&lt;/code&gt;) in &lt;a href=&quot;../api/application-api#directive&quot;&gt;Custom Directive API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a321e28dae8c3d2b4ba9a95524f5a758d218685" translate="yes" xml:space="preserve">
          <source>You can check the list of available options in the &lt;a href=&quot;../api/global-api#arguments-4&quot;&gt;API Reference&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498c9c8804cc7d12217ea3d9f3524d82346ca9db" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; depends on &lt;code&gt;vm.author.books&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; when &lt;code&gt;vm.author.books&lt;/code&gt; changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">您可以将数据绑定到模板中的计算属性，就像普通属性一样。Vue知道 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 依赖于 &lt;code&gt;vm.message&lt;/code&gt; ，因此当 &lt;code&gt;vm.message&lt;/code&gt; 更改时，它将更新任何依赖于 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的绑定。最棒的是，我们以声明方式创建了这种依赖关系：计算得到的getter函数没有副作用，这使得测试和理解起来更加容易。</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">您可以在组件的选项中定义本地过滤器：</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">如果愿意，您可以在组件名称中绝对包含这些连接器词，但是顺序仍然很重要。</target>
        </trans-unit>
        <trans-unit id="f39a90801437ef44d3dae3a0d0e800d9fa37f7c2" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you'd like, but the order is still important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">您可以像任何普通元素一样直接在自定义组件上使用 &lt;code&gt;v-for&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a0f496ff2b9d3f296d22a7febb3e4014d60fe282" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt; (opens new window)&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">您可以将通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt;公开的任何有效键名直接用作修饰符，方法是将它们转换为kebab-case。</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">你甚至可以定义后备选项,以便在一个插槽道具未定义时使用。</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">你甚至可以按多列排序。</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">您甚至可以使用预处理器,如Pug(以前称为Jade)来编写您的Vue模板。</target>
        </trans-unit>
        <trans-unit id="bcde8b53cf3059c4972d20e4534b1e469ee4c5fb" translate="yes" xml:space="preserve">
          <source>You can find more information at this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b95ad424054751a98acdcf21d4dc4035ab20f" translate="yes" xml:space="preserve">
          <source>You can get a lot of unique effects and make your animation very stylish by adjusting your easing. CSS allows you to modify this by adjusting a cubic bezier property, &lt;a href=&quot;https://cubic-bezier.com/#.17,.67,.83,.67&quot;&gt;this playground (opens new window)&lt;/a&gt; by Lea Verou is very helpful for exploring this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df595af00721f8288076a5f9fba469b9a917832" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">您可以通过在对象中具有更多字段来切换多个类。另外， &lt;code&gt;v-bind:class&lt;/code&gt; 指令也可以与纯 &lt;code&gt;class&lt;/code&gt; 属性共存。因此，给出以下模板：</target>
        </trans-unit>
        <trans-unit id="8aa030b589eee93625f4864d21a641f8663ff7c6" translate="yes" xml:space="preserve">
          <source>You can have multiple methods in an event handler separated by a comma operator like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56c7af523fb7e0763535f3902c25d971d409bc6" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;reactive&lt;/code&gt; in the &lt;a href=&quot;../api/basic-reactivity&quot;&gt;Basic Reactivity API's&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08c4fe759a5cd0a79d2084a4f5a83a750978591" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;refs&lt;/code&gt; in the &lt;a href=&quot;../api/refs-api#ref&quot;&gt;Refs API&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bd14a02b45ad31d79cd406616fc79e061cec94" translate="yes" xml:space="preserve">
          <source>You can learn more about component attribute inheritance in &lt;a href=&quot;component-attrs&quot;&gt;Non-Prop Attributes&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">你可以利用完整的编程语言(JavaScript)的力量来构建你的视图。这包括临时变量、流控制以及在范围内直接引用JavaScript值。</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">你可以在这个钩子中修改组件的状态。然而,在你的模板或渲染函数中设置条件是很重要的,当一个错误被捕获时,其他内容会被短路;否则组件将被扔进一个无限的渲染循环。</target>
        </trans-unit>
        <trans-unit id="483010467e7b1520e8252c976ccc95f6183b6a3a" translate="yes" xml:space="preserve">
          <source>You can modify its properties, listed below, before mounting your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">您可以打开控制台并自己玩示例vm。 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的值始终取决于 &lt;code&gt;vm.message&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">您可以打开控制台，并通过调用其突变方法来使用前面示例的 &lt;code&gt;items&lt;/code&gt; 数组。例如： &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7275711fe53486de9349eeef7453708059692c43" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples' &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">你可以选择传入一些选项。</target>
        </trans-unit>
        <trans-unit id="69df9eda77fa786bedb0320c7efdaa4e55ad2623" translate="yes" xml:space="preserve">
          <source>You can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">你可以换成:</target>
        </trans-unit>
        <trans-unit id="f3ebee5b6a0c8de1d1b75a459aa211a5e7be2130" translate="yes" xml:space="preserve">
          <source>You can see how we could use this for data visualization, for physics effects, for character animations and interactions, the sky's the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">您可以在&amp;ldquo; &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;样式指南&amp;rdquo;中&lt;/a&gt;看到有关组件名称的其他建议。</target>
        </trans-unit>
        <trans-unit id="c82861be683435cc1668ccd7f2e6b81cafe38300" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;此处&lt;/a&gt;看到完整的示例。使用 &lt;code&gt;$parent&lt;/code&gt; 的好处是，我们可以在&lt;em&gt;任何&lt;/em&gt;后代组件中访问 &lt;code&gt;getMap&lt;/code&gt; ，而无需暴露 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 的整个实例。这使我们可以更安全地继续开发该组件，而不必担心我们可能会更改/删除子组件所依赖的内容。就像 &lt;code&gt;props&lt;/code&gt; 一样，这些组件之间的接口保持清晰定义。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16bcf864fb3aac6cb97fde8cea277e3092eccb3c" translate="yes" xml:space="preserve">
          <source>You can see the description by inspecting Chrome DevTools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4d8ebb6112a000f5549eb59e46ddfbf5ba539c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &quot;else block&quot; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;v-else&lt;/code&gt; 指令为 &lt;code&gt;v-if&lt;/code&gt; 指示&amp;ldquo;其他块&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">您可以使用 &lt;code&gt;v-model&lt;/code&gt; 指令在表单输入，textarea和select元素上创建双向数据绑定。它会根据输入类型自动选择更新元素的正确方法。尽管有点神奇，但 &lt;code&gt;v-model&lt;/code&gt; 本质上是用于在用户输入事件上更新数据的语法糖，并且在某些情况下需要特别注意。</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">您可以使用以下修饰符,只有在按下相应的修饰键时才能触发鼠标或键盘事件监听器。</target>
        </trans-unit>
        <trans-unit id="8ddb37f26a92a06753b285b9c9c11e196959baab" translate="yes" xml:space="preserve">
          <source>You can use this technique to create functional images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">你可以用:</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">您可以使用 &lt;code&gt;age&lt;/code&gt; 向嵌套的 &lt;code&gt;userProfile&lt;/code&gt; 对象添加新的age属性：</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">你可以用一个程序化的监听器来解决这两个问题。</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">你可以用。</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">你可以写。</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">您无需在组件中进行任何特殊操作即可使其可测试。导出原始选项：</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">在定义组件名称时,您有两个选项。</target>
        </trans-unit>
        <trans-unit id="32c890526e2b50fb6ddd6a47a453deb3b5176a87" translate="yes" xml:space="preserve">
          <source>You may also find that entrances look better with slightly more time than an exit. The user typically is being guided during the entrance, and is a little less patient upon exit because they want to go on their way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">您可能想知道Vue的模板实际上是编译成渲染功能的。这是您通常不需要了解的实现细节，但是如果您想了解特定模板功能的编译方式，您可能会发现它很有趣。下面是一个使用 &lt;code&gt;Vue.compile&lt;/code&gt; 实时编译模板字符串的演示：</target>
        </trans-unit>
        <trans-unit id="8cd17a8f30e925013013a4351cf5807785289ba1" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">你可能想知道。</target>
        </trans-unit>
        <trans-unit id="143b9f4f1dc7d1bfde27bde6e896dca625ded097" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec (opens new window)&lt;/a&gt;. That's because Vue's component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API (opens new window)&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">您可能已经注意到，Vue组件与&amp;ldquo; &lt;strong&gt;自定义元素&amp;rdquo;&lt;/strong&gt;非常相似，后者是&lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web组件规范的一部分&lt;/a&gt;。这是因为Vue的组件语法是按照规范松散建模的。例如，Vue组件实现了&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt;，并且 &lt;code&gt;is&lt;/code&gt; 是特殊属性。但是，有一些主要区别：</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">你可能已经注意到,我们可以通过调用表达式中的方法来实现同样的结果。</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">您可能没有考虑&lt;a href=&quot;list#Caveats&quot;&gt;使用数组&lt;/a&gt;或&lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;对象&lt;/a&gt;进行变更检测的注意事项，或者您可能依赖于Vue的反应性系统无法跟踪的状态，例如 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f78a45e93ff614ad4d560280cdd81744a9547eeb" translate="yes" xml:space="preserve">
          <source>You may notice that the animations shown above are using things like &lt;code&gt;transforms&lt;/code&gt;, and applying strange properties like &lt;code&gt;perspective&lt;/code&gt;- why were they built that way instead of just using &lt;code&gt;margin&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; etc?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">你可能会注意到:</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">您可能想知道为什么我们同时需要 &lt;code&gt;slots()&lt;/code&gt; 和 &lt;code&gt;children&lt;/code&gt; 。会不会 &lt;code&gt;slots().default&lt;/code&gt; 是相同的 &lt;code&gt;children&lt;/code&gt; ？在某些情况下，是的-但是如果您的功能组件包含以下子项，该怎么办？</target>
        </trans-unit>
        <trans-unit id="f4b169dfdbff18ce5e5cf4146c1cf33c657dfab8" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &quot;separation of concerns&quot;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">您可能会担心，整个事件监听方法都违反了有关&amp;ldquo;关注点分离&amp;rdquo;的良好旧规则。请放心-由于所有Vue处理函数和表达式都严格绑定到处理当前视图的ViewModel，因此不会造成任何维护困难。实际上，使用 &lt;code&gt;v-on&lt;/code&gt; 有几个好处：</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">您可能会想通过将子组件嵌套在以父组件命名的目录中来解决这个问题。比如说,你可以把子组件嵌套在以其父名命名的目录中。</target>
        </trans-unit>
        <trans-unit id="a47591adc396778366644573330c716aad893852" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &quot;search&quot; directory, then all the settings components under a &quot;settings&quot; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">您可能会尝试以不同的方式解决此问题，将所有搜索组件嵌套在&amp;ldquo;搜索&amp;rdquo;目录下，然后将所有设置组件嵌套在&amp;ldquo;设置&amp;rdquo;目录下。出于以下原因，我们建议仅在大型应用程序（例如100多个组件）中考虑使用此方法：</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">你可能会认为这会导致Vue扔掉现有的DOM并重新渲染整个列表--幸运的是,情况并非如此。Vue实现了一些智能的启发式方法来最大化DOM元素的重用,所以用另一个包含重叠对象的数组替换一个数组是一个非常高效的操作。</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">通常，您不必使用它们，但是在需要手动侦听组件实例上的事件的情况下，它们是可用的。它们还可以用作代码组织工具。例如，您可能经常会看到这种用于集成第三方库的模式：</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">您将一个路由器属性传递给Vue实例。</target>
        </trans-unit>
        <trans-unit id="efb25a0ae9444bc1df853a464d4343356ffb5415" translate="yes" xml:space="preserve">
          <source>You probably have noticed the use of &lt;code&gt;toRefs&lt;/code&gt; at the top of our &lt;code&gt;setup&lt;/code&gt;. This is to ensure our watcher will react to changes made to the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6607184e34ec98c705e8936d4bd119debd7a5883" translate="yes" xml:space="preserve">
          <source>You should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">您应该确保 &lt;code&gt;text&lt;/code&gt; 的初始值是&amp;ldquo; hello world&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0388064a0faab22748fe939b523209cc3a4161d9" translate="yes" xml:space="preserve">
          <source>You should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">你仍然可以获得道具的原始价值。</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">你会添加新的、反应性的属性与。</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">你现在要写。</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">你会用:</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">您需要像这样更新它：</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">您会注意到，如果选择帖子，请切换至&amp;ldquo; &lt;em&gt;存档&amp;rdquo;&lt;/em&gt;标签，然后再切换回&amp;ldquo; &lt;em&gt;帖子&amp;rdquo;&lt;/em&gt;，它将不再显示您选择的帖子。这是因为每次切换到新选项卡时，Vue都会创建一个 &lt;code&gt;currentTabComponent&lt;/code&gt; 的新实例。</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">稍后您将看到改性剂的其他例子，&lt;a href=&quot;events#Event-Modifiers&quot;&gt;用于 &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;forms#Modifiers&quot;&gt;为 &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt;，当我们探究这些功能。</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">您还看到了通过 &lt;code&gt;v-bind&lt;/code&gt; 动态分配的道具，例如：</target>
        </trans-unit>
        <trans-unit id="e7be35175595e36028a58566d499b0922b290b29" translate="yes" xml:space="preserve">
          <source>You'll find very quickly that &lt;code&gt;out-in&lt;/code&gt; is the state you will want most of the time 😃</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534161e1c7e94319d05a92ec6723a8bacc8c01a4" translate="yes" xml:space="preserve">
          <source>You'll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daeca355004e5e6b6695c8995c5901fed3362699" translate="yes" xml:space="preserve">
          <source>You'll see other examples of modifiers later, &lt;a href=&quot;events#event-modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a835cf811b8522c8db0e1f6d873fc28bdc60bb" translate="yes" xml:space="preserve">
          <source>You've also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt; or its shortcut, the &lt;code&gt;:&lt;/code&gt; character, such as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b27e33e416edbd67daffe51a424c0c9ef6b0f3" translate="yes" xml:space="preserve">
          <source>Your browser does not support the video tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">你的内联模板需要在Vue所连接的DOM元素中定义。</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">你的x-template需要在Vue所连接的DOM元素之外定义。</target>
        </trans-unit>
        <trans-unit id="719b3279429110b4281221c4c4d4388f5c5f6d57" translate="yes" xml:space="preserve">
          <source>ZoomText (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954963c855d044c40d394debb8685e798d25e0c3" translate="yes" xml:space="preserve">
          <source>Zooming Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a221925ebff8ab7b21b8e492fd8afd314da61e41" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/eslint-plugin-vue&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b02ba7769882289f391dd6032af22b8a8bcfc" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/jsx-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25af989e02d5c99908ae438d2926502894ee2e7e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/rollup-plugin-vue/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baa16f6d48ca446fc08d35723e042c4ab28008f" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-class-component/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36204eda54f3ff6c52797fd1a52e5a030c6b5463" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-loader/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8ba12c942b8b26403cd1f4cc7f6445d6ba6cd3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-test-utils-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[] &lt;sup&gt;已删除&lt;/sup&gt;查询中数组的语法&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">组件的选项对象</target>
        </trans-unit>
        <trans-unit id="aac58ea6af883add3a2d5783edf0931a374353ca" translate="yes" xml:space="preserve">
          <source>a component's options object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">计算式</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">一个数据属性,该道具用于设置其默认值。</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">一个字符串数组,或</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">一个对象,其中键是本地绑定名称,值是:</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">一个对象,其中:</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">祖先组件不需要知道哪些后代使用它提供的属性</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">和自定义JavaScript钩子。</target>
        </trans-unit>
        <trans-unit id="467081e5090da9dbbbeef46980aa3215471c51a8" translate="yes" xml:space="preserve">
          <source>app.component</source>
          <target state="translated">app.component</target>
        </trans-unit>
        <trans-unit id="5242c228688e376d238375da2e61daa4d72f01db" translate="yes" xml:space="preserve">
          <source>app.config</source>
          <target state="translated">app.config</target>
        </trans-unit>
        <trans-unit id="18219ca7f262cc06aea854c86b553561b308e57f" translate="yes" xml:space="preserve">
          <source>app.config.globalProperties (&lt;a href=&quot;#vue-prototype-replaced-by-config-globalproperties&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a870440d8c7f82a6a1f2568c003080c77c5339e" translate="yes" xml:space="preserve">
          <source>app.config.isCustomElement (&lt;a href=&quot;#config-ignoredelements-is-now-config-iscustomelement&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85ceb7e6fd9d135c221589e806583d76513472" translate="yes" xml:space="preserve">
          <source>app.directive</source>
          <target state="translated">app.directive</target>
        </trans-unit>
        <trans-unit id="4c693e55b34812b4bae7c65ed8632f25ecb7dd87" translate="yes" xml:space="preserve">
          <source>app.mixin</source>
          <target state="translated">app.mixin</target>
        </trans-unit>
        <trans-unit id="1f2300b97dba467c4a8c4a56ebdb0ce97fcb714d" translate="yes" xml:space="preserve">
          <source>app.use (&lt;a href=&quot;#a-note-for-plugin-authors&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e046efd172457735b44f7929fe7efc0747f1" translate="yes" xml:space="preserve">
          <source>aria-describedby</source>
          <target state="translated">aria-describedby</target>
        </trans-unit>
        <trans-unit id="e4f0ab341d5e8e82e3d8dc99926c2333f783f688" translate="yes" xml:space="preserve">
          <source>aria-hidden=&quot;true&quot;</source>
          <target state="translated">aria-hidden=&quot;true&quot;</target>
        </trans-unit>
        <trans-unit id="c399d0d9385cb50ef9a74487c5e1ea13ac3f984e" translate="yes" xml:space="preserve">
          <source>aria-label</source>
          <target state="translated">aria-label</target>
        </trans-unit>
        <trans-unit id="ec0bffb04210018ec41d270900cc33a6714de325" translate="yes" xml:space="preserve">
          <source>aria-labelledby</source>
          <target state="translated">aria-labelledby</target>
        </trans-unit>
        <trans-unit id="f68ce285b8377013d64f60cad53e6825b9961b6a" translate="yes" xml:space="preserve">
          <source>as a performance optimization, because they initialized much faster than stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77cad1467608c98b4675073084c13ea3aba2ffb" translate="yes" xml:space="preserve">
          <source>aside</source>
          <target state="translated">aside</target>
        </trans-unit>
        <trans-unit id="394bb07928a366287168902c26665311049fa093" translate="yes" xml:space="preserve">
          <source>authoring tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">自动为CSS过渡和动画应用类。</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">由这些数据支持的。</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">能够不加修改地复制和粘贴大多数社区的代码示例。</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="8acebefba44388f598e2b99e8302ab67d355632c" translate="yes" xml:space="preserve">
          <source>beforeUnmount</source>
          <target state="translated">beforeUnmount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="77c5f425bb928c51b842ddf1e44748f43c932105" translate="yes" xml:space="preserve">
          <source>bind &amp;rarr; &lt;strong&gt;beforeMount&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fb8d92972382b39b524ce7f8cdc6213d95500" translate="yes" xml:space="preserve">
          <source>binding</source>
          <target state="translated">binding</target>
        </trans-unit>
        <trans-unit id="8e2b6e21dfdfc190c998d11093ac469ffd7f3aed" translate="yes" xml:space="preserve">
          <source>breaking</source>
          <target state="translated">breaking</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">复选框和单选按钮使用 &lt;code&gt;checked&lt;/code&gt; 属性和 &lt;code&gt;change&lt;/code&gt; 事件；</target>
        </trans-unit>
        <trans-unit id="db88192ef37fddf9df1a8a94d3fa600728fa8e81" translate="yes" xml:space="preserve">
          <source>checking your codebase for &lt;code&gt;.sync&lt;/code&gt; usage and replace it with &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cbf9910961b7b720be422c5227a48b45481be1" translate="yes" xml:space="preserve">
          <source>child components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42685f11da91a55b1f5c5b782edb2f0fc1dd5148" translate="yes" xml:space="preserve">
          <source>children</source>
          <target state="translated">children</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">显示颜色</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="ddcc491de82ebec3c03853395e5b60c154cbc452" translate="yes" xml:space="preserve">
          <source>componentUpdated &amp;rarr; &lt;strong&gt;updated&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f568e3b2e689e9753b26737cdc027b1633a22b7e" translate="yes" xml:space="preserve">
          <source>createApp</source>
          <target state="translated">createApp</target>
        </trans-unit>
        <trans-unit id="43caa510c0daadd6d3dc4ad43a5427148c2e6d9c" translate="yes" xml:space="preserve">
          <source>createRenderer</source>
          <target state="translated">createRenderer</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="d8844c3455799a9155c640b8dcfd223ef31c8542" translate="yes" xml:space="preserve">
          <source>defineAsyncComponent</source>
          <target state="translated">defineAsyncComponent</target>
        </trans-unit>
        <trans-unit id="0b351e6c4acf449188607d84ef9ac58fe7aff147" translate="yes" xml:space="preserve">
          <source>defineComponent</source>
          <target state="translated">defineComponent</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">后代组件不需要知道注入的属性来自哪里</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="3d981bf920ab98c455a9796d062745b9d6b5cbfb" translate="yes" xml:space="preserve">
          <source>directive</source>
          <target state="translated">directive</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">做同样的事情,因为。</target>
        </trans-unit>
        <trans-unit id="72ef9ecc0ee2490979708ebb01e137eae4c8f425" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;.enter&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="01b78ec3ef69d582c34c04fd02137b4b2a0b2057" translate="yes" xml:space="preserve">
          <source>ensure that all your components document their events with the &lt;code&gt;emits&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="72f59f31388477ad92fbebfc6b623eb3ba553f3e" translate="yes" xml:space="preserve">
          <source>eslint-plugin-vue</source>
          <target state="translated">eslint-plugin-vue</target>
        </trans-unit>
        <trans-unit id="e9922bd8a80da72306d79eeaf9a6b98cb64268db" translate="yes" xml:space="preserve">
          <source>event: &lt;code&gt;input&lt;/code&gt; -&amp;gt; &lt;code&gt;update:modelValue&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">公开与 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 相同的事件。</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;mode&lt;/code&gt; 以外，与 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 展示相同的道具。</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="d7eb6b340a11a367a1bec55e4a421d949214759f" translate="yes" xml:space="preserve">
          <source>footer</source>
          <target state="translated">footer</target>
        </trans-unit>
        <trans-unit id="acb51e7c16264c729e7521b40c23a4b9d8986b65" translate="yes" xml:space="preserve">
          <source>for all &lt;code&gt;v-model&lt;/code&gt;s without arguments, make sure to change props and events name to &lt;code&gt;modelValue&lt;/code&gt; and &lt;code&gt;update:modelValue&lt;/code&gt; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b39815c187d832cef3239eb7a77580728dc47" translate="yes" xml:space="preserve">
          <source>form</source>
          <target state="translated">form</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">完全支持Vue 1.0和2.0。</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="8574ae3fb0102e604b132e245a7a13501af7382a" translate="yes" xml:space="preserve">
          <source>globalProperties</source>
          <target state="translated">globalProperties</target>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="594fd1615a341c77829e83ed988f137e1ba96231" translate="yes" xml:space="preserve">
          <source>header</source>
          <target state="translated">header</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="33651e92d7f8755c3775bf7e6f2865577e7988de" translate="yes" xml:space="preserve">
          <source>how to build our package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">在2.6.0+中。有关新的建议语法，请参见&lt;a href=&quot;#Named-Slots&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">在2.6.0+中。有关新的建议语法，请参见&lt;a href=&quot;#Scoped-Slots&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="3014bf5a29cbc2f5b4c95b4c0f384113201b257e" translate="yes" xml:space="preserve">
          <source>inserted &amp;rarr; &lt;strong&gt;mounted&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9587db9f8e8a4535e8dcb6eaa79c2cf675a7519b" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as &lt;a href=&quot;https://animate.style/&quot;&gt;Animate.css (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">集成第三方CSS动画库,如Animate.css。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
