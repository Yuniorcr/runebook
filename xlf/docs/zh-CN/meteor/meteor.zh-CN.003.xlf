<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="meteor">
    <body>
      <group id="meteor">
        <trans-unit id="66705d703f7a2f4cfa2768aba4c5d97e0a610903" translate="yes" xml:space="preserve">
          <source>Helpers can accept positional and keyword arguments:</source>
          <target state="translated">助手可以接受位置参数和关键字参数。</target>
        </trans-unit>
        <trans-unit id="f606af98d3fda823ee4e02606188ad04bfc3336f" translate="yes" xml:space="preserve">
          <source>Helpers on &lt;code&gt;Template.body&lt;/code&gt; are only available in the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags of your app. To register a global helper, use &lt;a href=&quot;templates#Template-registerHelper&quot;&gt;Template.registerHelper&lt;/a&gt;. Event maps on &lt;code&gt;Template.body&lt;/code&gt; don&amp;rsquo;t apply to elements added to the body via &lt;code&gt;Blaze.render&lt;/code&gt;, jQuery, or the DOM API, or to the body element itself. To handle events on the body, window, or document, use jQuery or the DOM API.</source>
          <target state="translated">&lt;code&gt;Template.body&lt;/code&gt; 上的帮助程序仅在您应用的 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标记中可用。要注册全局助手，请使用&lt;a href=&quot;templates#Template-registerHelper&quot;&gt;Template.registerHelper&lt;/a&gt;。 &lt;code&gt;Template.body&lt;/code&gt; 上的事件映射不适用于通过 &lt;code&gt;Blaze.render&lt;/code&gt; ，jQuery或DOM API 添加到主体的元素，也不适用于body元素本身。要处理正文，窗口或文档上的事件，请使用jQuery或DOM API。</target>
        </trans-unit>
        <trans-unit id="e5246cd17978b86288a03ea9a792c469ffec54e6" translate="yes" xml:space="preserve">
          <source>Here are a couple of screenshots of &lt;code&gt;accounts-ui&lt;/code&gt; so you know what to expect:</source>
          <target state="translated">这是 &lt;code&gt;accounts-ui&lt;/code&gt; 的几个屏幕截图，所以您知道会发生什么：</target>
        </trans-unit>
        <trans-unit id="f48e2388b980916b8ed5a1115d6f5dab642002be" translate="yes" xml:space="preserve">
          <source>Here are a few of those methods:</source>
          <target state="translated">下面是其中的几种方法。</target>
        </trans-unit>
        <trans-unit id="122f48652eb654604aa8f40dbd193ba3643fafb4" translate="yes" xml:space="preserve">
          <source>Here are some example URLs and the resulting &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;queryParams&lt;/code&gt;:</source>
          <target state="translated">以下是一些示例URL以及生成的 &lt;code&gt;params&lt;/code&gt; 和 &lt;code&gt;queryParams&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8089ef0ac1ba3a3d90910291c8064cadc6cade07" translate="yes" xml:space="preserve">
          <source>Here are some patterns that are useful to keep in mind when building the user interface of your Meteor application.</source>
          <target state="translated">这里有一些模式,在构建Meteor应用程序的用户界面时,这些模式是有用的。</target>
        </trans-unit>
        <trans-unit id="2dcebaa7ae6f51f37f9ffdb4f73c5b848d80a690" translate="yes" xml:space="preserve">
          <source>Here at Meteor, we strongly believe that JavaScript is the best language to build web applications, for a variety of reasons. JavaScript is constantly improving, and the standards around ES2015 have really brought together the JavaScript community. Here are our recommendations about how to use ES2015 JavaScript in your app today.</source>
          <target state="translated">在Meteor,我们坚信JavaScript是构建Web应用的最佳语言,原因有很多。JavaScript在不断地改进,围绕ES2015的标准已经真正将JavaScript社区聚集在一起。以下是我们关于今天如何在你的应用中使用ES2015 JavaScript的建议。</target>
        </trans-unit>
        <trans-unit id="f71402dbd1216ae9cf759713e28e73c0e95baeec" translate="yes" xml:space="preserve">
          <source>Here is a basic example of &lt;code&gt;onPageLoad&lt;/code&gt; usage on the server:</source>
          <target state="translated">这是服务器上 &lt;code&gt;onPageLoad&lt;/code&gt; 用法的基本示例：</target>
        </trans-unit>
        <trans-unit id="65537fb9cd918f037957e1954de8cf28f515877d" translate="yes" xml:space="preserve">
          <source>Here is a list of the Babel transformers that are currently enabled:</source>
          <target state="translated">以下是当前启用的巴别变压器列表。</target>
        </trans-unit>
        <trans-unit id="ce9747381012c031c940584519e19bcf1ce3b6e6" translate="yes" xml:space="preserve">
          <source>Here is a more complicated example of &lt;code&gt;onPageLoad&lt;/code&gt; usage on the server, involving the &lt;a href=&quot;https://www.styled-components.com/docs/advanced#server-side-rendering&quot;&gt;&lt;code&gt;styled-components&lt;/code&gt;&lt;/a&gt; npm package:</source>
          <target state="translated">这是服务器上 &lt;code&gt;onPageLoad&lt;/code&gt; 用法的一个更复杂的示例，涉及&lt;a href=&quot;https://www.styled-components.com/docs/advanced#server-side-rendering&quot;&gt; &lt;code&gt;styled-components&lt;/code&gt; &lt;/a&gt; npm包：</target>
        </trans-unit>
        <trans-unit id="509e3b432dc6e032e4fe33905cf2847a7758f7a9" translate="yes" xml:space="preserve">
          <source>Here is a simple block helper that wraps its content in a div:</source>
          <target state="translated">这里有一个简单的块助手,它将其内容包裹在div中。</target>
        </trans-unit>
        <trans-unit id="b5cc21ccac7e95544ffe6831f0bb2aa87867a0cd" translate="yes" xml:space="preserve">
          <source>Here is an example of implementing &lt;code&gt;#unless&lt;/code&gt; in terms of &lt;code&gt;#if&lt;/code&gt; (ignoring for the moment that &lt;code&gt;unless&lt;/code&gt; is a built-in directive):</source>
          <target state="translated">下面是实现的一个例子 &lt;code&gt;#unless&lt;/code&gt; 来讲 &lt;code&gt;#if&lt;/code&gt; （暂时忽略那 &lt;code&gt;unless&lt;/code&gt; 是一个内置的指令）：</target>
        </trans-unit>
        <trans-unit id="99b57bf1c2eb8500e43bf390896c3d292a46ad27" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;todo&lt;/code&gt; is passed as argument to the &lt;code&gt;todoArgs&lt;/code&gt; helper, then the output is passed into the &lt;code&gt;Todos_item&lt;/code&gt; template.</source>
          <target state="translated">在这里，将 &lt;code&gt;todo&lt;/code&gt; 作为参数传递给 &lt;code&gt;todoArgs&lt;/code&gt; 帮助器，然后将输出传递给 &lt;code&gt;Todos_item&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="71564680d4662152ecd029a6af15b1de99dd3a59" translate="yes" xml:space="preserve">
          <source>Here we wrote a little utility (which could be abstracted into a general package) to wait for all the subscriptions which are created by the route change (the &lt;code&gt;todos.inList&lt;/code&gt; subscription in this case) to become ready before checking their data.</source>
          <target state="translated">在这里，我们编写了一个小实用程序（可以抽象为通用程序包）来等待由路由更改创建的所有订阅（在本例中为 &lt;code&gt;todos.inList&lt;/code&gt; 订阅）在检查其数据之前准备就绪。</target>
        </trans-unit>
        <trans-unit id="5e28fa6148e604c17f82fb6c77eaea161163e7f0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a code snippet to add to your server code which disables client-side updates on a collection. This will make sure no other part of your app can use &lt;code&gt;allow&lt;/code&gt;:</source>
          <target state="translated">这是要添加到服务器代码中的代码段，该代码段将禁用集合上的客户端更新。这将确保您的应用程序的其他任何部分都不能使用 &lt;code&gt;allow&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="54e66c5d3e6fd46629bc99740b47035d52d22a43" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete list of login providers for which Meteor actively maintains core packages:</source>
          <target state="translated">这是Meteor为其主动维护核心软件包的登录提供程序的完整列表：</target>
        </trans-unit>
        <trans-unit id="ec268f472c952354bc36644807f1d8595b86f53e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a list of the environment variables you can provide to your application.</source>
          <target state="translated">这是可以提供给应用程序的环境变量的列表。</target>
        </trans-unit>
        <trans-unit id="bdb3e52cfb8a1a584040971907ed393311be1bad" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a publication which takes a named argument. Note that it&amp;rsquo;s important to check the types of arguments that come in over the network.</source>
          <target state="translated">这是采用命名参数的出版物的示例。请注意，检查通过网络传入的参数的类型很重要。</target>
        </trans-unit>
        <trans-unit id="d42755fc2a80f16b4ae5e6731999055912a149f1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s exactly what happens, in order, when a Method is called:</source>
          <target state="translated">正确地，按顺序调用方法时，会发生以下情况：</target>
        </trans-unit>
        <trans-unit id="d0d2c82f3c0208bb883c5f70223a9dc14a58a834" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s example of defining a rule and adding it into the &lt;code&gt;DDPRateLimiter&lt;/code&gt;:</source>
          <target state="translated">这是定义规则并将其添加到 &lt;code&gt;DDPRateLimiter&lt;/code&gt; 中的示例：</target>
        </trans-unit>
        <trans-unit id="3d465f47d094851011549b7b95c4e71181dc41a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how CoffeeScript works with Meteor&amp;rsquo;s namespacing.</source>
          <target state="translated">这是CoffeeScript与Meteor的命名空间一起工作的方式。</target>
        </trans-unit>
        <trans-unit id="69e8aca3a6933ce33491c685e121def5e8a30364" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how this naming convention looks when applied to a publication:</source>
          <target state="translated">将这种命名约定应用于出版物时，其外观如下：</target>
        </trans-unit>
        <trans-unit id="cc11167a51129d41af575d59c26734ecde856b3d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we can add the &lt;a href=&quot;https://atmospherejs.com/practicalmeteor/mocha&quot;&gt;&lt;code&gt;practicalmeteor:mocha&lt;/code&gt;&lt;/a&gt; package to our app:</source>
          <target state="translated">这是我们可以向我们的应用程序添加&lt;a href=&quot;https://atmospherejs.com/practicalmeteor/mocha&quot;&gt; &lt;code&gt;practicalmeteor:mocha&lt;/code&gt; &lt;/a&gt;包的方法：</target>
        </trans-unit>
        <trans-unit id="2993429f6666895611a75fd1680667898ed86228" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can call this Method from the client:</source>
          <target state="translated">从客户端调用此方法的方法如下：</target>
        </trans-unit>
        <trans-unit id="a03a6bf334d1fa07c792e4ac2e93e75d11fd63f7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can use the built-in &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_methods&quot;&gt;&lt;code&gt;Meteor.methods&lt;/code&gt; API&lt;/a&gt; to define a Method. Note that Methods should always be defined in common code loaded on the client and the server to enable Optimistic UI. If you have some secret code in your Method, consult the &lt;a href=&quot;security#secret-code&quot;&gt;Security article&lt;/a&gt; for how to hide it from the client.</source>
          <target state="translated">这是使用内置&lt;a href=&quot;http://docs.meteor.com/#/full/meteor_methods&quot;&gt; &lt;code&gt;Meteor.methods&lt;/code&gt; API&lt;/a&gt;定义方法的方法。请注意，应始终在客户端和服务器上加载的通用代码中定义方法，以启用乐观UI。如果您的方法中包含一些秘密代码，请参阅&amp;ldquo; &lt;a href=&quot;security#secret-code&quot;&gt;安全性&amp;rdquo;文章，&lt;/a&gt;以了解如何从客户端隐藏它。</target>
        </trans-unit>
        <trans-unit id="696867911bab2ea0eb5b310080c679b35882906b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would use one of these functions:</source>
          <target state="translated">使用以下功能之一的方法如下：</target>
        </trans-unit>
        <trans-unit id="b98915e0ff7bf6068966ab369348da90186ad4eb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some of the functionality an ideal Method would have:</source>
          <target state="translated">这是理想方法具有的一些功能：</target>
        </trans-unit>
        <trans-unit id="16327c7e09eaa3c233c4af5d587f0262a9f672b6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what a settings file with some API keys might look like:</source>
          <target state="translated">这是带有一些API密钥的设置文件的样子：</target>
        </trans-unit>
        <trans-unit id="712cb1c96036df069e9f03a6480e392756e99912" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what our new override template looks like:</source>
          <target state="translated">这是我们新的替代模板的样子：</target>
        </trans-unit>
        <trans-unit id="eb48dea1c738bb38b3eb0dee57ebc149848ecf1f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the same user would look like if they instead logged in with Facebook:</source>
          <target state="translated">如果他们改用Facebook登录，则相同用户的外观如下：</target>
        </trans-unit>
        <trans-unit id="7a99388f1dcb77ee59a544e3d864ffedaf4ab1d5" translate="yes" xml:space="preserve">
          <source>Here's how events are counted: Each event that satisfies the matcher's filter is mapped to a bucket. Buckets are uniquely determined by the event object's values for all properties present in both the matcher and event objects.</source>
          <target state="translated">下面是如何计算事件的。每一个满足匹配器过滤器的事件都会被映射到一个桶上。桶由事件对象在匹配器和事件对象中的所有属性值唯一确定。</target>
        </trans-unit>
        <trans-unit id="2cbef85b2a837410cdd665fc731fcf3aeefa3286" translate="yes" xml:space="preserve">
          <source>Here, we are using a Blaze feature called &lt;code&gt;Template.dynamic&lt;/code&gt; to render a template which is attached to the &lt;code&gt;main&lt;/code&gt; property of the data context. Using Blaze Layout, we can change that &lt;code&gt;main&lt;/code&gt; property when a route is accessed.</source>
          <target state="translated">在这里，我们使用一个名为 &lt;code&gt;Template.dynamic&lt;/code&gt; 的Blaze功能来呈现一个模板，该模板附加到数据上下文的 &lt;code&gt;main&lt;/code&gt; 属性。使用Blaze Layout，我们可以在访问路线时更改该 &lt;code&gt;main&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="98cba56377787fb9c3921bdf7829a6e92c57e6bd" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll talk about how to manage the whole process manually from start to finish.</source>
          <target state="translated">在这里，我们将讨论如何从头到尾手动管理整个过程。</target>
        </trans-unit>
        <trans-unit id="bda39278f821eb4630143ec047c505f6808509c1" translate="yes" xml:space="preserve">
          <source>Highlighting the active route</source>
          <target state="translated">高亮显示活动中的途径</target>
        </trans-unit>
        <trans-unit id="03c8f7b472c34255625fa195d9be2e582eb8c1c0" translate="yes" xml:space="preserve">
          <source>Historical comparison with allow/deny</source>
          <target state="translated">与允许/拒绝的历史比较</target>
        </trans-unit>
        <trans-unit id="0b8220021c88dac6621398966f4a9c2fe108248e" translate="yes" xml:space="preserve">
          <source>Historically, there have been some misconceptions about the features of Meteor Methods as compared with the allow/deny feature, including that it was more difficult to achieve Optimistic UI when using Methods. However, the client-side &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; feature is actually implemented &lt;em&gt;on top of&lt;/em&gt; Methods, so Methods are strictly more powerful. You get great default Optimistic UI just by defining your Method code on the client and the server, as described in the Method lifecycle section above.</source>
          <target state="translated">从历史上看，与&amp;ldquo;允许/拒绝&amp;rdquo;功能相比，对&amp;ldquo;流星方法&amp;rdquo;的功能存在一些误解，包括使用&amp;ldquo;方法&amp;rdquo;时要实现&amp;ldquo;乐观UI&amp;rdquo;更为困难。但是，客户端的 &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 功能实际上是&lt;em&gt;在&lt;/em&gt; Methods &lt;em&gt;之上&lt;/em&gt;实现&lt;em&gt;的&lt;/em&gt;，因此Methods绝对更强大。您只需在客户端和服务器上定义方法代码即可获得出色的默认Optimistic UI，如上面&amp;ldquo;方法生命周期&amp;rdquo;部分所述。</target>
        </trans-unit>
        <trans-unit id="b65d23158f9d2b8a79c8bdcb42105481603c266f" translate="yes" xml:space="preserve">
          <source>Hooks on insert/update/remove</source>
          <target state="translated">插入/更新/删除的挂钩。</target>
        </trans-unit>
        <trans-unit id="98c8e71970a91a935ce63293bf6d663385373e71" translate="yes" xml:space="preserve">
          <source>Hosted service (recommended)</source>
          <target state="translated">托管服务(建议)</target>
        </trans-unit>
        <trans-unit id="06a22da7df1c05a8fcebe643d8e0c297d4921ba5" translate="yes" xml:space="preserve">
          <source>Hot code push greatly improves the development experience, but on mobile, it is also a really useful feature for production apps, because it allows you to quickly push updates to devices without having users update the app through the store and without going through a possibly lengthy review process to get your update accepted.</source>
          <target state="translated">热代码推送极大地改善了开发体验,但在移动端,它对于生产型应用来说也是一个非常有用的功能,因为它允许你快速推送更新到设备上,而不需要用户通过商店更新应用,也不需要通过可能漫长的审核过程来让你的更新被接受。</target>
        </trans-unit>
        <trans-unit id="7b97e36f13053cab23ebd066264ad4c4358f7855" translate="yes" xml:space="preserve">
          <source>Hot code push on mobile</source>
          <target state="translated">手机上的热码推送</target>
        </trans-unit>
        <trans-unit id="aa4ce17338e3e7feaab4b85c1474e46f3709dee6" translate="yes" xml:space="preserve">
          <source>Hot code pushes are loaded by the browser in the background while the app continues to run. Once the new code has been fully loaded the browser is able to switch over to the new code quickly.</source>
          <target state="translated">热代码推送由浏览器在后台加载,同时应用继续运行。一旦新代码被完全加载,浏览器就能快速切换到新代码。</target>
        </trans-unit>
        <trans-unit id="2066575c244e8a723fccd0aec086a276d9c21f57" translate="yes" xml:space="preserve">
          <source>Hot code pushing new JavaScript code to a device could accidentally push code containing errors, which might leave users with a broken app (a &amp;ldquo;white screen of death&amp;rdquo; in the worst case), and could even disable hot code push (because the code that makes a connection to the server may no longer run).</source>
          <target state="translated">将新的JavaScript代码推送到设备上的热门代码可能会意外地将包含错误的代码推送到设备中，这可能会使用户的应用程序损坏（在最坏的情况下为&amp;ldquo;白屏死机&amp;rdquo;），甚至可能会禁用热门代码推送（因为该代码会与服务器建立连接可能不再运行）。</target>
        </trans-unit>
        <trans-unit id="0c468fa8a67f39184615650decddfc80cc0e13c4" translate="yes" xml:space="preserve">
          <source>How a Meteor application compares to other types of applications in terms of file structure.</source>
          <target state="translated">Meteor应用程序与其他类型的应用程序在文件结构上的比较。</target>
        </trans-unit>
        <trans-unit id="5b27be0a7736ae16346c8f3010a0842ac1842250" translate="yes" xml:space="preserve">
          <source>How and where to load data in your Meteor app using publications and subscriptions.</source>
          <target state="translated">如何以及在哪里使用出版物和订阅在你的Meteor应用中加载数据。</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何工作的?</target>
        </trans-unit>
        <trans-unit id="79737bf4fbfdfaf16cbff20c8cedc1016aca3d24" translate="yes" xml:space="preserve">
          <source>How hot code push allows you to update your mobile app&amp;rsquo;s code without reinstalling the app on your device or submitting a new version to the store</source>
          <target state="translated">热代码推送如何使您能够更新移动应用程序的代码，而无需在设备上重新安装该应用程序或向商店提交新版本</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">运作方式</target>
        </trans-unit>
        <trans-unit id="967ddbc90240ac3f428c78a61d8e0a67a5b9403e" translate="yes" xml:space="preserve">
          <source>How much does ES2015 cost?</source>
          <target state="translated">ES2015需要多少钱?</target>
        </trans-unit>
        <trans-unit id="6d22435b35abe40c0cf0fbd752555fbea41a477f" translate="yes" xml:space="preserve">
          <source>How the Blaze rendering engine works under the hood and some advanced techniques for using it.</source>
          <target state="translated">Blaze渲染引擎的工作原理以及一些高级的使用技巧。</target>
        </trans-unit>
        <trans-unit id="f59d7854a399e000654c2134b562d445d54bdc3f" translate="yes" xml:space="preserve">
          <source>How to access local files and remote resources from your app</source>
          <target state="translated">如何从您的应用程序访问本地文件和远程资源?</target>
        </trans-unit>
        <trans-unit id="79a10b0297b96af92ba177f0d19af0376a82ade1" translate="yes" xml:space="preserve">
          <source>How to add custom data to Meteor&amp;rsquo;s users collection</source>
          <target state="translated">如何向Meteor的用户集合中添加自定义数据</target>
        </trans-unit>
        <trans-unit id="33fc1725259f982690c0c3868e0dd264ea21ced2" translate="yes" xml:space="preserve">
          <source>How to build a fully-featured password login experience</source>
          <target state="translated">如何打造功能齐全的密码登录体验?</target>
        </trans-unit>
        <trans-unit id="ff7ecc6e2bcc9cae41da455b438fe4522076c00e" translate="yes" xml:space="preserve">
          <source>How to build a style guide to allow you to visually test such reusable components.</source>
          <target state="translated">如何构建一个样式指南,让你直观地测试这种可复用的组件。</target>
        </trans-unit>
        <trans-unit id="9f0f532fd34a53fb4a594dc19a719c2439d0ea43" translate="yes" xml:space="preserve">
          <source>How to build components that can cope with a variety of different data sources.</source>
          <target state="translated">如何构建能够应对各种不同数据源的组件。</target>
        </trans-unit>
        <trans-unit id="f620f1143e3f16e4c6451014fbeff86b425d54dd" translate="yes" xml:space="preserve">
          <source>How to build mobile apps using Meteor's Cordova integration.</source>
          <target state="translated">如何使用Meteor的Cordova集成构建移动应用。</target>
        </trans-unit>
        <trans-unit id="82e2bd276624454965277a70bec9cff399045dc9" translate="yes" xml:space="preserve">
          <source>How to build reusable client side components in any user interface framework.</source>
          <target state="translated">如何在任何用户界面框架中构建可重用的客户端组件。</target>
        </trans-unit>
        <trans-unit id="442c055554f5d2635c3a0c96be4746922789ee45" translate="yes" xml:space="preserve">
          <source>How to build user interfaces in a maintainable and extensible way.</source>
          <target state="translated">如何以可维护和可扩展的方式构建用户界面。</target>
        </trans-unit>
        <trans-unit id="6bb8165750968751f161ae21ffa8c2d9543a2f2b" translate="yes" xml:space="preserve">
          <source>How to build user login functionality into a Meteor app. Let your users log in with passwords, Facebook, Google, GitHub, and more.</source>
          <target state="translated">如何在Meteor应用中构建用户登录功能。让你的用户用密码、Facebook、Google、GitHub等登录。</target>
        </trans-unit>
        <trans-unit id="613a4683eaabfd5114944341c7d5cc636be600ae" translate="yes" xml:space="preserve">
          <source>How to build your project and submit your mobile app to the store</source>
          <target state="translated">如何建立你的项目并向商店提交你的移动应用?</target>
        </trans-unit>
        <trans-unit id="6f79f62ec30f56e0cffa12bbf721cc206c707c8a" translate="yes" xml:space="preserve">
          <source>How to call a Method from a form.</source>
          <target state="translated">如何从表单中调用一个方法。</target>
        </trans-unit>
        <trans-unit id="7a0489695f65f2749f41e07192ca7fb0db68aaae" translate="yes" xml:space="preserve">
          <source>How to carefully change the schema of your collection.</source>
          <target state="translated">如何小心翼翼地改变你的集合模式。</target>
        </trans-unit>
        <trans-unit id="f18ba9888a15c844de9e2e24971df560b7a4b57a" translate="yes" xml:space="preserve">
          <source>How to configure your app to use your own app icon, launch screen, and set other preferences</source>
          <target state="translated">如何配置你的应用使用自己的应用图标、启动屏幕以及设置其他偏好</target>
        </trans-unit>
        <trans-unit id="084ba40658863bee602e98443850bc2d52b7cee8" translate="yes" xml:space="preserve">
          <source>How to construct links to routes and go to routes programmatically.</source>
          <target state="translated">如何以程序化的方式构建路由的链接和去路由。</target>
        </trans-unit>
        <trans-unit id="3206e41c33cefc9e1e4ccbd8e112597ee714051e" translate="yes" xml:space="preserve">
          <source>How to deal with associations between records.</source>
          <target state="translated">如何处理记录之间的关联。</target>
        </trans-unit>
        <trans-unit id="bbd45428caec2a73caa2b90f0ed23e9893353fc6" translate="yes" xml:space="preserve">
          <source>How to define a publication on the server.</source>
          <target state="translated">如何在服务器上定义一个出版物。</target>
        </trans-unit>
        <trans-unit id="001c195b1c8f92db4bd1e00537113ea757fcc71c" translate="yes" xml:space="preserve">
          <source>How to define a schema for a collection to control its content.</source>
          <target state="translated">如何为一个集合定义一个模式来控制其内容。</target>
        </trans-unit>
        <trans-unit id="de36a072d9a7a204255d05eeed6528e92f1d0fec" translate="yes" xml:space="preserve">
          <source>How to define client and server routes for your app using Flow Router.</source>
          <target state="translated">如何使用Flow Router为你的应用程序定义客户端和服务器路由。</target>
        </trans-unit>
        <trans-unit id="f4672cb2a09b02d43385cf78f81fdadbe49d67ad" translate="yes" xml:space="preserve">
          <source>How to define, use, and maintain MongoDB collections in Meteor.</source>
          <target state="translated">如何在Meteor中定义、使用和维护MongoDB集合。</target>
        </trans-unit>
        <trans-unit id="65a17df578e3256e7926af71803d435efe3f6d94" translate="yes" xml:space="preserve">
          <source>How to deploy to some common Meteor hosting environments.</source>
          <target state="translated">如何部署到一些常见的Meteor托管环境。</target>
        </trans-unit>
        <trans-unit id="bf2ed0809ba4bd48b87963356019f3516c9d3ffc" translate="yes" xml:space="preserve">
          <source>How to deploy, run, and monitor your Meteor app in production.</source>
          <target state="translated">如何在生产中部署、运行和监控你的Meteor应用。</target>
        </trans-unit>
        <trans-unit id="7db5874eb57134ae471f866a45450d6560a710fe" translate="yes" xml:space="preserve">
          <source>How to design a deployment process to make sure your application&amp;rsquo;s quality is maintained.</source>
          <target state="translated">如何设计部署过程以确保维持应用程序的质量。</target>
        </trans-unit>
        <trans-unit id="cc48d1ba2ddebe0f75e698c7ce8e86f119fb8753" translate="yes" xml:space="preserve">
          <source>How to drive your Meteor app's UI using URLs with FlowRouter.</source>
          <target state="translated">如何使用URL与FlowRouter驱动你的Meteor应用的UI。</target>
        </trans-unit>
        <trans-unit id="fbdf53b5acf40587f418ac4b66f646e85284a611" translate="yes" xml:space="preserve">
          <source>How to enable login through OAuth providers like Facebook</source>
          <target state="translated">如何通过Facebook等OAuth提供商启用登录功能</target>
        </trans-unit>
        <trans-unit id="5a8ed5bf88336ea0b05bc4fdf46c9e8c55216c14" translate="yes" xml:space="preserve">
          <source>How to enforce the schema when writing to a collection.</source>
          <target state="translated">当写到一个集合时,如何执行模式。</target>
        </trans-unit>
        <trans-unit id="11ad33e91f73fac9016919655ed5cdc9fc196864" translate="yes" xml:space="preserve">
          <source>How to ensure your publication is secure in the face of reactive changes.</source>
          <target state="translated">如何确保你的出版物在面对被动变化时是安全的。</target>
        </trans-unit>
        <trans-unit id="a9200b2e8bc1f4d62a398d453fb58a0105dd8a0a" translate="yes" xml:space="preserve">
          <source>How to follow a security checklist when auditing your app.</source>
          <target state="translated">审核应用时,如何遵循安全检查表。</target>
        </trans-unit>
        <trans-unit id="865e77adcc2e8ff36ce26ab7713f52ca69f663c5" translate="yes" xml:space="preserve">
          <source>How to format your code and name the parts of your application in consistent and maintainable ways.</source>
          <target state="translated">如何格式化你的代码,并以一致和可维护的方式命名你的应用程序的部分。</target>
        </trans-unit>
        <trans-unit id="08dd8cb16e8a03ad4adc353983d7261074e9be6e" translate="yes" xml:space="preserve">
          <source>How to have your app display different content depending on the URL.</source>
          <target state="translated">如何让你的应用根据URL显示不同的内容。</target>
        </trans-unit>
        <trans-unit id="1dcdf130c5eafaf08d5fca5c79cd4960da3cf851" translate="yes" xml:space="preserve">
          <source>How to install React in your Meteor application, and how to use it correctly.</source>
          <target state="translated">如何在你的Meteor应用中安装React,以及如何正确使用它。</target>
        </trans-unit>
        <trans-unit id="2f53e7bc7003cb7ec4b9a690bd3c238f9761f699" translate="yes" xml:space="preserve">
          <source>How to integrate React with Meteor&amp;rsquo;s realtime data layer.</source>
          <target state="translated">如何将React与Meteor的实时数据层集成在一起。</target>
        </trans-unit>
        <trans-unit id="79ad3e62b0f71069748525e24f5c44e73cc1405f" translate="yes" xml:space="preserve">
          <source>How to make sure your site is discoverable by search engines.</source>
          <target state="translated">如何确保你的网站能被搜索引擎发现。</target>
        </trans-unit>
        <trans-unit id="8116f88777601e3f230ec85d8cd5a7dc443fd6f8" translate="yes" xml:space="preserve">
          <source>How to manage user roles and permissions</source>
          <target state="translated">如何管理用户角色和权限</target>
        </trans-unit>
        <trans-unit id="c14589324af2b2d084ebebe408ca5cffd10f5b5e" translate="yes" xml:space="preserve">
          <source>How to migrate your application to Meteor 1.5.</source>
          <target state="translated">如何将你的应用程序迁移到Meteor 1.5。</target>
        </trans-unit>
        <trans-unit id="a7467688b0b4ce33388d7aa9d5757422fcf74167" translate="yes" xml:space="preserve">
          <source>How to monitor user behavior with analytics tools.</source>
          <target state="translated">如何利用分析工具监控用户行为。</target>
        </trans-unit>
        <trans-unit id="14a2c6edfa20423f34c12da78af6c9a5f40c05a9" translate="yes" xml:space="preserve">
          <source>How to monitor your application with Kadira.</source>
          <target state="translated">如何使用Kadira监控您的应用程序。</target>
        </trans-unit>
        <trans-unit id="3ae80990ce8a4c686f061258ba9df4e41384cbed" translate="yes" xml:space="preserve">
          <source>How to organize your application both for small and larger applications.</source>
          <target state="translated">如何组织你的小程序和大程序。</target>
        </trans-unit>
        <trans-unit id="cae8a2c57a25249a2e7c309800eb0b62b59da9b3" translate="yes" xml:space="preserve">
          <source>How to reactively publish related data.</source>
          <target state="translated">如何反应性地发布相关数据。</target>
        </trans-unit>
        <trans-unit id="21e7cb0d69f8aff289c7e7291815df768b889994" translate="yes" xml:space="preserve">
          <source>How to route in a React/Meteor application.</source>
          <target state="translated">如何在React/Metor应用中进行路由。</target>
        </trans-unit>
        <trans-unit id="590a24a3e16d85a94228b032aaa14302d5934117" translate="yes" xml:space="preserve">
          <source>How to run and debug your app on a mobile device or simulator/emulator</source>
          <target state="translated">如何在移动设备或模拟器/仿真器上运行和调试你的应用。</target>
        </trans-unit>
        <trans-unit id="cd639f12e58bf9c47cda6bdd69294c646c0cf197" translate="yes" xml:space="preserve">
          <source>How to secure Meteor Methods, publications, and source code.</source>
          <target state="translated">如何保护Meteor方法、出版物和源代码的安全。</target>
        </trans-unit>
        <trans-unit id="7d1d112874c1e438b01df0fa51e394f9aa9fdc67" translate="yes" xml:space="preserve">
          <source>How to secure your Meteor app.</source>
          <target state="translated">如何保护你的Meteor应用的安全。</target>
        </trans-unit>
        <trans-unit id="01989ca23419835536e69863931b29321a5f77ad" translate="yes" xml:space="preserve">
          <source>How to set up ESLint to check code style automatically</source>
          <target state="translated">如何设置ESLint自动检查代码风格?</target>
        </trans-unit>
        <trans-unit id="ae4a6fec308fbeb396dadf1c55d3db21a38ebb0b" translate="yes" xml:space="preserve">
          <source>How to set up your local machine for mobile development</source>
          <target state="translated">如何设置本地机进行移动开发?</target>
        </trans-unit>
        <trans-unit id="075a8b2cd13873e26d2c47c68589296d27e739f4" translate="yes" xml:space="preserve">
          <source>How to structure your Meteor app with ES2015 modules, ship code to the client and server, and split your code into multiple apps.</source>
          <target state="translated">如何使用ES2015模块来架构你的Meteor应用,将代码运送到客户端和服务器,并将你的代码分割成多个应用。</target>
        </trans-unit>
        <trans-unit id="61cc3e02447eba1e1dfd7f6efe94b2279004faca" translate="yes" xml:space="preserve">
          <source>How to test Blaze templates.</source>
          <target state="translated">如何测试Blaze模板。</target>
        </trans-unit>
        <trans-unit id="b4c58dbd39ef36e4b861f14a009aea0b30e603d1" translate="yes" xml:space="preserve">
          <source>How to test your Meteor application</source>
          <target state="translated">如何测试你的Meteor应用</target>
        </trans-unit>
        <trans-unit id="498a8587074134d1f49975927b063ca03d14dbde" translate="yes" xml:space="preserve">
          <source>How to throw and handle errors with Methods.</source>
          <target state="translated">如何用Methods抛出和处理错误。</target>
        </trans-unit>
        <trans-unit id="a42012b02b5ce5fb2147f665fac159a2785623d5" translate="yes" xml:space="preserve">
          <source>How to turn a 3rd-party REST endpoint into a publication.</source>
          <target state="translated">如何将第三方REST端点变成出版物。</target>
        </trans-unit>
        <trans-unit id="fc9900992671d58e8ec02210e566d65a7dcfcc36" translate="yes" xml:space="preserve">
          <source>How to turn a publication in your app into a REST endpoint.</source>
          <target state="translated">如何将应用程序中的出版物变成一个REST端点。</target>
        </trans-unit>
        <trans-unit id="d31ca247c099f8e976ab7f7d067ea730923a0023" translate="yes" xml:space="preserve">
          <source>How to use Blaze, Meteor's frontend rendering system, to build usable and maintainable user interfaces.</source>
          <target state="translated">如何使用Meteor的前端渲染系统Blaze来构建可用且可维护的用户界面。</target>
        </trans-unit>
        <trans-unit id="32eec04a5518012c77e50abdb4143965eb80916c" translate="yes" xml:space="preserve">
          <source>How to use Cordova plugins to take advantage of native device features</source>
          <target state="translated">如何使用Cordova插件来利用原生设备功能</target>
        </trans-unit>
        <trans-unit id="299f7825137660055b571c632d327a67919b58c6" translate="yes" xml:space="preserve">
          <source>How to use Meteor's build system to compile your app.</source>
          <target state="translated">如何使用Meteor的构建系统来编译你的应用程序。</target>
        </trans-unit>
        <trans-unit id="0880cb01b1a00e985f2c7e71f3d0017db0085473" translate="yes" xml:space="preserve">
          <source>How to use Methods, Meteor's remote procedure call system, to write to the database.</source>
          <target state="translated">如何使用Meteor的远程过程调用系统Methods向数据库写入。</target>
        </trans-unit>
        <trans-unit id="688a83c5025d4a8c046fbe31b74ab5178e41216b" translate="yes" xml:space="preserve">
          <source>How to use React, Facebook's frontend rendering library, with Meteor.</source>
          <target state="translated">如何用Meteor使用Facebook的前端渲染库React。</target>
        </trans-unit>
        <trans-unit id="c2bb37f66501b983211c1ed6ee6200be042fda80" translate="yes" xml:space="preserve">
          <source>How to use accounts-ui for a quick prototype</source>
          <target state="translated">如何使用account-ui进行快速原型设计?</target>
        </trans-unit>
        <trans-unit id="0f38a5a5f1894f9313a486914d1e9b393ea05617" translate="yes" xml:space="preserve">
          <source>How to use animation to keep users informed of changes.</source>
          <target state="translated">如何利用动画让用户了解变化。</target>
        </trans-unit>
        <trans-unit id="a41fcd3ded5fd9a81452a7e3adbd33b9167094bd" translate="yes" xml:space="preserve">
          <source>How to use the Spacebars language to define templates rendered by the Blaze engine.</source>
          <target state="translated">如何使用Spacebars语言来定义由Blaze引擎渲染的模板。</target>
        </trans-unit>
        <trans-unit id="6fed2d3b42e94124dbea85c98c035ea167374d51" translate="yes" xml:space="preserve">
          <source>How to use the low-level publish API to publish anything.</source>
          <target state="translated">如何使用低级的发布API来发布任何东西。</target>
        </trans-unit>
        <trans-unit id="cea5029d5dba90aa9b552b8390ce67dfbb8257c1" translate="yes" xml:space="preserve">
          <source>How to use the useraccounts family of packages to build your login UI</source>
          <target state="translated">如何使用useraccounts系列的包来构建你的登录界面。</target>
        </trans-unit>
        <trans-unit id="8aa7e99c007ce54d681ed2efff96da799bd28bb4" translate="yes" xml:space="preserve">
          <source>However there are some challenges to splitting your code in this way that should be considered before jumping in.</source>
          <target state="translated">然而,以这种方式拆分你的代码有一些挑战,在跳进去之前应该考虑。</target>
        </trans-unit>
        <trans-unit id="e1c8f634a52074d6597171d516f4582641100073" translate="yes" xml:space="preserve">
          <source>However, an integration test that crosses the client-server boundary of a Meteor application (where the modules under test cross that boundary) requires a different testing infrastructure, namely Meteor&amp;rsquo;s &amp;ldquo;full app&amp;rdquo; testing mode.</source>
          <target state="translated">但是，跨Meteor应用程序的客户端-服务器边界（其中被测模块跨越该边界）的集成测试需要不同的测试基础结构，即Meteor的&amp;ldquo;完整应用程序&amp;rdquo;测试模式。</target>
        </trans-unit>
        <trans-unit id="a918955046dbaa975a249800c9befcb7320189e8" translate="yes" xml:space="preserve">
          <source>However, collections are a lot more than a way to save and retrieve data. They also provide the core of the interactive, connected user experience that users expect from the best applications. Meteor makes this user experience easy to implement.</source>
          <target state="translated">然而,集合不仅仅是一种保存和检索数据的方式。它们还提供了用户期望从最好的应用程序中获得的交互式、连接式用户体验的核心。Meteor让这种用户体验易于实现。</target>
        </trans-unit>
        <trans-unit id="db39b1f8cbeac77448045e435f16b7de310b67a3" translate="yes" xml:space="preserve">
          <source>However, due to the same reasons discussed above, the publication &lt;em&gt;will not re-run&lt;/em&gt; if the user&amp;rsquo;s &lt;code&gt;admin&lt;/code&gt; status changes. If this is something that is likely to happen and reactive changes are needed, then we&amp;rsquo;ll need to make the publication reactive. We can do this via the same technique as above however:</source>
          <target state="translated">但是，由于上述相同的原因，如果用户的 &lt;code&gt;admin&lt;/code&gt; 状态更改，则发布&lt;em&gt;将不会重新运行&lt;/em&gt;。如果这很可能发生并且需要做出反应性的更改，那么我们将需要使出版物具有反应性。我们可以通过与上述相同的技术来做到这一点：</target>
        </trans-unit>
        <trans-unit id="07bc3d1a3b522bd465d14dbe6b50d6184fd6ee5e" translate="yes" xml:space="preserve">
          <source>However, given that MongoDB prior to version 3.2 doesn&amp;rsquo;t support queries over multiple collections (&amp;ldquo;joins&amp;rdquo;), we typically end up having to denormalize some data back onto the parent collection. Denormalization is the practice of storing the same piece of information in the database multiple times (as opposed to a non-redundant &amp;ldquo;normal&amp;rdquo; form). MongoDB is a database where denormalizing is encouraged, and thus optimized for this practice.</source>
          <target state="translated">但是，鉴于3.2版之前的MongoDB不支持对多个集合的查询（&amp;ldquo;联接&amp;rdquo;），我们通常最终不得不将一些数据归一化到父集合中。非规范化是将同一条信息多次存储在数据库中的实践（与非冗余的&amp;ldquo;正常&amp;rdquo;形式相反）。MongoDB是一个鼓励非规范化的数据库，因此针对此实践进行了优化。</target>
        </trans-unit>
        <trans-unit id="d915b3504d950ee54b74a67869675a06e69392b1" translate="yes" xml:space="preserve">
          <source>However, if we wanted to wait for the method to return from the server, we can put the redirection in the callback of the method:</source>
          <target state="translated">但是,如果我们想等待方法从服务器返回,我们可以把重定向放在方法的回调中。</target>
        </trans-unit>
        <trans-unit id="ead0301581de2d42f5482fead5b2800774a8f147" translate="yes" xml:space="preserve">
          <source>However, in some cases it&amp;rsquo;s better to allow one application to be the master and control access to the data for other applications via an API. This can help if you want to deploy the different applications on different schedules and need to be conservative about how the data changes.</source>
          <target state="translated">但是，在某些情况下，最好是允许一个应用程序为主控，并通过API控制对其他应用程序的数据访问。如果您想按不同的时间表部署不同的应用程序，并且需要对数据的更改保持保守，这将有所帮助。</target>
        </trans-unit>
        <trans-unit id="f685a9f89b108ab4d5e0796da8c4712045678605" translate="yes" xml:space="preserve">
          <source>However, it is important to realize that hot code push can only be used to update the HTML, CSS, JavaScript code and other assets making up your web app. Changes to native code will still require you &lt;a href=&quot;#building-and-submitting&quot;&gt;to submit a new version of your app to the store&lt;/a&gt;.</source>
          <target state="translated">但是，重要的是要认识到，热代码推送只能用于更新HTML，CSS，JavaScript代码和构成Web应用程序的其他资产。更改本机代码仍将需要您&lt;a href=&quot;#building-and-submitting&quot;&gt;向商店提交新版本的应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17106978fe2abf404ef82c52a8d4dd21b3a9e682" translate="yes" xml:space="preserve">
          <source>However, it is possible to do this thanks to our split between smart and reusable components. The reusable component simply renders what it&amp;rsquo;s given, so we use our smart component to control that information. We can use a &lt;a href=&quot;collections#local-collections&quot;&gt;&lt;em&gt;local collection&lt;/em&gt;&lt;/a&gt; to store the rendered data, and then push data into it when the user requests an update:</source>
          <target state="translated">但是，由于我们在智能组件和可重用组件之间进行了划分，因此可以实现此目的。可重用组件只是呈现所提供的内容，因此我们使用智能组件来控制该信息。我们可以使用&lt;a href=&quot;collections#local-collections&quot;&gt;&lt;em&gt;本地集合&lt;/em&gt;&lt;/a&gt;来存储渲染的数据，然后在用户请求更新时将数据推送到其中：</target>
        </trans-unit>
        <trans-unit id="73c4c15b9b1bdce95ff35a1cc7e67b8e37b22011" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s a good idea to think ahead to how the schema may change over time. For instance, you may have a list of strings on a document (perhaps a set of tags). Although it&amp;rsquo;s tempting to leave them as a subfield on the document (assuming they don&amp;rsquo;t change much), if there&amp;rsquo;s a good chance that they&amp;rsquo;ll end up becoming more complicated in the future (perhaps tags will have a creator, or subtags later on?), then it might be easier in the long run to make a separate collection from the beginning.</source>
          <target state="translated">但是，最好预先考虑架构随时间的变化。例如，您可能在文档上有一个字符串列表（也许是一组标签）。尽管很容易将它们保留为文档的子字段（假设它们没有太大变化），但是如果将来很有可能它们最终变得更加复杂（也许标签将有一个创建者，或者以后会带有子标签）上吗？），从长远来看，从一开始进行单独的收集可能会更容易。</target>
        </trans-unit>
        <trans-unit id="7b76fb027b5dabff6002b7e8af0c64c751927319" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s generally a good idea to use a layout component (which you wrap all your components in) to subscribe to this subscription anyway. It&amp;rsquo;s better to be consistent about such things, and it makes for a more flexible system if you ever decide you have a screen that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need that data.</source>
          <target state="translated">但是，通常最好使用布局组件（将所有组件包装在其中）来订阅该订阅。最好保持一致，如果您决定使用不需要该数据的屏幕，&lt;em&gt;则&lt;/em&gt;可以使系统更加灵活。</target>
        </trans-unit>
        <trans-unit id="529994c2f075bbc6cb5b867bd818a97438f74275" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not &lt;em&gt;always&lt;/em&gt; necessarily a good idea to be optimistic. Sometimes we may actually want to wait for the server&amp;rsquo;s response. For instance, when a user is logging in, you &lt;em&gt;have&lt;/em&gt; to wait for the server to check the password is correct before you can start allowing them into the site.</source>
          <target state="translated">但是，乐观并不&lt;em&gt;总是&lt;/em&gt;一个好主意。有时，我们实际上可能要等待服务器的响应。例如，当用户登录时，您&lt;em&gt;必须&lt;/em&gt;等待服务器检查密码是否正确，然后才能开始允许他们进入站点。</target>
        </trans-unit>
        <trans-unit id="0a152a81ab365c7c58a7a037bc1e4b320d3fabb2" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s still important to test your changes throughly with a good process of Quality Assurance (QA). Although it&amp;rsquo;s easy to push out fixes to bugs, those bugs can still cause major problems to users and even potentially data corruption!</source>
          <target state="translated">但是，通过良好的质量保证（QA）过程全面测试您的更改仍然很重要。尽管推出漏洞修复程序很容易，但这些漏洞仍可能给用户带来重大问题，甚至可能导致数据损坏！</target>
        </trans-unit>
        <trans-unit id="c54619cee1903cd2619a4bd3c99dde830c8d8834" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s terrible UX to simply jump the user to an unexpected state without explaining what&amp;rsquo;s happened. We used a &lt;code&gt;alert()&lt;/code&gt; above, which is a pretty poor option, but gets the job done. One better approach is to indicate changes via a &amp;ldquo;flash notification&amp;rdquo;, which is a UI element that&amp;rsquo;s displayed &amp;ldquo;out-of-band&amp;rdquo;, typically in the top right of the screen, given the user &lt;em&gt;some&lt;/em&gt; indication of what&amp;rsquo;s happened. Here&amp;rsquo;s an example of a flash notification in Galaxy, at the top right of the page:</source>
          <target state="translated">但是，糟糕的UX只是简单地使用户跳到意外状态而没有解释发生了什么。我们在上面使用了 &lt;code&gt;alert()&lt;/code&gt; ，这是一个很差的选择，但是可以完成工作。一种更好的方法是通过&amp;ldquo;闪存通知&amp;rdquo;来指示更改，该通知是&amp;ldquo;带外&amp;rdquo;显示的UI元素，通常在屏幕的右上角，给用户&lt;em&gt;一些&lt;/em&gt;有关发生情况的指示。这是页面右上方的Galaxy中的Flash通知示例：</target>
        </trans-unit>
        <trans-unit id="e59ebb5ff4324c5787fa66b34f3a5d8be022b8e9" translate="yes" xml:space="preserve">
          <source>However, most of the user-facing features of URLs listed above are still relevant for typical Meteor applications. Since the server is not URL-driven, the URL just becomes a useful representation of the client-side state the user is currently looking at. However, unlike in a server-rendered application, it does not need to describe the entirety of the user&amp;rsquo;s current state; it simply needs to contain the parts that you want to be linkable. For example, the URL should contain any search filters applied on a page, but not necessarily the state of a dropdown menu or popup.</source>
          <target state="translated">但是，上面列出的URL的大多数面向用户功能仍与典型的Meteor应用程序相关。由于服务器不是URL驱动的，因此URL只是成为用户当前正在查看的客户端状态的有用表示。但是，与服务器呈现的应用程序不同，它不需要描述用户当前状态的全部；它只需要包含您希望可链接的部分。例如，URL应该包含应用于页面的所有搜索过滤器，但不一定包含下拉菜单或弹出窗口的状态。</target>
        </trans-unit>
        <trans-unit id="48d6099bf45d6ffea137c3a2c863d6d16a8ede13" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to do more complex initialization to documents before inserting them into collections. For instance, in the Todos app, we want to set the name of new lists to be &lt;code&gt;List X&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; is the next available unique letter.</source>
          <target state="translated">但是，有时在将文档插入集合之前对文档进行更复杂的初始化很有用。例如，在Todos应用中，我们要将新列表的名称设置为 &lt;code&gt;List X&lt;/code&gt; ，其中 &lt;code&gt;X&lt;/code&gt; 是下一个可用的唯一字母。</target>
        </trans-unit>
        <trans-unit id="03fed144304cb92f06be961007d281acb5aa875b" translate="yes" xml:space="preserve">
          <source>However, this doesn&amp;rsquo;t mean you can&amp;rsquo;t have any flexibility in your Methods. Let&amp;rsquo;s look at an example:</source>
          <target state="translated">但是，这并不意味着您的方法不能具有任何灵活性。让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="0846b39f92fd5c549adffd2cce9aa4b5fe3b812e" translate="yes" xml:space="preserve">
          <source>However, this example will not work as you might expect. The reason is that reactivity doesn&amp;rsquo;t work in the same way on the server as it does on the client. On the client, if &lt;em&gt;anything&lt;/em&gt; in a reactive function changes, the whole function will re-run, and the results are fairly intuitive.</source>
          <target state="translated">但是，此示例将无法正常工作。原因是服务器上的反应性与客户端上的反应性不同。在客户端上，如果反应式功能中的&lt;em&gt;任何内容&lt;/em&gt;发生更改，则整个功能将重新运行，结果相当直观。</target>
        </trans-unit>
        <trans-unit id="efe7fbd39ef5cbe0a56364dcc763d212edb1215f" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t work in all cases - since the code runs asynchronously, we can&amp;rsquo;t use anything we got from an API in the method return value. We need a different approach that will convert the async API to a synchronous-looking one that will allow us to return a value.</source>
          <target state="translated">但是，这并非在所有情况下都有效-由于代码是异步运行的，因此我们不能在方法返回值中使用从API获得的任何内容。我们需要一种将异步API转换为具有同步外观的方法的方法，该方法将允许我们返回值。</target>
        </trans-unit>
        <trans-unit id="ae6ed46dde3f3aa91cbb3d5ee4fbbf57822cb7b9" translate="yes" xml:space="preserve">
          <source>However, we can write publications that are properly reactive to changes across collections. To do this, we use the &lt;a href=&quot;https://atmospherejs.com/reywood/publish-composite&quot;&gt;&lt;code&gt;reywood:publish-composite&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">但是，我们可以编写对集合中的更改有适当反应的出版物。为此，我们使用&lt;a href=&quot;https://atmospherejs.com/reywood/publish-composite&quot;&gt; &lt;code&gt;reywood:publish-composite&lt;/code&gt; &lt;/a&gt;包。</target>
        </trans-unit>
        <trans-unit id="d54763561ff30677fe28c88ea1404ea1659fe6a9" translate="yes" xml:space="preserve">
          <source>However, we still need to subscribe to the list of items and the count, and collect that data somewhere. To do this, it&amp;rsquo;s sensible to use a smart wrapper component (analogous to an MVC &amp;ldquo;controller&amp;rdquo;) whose job it is to subscribe and fetch the relevant data.</source>
          <target state="translated">但是，我们仍然需要订阅项目列表和计数，并在某个地方收集该数据。为此，明智的做法是使用智能包装器组件（类似于MVC&amp;ldquo;控制器&amp;rdquo;），该组件的作用是订阅和获取相关数据。</target>
        </trans-unit>
        <trans-unit id="75b8875b64a459d63c7376fbe3e8edbd52c6088b" translate="yes" xml:space="preserve">
          <source>Http(s) URLs to a git commit by SHA.</source>
          <target state="translated">Http(s)通过SHA指向git提交的URL。</target>
        </trans-unit>
        <trans-unit id="6f91972118a54e8f5071265110d2769e99d68a4a" translate="yes" xml:space="preserve">
          <source>Https URL example:</source>
          <target state="translated">Https URL例子。</target>
        </trans-unit>
        <trans-unit id="006e123d5adcde715b21c22e9f7ad2e2086b1860" translate="yes" xml:space="preserve">
          <source>Ideally, once a smart component has assembled such a set of data, it passes it off to a reusable component child to render with. Smart components usually don&amp;rsquo;t render anything apart from one or more reusable children. This makes it easy to separate rendering and data loading in your tests.</source>
          <target state="translated">理想情况下，一旦智能组件组装了这样的数据集，它就会将其传递给可重用的组件子代进行渲染。除了一个或多个可重用的子代，智能组件通常不会渲染任何东西。这使得在测试中分离渲染和数据加载变得容易。</target>
        </trans-unit>
        <trans-unit id="295be7d94767d973e13a36c48f06bd1fd60478cb" translate="yes" xml:space="preserve">
          <source>Identifiers and Paths</source>
          <target state="translated">识别器和路径</target>
        </trans-unit>
        <trans-unit id="ec8d2a53e9795bdc00356965f6107d8ffc4749a6" translate="yes" xml:space="preserve">
          <source>Identifying when the link is clicked</source>
          <target state="translated">识别链接被点击的时间</target>
        </trans-unit>
        <trans-unit id="1c24c81343fa36615a777cf9245dc925ab6b9292" translate="yes" xml:space="preserve">
          <source>If / Unless</source>
          <target state="translated">如果/除非</target>
        </trans-unit>
        <trans-unit id="2271745d2c04f3025da05e53769aadf55c678925" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MAIL_URL&lt;/code&gt; is not set, &lt;code&gt;Email.send&lt;/code&gt; outputs the message to standard output instead.</source>
          <target state="translated">如果 &lt;code&gt;MAIL_URL&lt;/code&gt; 没有设置， &lt;code&gt;Email.send&lt;/code&gt; 输出消息到标准输出代替。</target>
        </trans-unit>
        <trans-unit id="5f296998f8bcc6d4ac57e7b10d46016c2d18e90b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;failed&lt;/code&gt;, a description of why the connection failed.</source>
          <target state="translated">如果 &lt;code&gt;status&lt;/code&gt; 是 &lt;code&gt;failed&lt;/code&gt; ，为什么连接失败的描述。</target>
        </trans-unit>
        <trans-unit id="294b76a3566d7d21c729fe4887cb4ac5ba31bfad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, transparently follow HTTP redirects. Cannot be set to &lt;code&gt;false&lt;/code&gt; on the client. Default &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则透明地遵循HTTP重定向。无法在客户端上设置为 &lt;code&gt;false&lt;/code&gt; 。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66bae8da8eb95f3daff532cd3fc97fed66213834" translate="yes" xml:space="preserve">
          <source>If Session.get had been used instead of Session.equals, then when the selection changed, all the items would be re-rendered.</source>
          <target state="translated">如果用Session.get代替Session.equals,那么当选择发生变化时,所有的项目都会被重新渲染。</target>
        </trans-unit>
        <trans-unit id="f5ee0a0623a24d5220dc026e6a766f82425de2fa" translate="yes" xml:space="preserve">
          <source>If String, name of the record set. If Object, publications Dictionary of publish functions by name. If &lt;code&gt;null&lt;/code&gt;, the set has no name, and the record set is automatically sent to all connected clients.</source>
          <target state="translated">如果为String，则为记录集的名称。如果为Object，则按名称发布发布函数的词典。如果为 &lt;code&gt;null&lt;/code&gt; ，则该集合没有名称，并且记录集会自动发送到所有连接的客户端。</target>
        </trans-unit>
        <trans-unit id="08b2874cec3b51d4885cefc9e71009d31d067774" translate="yes" xml:space="preserve">
          <source>If a URL is simply out-of-date (sometimes you might change the URL scheme of an application), you can redirect inside the &lt;code&gt;action&lt;/code&gt; function of the route:</source>
          <target state="translated">如果某个URL只是过时的（有时您可能会更改应用程序的URL方案），则可以在路由的 &lt;code&gt;action&lt;/code&gt; 函数内重定向：</target>
        </trans-unit>
        <trans-unit id="404cb5b1b683f3615e494c3a796a23a014d494e3" translate="yes" xml:space="preserve">
          <source>If a client calls a method and is disconnected before it receives a response, it will re-call the method when it reconnects. This means that a client may call a method multiple times when it only means to call it once. If this behavior is problematic for your method, consider attaching a unique ID to each method call on the client, and checking on the server whether a call with this ID has already been made. Alternatively, you can use &lt;a href=&quot;#meteor_apply&quot;&gt;&lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt; with the noRetry option set to true.</source>
          <target state="translated">如果客户端调用方法并在收到响应之前断开连接，则客户端将在重新连接时重新调用该方法。这意味着客户端仅意味着一次调用一个方法时，可以多次调用该方法。如果此行为对您的方法有问题，请考虑将唯一的ID附加到客户端上的每个方法调用，然后在服务器上检查是否已使用此ID进行了调用。另外，您可以将&lt;a href=&quot;#meteor_apply&quot;&gt; &lt;code&gt;Meteor.apply&lt;/code&gt; &lt;/a&gt;与noRetry选项设置为true。</target>
        </trans-unit>
        <trans-unit id="fc6e97abc3e5521519dac25e93db492199f6f5fb" translate="yes" xml:space="preserve">
          <source>If a double-braced tag at element level evalutes to an object created with &lt;code&gt;Spacebars.SafeString(&quot;&amp;lt;span&amp;gt;Some HTML&amp;lt;/span&amp;gt;&quot;)&lt;/code&gt;, the HTML is inserted at the current location. The code that calls &lt;code&gt;SafeString&lt;/code&gt; is asserting that this HTML is safe to insert.</source>
          <target state="translated">如果元素级别的双括号标签评估为使用 &lt;code&gt;Spacebars.SafeString(&quot;&amp;lt;span&amp;gt;Some HTML&amp;lt;/span&amp;gt;&quot;)&lt;/code&gt; 创建的对象，则HTML将插入当前位置。调用 &lt;code&gt;SafeString&lt;/code&gt; 的代码断言可以安全地插入此HTML。</target>
        </trans-unit>
        <trans-unit id="e561cf254115ebe95b56ad073070db08304a680d" translate="yes" xml:space="preserve">
          <source>If a path starts with &lt;code&gt;..&lt;/code&gt;, then the &lt;em&gt;enclosing&lt;/em&gt; data context is used instead of the current one. The enclosing data context might be the one outside the current &lt;code&gt;#each&lt;/code&gt;, &lt;code&gt;#with&lt;/code&gt;, or template inclusion.</source>
          <target state="translated">如果路径以 &lt;code&gt;..&lt;/code&gt; 开头，则使用&lt;em&gt;封闭的&lt;/em&gt;数据上下文，而不是当前的上下文。封闭数据上下文可能是当前外的一个 &lt;code&gt;#each&lt;/code&gt; ， &lt;code&gt;#with&lt;/code&gt; ，或模板包容。</target>
        </trans-unit>
        <trans-unit id="c296965895460cad94501bae9df4c08010ed8a6d" translate="yes" xml:space="preserve">
          <source>If a publish function does not return a cursor or array of cursors, it is assumed to be using the low-level &lt;code&gt;added&lt;/code&gt;/&lt;code&gt;changed&lt;/code&gt;/&lt;code&gt;removed&lt;/code&gt; interface, and it &lt;strong&gt;must also call &lt;a href=&quot;#publish_ready&quot;&gt;&lt;code&gt;ready&lt;/code&gt;&lt;/a&gt; once the initial record set is complete&lt;/strong&gt;.</source>
          <target state="translated">如果发布函数未返回游标或游标数组，则假定它正在使用低级 &lt;code&gt;added&lt;/code&gt; / &lt;code&gt;changed&lt;/code&gt; / &lt;code&gt;removed&lt;/code&gt; 接口，并且&lt;strong&gt;初始记录集完成后&lt;/strong&gt;，它还&lt;strong&gt;必须调用&lt;a href=&quot;#publish_ready&quot;&gt; &lt;code&gt;ready&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c67236e4a923771c827a8a9684de68ba83c48c75" translate="yes" xml:space="preserve">
          <source>If a selector matches multiple elements that an event bubbles to, it will be called multiple times, for example in the case of &lt;code&gt;'click
div'&lt;/code&gt; or &lt;code&gt;'click *'&lt;/code&gt;. If no selector is given, the handler will only be called once, on the original target element.</source>
          <target state="translated">如果选择器匹配事件冒泡的多个元素，则将多次调用它，例如，在 &lt;code&gt;'click div'&lt;/code&gt; 或 &lt;code&gt;'click *'&lt;/code&gt; 。如果未提供选择器，则在原始目标元素上仅将处理程序调用一次。</target>
        </trans-unit>
        <trans-unit id="fc468b03ef781b0b140b8837f90bcd87ef3102bd" translate="yes" xml:space="preserve">
          <source>If a user types an incorrect URL, chances are you want to show them some kind of amusing not-found page. There are actually two categories of not-found pages. The first is when the URL typed in doesn&amp;rsquo;t match any of your route definitions. You can use &lt;code&gt;FlowRouter.notFound&lt;/code&gt; to handle this:</source>
          <target state="translated">如果用户输入了错误的URL，则可能要向他们显示某种有趣的找不到页面。实际上有两类未找到的页面。第一种是输入的URL与您的任何路由定义都不匹配时。您可以使用 &lt;code&gt;FlowRouter.notFound&lt;/code&gt; 处理此问题：</target>
        </trans-unit>
        <trans-unit id="9026fe644d96ba958ad6a899068c1879787ee471" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from the Method simulation, then by default Meteor ignores it and continues to step (2). If you are using &lt;code&gt;ValidatedMethod&lt;/code&gt; or pass a special &lt;code&gt;throwStubExceptions&lt;/code&gt; option to &lt;code&gt;Meteor.apply&lt;/code&gt;, then an exception thrown from the simulation will stop the server-side Method from running at all.</source>
          <target state="translated">如果从Method模拟中抛出异常，那么默认情况下，Meteor会忽略该异常并继续执行步骤（2）。如果您使用 &lt;code&gt;ValidatedMethod&lt;/code&gt; 或将特殊的 &lt;code&gt;throwStubExceptions&lt;/code&gt; 选项传递给 &lt;code&gt;Meteor.apply&lt;/code&gt; ，则模拟中引发的异常将完全停止服务器端Method的运行。</target>
        </trans-unit>
        <trans-unit id="bf211b40f906a97c0f1f5f10fafd264a5fc9b391" translate="yes" xml:space="preserve">
          <source>If an inclusion tag resolves to a function, the function must return a template object or &lt;code&gt;null&lt;/code&gt;. The function is reactively re-run, and if its return value changes, the template will be replaced.</source>
          <target state="translated">如果包含标签解析为函数，则该函数必须返回模板对象或 &lt;code&gt;null&lt;/code&gt; 。该函数将以响应方式重新运行，并且如果其返回值更改，则将替换模板。</target>
        </trans-unit>
        <trans-unit id="c8e71dee77de483007af38976102d6166b5a09ac" translate="yes" xml:space="preserve">
          <source>If possible, it&amp;rsquo;s usually best to try and abstract out the reusable part of the two components that need to share functionality into a new, smaller component. If you follow the patterns for &lt;a href=&quot;reusable-components&quot;&gt;reusable components&lt;/a&gt;, it should be simple to reuse this sub-component everywhere you need this functionality.</source>
          <target state="translated">如果可能的话，通常最好尝试将需要共享功能的两个组件的可重用部分抽象为一个较小的新组件。如果遵循&lt;a href=&quot;reusable-components&quot;&gt;可重用组件&lt;/a&gt;的模式，那么在需要此功能的任何地方重用此子组件应该很简单。</target>
        </trans-unit>
        <trans-unit id="faddab19504c5fd4ecc813555cd3025952a1e1bc" translate="yes" xml:space="preserve">
          <source>If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true. The function is passed the full email address of the proposed new user. Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: &lt;code&gt;Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })&lt;/code&gt;.</source>
          <target state="translated">如果设置为字符串，则仅当新用户的电子邮件地址的域部分与字符串匹配时才允许新用户。如果设置为函数，则仅当函数返回true时才允许新用户。该功能将传递给建议的新用户的完整电子邮件地址。可使用基于密码的登录和外部服务公开电子邮件地址（Google，Facebook，GitHub）。启用此选项后，所有现有用户仍可以登录。示例： &lt;code&gt;Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c268ce2b10b3ffffefc2144b86ac42f77e4d52f" translate="yes" xml:space="preserve">
          <source>If someone comes along and passes a non-ID selector like &lt;code&gt;{}&lt;/code&gt;, they will end up deleting the entire collection.</source>
          <target state="translated">如果有人出现并通过了 &lt;code&gt;{}&lt;/code&gt; 这样的非ID选择器，他们最终将删除整个集合。</target>
        </trans-unit>
        <trans-unit id="561766f90c831adc2b315203e468534153640cd3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MAIL_URL&lt;/code&gt; environment variable is set, actually sends the email. Otherwise, prints the contents of the email to standard out.</source>
          <target state="translated">如果设置了 &lt;code&gt;MAIL_URL&lt;/code&gt; 环境变量，则实际上发送电子邮件。否则，将电子邮件内容打印为标准输出。</target>
        </trans-unit>
        <trans-unit id="760fe41acd350bff390e995daccf34f94bd6130d" translate="yes" xml:space="preserve">
          <source>If the Method throws an error, you get that in the first argument of the callback. If the Method succeeds, you get the result in the second argument and the first argument &lt;code&gt;err&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. For more information about errors, see the section below about error handling.</source>
          <target state="translated">如果该方法引发错误，则可以在回调的第一个参数中得到该错误。如果方法成功，您将在第二个参数中得到结果，而第一个参数 &lt;code&gt;err&lt;/code&gt; 将是 &lt;code&gt;undefined&lt;/code&gt; 。有关错误的更多信息，请参见下面有关错误处理的部分。</target>
        </trans-unit>
        <trans-unit id="ff5bffa4493549d3c3eb5dcbedb088285a119567" translate="yes" xml:space="preserve">
          <source>If the View hasn&amp;rsquo;t been created yet, calls &lt;code&gt;func&lt;/code&gt; when the View is created. In &lt;code&gt;func&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">如果尚未创建视图，请在创建视图时调用 &lt;code&gt;func&lt;/code&gt; 。在 &lt;code&gt;func&lt;/code&gt; 中，View与 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb6c5632533f02eb65b914e68ac1df32dd0adf96" translate="yes" xml:space="preserve">
          <source>If the View hasn&amp;rsquo;t been destroyed yet, calls &lt;code&gt;func&lt;/code&gt; when the View is destroyed. A View may be destroyed without ever becoming &amp;ldquo;ready.&amp;rdquo; In &lt;code&gt;func&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">如果View尚未销毁，请在销毁View时调用 &lt;code&gt;func&lt;/code&gt; 。一个View可能会被破坏，而不会变得&amp;ldquo;准备就绪&amp;rdquo;。在 &lt;code&gt;func&lt;/code&gt; 中，View与 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adad32e4ae914f0a838d66caaaafb90c377bc501" translate="yes" xml:space="preserve">
          <source>If the View is removed by some other mechanism besides Meteor or jQuery (which Meteor integrates with by default), the View may continue to update indefinitely. Most users will not need to manually render templates and insert them into the DOM, but if you do, be mindful to always call &lt;a href=&quot;#Blaze-remove&quot;&gt;&lt;code&gt;Blaze.remove&lt;/code&gt;&lt;/a&gt; when the View is no longer needed.</source>
          <target state="translated">如果通过Meteor或jQuery（Meteor默认与之集成）以外的其他机制删除了View，则View可能会无限期地更新。大多数用户不需要手动呈现模板并将其插入DOM中，但是如果这样做，请&lt;a href=&quot;#Blaze-remove&quot;&gt; &lt;code&gt;Blaze.remove&lt;/code&gt; &lt;/a&gt;在不再需要View时始终调用Blaze.remove。</target>
        </trans-unit>
        <trans-unit id="e2c5d9d4fb620079dab064cc2d9258b666383207" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;#with&lt;/code&gt; is a string or other non-object value, it may be promoted to a JavaScript wrapper object (also known as a boxed value) when passed to helpers, because JavaScript traditionally only allows an object for &lt;code&gt;this&lt;/code&gt;. Use &lt;code&gt;String(this)&lt;/code&gt; to get an unboxed string value or &lt;code&gt;Number(this)&lt;/code&gt; to get an unboxed number value.</source>
          <target state="translated">如果 &lt;code&gt;#with&lt;/code&gt; 的参数是字符串或其他非对象值，则在传递给帮助器时，它可能会提升为JavaScript包装器对象（也称为盒装值），因为JavaScript传统上仅为 &lt;code&gt;this&lt;/code&gt; 目的提供一个对象。使用 &lt;code&gt;String(this)&lt;/code&gt; 获取未装箱的字符串值或使用 &lt;code&gt;Number(this)&lt;/code&gt; 获取未装箱的数字值。</target>
        </trans-unit>
        <trans-unit id="ad2e0c81a533f5d9fa655a5c6172c577ba7bb0c7" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;#with&lt;/code&gt; is falsy (by the same rules as for &lt;code&gt;#if&lt;/code&gt;), the content is not rendered. An &amp;ldquo;else&amp;rdquo; block may be provided, which will be rendered instead.</source>
          <target state="translated">如果 &lt;code&gt;#with&lt;/code&gt; 的参数是错误的（按照与 &lt;code&gt;#if&lt;/code&gt; 相同的规则），则不会呈现内容。可以提供&amp;ldquo; else&amp;rdquo;块，而将其呈现。</target>
        </trans-unit>
        <trans-unit id="eaa59d0b779e3dfa672d6ff91d93fd367aaef255" translate="yes" xml:space="preserve">
          <source>If the autopublish package is installed, information about all users on the system is published to all clients. This includes &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;profile&lt;/code&gt;, and any fields in &lt;code&gt;services&lt;/code&gt; that are meant to be public (eg &lt;code&gt;services.facebook.id&lt;/code&gt;, &lt;code&gt;services.twitter.screenName&lt;/code&gt;). Additionally, when using autopublish more information is published for the currently logged in user, including access tokens. This allows making API calls directly from the client for services that allow this.</source>
          <target state="translated">如果安装了自动发布程序包，则将系统上所有用户的信息发布到所有客户端。这包括 &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;profile&lt;/code&gt; 以及本应公开的 &lt;code&gt;services&lt;/code&gt; 中的任何字段（例如， &lt;code&gt;services.facebook.id&lt;/code&gt; ， &lt;code&gt;services.twitter.screenName&lt;/code&gt; ）。此外，使用自动发布时，将为当前登录的用户发布更多信息，包括访问令牌。这允许直接从客户端对允许此功能的服务进行API调用。</target>
        </trans-unit>
        <trans-unit id="a74cfb01a0afac49fbd69424dc2af89d335da6be" translate="yes" xml:space="preserve">
          <source>If the code is private, or of no interest to others, it typically makes sense to simply include the same module in both applications (you &lt;em&gt;can&lt;/em&gt; do this with &lt;a href=&quot;https://www.npmjs.com/private-modules&quot;&gt;private npm modules&lt;/a&gt;). There are several ways to do this:</source>
          <target state="translated">如果代码是私有的，或者对其他人不感兴趣，则通常在两个应用程序中简单地包含相同的模块是有意义的（您&lt;em&gt;可以&lt;/em&gt;使用&lt;a href=&quot;https://www.npmjs.com/private-modules&quot;&gt;private npm modules&lt;/a&gt;做到这一点）。做这件事有很多种方法：</target>
        </trans-unit>
        <trans-unit id="2a810388d29aae9dd5ed67e04a227f42a27afb26" translate="yes" xml:space="preserve">
          <source>If the initial run of an autorun throws an exception, the computation is automatically stopped and won&amp;rsquo;t be rerun.</source>
          <target state="translated">如果自动运行的初始运行引发异常，则计算将自动停止并且不会重新运行。</target>
        </trans-unit>
        <trans-unit id="311fc9d51fdd289b30affd698690e03de43248a3" translate="yes" xml:space="preserve">
          <source>If the match fails, &lt;code&gt;check&lt;/code&gt; throws a &lt;code&gt;Match.Error&lt;/code&gt; describing how it failed. If this error gets sent over the wire to the client, it will appear only as &lt;code&gt;Meteor.Error(400, 'Match Failed')&lt;/code&gt;. The failure details will be written to the server logs but not revealed to the client.</source>
          <target state="translated">如果匹配失败， &lt;code&gt;check&lt;/code&gt; 将抛出 &lt;code&gt;Match.Error&lt;/code&gt; ,描述匹配失败的方式。如果此错误通过电线发送到客户端，它将仅显示为 &lt;code&gt;Meteor.Error(400, 'Match Failed')&lt;/code&gt; 。故障详细信息将被写入服务器日志，但不会显示给客户端。</target>
        </trans-unit>
        <trans-unit id="6216c97351dae4afadee52afc404a9827779c513" translate="yes" xml:space="preserve">
          <source>If the migration logs anything to the console, you&amp;rsquo;ll see it in the terminal window that is running the Meteor server.</source>
          <target state="translated">如果迁移将任何内容记录到控制台，您将在运行Meteor服务器的终端窗口中看到它。</target>
        </trans-unit>
        <trans-unit id="383457a28536fcc159b3ba0f9ca5202fd8c020c8" translate="yes" xml:space="preserve">
          <source>If the new version involves different data formats in the database, then you need to be a little more careful about how you step through versions to ensure that all the versions that are running simultaneously can work together. You can read more about how to do this in the &lt;a href=&quot;collections#migrations&quot;&gt;collections article&lt;/a&gt;.</source>
          <target state="translated">如果新版本在数据库中涉及不同的数据格式，那么您需要更加谨慎地逐步浏览版本，以确保同时运行的所有版本可以协同工作。您可以在&lt;a href=&quot;collections#migrations&quot;&gt;收藏文章中&lt;/a&gt;了解有关如何执行此操作的更多信息。</target>
        </trans-unit>
        <trans-unit id="8c504e34fd35712e27574ed506051530693a4039" translate="yes" xml:space="preserve">
          <source>If the package is just a development dependency (i.e. it&amp;rsquo;s used for testing, linting or the like) then you should use &lt;code&gt;--save-dev&lt;/code&gt;. That way if you have some kind of build script, it can do &lt;code&gt;npm install --production&lt;/code&gt; and avoid installing packages it doesn&amp;rsquo;t need.</source>
          <target state="translated">如果该包只是开发依赖项（即用于测试，整理或类似操作），则应使用 &lt;code&gt;--save-dev&lt;/code&gt; 。这样，如果您具有某种构建脚本，则可以执行 &lt;code&gt;npm install --production&lt;/code&gt; 并避免安装不需要的软件包。</target>
        </trans-unit>
        <trans-unit id="829ea98439cbd81ab5f2feeaae924a345f0111ea" translate="yes" xml:space="preserve">
          <source>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</source>
          <target state="translated">如果响应头显示JSON内容,则包含作为JSON对象解析的文档主体。</target>
        </trans-unit>
        <trans-unit id="53418477ff1863486739569580596b4616219822" translate="yes" xml:space="preserve">
          <source>If the store is multi-dimensional, you may want to use a &lt;code&gt;ReactiveDict&lt;/code&gt; (from the &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt;&lt;code&gt;reactive-dict&lt;/code&gt;&lt;/a&gt; package):</source>
          <target state="translated">如果商店是多维的，则可能要使用 &lt;code&gt;ReactiveDict&lt;/code&gt; （来自&lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt; &lt;code&gt;reactive-dict&lt;/code&gt; &lt;/a&gt;包）：</target>
        </trans-unit>
        <trans-unit id="8ae137251be09c6077d03f298005082d3e8c8fc6" translate="yes" xml:space="preserve">
          <source>If the store is single-dimensional, you can probably use a &lt;code&gt;ReactiveVar&lt;/code&gt; to store it (provided by the &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-var&quot;&gt;&lt;code&gt;reactive-var&lt;/code&gt;&lt;/a&gt; package). A &lt;code&gt;ReactiveVar&lt;/code&gt; has two properties, &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt;:</source>
          <target state="translated">如果存储是一维的，则可能可以使用 &lt;code&gt;ReactiveVar&lt;/code&gt; 进行存储（由&lt;a href=&quot;https://atmospherejs.com/meteor/reactive-var&quot;&gt; &lt;code&gt;reactive-var&lt;/code&gt; &lt;/a&gt;包提供）。一个 &lt;code&gt;ReactiveVar&lt;/code&gt; 有两个属性 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;set()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a987e30de15b07bf76728d567d6ffad1e4f5236" translate="yes" xml:space="preserve">
          <source>If the subscription is run with &lt;em&gt;different arguments&lt;/em&gt;, then a new subscription is created, which connects to the publication on the server.</source>
          <target state="translated">如果订阅使用&lt;em&gt;不同的参数&lt;/em&gt;运行，则将创建一个新的订阅，该订阅将连接到服务器上的发布。</target>
        </trans-unit>
        <trans-unit id="8c69463b66d86765802ca248de505a52a66a5048" translate="yes" xml:space="preserve">
          <source>If the subscription is run with the &lt;em&gt;same arguments&lt;/em&gt; then the &amp;ldquo;new&amp;rdquo; subscription discovers the old &amp;ldquo;marked for destruction&amp;rdquo; subscription that&amp;rsquo;s sitting around, with the same data already ready, and simply reuses that.</source>
          <target state="translated">如果订阅使用&lt;em&gt;相同的参数&lt;/em&gt;运行，则&amp;ldquo;新&amp;rdquo;订阅会发现周围有旧的&amp;ldquo;标记为破坏&amp;rdquo;订阅，并且已经准备好相同的数据，然后简单地重用它。</target>
        </trans-unit>
        <trans-unit id="5e5ff626f0630055385718ace638d74ee720f863" translate="yes" xml:space="preserve">
          <source>If the user is being created as part of a login attempt from a client (eg, calling &lt;a href=&quot;#accounts_createuser&quot;&gt;&lt;code&gt;Accounts.createUser&lt;/code&gt;&lt;/a&gt; from the client, or &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;logging in for the first time with an external service&lt;/a&gt;), these callbacks are called &lt;em&gt;before&lt;/em&gt; the &lt;a href=&quot;#accounts_validateloginattempt&quot;&gt;&lt;code&gt;Accounts.validateLoginAttempt&lt;/code&gt;&lt;/a&gt; callbacks. If these callbacks succeed but those fail, the user will still be created but the connection will not be logged in as that user.</source>
          <target state="translated">如果用户被作为来自客户端的登录尝试的一部分创建的（例如，主叫&lt;a href=&quot;#accounts_createuser&quot;&gt; &lt;code&gt;Accounts.createUser&lt;/code&gt; &lt;/a&gt;从客户端，或&lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;在首次与外部服务日志记录&lt;/a&gt;），这些回调被称为&lt;em&gt;前&lt;/em&gt;的&lt;a href=&quot;#accounts_validateloginattempt&quot;&gt; &lt;code&gt;Accounts.validateLoginAttempt&lt;/code&gt; &lt;/a&gt;回调。如果这些回调成功但失败，则仍将创建该用户，但连接将不会以该用户身份登录。</target>
        </trans-unit>
        <trans-unit id="2aab0de68554c2f9d2c23534c066f46b08990716" translate="yes" xml:space="preserve">
          <source>If there are multiple users with a username or email only differing in case, a case sensitive match is required. Although &lt;code&gt;createUser&lt;/code&gt; won&amp;rsquo;t let you create users with ambiguous usernames or emails, this could happen with existing databases or if you modify the users collection directly.</source>
          <target state="translated">如果多个用户的用户名或电子邮件仅大小写不同，则需要区分大小写。尽管 &lt;code&gt;createUser&lt;/code&gt; 不允许您使用歧义的用户名或电子邮件创建用户，但是这可能在现有数据库中发生，或者如果直接修改用户集合，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="817e3d1c7ee37462fd0e8cfe4b3e638f50a62cd8" translate="yes" xml:space="preserve">
          <source>If there is no current computation and &lt;code&gt;depend()&lt;/code&gt; is called with no arguments, it does nothing and returns false.</source>
          <target state="translated">如果没有当前计算，并且不带任何参数调用 &lt;code&gt;depend()&lt;/code&gt; ，则不执行任何操作并返回false。</target>
        </trans-unit>
        <trans-unit id="17b33175544254dd250f44caa96b1c820435d75f" translate="yes" xml:space="preserve">
          <source>If this file is JavaScript code or will be compiled into JavaScript code by a build plugin, don't wrap the resulting file in a closure. Has the same effect as putting a file into the &lt;code&gt;client/compatibility&lt;/code&gt; directory in an app.</source>
          <target state="translated">如果此文件是JavaScript代码，或者将由构建插件编译为JavaScript代码，请不要将结果文件包装在闭包中。与将文件放入应用程序的 &lt;code&gt;client/compatibility&lt;/code&gt; 目录中的作用相同。</target>
        </trans-unit>
        <trans-unit id="acdfb992cc79afe4176ec5764edc7138672f8dc2" translate="yes" xml:space="preserve">
          <source>If this template is a &amp;ldquo;smart&amp;rdquo; component that loads server data and accesses the router, append &lt;code&gt;_page&lt;/code&gt; to the name:</source>
          <target state="translated">如果此模板是加载服务器数据并访问路由器的&amp;ldquo;智能&amp;rdquo;组件，请在名称后附加 &lt;code&gt;_page&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e2beb9d526ea953a6af4e3b7966daac6dcc4894" translate="yes" xml:space="preserve">
          <source>If true, asks the user for permission to act on their behalf when offline. This stores an additional offline token in the &lt;code&gt;services&lt;/code&gt; field of the user document. Currently only supported with Google.</source>
          <target state="translated">如果为true，则请求用户在脱机时允许代表他们执行操作。这会将额外的脱机令牌存储在用户文档的 &lt;code&gt;services&lt;/code&gt; 字段中。目前仅支持Google。</target>
        </trans-unit>
        <trans-unit id="ef8ffda122ef746673a4f129a3cf7773ea4dda80" translate="yes" xml:space="preserve">
          <source>If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.</source>
          <target state="translated">如果为真,强制用户批准应用程序的权限,即使之前已经批准。目前只支持谷歌。</target>
        </trans-unit>
        <trans-unit id="3dec2ec903c1d9bed96d0c5732a548c85a313951" translate="yes" xml:space="preserve">
          <source>If true, this symbol will only be exported when running tests for this package.</source>
          <target state="translated">如果为 &quot;true&quot;,这个符号将只在为这个包运行测试时导出。</target>
        </trans-unit>
        <trans-unit id="816592e9a7f706b71f78dc4c21a438bba4f5ada5" translate="yes" xml:space="preserve">
          <source>If using &quot;redirect&quot; login style, the user will be returned to this URL after authorisation has been completed.</source>
          <target state="translated">如果使用 &quot;重定向 &quot;的登录方式,用户在完成授权后会被返回到这个URL。</target>
        </trans-unit>
        <trans-unit id="f434f553446118d172aee2015a1698385fbddd3f" translate="yes" xml:space="preserve">
          <source>If value is a scalar, then these two expressions do the same thing:</source>
          <target state="translated">如果value是一个标量,那么这两个表达式的作用是一样的。</target>
        </trans-unit>
        <trans-unit id="8d4f8a30a2b4b0eb7d59c43418b3a77576996f3a" translate="yes" xml:space="preserve">
          <source>If we defined this Method in client and server code, as all Methods should be, a Method simulation is executed in the client that called it.</source>
          <target state="translated">如果我们在客户端和服务器代码中定义了这个Method,就像所有的Method都应该是这样的,那么在调用它的客户端就会执行一个Method模拟。</target>
        </trans-unit>
        <trans-unit id="f07138b6c6c4818214c354c3a4f0782d3d62e5c5" translate="yes" xml:space="preserve">
          <source>If we have any publications on the page that have been affected by the database writes from this Method, the server sends the appropriate updates to the client. Note that the client data system doesn&amp;rsquo;t reveal these updates to the app UI until the next step.</source>
          <target state="translated">如果页面上有任何受此方法的数据库写入影响的发布，则服务器会将适当的更新发送给客户端。请注意，客户端数据系统在下一步之前不会向应用程序UI显示这些更新。</target>
        </trans-unit>
        <trans-unit id="b5bb120936667fc7c69d5cda8b46e689ced2d89a" translate="yes" xml:space="preserve">
          <source>If you also want to change the logged-in user on the client, then after calling &lt;code&gt;setUserId&lt;/code&gt; on the server, call &lt;code&gt;Meteor.connection.setUserId(userId)&lt;/code&gt; on the client.</source>
          <target state="translated">如果还想更改客户端上的登录用户，则在服务器上调用 &lt;code&gt;setUserId&lt;/code&gt; 之后，请在客户端上调用 &lt;code&gt;Meteor.connection.setUserId(userId)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="788d043c0fb3fc8b9b1f135d3ca58a12cc807709" translate="yes" xml:space="preserve">
          <source>If you are a package author, in addition to putting &lt;code&gt;api.use('modules')&lt;/code&gt; or &lt;code&gt;api.use('ecmascript')&lt;/code&gt; in the &lt;code&gt;Package.onUse&lt;/code&gt; section of your &lt;code&gt;package.js&lt;/code&gt; file, you can also use a new API called &lt;code&gt;api.mainModule&lt;/code&gt; to specify the main entry point for your package:</source>
          <target state="translated">如果您是包作者，则除了将 &lt;code&gt;api.use('modules')&lt;/code&gt; 或 &lt;code&gt;api.use('ecmascript')&lt;/code&gt; 放入 &lt;code&gt;package.js&lt;/code&gt; 文件的 &lt;code&gt;Package.onUse&lt;/code&gt; 部分外，您还可以使用称为 &lt;code&gt;api.mainModule&lt;/code&gt; 的新API .mainModule指定包的主要入口点：</target>
        </trans-unit>
        <trans-unit id="d21642096bcfaa645b8d17141a6f4d338fa53a3e" translate="yes" xml:space="preserve">
          <source>If you are familiar with modules in Node, you might expect modules not to be evaluated until the first time you import them. However, because earlier versions of Meteor evaluated all of your code when the application started, and we care about backwards compatibility, eager evaluation is still the default behavior.</source>
          <target state="translated">如果您熟悉 Node 中的模块,您可能会期望模块在您第一次导入它们之前不会被评估。然而,因为Meteor的早期版本在应用程序启动时评估了你所有的代码,而且我们关心的是向后的兼容性,急切的评估仍然是默认的行为。</target>
        </trans-unit>
        <trans-unit id="5ebda88d01db28805009fc87fd2a2245e494587f" translate="yes" xml:space="preserve">
          <source>If you are following &lt;a href=&quot;security#ssl&quot;&gt;our advice&lt;/a&gt;, you&amp;rsquo;ll probably want to &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;set up SSL&lt;/a&gt; on your Galaxy application with the certificate and key for your domain. You should also read the &lt;a href=&quot;security#ssl&quot;&gt;Security&lt;/a&gt; section of this guide for information on how to forcibly redirect HTTP to HTTPS.</source>
          <target state="translated">如果您遵循&lt;a href=&quot;security#ssl&quot;&gt;我们的建议&lt;/a&gt;，则可能需要使用域的证书和密钥在Galaxy应用程序上&lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;设置SSL&lt;/a&gt;。您还应该阅读本指南的&amp;ldquo; &lt;a href=&quot;security#ssl&quot;&gt;安全性&amp;rdquo;&lt;/a&gt;部分，以获取有关如何将HTTP强制重定向到HTTPS的信息。</target>
        </trans-unit>
        <trans-unit id="ec2da9b73ca892139e92afc2774d7ee5c4fc3049" translate="yes" xml:space="preserve">
          <source>If you are hosting a webfont as part of your application and serving it via a CDN, you may need to configure the served headers for the font to allow cross-origin resource sharing (as the webfont is now served from a different origin to your site itself). You can do this easily enough in Meteor by adding a handler (you&amp;rsquo;ll need to ensure your CDN is passing the header through):</source>
          <target state="translated">如果您将Webfont作为应用程序的一部分托管并通过CDN进行提供，则可能需要配置该字体的提供的标头以允许跨域资源共享（因为Webfont现在是从其他来源提供给您的站点的本身）。您可以通过添加处理程序在Meteor中轻松完成此操作（您需要确保CDN可以通过标头）：</target>
        </trans-unit>
        <trans-unit id="d2c577722b11f969b8bd32347a448e2c449248d7" translate="yes" xml:space="preserve">
          <source>If you are looking to write an Atmosphere package that wraps such a component, you need to take some &lt;a href=&quot;#atmosphere-packages&quot;&gt;further steps&lt;/a&gt;.</source>
          <target state="translated">如果您要编写包装此类组件的Atmosphere软件包，则需要采取&lt;a href=&quot;#atmosphere-packages&quot;&gt;进一步的措施&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fb4dd30c782f92e559875fa4cb72b2966ae7583" translate="yes" xml:space="preserve">
          <source>If you are running a test that relies on using the database, and specifically the content of the database, you&amp;rsquo;ll need to perform some &lt;em&gt;setup&lt;/em&gt; steps in your test to ensure the database is in the state you expect. There are some tools you can use to do this.</source>
          <target state="translated">如果运行的测试依赖于使用数据库，尤其是数据库的内容，则需要在测试中执行一些&lt;em&gt;设置&lt;/em&gt;步骤，以确保数据库处于期望的状态。您可以使用一些工具来执行此操作。</target>
        </trans-unit>
        <trans-unit id="5b84b1c7a471fcb5f7807f6f6faaa8c384852263" translate="yes" xml:space="preserve">
          <source>If you are running on your own &lt;a href=&quot;deployment#custom-deployment&quot;&gt;infrastructure&lt;/a&gt;, there are a few options for setting up SSL, mostly through configuring a proxy web server. See the articles: &lt;a href=&quot;http://joshowens.me/ssl-and-meteor-js/&quot;&gt;Josh Owens on SSL and Meteor&lt;/a&gt;, &lt;a href=&quot;http://www.meteorpedia.com/read/SSL&quot;&gt;SSL on Meteorpedia&lt;/a&gt;, and &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-deploy-a-meteor-js-application-on-ubuntu-14-04-with-nginx&quot;&gt;Digital Ocean tutorial with an Nginx config&lt;/a&gt;.</source>
          <target state="translated">如果您在自己的&lt;a href=&quot;deployment#custom-deployment&quot;&gt;基础&lt;/a&gt;结构上运行，则有几种设置SSL的选项，主要是通过配置代理Web服务器来进行的。请参阅文章：&lt;a href=&quot;http://joshowens.me/ssl-and-meteor-js/&quot;&gt;乔什&amp;middot;欧文斯对SSL和流星&lt;/a&gt;，&lt;a href=&quot;http://www.meteorpedia.com/read/SSL&quot;&gt;在Meteorpedia SSL&lt;/a&gt;和&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-deploy-a-meteor-js-application-on-ubuntu-14-04-with-nginx&quot;&gt;数字海洋教程，Nginx上配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00b7fbb4db82beecfc26e25ccb6be5dc4176346d" translate="yes" xml:space="preserve">
          <source>If you are using an off-the-shelf login UI like &lt;code&gt;accounts-ui&lt;/code&gt; or &lt;code&gt;useraccounts&lt;/code&gt;, you don&amp;rsquo;t need to write any code after adding the relevant package from the list above. If you are building a login experience from scratch, you can log in programmatically using the &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_loginwithexternalservice&quot;&gt;&lt;code&gt;Meteor.loginWith&amp;lt;Service&amp;gt;&lt;/code&gt;&lt;/a&gt; function. It looks like this:</source>
          <target state="translated">如果您使用的是现成的登录UI（例如 &lt;code&gt;accounts-ui&lt;/code&gt; 或 &lt;code&gt;useraccounts&lt;/code&gt; )，则从上面的列表中添加相关的软件包后，无需编写任何代码。如果要从头开始构建登录体验，则可以使用&lt;a href=&quot;http://docs.meteor.com/#/full/meteor_loginwithexternalservice&quot;&gt; &lt;code&gt;Meteor.loginWith&amp;lt;Service&amp;gt;&lt;/code&gt; &lt;/a&gt;函数以编程方式登录。看起来像这样：</target>
        </trans-unit>
        <trans-unit id="d8aa0b0804bd0e52d77c6e2eaa9cb79bae275633" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;#accounts_api&quot;&gt;built-in Meteor accounts system&lt;/a&gt; then this should correspond to the &lt;code&gt;_id&lt;/code&gt; field of a document in the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">如果您使用&lt;a href=&quot;#accounts_api&quot;&gt;内置的Meteor帐户系统，&lt;/a&gt;则它应对应于&lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt;集合中文档的 &lt;code&gt;_id&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="aa9cbac2148670526d3d519e5dee6ea130222409" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;#accountsui&quot;&gt;&lt;code&gt;accounts-ui&lt;/code&gt; package&lt;/a&gt;, this is handled automatically. Otherwise, it is your responsibility to prompt the user for the new password and call &lt;code&gt;resetPassword&lt;/code&gt;.</source>
          <target state="translated">如果您使用&lt;a href=&quot;#accountsui&quot;&gt; &lt;code&gt;accounts-ui&lt;/code&gt; 软件包&lt;/a&gt;，则将自动处理它。否则，您有责任提示用户输入新密码并致电 &lt;code&gt;resetPassword&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06bcc9e78c2bb21dcb3079aac6d84540f5b3aefe" translate="yes" xml:space="preserve">
          <source>If you are writing a sufficiently complex system, there can come a time where it makes sense to split your code up into multiple applications. For example you may want to create a separate application for the administration UI (rather than checking permissions all through the admin part of your site, you can check once), or separate the code for the mobile and desktop versions of your app.</source>
          <target state="translated">如果你正在编写一个足够复杂的系统,那么有可能会出现将你的代码拆分成多个应用程序的情况。例如,你可能想为管理UI创建一个单独的应用程序(而不是通过网站的管理部分检查所有的权限,你可以检查一次),或者将应用程序的移动和桌面版本的代码分开。</target>
        </trans-unit>
        <trans-unit id="7f83f266fe7c51111db4542f3327157af67710c3" translate="yes" xml:space="preserve">
          <source>If you are writing an Atmosphere package and want to depend on React or an npm package that itself depends on React, you can&amp;rsquo;t use &lt;code&gt;Npm.depends()&lt;/code&gt; and &lt;code&gt;Npm.require()&lt;/code&gt;, as this will result in &lt;em&gt;2&lt;/em&gt; copies of React being installed into the application (and besides &lt;code&gt;Npm.require()&lt;/code&gt; only works on the server).</source>
          <target state="translated">如果您正在编写Atmosphere软件包并希望依赖于React或本身依赖于React的npm软件包，则不能使用 &lt;code&gt;Npm.depends()&lt;/code&gt; 和 &lt;code&gt;Npm.require()&lt;/code&gt; ，因为这将导致生成&lt;em&gt;2&lt;/em&gt;个React副本安装到应用程序中（除了 &lt;code&gt;Npm.require()&lt;/code&gt; 仅在服务器上有效）。</target>
        </trans-unit>
        <trans-unit id="e329ffe4d4352ad12312e6534162a4a2e649de79" translate="yes" xml:space="preserve">
          <source>If you are writing your UI in React, you don&amp;rsquo;t need to use the underscore-split names because you can import and export your components using the JavaScript module system.</source>
          <target state="translated">如果您在React中编写UI，则无需使用下划线分隔的名称，因为您可以使用JavaScript模块系统导入和导出组件。</target>
        </trans-unit>
        <trans-unit id="659690531c99cc5e2d95d388f1499fce82ca8944" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;#observe&quot;&gt;&lt;code&gt;observe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#observe_changes&quot;&gt;&lt;code&gt;observeChanges&lt;/code&gt;&lt;/a&gt; in your publish handler, this is the place to stop the observes.</source>
          <target state="translated">如果您在发布处理程序中调用&lt;a href=&quot;#observe&quot;&gt; &lt;code&gt;observe&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#observe_changes&quot;&gt; &lt;code&gt;observeChanges&lt;/code&gt; &lt;/a&gt;，则这是停止观察的地方。</target>
        </trans-unit>
        <trans-unit id="f940f6361999d494cb3913faecf1eef5363643fe" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;Meteor.subscribe&lt;/code&gt; within a &lt;a href=&quot;#reactivity&quot;&gt;reactive computation&lt;/a&gt;, for example using &lt;a href=&quot;#tracker_autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt;, the subscription will automatically be cancelled when the computation is invalidated or stopped; it is not necessary to call &lt;code&gt;stop&lt;/code&gt; on subscriptions made from inside &lt;code&gt;autorun&lt;/code&gt;. However, if the next iteration of your run function subscribes to the same record set (same name and parameters), Meteor is smart enough to skip a wasteful unsubscribe/resubscribe. For example:</source>
          <target state="translated">如果您在&lt;a href=&quot;#reactivity&quot;&gt;反应式计算中&lt;/a&gt;调用 &lt;code&gt;Meteor.subscribe&lt;/code&gt; ，例如使用&lt;a href=&quot;#tracker_autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; &lt;/a&gt;，则在计算无效或停止时，该订阅将自动被取消；不需要对在 &lt;code&gt;autorun&lt;/code&gt; 内部进行的订阅调用 &lt;code&gt;stop&lt;/code&gt; 。但是，如果运行函数的下一个迭代订阅相同的记录集（相同的名称和参数），则Meteor足够聪明，可以跳过浪费的取消订阅/重新订阅。例如：</target>
        </trans-unit>
        <trans-unit id="363327b954cca9f195c1c649f444f45739a2e788" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;retrieveCredential&lt;/code&gt; (such as &lt;code&gt;Twitter.retrieveCredential&lt;/code&gt;) as part of your process, you&amp;rsquo;ll find when using oauth-encryption that the sensitive service data fields will be encrypted.</source>
          <target state="translated">如果在处理过程中调用 &lt;code&gt;retrieveCredential&lt;/code&gt; （例如 &lt;code&gt;Twitter.retrieveCredential&lt;/code&gt; ），则在使用oauth-encryption时会发现敏感服务数据字段将被加密。</target>
        </trans-unit>
        <trans-unit id="1a2a8c9ff8959cd1adc8f20009a2ba8c4e5965f4" translate="yes" xml:space="preserve">
          <source>If you call a Method from the client, and the user&amp;rsquo;s Internet connection disconnects before the result is received, Meteor assumes that the Method didn&amp;rsquo;t actually run. When the connection is re-established, the Method call will be sent again. This means that, in certain situations, Methods can be sent more than once. This should only happen very rarely, but in the case where an extra Method call could have negative consequences it is worth putting in extra effort to ensure that Methods are idempotent - that is, calling them multiple times doesn&amp;rsquo;t result in additional changes to the database.</source>
          <target state="translated">如果您从客户端调用方法，并且在收到结果之前用户的Internet连接断开，Meteor会认为该方法实际上并未运行。重新建立连接后，将再次发送&amp;ldquo;方法&amp;rdquo;调用。这意味着在某些情况下，方法可以发送多次。这种情况很少发生，但是在额外的方法调用可能带来负面后果的情况下，值得付出额外的努力来确保方法是幂等的-也就是说，多次调用它们不会导致对方法的其他更改数据库。</target>
        </trans-unit>
        <trans-unit id="2b45991fd53c406dd8ba5027a0a2ef5841574572" translate="yes" xml:space="preserve">
          <source>If you declare your function &lt;code&gt;async&lt;/code&gt; (which ends up meaning it returns a Promise itself), then you can use the &lt;code&gt;await&lt;/code&gt; keyword to wait on other promise inside. This makes it very easy to serially call Promise-based libraries:</source>
          <target state="translated">如果您声明函数 &lt;code&gt;async&lt;/code&gt; （最终意味着它返回Promise本身），则可以使用 &lt;code&gt;await&lt;/code&gt; 关键字等待内部的其他promise。这使得串行调用基于Promise的库非常容易：</target>
        </trans-unit>
        <trans-unit id="fd785af84fa7dff0dbf544f602fd98895d4d3b63" translate="yes" xml:space="preserve">
          <source>If you do define a stub, when a client invokes a server method it will also run its stub in parallel. On the client, the return value of a stub is ignored. Stubs are run for their side-effects: they are intended to &lt;em&gt;simulate&lt;/em&gt; the result of what the server&amp;rsquo;s method will do, but without waiting for the round trip delay. If a stub throws an exception it will be logged to the console.</source>
          <target state="translated">如果您确实定义了存根，则当客户端调用服务器方法时，它还将并行运行其存根。在客户端上，存根的返回值将被忽略。运行存根是有其副作用的：它们旨在&lt;em&gt;模拟&lt;/em&gt;服务器方法将执行的结果，但无需等待往返延迟。如果存根引发异常，它将被记录到控制台。</target>
        </trans-unit>
        <trans-unit id="6148c0d6b3374c86a11ad5b57f1396a9d7e550bc" translate="yes" xml:space="preserve">
          <source>If you do not pass a callback on the server, the method invocation will block until the method is complete. It will eventually return the return value of the method, or it will throw an exception if the method threw an exception. (Possibly mapped to 500 Server Error if the exception happened remotely and it was not a &lt;code&gt;Meteor.Error&lt;/code&gt; exception.)</source>
          <target state="translated">如果未在服务器上传递回调，则方法调用将一直阻塞，直到方法完成为止。它将最终返回该方法的返回值，或者如果该方法引发异常，则它将引发异常。（如果异常是远程发生的，并且不是 &lt;code&gt;Meteor.Error&lt;/code&gt; 异常，则可能映射到500 Server Error 。）</target>
        </trans-unit>
        <trans-unit id="fd4ae11be9d693e1df07c25a2b8223c096072e18" translate="yes" xml:space="preserve">
          <source>If you do not, you&amp;rsquo;ll see performance problems across the board: you&amp;rsquo;ll be flooding the user&amp;rsquo;s network connection with a lot of small changes, the UI will update on every keystroke, potentially causing poor performance, and your database will suffer with a lot of writes.</source>
          <target state="translated">如果不这样做，您将看到全面的性能问题：您将在用户的网络连接上进行很多小的更改，UI会在每次击键时更新，从而可能导致性能下降，并且数据库将遭受很多写。</target>
        </trans-unit>
        <trans-unit id="76fb23773566e23e36d33206e24cdb3178ab9aa9" translate="yes" xml:space="preserve">
          <source>If you do want to run on an emulator however, you will have to create an Android Virtual Device (AVD) using the &lt;a href=&quot;http://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD Manager&lt;/a&gt;. Make sure to configure an AVD with an API level that is supported by the version of &lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt; you are using.</source>
          <target state="translated">但是，如果您确实想在模拟器上运行，则必须使用&lt;a href=&quot;http://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD Manager&lt;/a&gt;创建一个Android虚拟设备（AVD）。确保使用您正在使用的&lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt;版本支持的API级别配置AVD 。</target>
        </trans-unit>
        <trans-unit id="d9d5dfa5aa9a9fed895487410611d51e88bb26a6" translate="yes" xml:space="preserve">
          <source>If you do want to run on an emulator however, you will have to create an Android Virtual Device (AVD) using the &lt;a href=&quot;https://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD Manager&lt;/a&gt;. Make sure to configure an AVD with an API level that is supported by the version of &lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt; you are using.</source>
          <target state="translated">但是，如果您确实想在模拟器上运行，则必须使用&lt;a href=&quot;https://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD Manager&lt;/a&gt;创建一个Android虚拟设备（AVD）。确保使用您正在使用的&lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt;版本支持的API级别配置AVD 。</target>
        </trans-unit>
        <trans-unit id="4a16236bdfe301b23681c3e64d38581d168c40e3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the Spacebars syntax Meteor uses by default and want something more concise, you can give Jade a try by using &lt;a href=&quot;https://atmospherejs.com/pacreach/jade&quot;&gt;&lt;code&gt;pacreach:jade&lt;/code&gt;&lt;/a&gt;. This package will compile all files in your app with the &lt;code&gt;.jade&lt;/code&gt; extension into Blaze-compatible code, and can be used side-by-side with &lt;code&gt;blaze-html-templates&lt;/code&gt; if you want to have some of your code in Spacebars and some in Jade.</source>
          <target state="translated">如果您不喜欢Meteor默认使用的空格键语法，并且想要更简洁一些，可以使用&lt;a href=&quot;https://atmospherejs.com/pacreach/jade&quot;&gt; &lt;code&gt;pacreach:jade&lt;/code&gt; &lt;/a&gt;来尝试Jade。该软件包会将带有 &lt;code&gt;.jade&lt;/code&gt; 扩展名的应用程序中的所有文件编译为与Blaze兼容的代码，并且如果您想在Spacebars中使用某些代码，而在Jade中使用某些代码，则可以与 &lt;code&gt;blaze-html-templates&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a95858c1b5bf60634e7f0d372e99009f60aac8a9" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify an &lt;code&gt;element&lt;/code&gt;, there must be a current View or an error will be thrown. This is in contrast to &lt;a href=&quot;#Blaze-currentView&quot;&gt;&lt;code&gt;Blaze.currentView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不指定 &lt;code&gt;element&lt;/code&gt; ，则必须有一个当前的View，否则将引发错误。这与&lt;a href=&quot;#Blaze-currentView&quot;&gt; &lt;code&gt;Blaze.currentView&lt;/code&gt; &lt;/a&gt;相反。</target>
        </trans-unit>
        <trans-unit id="cd239e7eea9e7f823e105095f42ad9b54c4839d8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to configure routing for your login flow, you can just drop in a self-managing accounts screen. Wherever you want the accounts UI template to render, just include the &lt;code&gt;atForm&lt;/code&gt; template, like so:</source>
          <target state="translated">如果您不想为登录流程配置路由，则可以进入自我管理帐户屏幕。无论您希望在何处呈现帐户UI模板，只需包括 &lt;code&gt;atForm&lt;/code&gt; 模板，如下所示：</target>
        </trans-unit>
        <trans-unit id="b1573469eb7f247c50ce7fbab146e00b26b3f812" translate="yes" xml:space="preserve">
          <source>If you find details which are not covered here, please discuss it using the &amp;ldquo;Discuss&amp;rdquo; button above, or if you have something super important, open a pull-request to this article using the &amp;ldquo;Edit on GitHub&amp;rdquo; button above!</source>
          <target state="translated">如果您发现此处未涵盖的详细信息，请使用上方的&amp;ldquo;讨论&amp;rdquo;按钮进行讨论，或者，如果您有一些非常重要的内容，请使用上方的&amp;ldquo;在GitHub上编辑&amp;rdquo;按钮打开对本文的拉取请求！</target>
        </trans-unit>
        <trans-unit id="65bc36c47d894f01a4e87b238fceb3d19a9623f5" translate="yes" xml:space="preserve">
          <source>If you find you need to roll your code version back, you&amp;rsquo;ll need to be careful about the data, and step carefully through your deployment steps in reverse.</source>
          <target state="translated">如果发现需要回滚代码版本，则需要注意数据，并以相反的顺序仔细完成部署步骤。</target>
        </trans-unit>
        <trans-unit id="32c6f2c42b738be2d574541d656f4e171c4fc143" translate="yes" xml:space="preserve">
          <source>If you find yourself repeating the fields often, it makes sense to factor out a dictionary of public fields that you can always filter by, like so:</source>
          <target state="translated">如果你发现自己经常重复这些字段,那么就可以考虑建立一个公共字段的字典,你可以随时通过这个字典进行过滤,就像这样。</target>
        </trans-unit>
        <trans-unit id="60508d0195278e02c7f01b6c3816fe005d0a2af0" translate="yes" xml:space="preserve">
          <source>If you have a Meteor Method in your app that has secret business logic, you might want to split the Method into two functions - the optimistic UI part that will run on the client, and the secret part that runs on the server. Most of the time, putting the entire Method on the server doesn&amp;rsquo;t result in the best user experience. Let&amp;rsquo;s look at an example, where you have a secret algorithm for calculating someone&amp;rsquo;s MMR (ranking) in a game:</source>
          <target state="translated">如果您的应用程序中有一个具有秘密业务逻辑的Meteor方法，则可能需要将该方法拆分为两个功能-将在客户端上运行的乐观UI部分和在服务器上运行的秘密部分。在大多数情况下，将整个方法放在服务器上并不能带来最佳的用户体验。让我们看一个示例，其中有一个用于计算游戏中某人的MMR（排名）的秘密算法：</target>
        </trans-unit>
        <trans-unit id="8156151f762a8b5bb399c6b5390e667ddae668b7" translate="yes" xml:space="preserve">
          <source>If you have common functionality for a template instance that needs to be abstracted or called from multiple event handlers, it&amp;rsquo;s sensible to attach it as functions directly to the template instance in the &lt;code&gt;onCreated()&lt;/code&gt; callback:</source>
          <target state="translated">如果您需要一个需要从多个事件处理程序中抽象或调用的模板实例的通用功能，将其作为函数直接附加到 &lt;code&gt;onCreated()&lt;/code&gt; 回调中的模板实例是明智的：</target>
        </trans-unit>
        <trans-unit id="5fe8e1ee5bcaefed08e7a001aa1e129aa98523ac" translate="yes" xml:space="preserve">
          <source>If you have customized the URL, you will need to add a new route to your router that handles the URL you have specified, and the default &lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt; and friends won&amp;rsquo;t work for you.</source>
          <target state="translated">如果您已自定义URL，则需要向路由器添加一条新路由以处理您指定的URL，默认的 &lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt; 和朋友将对您不起作用。</target>
        </trans-unit>
        <trans-unit id="2576bf6b17f6256f97eaf30e6197009d3a4bb8a9" translate="yes" xml:space="preserve">
          <source>If you have files too large to fit in the cache you can disable caching by URL prefix. For example,</source>
          <target state="translated">如果您的文件太大,无法放入缓存,您可以通过URL前缀来禁止缓存。例如</target>
        </trans-unit>
        <trans-unit id="55c37bdac67940dd6c04beee487794a450e41286" translate="yes" xml:space="preserve">
          <source>If you have installed the &lt;a href=&quot;https://crosswalk-project.org/&quot;&gt;Crosswalk plugin&lt;/a&gt; you will need to manually copy the APK file &lt;code&gt;cp ~/build-output-directory/android/project/build/outputs/apk/android-armv7-release-unsigned.apk ~/build-output-directory/android/release-unsigned.apk&lt;/code&gt;</source>
          <target state="translated">如果您已经安装了&lt;a href=&quot;https://crosswalk-project.org/&quot;&gt;Crosswalk插件&lt;/a&gt;，则需要手动复制APK文件 &lt;code&gt;cp ~/build-output-directory/android/project/build/outputs/apk/android-armv7-release-unsigned.apk ~/build-output-directory/android/release-unsigned.apk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19d4f62e5ed43836a90bb2599b61937b57ea459e" translate="yes" xml:space="preserve">
          <source>If you have two servers that access the same database and you want authenticated users to make DDP calls across the both of them, you can use the &lt;em&gt;resume token&lt;/em&gt; set on one connection to login on the other.</source>
          <target state="translated">如果您有两个访问同一数据库的服务器，并且希望经过身份验证的用户在这两个服务器上进行DDP调用，则可以使用在一个连接上设置的&lt;em&gt;恢复令牌&lt;/em&gt;登录另一个连接。</target>
        </trans-unit>
        <trans-unit id="708491dd1370be5e5338376bb313b8787ead6f4a" translate="yes" xml:space="preserve">
          <source>If you include a callback function as the last argument (which can&amp;rsquo;t be an argument to the method, since functions aren&amp;rsquo;t serializable), the method will run asynchronously: it will return nothing in particular and will not throw an exception. When the method is complete (which may or may not happen before &lt;code&gt;Meteor.call&lt;/code&gt; returns), the callback will be called with two arguments: &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt;. If an error was thrown, then &lt;code&gt;error&lt;/code&gt; will be the exception object. Otherwise, &lt;code&gt;error&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; and the return value (possibly &lt;code&gt;undefined&lt;/code&gt;) will be in &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">如果您将回调函数作为最后一个参数（由于函数无法序列化，则不能作为该方法的参数），则该方法将异步运行：它不会特别返回任何内容，也不会引发异常。方法完成后（在 &lt;code&gt;Meteor.call&lt;/code&gt; 返回之前可能会发生或可能不会发生），将使用两个参数调用回调： &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 。如果抛出错误，则 &lt;code&gt;error&lt;/code&gt; 将是异常对象。否则， &lt;code&gt;error&lt;/code&gt; 将是 &lt;code&gt;undefined&lt;/code&gt; ，并且返回值（可能是 &lt;code&gt;undefined&lt;/code&gt; ）将是 &lt;code&gt;result&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c09f3964469e3d6071e869f94fc554ee91ba160" translate="yes" xml:space="preserve">
          <source>If you need more control, you can use the comprehensive &lt;a href=&quot;https://atmospherejs.com/nimble/restivus&quot;&gt;&lt;code&gt;nimble:restivus&lt;/code&gt;&lt;/a&gt; package to create more or less whatever you need in whatever ontology you require.</source>
          <target state="translated">如果您需要更多控制权，则可以使用全面的&lt;a href=&quot;https://atmospherejs.com/nimble/restivus&quot;&gt; &lt;code&gt;nimble:restivus&lt;/code&gt; &lt;/a&gt;软件包来创建或多或少创建所需本体中的所需对象。</target>
        </trans-unit>
        <trans-unit id="69e1d32387fa3bf1f8850dd2be1963668d185452" translate="yes" xml:space="preserve">
          <source>If you need to &lt;code&gt;require&lt;/code&gt; from an ES2015 module with a &lt;code&gt;default&lt;/code&gt; export, you can grab the export with &lt;code&gt;require(&quot;package&quot;).default&lt;/code&gt;.</source>
          <target state="translated">如果您需要使用 &lt;code&gt;default&lt;/code&gt; 导出的ES2015模块进行 &lt;code&gt;require&lt;/code&gt; ，则可以使用 &lt;code&gt;require(&quot;package&quot;).default&lt;/code&gt; 获取导出。</target>
        </trans-unit>
        <trans-unit id="32f5a311eb54e0e89f2a82767a1d291a18a86abb" translate="yes" xml:space="preserve">
          <source>If you need to communicate &lt;em&gt;up&lt;/em&gt; the component hierarchy, it&amp;rsquo;s best to pass a &lt;em&gt;callback&lt;/em&gt; for the sub-component to call.</source>
          <target state="translated">如果您需要&lt;em&gt;向上&lt;/em&gt;沟通组件层次结构，则最好传递一个&lt;em&gt;回调&lt;/em&gt;以供子组件调用。</target>
        </trans-unit>
        <trans-unit id="a950a357df8eb170b55154af24dd529d3c231d91" translate="yes" xml:space="preserve">
          <source>If you need to customize configuration files, a workaround is to create a dummy Cordova plugin. In its &lt;code&gt;plugin.xml&lt;/code&gt;, you can specify a &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/plugin_ref/spec.html#config-file&quot;&gt;&lt;code&gt;config-file&lt;/code&gt; element&lt;/a&gt; to selectively change parts of configuration files, including &lt;code&gt;config.xml&lt;/code&gt;.</source>
          <target state="translated">如果您需要自定义配置文件，则解决方法是创建一个虚拟Cordova插件。在其 &lt;code&gt;plugin.xml&lt;/code&gt; 中，可以指定&lt;a href=&quot;https://cordova.apache.org/docs/en/dev/plugin_ref/spec.html#config-file&quot;&gt; &lt;code&gt;config-file&lt;/code&gt; 元素&lt;/a&gt;以有选择地更改部分配置文件，包括 &lt;code&gt;config.xml&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="023f7fb7bd41613742fdd31b445948d2c96152f8" translate="yes" xml:space="preserve">
          <source>If you need to modify a package to do something that the published version doesn&amp;rsquo;t do, you can edit a local version of the package on your computer.</source>
          <target state="translated">如果您需要修改软件包以执行发布的版本不执行的操作，则可以在计算机上编辑软件包的本地版本。</target>
        </trans-unit>
        <trans-unit id="8e59c515e053f34b94356278d4d589171811b978" translate="yes" xml:space="preserve">
          <source>If you need to modify an Atmosphere package to do something that the published version doesn&amp;rsquo;t do, you can edit a local version of the package on your computer.</source>
          <target state="translated">如果您需要修改Atmosphere程序包以执行发布版本不执行的操作，则可以在计算机上编辑该程序包的本地版本。</target>
        </trans-unit>
        <trans-unit id="6719ea6fd09d8642115e2738b2fa7b3c19b86c2e" translate="yes" xml:space="preserve">
          <source>If you need to pass in content to a sub-component (for instance the content of a modal dialog), you can use the &lt;a href=&quot;spacebars#Block-Helpers&quot;&gt;custom block helper&lt;/a&gt; to provide a block of content. If you need more flexibility, typically just providing the component name as an argument is the way to go. The sub-component can then just render that component with:</source>
          <target state="translated">如果需要将内容传递给子组件（例如，模式对话框的内容），则可以使用&lt;a href=&quot;spacebars#Block-Helpers&quot;&gt;自定义块帮助器&lt;/a&gt;来提供内容块。如果需要更大的灵活性，通常只需提供组件名称作为参数即可。然后，子组件可以使用以下命令渲染该组件：</target>
        </trans-unit>
        <trans-unit id="60e1562de4c4577b416776c8f13b5ce755259251" translate="yes" xml:space="preserve">
          <source>If you need to perform complex logic in the update (e.g. not just call &lt;code&gt;.set()&lt;/code&gt; etc), it&amp;rsquo;s a good idea to define a mutator on the store. As the store is a singleton, you can just attach a function to the object directly:</source>
          <target state="translated">如果您需要在更新中执行复杂的逻辑（例如，不仅要调用 &lt;code&gt;.set()&lt;/code&gt; 等），最好在商店中定义一个mutator。由于商店是单身人士，您可以直接将函数附加到对象：</target>
        </trans-unit>
        <trans-unit id="654272e3ce4909f8985019cb527be487853abbd2" translate="yes" xml:space="preserve">
          <source>If you need to query the store, or store many related items, it&amp;rsquo;s probably a good idea to use a Local Collection (see the &lt;a href=&quot;collections#local-collections&quot;&gt;Collections Article&lt;/a&gt;).</source>
          <target state="translated">如果您需要查询商店或存储许多相关项目，则最好使用Local Collection（请参阅&lt;a href=&quot;collections#local-collections&quot;&gt;Collections文章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6ab6af9f91959a8a24789d29e0b338bb37411702" translate="yes" xml:space="preserve">
          <source>If you need to update a store as a result of user action, you&amp;rsquo;d update the store from an event handler, just like you call &lt;a href=&quot;methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">如果您需要由于用户操作而更新商店，则可以从事件处理程序中更新商店，就像调用&lt;a href=&quot;methods&quot;&gt;Methods一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efd2957123b064a7818d716974462558124329d7" translate="yes" xml:space="preserve">
          <source>If you need to wait on specific data that you aren&amp;rsquo;t already subscribed to at creation time, you can use an &lt;code&gt;autorun&lt;/code&gt; and &lt;code&gt;subscriptionsReady()&lt;/code&gt; to wait on that subscription:</source>
          <target state="translated">如果需要等待创建时尚未订阅的特定数据，可以使用 &lt;code&gt;autorun&lt;/code&gt; 和 &lt;code&gt;subscriptionsReady()&lt;/code&gt; 来等待该订阅：</target>
        </trans-unit>
        <trans-unit id="9f3346d500969dfc5716aa94a72a5dfd4cd9fcf2" translate="yes" xml:space="preserve">
          <source>If you nest calls to &lt;code&gt;Tracker.autorun&lt;/code&gt;, then when the outer call stops or reruns, the inner call will stop automatically. Subscriptions and observers are also automatically stopped when used as part of a computation that is rerun, allowing new ones to be established. See &lt;a href=&quot;#meteor_subscribe&quot;&gt;&lt;code&gt;Meteor.subscribe&lt;/code&gt;&lt;/a&gt; for more information about subscriptions and reactivity.</source>
          <target state="translated">如果将调用嵌套到 &lt;code&gt;Tracker.autorun&lt;/code&gt; ，则外部调用停止或重新运行时，内部调用将自动停止。当订阅和观察者用作重新运行的计算的一部分时，也会自动停止，从而可以建立新的订阅者和观察者。有关订阅和反应性的更多信息，请参见&lt;a href=&quot;#meteor_subscribe&quot;&gt; &lt;code&gt;Meteor.subscribe&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eae024890ceb1234290cc4d422f8ed1a2b324cb8" translate="yes" xml:space="preserve">
          <source>If you never set up any &lt;code&gt;allow&lt;/code&gt; rules on a collection then all client writes to the collection will be denied, and it will only be possible to write to the collection from server-side code. In this case you will have to create a method for each possible write that clients are allowed to do. You&amp;rsquo;ll then call these methods with &lt;code&gt;Meteor.call&lt;/code&gt; rather than having the clients call &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; directly on the collection.</source>
          <target state="translated">如果您从未在集合上设置任何 &lt;code&gt;allow&lt;/code&gt; 规则，则所有客户端对该集合的写操作都将被拒绝，并且只能从服务器端代码写入该集合。在这种情况下，您将必须为允许客户端执行的每个可能的写入创建一个方法。然后，您将使用 &lt;code&gt;Meteor.call&lt;/code&gt; 调用这些方法，而不是让客户端直接在集合上调用 &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31353d838973b6f1d6acf793dd0fd42bc4f4e33e" translate="yes" xml:space="preserve">
          <source>If you only use the package on the server (or the client), you can pass in the second argument (e.g., &lt;code&gt;'server'&lt;/code&gt;, &lt;code&gt;'client'&lt;/code&gt;, &lt;code&gt;'web.browser'&lt;/code&gt;, &lt;code&gt;'web.cordova'&lt;/code&gt;) to specify what architecture the package is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt;.</source>
          <target state="translated">如果仅在服务器（或客户端）上使用软件包，则可以传入第二个参数（例如 &lt;code&gt;'server'&lt;/code&gt; ， &lt;code&gt;'client'&lt;/code&gt; ， &lt;code&gt;'web.browser'&lt;/code&gt; ， &lt;code&gt;'web.cordova'&lt;/code&gt; ）来指定包一起使用。您可以通过传入数组来指定多种架构，例如 &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70eda8c785500d1835d716f8bcc7b8608c610f85" translate="yes" xml:space="preserve">
          <source>If you only want to export the object on the server (or the client), you can pass in the second argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the export is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova',
'os.linux']&lt;/code&gt;.</source>
          <target state="translated">如果只想在服务器（或客户端）上导出对象，则可以传入第二个参数（例如，&amp;ldquo;服务器&amp;rdquo;，&amp;ldquo;客户端&amp;rdquo;，&amp;ldquo; web.browser&amp;rdquo;，&amp;ldquo; web.cordova&amp;rdquo;）以指定导出所使用的体系结构。您可以通过传入数组来指定多种架构，例如 &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb64e0557d37e4a2ee2273b90c1a4a82f437c565" translate="yes" xml:space="preserve">
          <source>If you only want to use the file on the server (or the client), you can pass this argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the file is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt;. By default, the file will be loaded on both server and client.</source>
          <target state="translated">如果您只想使用服务器（或客户端）上的文件，则可以传递此参数（例如，&amp;ldquo;服务器&amp;rdquo;，&amp;ldquo;客户端&amp;rdquo;，&amp;ldquo; web.browser&amp;rdquo;，&amp;ldquo; web.cordova&amp;rdquo;）来指定文件一起使用。您可以通过传入数组来指定多种架构，例如 &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; 。默认情况下，文件将同时在服务器和客户端上加载。</target>
        </trans-unit>
        <trans-unit id="b51bac2bb462f0ba6e12e56dd4ca41d9afce2036" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;name&lt;/code&gt;, then you&amp;rsquo;re creating a local collection. It&amp;rsquo;s not synchronized anywhere; it&amp;rsquo;s just a local scratchpad that supports Mongo-style &lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#remove&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; operations. (On both the client and the server, this scratchpad is implemented using Minimongo.)</source>
          <target state="translated">如果您传递 &lt;code&gt;null&lt;/code&gt; 作为 &lt;code&gt;name&lt;/code&gt; ，那么您正在创建本地集合。它没有在任何地方同步；它只是一个本地暂存器，支持Mongo风格的&lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#update&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#remove&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt;操作。（在客户端和服务器上，都使用Minimongo来实现此暂存器。）</target>
        </trans-unit>
        <trans-unit id="76375f0d40a2218ea32885bbabe00ec9f6d79889" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;name&lt;/code&gt; when you create the collection, then you are declaring a persistent collection &amp;mdash; one that is stored on the server and seen by all users. Client code and server code can both access the same collection using the same API.</source>
          <target state="translated">如果在创建集合时传递 &lt;code&gt;name&lt;/code&gt; ，那么您将声明一个持久性集合-存储在服务器上并被所有用户看到的持久性集合。客户端代码和服务器代码都可以使用相同的API访问相同的集合。</target>
        </trans-unit>
        <trans-unit id="c4c2ef87749b60f0b7cd70a7d4629765b8376fa9" translate="yes" xml:space="preserve">
          <source>If you prefer, you can &lt;code&gt;export&lt;/code&gt; variables by name, rather than prefixing their declarations with the &lt;code&gt;export&lt;/code&gt; keyword:</source>
          <target state="translated">如果愿意，可以按名称 &lt;code&gt;export&lt;/code&gt; 变量，而不必在声明前加上 &lt;code&gt;export&lt;/code&gt; 关键字：</target>
        </trans-unit>
        <trans-unit id="0d3b5535270d855b9d87288618cee525ac40aa10" translate="yes" xml:space="preserve">
          <source>If you receive an error message trying to run the app on your device after adding or removing the Crosswalk plugin, you may have to remove the existing app from your device first.</source>
          <target state="translated">如果您在添加或删除Crosswalk插件后,试图在设备上运行应用时收到错误信息,您可能需要先从设备上删除现有应用。</target>
        </trans-unit>
        <trans-unit id="fa02ebfad523f59063b573838ecf664c424fcb41" translate="yes" xml:space="preserve">
          <source>If you return multiple cursors in an array, they currently must all be from different collections. We hope to lift this restriction in a future release.</source>
          <target state="translated">如果你在一个数组中返回多个游标,目前它们必须都来自不同的集合。我们希望在未来的版本中取消这个限制。</target>
        </trans-unit>
        <trans-unit id="e312d61a29c2e25efd10fe560130993582d137e4" translate="yes" xml:space="preserve">
          <source>If you run this inside an app, it will place the newly generated package in that app&amp;rsquo;s &lt;code&gt;packages/&lt;/code&gt; directory. Outside an app, it will just create a standalone package directory. The command also generates some boilerplate files for you:</source>
          <target state="translated">如果您在应用程序中运行此程序，它将把新生成的程序包放在该应用程序的 &lt;code&gt;packages/&lt;/code&gt; 目录中。在应用程序外部，它将仅创建一个独立的软件包目录。该命令还会为您生成一些样板文件：</target>
        </trans-unit>
        <trans-unit id="742984d503cc47bf2c358af12faa73a9fb129605" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;transform&lt;/code&gt; option to the &lt;code&gt;Collection&lt;/code&gt; or any of its retrieval methods, documents are passed through the &lt;code&gt;transform&lt;/code&gt; function before being returned or passed to callbacks. This allows you to add methods or otherwise modify the contents of your collection from their database representation. You can also specify &lt;code&gt;transform&lt;/code&gt; on a particular &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findOne&lt;/code&gt;, &lt;code&gt;allow&lt;/code&gt;, or &lt;code&gt;deny&lt;/code&gt; call. Transform functions must return an object and they may not change the value of the document&amp;rsquo;s &lt;code&gt;_id&lt;/code&gt; field (though it&amp;rsquo;s OK to leave it out).</source>
          <target state="translated">如果为 &lt;code&gt;Collection&lt;/code&gt; 或其任何检索方法指定了 &lt;code&gt;transform&lt;/code&gt; 选项，则文档在返回或传递给回调之前先通过 &lt;code&gt;transform&lt;/code&gt; 函数传递。这使您可以添加方法或通过其数据库表示形式修改集合的内容。您还可以在特定的 &lt;code&gt;find&lt;/code&gt; ， &lt;code&gt;findOne&lt;/code&gt; ， &lt;code&gt;allow&lt;/code&gt; 或 &lt;code&gt;deny&lt;/code&gt; 调用上指定 &lt;code&gt;transform&lt;/code&gt; 。转换函数必须返回一个对象，并且它们不能更改文档的 &lt;code&gt;_id&lt;/code&gt; 字段的值（尽管可以将其保留）。</target>
        </trans-unit>
        <trans-unit id="edc0fd33d8a117a5ab7778b16886ea7f1d79a0d8" translate="yes" xml:space="preserve">
          <source>If you use a mis-matched version of Node when deploying your application, you will encounter errors!</source>
          <target state="translated">如果你在部署应用时使用了错误匹配的Node版本,你将会遇到错误!</target>
        </trans-unit>
        <trans-unit id="43c2fb22beebdc9b2308d62f74049ee5dae68715" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;--extra-packages&lt;/code&gt;, simply remove &lt;code&gt;bundle-visualizer&lt;/code&gt; from the list of included packages and run &lt;code&gt;meteor&lt;/code&gt; as normal.</source>
          <target state="translated">如果您使用 &lt;code&gt;--extra-packages&lt;/code&gt; ，只需从包含的软件包列表中删除 &lt;code&gt;bundle-visualizer&lt;/code&gt; 即可正常运行 &lt;code&gt;meteor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="805385e49f22a4e87ef81b6890d03855fe1bb088" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;meteor create&lt;/code&gt; to set up your package, Meteor will create the required scaffolding in &lt;code&gt;package.js&lt;/code&gt;, and you&amp;rsquo;ll only need to add unit test code in the &lt;code&gt;_test.js&lt;/code&gt; file that was created.</source>
          <target state="translated">如果您使用 &lt;code&gt;meteor create&lt;/code&gt; 设置程序包，Meteor将在 &lt;code&gt;package.js&lt;/code&gt; 中创建所需的脚手架，而您只需要在创建的 &lt;code&gt;_test.js&lt;/code&gt; 文件中添加单元测试代码。</target>
        </trans-unit>
        <trans-unit id="821581b081f9e39832410418d07af184f979c66c" translate="yes" xml:space="preserve">
          <source>If you want a different URL for your reset password page, you need to customize it using the &lt;code&gt;Accounts.urls&lt;/code&gt; option:</source>
          <target state="translated">如果您要为重置密码页面使用其他URL，则需要使用 &lt;code&gt;Accounts.urls&lt;/code&gt; 选项来自定义它：</target>
        </trans-unit>
        <trans-unit id="9c96c2c8b925cd1f056cacee3cba2eff30a8a78b" translate="yes" xml:space="preserve">
          <source>If you want something that just works out of the box, you can use &lt;code&gt;accounts-ui&lt;/code&gt; or &lt;code&gt;useraccounts&lt;/code&gt; which basically do everything for you. Only follow the directions below if you definitely want to build all parts of the email flow yourself.</source>
          <target state="translated">如果您想开箱即用，则可以使用 &lt;code&gt;accounts-ui&lt;/code&gt; 或 &lt;code&gt;useraccounts&lt;/code&gt; ，它们基本上可以为您做任何事情。如果您确实要自己构建电子邮件流的所有部分，请仅遵循以下说明。</target>
        </trans-unit>
        <trans-unit id="a923cf26eb143d4bd926131addd26f0898988c97" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;@import&lt;/code&gt; a file, give it the extension &lt;code&gt;.import.less&lt;/code&gt; to prevent Meteor from processing it independently.</source>
          <target state="translated">如果要 &lt;code&gt;@import&lt;/code&gt; 文件，请给它扩展名 &lt;code&gt;.import.less&lt;/code&gt; 以防止Meteor独立处理它。</target>
        </trans-unit>
        <trans-unit id="36263f74ab08609e71e2a0635b7e0b3763fc19ed" translate="yes" xml:space="preserve">
          <source>If you want to access the custom data you&amp;rsquo;ve added to the &lt;code&gt;Meteor.users&lt;/code&gt; collection in your UI, you&amp;rsquo;ll need to publish it to the client. Mostly, you can just follow the advice in the &lt;a href=&quot;data-loading#publications&quot;&gt;Data Loading&lt;/a&gt; and &lt;a href=&quot;security#publications&quot;&gt;Security&lt;/a&gt; articles.</source>
          <target state="translated">如果要访问已添加到UI中 &lt;code&gt;Meteor.users&lt;/code&gt; 集合中的自定义数据，则需要将其发布到客户端。通常，您可以按照&amp;ldquo; &lt;a href=&quot;data-loading#publications&quot;&gt;数据加载&lt;/a&gt;和&lt;a href=&quot;security#publications&quot;&gt;安全性&amp;rdquo;&lt;/a&gt;文章中的建议进行操作。</target>
        </trans-unit>
        <trans-unit id="1dd7a801198a2c39927ff54c88b3c6d8df722080" translate="yes" xml:space="preserve">
          <source>If you want to add a plugin to your project directly, you use the same &lt;code&gt;meteor add&lt;/code&gt; command you use for Meteor packages, but with a &lt;code&gt;cordova:&lt;/code&gt; prefix:</source>
          <target state="translated">如果要直接将插件添加到项目中，请使用与Meteor软件包相同的 &lt;code&gt;meteor add&lt;/code&gt; 命令，但要使用 &lt;code&gt;cordova:&lt;/code&gt; 前缀：</target>
        </trans-unit>
        <trans-unit id="92a9fd0bc52ad779ebd778c5fd248dc61e5c0046" translate="yes" xml:space="preserve">
          <source>If you want to control the look and feel of your accounts system a little more, we recommend reading the &lt;a href=&quot;http://guide.meteor.com/accounts.html#useraccounts&quot;&gt;useraccounts&lt;/a&gt; section of the Meteor Guide.</source>
          <target state="translated">如果你想控制你的帐户系统的外观和感觉多一点，我们建议您阅读&lt;a href=&quot;http://guide.meteor.com/accounts.html#useraccounts&quot;&gt;useraccounts&lt;/a&gt;流星指南的部分。</target>
        </trans-unit>
        <trans-unit id="e4485e7c91563dbd446f72af133ab9e712fa169e" translate="yes" xml:space="preserve">
          <source>If you want to create Meteor applications with separate code, you&amp;rsquo;ll have some modules that you&amp;rsquo;d like to share between them. If those modules are something the wider world could use, you should consider &lt;a href=&quot;https://guide.meteor.com/writing-packages.html&quot;&gt;publishing them to a package system&lt;/a&gt;, either npm or Atmosphere, depending on whether the code is Meteor-specific or otherwise.</source>
          <target state="translated">如果要使用单独的代码创建Meteor应用程序，则需要在其中共享一些模块。如果这些模块是更广泛的世界可以使用的模块，则应考虑将其&lt;a href=&quot;https://guide.meteor.com/writing-packages.html&quot;&gt;发布到软件包系统&lt;/a&gt;（npm或Atmosphere），具体取决于代码是特定于Meteor还是其他。</target>
        </trans-unit>
        <trans-unit id="fc0eac225bc136e4bc540429b926182185644a6c" translate="yes" xml:space="preserve">
          <source>If you want to distribute and reuse code that you&amp;rsquo;ve written for a Meteor application, then you should consider publishing that code on npm if it&amp;rsquo;s general enough to be consumed by a wider JavaScript audience. It&amp;rsquo;s simple to &lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;use npm packages in Meteor applications&lt;/a&gt;, and possible to &lt;a href=&quot;writing-atmosphere-packages#npm-dependencies&quot;&gt;use npm packages within Atmosphere packages&lt;/a&gt;, so even if your main audience is Meteor developers, npm might be the best choice.</source>
          <target state="translated">如果您想分发和重用为Meteor应用程序编写的代码，则应考虑在通用代码中将其发布给npm，以使更多的JavaScript读者可以使用。&lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;在Meteor应用程序中使用npm软件包&lt;/a&gt;很简单，并且可以&lt;a href=&quot;writing-atmosphere-packages#npm-dependencies&quot;&gt;在Atmosphere软件包中使用npm软件包&lt;/a&gt;，因此，即使您的主要受众是Meteor开发人员，npm也是最佳选择。</target>
        </trans-unit>
        <trans-unit id="c0fc530b3866845a455553c0e4ab36f9e6f967d6" translate="yes" xml:space="preserve">
          <source>If you want to figure out your hosting solution completely from scratch, the Meteor tool has a command &lt;code&gt;meteor build&lt;/code&gt; that creates a deployment bundle that contains a plain Node.js application. Any npm dependencies must be installed before issuing the &lt;code&gt;meteor build&lt;/code&gt; command to be included in the bundle. You can host this application wherever you like and there are many options in terms of how you set it up and configure it.</source>
          <target state="translated">如果您想完全从头解决托管解决方案，则Meteor工具具有命令 &lt;code&gt;meteor build&lt;/code&gt; ，该命令流创建了一个包含简单Node.js应用程序的部署捆绑包。在发出要包含在包中的 &lt;code&gt;meteor build&lt;/code&gt; 命令之前，必须安装所有npm依赖项。您可以随时随地托管此应用程序，并且在设置和配置方式方面有很多选择。</target>
        </trans-unit>
        <trans-unit id="7ae60d3de6bfaaedbdcc006106966c1f253333e9" translate="yes" xml:space="preserve">
          <source>If you want to include different files on the client and server, you can specify multiple entry points using the second argument to the function:</source>
          <target state="translated">如果你想在客户端和服务器上包含不同的文件,你可以使用函数的第二个参数指定多个入口点。</target>
        </trans-unit>
        <trans-unit id="4f972521fcac6ee91fd73a08381fa4f8f920e549" translate="yes" xml:space="preserve">
          <source>If you want to return an error from a method, throw an exception. Methods can throw any kind of exception. But &lt;code&gt;Meteor.Error&lt;/code&gt; is the only kind of error that a server will send to the client. If a method function throws a different exception, then it will be mapped to a sanitized version on the wire. Specifically, if the &lt;code&gt;sanitizedError&lt;/code&gt; field on the thrown error is set to a &lt;code&gt;Meteor.Error&lt;/code&gt;, then that error will be sent to the client. Otherwise, if no sanitized version is available, the client gets &lt;code&gt;Meteor.Error(500, 'Internal server error')&lt;/code&gt;.</source>
          <target state="translated">如果要从方法返回错误，请引发异常。方法可以引发任何类型的异常。但是 &lt;code&gt;Meteor.Error&lt;/code&gt; 是服务器将发送到客户端的唯一错误类型。如果一个方法函数抛出一个不同的异常，那么它将被映射到网络上的一个已清理版本。具体来说，如果抛出的错误上的 &lt;code&gt;sanitizedError&lt;/code&gt; 字段设置为 &lt;code&gt;Meteor.Error&lt;/code&gt; ，则该错误将发送到客户端。否则，如果没有可用的经过清理的版本，则客户端将获取 &lt;code&gt;Meteor.Error(500, 'Internal server error')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7111ffe70dd95b9b0e14be2f5578ec58fc3ed2" translate="yes" xml:space="preserve">
          <source>If you want to share packages during development, we recommend using the &lt;a href=&quot;#including-in-app&quot;&gt;above methods&lt;/a&gt; instead of the registry. If you use the registry, then every time you change the package, you need to increment the version number, publish, and then &lt;code&gt;npm update my-package&lt;/code&gt; inside your app.</source>
          <target state="translated">如果要在开发过程中共享软件包，建议使用&lt;a href=&quot;#including-in-app&quot;&gt;上述方法&lt;/a&gt;代替注册表。如果使用注册表，则每次更改软件包时，都需要增加版本号，发布，然后 &lt;code&gt;npm update my-package&lt;/code&gt; 应用程序内部的my-package。</target>
        </trans-unit>
        <trans-unit id="cacc81197389ff21d88d4a1b76df1c865b14ae98" translate="yes" xml:space="preserve">
          <source>If you want to share variables between &lt;code&gt;.coffee&lt;/code&gt; files in the same package, and don&amp;rsquo;t want to separately declare them in a &lt;code&gt;.js&lt;/code&gt; file, we have an experimental feature that you may like. An object called &lt;code&gt;share&lt;/code&gt; is visible in CoffeeScript code and is shared across all &lt;code&gt;.coffee&lt;/code&gt; files in the same package. So, you can write &lt;code&gt;share.foo&lt;/code&gt; for a value that is shared between all CoffeeScript code in a package, but doesn&amp;rsquo;t escape that package.</source>
          <target state="translated">如果您想在同一包中的 &lt;code&gt;.coffee&lt;/code&gt; 文件之间共享变量，并且不想在 &lt;code&gt;.js&lt;/code&gt; 文件中单独声明它们，则我们可能会提供实验功能。在CoffeeScript代码中可见一个名为 &lt;code&gt;share&lt;/code&gt; 的对象，该对象在同一包中的所有 &lt;code&gt;.coffee&lt;/code&gt; 文件中共享。因此，您可以为一个包中所有CoffeeScript代码之间共享的值编写 &lt;code&gt;share.foo&lt;/code&gt; ，但不会对该包进行转义。</target>
        </trans-unit>
        <trans-unit id="49cf7dc12dadff9f25f077c9b8c06f4354a4b8a8" translate="yes" xml:space="preserve">
          <source>If you want to use React but don&amp;rsquo;t want to deal with JSX and prefer a more HTML-like syntax, there are a few community options available. One that stands out in particular is &lt;a href=&quot;https://github.com/timbrandin/blaze-react&quot;&gt;Blaze-React&lt;/a&gt;, which simulates the entire Blaze API using React as a rendering engine.</source>
          <target state="translated">如果您想使用React而又不想使用JSX并更喜欢类似HTML的语法，那么可以使用一些社区选项。特别引人注目的一个是&lt;a href=&quot;https://github.com/timbrandin/blaze-react&quot;&gt;Blaze-React&lt;/a&gt;，它使用React作为渲染引擎来模拟整个Blaze API。</target>
        </trans-unit>
        <trans-unit id="41bade3a7dcebb190bfe12581761642937527f57" translate="yes" xml:space="preserve">
          <source>If you want to use oplog tailing for livequeries, you should also set &lt;code&gt;MONGO_OPLOG_URL&lt;/code&gt; (generally you&amp;rsquo;ll need a special user with oplog access, but the detail can differ depending on how you host your MongoDB. Read more &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">如果您想使用oplog &lt;code&gt;MONGO_OPLOG_URL&lt;/code&gt; ，还应该设置MONGO_OPLOG_URL（通常，您需要具有oplog访问权限的特殊用户，但是具体信息可能取决于您托管MongoDB的方式。&lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md&quot;&gt;在此处&lt;/a&gt;了解更多信息）。</target>
        </trans-unit>
        <trans-unit id="ce4d1abdea3f4e41b8fe3175178e29f4791be17f" translate="yes" xml:space="preserve">
          <source>If you wanted to refactor this and create a completely fiber-wrapper GitHub client, you could write some logic to loop over all of the methods available and call &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; on them, creating a new object with the same shape but with a more Meteor-compatible API.</source>
          <target state="translated">如果您想重构它并创建一个完全用光纤包装的GitHub客户端，则可以编写一些逻辑来循环所有可用方法，并在它们上调用 &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; ，以创建形状相同但流星更多的新对象兼容的API。</target>
        </trans-unit>
        <trans-unit id="1c33d46441a45788337f6d42fd1d1e26bedc1952" translate="yes" xml:space="preserve">
          <source>If you would like a module to be evaluated &lt;em&gt;lazily&lt;/em&gt; (in other words: on demand, the first time you import it, just like Node does it), then you should put that module in an &lt;code&gt;imports/&lt;/code&gt; directory (anywhere in your app, not just the root directory), and include that directory when you import the module: &lt;code&gt;import {stuff} from './imports/lazy'&lt;/code&gt;. Note: files contained by &lt;code&gt;node_modules/&lt;/code&gt; directories will also be evaluated lazily (more on that below).</source>
          <target state="translated">如果您希望对模块进行&lt;em&gt;延迟&lt;/em&gt;评估（换句话说：按需，第一次导入它，就像Node一样），那么您应该将该模块放在 &lt;code&gt;imports/&lt;/code&gt; 目录中（在您应用中的任何位置，而不是只是根目录），并在导入模块时包括该目录： &lt;code&gt;import {stuff} from './imports/lazy'&lt;/code&gt; 。注意： &lt;code&gt;node_modules/&lt;/code&gt; 目录中包含的文件也将被延迟评估（更多内容请参见下文）。</target>
        </trans-unit>
        <trans-unit id="42245b2fe211585e66a13c2329947b0a15f2c9eb" translate="yes" xml:space="preserve">
          <source>If you would like to write your UI in Angular, you will need to switch out Meteor&amp;rsquo;s Blaze template compiler which comes by default with the Angular one. Read about how to do this in the &lt;a href=&quot;https://www.meteor.com/tutorials/angular/templates&quot;&gt;Angular-Meteor tutorial&lt;/a&gt;.</source>
          <target state="translated">如果要用Angular编写UI，则需要切换Meteor的Blaze模板编译器（默认情况下是Angular附带）。在&lt;a href=&quot;https://www.meteor.com/tutorials/angular/templates&quot;&gt;Angular-Meteor教程中&lt;/a&gt;了解有关如何执行此操作的信息。</target>
        </trans-unit>
        <trans-unit id="6ae0f5526a3368a315a3ee049922b378d12a6796" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use React within a larger app built with &lt;a href=&quot;#blaze.html&quot;&gt;Blaze&lt;/a&gt; (which is a good strategy if you&amp;rsquo;d like to incrementally migrate an app from Blaze to React), you can use the &lt;a href=&quot;https://atmospherejs.com/meteor/react-template-helper&quot;&gt;&lt;code&gt;react-template-helper&lt;/code&gt;&lt;/a&gt; component which renders a react component inside a Blaze template. First run &lt;code&gt;meteor add react-template-helper&lt;/code&gt;, then use the &lt;code&gt;React&lt;/code&gt; helper in your template:</source>
          <target state="translated">如果您想在使用&lt;a href=&quot;#blaze.html&quot;&gt;Blaze&lt;/a&gt;构建的更大应用程序中使用React （如果您希望将应用程序从Blaze逐步迁移到React，这是一个不错的策略），则可以使用&lt;a href=&quot;https://atmospherejs.com/meteor/react-template-helper&quot;&gt; &lt;code&gt;react-template-helper&lt;/code&gt; &lt;/a&gt;组件，该组件将对Blaze模板中的组件进行反应。首先运行 &lt;code&gt;meteor add react-template-helper&lt;/code&gt; ，然后在模板中使用 &lt;code&gt;React&lt;/code&gt; helper：</target>
        </trans-unit>
        <trans-unit id="7596943dbc0af4ae30e0432a397f5843337ecb20" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use a third party React component that has been &lt;a href=&quot;https://www.npmjs.com/search?q=react&quot;&gt;published on npm&lt;/a&gt;, you can &lt;code&gt;meteor npm install --save&lt;/code&gt; them and &lt;code&gt;import&lt;/code&gt; from within your app.</source>
          <target state="translated">如果您想使用&lt;a href=&quot;https://www.npmjs.com/search?q=react&quot;&gt;npm&lt;/a&gt;上发布的第三方React组件，可以使用 &lt;code&gt;meteor npm install --save&lt;/code&gt; 它们并从您的应用程序中 &lt;code&gt;import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3a47851997e9719060ed24db1f93098aa6f746" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer not to move your files, you can use the file names themselves as the URL prefix:</source>
          <target state="translated">如果您不想移动文件，则可以使用文件名本身作为URL前缀：</target>
        </trans-unit>
        <trans-unit id="499841c65766072e137aeada538c5c92c96ee692" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather use different names, you&amp;rsquo;ll be glad to know &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements can rename their arguments:</source>
          <target state="translated">如果您想使用其他名称，您将很高兴知道 &lt;code&gt;export&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 语句可以重命名其参数：</target>
        </trans-unit>
        <trans-unit id="88f3c1415cb4c72de10579daaedaddf12c72050f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building your app&amp;rsquo;s UI with React, currently the most popular way to write your UI components involves JSX, an extension to JavaScript that allows you to type HTML tags that are converted to React DOM elements. JSX code is handled automatically by the &lt;code&gt;ecmascript&lt;/code&gt; package.</source>
          <target state="translated">如果您使用React构建应用的UI，那么目前最流行的编写UI组件的方式就是JSX，它是JavaScript的扩展，允许您键入转换为React DOM元素的HTML标签。 &lt;code&gt;ecmascript&lt;/code&gt; 软件包自动处理JSX代码。</target>
        </trans-unit>
        <trans-unit id="31775e85032a6fd9250108f5001616c8899d8c0f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating from a version of Meteor older than Meteor 1.4, there may be important considerations not listed in this guide (which specifically covers 1.4 to 1.5). Please review the older migration guides for details:</source>
          <target state="translated">如果要从早于Meteor 1.4的Meteor版本进行迁移，则可能有一些重要注意事项未在本指南中列出（具体涵盖1.4到1.5）。请查看旧的迁移指南以了解详细信息：</target>
        </trans-unit>
        <trans-unit id="5365047de0adb8409cd922540f38f767bd93d769" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 14.04 LTS, you&amp;rsquo;ll have to add the Ubuntu Make ppa first:</source>
          <target state="translated">如果您使用的是Ubuntu 14.04 LTS，则必须首先添加Ubuntu Make ppa：</target>
        </trans-unit>
        <trans-unit id="5c5696d8555b1c20f1bf0bb1844d70e90ed70e80" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re publishing a subset of your data, it might be tempting to simply query for all data available in a collection (i.e. &lt;code&gt;Lists.find()&lt;/code&gt;) in order to get that subset on the client, without re-specifying the Mongo selector you used to publish that data in the first place.</source>
          <target state="translated">如果要发布数据的子集，可能 &lt;code&gt;Lists.find()&lt;/code&gt; 简单地查询集合中的所有可用数据（即Lists.find（）），以便在客户端上获取该子集，而无需重新指定Mongo选择器您曾经首先发布该数据。</target>
        </trans-unit>
        <trans-unit id="fb02597191cd0266ef242c2eea7154a86775dbd9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running Ubuntu, the easiest way to install both a Java Development Kit and Android Studio is by using &lt;a href=&quot;https://wiki.ubuntu.com/ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt;, a command line tool that sets up development environments and dependencies for you.</source>
          <target state="translated">如果您正在运行Ubuntu，则同时安装Java开发工具包和Android Studio的最简单方法是使用&lt;a href=&quot;https://wiki.ubuntu.com/ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt;（命令行工具），该工具为您设置开发环境和依赖项。</target>
        </trans-unit>
        <trans-unit id="5f22fc89859e18f087e9ac77136cd04b17cad5ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running your Meteor server behind a proxy (so that clients are connecting to the proxy instead of to your server directly), you&amp;rsquo;ll need to set the &lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; environment variable for the correct IP address to be reported by &lt;code&gt;clientAddress&lt;/code&gt;.</source>
          <target state="translated">如果你正在运行的背后代理您的流星服务器（以便客户端连接到代理，而不是你的服务器直接），你需要设置 &lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; 环境变量被报告正确的IP地址 &lt;code&gt;clientAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20e4e29c6b6992e85e71ca85e9479b3d30a6511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re testing code that makes use of globals, you&amp;rsquo;ll need to import those globals. For instance if you have a global &lt;code&gt;Todos&lt;/code&gt; collection and are testing this file:</source>
          <target state="translated">如果要测试使用全局变量的代码，则需要导入这些全局变量。例如，如果您有一个全局的 &lt;code&gt;Todos&lt;/code&gt; 集合并正在测试此文件：</target>
        </trans-unit>
        <trans-unit id="3ea89e1575e79ec50a68342b1f9403e4d48ee575" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;Galaxy to host your meteor apps&lt;/a&gt;, you can also take advantage of built-in automatic &lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt; integration. Simply add &lt;a href=&quot;https://atmospherejs.com/mdg/seo&quot;&gt;&lt;code&gt;mdg:seo&lt;/code&gt;&lt;/a&gt; to your app and Galaxy will take care of the rest: loading the code and configuring it with Galaxy-provided credentials.</source>
          <target state="translated">如果您使用&lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;Galaxy托管流星应用程序&lt;/a&gt;，则还可以利用内置的自动&lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt;集成。只需将&lt;a href=&quot;https://atmospherejs.com/mdg/seo&quot;&gt; &lt;code&gt;mdg:seo&lt;/code&gt; &lt;/a&gt;添加到您的应用程序中，剩下的工作将由Galaxy负责：加载代码并使用Galaxy提供的凭据对其进行配置。</target>
        </trans-unit>
        <trans-unit id="a4a00ef04d1c2eaefdc036812fd307a1efa0977e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the oauth packages directly instead of through the Meteor accounts packages, you can load the OAuth encryption key directly using &lt;code&gt;OAuthEncryption.loadKey&lt;/code&gt;:</source>
          <target state="translated">如果直接使用oauth软件包而不是通过Meteor &lt;code&gt;OAuthEncryption.loadKey&lt;/code&gt; 软件包，则可以使用OAuthEncryption.loadKey直接加载OAuth加密密钥：</target>
        </trans-unit>
        <trans-unit id="0260685729406497298030dd969298bab8f10738" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve added &lt;code&gt;bundle-visualizer&lt;/code&gt; permanently with &lt;code&gt;meteor add&lt;/code&gt;, it is important to remove this package prior to bundling or deploying to production with &lt;code&gt;meteor remove bundle-visualizer&lt;/code&gt;.</source>
          <target state="translated">如果您已将 &lt;code&gt;bundle-visualizer&lt;/code&gt; 永久 &lt;code&gt;meteor add&lt;/code&gt; 到meteor add中，那么在捆绑包或使用 &lt;code&gt;meteor remove bundle-visualizer&lt;/code&gt; 进行生产之前，请务必删除此软件包。</target>
        </trans-unit>
        <trans-unit id="19725733123f8a4d34132c4329ecf327377a341b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever looked inside Meteor&amp;rsquo;s package cache at &lt;code&gt;~/.meteor/packages&lt;/code&gt;, you know that the on-disk format of a built Meteor package is completely different from the way the source code looks when you&amp;rsquo;re developing the package. The idea is that the target format of a package can remain consistent even if the API for development changes.</source>
          <target state="translated">如果您曾经在 &lt;code&gt;~/.meteor/packages&lt;/code&gt; 查看过Meteor的程序包缓存，就会知道内置的Meteor程序包的磁盘格式与开发程序包时源代码的外观完全不同。这个想法是，即使用于开发的API发生更改，程序包的目标格式也可以保持一致。</target>
        </trans-unit>
        <trans-unit id="9f440a209b38a0f987257912b3f67de486d7d36a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever needed to deal with sending pretty HTML emails from an app, you know that it can quickly become a nightmare. Compatibility of popular email clients with basic HTML features like CSS is notoriously spotty, so it is hard to author something that works at all. Start with a &lt;a href=&quot;https://github.com/leemunroe/responsive-html-email-template&quot;&gt;responsive email template&lt;/a&gt; or &lt;a href=&quot;http://foundation.zurb.com/emails/email-templates.html&quot;&gt;framework&lt;/a&gt;, and then use a tool to convert your email content into something that is compatible with all email clients. &lt;a href=&quot;http://blog.mailgun.com/transactional-html-email-templates/&quot;&gt;This blog post by Mailgun covers some of the main issues with HTML email.&lt;/a&gt; In theory, a community package could extend Meteor&amp;rsquo;s build system to do the email compilation for you, but at the time of writing we were not aware of any such packages.</source>
          <target state="translated">如果您曾经需要通过应用程序发送漂亮的HTML电子邮件，那么您就会知道它很快就会成为噩梦。众所周知，流行的电子邮件客户端与CSS之类的基本HTML功能之间的兼容性差强人意，因此很难编写出所有有用的东西。从&lt;a href=&quot;https://github.com/leemunroe/responsive-html-email-template&quot;&gt;响应式电子邮件模板&lt;/a&gt;或&lt;a href=&quot;http://foundation.zurb.com/emails/email-templates.html&quot;&gt;框架开始&lt;/a&gt;，然后使用工具将您的电子邮件内容转换为与所有电子邮件客户端兼容的内容。&lt;a href=&quot;http://blog.mailgun.com/transactional-html-email-templates/&quot;&gt;Mailgun的这篇博客文章介绍了HTML电子邮件的一些主要问题。&lt;/a&gt;从理论上讲，社区软件包可以扩展Meteor的构建系统来为您完成电子邮件编译，但是在撰写本文时，我们还没有发现任何此类软件包。</target>
        </trans-unit>
        <trans-unit id="f6cfc5243c8df3d9a63fb062cb8ee3ba3d011041" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;MAIL_URL&lt;/code&gt; is TLS/SSL-only (and does not need &lt;a href=&quot;https://en.wikipedia.org/wiki/Opportunistic_TLS&quot;&gt;&lt;code&gt;STARTTLS&lt;/code&gt;&lt;/a&gt;), be sure that the &lt;code&gt;MAIL_URL&lt;/code&gt; starts with &lt;code&gt;smtps://&lt;/code&gt; and not just &lt;code&gt;smtp://&lt;/code&gt;.</source>
          <target state="translated">如果您的 &lt;code&gt;MAIL_URL&lt;/code&gt; 仅是TLS / SSL（并且不需要&lt;a href=&quot;https://en.wikipedia.org/wiki/Opportunistic_TLS&quot;&gt; &lt;code&gt;STARTTLS&lt;/code&gt; &lt;/a&gt;），请确保 &lt;code&gt;MAIL_URL&lt;/code&gt; 以 &lt;code&gt;smtps://&lt;/code&gt; 开头，而不仅仅是 &lt;code&gt;smtp://&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bca3c619420dcc3af6e645389094a62cbd09e93a" translate="yes" xml:space="preserve">
          <source>If your Meteor application targets mobile platforms such as iOS or Android, you can configure your app&amp;rsquo;s metadata and build process in a special top-level file called &lt;code&gt;mobile-config.js&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; included in your application and is used only for this configuration.</source>
          <target state="translated">如果您的流星应用程序面向移动平台如iOS或Android，你可以称之为一种特殊的顶层文件来配置你的应用程序的元数据和生成过程 &lt;code&gt;mobile-config.js&lt;/code&gt; 这是&lt;em&gt;不&lt;/em&gt;包含在您的应用程序，仅用于此配置。</target>
        </trans-unit>
        <trans-unit id="2da0eab193064a83b91356769c2f6cdf1588ce7f" translate="yes" xml:space="preserve">
          <source>If your app is running when you add a new package, Meteor will automatically download it and restart your app for you.</source>
          <target state="translated">如果您在添加新包时,您的应用正在运行,Meteor会自动为您下载并重启您的应用。</target>
        </trans-unit>
        <trans-unit id="2222e79cd3eccad7198f782778d27c13e6b13b42" translate="yes" xml:space="preserve">
          <source>If your app supports or even requires login with an external service such as Facebook, it&amp;rsquo;s natural to also want to use that service&amp;rsquo;s API to request additional data about that user. For example, you might want to get a list of a Facebook user&amp;rsquo;s photos.</source>
          <target state="translated">如果您的应用程序支持甚至需要使用Facebook之类的外部服务登录，那么自然也要使用该服务的API来请求有关该用户的其他数据。例如，您可能想要获取Facebook用户照片的列表。</target>
        </trans-unit>
        <trans-unit id="08e998b29173e8ef9bfc7d2f8922182e751fad65" translate="yes" xml:space="preserve">
          <source>If your app uses &lt;code&gt;ES2015&lt;/code&gt; modules included from &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt; entry points, import your JSON file(s) there. The &lt;code&gt;i18n.__()&lt;/code&gt; function will now locate keys you pass.</source>
          <target state="translated">如果您的应用程序使用 &lt;code&gt;client/main.js&lt;/code&gt; 和 &lt;code&gt;server/main.js&lt;/code&gt; 入口点中包含的 &lt;code&gt;ES2015&lt;/code&gt; 模块，请在此处导入您的JSON文件。在 &lt;code&gt;i18n.__()&lt;/code&gt; 函数现在找到你传递的密钥。</target>
        </trans-unit>
        <trans-unit id="e1b228c980b89740aa6d004bbb2d247570085696" translate="yes" xml:space="preserve">
          <source>If your application contains a lot of publicly accessible content, then you probably want it to rank well in Google and other search engines&amp;rsquo; indexes. As most webcrawlers do not support client-side rendering (or if they do, have spotty support for websockets), it&amp;rsquo;s better to render the site on the server and deliver it as HTML in this special case.</source>
          <target state="translated">如果您的应用程序包含许多可公开访问的内容，那么您可能希望它在Google和其他搜索引擎的索引中排名较高。由于大多数网络爬虫都不支持客户端渲染（或者，如果支持，则对Websockets的支持很差），因此在这种特殊情况下，最好在服务器上渲染站点并将其作为HTML交付。</target>
        </trans-unit>
        <trans-unit id="443805ac684272a5317505238336ced4fa1d6932" translate="yes" xml:space="preserve">
          <source>If your helper or sub-component is expensive to run, and often re-runs without any visible effect, you can short circuit unnecessary re-runs by using a more subtle reactive data source. The &lt;a href=&quot;https://atmospherejs.com/peerlibrary/computed-field&quot;&gt;&lt;code&gt;peerlibrary:computed-field&lt;/code&gt;&lt;/a&gt; package helps achieve this pattern.</source>
          <target state="translated">如果您的助手或子组件的运行成本很高，并且经常重新运行而没有任何可见的效果，则可以通过使用更细微的反应性数据源来短路不必要的重新运行。该&lt;a href=&quot;https://atmospherejs.com/peerlibrary/computed-field&quot;&gt; &lt;code&gt;peerlibrary:computed-field&lt;/code&gt; &lt;/a&gt;封装有助于实现这种模式。</target>
        </trans-unit>
        <trans-unit id="8b6c180b8b1666c01b2235381c3ddbf401cb3710" translate="yes" xml:space="preserve">
          <source>If your local machine does not (yet) fulfill the &lt;a href=&quot;#installing-prerequisites&quot;&gt;prerequisites&lt;/a&gt; for building apps for a mobile platform, an error message with a list of missing requirements is printed (but the platform is still added). You will have to make sure these requirements are fulfilled before you&amp;rsquo;re able to build and run mobile apps from your machine.</source>
          <target state="translated">如果您的本地计算机（尚未）满足构建移动平台应用程序的&lt;a href=&quot;#installing-prerequisites&quot;&gt;先决条件&lt;/a&gt;，则会显示一条错误消息，其中列出了缺少的要求（但仍添加了平台）。您必须先确保满足这些要求，然后才能从计算机上构建和运行移动应用程序。</target>
        </trans-unit>
        <trans-unit id="bbfb435552ea9ee7046837462da38f718f502dd4" translate="yes" xml:space="preserve">
          <source>If your migration needs to change a lot of data, and especially if you need to stop your app server while it&amp;rsquo;s running, it may be a good idea to use a &lt;a href=&quot;https://docs.mongodb.org/v3.0/core/bulk-write-operations/&quot;&gt;MongoDB Bulk Operation&lt;/a&gt;.</source>
          <target state="translated">如果您的迁移需要更改大量数据，特别是如果您需要在应用服务器运行时停止它，那么最好使用&lt;a href=&quot;https://docs.mongodb.org/v3.0/core/bulk-write-operations/&quot;&gt;MongoDB批量操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c47562df69dcac594dd921f0b8fca330b6da4988" translate="yes" xml:space="preserve">
          <source>If your package depends on an Atmosphere package (which, in Meteor 1.3, includes the Meteor core packages), or needs to take advantage of Meteor&amp;rsquo;s &lt;a href=&quot;build-tool&quot;&gt;build system&lt;/a&gt;, writing an Atmosphere package might be the best option for now.</source>
          <target state="translated">如果您的软件包依赖于Atmosphere软件包（在Meteor 1.3中包括Meteor核心软件包），或者需要利用Meteor的&lt;a href=&quot;build-tool&quot;&gt;构建系统&lt;/a&gt;，那么编写Atmosphere软件包可能是目前的最佳选择。</target>
        </trans-unit>
        <trans-unit id="7df795cdeb6c4309ef74c33ebea90ca11bb2cea9" translate="yes" xml:space="preserve">
          <source>If your type does not have a &lt;code&gt;clone&lt;/code&gt; method, &lt;code&gt;EJSON.clone&lt;/code&gt; will use &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; and the factory instead.</source>
          <target state="translated">如果您的类型没有 &lt;code&gt;clone&lt;/code&gt; 方法，则 &lt;code&gt;EJSON.clone&lt;/code&gt; 将使用&lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt;和工厂代替。</target>
        </trans-unit>
        <trans-unit id="4952908c2b33520dba66cb4ce8895b270a0b5c4d" translate="yes" xml:space="preserve">
          <source>If your type does not have an &lt;code&gt;equals&lt;/code&gt; method, &lt;code&gt;EJSON.equals&lt;/code&gt; will compare the result of calling &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您的类型没有 &lt;code&gt;equals&lt;/code&gt; 方法，则 &lt;code&gt;EJSON.equals&lt;/code&gt; 会比较调用&lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="3780874bb50e4ae63d44565f0229e3cb84ecb1c3" translate="yes" xml:space="preserve">
          <source>If your user has connected to server A, then you can use &lt;code&gt;DDP.connect()&lt;/code&gt; to open a connection to server B, and pass in server A&amp;rsquo;s resume token to authenticate on server B. As both servers are using the same DB, the same server token will work in both cases. The code to authenticate looks like this:</source>
          <target state="translated">如果您的用户已连接到服务器A，则可以使用 &lt;code&gt;DDP.connect()&lt;/code&gt; 打开与服务器B的连接，并传入服务器A的恢复令牌以在服务器B上进行身份验证。由于两个服务器都使用相同的数据库，因此相同服务器令牌将在两种情况下均起作用。进行身份验证的代码如下所示：</target>
        </trans-unit>
        <trans-unit id="0d6c3eca8ae6dd0e9730869d69558e35ae209f84" translate="yes" xml:space="preserve">
          <source>If/Unless</source>
          <target state="translated">If/Unless</target>
        </trans-unit>
        <trans-unit id="c4fff34a8b4255393b375dcf27718bc368d36741" translate="yes" xml:space="preserve">
          <source>Important: The Crosswalk project is not maintained anymore. The last Crosswalk release was Crosswalk 23. Read more in this &lt;a href=&quot;https://crosswalk-project.org/blog/crosswalk-final-release.html&quot;&gt;announcement&lt;/a&gt;</source>
          <target state="translated">重要说明：Crosswalk项目不再维护。Crosswalk的最新版本是Crosswalk23。阅读此&lt;a href=&quot;https://crosswalk-project.org/blog/crosswalk-final-release.html&quot;&gt;公告中的&lt;/a&gt;更多内容</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="8de4d9b83abc3870a49a5b05034966d706aff446" translate="yes" xml:space="preserve">
          <source>Importing Meteor &amp;ldquo;pseudo-globals&amp;rdquo;</source>
          <target state="translated">导入流星&amp;ldquo; pseudo-globals&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0180eade6f8fdf9833f897f7054b069805c4cee6" translate="yes" xml:space="preserve">
          <source>Importing from packages</source>
          <target state="translated">从包中导入</target>
        </trans-unit>
        <trans-unit id="93d406ddd29c50f712d0a5130e11b85db3a79c5f" translate="yes" xml:space="preserve">
          <source>Importing styles</source>
          <target state="translated">导入样式</target>
        </trans-unit>
        <trans-unit id="683aeb4ac5cf9954986f29864981cce1ab6c749f" translate="yes" xml:space="preserve">
          <source>Importing styles from Atmosphere packages</source>
          <target state="translated">从Atmosphere包中导入样式</target>
        </trans-unit>
        <trans-unit id="24c238bdcdfe7255fb7fb97ee01cef351c1aab61" translate="yes" xml:space="preserve">
          <source>Importing styles from an Atmosphere package using the &lt;code&gt;{}&lt;/code&gt; package name syntax:</source>
          <target state="translated">使用 &lt;code&gt;{}&lt;/code&gt; 包名称语法从Atmosphere包中导入样式：</target>
        </trans-unit>
        <trans-unit id="479bfc3d1edcdab2600d4235255458197f7b0cd7" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package using the &lt;code&gt;{}&lt;/code&gt; syntax:</source>
          <target state="translated">使用 &lt;code&gt;{}&lt;/code&gt; 语法从npm包中导入样式：</target>
        </trans-unit>
        <trans-unit id="4238f168334816b667d140df15414651a0683de7" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package with a relative path:</source>
          <target state="translated">用相对路径从npm包中导入样式。</target>
        </trans-unit>
        <trans-unit id="0275d88be57e1367c71daad9fd6ddfc29c5fc843" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package with an absolute path using the &lt;code&gt;{}&lt;/code&gt; syntax, for instance with Less:</source>
          <target state="translated">使用 &lt;code&gt;{}&lt;/code&gt; 语法从具有绝对路径的npm包中导入样式，例如使用Less：</target>
        </trans-unit>
        <trans-unit id="a57ac434414f4329e7d46fe7b8b105b9a5300f54" translate="yes" xml:space="preserve">
          <source>Importing styles from npm</source>
          <target state="translated">从npm导入样式</target>
        </trans-unit>
        <trans-unit id="ba38d99c7c09ed3a5166d4be08a0c24fe130a291" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI/UX article&lt;/a&gt; we discussed the merits of creating reusable components that interact with their environment in clear and minimal ways.</source>
          <target state="translated">在&lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI / UX文章中，&lt;/a&gt;我们讨论了创建可重用组件的优点，这些组件以清晰，最少的方式与其环境进行交互。</target>
        </trans-unit>
        <trans-unit id="5e66dd15b560e11ce815bd97ff948a7f63a4ccea" translate="yes" xml:space="preserve">
          <source>In Attribute Values</source>
          <target state="translated">在属性值中</target>
        </trans-unit>
        <trans-unit id="031be70926363c1353ae6ce239855bf4ccc6ca74" translate="yes" xml:space="preserve">
          <source>In Chimp tests, you have a DDP connection to the server available on the &lt;code&gt;server&lt;/code&gt; variable. You can thus use &lt;code&gt;server.call()&lt;/code&gt; (which is wrapped to be synchronous in Chimp tests) to call these methods. This is a convenient way to share data preparation code between acceptance and integration tests.</source>
          <target state="translated">在Chimp测试中， &lt;code&gt;server&lt;/code&gt; 变量上具有与服务器的DDP连接。因此，您可以使用 &lt;code&gt;server.call()&lt;/code&gt; （在Chimp测试中包装为同步）来调用这些方法。这是在验收测试和集成测试之间共享数据准备代码的便捷方法。</target>
        </trans-unit>
        <trans-unit id="cd540b8827cd136018e89af4ab6c812a10f70ce3" translate="yes" xml:space="preserve">
          <source>In ES2015, you can make variables available outside a file using the &lt;code&gt;export&lt;/code&gt; keyword. To use the variables somewhere else, you must &lt;code&gt;import&lt;/code&gt; them using the path to the source. Files that export some variables are called &amp;ldquo;modules&amp;rdquo;, because they represent a unit of reusable code. Explicitly importing the modules and packages you use helps you write your code in a modular way, avoiding the introduction of global symbols and &amp;ldquo;action at a distance&amp;rdquo;.</source>
          <target state="translated">在ES2015中，可以使用 &lt;code&gt;export&lt;/code&gt; 关键字使变量在文件外部可用。要在其他地方使用变量，必须使用源路径将其 &lt;code&gt;import&lt;/code&gt; 。导出某些变量的文件称为&amp;ldquo;模块&amp;rdquo;，因为它们代表可重复使用的代码单元。显式导入您使用的模块和软件包可帮助您以模块化方式编写代码，避免引入全局符号和&amp;ldquo;远距离操作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0ccbcafe57980d66695f4ae15c7f237da4917dae" translate="yes" xml:space="preserve">
          <source>In Meteor a &lt;strong&gt;publication&lt;/strong&gt; is a named API on the server that constructs a set of data to send to a client. A client initiates a &lt;strong&gt;subscription&lt;/strong&gt; which connects to a publication, and receives that data. That data consists of a first batch sent when the subscription is initialized and then incremental updates as the published data changes.</source>
          <target state="translated">在Meteor中，&lt;strong&gt;发布&lt;/strong&gt;是服务器上的命名API，该API构造了一组数据以发送给客户端。客户端发起一个&lt;strong&gt;订阅&lt;/strong&gt;，该&lt;strong&gt;订阅&lt;/strong&gt;连接到发布，并接收该数据。该数据包括在初始化订阅时发送的第一批数据，然后随着已发布数据的更改而进行增量更新。</target>
        </trans-unit>
        <trans-unit id="99e82a5e498c26c24995b21ed17d9fe40e3ffc83" translate="yes" xml:space="preserve">
          <source>In Meteor specifically, this means a component which does not access data from any global sources&amp;mdash;Collections, Stores, routers, user data, or similar. For instance, in the Todos example app, the &lt;code&gt;Lists_show&lt;/code&gt; template takes in the list it is rendering and the set of todos for that list, and it never looks directly in the &lt;code&gt;Todos&lt;/code&gt; or &lt;code&gt;Lists&lt;/code&gt; collections.</source>
          <target state="translated">具体来说，在Meteor中，这表示不访问任何全局源（集合，商店，路由器，用户数据或类似数据）中的数据的组件。例如，在Todos示例应用程序中， &lt;code&gt;Lists_show&lt;/code&gt; 模板接受正在渲染的列表以及该列表的todo集，并且从不直接在 &lt;code&gt;Todos&lt;/code&gt; 或 &lt;code&gt;Lists&lt;/code&gt; 集合中查找。</target>
        </trans-unit>
        <trans-unit id="73216ee871c012e3c35909ff083baf1ebb594997" translate="yes" xml:space="preserve">
          <source>In Meteor, &lt;a href=&quot;https://atmospherejs.com/tap/i18n&quot;&gt;the excellent &lt;code&gt;tap:i18n&lt;/code&gt; package&lt;/a&gt; provides an API for building translations and using them in your components and frontend code.</source>
          <target state="translated">在Meteor中，&lt;a href=&quot;https://atmospherejs.com/tap/i18n&quot;&gt;出色的 &lt;code&gt;tap:i18n&lt;/code&gt; 软件包&lt;/a&gt;提供了一个API，用于构建翻译并将其用于您的组件和前端代码中。</target>
        </trans-unit>
        <trans-unit id="1ec923b5f4339427381c3dc9b43a7f722506d8be" translate="yes" xml:space="preserve">
          <source>In Meteor, &lt;code&gt;import&lt;/code&gt; statements compile to CommonJS &lt;code&gt;require&lt;/code&gt; syntax. However, as a convention we encourage you to use &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">在Meteor中， &lt;code&gt;import&lt;/code&gt; 语句编译为CommonJS &lt;code&gt;require&lt;/code&gt; 语法。但是，按照惯例，我们鼓励您使用 &lt;code&gt;import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32c6aaabc70a85f54e76772ac92b389fc838ac70" translate="yes" xml:space="preserve">
          <source>In Meteor, each of your &lt;code&gt;.scss&lt;/code&gt;, &lt;code&gt;.less&lt;/code&gt;, or &lt;code&gt;.styl&lt;/code&gt; source files will be one of two types: &amp;ldquo;source&amp;rdquo; or &amp;ldquo;import&amp;rdquo;.</source>
          <target state="translated">在流星，每个的 &lt;code&gt;.scss&lt;/code&gt; ， &lt;code&gt;.less&lt;/code&gt; ，或 &lt;code&gt;.styl&lt;/code&gt; 源文件将两种类型之一：&amp;ldquo;源&amp;rdquo;或&amp;ldquo;进口&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4923d1b0b76daf5fcbd508288c27cc3e7957dcff" translate="yes" xml:space="preserve">
          <source>In Meteor, it is also simple and straightforward to use the &lt;code&gt;import&lt;/code&gt; syntax to load npm packages on the client or server and access the package&amp;rsquo;s exported symbols as you would with any other module. You can also import from Meteor Atmosphere packages, but the import path must be prefixed with &lt;code&gt;meteor/&lt;/code&gt; to avoid conflict with the npm package namespace. For example, to import &lt;code&gt;moment&lt;/code&gt; from npm and &lt;code&gt;HTTP&lt;/code&gt; from Atmosphere:</source>
          <target state="translated">在Meteor中，使用 &lt;code&gt;import&lt;/code&gt; 语法在客户端或服务器上加载npm软件包并访问该软件包的导出符号就像使用其他模块一样简单明了。您也可以从Meteor Atmosphere包中导入，但是导入路径必须以 &lt;code&gt;meteor/&lt;/code&gt; 为前缀，以避免与npm包名称空间冲突。例如，要从npm 导入 &lt;code&gt;moment&lt;/code&gt; 和从Atmosphere 导入 &lt;code&gt;HTTP&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4c64b572b6ef2d24b502212bbb30ca768c6dbbea" translate="yes" xml:space="preserve">
          <source>In Meteor, it&amp;rsquo;s best to make stores &lt;em&gt;reactive data&lt;/em&gt; sources, as that way they tie most naturally into the rest of the ecosystem. There are a few different packages you can use for stores.</source>
          <target state="translated">在Meteor中，最好使存储&lt;em&gt;响应数据&lt;/em&gt;源，因为这样它们就可以最自然地与生态系统的其余部分联系起来。您可以将几种不同的包装用于商店。</target>
        </trans-unit>
        <trans-unit id="e155d50f4e4eecfcb2e4f34e4e2b6a5b9a059df8" translate="yes" xml:space="preserve">
          <source>In Meteor, it&amp;rsquo;s often less of a problem doing this than it would be in a typical MongoDB application, as it&amp;rsquo;s easy to publish overlapping sets of documents (we might need one set of users to render one screen of our app, and an intersecting set for another), which may stay on the client as we move around the application. So in that scenario there is an advantage to separating the subdocuments from the parent.</source>
          <target state="translated">在Meteor中，这样做比通常的MongoDB应用程序中的问题少很多，因为它很容易发布重叠的文档集（我们可能需要一组用户来渲染应用程序的一个屏幕，以及一组相交的文件另一个），当我们在应用程序中移动时，它可能留在客户端上。因此，在这种情况下，将子文档与父文档分开是有好处的。</target>
        </trans-unit>
        <trans-unit id="04b569e393a950ad85b36c4944e4ee78cfce96f7" translate="yes" xml:space="preserve">
          <source>In Meteor, persistent or shared data comes over the wire on publications. However, there are some types of data which doesn&amp;rsquo;t need to be persistent or shared between users. For instance, the &amp;ldquo;logged-in-ness&amp;rdquo; of the current user, or the route they are currently viewing.</source>
          <target state="translated">在Meteor中，持久性数据或共享数据通过发布在线进行。但是，有些类型的数据不需要持久化或在用户之间共享。例如，当前用户的&amp;ldquo;登录身份&amp;rdquo;或他们当前正在查看的路线。</target>
        </trans-unit>
        <trans-unit id="243df2bc50939e5c8dbff8ec7e02da11a7cfafdd" translate="yes" xml:space="preserve">
          <source>In Meteor, that data layer is typically stored in MongoDB. A set of related data in MongoDB is referred to as a &amp;ldquo;collection&amp;rdquo;. In Meteor you access MongoDB through &lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection&quot;&gt;collections&lt;/a&gt;, making them the primary persistence mechanism for your app data.</source>
          <target state="translated">在Meteor中，该数据层通常存储在MongoDB中。MongoDB中的一组相关数据称为&amp;ldquo;集合&amp;rdquo;。在Meteor中，您可以通过&lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection&quot;&gt;collection&lt;/a&gt;访问MongoDB ，使它们成为应用程序数据的主要持久性机制。</target>
        </trans-unit>
        <trans-unit id="d705c2f995526763684d5c0dbcc5d7413ae75f89" translate="yes" xml:space="preserve">
          <source>In Meteor, the pre-eminent schema package is &lt;a href=&quot;https://atmospherejs.com/aldeed/simple-schema&quot;&gt;aldeed:simple-schema&lt;/a&gt;. It&amp;rsquo;s an expressive, MongoDB based schema that&amp;rsquo;s used to insert and update documents. Another alternative is &lt;a href=&quot;https://atmospherejs.com/jagi/astronomy&quot;&gt;jagi:astronomy&lt;/a&gt; which is a full Object Model (OM) layer offering schema definition, server/client side validators, object methods and event handlers.</source>
          <target state="translated">在Meteor中，卓越的模式包为&lt;a href=&quot;https://atmospherejs.com/aldeed/simple-schema&quot;&gt;aldeed：simple-schema&lt;/a&gt;。这是一种基于MongoDB的表达性架构，用于插入和更新文档。另一个选择是&lt;a href=&quot;https://atmospherejs.com/jagi/astronomy&quot;&gt;jagi：astronomy&lt;/a&gt;，它是一个完整的对象模型（OM）层，提供模式定义，服务器/客户端验证器，对象方法和事件处理程序。</target>
        </trans-unit>
        <trans-unit id="c20ea551526624e66f32c02279ddfd4ad6a453ae" translate="yes" xml:space="preserve">
          <source>In Meteor, you use &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-accessRule&quot;&gt;&lt;code&gt;App.accessRule&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;&lt;code&gt;mobile-config.js&lt;/code&gt;&lt;/a&gt; to set additional rules. (These correspond to &lt;code&gt;&amp;lt;access&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;allow-navigation&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;allow-intent&amp;gt;&lt;/code&gt; tags in the generated &lt;code&gt;config.xml&lt;/code&gt;.)</source>
          <target state="translated">在流星，你用&lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-accessRule&quot;&gt; &lt;code&gt;App.accessRule&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt; &lt;code&gt;mobile-config.js&lt;/code&gt; &lt;/a&gt;设置附加规则。（这些对应于生成的 &lt;code&gt;config.xml&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;access&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;allow-navigation&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;allow-intent&amp;gt;&lt;/code&gt; 标记。）</target>
        </trans-unit>
        <trans-unit id="08cb8883e896e97469dea50de221a87f03c6ddb2" translate="yes" xml:space="preserve">
          <source>In Safari on iOS8 (&lt;code&gt;window.close&lt;/code&gt; is not supported due to a bug)</source>
          <target state="translated">在iOS8的Safari中（由于存在错误，不支持 &lt;code&gt;window.close&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e765da49b6b79dfd4b8f2657786c8bc5f8b9e578" translate="yes" xml:space="preserve">
          <source>In a Mocha test, it makes sense to use &lt;code&gt;stub-collections&lt;/code&gt; in a &lt;code&gt;beforeEach&lt;/code&gt;/&lt;code&gt;afterEach&lt;/code&gt; block.</source>
          <target state="translated">在Mocha测试中，在 &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;afterEach&lt;/code&gt; 块中使用 &lt;code&gt;stub-collections&lt;/code&gt; 是有意义的。</target>
        </trans-unit>
        <trans-unit id="da80a6cebc2bbd7e40ea51ebd1046f8a19142dc8" translate="yes" xml:space="preserve">
          <source>In a basic app, defining a Meteor Method is as simple as defining a function. In a complex app, you want a few extra features to make Methods more powerful and easily testable. First, we&amp;rsquo;re going to go over how to define a Method using the Meteor core API, and in a later section we&amp;rsquo;ll go over how to use a helpful wrapper package we&amp;rsquo;ve created to enable a more powerful Method workflow.</source>
          <target state="translated">在基本应用程序中，定义&amp;ldquo;流星方法&amp;rdquo;就像定义一个函数一样简单。在复杂的应用程序中，您需要一些额外的功能来使&amp;ldquo;方法&amp;rdquo;更强大且更易于测试。首先，我们将介绍如何使用Meteor核心API定义方法，在下一节中，我们将介绍如何使用我们创建的有用包装程序包来启用更强大的Method工作流程。</target>
        </trans-unit>
        <trans-unit id="84469f6f0a35debbc63a6f80271ff741912d6215" translate="yes" xml:space="preserve">
          <source>In a server-side-rendered framework like Ruby on Rails, it&amp;rsquo;s sufficient to simply not display sensitive data in the returned HTML response. In Meteor, since the rendering is done on the client, an &lt;code&gt;if&lt;/code&gt; statement in your HTML template is not secure; you need to do security at the data level to make sure that data is never sent in the first place.</source>
          <target state="translated">在像Ruby on Rails这样的服务器端渲染框架中，仅在返回的HTML响应中不显示敏感数据就足够了。在Meteor中，由于渲染是在客户端完成的，因此HTML模板中的 &lt;code&gt;if&lt;/code&gt; 语句并不安全；您需要在数据级别执行安全性，以确保永远不会发送数据。</target>
        </trans-unit>
        <trans-unit id="32d304712bbdf90fd9fac9646044f4bd51f3331a" translate="yes" xml:space="preserve">
          <source>In a start tag in place of an attribute name/value pair</source>
          <target state="translated">在起始标签中,代替属性名/值对。</target>
        </trans-unit>
        <trans-unit id="f96457239ad16229e782b00e8a11ce292869f998" translate="yes" xml:space="preserve">
          <source>In a traditional web application stack, where the server renders HTML one page at a time, the URL is the fundamental entry point for the user to access the application. Users navigate an application by clicking through URLs, which are sent to the server via HTTP, and the server responds appropriately via a server-side router.</source>
          <target state="translated">在传统的Web应用栈中,服务器每次只渲染一个HTML页面,URL是用户访问应用的基本入口。用户通过点击URL来浏览应用,URL通过HTTP发送到服务器,服务器通过服务器端路由器做出相应的响应。</target>
        </trans-unit>
        <trans-unit id="a98f067a3014e1e496902f925c40364c5fb35573" translate="yes" xml:space="preserve">
          <source>In a traditional, HTTP-based web application, the client and server communicate in a &amp;ldquo;request-response&amp;rdquo; fashion. Typically the client makes RESTful HTTP requests to the server and receives HTML or JSON data in response, and there&amp;rsquo;s no way for the server to &amp;ldquo;push&amp;rdquo; data to the client when changes happen at the backend.</source>
          <target state="translated">在基于HTTP的传统Web应用程序中，客户端和服务器以&amp;ldquo;请求-响应&amp;rdquo;方式进行通信。通常，客户端向服务器发出RESTful HTTP请求，并作为响应接收HTML或JSON数据，并且当后端发生更改时，服务器无法将数据&amp;ldquo;推送&amp;rdquo;到客户端。</target>
        </trans-unit>
        <trans-unit id="c0aad52585bc81d3838aafeaa544382c0c5c06fb" translate="yes" xml:space="preserve">
          <source>In a web application, &lt;em&gt;routing&lt;/em&gt; is the process of using URLs to drive the user interface (UI). URLs are a prominent feature in every single web browser, and have several main functions from the user&amp;rsquo;s point of view:</source>
          <target state="translated">在Web应用程序中，&lt;em&gt;路由&lt;/em&gt;是使用URL驱动用户界面（UI）的过程。URL是每个Web浏览器中的突出功能，从用户的角度来看，URL具有几个主要功能：</target>
        </trans-unit>
        <trans-unit id="24fc6d3a11f7f9ee64e5bc4614dce9e9f93e6b25" translate="yes" xml:space="preserve">
          <source>In addition to CSS pre-processors like Sass, Less, and Stylus, there is now an ecosystem of CSS post-processors. Regardless of which CSS pre-processor you use, a post-processor can give you additional benefits like cross-browser compatibility.</source>
          <target state="translated">除了Sass、Less和Stylus等CSS预处理器之外,现在还有一个CSS后处理器的生态系统。无论你使用哪种CSS前处理器,后处理器都能给你带来额外的好处,比如跨浏览器兼容性。</target>
        </trans-unit>
        <trans-unit id="e5d55f16ffee4dd36dfbe342034bd8bbd049ead8" translate="yes" xml:space="preserve">
          <source>In addition to configuring the &lt;a href=&quot;email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s &lt;code&gt;MAIL_URL&lt;/code&gt;, it is critical that you set proper values (specifically the &lt;code&gt;from&lt;/code&gt; address) in &lt;a href=&quot;#Accounts-emailTemplates&quot;&gt;&lt;code&gt;Accounts.emailTemplates&lt;/code&gt;&lt;/a&gt; to ensure proper delivery of e-mails!</source>
          <target state="translated">除了配置的&lt;a href=&quot;email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt;包的 &lt;code&gt;MAIL_URL&lt;/code&gt; ，关键是你设置恰当的值（特别是 &lt;code&gt;from&lt;/code&gt; 地址）&lt;a href=&quot;#Accounts-emailTemplates&quot;&gt; &lt;code&gt;Accounts.emailTemplates&lt;/code&gt; &lt;/a&gt;确保电子邮件的正常发货！</target>
        </trans-unit>
        <trans-unit id="254e551511c3f0f235073f44d097d7a3b65e7068" translate="yes" xml:space="preserve">
          <source>In addition to having control over the templates, you&amp;rsquo;ll want to be able to control the routing and URLs for the different views offered by &lt;code&gt;useraccounts&lt;/code&gt;. Since Flow Router is the officially recommended routing option for Meteor, we&amp;rsquo;ll go over that in particular.</source>
          <target state="translated">除了可以控制模板之外，您还希望能够控制 &lt;code&gt;useraccounts&lt;/code&gt; 提供的不同视图的路由和URL 。由于流路由器是Meteor的官方推荐路由选项，因此我们将对其进行详细介绍。</target>
        </trans-unit>
        <trans-unit id="a9747d35b7695a04bf88b38e2c3d4145cdd4811e" translate="yes" xml:space="preserve">
          <source>In addition to identifying the user to your application, some services have APIs that allow you to take action on behalf of the user. To request specific permissions from the user, pass the &lt;code&gt;requestPermissions&lt;/code&gt; option the login function. This will cause the user to be presented with an additional page in the pop-up dialog to permit access to their data. The user&amp;rsquo;s &lt;code&gt;accessToken&lt;/code&gt; &amp;mdash; with permissions to access the service&amp;rsquo;s API &amp;mdash; is stored in the &lt;code&gt;services&lt;/code&gt; field of the user document. The supported values for &lt;code&gt;requestPermissions&lt;/code&gt; differ for each login service and are documented on their respective developer sites:</source>
          <target state="translated">除了识别您的应用程序用户外，某些服务还具有API，可让您代表用户采取措施。要向用户请求特定的权限，请将 &lt;code&gt;requestPermissions&lt;/code&gt; 选项传递给登录功能。这将使用户在弹出对话框中显示一个附加页面，以允许访问其数据。具有访问服务API权限的用户的 &lt;code&gt;accessToken&lt;/code&gt; 存储在用户文档的 &lt;code&gt;services&lt;/code&gt; 字段中。每个登录服务对 &lt;code&gt;requestPermissions&lt;/code&gt; 支持的值各不相同，并记录在其各自的开发人员站点上：</target>
        </trans-unit>
        <trans-unit id="1574ee753719b0815edfc480971fd438bb650e36" translate="yes" xml:space="preserve">
          <source>In addition to local scope and package scope, there are also package exports. A package export is a &amp;ldquo;pseudo global&amp;rdquo; variable that a package makes available for you to use when you install that package. For example, the &lt;code&gt;email&lt;/code&gt; package exports the &lt;code&gt;Email&lt;/code&gt; variable. If your app uses the &lt;code&gt;email&lt;/code&gt; package (and &lt;em&gt;only&lt;/em&gt; if it uses the &lt;code&gt;email&lt;/code&gt; package!) then your app can access the &lt;code&gt;Email&lt;/code&gt; symbol and you can call &lt;code&gt;Email.send&lt;/code&gt;. Most packages have only one export, but some packages might have two or three (for example, a package that provides several classes that work together).</source>
          <target state="translated">除了本地范围和包范围之外，还存在包导出。程序包导出是一个&amp;ldquo;伪全局&amp;rdquo;变量，在安装该程序包时，程序包可让您使用该变量。例如， &lt;code&gt;email&lt;/code&gt; 包导出 &lt;code&gt;Email&lt;/code&gt; 变量。如果您的应用程序使用 &lt;code&gt;email&lt;/code&gt; 程序包（并且&lt;em&gt;仅&lt;/em&gt;当它使用 &lt;code&gt;email&lt;/code&gt; 程序包！），则您的应用程序可以访问 &lt;code&gt;Email&lt;/code&gt; 符号，并且可以调用 &lt;code&gt;Email.send&lt;/code&gt; 。大多数软件包只有一个导出，但是某些软件包可能只有两个或三个（例如，一个提供多个可一起使用的类的软件包）。</target>
        </trans-unit>
        <trans-unit id="1b22a39f7adb1f27dfac47bb5fc5985a0ccd460d" translate="yes" xml:space="preserve">
          <source>In addition to methods like &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;helpers&lt;/code&gt;, documented as part of the &lt;a href=&quot;templates&quot;&gt;Template API&lt;/a&gt;, the following fields and methods are present on template objects:</source>
          <target state="translated">除了作为&lt;a href=&quot;templates&quot;&gt;模板API&lt;/a&gt;一部分记录的 &lt;code&gt;events&lt;/code&gt; 和 &lt;code&gt;helpers&lt;/code&gt; 之类的方法之外，模板对象还包含以下字段和方法：</target>
        </trans-unit>
        <trans-unit id="68d18296af0e1595ea377e4e8d2b91f86dd27900" translate="yes" xml:space="preserve">
          <source>In addition to passing in the parameters as arguments to the &lt;code&gt;action&lt;/code&gt; function on the route, Flow Router makes a variety of information available via (reactive and otherwise) functions on the global singleton &lt;code&gt;FlowRouter&lt;/code&gt;. As the user navigates around your app, the values of these functions will change (reactively in some cases) correspondingly.</source>
          <target state="translated">除了将参数作为参数传递给路线上的 &lt;code&gt;action&lt;/code&gt; 函数外，Flow Router还可以通过全局单例 &lt;code&gt;FlowRouter&lt;/code&gt; 上的（反应性和其他）函数提供各种信息。当用户浏览您的应用程序时，这些功能的值将相应地更改（在某些情况下为响应式）。</target>
        </trans-unit>
        <trans-unit id="500f0cdb093cfeb5c24e523d322cfcac89b9b21e" translate="yes" xml:space="preserve">
          <source>In addition to that core API, there are some helpful shorthand helpers: &lt;code&gt;Meteor.user()&lt;/code&gt;, which is exactly equal to calling &lt;code&gt;Meteor.users.findOne(Meteor.userId())&lt;/code&gt;, and the &lt;code&gt;{{currentUser}}&lt;/code&gt; Blaze helper that returns the value of &lt;code&gt;Meteor.user()&lt;/code&gt;.</source>
          <target state="translated">除了该核心API，还有一些有用的速记助手： &lt;code&gt;Meteor.user()&lt;/code&gt; ，它完全等同于调用 &lt;code&gt;Meteor.users.findOne(Meteor.userId())&lt;/code&gt; ，以及 &lt;code&gt;{{currentUser}}&lt;/code&gt; Blaze助手，它返回 &lt;code&gt;Meteor.user()&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="abfea8c8c422e9a121afa6d85247dfce6e983e55" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;jquery&lt;/code&gt; package, Meteor provides several jQuery plugins as separate packages. These include:</source>
          <target state="translated">除了 &lt;code&gt;jquery&lt;/code&gt; 包，Meteor还提供了几个jQuery插件作为单独的包。这些包括：</target>
        </trans-unit>
        <trans-unit id="dbea572dac37433068b62198ba9f8a2ada7605d1" translate="yes" xml:space="preserve">
          <source>In addition to the domain whitelisting mechanism Cordova implements, the web view itself may also enforce access rules through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;. For now, Meteor adds a permissive &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;...&quot;&lt;/code&gt; header to the generated index page. We may want to allow more fine grained control in the future (through integrating with the &lt;code&gt;browser-policy&lt;/code&gt; package for instance.)</source>
          <target state="translated">除了Cordova实现的域白名单机制外，Web视图本身还可以通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;内容安全策略（CSP）&lt;/a&gt;强制执行访问规则。目前，Meteor将允许的 &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;...&quot;&lt;/code&gt; 标头添加到生成的索引页面。我们将来可能希望允许进行更精细的控制（例如，通过与 &lt;code&gt;browser-policy&lt;/code&gt; 包集成）。</target>
        </trans-unit>
        <trans-unit id="97782f3129575db978a071a5286f076d635aebf7" translate="yes" xml:space="preserve">
          <source>In addition to the properties and functions described below, you can assign additional properties of your choice to the object. Use the &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;onCreated&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt;&lt;code&gt;onDestroyed&lt;/code&gt;&lt;/a&gt; methods to add callbacks performing initialization or clean-up on the object.</source>
          <target state="translated">除了下面描述的属性和功能，您还可以将所选的其他属性分配给对象。使用&lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;onCreated&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;templates#Template-onDestroyed&quot;&gt; &lt;code&gt;onDestroyed&lt;/code&gt; &lt;/a&gt;方法添加对对象执行初始化或清除的回调。</target>
        </trans-unit>
        <trans-unit id="8ced6cb3cd6aec9aa26ccbe5e79042362fb90a7e" translate="yes" xml:space="preserve">
          <source>In addition, Spacebars will call functions for you, so &lt;code&gt;{{foo.bar}}&lt;/code&gt; may be taken to mean &lt;code&gt;foo().bar&lt;/code&gt;, &lt;code&gt;foo.bar()&lt;/code&gt;, or &lt;code&gt;foo().bar()&lt;/code&gt; as appropriate.</source>
          <target state="translated">另外，空格键将为您调用函数，因此 &lt;code&gt;{{foo.bar}}&lt;/code&gt; 可以视情况表示 &lt;code&gt;foo().bar&lt;/code&gt; ， &lt;code&gt;foo.bar()&lt;/code&gt; 或 &lt;code&gt;foo().bar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7297153e2ff4678269802ad1c25087b6ec8655f3" translate="yes" xml:space="preserve">
          <source>In addition, packages can include a different set of files for Cordova builds and browser builds with &lt;code&gt;addFiles&lt;/code&gt;:</source>
          <target state="translated">此外，程序包可以包含用于Cordova构建和带有 &lt;code&gt;addFiles&lt;/code&gt; 的浏览器构建的不同文件集：</target>
        </trans-unit>
        <trans-unit id="41cd2029bccb8ae22ec89e0f770c614fb7bce861" translate="yes" xml:space="preserve">
          <source>In addition, you will need to configure the server with the right connection address. This happens automatically if you&amp;rsquo;re using &lt;code&gt;meteor deploy&lt;/code&gt; to deploy to Galaxy, but when deploying to your own server you&amp;rsquo;ll have to make sure to define the &lt;code&gt;ROOT_URL&lt;/code&gt; environment variable there. (For Meteor Up, you can configure this in &lt;code&gt;mup.json&lt;/code&gt;.)</source>
          <target state="translated">此外，您将需要使用正确的连接地址配置服务器。如果您使用 &lt;code&gt;meteor deploy&lt;/code&gt; 来部署到Galaxy，这会自动发生，但是当部署到您自己的服务器时，您必须确保在那里定义 &lt;code&gt;ROOT_URL&lt;/code&gt; 环境变量。（对于Meteor Up，您可以在 &lt;code&gt;mup.json&lt;/code&gt; 中进行配置。）</target>
        </trans-unit>
        <trans-unit id="eb8a4c4b4c418aa05a1ae3ff4b909a7ae6d8876e" translate="yes" xml:space="preserve">
          <source>In all of our examples so far (outside of using&lt;code&gt;Meteor.publishComposite()&lt;/code&gt;) we&amp;rsquo;ve returned a cursor from our &lt;code&gt;Meteor.publish()&lt;/code&gt; handlers. Doing this ensures Meteor takes care of the job of keeping the contents of that cursor in sync between the server and the client. However, there&amp;rsquo;s another API you can use for publish functions which is closer to the way the underlying Distributed Data Protocol (DDP) works.</source>
          <target state="translated">到目前为止，在所有示例中（除了使用 &lt;code&gt;Meteor.publishComposite()&lt;/code&gt; 之外），我们都从 &lt;code&gt;Meteor.publish()&lt;/code&gt; 处理程序中返回了一个游标。这样做可以确保Meteor负责使该游标的内容在服务器和客户端之间保持同步。但是，还有另一个API可用于发布功能，该API与基础分布式数据协议（DDP）的工作方式更为接近。</target>
        </trans-unit>
        <trans-unit id="5ad38b740358ecdcc878fd6eb3a2e8783e86430d" translate="yes" xml:space="preserve">
          <source>In all three Meteor supported CSS pre-processors you can import other style files from both relative and absolute paths in your app and from both npm and Meteor Atmosphere packages.</source>
          <target state="translated">在所有三个Meteor支持的CSS预处理器中,你可以从你的应用程序中的相对路径和绝对路径以及npm和Meteor Atmosphere包中导入其他样式文件。</target>
        </trans-unit>
        <trans-unit id="f2bff92a3d08447c1ef56770839a28f6a7e97560" translate="yes" xml:space="preserve">
          <source>In an attribute value</source>
          <target state="translated">在一个属性值中</target>
        </trans-unit>
        <trans-unit id="074ffbf148764d68cdccba5f19c1fa7e4961aeda" translate="yes" xml:space="preserve">
          <source>In an infinite scroll publication, we simply need to add a new argument to our publication controlling how many items to load. Suppose we wanted to paginate the todo items in our Todos example app:</source>
          <target state="translated">在一个无限滚动的出版物中,我们只需要在出版物中添加一个新的参数,控制要加载多少个项目。假设我们想在Todos示例应用程序中对todo项目进行分页。</target>
        </trans-unit>
        <trans-unit id="28a83f5f63dd43cc115d0989bd09aaa92f50fa30" translate="yes" xml:space="preserve">
          <source>In another:</source>
          <target state="translated">在另一个:</target>
        </trans-unit>
        <trans-unit id="d62204bc13f389fb789a0a84468b26acf3fc21a5" translate="yes" xml:space="preserve">
          <source>In case of duplicate identification keys, all duplicates after the first are replaced with random ones. Using objects with unique &lt;code&gt;_id&lt;/code&gt; fields is the way to get full control over the identity of rendered elements.</source>
          <target state="translated">如果有重复的识别码，则将第一个之后的所有重复替换为随机的。使用具有唯一 &lt;code&gt;_id&lt;/code&gt; 字段的对象是完全控制渲染元素的身份的方法。</target>
        </trans-unit>
        <trans-unit id="8bb2df7708ffc61dea83f8fcc495f70389246c5d" translate="yes" xml:space="preserve">
          <source>In contrast to Meteor packages, you&amp;rsquo;ll have to specify the exact version of the plugin. This can be a bit of a pain because you first need to look up what the most recent &lt;a href=&quot;#plugin-compatibility&quot;&gt;(compatible)&lt;/a&gt; version of a plugin is before you can add it.</source>
          <target state="translated">与Meteor软件包相比，您必须指定插件的确切版本。这可能会有些麻烦，因为您首先需要查找插件的最新&lt;a href=&quot;#plugin-compatibility&quot;&gt;（兼容）&lt;/a&gt;版本，然后才能添加它。</target>
        </trans-unit>
        <trans-unit id="c5fb8709a2f0ca1acce23efe04cf7b9227338776" translate="yes" xml:space="preserve">
          <source>In contrast, Meteor operates on the principle of &lt;em&gt;data on the wire&lt;/em&gt;, where the server doesn&amp;rsquo;t think in terms of URLs or HTML pages. The client application communicates with the server over DDP. Typically as an application loads, it initializes a series of &lt;em&gt;subscriptions&lt;/em&gt; which fetch the data required to render the application. As the user interacts with the application, different subscriptions may load, but there&amp;rsquo;s no technical need for URLs to be involved in this process - you could easily have a Meteor app where the URL never changes.</source>
          <target state="translated">相比之下，Meteor的运行原理是&lt;em&gt;基于网络上的数据&lt;/em&gt;原理，其中服务器不考虑URL或HTML页面。客户端应用程序通过DDP与服务器通信。通常，在应用程序加载时，它会初始化一系列&lt;em&gt;订阅&lt;/em&gt;，这些&lt;em&gt;订阅&lt;/em&gt;将获取呈现应用程序所需的数据。当用户与应用程序交互时，可能会加载不同的订阅，但是在此过程中不需要URL涉及技术-您很容易拥有一个Meteor应用程序，其中URL永远不会改变。</target>
        </trans-unit>
        <trans-unit id="a75d46c699ae9dcb32de4c2902e36e65a7323ed6" translate="yes" xml:space="preserve">
          <source>In development, this can be accomplished with &lt;code&gt;meteor run --port &amp;lt;port&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在开发中，可以使用 &lt;code&gt;meteor run --port &amp;lt;port&amp;gt;&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="41f2552ffb3316d00522fa03c0d672bd44ebc89c" translate="yes" xml:space="preserve">
          <source>In development, this can be accomplished with &lt;code&gt;meteor run --port a.b.c.d:port&lt;/code&gt;.</source>
          <target state="translated">在开发中，可以使用 &lt;code&gt;meteor run --port a.b.c.d:port&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="1547e45443ffc5fb4eacd479e6a27ffff9f59035" translate="yes" xml:space="preserve">
          <source>In development, this is accomplished with &lt;code&gt;meteor --settings [file.json]&lt;/code&gt; in order to provide full-reactivity when changing settings. Those settings are simply passed as a string here. Please see the &lt;a href=&quot;http://docs.meteor.com/api/core.html#Meteor-settings&quot;&gt;Meteor.settings&lt;/a&gt; documentation for further information.</source>
          <target state="translated">在开发中，这是通过 &lt;code&gt;meteor --settings [file.json]&lt;/code&gt; ，以便在更改设置时提供完全的反应性。这些设置仅在此处作为字符串传递。请参阅&lt;a href=&quot;http://docs.meteor.com/api/core.html#Meteor-settings&quot;&gt;Meteor.settings&lt;/a&gt;文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="66eed1452b660a96e4920e5e5fc7876625a51627" translate="yes" xml:space="preserve">
          <source>In fact, the default export is conceptually just another named export whose name happens to be &amp;ldquo;default&amp;rdquo;:</source>
          <target state="translated">实际上，默认导出在概念上只是另一个命名导出，其名称恰好是&amp;ldquo;默认&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="ffee380bed7d956f4542c972231b70e87958b38a" translate="yes" xml:space="preserve">
          <source>In general if you want to store arbitrary serializable data in a URL param, you can use &lt;a href=&quot;http://docs.meteor.com/#/full/ejson_stringify&quot;&gt;&lt;code&gt;EJSON.stringify()&lt;/code&gt;&lt;/a&gt; to turn it into a string. You&amp;rsquo;ll need to URL-encode the string using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent&quot;&gt;&lt;code&gt;encodeURIComponent&lt;/code&gt;&lt;/a&gt; to remove any characters that have meaning in a URL:</source>
          <target state="translated">通常，如果要在URL参数中存储任意可序列化的数据，则可以使用&lt;a href=&quot;http://docs.meteor.com/#/full/ejson_stringify&quot;&gt; &lt;code&gt;EJSON.stringify()&lt;/code&gt; &lt;/a&gt;将其转换为字符串。您需要使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent&quot;&gt; &lt;code&gt;encodeURIComponent&lt;/code&gt; &lt;/a&gt;对字符串进行URL编码，以删除URL中所有有意义的字符：</target>
        </trans-unit>
        <trans-unit id="42f56562317830f4b12417573fd1f24084b5a994" translate="yes" xml:space="preserve">
          <source>In general, you must specify a package's version (e.g., &lt;code&gt;'accounts@1.0.0'&lt;/code&gt; to use version 1.0.0 or a higher compatible version (ex: 1.0.1, 1.5.0, etc.) of the &lt;code&gt;accounts&lt;/code&gt; package). If you are sourcing core packages from a Meteor release with &lt;code&gt;versionsFrom&lt;/code&gt;, you may leave off version names for core packages. You may also specify constraints, such as &lt;code&gt;my:forms@=1.0.0&lt;/code&gt; (this package demands &lt;code&gt;my:forms&lt;/code&gt; at &lt;code&gt;1.0.0&lt;/code&gt; exactly), or &lt;code&gt;my:forms@1.0.0 || =2.0.1&lt;/code&gt; (&lt;code&gt;my:forms&lt;/code&gt; at &lt;code&gt;1.x.y&lt;/code&gt;, or exactly &lt;code&gt;2.0.1&lt;/code&gt;).</source>
          <target state="translated">通常，您必须指定软件包的版本（例如， &lt;code&gt;'accounts@1.0.0'&lt;/code&gt; 以使用1.0.0或更高版本的 &lt;code&gt;accounts&lt;/code&gt; 软件包的兼容版本（例如：1.0.1、1.5.0等））。如果你是从一个流星发布与采购核心包 &lt;code&gt;versionsFrom&lt;/code&gt; ，您还可以关闭核心包版本名称。您也可以指定约束，例如 &lt;code&gt;my:forms@=1.0.0&lt;/code&gt; （此程序包要求 &lt;code&gt;my:forms&lt;/code&gt; 的精确值为 &lt;code&gt;1.0.0&lt;/code&gt; ）或 &lt;code&gt;my:forms@1.0.0 || =2.0.1&lt;/code&gt; （ &lt;code&gt;my:forms&lt;/code&gt; 为 &lt;code&gt;1.x.y&lt;/code&gt; 或正好为 &lt;code&gt;2.0.1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d90a3412a3c35ae0d4d9a00f5337fa36394e6a1a" translate="yes" xml:space="preserve">
          <source>In most cases, simply wrapping the callback in &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; will do the trick. This function both wraps the callback in a fiber, and does some work to maintain Meteor&amp;rsquo;s server-side environment tracking. Here&amp;rsquo;s the same code with &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt;:</source>
          <target state="translated">在大多数情况下，只需将回调包装在 &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; 中即可。此函数既将回调包装在光纤中，又做了一些工作来维护Meteor的服务器端环境跟踪。这是与 &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; 相同的代码：</target>
        </trans-unit>
        <trans-unit id="876ee006558850d6ced23a44b1f6767aa8a1f893" translate="yes" xml:space="preserve">
          <source>In most normal situations, API keys from your settings file will only be used by the server, and by default the data passed in through &lt;code&gt;--settings&lt;/code&gt; is only available on the server. However, if you put data under a special key called &lt;code&gt;public&lt;/code&gt;, it will be available on the client. You might want to do this if, for example, you need to make an API call from the client and are OK with users knowing that key. Public settings will be available on the client under &lt;code&gt;Meteor.settings.public&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下，设置文件中的API密钥仅由服务器使用，默认情况下，通过 &lt;code&gt;--settings&lt;/code&gt; 传递的数据仅在服务器上可用。但是，如果将数据放在名为 &lt;code&gt;public&lt;/code&gt; 的特殊密钥下，则它将在客户端上可用。例如，如果您需要从客户端进行API调用并且对知道该密钥的用户满意，则可能需要执行此操作。公共设置将在客户端的 &lt;code&gt;Meteor.settings.public&lt;/code&gt; 下可用。</target>
        </trans-unit>
        <trans-unit id="ac5b0f3dd6a9204e7e6fe1a3b2ae8988622aecc7" translate="yes" xml:space="preserve">
          <source>In most ways, testing a Meteor app is no different from testing any other full stack JavaScript application. However, compared to more traditional backend or front-end focused frameworks, two factors can make testing a little more challenging:</source>
          <target state="translated">在大多数情况下,测试Meteor应用与测试任何其他全栈JavaScript应用没有什么不同。然而,与更多传统的后端或前端关注的框架相比,有两个因素会使测试更具挑战性。</target>
        </trans-unit>
        <trans-unit id="9c552c52bc3f3ce110f62879e28d7c812aa8fd7f" translate="yes" xml:space="preserve">
          <source>In one terminal, we can do:</source>
          <target state="translated">在一个终端,我们可以做到。</target>
        </trans-unit>
        <trans-unit id="95183e67e9e7b925ce0590a932667601e3ee8abe" translate="yes" xml:space="preserve">
          <source>In order for Galaxy to work with your custom domain (&lt;code&gt;your-app.com&lt;/code&gt; in this case), you need to &lt;a href=&quot;http://galaxy-guide.meteor.com/dns.html&quot;&gt;set up your DNS to point at Galaxy&lt;/a&gt;. Once you&amp;rsquo;ve done this, you should be able to reach your site from a browser.</source>
          <target state="translated">为了使Galaxy与您的自定义域（在本例中为 &lt;code&gt;your-app.com&lt;/code&gt; ）一起使用，您需要&lt;a href=&quot;http://galaxy-guide.meteor.com/dns.html&quot;&gt;设置DNS以指向Galaxy&lt;/a&gt;。完成此操作后，您应该可以从浏览器访问您的网站。</target>
        </trans-unit>
        <trans-unit id="af11932b55bf47cb987fa62abbddfc787b349037" translate="yes" xml:space="preserve">
          <source>In order to avoid a situation where JavaScript code that relies on changed native code is pushed to a client, we calculate a compatibility version hash from the Cordova platform and plugin versions, and only download a new version to a device when there is an exact match. This means any change to the list of plugins, or updating to a Meteor release which contains a new platform version, will block hot code push to existing mobile clients until the app has been updated from the store.</source>
          <target state="translated">为了避免出现依赖更改后的原生代码的JavaScript代码推送到客户端的情况,我们从Cordova平台和插件版本中计算出一个兼容性版本哈希,只有在完全匹配的情况下才会下载新版本到设备上。这意味着对插件列表的任何更改,或者更新到包含新平台版本的Meteor版本,都会阻止热代码推送到现有的移动客户端,直到应用从商店更新。</target>
        </trans-unit>
        <trans-unit id="1095541060de9f532b046fdedba0debfabec44ba" translate="yes" xml:space="preserve">
          <source>In order to build and run Android apps, you will need to:</source>
          <target state="translated">为了构建和运行Android应用,你需要。</target>
        </trans-unit>
        <trans-unit id="3f944e5599ea66b86050615b4a5b09a0f9cfeda5" translate="yes" xml:space="preserve">
          <source>In order to build and run iOS apps, you will need a Mac with &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Apple Xcode&lt;/a&gt; developer tools installed. We recommend installing the latest version, but you should also check the &lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/History.md&quot;&gt;Meteor history&lt;/a&gt; for any specific version dependencies.</source>
          <target state="translated">为了构建和运行iOS应用，您将需要一台装有&lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Apple Xcode&lt;/a&gt;开发人员工具的Mac 。我们建议您安装最新版本，但是您还应该检查&lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/History.md&quot;&gt;Meteor历史记录中&lt;/a&gt;是否存在任何特定的版本依赖性。</target>
        </trans-unit>
        <trans-unit id="a134fe859a2d1d915a31aa217a1d22162302e6d8" translate="yes" xml:space="preserve">
          <source>In order to build and run mobile apps, you will need to install some prerequisites on your local machine.</source>
          <target state="translated">为了构建和运行移动应用,你需要在本地机器上安装一些先决条件。</target>
        </trans-unit>
        <trans-unit id="37933940fd10fbe726076dfb20016532e832ce79" translate="yes" xml:space="preserve">
          <source>In order to build your app for Android, you will need to &lt;a href=&quot;#configuring-your-app&quot;&gt;configure your app&lt;/a&gt; with at least a version number, and the required set of app icons and launch screens.</source>
          <target state="translated">为了构建适用于Android的应用，您将需要使用至少一个版本号以及所需的一组应用图标和启动屏幕来&lt;a href=&quot;#configuring-your-app&quot;&gt;配置您的应用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b038d1d31a2ea430908a2ca9ebb59b5ffa98c6f" translate="yes" xml:space="preserve">
          <source>In order to build your app for iOS, you will need to &lt;a href=&quot;#configuring-your-app&quot;&gt;configure your app&lt;/a&gt; with at least a version number, and the required set of app icons and launch screens.</source>
          <target state="translated">为了构建适用于iOS的应用，您将需要使用至少一个版本号以及所需的一组应用图标和启动屏幕来&lt;a href=&quot;#configuring-your-app&quot;&gt;配置您的应用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3695f6f0f1be90a7e86fa13c1a10465a121552f0" translate="yes" xml:space="preserve">
          <source>In order to check that a user has installed the correct versions of npm packages, you can use the &lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt;&lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt;&lt;/a&gt; package to check dependency versions at runtime.</source>
          <target state="translated">为了检查用户是否已安装正确版本的npm软件包，可以使用&lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt; &lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt; &lt;/a&gt;软件包在运行时检查依赖项版本。</target>
        </trans-unit>
        <trans-unit id="ecd270745296cda593c6978ffc2b9a281c12001c" translate="yes" xml:space="preserve">
          <source>In order to deploy to Galaxy, you&amp;rsquo;ll need to &lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;sign up for an account&lt;/a&gt;, and separately provision a MongoDB database (see below).</source>
          <target state="translated">为了部署到Galaxy，您需要&lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;注册一个帐户&lt;/a&gt;，并单独设置一个MongoDB数据库（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="0100e88f1f4d191fc64f05211f5fbbd8cbbe0092" translate="yes" xml:space="preserve">
          <source>In order to ensure your component always gets the data you expect, you should validate the data context provided to it. This is just like validating the arguments to any Meteor Method or publication, and lets you write your validation code in one place and then assume that the data is correct.</source>
          <target state="translated">为了确保你的组件总是得到你期望的数据,你应该验证提供给它的数据上下文。这就像验证任何Meteor Method或出版物的参数一样,让你在一个地方写下你的验证代码,然后假设数据是正确的。</target>
        </trans-unit>
        <trans-unit id="d396d4b652641df47632e7daa1a2b6d5f306e7e0" translate="yes" xml:space="preserve">
          <source>In order to help with this, we pin core plugins to a minimum version known to work with the Cordova versions we bundle. This mechanism doesn&amp;rsquo;t apply to third-party plugins however, so you&amp;rsquo;ll have to assess compatibility for these yourself.</source>
          <target state="translated">为了解决这个问题，我们将核心插件固定到了与我们捆绑的Cordova版本一起使用的最低版本。但是，该机制不适用于第三方插件，因此您必须自己评估它们的兼容性。</target>
        </trans-unit>
        <trans-unit id="a3dadd58446c260ec034cda6418866472bcdac4a" translate="yes" xml:space="preserve">
          <source>In our example of the list page from the Todos app, we access the current list&amp;rsquo;s id with &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; (we&amp;rsquo;ll see more on this below).</source>
          <target state="translated">在Todos应用程序的列表页面示例中，我们使用 &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; 访问当前列表的ID （我们将在下文中详细介绍）。</target>
        </trans-unit>
        <trans-unit id="110a9d1509fc3777c243276d40bda42245df81e5" translate="yes" xml:space="preserve">
          <source>In our example, the &lt;code&gt;autorun&lt;/code&gt; will re-run whenever &lt;code&gt;this.getListId()&lt;/code&gt; changes, (ultimately because &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; changes), although other common reactive data sources are:</source>
          <target state="translated">在我们的示例中，只要 &lt;code&gt;this.getListId()&lt;/code&gt; 发生更改（最终是因为 &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; 发生更改）， &lt;code&gt;autorun&lt;/code&gt; 就会重新运行，尽管其他常见的响应数据源是：</target>
        </trans-unit>
        <trans-unit id="5f1118f050e1e527ba90635c862b4ac7a0be8bb1" translate="yes" xml:space="preserve">
          <source>In practice, this means that you should do most of your security and validation on the boundary between these two domains. In simple terms:</source>
          <target state="translated">在实践中,这意味着你应该在这两个领域的边界上进行大部分的安全和验证。简单来说,就是</target>
        </trans-unit>
        <trans-unit id="ff8362e76f2b5492fce7b9ccc1912bcccbafff6a" translate="yes" xml:space="preserve">
          <source>In production</source>
          <target state="translated">生产中</target>
        </trans-unit>
        <trans-unit id="6e9d0b9bac3c9016a8172bf03b65fdc616968da2" translate="yes" xml:space="preserve">
          <source>In regular JavaScript functions, you indicate errors by throwing an &lt;code&gt;Error&lt;/code&gt; object. Throwing errors from Meteor Methods works almost the same way, but a bit of complexity is introduced by the fact that in some cases the error object will be sent over a websocket back to the client.</source>
          <target state="translated">在常规JavaScript函数中，您可以通过抛出 &lt;code&gt;Error&lt;/code&gt; 对象来指示错误。流星方法引发错误的方式几乎相同，但是由于在某些情况下错误对象将通过WebSocket发送回客户端而引入了一些复杂性。</target>
        </trans-unit>
        <trans-unit id="86362326c255302320a86c160f4f23716a23fa60" translate="yes" xml:space="preserve">
          <source>In some cases you want to change routes based on user action outside of them clicking on a link. For instance, in the example app, when a user creates a new list, we want to route them to the list they just created. We do this by calling &lt;code&gt;FlowRouter.go()&lt;/code&gt; once we know the id of the new list:</source>
          <target state="translated">在某些情况下，您想根据用户之外的用户操作来更改路由，请单击链接。例如，在示例应用程序中，当用户创建新列表时，我们希望将其路由到他们刚刚创建的列表。我们 &lt;code&gt;FlowRouter.go()&lt;/code&gt; 知道新列表的ID，就可以通过调用FlowRouter.go（）来实现：</target>
        </trans-unit>
        <trans-unit id="3755ced3aa531457993ff464095e1613a41daeb3" translate="yes" xml:space="preserve">
          <source>In summary, you should make sure that any options passed from the client to a publication can only restrict the data being requested, rather than extending it.</source>
          <target state="translated">总之,你应该确保从客户端传递给出版物的任何选项只能限制被请求的数据,而不是扩展数据。</target>
        </trans-unit>
        <trans-unit id="154b7f812990909b655a30ced949019ea3ec45aa" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#simple-blaze-unit-test&quot;&gt;unit tests above&lt;/a&gt; we saw a very limited example of how to isolate a module from the larger app. This is critical for proper unit testing. Some other utilities and techniques include:</source>
          <target state="translated">在&lt;a href=&quot;#simple-blaze-unit-test&quot;&gt;上面&lt;/a&gt;的单元测试中，我们看到了一个非常有限的示例，说明如何将模块与较大的应用程序隔离。这对于正确的单元测试至关重要。其他实用程序和技术包括：</target>
        </trans-unit>
        <trans-unit id="cd03cba6f3f4c87ab484dc96fbf5f9080dd290da" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;data-loading#pagination&quot;&gt;Data Loading article&lt;/a&gt; we discuss a pattern of paging through an &amp;ldquo;infinite scroll&amp;rdquo; type subscription which loads one page of data at a time as a user scrolls down the page. It&amp;rsquo;s interesting to consider UX patterns to consume that data and indicate what&amp;rsquo;s happening to the user.</source>
          <target state="translated">在&amp;ldquo; &lt;a href=&quot;data-loading#pagination&quot;&gt;数据加载&amp;rdquo;文章中，&lt;/a&gt;我们讨论了通过&amp;ldquo;无限滚动&amp;rdquo;类型订阅进行分页的模式，该订阅在用户向下滚动页面时一次加载一页数据。考虑UX模式以使用该数据并指示用户正在发生的事情很有趣。</target>
        </trans-unit>
        <trans-unit id="c5b5f38a9dbced09959afc33d982e81d4214f9a8" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, thanks to the fact that we&amp;rsquo;ve split our User Interface into &lt;a href=&quot;ui-ux#components&quot;&gt;smart and reusable components&lt;/a&gt;, it&amp;rsquo;s natural to want to unit test some of our reusable components (we&amp;rsquo;ll see below how to &lt;a href=&quot;#simple-integration-test&quot;&gt;integration test&lt;/a&gt; our smart components).</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt;示例应用程序中，由于我们已经将用户界面划分为&lt;a href=&quot;ui-ux#components&quot;&gt;智能和可重用的组件&lt;/a&gt;，因此自然要对我们的一些可重用组件进行单元测试（我们将在下面看到如何对智能组件进行&lt;a href=&quot;#simple-integration-test&quot;&gt;集成测试&lt;/a&gt;） 。</target>
        </trans-unit>
        <trans-unit id="aa2f9ac4ae09c3a6a03e519716500e4f30a23748" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, we define a factory to describe how to create a test todo item, using the &lt;a href=&quot;https://www.npmjs.com/package/faker&quot;&gt;&lt;code&gt;faker&lt;/code&gt;&lt;/a&gt; npm package:</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt;示例应用程序中，我们定义了一个工厂来描述如何使用&lt;a href=&quot;https://www.npmjs.com/package/faker&quot;&gt; &lt;code&gt;faker&lt;/code&gt; &lt;/a&gt; npm包创建测试待办事项：</target>
        </trans-unit>
        <trans-unit id="0cd10266ce18083c8c52cb5aae9c7eb32c70b16e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, we have an integration test for the &lt;code&gt;Lists_show_page&lt;/code&gt; smart component. This test simply ensures that when the correct data is present in the database, the template renders correctly &amp;ndash; that it is gathering the correct data as we expect. It isolates the rendering tree from the more complex data subscription part of the Meteor stack. If we wanted to test that the subscription side of things was working in concert with the smart component, we&amp;rsquo;d need to write a &lt;a href=&quot;#full-app-integration-test&quot;&gt;full app integration test&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt;示例应用程序中，我们对 &lt;code&gt;Lists_show_page&lt;/code&gt; 智能组件进行了集成测试。该测试只是确保当数据库中存在正确的数据时，模板会正确呈现&amp;ndash;可以按照我们的预期收集正确的数据。它将渲染树与Meteor堆栈中较复杂的数据订阅部分隔离开来。如果我们想测试事物的订阅方面是否与智能组件协同工作，则需要编写一个&lt;a href=&quot;#full-app-integration-test&quot;&gt;完整的应用程序集成测试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00b754fe9ced1dfd5206ceba80b40b057cf765f1" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example application, we have a integration test which ensures that we see the full contents of a list when we route to it, which demonstrates a few techniques of integration tests.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt;示例应用程序中，我们有一个集成测试，可确保在路由到列表时能看到列表的完整内容，其中展示了一些集成测试技术。</target>
        </trans-unit>
        <trans-unit id="cd1c9fe855dd52330c81745b2eaa8b6d9a48a31b" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we already have a wrapping component for the list that talks to the router and sets up subscriptions. This component could easily be extended to understand pagination:</source>
          <target state="translated">在Todos示例应用中,我们已经有了一个与路由器对话并设置订阅的列表包装组件。这个组件可以很容易地扩展到理解分页。</target>
        </trans-unit>
        <trans-unit id="4152f7ff0a1d8b4927f75d321cc1bc0eaf345b9f" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we build a &lt;code&gt;incompleteCountDenormalizer&lt;/code&gt; to abstract the counting of incomplete todos on the lists. This code needs to run whenever a todo item is inserted, updated (checked or unchecked), or removed. The code looks like:</source>
          <target state="translated">在Todos示例应用程序中，我们构建了一个 &lt;code&gt;incompleteCountDenormalizer&lt;/code&gt; 来抽象列表上未完成的待办事项的计数。每当待办事项被插入，更新（选中或取消选中）或删除时，都需要运行此代码。代码如下：</target>
        </trans-unit>
        <trans-unit id="bfb04dea501399ed95b413d52e56102a16943eb7" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we have done this, and you can now access our publications over HTTP:</source>
          <target state="translated">在Todos示例应用中,我们已经做到了这一点,现在你可以通过HTTP访问我们的出版物。</target>
        </trans-unit>
        <trans-unit id="d9a2d1d927f8a3f86168a8233f485d3e147994c6" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we link to each list the user knows about in the &lt;code&gt;App_body&lt;/code&gt; template:</source>
          <target state="translated">在Todos示例应用程序中，我们链接到 &lt;code&gt;App_body&lt;/code&gt; 模板中用户知道的每个列表：</target>
        </trans-unit>
        <trans-unit id="5942975a97800cdf89c874bcbc7a658118e21a15" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we use the following code to set a basic rate limit on all Methods:</source>
          <target state="translated">在Todos示例应用中,我们使用以下代码对所有Methods设置基本速率限制。</target>
        </trans-unit>
        <trans-unit id="4841073ceb3cd7cc3a48b756092ed6f3b5674ad0" translate="yes" xml:space="preserve">
          <source>In the below example, your &lt;code&gt;App&lt;/code&gt; component would receive a &lt;code&gt;main&lt;/code&gt; prop with a instantiated React Element to render:</source>
          <target state="translated">在以下示例中，您的 &lt;code&gt;App&lt;/code&gt; 组件将收到一个带有实例化React元素的 &lt;code&gt;main&lt;/code&gt; prop来呈现：</target>
        </trans-unit>
        <trans-unit id="6b7dd1cd09ae0021104564795bd86664a9639f40" translate="yes" xml:space="preserve">
          <source>In the body of a callback, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;templates#Template-instances&quot;&gt;template instance&lt;/a&gt; object that is unique to this occurrence of the template and persists across re-renderings. Use the &lt;code&gt;onCreated&lt;/code&gt; and &lt;code&gt;onDestroyed&lt;/code&gt; callbacks to perform initialization or clean-up on the object.</source>
          <target state="translated">在回调的主体中， &lt;code&gt;this&lt;/code&gt; 是一个&lt;a href=&quot;templates#Template-instances&quot;&gt;模板实例&lt;/a&gt;对象，对于模板的这种出现是唯一的，并且在重新渲染期间一直存在。使用 &lt;code&gt;onCreated&lt;/code&gt; 和 &lt;code&gt;onDestroyed&lt;/code&gt; 回调对对象执行初始化或清理。</target>
        </trans-unit>
        <trans-unit id="ffcf96e7bef4cc2550b3b4637a1fe80e204eb39e" translate="yes" xml:space="preserve">
          <source>In the case of a logged-out user, we explicitly call &lt;code&gt;this.ready()&lt;/code&gt;, which indicates to the subscription that we&amp;rsquo;ve sent all the data we are initially going to send (in this case none). It&amp;rsquo;s important to know that if you don&amp;rsquo;t return a cursor from the publication or call &lt;code&gt;this.ready()&lt;/code&gt;, the user&amp;rsquo;s subscription will never become ready, and they will likely see a loading state forever.</source>
          <target state="translated">对于注销用户，我们显式调用 &lt;code&gt;this.ready()&lt;/code&gt; ，这向预订指示已发送了我们最初要发送的所有数据（在本例中为无）。重要的是要知道，如果您不从发布中返回游标或调用 &lt;code&gt;this.ready()&lt;/code&gt; ，则用户的订阅将永远不会就绪，并且他们可能永远看到加载状态。</target>
        </trans-unit>
        <trans-unit id="0ea6c2e2f7dd4b5ca26ce085b335adebe1937488" translate="yes" xml:space="preserve">
          <source>In the case of the Todos application, as we want to display the number of unfinished todos next to each list, we need to denormalize &lt;code&gt;list.incompleteTodoCount&lt;/code&gt;. This is an inconvenience but typically reasonably easy to do as we&amp;rsquo;ll see in the section on &lt;a href=&quot;#abstracting-denormalizers&quot;&gt;abstracting denormalizers&lt;/a&gt; below.</source>
          <target state="translated">对于Todos应用程序，由于我们要在每个列表旁边显示未完成的 &lt;code&gt;list.incompleteTodoCount&lt;/code&gt; 的数量，因此需要对list.incompleteTodoCount进行规范化。这是一个不便，但通常相当容易实现，正如我们在下面的&lt;a href=&quot;#abstracting-denormalizers&quot;&gt;抽象非规范化器&lt;/a&gt;部分中所见。</target>
        </trans-unit>
        <trans-unit id="2957437af76604980e751ea1c401963d86da16c9" translate="yes" xml:space="preserve">
          <source>In the context of a Blaze helper, &lt;code&gt;this&lt;/code&gt; is scoped to the current &lt;em&gt;data context&lt;/em&gt; at the point the helper was used. This can be hard to reason about, so it&amp;rsquo;s often a good idea to instead pass the required data into the helper as an argument (as we do here).</source>
          <target state="translated">在Blaze助手的上下文中， &lt;code&gt;this&lt;/code&gt; 范围仅限于使用助手时的当前&lt;em&gt;数据上下文&lt;/em&gt;。这可能很难推理，因此，通常最好将所需的数据作为参数传递给助手（如我们在此处所做的那样）。</target>
        </trans-unit>
        <trans-unit id="3b111aa7d6dfce20fe48e45474489a66532dcdc1" translate="yes" xml:space="preserve">
          <source>In the distant past, it could have been a huge headache to get Facebook or Google login to work with your app. Thankfully, most popular login providers have standardized around some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt;, and Meteor supports some of the most popular login services out of the box.</source>
          <target state="translated">在遥远的过去，让Facebook或Google登录以与您的应用一起使用可能会非常麻烦。值得庆幸的是，大多数流行的登录提供程序已经围绕&lt;a href=&quot;https://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth的&lt;/a&gt;某些版本进行了标准化，Meteor支持一些现成的流行登录服务。</target>
        </trans-unit>
        <trans-unit id="6f7a04de97df1a0989d9427322890dd7af2c9f4c" translate="yes" xml:space="preserve">
          <source>In the event that a platform does not offer the ability to configure this, the &lt;code&gt;force-ssl&lt;/code&gt; package can be added to the project and Meteor will attempt to intelligently redirect based on the presence of the &lt;code&gt;x-forwarded-for&lt;/code&gt; header.</source>
          <target state="translated">如果平台不提供配置功能，可以将 &lt;code&gt;force-ssl&lt;/code&gt; 程序包添加到项目中，并且Meteor将基于 &lt;code&gt;x-forwarded-for&lt;/code&gt; 标头的存在尝试进行智能重定向。</target>
        </trans-unit>
        <trans-unit id="33d609ba9ea9ec0778a93a11d4f1c75031af9649" translate="yes" xml:space="preserve">
          <source>In the event that your own deployment platform does not support WebSockets, or you are confident that you will not benefit from them, setting this variable with &lt;code&gt;DISABLE_WEBSOCKETS=1&lt;/code&gt; will explicitly disable WebSockets and forcibly resort to the fallback polling-mechanism, instead of trying to detect this automatically.</source>
          <target state="translated">如果您自己的部署平台不支持WebSockets，或者您有信心无法从中受益，则将此变量设置为 &lt;code&gt;DISABLE_WEBSOCKETS=1&lt;/code&gt; 将会显式禁用WebSockets并强制采用后备轮询机制，而不是尝试自动检测到。</target>
        </trans-unit>
        <trans-unit id="62250cb451baa040e8183f5601b89d20569053a3" translate="yes" xml:space="preserve">
          <source>In the example app we are using the Flow Router integration with great success. Some of the later sections will cover how to customize the routes and templates to fit your app better.</source>
          <target state="translated">在示例应用中,我们使用Flow Router集成取得了巨大成功。后面的一些章节将介绍如何定制路由和模板以更好地适应您的应用程序。</target>
        </trans-unit>
        <trans-unit id="5b67d1d86027f5daf65368d7edbca35a1db90b62" translate="yes" xml:space="preserve">
          <source>In the first example, if the &lt;code&gt;userId&lt;/code&gt; property on the selected list changes, the query in the publication will still return the data, since the security check in the beginning will not re-run. In the second example, we have fixed this by putting the security check in the returned query itself.</source>
          <target state="translated">在第一个示例中，如果所选列表上的 &lt;code&gt;userId&lt;/code&gt; 属性发生更改，则发布中的查询仍将返回数据，因为开头的安全检查将不会重新运行。在第二个示例中，我们通过将安全检查放入返回的查询本身中来解决此问题。</target>
        </trans-unit>
        <trans-unit id="1b19d3f92a4202469b135b88552d3ccf5b0864af" translate="yes" xml:space="preserve">
          <source>In the future, when client reconnection is fully implemented, reconnecting from the client will reconnect to the same connection on the server: the &lt;code&gt;onConnection&lt;/code&gt; callback won&amp;rsquo;t be called for that connection again, and the connection will still have the same connection &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">将来，当完全实现客户端重新连接后，与客户端的重新连接将重新连接到服务器上的同一连接：不再为该连接调用 &lt;code&gt;onConnection&lt;/code&gt; 回调，并且该连接仍将具有相同的连接 &lt;code&gt;id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9935b768ce988e3fa5cad7fddb5e2f8b66952ab" translate="yes" xml:space="preserve">
          <source>In the list above, we didn&amp;rsquo;t cover the case when the Method execution on the server throws an error. In that case, there is no return value, and the client gets an error instead. The Method callback is fired instantly with the returned error as the first argument. Read more about error handling in the section about errors below.</source>
          <target state="translated">在上面的列表中，我们没有涉及服务器上的Method执行抛出错误的情况。在这种情况下，没有返回值，而是客户端得到一个错误。立即使用返回的错误作为第一个参数触发Method回调。在下面有关错误的部分中阅读有关错误处理的更多信息。</target>
        </trans-unit>
        <trans-unit id="08a6a394474dbaf7a6999d26e3c837991da10f65" translate="yes" xml:space="preserve">
          <source>In the project navigator, choose your device from the Scheme toolbar menu:</source>
          <target state="translated">在项目导航仪中,从Scheme工具条菜单中选择你的设备。</target>
        </trans-unit>
        <trans-unit id="fff13c41f7cc356bf8785f787e833dcf881ee7a6" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll look closely at how collections work in various places in the framework, and how to get the most out of them.</source>
          <target state="translated">在本文中，我们将仔细研究集合在框架中各个位置的工作方式，以及如何充分利用它们。</target>
        </trans-unit>
        <trans-unit id="cd5c057a73f061460bb50cfe06d78bddf617379c" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll refer to the elements in your user interface as &amp;ldquo;components&amp;rdquo;. Although in some systems, you may refer to them as &amp;ldquo;templates&amp;rdquo;, it can be a good idea to think of them as something more like a component, which has an API and internal logic, rather than a template, which is just a bit of HTML.</source>
          <target state="translated">在本文中，我们将用户界面中的元素称为&amp;ldquo;组件&amp;rdquo;。尽管在某些系统中，您可以将它们称为&amp;ldquo;模板&amp;rdquo;，但最好将它们视为类似于具有API和内部逻辑的组件，而不是仅是一点点的模板。 HTML。</target>
        </trans-unit>
        <trans-unit id="16a951a354967b9d301d65d18b65670a937d2ddd" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll use the popular &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt; test runner alongside the &lt;a href=&quot;http://chaijs.com&quot;&gt;Chai&lt;/a&gt; assertion library to test our application. In order to write and run tests in Mocha, we need to add an appropriate test driver package.</source>
          <target state="translated">在本文中，我们将使用流行的&lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt;测试运行程序以及&lt;a href=&quot;http://chaijs.com&quot;&gt;Chai&lt;/a&gt;断言库来测试我们的应用程序。为了在Mocha中编写和运行测试，我们需要添加适当的测试驱动程序包。</target>
        </trans-unit>
        <trans-unit id="9f2c4aaa02e0b2ab31096746b667315ca3412515" translate="yes" xml:space="preserve">
          <source>In this case, as the list is valid according to the schema, the &lt;code&gt;validate()&lt;/code&gt; line will run without problems. If however, we wrote:</source>
          <target state="translated">在这种情况下，由于列表根据架构是有效的，因此 &lt;code&gt;validate()&lt;/code&gt; 行将毫无问题地运行。但是，如果我们写了：</target>
        </trans-unit>
        <trans-unit id="393960455a77603119555fd413f34cc2ee704b29" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;TodoItem&lt;/code&gt; component calls a &lt;a href=&quot;methods&quot;&gt;Meteor Method&lt;/a&gt;&lt;code&gt;setCheckedStatus&lt;/code&gt; when the user clicks, but this is a unit test so there&amp;rsquo;s no server running. So we stub it out using &lt;a href=&quot;http://sinonjs.org&quot;&gt;Sinon&lt;/a&gt;. After we simulate the click, we verify that the stub was called with the correct arguments. Finally, we clean up the stub and restore the original method behavior.</source>
          <target state="translated">在这种情况下，当用户单击时 &lt;code&gt;TodoItem&lt;/code&gt; 组件将调用&lt;a href=&quot;methods&quot;&gt;Meteor方法&lt;/a&gt; &lt;code&gt;setCheckedStatus&lt;/code&gt; ，但这是一个单元测试，因此没有服务器在运行。因此，我们使用&lt;a href=&quot;http://sinonjs.org&quot;&gt;Sinon&lt;/a&gt;对其进行了存根。模拟点击之后，我们验证是否已使用正确的参数调用了存根。最后，我们清理存根并恢复原始方法的行为。</target>
        </trans-unit>
        <trans-unit id="c130ef79a970932453defcdf9be810ff472f64f6" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;subComponent&lt;/code&gt; component can expect a data context of the form:</source>
          <target state="translated">在这种情况下， &lt;code&gt;subComponent&lt;/code&gt; 组件可以期望以下形式的数据上下文：</target>
        </trans-unit>
        <trans-unit id="7dbfc0ef10c1c7ae3ee6d563b8dee191c69c394f" translate="yes" xml:space="preserve">
          <source>In this case, the HTML template for &lt;code&gt;Lists_show_page&lt;/code&gt; will look very simple, with most of the logic in the JavaScript code:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Lists_show_page&lt;/code&gt; 的HTML模板看起来非常简单，其中大多数逻辑都包含在JavaScript代码中：</target>
        </trans-unit>
        <trans-unit id="2f4075780b58b955e5015e6a2def734aa0c35b98" translate="yes" xml:space="preserve">
          <source>In this case, we want to use the &lt;code&gt;App_body&lt;/code&gt; layout template for all of the accounts-related pages. This template has a content region called &lt;code&gt;main&lt;/code&gt;. Now, let&amp;rsquo;s configure some routes:</source>
          <target state="translated">在这种情况下，我们要对所有与帐户相关的页面使用 &lt;code&gt;App_body&lt;/code&gt; 布局模板。该模板具有一个名为 &lt;code&gt;main&lt;/code&gt; 的内容区域。现在，让我们配置一些路由：</target>
        </trans-unit>
        <trans-unit id="d7bc90b15f112041a070fc1212f24c086eb6b5b1" translate="yes" xml:space="preserve">
          <source>In this code snippet we can see two important techniques for subscribing in Blaze templates:</source>
          <target state="translated">在这段代码中,我们可以看到Blaze模板中订阅的两个重要技术。</target>
        </trans-unit>
        <trans-unit id="0ae66971710dbb7005d0af5a6a72e160ea8c0491" translate="yes" xml:space="preserve">
          <source>In this example, the callback not only renders the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; element into the element with &lt;code&gt;id=&quot;app&quot;&lt;/code&gt;, but also appends any &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tag(s) generated during rendering to the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; of the response document.</source>
          <target state="translated">在此示例中，回调不仅将 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 元素呈现到具有 &lt;code&gt;id=&quot;app&quot;&lt;/code&gt; 的元素中，而且还将呈现过程中生成的任何 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签附加到响应文档的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="716caa47ae19a40f3022ec4e7676410324fb3962" translate="yes" xml:space="preserve">
          <source>In this example, the result of the &lt;code&gt;getSummary&lt;/code&gt; helper call will be passed to the &lt;code&gt;capitalize&lt;/code&gt; helper.</source>
          <target state="translated">在此示例中， &lt;code&gt;getSummary&lt;/code&gt; 帮助程序调用的结果将传递给 &lt;code&gt;capitalize&lt;/code&gt; 帮助程序。</target>
        </trans-unit>
        <trans-unit id="1a4426a50935ec09bf4a10ddc5e8ba5698c3c42b" translate="yes" xml:space="preserve">
          <source>In this example, we re-add the same files in the development mode to avoid unnecessary work and then we minify the files in production mode.</source>
          <target state="translated">在这个例子中,我们在开发模式下重新添加相同的文件,以避免不必要的工作,然后我们在生产模式下对文件进行最小化。</target>
        </trans-unit>
        <trans-unit id="50bb6fed7d0d7addafa71c7a00eb5d4ba619fc11" translate="yes" xml:space="preserve">
          <source>In this example, we register a linter that runs on all &lt;code&gt;js&lt;/code&gt; files and also reads a file named &lt;code&gt;.linterrc&lt;/code&gt; to get a configuration.</source>
          <target state="translated">在此示例中，我们注册了一个在所有 &lt;code&gt;js&lt;/code&gt; 文件上运行的 &lt;code&gt;.linterrc&lt;/code&gt; ，并且还读取了一个名为.linterrc的文件以获取配置。</target>
        </trans-unit>
        <trans-unit id="859031e359200cd0a3abc91fa2cc21ac074c5a50" translate="yes" xml:space="preserve">
          <source>In this example, we write a complicated query to make sure that we only ever find a list if we are allowed to see it, then, once per list we find (which can be one or zero times depending on access), we publish the todos for that list. Publish Composite takes care of stopping and starting the dependent cursors if the list stops matching the original query or otherwise.</source>
          <target state="translated">在这个例子中,我们写了一个复杂的查询,以确保只有在允许我们查看的情况下才能找到一个列表,然后,我们对每个找到的列表发布一次(根据访问权限,可以是一次或零次),发布该列表的todos。如果列表停止匹配原始查询或其他情况,发布复合负责停止和启动依赖的光标。</target>
        </trans-unit>
        <trans-unit id="f4f9fc4939653780350ebd47e5cbc74147faad2c" translate="yes" xml:space="preserve">
          <source>In this guide article, we will go over some important points for building packages, but we won&amp;rsquo;t explain every part of the &lt;code&gt;package.js&lt;/code&gt; API. To learn about all of the options, &lt;a href=&quot;http://docs.meteor.com/#/full/packagejs&quot;&gt;read about the &lt;code&gt;package.js&lt;/code&gt; API in the Meteor docs.&lt;/a&gt;</source>
          <target state="translated">在本指南文章中，我们将介绍构建软件包的一些重要点，但是我们不会解释 &lt;code&gt;package.js&lt;/code&gt; API的每个部分。要了解所有选项，请&lt;a href=&quot;http://docs.meteor.com/#/full/packagejs&quot;&gt;阅读Meteor文档中的 &lt;code&gt;package.js&lt;/code&gt; API。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de40712f96ccbc5878832b3c65a8203bb4e6f428" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;re going to take a strong position that using &lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt;allow&lt;/a&gt; or &lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt;deny&lt;/a&gt; to run MongoDB queries directly from the client is not a good idea. The main reason is that it is hard to follow the principles outlined above. It&amp;rsquo;s extremely difficult to validate the complete space of possible MongoDB operators, which could potentially grow over time with new versions of MongoDB.</source>
          <target state="translated">在本指南中，我们将采取强有力的立场，即直接使用&lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt;允许&lt;/a&gt;或&lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt;拒绝&lt;/a&gt;从客户端运行MongoDB查询不是一个好主意。主要原因是很难遵循上述原则。验证可能的MongoDB操作员的完整空间非常困难，而随着新版本的MongoDB的使用，该空间可能会随着时间增长。</target>
        </trans-unit>
        <trans-unit id="44715bbc86bdfa46a48d2ab0256fd8059347cf7f" translate="yes" xml:space="preserve">
          <source>In this publication, which loads private lists, we need to use &lt;code&gt;this.userId&lt;/code&gt; to get only the todo lists that belong to a specific user.</source>
          <target state="translated">在加载私有列表的此出版物中，我们需要使用 &lt;code&gt;this.userId&lt;/code&gt; 仅获取属于特定用户的待办事项列表。</target>
        </trans-unit>
        <trans-unit id="ef6286f6d925f3eea0fa1f1d8e182daba9569288" translate="yes" xml:space="preserve">
          <source>In this release, Minimongo has some limitations:</source>
          <target state="translated">在这个版本中,Minimongo有一些限制。</target>
        </trans-unit>
        <trans-unit id="a84400a9a251f4df3aa4777ac358a066646f489e" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll consider a publication/subscription technique for the second, infinite-scroll style pagination. The page-by-page technique is a little tricker to handle in Meteor, due to it being difficult to calculate the offset on the client. If you need to do so, you can follow many of the same techniques that we use here and use the &lt;a href=&quot;https://atmospherejs.com/percolate/find-from-publication&quot;&gt;&lt;code&gt;percolate:find-from-publication&lt;/code&gt;&lt;/a&gt; package to keep track of which records have come from your publication.</source>
          <target state="translated">在本节中，我们将考虑第二种无限滚动样式分页的发布/订阅技术。由于很难在客户端上计算偏移量，因此逐页技术在Meteor中处理起来有些麻烦。如果需要这样做，您可以遵循此处使用的许多相同技术，并使用&lt;a href=&quot;https://atmospherejs.com/percolate/find-from-publication&quot;&gt; &lt;code&gt;percolate:find-from-publication&lt;/code&gt; &lt;/a&gt;包来跟踪来自您出版物的记录。</target>
        </trans-unit>
        <trans-unit id="8bee80ec74e593fd4cc58d070cd4ef3b4a1765ff" translate="yes" xml:space="preserve">
          <source>In this test, we used &lt;a href=&quot;#test-data&quot;&gt;Factory package&amp;rsquo;s&lt;/a&gt;&lt;code&gt;.create()&lt;/code&gt; API, which inserts data into the real collection. However, as we&amp;rsquo;ve proxied all of the &lt;code&gt;Todos&lt;/code&gt; and &lt;code&gt;Lists&lt;/code&gt; collection methods onto a local collection (this is what &lt;code&gt;hwillson:stub-collections&lt;/code&gt; is doing), we won&amp;rsquo;t run into any problems with trying to perform inserts from the client.</source>
          <target state="translated">在此测试中，我们使用了&lt;a href=&quot;#test-data&quot;&gt;Factory程序包的&lt;/a&gt; &lt;code&gt;.create()&lt;/code&gt; API，它将数据插入到实际集合中。但是，由于我们已将所有 &lt;code&gt;Todos&lt;/code&gt; 和 &lt;code&gt;Lists&lt;/code&gt; 集合方法代理到本地集合中（这是 &lt;code&gt;hwillson:stub-collections&lt;/code&gt; 所做的事情），因此尝试从客户端执行插入操作不会遇到任何问题。</target>
        </trans-unit>
        <trans-unit id="48d58d96176f8e5734d6d01f807e05aa18aa8373" translate="yes" xml:space="preserve">
          <source>In web application deployment it&amp;rsquo;s common to refer to three runtime environments:</source>
          <target state="translated">在Web应用程序部署中，通常引用三个运行时环境：</target>
        </trans-unit>
        <trans-unit id="b2138449e1b676a59c755a472878c39768fd1e0f" translate="yes" xml:space="preserve">
          <source>In your app&amp;rsquo;s JavaScript code, these settings can be accessed from the variable &lt;code&gt;Meteor.settings&lt;/code&gt;.</source>
          <target state="translated">在应用程序的JavaScript代码中，可以从变量 &lt;code&gt;Meteor.settings&lt;/code&gt; 访问这些设置。</target>
        </trans-unit>
        <trans-unit id="e633340302cf126d7622043227bbf7e61f4c15a2" translate="yes" xml:space="preserve">
          <source>In your build plugin source, register a Compiler Plugin: similar to other types of build plugins, provide the details, extensions and filenames and a factory function that returns an instance of the compiler. Ex.:</source>
          <target state="translated">在你的构建插件源码中,注册一个编译器插件:与其他类型的构建插件类似,提供细节、扩展名和文件名,以及一个返回编译器实例的工厂函数。例子..:</target>
        </trans-unit>
        <trans-unit id="3f85d67d9b9661cee48fb29e5de7a1a5f4cec087" translate="yes" xml:space="preserve">
          <source>In your build plugin source, register a Minifier Plugin. Similar to Linter and Compiler plugin, specify the interested extensions (&lt;code&gt;css&lt;/code&gt; or &lt;code&gt;js&lt;/code&gt;). The factory function returns an instance of the minifier class.</source>
          <target state="translated">在您的构建插件源中，注册一个Minifier插件。与Linter和Compiler插件类似，请指定感兴趣的扩展名（ &lt;code&gt;css&lt;/code&gt; 或 &lt;code&gt;js&lt;/code&gt; ）。工厂函数返回minifier类的实例。</target>
        </trans-unit>
        <trans-unit id="aa16ac7e9796342ae5c54d13d0d2ac8301db0349" translate="yes" xml:space="preserve">
          <source>In your build plugin sources, register a Linter Plugin: provide details such as a name, list of extensions and filenames the plugin will handle and a factory function that returns an instance of a linter class. Example:</source>
          <target state="translated">在你的构建插件源中,注册一个Linter插件:提供诸如名称、插件将处理的扩展名和文件名列表以及返回一个Linter类实例的工厂函数等细节。例子:在你的构建插件源中,注册一个Linter插件:提供详细的名称、扩展名和文件名列表以及插件将处理的文件和返回linter类实例的工厂函数。</target>
        </trans-unit>
        <trans-unit id="a58097e9eae38a2a6d42be2241a68bd3fda8cbc6" translate="yes" xml:space="preserve">
          <source>Include &lt;a href=&quot;build-tool#compiles-with-build-plugins&quot;&gt;build plugins&lt;/a&gt; for Meteor&amp;rsquo;s build system</source>
          <target state="translated">包括用于Meteor构建系统的&lt;a href=&quot;build-tool#compiles-with-build-plugins&quot;&gt;构建插件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353db2b05370e2628bf6610a4bfbf0cb7679c248" translate="yes" xml:space="preserve">
          <source>Include Cordova plugins in your Meteor package by using &lt;a href=&quot;http://docs.meteor.com/#/full/Cordova-depends&quot;&gt;Cordova.depends&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;http://docs.meteor.com/#/full/Cordova-depends&quot;&gt;Cordova.depends&lt;/a&gt;在您的Meteor包中包含Cordova插件。</target>
        </trans-unit>
        <trans-unit id="cf0025e3001017ccd9edf1af6b727b14f2db3276" translate="yes" xml:space="preserve">
          <source>Include pre-built binary code for different server architectures, such as Linux or Windows</source>
          <target state="translated">包括不同服务器架构的预建二进制代码,如Linux或Windows。</target>
        </trans-unit>
        <trans-unit id="773d8fcfde1c62ca678d7fe259059da2812244f7" translate="yes" xml:space="preserve">
          <source>Including in your app</source>
          <target state="translated">包括在您的应用程序中</target>
        </trans-unit>
        <trans-unit id="f8afa7df51d1a363c6b3729a5966a161fa6e983c" translate="yes" xml:space="preserve">
          <source>Inclusion Tags</source>
          <target state="translated">纳入标签</target>
        </trans-unit>
        <trans-unit id="06f64eb2109c825d33e153e4148dc6e13c959ff4" translate="yes" xml:space="preserve">
          <source>Inclusion and Block Arguments</source>
          <target state="translated">包含和块状论据</target>
        </trans-unit>
        <trans-unit id="45280beec399004106474e535f46d0fdcb55635d" translate="yes" xml:space="preserve">
          <source>Inclusion tags (&lt;code&gt;{{&amp;gt; foo}}&lt;/code&gt;) and block tags (&lt;code&gt;{{#foo}}&lt;/code&gt;) take a single data argument, or no argument. Any other form of arguments will be interpreted as an &lt;em&gt;object specification&lt;/em&gt; or a &lt;em&gt;nested helper&lt;/em&gt;:</source>
          <target state="translated">包含标记（ &lt;code&gt;{{&amp;gt; foo}}&lt;/code&gt; ）和块标记（ &lt;code&gt;{{#foo}}&lt;/code&gt; ）仅包含一个数据参数，也可以不包含任何参数。任何其他形式的参数将被解释为&lt;em&gt;对象规范&lt;/em&gt;或&lt;em&gt;嵌套帮助器&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="5e78a5cfb1db22808629144956804fa8cb9908bc" translate="yes" xml:space="preserve">
          <source>Indents objects and arrays for easy readability. When &lt;code&gt;true&lt;/code&gt;, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.</source>
          <target state="translated">缩进对象和数组以便于阅读。如果为 &lt;code&gt;true&lt;/code&gt; ，则缩进2个空格；当整数时，缩进该数量的空格；当是字符串时，使用该字符串作为缩进模式。</target>
        </trans-unit>
        <trans-unit id="37850cb533f69eb02117841a8a5cd87c07aa7199" translate="yes" xml:space="preserve">
          <source>Indexing the current data context. The identifier &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;foo&lt;/code&gt; property of the current data context object.</source>
          <target state="translated">索引当前数据上下文。标识符 &lt;code&gt;foo&lt;/code&gt; 引用当前数据上下文对象的 &lt;code&gt;foo&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="368c35c76c4ede42543dc12e7427a7453d231d69" translate="yes" xml:space="preserve">
          <source>Indicating when a write is in progress</source>
          <target state="translated">表示何时正在进行写入</target>
        </trans-unit>
        <trans-unit id="7b691a16e23a6ebb1c523c417f5ba56e56eebeb3" translate="yes" xml:space="preserve">
          <source>Initially loading, no data available yet.</source>
          <target state="translated">刚开始加载,还没有数据。</target>
        </trans-unit>
        <trans-unit id="614d878a15a0519edf83c79deb485104433bc31a" translate="yes" xml:space="preserve">
          <source>Insert a document in the collection. Returns its unique _id.</source>
          <target state="translated">在集合中插入一个文档。返回其唯一的_id。</target>
        </trans-unit>
        <trans-unit id="ecd13ed03842fb804f904a59d3e0dfdb0ae55e5c" translate="yes" xml:space="preserve">
          <source>Inside UIWebViews (when your app is loaded inside a mobile app)</source>
          <target state="translated">在UIWebViews内(当您的应用程序在移动应用程序内加载时)。</target>
        </trans-unit>
        <trans-unit id="2780ace99845806a4b862b4386e7617dfccfeb59" translate="yes" xml:space="preserve">
          <source>Inside a Method execution on the server, calling another Method runs that Method as if it were called by the same client. That means the Method runs as usual, and the context - &lt;code&gt;userId&lt;/code&gt;, &lt;code&gt;connection&lt;/code&gt;, etc - are taken from the original Method call.</source>
          <target state="translated">在服务器上的方法执行内部，调用另一个方法将运行该方法，就像该方法是由同一客户端调用一样。这意味着Method照常运行，并且上下文 &lt;code&gt;userId&lt;/code&gt; ， &lt;code&gt;connection&lt;/code&gt; 等-是从原始Method调用中获取的。</target>
        </trans-unit>
        <trans-unit id="360e39954fe7e4bf71ce5be7e6215592b14b0bff" translate="yes" xml:space="preserve">
          <source>Inside a build plugin source file specified in &lt;a href=&quot;#Package-registerBuildPlugin&quot;&gt;Package.registerBuildPlugin&lt;/a&gt;, add a handler to compile files with a certain file extension.</source>
          <target state="translated">在&lt;a href=&quot;#Package-registerBuildPlugin&quot;&gt;Package.registerBuildPlugin中&lt;/a&gt;指定的构建插件源文件中，添加处理程序以编译具有特定文件扩展名的文件。</target>
        </trans-unit>
        <trans-unit id="3de6c7e92d33543486b90a5646cd0b72fe77b438" translate="yes" xml:space="preserve">
          <source>Inside a client-side Method simulation, calling another Method doesn&amp;rsquo;t fire off an extra request to the server - the assumption is that the server-side implementation of the Method will do it. However, it does run the &lt;em&gt;simulation&lt;/em&gt; of the called Method, so that the simulation on the client closely matches what will happen on the server.</source>
          <target state="translated">在客户端方法模拟中，调用另一个方法不会向服务器发出额外的请求-假设方法的服务器端实现可以做到。但是，它运行&lt;em&gt;仿真&lt;/em&gt;所调用的方法，使客户端上的仿真紧密匹配将在服务器上发生了什么。</target>
        </trans-unit>
        <trans-unit id="e489fd661adfe67fc2a7cd7c6480dd5e88240d6d" translate="yes" xml:space="preserve">
          <source>Inside a helper, returns the data context of the DOM node where the helper was used.</source>
          <target state="translated">在助记器内部,返回使用助记器的DOM节点的数据上下文。</target>
        </trans-unit>
        <trans-unit id="e29b20f0936432bd21e9feaaf8c1f6dd5c68634f" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;onCreated&lt;/code&gt;, &lt;code&gt;onRendered&lt;/code&gt;, or &lt;code&gt;onDestroyed&lt;/code&gt; callback, returns the data context of the template.</source>
          <target state="translated">在 &lt;code&gt;onCreated&lt;/code&gt; ， &lt;code&gt;onRendered&lt;/code&gt; 或 &lt;code&gt;onDestroyed&lt;/code&gt; 回调内部，返回模板的数据上下文。</target>
        </trans-unit>
        <trans-unit id="21fd895aa8247746bb75b6a2ecd0de8e4ea210e4" translate="yes" xml:space="preserve">
          <source>Inside an event handler, returns the data context of the template on which this event handler was defined.</source>
          <target state="translated">在事件处理程序中,返回定义该事件处理程序的模板的数据上下文。</target>
        </trans-unit>
        <trans-unit id="b5e254ddf3e1050b0794e3b4eeed21271b77c186" translate="yes" xml:space="preserve">
          <source>Inside the template&amp;rsquo;s HTML, you can use the built-in helper &lt;code&gt;Template.subscriptionsReady&lt;/code&gt;, which is an easy pattern for showing loading indicators in your templates when they depend on data loaded from subscriptions.</source>
          <target state="translated">在模板的HTML内，您可以使用内置的帮助器 &lt;code&gt;Template.subscriptionsReady&lt;/code&gt; ，这是一种简单的模式，用于在模板中依赖于从订阅加载的数据时显示加载指示符。</target>
        </trans-unit>
        <trans-unit id="09eb13722fb4946d0ab8516ad78e61b59fd40bd1" translate="yes" xml:space="preserve">
          <source>Install a Java Development Kit (JDK)</source>
          <target state="translated">安装一个Java开发工具包(JDK)。</target>
        </trans-unit>
        <trans-unit id="f3ced16a0c5123202e7015520c619a9d22b468bd" translate="yes" xml:space="preserve">
          <source>Install the Android SDK and download the required tools, platforms, and other components (which is done most easily by installing Android Studio)</source>
          <target state="translated">安装Android SDK,并下载所需的工具、平台和其他组件(通过安装Android Studio最容易完成)。</target>
        </trans-unit>
        <trans-unit id="76993e75d0ce1819da322a7383015f3dd8e33bc4" translate="yes" xml:space="preserve">
          <source>Installing Android Studio</source>
          <target state="translated">安装Android Studio</target>
        </trans-unit>
        <trans-unit id="89adbddd338a7b46a342e12a62babc5b6d68de4f" translate="yes" xml:space="preserve">
          <source>Installing Atmosphere Packages</source>
          <target state="translated">安装Atmosphere包</target>
        </trans-unit>
        <trans-unit id="a0d9b605309f5935493e4e274c41f140208085c9" translate="yes" xml:space="preserve">
          <source>Installing Xcode from the App Store</source>
          <target state="translated">从App Store安装Xcode</target>
        </trans-unit>
        <trans-unit id="ab9d4f985be9ceba61fa41d995398a2b136cd5ce" translate="yes" xml:space="preserve">
          <source>Installing a plugin from Git</source>
          <target state="translated">从Git安装插件</target>
        </trans-unit>
        <trans-unit id="24d517fefcb756696a14e1601f2278491fb55d21" translate="yes" xml:space="preserve">
          <source>Installing a plugin from the local file system</source>
          <target state="translated">从本地文件系统安装插件</target>
        </trans-unit>
        <trans-unit id="f5abeac6a79ab675fd8731f7c59fc53892ec0b01" translate="yes" xml:space="preserve">
          <source>Installing and running ESLint</source>
          <target state="translated">安装和运行ESLint</target>
        </trans-unit>
        <trans-unit id="79604a617bbef8796e8b97c478f8ebdb918d742a" translate="yes" xml:space="preserve">
          <source>Installing and using React</source>
          <target state="translated">安装和使用React</target>
        </trans-unit>
        <trans-unit id="880fa89fcd4a2214a9ac4718234c4b73084e8494" translate="yes" xml:space="preserve">
          <source>Installing npm Packages</source>
          <target state="translated">安装npm包</target>
        </trans-unit>
        <trans-unit id="bad94515f6d136d2603333a9eb3cf4a918bebd46" translate="yes" xml:space="preserve">
          <source>Installing plugins</source>
          <target state="translated">安装插件</target>
        </trans-unit>
        <trans-unit id="a847bfe09db07365fa859da9e751d802e54df632" translate="yes" xml:space="preserve">
          <source>Installing prerequisites</source>
          <target state="translated">安装先决条件</target>
        </trans-unit>
        <trans-unit id="4f3f1c71dba2241f80e748f3df6dbef5ea21fc96" translate="yes" xml:space="preserve">
          <source>Installing the Java Development Kit (JDK)</source>
          <target state="translated">安装Java开发工具包(JDK)</target>
        </trans-unit>
        <trans-unit id="de59f6df2a2743da46b4d8a4d279d928aa0f5fb2" translate="yes" xml:space="preserve">
          <source>Instance configurability &amp;ndash; Independently configure your CPU, memory, storage and disk I/O speed.</source>
          <target state="translated">实例可配置性&amp;ndash;独立配置CPU，内存，存储和磁盘I / O速度。</target>
        </trans-unit>
        <trans-unit id="0edae422dcff14cfcccca293a2d05091989c10a7" translate="yes" xml:space="preserve">
          <source>Instance size &amp;amp; options</source>
          <target state="translated">实例大小和选项</target>
        </trans-unit>
        <trans-unit id="2959b3a45b76563d6c8510666e6780446d2712e1" translate="yes" xml:space="preserve">
          <source>Instances of your type must implement &lt;a href=&quot;#ejson_type_typeName&quot;&gt;&lt;code&gt;typeName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; methods, and may implement &lt;a href=&quot;#ejson_type_clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ejson_type_equals&quot;&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/a&gt; methods if the default implementations are not sufficient.</source>
          <target state="translated">您类型的实例必须实现&lt;a href=&quot;#ejson_type_typeName&quot;&gt; &lt;code&gt;typeName&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt;方法，并且如果默认实现还不够，则可以实现&lt;a href=&quot;#ejson_type_clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ejson_type_equals&quot;&gt; &lt;code&gt;equals&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="baf7b528aae503023c9477df1c8b138d269a300a" translate="yes" xml:space="preserve">
          <source>Instead of modifying documents in the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection directly, use these convenience functions which correctly check for case insensitive duplicates before updates.</source>
          <target state="translated">使用这些便捷功能，而不是直接修改&lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt;集合中的文档，而是在更新之前正确检查不区分大小写的重复项。</target>
        </trans-unit>
        <trans-unit id="c66d0782f8ea038667dc5fb044a411f571689778" translate="yes" xml:space="preserve">
          <source>Instead of simply naming a template, an inclusion tag can also specify a path that evalutes to a template object, or to a function that returns a template object.</source>
          <target state="translated">不仅仅是简单地命名一个模板,一个包含标签还可以指定一个路径,该路径评估到一个模板对象,或者评估到一个返回模板对象的函数。</target>
        </trans-unit>
        <trans-unit id="a86f3bd3744743ae8ef66c864c95422fcc0d0c74" translate="yes" xml:space="preserve">
          <source>Instead of taking a single opaque &lt;code&gt;options&lt;/code&gt; parameter, a function can use an object destructuring pattern to name the expected options:</source>
          <target state="translated">函数可以采用对象分解模式来命名所需的选项，而不是采用单个不透明的 &lt;code&gt;options&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="40186957b76c782b5781708846b5c30d99db8ba9" translate="yes" xml:space="preserve">
          <source>Instead of using callbacks to notify you on changes, this is a &lt;a href=&quot;#reactivity&quot;&gt;reactive&lt;/a&gt; data source. You can use it in a &lt;a href=&quot;#livehtmltemplates&quot;&gt;template&lt;/a&gt; or &lt;a href=&quot;#tracker_autorun&quot;&gt;computation&lt;/a&gt; to get realtime updates.</source>
          <target state="translated">这不是&lt;a href=&quot;#reactivity&quot;&gt;反应式&lt;/a&gt;数据源，而不是使用回调通知您更改。您可以在&lt;a href=&quot;#livehtmltemplates&quot;&gt;模板&lt;/a&gt;或&lt;a href=&quot;#tracker_autorun&quot;&gt;计算中&lt;/a&gt;使用它来获取实时更新。</target>
        </trans-unit>
        <trans-unit id="dc2c1243a177f557f90c231e9d87723dfe2e42e7" translate="yes" xml:space="preserve">
          <source>Instead, Blaze gives you a way to scope a lookup to within the current template instance. Typically you use this either from a &lt;code&gt;onRendered()&lt;/code&gt; callback to setup jQuery plugins (called via &lt;code&gt;Template.instance().$()&lt;/code&gt; or &lt;code&gt;this.$()&lt;/code&gt;), or from event handlers to call DOM functions directly (called via &lt;code&gt;Template.instance().$()&lt;/code&gt; or using the event handler&amp;rsquo;s second argument like &lt;code&gt;instance.$()&lt;/code&gt;). For instance, when the user clicks the add todo button, we want to focus the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">取而代之的是，Blaze为您提供了一种将查询范围限定在当前模板实例内的方法。通常，您可以通过 &lt;code&gt;onRendered()&lt;/code&gt; 回调来设置jQuery插件（通过 &lt;code&gt;Template.instance().$()&lt;/code&gt; 或 &lt;code&gt;this.$()&lt;/code&gt; ），也可以从事件处理程序中直接使用DOM函数（通过 &lt;code&gt;Template.instance().$()&lt;/code&gt; 调用）（）。$（）或使用事件处理程序的第二个参数，例如 &lt;code&gt;instance.$()&lt;/code&gt; ）。例如，当用户单击添加待办事项按钮时，我们要关注 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素：</target>
        </trans-unit>
        <trans-unit id="4bb1cdd9084f3d40a8c11e0a82440bd526448b7f" translate="yes" xml:space="preserve">
          <source>Instead, you need to ask your users to install the correct npm packages in the application itself. This will ensure that only one copy of React is shipped to the client and there are no version conflicts.</source>
          <target state="translated">相反,你需要要求你的用户在应用程序本身中安装正确的npm包。这将确保只有一个React副本被运送到客户端,并且没有版本冲突。</target>
        </trans-unit>
        <trans-unit id="a9a80ab23d0834af074a4d02b121694639575834" translate="yes" xml:space="preserve">
          <source>Integrating with your editor</source>
          <target state="translated">与您的编辑器集成</target>
        </trans-unit>
        <trans-unit id="f48cb5c70273adca2f1ae065a022640d580c33cc" translate="yes" xml:space="preserve">
          <source>Integration testing</source>
          <target state="translated">集成测试</target>
        </trans-unit>
        <trans-unit id="7d8fc660207b21d44ff4e303a49e49321e5438fb" translate="yes" xml:space="preserve">
          <source>Internally, renderable content includes objects representing HTML tags as well, but these objects are not yet part of the officially-supported, public API.</source>
          <target state="translated">在内部,可渲染的内容也包括代表HTML标签的对象,但这些对象还不是官方支持的公共API的一部分。</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="72a68d6949dcd099bf168f39deca7ad5c3548f6f" translate="yes" xml:space="preserve">
          <source>Internationalization (i18n) is the process of generalizing the UI of your app in such a way that it&amp;rsquo;s easy to render all text in a different language. Meteor&amp;rsquo;s package ecosystem includes internationalization options tailored to your frontend framework of choice.</source>
          <target state="translated">国际化（i18n）是一种通用化应用程序UI的过程，可以轻松地以不同语言呈现所有文本。流星的软件包生态系统包括针对您选择的前端框架量身定制的国际化选项。</target>
        </trans-unit>
        <trans-unit id="c501914e1d7d2737a768eaeaa3672c88d11b8c6e" translate="yes" xml:space="preserve">
          <source>Introduced in Meteor 1.2</source>
          <target state="translated">在Meteor 1.2中引入</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3e3e50205a99a4864015c0d0c5651a5b41fdac00" translate="yes" xml:space="preserve">
          <source>Introduction to using &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 使用简介</target>
        </trans-unit>
        <trans-unit id="b3ddef764921d4e6c2d0ab06805638effe0f5673" translate="yes" xml:space="preserve">
          <source>Invalidate all dependent computations immediately and remove them as dependents.</source>
          <target state="translated">立即使所有依赖的计算无效,并将其作为依赖项删除。</target>
        </trans-unit>
        <trans-unit id="d640bfda5eaaaf39be21eab38996850e0410e44c" translate="yes" xml:space="preserve">
          <source>Invalidates this computation so that it will be rerun.</source>
          <target state="translated">使该计算无效,以便重新运行。</target>
        </trans-unit>
        <trans-unit id="4b6ad188d9c21e416b0517060e0d039d07ca3737" translate="yes" xml:space="preserve">
          <source>Invalidating a computation immediately calls all &lt;code&gt;onInvalidate&lt;/code&gt; callbacks registered on it. Invalidating a computation that is currently invalidated or is stopped has no effect. A computation can invalidate itself, but if it continues to do so indefinitely, the result will be an infinite loop.</source>
          <target state="translated">使计算无效将立即调用在其上注册的所有 &lt;code&gt;onInvalidate&lt;/code&gt; 回调。使当前无效或已停止的计算无效使无效。计算可以使自身无效，但是如果无限期地继续这样做，则结果将是无限循环。</target>
        </trans-unit>
        <trans-unit id="b7cc5b489d1e5691b3fc19d7e01449256c899855" translate="yes" xml:space="preserve">
          <source>Invalidating a computation marks it to be rerun at &lt;a href=&quot;#tracker_flush&quot;&gt;flush time&lt;/a&gt;, at which point the computation becomes valid again. It is rare to invalidate a computation manually, because reactive data sources invalidate their calling computations when they change. Reactive data sources in turn perform this invalidation using one or more &lt;a href=&quot;#tracker_dependency&quot;&gt;&lt;code&gt;Tracker.Dependency&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">使计算无效使它在&lt;a href=&quot;#tracker_flush&quot;&gt;刷新时间&lt;/a&gt;重新运行，这时计算再次变得有效。很少会手动使计算无效，因为反应性数据源在更改时会使其调用计算无效。反应性数据源又使用一个或多个&lt;a href=&quot;#tracker_dependency&quot;&gt; &lt;code&gt;Tracker.Dependency&lt;/code&gt; &lt;/a&gt;对象执行此无效操作。</target>
        </trans-unit>
        <trans-unit id="90203a1d90242066ba2a13f0f274b4953a7863af" translate="yes" xml:space="preserve">
          <source>Invalidating a computation sets its &lt;code&gt;invalidated&lt;/code&gt; property to true and immediately calls all of the computation&amp;rsquo;s &lt;code&gt;onInvalidate&lt;/code&gt; callbacks. When a flush occurs, if the computation has been invalidated and not stopped, then the computation is rerun by setting the &lt;code&gt;invalidated&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; and calling the original function that was passed to &lt;code&gt;Tracker.autorun&lt;/code&gt;. A flush will occur when the current code finishes running, or sooner if &lt;code&gt;Tracker.flush&lt;/code&gt; is called.</source>
          <target state="translated">使计算 &lt;code&gt;invalidated&lt;/code&gt; 它的invalidate属性设置为true，并立即调用该计算的所有 &lt;code&gt;onInvalidate&lt;/code&gt; 回调。发生刷新时，如果计算已经无效并且没有停止，那么可以通过将 &lt;code&gt;invalidated&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; 并调用传递给 &lt;code&gt;Tracker.autorun&lt;/code&gt; 的原始函数来重新运行计算。当前代码完成运行时将发生刷新，或者如果 &lt;code&gt;Tracker.flush&lt;/code&gt; 则更快。</target>
        </trans-unit>
        <trans-unit id="d7340978cf7ba632bc8aad9258c7944b2c1177cf" translate="yes" xml:space="preserve">
          <source>Invoke a method passing an array of arguments.</source>
          <target state="translated">调用一个传递参数数组的方法。</target>
        </trans-unit>
        <trans-unit id="8bdf537dabe796e64289ecdd6b26db4875334981" translate="yes" xml:space="preserve">
          <source>Invokes a method passing any number of arguments.</source>
          <target state="translated">调用一个传递任意数量参数的方法。</target>
        </trans-unit>
        <trans-unit id="1e3e33285679d56b5e1b8f73b6740557af585234" translate="yes" xml:space="preserve">
          <source>Ionic 1 uses Angular 1, but there are also &lt;a href=&quot;http://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt; and &lt;a href=&quot;http://reactionic.github.io/&quot;&gt;React&lt;/a&gt; ports.</source>
          <target state="translated">Ionic 1使用Angular 1，但也有&lt;a href=&quot;http://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt;和&lt;a href=&quot;http://reactionic.github.io/&quot;&gt;React&lt;/a&gt;端口。</target>
        </trans-unit>
        <trans-unit id="3922fe5889256f35ee95138293d959a16f809c18" translate="yes" xml:space="preserve">
          <source>Ionic 1 uses Angular 1, but there are also &lt;a href=&quot;https://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt; and &lt;a href=&quot;https://reactionic.github.io/&quot;&gt;React&lt;/a&gt; ports.</source>
          <target state="translated">Ionic 1使用Angular 1，但也有&lt;a href=&quot;https://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt;和&lt;a href=&quot;https://reactionic.github.io/&quot;&gt;React&lt;/a&gt;端口。</target>
        </trans-unit>
        <trans-unit id="4b9fc016d45806a5ed8dbb9aace5d48f53fd64ab" translate="yes" xml:space="preserve">
          <source>Iron Router</source>
          <target state="translated">铣铁机</target>
        </trans-unit>
        <trans-unit id="3639210fe06e16f98e387ab3259d91f9432684a2" translate="yes" xml:space="preserve">
          <source>Isobuild Feature Packages</source>
          <target state="translated">Isobuild功能包</target>
        </trans-unit>
        <trans-unit id="1ebcccc762c5c527531f6a2b87a1f54ab5a43a92" translate="yes" xml:space="preserve">
          <source>Isolation techniques</source>
          <target state="translated">技术绝缘</target>
        </trans-unit>
        <trans-unit id="418880ae80ca0c74fdd6999714deab185c18084d" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;does&lt;/strong&gt; eagerly load our application code as Meteor normally would.</source>
          <target state="translated">它&lt;strong&gt;确实&lt;/strong&gt;渴望像通常的Meteor一样加载我们的应用程序代码。</target>
        </trans-unit>
        <trans-unit id="43be4eab938bad7d8ccafe048fe0e4e2c9341169" translate="yes" xml:space="preserve">
          <source>It also needs to be responsive to reactive changes in the state of those actions (for instance if a todo changes due to the action of another user). All this data loading complexity is a typical use-case for a container-presentational component split, and the &lt;code&gt;withTracker&lt;/code&gt; function makes it simple to do this.</source>
          <target state="translated">它还需要对那些操作状态的反应性变化做出响应（例如，如果待办事项由于其他用户的操作而发生变化）。所有这些数据加载复杂性都是容器表示组件拆分的典型用例，并且 &lt;code&gt;withTracker&lt;/code&gt; 函数使此操作变得简单。</target>
        </trans-unit>
        <trans-unit id="1ca247c8d664df3369fff68c26a965ce58f48964" translate="yes" xml:space="preserve">
          <source>It can be a challenge to write a hook in a completely general way (that covers every possible selector and modifier), and it may not be necessary for your application (because perhaps you only ever call that mutator in one way).</source>
          <target state="translated">以一种完全通用的方式写一个钩子(涵盖所有可能的选择器和修饰器)可能是一个挑战,而且它可能对你的应用来说并不是必需的(因为也许你只以一种方式调用那个突变器)。</target>
        </trans-unit>
        <trans-unit id="c691f3bcdcddc67a71812db1aa6dae9fdb95c5e2" translate="yes" xml:space="preserve">
          <source>It could make sense for packages to exist to completely abstract some common denormalization techniques and actually attempt to deal with all possible modifications. If you write such a package, please let us know!</source>
          <target state="translated">如果有一个包能够完全抽象出一些常见的去归一化技术,并实际尝试处理所有可能的修改,可能是有意义的。如果你写了这样一个包,请让我们知道。</target>
        </trans-unit>
        <trans-unit id="8559f30e5502fc9ffdb0ba8086b3c8d12fe9f83f" translate="yes" xml:space="preserve">
          <source>It does something totally different!</source>
          <target state="translated">它的作用完全不同!</target>
        </trans-unit>
        <trans-unit id="e14be95c4c53eb1a3e234af0232df0160edffd59" translate="yes" xml:space="preserve">
          <source>It is best to place the subscription as close as possible to the place where the data from the subscription is needed. This reduces &amp;ldquo;action at a distance&amp;rdquo; and makes it easier to understand the flow of data through your application. If the subscription and fetch are separated, then it&amp;rsquo;s not always clear how and why changes to the subscriptions (such as changing arguments), will affect the contents of the cursor.</source>
          <target state="translated">最好将订阅放置在尽可能靠近需要订阅数据的位置。这减少了&amp;ldquo;远距离操作&amp;rdquo;，并使您更容易理解应用程序中的数据流。如果订阅和获取是分开的，那么并不总是清楚如何以及为什么对订阅的更改（例如，更改参数）会影响游标的内容。</target>
        </trans-unit>
        <trans-unit id="e3ec9112fb49cd4dd06386b01bbb94e96a35d400" translate="yes" xml:space="preserve">
          <source>It is illegal to call &lt;code&gt;flush&lt;/code&gt; from inside a &lt;code&gt;flush&lt;/code&gt; or from a running computation.</source>
          <target state="translated">它是非法调用 &lt;code&gt;flush&lt;/code&gt; 从里面 &lt;code&gt;flush&lt;/code&gt; 或从正在运行的计算。</target>
        </trans-unit>
        <trans-unit id="41d866892ab96b900a2aced50924d3d177f0a796" translate="yes" xml:space="preserve">
          <source>It is key to understand that a subscription will not instantly provide its data. There will be a latency between subscribing to the data on the client and it arriving from the publication on the server. You should also be aware that this delay may be a lot longer for your users in production than for you locally in development!</source>
          <target state="translated">关键是要明白,订阅不会立即提供数据。在客户端上订阅数据和数据从服务器上的发布到达之间会有一个延迟。你也应该意识到,这个延迟对于生产中的用户来说,可能比你在本地开发中的用户要长得多!</target>
        </trans-unit>
        <trans-unit id="406170b3a37d468efe5138052cfd282f8c336370" translate="yes" xml:space="preserve">
          <source>It is necessary to configure the TypeScript compiler with a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">必须使用 &lt;code&gt;tsconfig.json&lt;/code&gt; 文件配置TypeScript编译器。</target>
        </trans-unit>
        <trans-unit id="19becc9f11e0a4a33bea34a6de176e135124b5d7" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the &lt;code&gt;ecmascript&lt;/code&gt; package and first call &lt;code&gt;import { Email } from 'meteor/email';&lt;/code&gt; before calling &lt;code&gt;Email.send&lt;/code&gt; in your app. It is also recommended that package developers now use ES2015 &lt;code&gt;export&lt;/code&gt; from their main JavaScript file instead of &lt;code&gt;api.export&lt;/code&gt;.</source>
          <target state="translated">建议您使用 &lt;code&gt;ecmascript&lt;/code&gt; 程序包，并首先 &lt;code&gt;import { Email } from 'meteor/email';&lt;/code&gt; 在您的应用中调用 &lt;code&gt;Email.send&lt;/code&gt; 之前。还建议程序包开发人员现在使用其主要JavaScript文件中的ES2015 &lt;code&gt;export&lt;/code&gt; 而不是 &lt;code&gt;api.export&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2723c139b2339ba19c9b59eb0a2da2ca4d231c85" translate="yes" xml:space="preserve">
          <source>It is recommended to use npm for 3rd party JavaScript libraries and use &lt;code&gt;import&lt;/code&gt; to control when files are loaded.</source>
          <target state="translated">建议将npm用于第三方JavaScript库，并使用 &lt;code&gt;import&lt;/code&gt; 控制何时加载文件。</target>
        </trans-unit>
        <trans-unit id="ff0d872e7e7860c7ab001fa5c473fa29c4549dd4" translate="yes" xml:space="preserve">
          <source>It is required that your &lt;code&gt;my-package&lt;/code&gt; name take the form of &lt;code&gt;username:my-package&lt;/code&gt;, where &lt;code&gt;username&lt;/code&gt; is your Meteor Developer username, if you plan to publish your package to Atmosphere.</source>
          <target state="translated">如果您打算将软件包发布到Atmosphere，则您的 &lt;code&gt;my-package&lt;/code&gt; 名称必须采用 &lt;code&gt;username:my-package&lt;/code&gt; 的形式，其中 &lt;code&gt;username&lt;/code&gt; 是您的Meteor Developer用户名。</target>
        </trans-unit>
        <trans-unit id="228b5380515ea3017a650ff8153e79a83573f7ea" translate="yes" xml:space="preserve">
          <source>It loads test files matching &lt;code&gt;*.app-test[s].*&lt;/code&gt; and &lt;code&gt;*.app-spec[s].*&lt;/code&gt;.</source>
          <target state="translated">它加载与 &lt;code&gt;*.app-test[s].*&lt;/code&gt; 和 &lt;code&gt;*.app-spec[s].*&lt;/code&gt; 匹配的测试文件。</target>
        </trans-unit>
        <trans-unit id="7eacf899f23c9c18c70e4aa55a3fd639c2e7e790" translate="yes" xml:space="preserve">
          <source>It makes sense for a &amp;ldquo;page&amp;rdquo; smart component like &lt;code&gt;Lists_show_page&lt;/code&gt; to:</source>
          <target state="translated">对于诸如 &lt;code&gt;Lists_show_page&lt;/code&gt; 之类的&amp;ldquo;页面&amp;rdquo;智能组件，有意义的是：</target>
        </trans-unit>
        <trans-unit id="228f249e2b6bc89042ba046dcaaa7196c0c69255" translate="yes" xml:space="preserve">
          <source>It makes sense to place a publication alongside the feature that it&amp;rsquo;s targeted for. For instance, sometimes publications provide very specific data that&amp;rsquo;s only really useful for the view for which they were developed. In that case, placing the publication in the same module or directory as the view code makes perfect sense.</source>
          <target state="translated">将出版物与目标功能一起放置是有意义的。例如，有时出版物会提供非常具体的数据，这些数据仅对它们所基于的视图真正有用。在这种情况下，将出版物与视图代码放在相同的模块或目录中是很有意义的。</target>
        </trans-unit>
        <trans-unit id="28b51bca68c25f23b252f2cc4cac7ffce8718f4c" translate="yes" xml:space="preserve">
          <source>It turns out that having a field writeable by default without making that super obvious might not be the best idea. There are many stories of new Meteor developers storing fields such as &lt;code&gt;isAdmin&lt;/code&gt; on &lt;code&gt;profile&lt;/code&gt;&amp;hellip; and then a malicious user can easily set that to true whenever they want, making themselves an admin. Even if you aren&amp;rsquo;t concerned about this, it isn&amp;rsquo;t a good idea to let malicious users store arbitrary amounts of data in your database.</source>
          <target state="translated">事实证明，默认情况下具有可写的字段而不使该字段变得明显可能不是最好的主意。有许多关于新Meteor开发人员在 &lt;code&gt;profile&lt;/code&gt; 上存储诸如 &lt;code&gt;isAdmin&lt;/code&gt; 之类的字段的故事，然后，恶意用户可以随时将其轻松设置为true，从而使自己成为管理员。即使您不必担心，让恶意用户将任意数量的数据存储在数据库中也不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="b1b14da312e733d43bb22d74e4430fc32c5a996b" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a bad idea to look up things directly in the DOM with jQuery&amp;rsquo;s global &lt;code&gt;$()&lt;/code&gt;. It&amp;rsquo;s easy to select some element on the page that has nothing to do with the current component. Also, it limits your options on rendering &lt;em&gt;outside&lt;/em&gt; of the main document (see testing section below).</source>
          <target state="translated">使用jQuery的全局 &lt;code&gt;$()&lt;/code&gt; 直接在DOM中查找内容是个坏主意。在页面上选择与当前组件无关的某些元素很容易。而且，它限制了您在主文档&lt;em&gt;之外&lt;/em&gt;进行渲染的选项（请参见下面的测试部分）。</target>
        </trans-unit>
        <trans-unit id="aa3a82b09261cbd84023d6ce1bf90f8a0e1dc729" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good habit to name your container exactly like the component that it wraps, with the word &amp;ldquo;Container&amp;rdquo; tacked onto the end. This way, when you&amp;rsquo;re attempting to track down issues in your code, it makes it much easier to locate the appropriate files/classes.</source>
          <target state="translated">最好按照包装容器的名称来命名容器，并在其末尾加上&amp;ldquo; Container&amp;rdquo;一词。这样，当您尝试查找代码中的问题时，可以更轻松地找到合适的文件/类。</target>
        </trans-unit>
        <trans-unit id="a34e996e030eb7d4e5f116557adfcde21b2c2159" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to have a release process that you follow in releasing your application. Typically that process looks something like:</source>
          <target state="translated">在发布应用程序时遵循发布过程是一个好主意。通常，该过程类似于：</target>
        </trans-unit>
        <trans-unit id="b39219a3bced108920f2a9ade043f419510201a9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also worth knowing a little about what happens on the server when the new subscription is started and the old one is stopped.</source>
          <target state="translated">另外，还应该对启动新订阅而停止旧订阅时在服务器上发生的情况有所了解。</target>
        </trans-unit>
        <trans-unit id="853429164832b5efbf06259b1c8aa99ca8a1b190" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always a good idea to use SSL for Meteor applications (see the &lt;a href=&quot;security#ssl&quot;&gt;Security Article&lt;/a&gt; to find out why). Once you have a registered domain name, you&amp;rsquo;ll need to generate an SSL certificate with a certificate authority for your domain. If you deploy to Galaxy, you can &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html#lets-encrypt&quot;&gt;generate a free SSL certificate with a single click&lt;/a&gt; (courtesy of Let&amp;rsquo;s Encrypt!).</source>
          <target state="translated">将SSL用于Meteor应用程序总是一个好主意（请参阅&lt;a href=&quot;security#ssl&quot;&gt;安全性文章&lt;/a&gt;以了解原因）。注册域名后，您将需要为您的域生成具有证书颁发机构的SSL证书。如果部署到Galaxy，则只需&lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html#lets-encrypt&quot;&gt;单击&lt;/a&gt;即可生成免费的SSL证书（由Let's Encrypt！提供）。</target>
        </trans-unit>
        <trans-unit id="46ee8c46487a50a48cf4fdbcdf0cd2f3f1941e78" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to handle the redirection from HTTP to HTTPS on the platform which handles the SSL certificates and termination.</source>
          <target state="translated">最好在处理SSL证书和终止的平台上处理从HTTP到HTTPS的重定向。</target>
        </trans-unit>
        <trans-unit id="757e0c44aed4ca9b9283e0ce28692a5a28229798" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to keep all logic around what to render in the component hierarchy (i.e. the tree of rendered components). So this authorization should happen inside a component. Suppose we wanted to add this to the &lt;code&gt;Lists_show_page&lt;/code&gt; we were looking at above. We could do something like:</source>
          <target state="translated">最好保持所有逻辑围绕组件层次结构中要呈现的内容（即，呈现的组件树）。因此，此授权应在组件内部进行。假设我们想将其添加到上面 &lt;code&gt;Lists_show_page&lt;/code&gt; 中。我们可以做类似的事情：</target>
        </trans-unit>
        <trans-unit id="9929693c4e7c4992e137e9f0ef1b60685fc83a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need related sets of data from multiple collections on a given page. For instance, in the Todos app, when we render a todo list, we want the list itself, as well as the set of todos that belong to that list.</source>
          <target state="translated">给定页面上需要多个集合中的相关数据集是很常见的。例如，在Todos应用程序中，当我们渲染待办事项列表时，我们需要列表本身以及属于该列表的待办事项集。</target>
        </trans-unit>
        <trans-unit id="439a1abd1582cb1ad7ca286054b9f291afda74d7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to know which pages of your app are most commonly visited, and where users are coming from. Here&amp;rsquo;s a simple setup that will get you URL tracking using Google Analytics. We&amp;rsquo;ll be using the &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;&lt;code&gt;okgrow:analytics&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">通常想知道您的应用最常访问哪些页面以及用户来自何处。这是一个简单的设置，可让您使用Google Analytics（分析）进行URL跟踪。我们将使用&lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt; &lt;code&gt;okgrow:analytics&lt;/code&gt; &lt;/a&gt;包。</target>
        </trans-unit>
        <trans-unit id="b5e91b26503a62d31558b0277c06d2eeec65d490" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to know which pages of your app are most commonly visited, and where users are coming from. You can read about how to set up Flow Router based analytics in the &lt;a href=&quot;deployment#analytics&quot;&gt;Deployment Guide&lt;/a&gt;.</source>
          <target state="translated">通常想知道您的应用最常访问哪些页面以及用户来自何处。您可以在&amp;ldquo; &lt;a href=&quot;deployment#analytics&quot;&gt;部署指南&amp;rdquo;中&lt;/a&gt;阅读有关如何设置基于Flow Router的分析的信息。</target>
        </trans-unit>
        <trans-unit id="4b9a1580833de91f46d31dc47e017a82efa79bcb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to reuse code between two otherwise unrelated components. There are two main ways to do this in Blaze.</source>
          <target state="translated">想要在两个其他不相关的组件之间重用代码是很常见的。在Blaze中，有两种主要方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7549849e7e8b4fad84055090bb60bd718ad56e51" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to learn everything about a programming language at once. For example, programmers new to JavaScript often struggle with the &lt;code&gt;var&lt;/code&gt; keyword and function scope. Using a community-recommended coding style with automatic linting can warn you about these pitfalls proactively. This means you can jump right into coding without learning about all of the edge cases of JavaScript ahead of time.</source>
          <target state="translated">很难一次学习有关编程语言的所有知识。例如，刚接触JavaScript的程序员经常在 &lt;code&gt;var&lt;/code&gt; 关键字和函数作用域中挣扎。将社区推荐的编码样式与自动掉毛一起使用可以主动警告您这些陷阱。这意味着您可以直接进入编码，而无需提前了解JavaScript的所有极端情况。</target>
        </trans-unit>
        <trans-unit id="ad12f5f933ed39efe48255089a0905fd3f5fa06c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important that we set a &lt;code&gt;sort&lt;/code&gt; parameter on our query (to ensure a repeatable order of list items as more pages are requested), and that we set an absolute maximum on the number of items a user can request (at least in the case where lists can grow without bound).</source>
          <target state="translated">重要的是，我们在查询中设置一个 &lt;code&gt;sort&lt;/code&gt; 参数（以确保请求更多页面时列表项的可重复顺序），并且我们设置用户可以请求的项目数的绝对最大值（至少在以下情况下）列表可以无限制地增长）。</target>
        </trans-unit>
        <trans-unit id="9d5d9268705b388fc3454c63be5fc49b857234b9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand what happens during a deployment, especially if your deployment involves changes in data format (and potentially data migrations, see the &lt;a href=&quot;collections#migrations&quot;&gt;Collections Article&lt;/a&gt;).</source>
          <target state="translated">重要的是要了解部署期间发生的情况，尤其是如果您的部署涉及数据格式的更改（以及可能的数据迁移，请参阅&lt;a href=&quot;collections#migrations&quot;&gt;Collections Article&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a7236f836ac3cb5aca066ad99178d22ac4de61f9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s instructive to think about what arguments such a component would need to differentiate between those five states. Let&amp;rsquo;s consider a generic pattern that would work in all cases where we provide the following information:</source>
          <target state="translated">考虑一下这样的组件在这五个状态之间需要区分哪些参数是很有启发性的。让我们考虑一种通用模式，该模式在提供以下信息的所有情况下都适用：</target>
        </trans-unit>
        <trans-unit id="a5593705f86d9ef004e814149e09f0cf48b60281" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s more flexible, in case you need to give the component more arguments in the future.</source>
          <target state="translated">如果将来需要为组件提供更多参数，它会更加灵活。</target>
        </trans-unit>
        <trans-unit id="1a180aafb82184c9d5d9574133aceeb3d8cf6697" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier to write clean code if you can assume your inputs are correct, so it&amp;rsquo;s valuable to validate all Method arguments before running any actual business logic. You don&amp;rsquo;t want someone to pass a data type you aren&amp;rsquo;t expecting and cause unexpected behavior.</source>
          <target state="translated">如果可以假设输入正确，则编写干净的代码要容易得多，因此在运行任何实际的业务逻辑之前验证所有Method参数很有价值。您不希望某人传递您不期望的数据类型并导致意外行为。</target>
        </trans-unit>
        <trans-unit id="c7193ac2a78039510cc45d8aa3e842e7e9d42406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not strictly required, but often a good idea to set up a Content Delivery Network (CDN) for your site. A CDN is a network of servers that hosts the static assets of your site (such as JavaScript, CSS, and images) in numerous locations around the world and uses the server closest to your user to provide those files in order to speed up their delivery. For example, if the actual web server for your application is on the east coast of the USA and your user is in Australia, a CDN could host a copy of the JavaScript of the site within Australia or even in the city the user is in. This has huge benefits for the initial loading time of your site.</source>
          <target state="translated">并非严格要求，但为您的站点设置内容交付网络（CDN）通常是一个好主意。CDN是由服务器组成的网络，在全球多个地方托管您站点的静态资产（例如JavaScript，CSS和图像），并使用距离您的用户最近的服务器来提供这些文件，以加快其交付速度。例如，如果您的应用程序的实际Web服务器位于美国的东海岸，而您的用户位于澳大利亚，则CDN可以承载该网站在澳大利亚甚至用户所在城市内的JavaScript副本。这对于您的网站的初始加载时间具有巨大的好处。</target>
        </trans-unit>
        <trans-unit id="5bbcba703bc3869b31fb79c00b4eb53bdff5b804" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s pretty straightforward to validate a document with a schema. We can write:</source>
          <target state="translated">使用架构验证文档非常简单。我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="5c6f4ec1705b73d6848b8412f9837628ca01938a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to just provide the object you&amp;rsquo;re interested in as the entire data context of the template (like &lt;code&gt;{{&amp;gt; Todos_item todo}}&lt;/code&gt;). It&amp;rsquo;s better to explicitly give it a name (&lt;code&gt;{{&amp;gt; Todos_item todo=todo}}&lt;/code&gt;). There are two primary reasons for this:</source>
          <target state="translated">仅仅将您感兴趣的对象作为模板的整个数据上下文提供是很诱人的（例如 &lt;code&gt;{{&amp;gt; Todos_item todo}}&lt;/code&gt; ）。最好明确为其命名（ &lt;code&gt;{{&amp;gt; Todos_item todo=todo}}&lt;/code&gt; ）。这样做的主要原因有两个：</target>
        </trans-unit>
        <trans-unit id="d3d8ad4bb37bba95e0227bdbc9a24681722711b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s the &lt;code&gt;listShow&lt;/code&gt; component (a reusuable component) that actually handles the job of rendering the content of the page. As the page component is passing the arguments into the reusuable component, it is able to be quite mechanical and the concerns of talking to the router and rendering the page have been separated.</source>
          <target state="translated">实际上是 &lt;code&gt;listShow&lt;/code&gt; 组件（可重用的组件）处理呈现页面内容的工作。当页面组件将参数传递给可重用组件时，它可以非常机械化，并且与路由器对话和呈现页面的考虑已分离。</target>
        </trans-unit>
        <trans-unit id="baecec7075ff567c964ed1f0138b45c793659be8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typical to make some kind of change to the database when a user takes an action. However it&amp;rsquo;s important to make sure you don&amp;rsquo;t do this too rapidly. For instance, if you wish to save the user&amp;rsquo;s text as they type in a text box, you should take steps to make sure that you don&amp;rsquo;t send method calls to your server more than every few hundred milliseconds.</source>
          <target state="translated">用户执行操作时，通常会对数据库进行某种更改。但是，重要的是要确保您不要做得太快。例如，如果您希望在用户输入文本框中时保存他们的文本，则应采取步骤确保您向服务器发送方法调用的时间间隔不超过每几百毫秒一次。</target>
        </trans-unit>
        <trans-unit id="a107e80ca79a3b1e3ba5dbe3b2aa4861066fe1c5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to access information about the current route in your code. Here are some reactive functions you can call:</source>
          <target state="translated">在代码中访问有关当前路线的信息很有用。您可以调用以下一些反应式函数：</target>
        </trans-unit>
        <trans-unit id="950d097078f93573b3aac8f0c2fb5cc95a3c62c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to consider the various places in the system that user-readable strings exist and make sure that you are properly using the i18n system to generate those strings in each case. We&amp;rsquo;ll go over the implementation for each case in the sections about &lt;a href=&quot;#tap-i18n-js&quot;&gt;&lt;code&gt;tap:i18n&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#universe-i18n&quot;&gt;&lt;code&gt;universe:i18n&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">考虑用户可读字符串在系统中的各个位置，并确保在每种情况下都正确使用i18n系统生成这些字符串，这很有用。我们将在以下有关&lt;a href=&quot;#tap-i18n-js&quot;&gt; &lt;code&gt;tap:i18n&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#universe-i18n&quot;&gt; &lt;code&gt;universe:i18n&lt;/code&gt; &lt;/a&gt;的部分中介绍每种情况的实现。</target>
        </trans-unit>
        <trans-unit id="dab08d31b2bc70dc0d06c49797b25313cc569d5d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually best to keep your view layer as thin as possible and contain a component to whatever specific task it specifically needs to do. If there&amp;rsquo;s heavy lifting involved (such as complicated data loading logic), it often makes sense to abstract it out into a library that simply deals with the logic alone and doesn&amp;rsquo;t deal with the Blaze system at all.</source>
          <target state="translated">通常最好使您的视图层尽可能地薄，并包含它专门需要执行的特定任务的组件。如果涉及繁重的工作（例如复杂的数据加载逻辑），则将其抽象到一个仅处理逻辑而根本不处理Blaze系统的库中通常是有意义的。</target>
        </trans-unit>
        <trans-unit id="c0cf738a4ddb81522363b6a983c9dc6988d9564c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very rare to need to access &lt;code&gt;currentComputation&lt;/code&gt; directly. The current computation is used implicitly by &lt;a href=&quot;#tracker_active&quot;&gt;&lt;code&gt;Tracker.active&lt;/code&gt;&lt;/a&gt; (which tests whether there is one), &lt;a href=&quot;#dependency_depend&quot;&gt;&lt;code&gt;dependency.depend()&lt;/code&gt;&lt;/a&gt; (which registers that it depends on a dependency), and &lt;a href=&quot;#tracker_oninvalidate&quot;&gt;&lt;code&gt;Tracker.onInvalidate&lt;/code&gt;&lt;/a&gt; (which registers a callback with it).</source>
          <target state="translated">需要直接访问 &lt;code&gt;currentComputation&lt;/code&gt; 的情况很少。&lt;a href=&quot;#tracker_active&quot;&gt; &lt;code&gt;Tracker.active&lt;/code&gt; &lt;/a&gt;（用于测试是否存在该函数），&lt;a href=&quot;#dependency_depend&quot;&gt; &lt;code&gt;dependency.depend()&lt;/code&gt; &lt;/a&gt;（用于注册依赖于依赖项）和&lt;a href=&quot;#tracker_oninvalidate&quot;&gt; &lt;code&gt;Tracker.onInvalidate&lt;/code&gt; &lt;/a&gt;（用于向其注册回调）将隐式使用当前计算。</target>
        </trans-unit>
        <trans-unit id="1bd96d98292cd9c6dc1782fc486bb4ffca45486a" translate="yes" xml:space="preserve">
          <source>It's okay to load this dependency after your package. (In general, dependencies specified by &lt;code&gt;api.use&lt;/code&gt; are loaded before your package.) You can use this option to break circular dependencies.</source>
          <target state="translated">可以在包后加载此依赖项。（通常，由 &lt;code&gt;api.use&lt;/code&gt; 指定的依赖项会在您的程序包之前加载。）您可以使用此选项来中断循环依赖项。</target>
        </trans-unit>
        <trans-unit id="3bb69bc98399d871e90ce634e6fe04aa07ed967f" translate="yes" xml:space="preserve">
          <source>JSON-able object to stringify and use as the HTTP request body. Overwrites &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">支持JSON的对象，可进行字符串化并用作HTTP请求正文。覆盖 &lt;code&gt;content&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f665bc0cac8508d3d9a6462e5db25967183e5e9d" translate="yes" xml:space="preserve">
          <source>JSX for React</source>
          <target state="translated">JSX for React</target>
        </trans-unit>
        <trans-unit id="e64573adaf2a2b18646f5dd15016651f18b995b4" translate="yes" xml:space="preserve">
          <source>JavaScript style guide</source>
          <target state="translated">JavaScript风格指南</target>
        </trans-unit>
        <trans-unit id="20d54bee594c4d2003348a9a777e19cf6fca6bf8" translate="yes" xml:space="preserve">
          <source>JavaScript transpilation</source>
          <target state="translated">JavaScript移植</target>
        </trans-unit>
        <trans-unit id="5a164c98944da0d19e07447709f42b273f9bd7a9" translate="yes" xml:space="preserve">
          <source>Just a sequence (Cursor, array, null, or undefined) not wrapped into an object. Inside the Each body, the current item will be set as the data context.</source>
          <target state="translated">只是一个序列(Cursor,数组,null,或未定义),没有包装成一个对象。在Each体中,当前项目将被设置为数据上下文。</target>
        </trans-unit>
        <trans-unit id="4db78b711fb2571459e84542effce8b854ced53b" translate="yes" xml:space="preserve">
          <source>Just as an example, here&amp;rsquo;s a situation where not checking arguments can be disastrous:</source>
          <target state="translated">仅作为示例，在这种情况下，不检查参数会造成灾难性的后果：</target>
        </trans-unit>
        <trans-unit id="61d739a8a4ec714809f6d3f135bcff9218e298ea" translate="yes" xml:space="preserve">
          <source>Just as you can use &lt;code&gt;Meteor.isServer&lt;/code&gt; and &lt;code&gt;Meteor.isClient&lt;/code&gt; to separate your client-side and server-side code, you can use &lt;code&gt;Meteor.isCordova&lt;/code&gt; to separate your Cordova-specific code from the rest of your code.</source>
          <target state="translated">就像可以使用 &lt;code&gt;Meteor.isServer&lt;/code&gt; 和 &lt;code&gt;Meteor.isClient&lt;/code&gt; 分离客户端代码和服务器端代码一样，您也可以使用 &lt;code&gt;Meteor.isCordova&lt;/code&gt; 将特定于Cordova的代码与其余代码分离。</target>
        </trans-unit>
        <trans-unit id="412ca4f30e9c7366b28b14f212cbaf625b699a90" translate="yes" xml:space="preserve">
          <source>Just follow one simple rule: don&amp;rsquo;t query the database by &lt;code&gt;username&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt; directly. Instead, use the &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByUsername&quot;&gt;&lt;code&gt;Accounts.findUserByUsername&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByEmail&quot;&gt;&lt;code&gt;Accounts.findUserByEmail&lt;/code&gt;&lt;/a&gt; methods provided by Meteor. This will run a query for you that is case-insensitive, so you will always find the user you are looking for.</source>
          <target state="translated">只需遵循一个简单的规则：不要通过 &lt;code&gt;username&lt;/code&gt; 或 &lt;code&gt;email&lt;/code&gt; 直接查询数据库。而是使用Meteor提供的&lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByUsername&quot;&gt; &lt;code&gt;Accounts.findUserByUsername&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByEmail&quot;&gt; &lt;code&gt;Accounts.findUserByEmail&lt;/code&gt; &lt;/a&gt;方法。这将为您运行一个不区分大小写的查询，因此您将始终找到所需的用户。</target>
        </trans-unit>
        <trans-unit id="590d767afb3541e6c72e772b44d8db1039fe26da" translate="yes" xml:space="preserve">
          <source>Just like REST endpoints, Meteor Methods can easily be called from anywhere - a malicious program, script in the browser console, etc. It is easy to fire many Method calls in a very short amount of time. This means it can be easy for an attacker to test lots of different inputs to find one that works. Meteor has built-in rate limiting for password login to stop password brute-forcing, but it&amp;rsquo;s up to you to define rate limits for your other Methods.</source>
          <target state="translated">就像REST端点一样，流星方法可以轻松地从任何地方调用-恶意程序，浏览器控制台中的脚本等。很容易在很短的时间内触发许多方法调用。这意味着攻击者可以很容易地测试许多不同的输入以找到有效的输入。Meteor具有用于密码登录的内置速率限制，以停止强行使用密码，但是由您决定其他方法的速率限制。</target>
        </trans-unit>
        <trans-unit id="01bb30534adc12830b04426f7ed298596be923e2" translate="yes" xml:space="preserve">
          <source>Just like packages can export JavaScript code, they can export reusable bits of CSS pre-processor code. You can also have a package that doesn&amp;rsquo;t actually include any CSS, but just exports different bits of reusable mixins and variables. To get more details see Meteor &lt;a href=&quot;build-tool#css&quot;&gt;build tool CSS pre-processors&lt;/a&gt;:</source>
          <target state="translated">就像包可以导出JavaScript代码一样，它们可以导出CSS预处理程序代码的可重用位。您还可以拥有一个实际上不包含任何CSS的包，而只是导出不同位的可重用mixin和变量。要获取更多详细信息，请参阅Meteor &lt;a href=&quot;build-tool#css&quot;&gt;构建工具CSS预处理器&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d3167bce4da7048a6ae30006c9ab98cf229fd691" translate="yes" xml:space="preserve">
          <source>Just like we can use React components in Blaze templates, we can also use Blaze templates in React components. This is similarly useful for a gradual transition strategy; but more importantly, it allows us to continue to use the multitude of Atmosphere packages built for Blaze in our React projects, as well as core packages like &lt;code&gt;accounts-ui&lt;/code&gt;.</source>
          <target state="translated">就像我们可以在Blaze模板中使用React组件一样，我们也可以在React组件中使用Blaze模板。这对于逐步过渡策略同样有用；但更重要的是，它使我们能够继续在我们的React项目中使用为Blaze构建的众多Atmosphere软件包，以及诸如 &lt;code&gt;accounts-ui&lt;/code&gt; 之类的核心软件包。</target>
        </trans-unit>
        <trans-unit id="0189e11e377829809f4a9f3616dd729630c8c0a3" translate="yes" xml:space="preserve">
          <source>Keep any &lt;code&gt;id&lt;/code&gt; attributes, like &lt;code&gt;at-btn&lt;/code&gt;, since those are used for event handling.</source>
          <target state="translated">保留所有 &lt;code&gt;id&lt;/code&gt; 属性，例如 &lt;code&gt;at-btn&lt;/code&gt; ，因为它们用于事件处理。</target>
        </trans-unit>
        <trans-unit id="4fd2ca0f7a61432dccc3415c507dabc2c0d4e0c7" translate="yes" xml:space="preserve">
          <source>Lastly, the callback passed to &lt;code&gt;Meteor.call&lt;/code&gt; actually fires with the return value from step 4. It&amp;rsquo;s important that the callback waits until the client is up to date, so that your Method callback can assume that the client state reflects any changes done inside the Method.</source>
          <target state="translated">最后，传递给 &lt;code&gt;Meteor.call&lt;/code&gt; 的回调实际上会使用第4步的返回值触发。重要的是，回调要等到客户端更新为止，以便您的Method回调可以假定客户端状态反映了内部所做的任何更改。方法。</target>
        </trans-unit>
        <trans-unit id="a446bae20cf72c1227b7a81479571a2bbf4f46f4" translate="yes" xml:space="preserve">
          <source>Launch VS Code and open the quick open menu by typing &lt;code&gt;Ctrl+P&lt;/code&gt;</source>
          <target state="translated">启动VS Code并通过键入 &lt;code&gt;Ctrl+P&lt;/code&gt; 打开快速打开菜单</target>
        </trans-unit>
        <trans-unit id="2a8f672e3a918a42df8c3ff614c94ed72a9efb02" translate="yes" xml:space="preserve">
          <source>Launch the app on your device and open remote debugger by choosing &lt;em&gt;Develop &amp;gt; &amp;lt;Your device&amp;gt; &amp;gt; &amp;lt;Your app&amp;gt;/localhost&lt;/em&gt;.</source>
          <target state="translated">在您的设备上启动该应用程序，然后选择&lt;em&gt;Develop&amp;gt; &amp;lt;您的设备&amp;gt;&amp;gt; &amp;lt;您的应用程序&amp;gt; / localhost来&lt;/em&gt;打开远程调试器。</target>
        </trans-unit>
        <trans-unit id="039a88b23905dcc483ef61e6ecbd1ab571d2f7d6" translate="yes" xml:space="preserve">
          <source>Lazy evaluation will very likely become the default behavior in a future version of Meteor, but if you want to embrace it as fully as possible in the meantime, we recommend putting all your modules inside either &lt;code&gt;client/imports/&lt;/code&gt; or &lt;code&gt;server/imports/&lt;/code&gt; directories, with just a single entry point for each architecture: &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt;. The &lt;code&gt;main.js&lt;/code&gt; files will be evaluated eagerly, giving your application a chance to import modules from the &lt;code&gt;imports/&lt;/code&gt; directories.</source>
          <target state="translated">懒惰评估很可能会成为Meteor未来版本中的默认行为，但是如果您希望在此期间尽可能全面地接受它，我们建议您将所有模块放入 &lt;code&gt;client/imports/&lt;/code&gt; 或 &lt;code&gt;server/imports/&lt;/code&gt; 目录中，只是一个单一的入口点，每个架构： &lt;code&gt;client/main.js&lt;/code&gt; 和 &lt;code&gt;server/main.js&lt;/code&gt; 。在 &lt;code&gt;main.js&lt;/code&gt; 文件将被热切评估，让您的应用程序有机会从导入模块 &lt;code&gt;imports/&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="2fc33234e3d7f2cbc82e1f5c7df969a421883551" translate="yes" xml:space="preserve">
          <source>Lazy loading modules from a package</source>
          <target state="translated">从包中偷懒加载模块</target>
        </trans-unit>
        <trans-unit id="3cefecad08fcaa310174a0a33bd07fc7c007d64c" translate="yes" xml:space="preserve">
          <source>Learn more about how to use collection helpers in the &lt;a href=&quot;collections#collection-helpers&quot;&gt;Collections article&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo;收藏夹&amp;rdquo; &lt;a href=&quot;collections#collection-helpers&quot;&gt;文章中&lt;/a&gt;了解有关如何使用收藏夹助手的更多信息。</target>
        </trans-unit>
        <trans-unit id="b11d8c0ab52d35e474966b5f7f1f39a6280e48c5" translate="yes" xml:space="preserve">
          <source>Length of the string</source>
          <target state="translated">字符串的长度</target>
        </trans-unit>
        <trans-unit id="526cb7425ab8d8d55c981974917cba26fab9834e" translate="yes" xml:space="preserve">
          <source>Less</source>
          <target state="translated">Less</target>
        </trans-unit>
        <trans-unit id="e4f98de3ab3f36d35435275056982699600a25d3" translate="yes" xml:space="preserve">
          <source>Less is maintained as a &lt;a href=&quot;https://atmospherejs.com/meteor/less&quot;&gt;Meteor core package called &lt;code&gt;less&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">少保持为&lt;a href=&quot;https://atmospherejs.com/meteor/less&quot;&gt;流星核心包被称为 &lt;code&gt;less&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39a42a6f682cb64e595380c28474baa0b5c89fe9" translate="yes" xml:space="preserve">
          <source>Less.js</source>
          <target state="translated">Less.js</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="533c8a360ad209573b7a035e6e9d85489e4df1b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume that we have a &lt;code&gt;Lists&lt;/code&gt; collection. To define a schema for this collection using &lt;code&gt;simple-schema&lt;/code&gt;, you can simply create a new instance of the &lt;code&gt;SimpleSchema&lt;/code&gt; class and attach it to the &lt;code&gt;Lists&lt;/code&gt; object:</source>
          <target state="translated">假设我们有一个 &lt;code&gt;Lists&lt;/code&gt; 集合。要使用 &lt;code&gt;simple-schema&lt;/code&gt; 为此集合定义一个架构，您可以简单地创建一个 &lt;code&gt;SimpleSchema&lt;/code&gt; 类的新实例并将其附加到 &lt;code&gt;Lists&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="fade3d4ebc786e1e532abc9af1b0a346dec80c2a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider any generic item-listing component. To focus on a concrete example, we could consider the todo list in the Todos example app. Although it does not in our current example app, in a future version it could paginate through the todos for a given list.</source>
          <target state="translated">让我们考虑任何通用的项目列表组件。为了关注具体示例，我们可以考虑Todos示例应用程序中的todo列表。尽管它在我们当前的示例应用程序中没有，但是在将来的版本中，它可以通过给定列表的待办事项进行分页。</target>
        </trans-unit>
        <trans-unit id="cb80f1f768c0643b760d9f831673d4bc7d5c2da8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the case of the Todos example app. Here we do a similar thing to achieve animation between pages, by using Momentum in the main layout template:</source>
          <target state="translated">让我们考虑一下Todos示例应用程序的情况。在这里，我们通过在主布局模板中使用Momentum做类似的事情来实现页面之间的动画：</target>
        </trans-unit>
        <trans-unit id="7d1f6e724a957e722c1209ff84d6d1892e5306a5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a simple HTML form:</source>
          <target state="translated">让我们定义一个简单的HTML表单：</target>
        </trans-unit>
        <trans-unit id="e66c87dd273adbaa4bd71414237809a738eb7fd6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a few ways to resolve this issue.</source>
          <target state="translated">让我们看一下解决此问题的几种方法。</target>
        </trans-unit>
        <trans-unit id="9027762c7d8b7751ed6d1d6047913ca85c43e436" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to modify the &lt;code&gt;left-pad&lt;/code&gt; npm package. If you haven&amp;rsquo;t already, run inside your app directory:</source>
          <target state="translated">假设您要修改 &lt;code&gt;left-pad&lt;/code&gt; npm软件包。如果尚未安装，请在您的应用目录中运行：</target>
        </trans-unit>
        <trans-unit id="e7d55e87875df5f4fc55d1ad5156f4b661e1de65" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at example of both kinds of tests.</source>
          <target state="translated">让我们看一下这两种测试的示例。</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="e0e16878b381615e86b13824930a254210b14558" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt;, except that the autorun is automatically stopped when the View is destroyed, and the &lt;a href=&quot;#Blaze-currentView&quot;&gt;current View&lt;/a&gt; is always set when running &lt;code&gt;runFunc&lt;/code&gt;. There is no relationship to the View&amp;rsquo;s internal autorun or render cycle. In &lt;code&gt;runFunc&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;https://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; 相似&lt;/a&gt;，除了在销毁View时自动停止自动运行，并且在运行 &lt;code&gt;runFunc&lt;/code&gt; 时始终设置&lt;a href=&quot;#Blaze-currentView&quot;&gt;当前View&lt;/a&gt;。与视图的内部自动运行或渲染周期没有关系。在 &lt;code&gt;runFunc&lt;/code&gt; 中，视图绑定 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42434c3cae0f5acc2defcf29aa2836b04c2893bd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{{#each .. in}}&lt;/code&gt;, &lt;code&gt;{{#each}}&lt;/code&gt; iterates over an array or cursor, changing the data context within its content block to be the item in the current iteration. &lt;code&gt;{{#with}}&lt;/code&gt; simply changes the data context inside itself to the provided object. In most cases it&amp;rsquo;s better to use &lt;code&gt;{{#each .. in}}&lt;/code&gt; and &lt;code&gt;{{#let}}&lt;/code&gt; instead, just like it&amp;rsquo;s better to declare a variable than use the JavaScript &lt;code&gt;with&lt;/code&gt; keyword.</source>
          <target state="translated">像 &lt;code&gt;{{#each .. in}}&lt;/code&gt; ， &lt;code&gt;{{#each}}&lt;/code&gt; 遍历数组或游标，将其内容块中的数据上下文更改为当前迭代中的项。 &lt;code&gt;{{#with}}&lt;/code&gt; 只是将自身内部的数据上下文更改为提供的对象。在大多数情况下，最好改用 &lt;code&gt;{{#each .. in}}&lt;/code&gt; 和 &lt;code&gt;{{#let}}&lt;/code&gt; ，就像声明变量比使用 &lt;code&gt;with&lt;/code&gt; 关键字的JavaScript更好。</target>
        </trans-unit>
        <trans-unit id="c17cd4675137c3211881b87771487db77b9a14f1" translate="yes" xml:space="preserve">
          <source>Like all &lt;a href=&quot;#collections&quot;&gt;Mongo.Collection&lt;/a&gt;s, you can access all documents on the server, but only those specifically published by the server are available on the client. You can also use all Collection methods, for instance &lt;code&gt;Meteor.users.remove&lt;/code&gt; on the server to delete a user.</source>
          <target state="translated">像所有&lt;a href=&quot;#collections&quot;&gt;Mongo.Collection&lt;/a&gt;一样，您可以访问服务器上的所有文档，但是只有客户端专门发布的那些文档才可用。您还可以使用所有Collection方法，例如服务器上的 &lt;code&gt;Meteor.users.remove&lt;/code&gt; 来删除用户。</target>
        </trans-unit>
        <trans-unit id="57282be9feffc0a99ce69cb83b6ece8c1c7d9e97" translate="yes" xml:space="preserve">
          <source>Like any other global singleton in your application (see the &lt;a href=&quot;data-loading#stores&quot;&gt;data loading&lt;/a&gt; for info about stores), it&amp;rsquo;s best to limit your access to &lt;code&gt;FlowRouter&lt;/code&gt;. That way the parts of your app will remain modular and more independent. In the case of &lt;code&gt;FlowRouter&lt;/code&gt;, it&amp;rsquo;s best to access it solely from the top of your component hierarchy, either in the &amp;ldquo;page&amp;rdquo; component, or the layouts that wrap it. Read more about accessing data in the &lt;a href=&quot;ui-ux#components&quot;&gt;UI article&lt;/a&gt;.</source>
          <target state="translated">与应用程序中的任何其他全局单例一样（请参阅&lt;a href=&quot;data-loading#stores&quot;&gt;数据加载&lt;/a&gt;以获取有关商店的信息），最好限制对 &lt;code&gt;FlowRouter&lt;/code&gt; 的访问。这样，您的应用程序的各个部分将保持模块化且更加独立。对于 &lt;code&gt;FlowRouter&lt;/code&gt; 来说，最好仅从组件层次结构的顶部（在&amp;ldquo;页面&amp;rdquo;组件中或包装它的布局中）访问它。在&lt;a href=&quot;ui-ux#components&quot;&gt;UI文章中&lt;/a&gt;阅读有关访问数据的更多信息。</target>
        </trans-unit>
        <trans-unit id="be27ee8daec41f6f1ae70ee3d8b18835b4abaeb8" translate="yes" xml:space="preserve">
          <source>Likewise on the client:</source>
          <target state="translated">同样在客户端上。</target>
        </trans-unit>
        <trans-unit id="a2607bd54add9408c0721369c9c1c8d041e8abf8" translate="yes" xml:space="preserve">
          <source>Limiting re-rendering</source>
          <target state="translated">限制再渲染</target>
        </trans-unit>
        <trans-unit id="83ffcdcfaf1c24e2d15ef594b5f5431a0e7f32a8" translate="yes" xml:space="preserve">
          <source>Limiting the results serves a double purpose: it both prevents sensitive fields from being disclosed to the client and limits recomputation to the relevant fields only (namely, the &lt;code&gt;admin&lt;/code&gt; field).</source>
          <target state="translated">限制结果有双重目的：既防止敏感字段泄露给客户，又限制重新计算仅涉及相关字段（即 &lt;code&gt;admin&lt;/code&gt; 字段）。</target>
        </trans-unit>
        <trans-unit id="f6737babb19a4d874f1ca10734cd454bf2662c6f" translate="yes" xml:space="preserve">
          <source>Link the JavaScript files: wrap them into closures and provide necessary package imports.</source>
          <target state="translated">链接JavaScript文件:将它们封装成闭包并提供必要的包导入。</target>
        </trans-unit>
        <trans-unit id="cbb9d2b8205838917953cadea0aa0bdcbc27a594" translate="yes" xml:space="preserve">
          <source>Lint all source files and print the linting warnings.</source>
          <target state="translated">精简所有源文件并打印精简警告。</target>
        </trans-unit>
        <trans-unit id="08c4bdbbc8b84fda922dfbab609ea3937e98134b" translate="yes" xml:space="preserve">
          <source>Linter plugin - processes any number of files, and can print lint errors. Multiple linters can process the same files.</source>
          <target state="translated">Linter插件--处理任意数量的文件,并能打印出绒毛错误。多个linters可以处理相同的文件。</target>
        </trans-unit>
        <trans-unit id="64a7a833a84d006de3da423e4b3f69148b963064" translate="yes" xml:space="preserve">
          <source>Linters</source>
          <target state="translated">Linters</target>
        </trans-unit>
        <trans-unit id="c20c35d5e5d64e2186ff761f431660d1bfca7a1b" translate="yes" xml:space="preserve">
          <source>Linters are programs that check the code for undeclared variables or find code that doesn&amp;rsquo;t correspond to certain style guidelines. Some of the popular examples of linters are &lt;a href=&quot;http://jshint.com/about/&quot;&gt;JSHint&lt;/a&gt; and &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;. Some of the non-JavaScript linter examples include &lt;a href=&quot;http://www.coffeelint.org/&quot;&gt;CoffeeLint&lt;/a&gt; for CoffeeScript and &lt;a href=&quot;http://csslint.net/&quot;&gt;CSSLint&lt;/a&gt; for CSS.</source>
          <target state="translated">Linters是用于检查代码中未声明变量或查找与某些样式准则不符的代码的程序。一些棉短绒的最典型的例子是&lt;a href=&quot;http://jshint.com/about/&quot;&gt;JSHint&lt;/a&gt;和&lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;。一些非JavaScript的&lt;a href=&quot;http://www.coffeelint.org/&quot;&gt;linter&lt;/a&gt;示例包括用于CoffeeScript的&lt;a href=&quot;http://csslint.net/&quot;&gt;CoffeeLint&lt;/a&gt;和用于CSS的CSSLint。</target>
        </trans-unit>
        <trans-unit id="5e89a08a35d6bca50ebd56b625757a9b53856de8" translate="yes" xml:space="preserve">
          <source>Linting can be activated on WebStorm on a project-by-project basis, or you can set ESLint as a default under Editor &amp;gt; Inspections, choosing the Default profile, checking &amp;ldquo;ESLint&amp;rdquo;, and applying.</source>
          <target state="translated">可以在WebStorm上逐个项目激活Linting，也可以在&amp;ldquo;编辑器&amp;rdquo;&amp;gt;&amp;ldquo;检查&amp;rdquo;下将ESLint设置为默认值，选择&amp;ldquo;默认&amp;rdquo;配置文件，选中&amp;ldquo; ESLint&amp;rdquo;并应用。</target>
        </trans-unit>
        <trans-unit id="807c5a611bc0187a87d766234267271b8e0c7a82" translate="yes" xml:space="preserve">
          <source>Linting is the fastest way to find potential bugs in your code. Running a linter is usually faster than running your app or your unit tests, so it&amp;rsquo;s a good idea to run it all the time. Setting up linting in your editor can seem annoying at first since it will complain often when you save poorly-formatted code, but over time you&amp;rsquo;ll develop the muscle memory to just write well-formatted code in the first place. Here are some directions for setting up ESLint in different editors:</source>
          <target state="translated">整理是查找代码中潜在错误的最快方法。通常，运行lint比运行应用程序或单元测试要快，因此始终运行它是一个好主意。首先在编辑器中设置lint似乎很烦人，因为当您保存格式不正确的代码时，它经常会抱怨，但是随着时间的流逝，您将开发出强大的存储能力，以首先编写格式正确的代码。以下是在不同编辑器中设置ESLint的一些说明：</target>
        </trans-unit>
        <trans-unit id="c5fbfa2b671a883848337ca1fbcbf12a2dff8542" translate="yes" xml:space="preserve">
          <source>List of environment variables that you can use with your Meteor application.</source>
          <target state="translated">你可以在Meteor应用程序中使用的环境变量列表。</target>
        </trans-unit>
        <trans-unit id="6a32ea9a210990174cdb9e5a3e5cdf4b656aa683" translate="yes" xml:space="preserve">
          <source>List of routing packages which supports rendering of blaze templates.</source>
          <target state="translated">支持渲染blaze模板的路由包列表。</target>
        </trans-unit>
        <trans-unit id="237c4e9c76dd34f9fef4cb5f527add12e50da086" translate="yes" xml:space="preserve">
          <source>Lists all of the platforms that have been explicitly added to your project.</source>
          <target state="translated">列出所有被明确添加到项目中的平台。</target>
        </trans-unit>
        <trans-unit id="289fbe2367499465f159d431d4539e1ccf3b5be3" translate="yes" xml:space="preserve">
          <source>Lists all the packages that you have added to your project. For each package, lists the version that you are using. Lets you know if a newer version of that package is available.</source>
          <target state="translated">列出所有你已经添加到项目中的软件包。对于每个软件包,列出你正在使用的版本。让你知道该软件包是否有更新的版本。</target>
        </trans-unit>
        <trans-unit id="d0929f65fd871a616b54e0f40a3e70433d2a1f23" translate="yes" xml:space="preserve">
          <source>Loading and displaying user data</source>
          <target state="translated">加载和显示用户数据</target>
        </trans-unit>
        <trans-unit id="e7e6cd559c8c3763e6639df54316f5fb7c52be56" translate="yes" xml:space="preserve">
          <source>Loading data from a REST endpoint with a publication</source>
          <target state="translated">从REST端点加载数据与出版物</target>
        </trans-unit>
        <trans-unit id="ffef655301a42ecab38bf3596a2c7ce13d16b222" translate="yes" xml:space="preserve">
          <source>Loading data with Methods</source>
          <target state="translated">用方法加载数据</target>
        </trans-unit>
        <trans-unit id="d53b5e4f51d74d9669432621576e04fcc6fd4a76" translate="yes" xml:space="preserve">
          <source>Loading states are notoriously difficult to work on visually as they are by definition transient and often are barely noticeable in a development environment where subscriptions load almost instantly.</source>
          <target state="translated">加载状态在视觉上很难处理,因为它们的定义是短暂的,而且在开发环境中,订阅几乎是即时加载的,通常几乎不容易察觉。</target>
        </trans-unit>
        <trans-unit id="dacb906d06c3edb1203b705cec44a92faaea9900" translate="yes" xml:space="preserve">
          <source>Local &lt;code&gt;node_modules&lt;/code&gt;</source>
          <target state="translated">本地 &lt;code&gt;node_modules&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="567dcc89ed871782a8ea57c5f0ee6e5a1ef1b4d5" translate="yes" xml:space="preserve">
          <source>Local collections</source>
          <target state="translated">当地收藏</target>
        </trans-unit>
        <trans-unit id="f4a889e8085dc57ac139a50362f502bdc1eacf7f" translate="yes" xml:space="preserve">
          <source>Local files</source>
          <target state="translated">本地文件</target>
        </trans-unit>
        <trans-unit id="41022c9a58e615d942f295ba352fd4e63d7bc667" translate="yes" xml:space="preserve">
          <source>Local packages</source>
          <target state="translated">当地配套</target>
        </trans-unit>
        <trans-unit id="27c0e0a7170faa8a9da9611875b0dac036558a2f" translate="yes" xml:space="preserve">
          <source>Log in and out of your account using Meteor&amp;rsquo;s authentication system.</source>
          <target state="translated">使用Meteor的身份验证系统登录和注销您的帐户。</target>
        </trans-unit>
        <trans-unit id="ce2bf9c2a4373ee255609030571e3033460571d8" translate="yes" xml:space="preserve">
          <source>Log out other clients logged in as the current user, but does not log out the client that calls this function.</source>
          <target state="translated">注销以当前用户身份登录的其他客户端,但不会注销调用该函数的客户端。</target>
        </trans-unit>
        <trans-unit id="4a57c5797fff2e3f238765076b070f1727771f56" translate="yes" xml:space="preserve">
          <source>Log the user in using an external service.</source>
          <target state="translated">使用外部服务登录用户。</target>
        </trans-unit>
        <trans-unit id="62bcfd8b5c64843ba3c1dd3405e9a324dfb93a64" translate="yes" xml:space="preserve">
          <source>Log the user in with a password.</source>
          <target state="translated">用密码登录用户。</target>
        </trans-unit>
        <trans-unit id="78bf1464712a439f5499592247c70a116b407683" translate="yes" xml:space="preserve">
          <source>Log the user out.</source>
          <target state="translated">将用户注销。</target>
        </trans-unit>
        <trans-unit id="31841ae644017a32c06ba2bfe4439341d3aad516" translate="yes" xml:space="preserve">
          <source>Logging and debugging</source>
          <target state="translated">记录和调试</target>
        </trans-unit>
        <trans-unit id="783f02798d5892e34e2b6c2aa451f3417f080785" translate="yes" xml:space="preserve">
          <source>Logging in</source>
          <target state="translated">登录</target>
        </trans-unit>
        <trans-unit id="6ceed770d54126021a13d9171a9ee0e97cad7073" translate="yes" xml:space="preserve">
          <source>Login service configuration is sent from the server to the client over DDP when your app starts up; you may not call the login function until the configuration is loaded. The function &lt;code&gt;Accounts.loginServicesConfigured()&lt;/code&gt; is a reactive data source that will return true once the login service is configured; you should not make login buttons visible or active until it is true.</source>
          <target state="translated">应用启动时，登录服务配置通过DDP从服务器发送到客户端。在加载配置之前，您可能无法调用登录功能。功能 &lt;code&gt;Accounts.loginServicesConfigured()&lt;/code&gt; 是一个反应性数据源，一旦配置了登录服务，该数据源将返回true。您必须先将登录按钮设为可见，然后再使其处于活动状态。</target>
        </trans-unit>
        <trans-unit id="9fd7bb7cd5ee09061a524c727a8fd4f9a425724a" translate="yes" xml:space="preserve">
          <source>Login style (&quot;popup&quot; or &quot;redirect&quot;, defaults to the login service configuration). The &quot;popup&quot; style opens the login page in a separate popup window, which is generally preferred because the Meteor application doesn't need to be reloaded. The &quot;redirect&quot; style redirects the Meteor application's window to the login page, and the login service provider redirects back to the Meteor application which is then reloaded. The &quot;redirect&quot; style can be used in situations where a popup window can't be opened, such as in a mobile UIWebView. The &quot;redirect&quot; style however relies on session storage which isn't available in Safari private mode, so the &quot;popup&quot; style will be forced if session storage can't be used.</source>
          <target state="translated">登录风格(&quot;弹出式 &quot;或 &quot;重定向&quot;,默认为登录服务配置)。&quot;弹出式 &quot;风格在一个单独的弹出式窗口中打开登录页面,一般来说,这是首选,因为Meteor应用程序不需要重新加载。&quot;重定向 &quot;样式将Meteor应用程序的窗口重定向到登录页面,而登录服务提供者则重定向回Meteor应用程序,然后再重新加载。&quot;重定向 &quot;样式可以用于无法打开弹出窗口的情况,例如在移动UIWebView中。然而,&quot;重定向 &quot;样式依赖于会话存储,而在Safari私人模式下,会话存储是不可用的,所以如果不能使用会话存储,&quot;弹出 &quot;样式将被强制使用。</target>
        </trans-unit>
        <trans-unit id="07de5cf7de296d1847046aebae8acafadfcb75d9" translate="yes" xml:space="preserve">
          <source>Logout all current connections with this userId (default: true)</source>
          <target state="translated">注销当前所有使用该用户ID的连接(默认:true)。</target>
        </trans-unit>
        <trans-unit id="ab9527efdb5520fd59ebe0531c100593d538a2d4" translate="yes" xml:space="preserve">
          <source>Lookup order</source>
          <target state="translated">查询顺序</target>
        </trans-unit>
        <trans-unit id="e973a05925c462f97e11d4b82b455afa324a7ec8" translate="yes" xml:space="preserve">
          <source>MAIL_URL</source>
          <target state="translated">MAIL_URL</target>
        </trans-unit>
        <trans-unit id="357a834b670084af1d1f6134f0ef53507b115246" translate="yes" xml:space="preserve">
          <source>METEOR_PACKAGE_DIRS</source>
          <target state="translated">METEOR_PACKAGE_DIRS</target>
        </trans-unit>
        <trans-unit id="4328c41a1c3a7f6d86eb9ca05323eccf06285d2c" translate="yes" xml:space="preserve">
          <source>METEOR_SETTINGS</source>
          <target state="translated">METEOR_SETTINGS</target>
        </trans-unit>
        <trans-unit id="b91dcf1e030967fd2c7bd0c3c58bad58cf16c8ff" translate="yes" xml:space="preserve">
          <source>MONGO_OPLOG_URL</source>
          <target state="translated">MONGO_OPLOG_URL</target>
        </trans-unit>
        <trans-unit id="e95f1d302570f380146a9bd4df7a6726daa4c2ea" translate="yes" xml:space="preserve">
          <source>MONGO_URL</source>
          <target state="translated">MONGO_URL</target>
        </trans-unit>
        <trans-unit id="08bce2d9a3206bf0d7143d86833197a8534fabc6" translate="yes" xml:space="preserve">
          <source>Mac</source>
          <target state="translated">Mac</target>
        </trans-unit>
        <trans-unit id="0f06fae50518f48a3780998a35f988974e32fb05" translate="yes" xml:space="preserve">
          <source>Mail body (in plain text and/or HTML)</source>
          <target state="translated">邮件正文(纯文本和/或HTML</target>
        </trans-unit>
        <trans-unit id="a28faad48ffe4d9f2fd6baedeefc521cecfb8314" translate="yes" xml:space="preserve">
          <source>Mail body in HTML specific for Apple Watch</source>
          <target state="translated">Apple Watch专用的HTML邮件正文</target>
        </trans-unit>
        <trans-unit id="b412ceec910344b549407171c1d1dcc6de9f7022" translate="yes" xml:space="preserve">
          <source>Make sure secret API keys and passwords aren&amp;rsquo;t in your source code.</source>
          <target state="translated">确保您的源代码中没有秘密的API密钥和密码。</target>
        </trans-unit>
        <trans-unit id="89aac1c91a334c0ca9c4eaebf899112859fa92ef" translate="yes" xml:space="preserve">
          <source>Make sure the device is connected to your computer via a USB cable.</source>
          <target state="translated">确保设备通过USB电缆与电脑连接。</target>
        </trans-unit>
        <trans-unit id="1e837c1b669985c06d8b9d5f95108990d0f07fb9" translate="yes" xml:space="preserve">
          <source>Make sure to select the correct version of the &lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;Android Studio SDK Tools&lt;/a&gt;:</source>
          <target state="translated">确保选择正确版本的&lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;Android Studio SDK工具&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="85404e99d1eb544d78211afc39e86e0dd1a63689" translate="yes" xml:space="preserve">
          <source>Make sure your app doesn&amp;rsquo;t have the &lt;code&gt;insecure&lt;/code&gt; or &lt;code&gt;autopublish&lt;/code&gt; packages.</source>
          <target state="translated">确保您的应用程序没有 &lt;code&gt;insecure&lt;/code&gt; 或 &lt;code&gt;autopublish&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="d5712bacc51d4ae0bcd9f6914d7e1bdc6d7ca4f3" translate="yes" xml:space="preserve">
          <source>Make sure your device is set up for development &lt;a href=&quot;http://developer.android.com/tools/device.html#setting-up&quot;&gt;as explained here&lt;/a&gt;.</source>
          <target state="translated">确保&lt;a href=&quot;http://developer.android.com/tools/device.html#setting-up&quot;&gt;按照以下说明&lt;/a&gt;为开发设置设备。</target>
        </trans-unit>
        <trans-unit id="d118a094c6b8c8780bccd9be2421cdf00c3440b7" translate="yes" xml:space="preserve">
          <source>Make sure your device is set up for development &lt;a href=&quot;https://developer.android.com/tools/device.html#setting-up&quot;&gt;as explained here&lt;/a&gt;.</source>
          <target state="translated">确保&lt;a href=&quot;https://developer.android.com/tools/device.html#setting-up&quot;&gt;按照以下说明&lt;/a&gt;为开发设置设备。</target>
        </trans-unit>
        <trans-unit id="18a375e5e20b590475e54609de53cc4959a2ab46" translate="yes" xml:space="preserve">
          <source>Makes it safe to use reserved keywords as property names. For example, &lt;code&gt;object.catch&lt;/code&gt; is translated to &lt;code&gt;object[&quot;catch&quot;]&lt;/code&gt;.</source>
          <target state="translated">可以安全地使用保留关键字作为属性名称。例如， &lt;code&gt;object.catch&lt;/code&gt; 转换为 &lt;code&gt;object[&quot;catch&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a636adb47b461fbd152a8377933d7f1ba89294ed" translate="yes" xml:space="preserve">
          <source>Makes it safe to use reserved keywords like &lt;code&gt;catch&lt;/code&gt; as unquoted keys in object literals. For example, &lt;code&gt;{ catch: 123 }&lt;/code&gt; is translated to &lt;code&gt;{ &quot;catch&quot;: 123 }&lt;/code&gt;.</source>
          <target state="translated">可以安全地将保留的关键字（例如 &lt;code&gt;catch&lt;/code&gt; )用作对象文字中未加引号的键。例如， &lt;code&gt;{ catch: 123 }&lt;/code&gt; 被翻译为 &lt;code&gt;{ &quot;catch&quot;: 123 }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b4a7a973e5f6071313d6e349133c5b901c16a58" translate="yes" xml:space="preserve">
          <source>Making sure a plugin is compatible with the bundled Cordova platform versions</source>
          <target state="translated">确保插件与捆绑的Cordova平台版本兼容。</target>
        </trans-unit>
        <trans-unit id="9888ad8ac1983d8dd059e79f6a9118f01551d935" translate="yes" xml:space="preserve">
          <source>Many Method operations are idempotent by default. Inserts will throw an error if they happen twice because the generated ID will conflict. Removes on collections won&amp;rsquo;t do anything the second time, and most update operators like &lt;code&gt;$set&lt;/code&gt; will have the same result if run again. The only places you need to worry about code running twice are MongoDB update operators that stack, like &lt;code&gt;$inc&lt;/code&gt; and &lt;code&gt;$push&lt;/code&gt;, and calls to external APIs.</source>
          <target state="translated">默认情况下，许多方法操作是幂等的。如果插入两次发生，则插入将引发错误，因为生成的ID将发生冲突。集合上的删除将第二次不执行任何操作，并且大多数更新操作符（如 &lt;code&gt;$set&lt;/code&gt; 如果再次运行将具有相同的结果。您只需要担心代码会运行两次的唯一地方就是堆栈的MongoDB更新运算符，例如 &lt;code&gt;$inc&lt;/code&gt; 和 &lt;code&gt;$push&lt;/code&gt; ，以及对外部API的调用。</target>
        </trans-unit>
        <trans-unit id="3d22d15470f5d8b97196e8e7bc9698996e974b43" translate="yes" xml:space="preserve">
          <source>Many articles reference the Todos example application. This code is being actively developed alongside the guide. You can see the latest source code for the app, and file issues or make suggestions via pull request at its &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;GitHub repository&lt;/a&gt;.</source>
          <target state="translated">许多文章引用了Todos示例应用程序。该代码正在与指南一起积极开发。您可以在该应用程序的&lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;GitHub存储库中&lt;/a&gt;查看该应用程序的最新源代码，文件问题或通过请求请求提出建议。</target>
        </trans-unit>
        <trans-unit id="1b24a8d32e364af4a31b5ca24c727fca9c029001" translate="yes" xml:space="preserve">
          <source>Many npm packages adopt the convention of taking a callback that accepts &lt;code&gt;(err, res)&lt;/code&gt; arguments. If your asynchronous function fits this description, like the one above, you can use &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; to convert to a fiberized API that uses return values and exceptions instead of callbacks, like so:</source>
          <target state="translated">许多npm软件包都采用接受接受 &lt;code&gt;(err, res)&lt;/code&gt; 参数的回调的约定。如果您的异步函数符合上述描述，则可以使用 &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; 转换为使用返回值和异常而不是回调的纤维化API，如下所示：</target>
        </trans-unit>
        <trans-unit id="050995dc3ca4d8451591198e4b2aafef357fa495" translate="yes" xml:space="preserve">
          <source>Many npm packages rely on an asynchronous, callback or promise-based coding style. For several reasons, Meteor is currently built around a synchronous-looking but still non-blocking style using &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers&lt;/a&gt;.</source>
          <target state="translated">许多npm软件包都依赖于异步，回调或基于promise的编码风格。由于多种原因，Meteor当前是使用&lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers&lt;/a&gt;围绕具有同步外观但仍不阻塞的样式构建的。</target>
        </trans-unit>
        <trans-unit id="513e71826dc59ee6d3b9dec634899d66c8bc8a8e" translate="yes" xml:space="preserve">
          <source>Map callback over all matching documents. Returns an Array.</source>
          <target state="translated">在所有匹配文档上进行回调。返回一个数组。</target>
        </trans-unit>
        <trans-unit id="8219b264ad4b0f6b88e15181ddc3b8fb6c17030f" translate="yes" xml:space="preserve">
          <source>Marks the user's email address as verified. Logs the user in afterwards.</source>
          <target state="translated">将用户的邮箱地址标记为已验证。之后登录用户。</target>
        </trans-unit>
        <trans-unit id="d20dcbee72eb621b15360eaea8236dddbe4a2138" translate="yes" xml:space="preserve">
          <source>Match Patterns</source>
          <target state="translated">匹配模式</target>
        </trans-unit>
        <trans-unit id="7668ef6191ec870aea04a7212985e7d39c7c8ae7" translate="yes" xml:space="preserve">
          <source>Match.test()</source>
          <target state="translated">Match.test()</target>
        </trans-unit>
        <trans-unit id="0a524dbdc4300b1d5c466dc5b11ec3fb9b8a6cac" translate="yes" xml:space="preserve">
          <source>Matchers specify which events are counted towards a rate limit. A matcher is an object that has a subset of the same properties as the event objects described above. Each value in a matcher object is one of the following:</source>
          <target state="translated">匹配器指定哪些事件被计入速率限制。匹配器是一个对象,它具有与上述事件对象相同属性的子集。匹配器对象中的每个值都是以下之一。</target>
        </trans-unit>
        <trans-unit id="03f73f73e53b8a20f7c958dda4c5b0061ccb9a8a" translate="yes" xml:space="preserve">
          <source>Matches a particular type of event, but only when it appears on an element that matches a certain CSS selector.</source>
          <target state="translated">匹配一个特定类型的事件,但只有当它出现在一个匹配特定CSS选择器的元素上时才会匹配。</target>
        </trans-unit>
        <trans-unit id="6abc84683b8c1c7a6a61381314c65fc24f52bd4b" translate="yes" xml:space="preserve">
          <source>Matches a primitive of the given type.</source>
          <target state="translated">匹配一个给定类型的基元。</target>
        </trans-unit>
        <trans-unit id="fb564a1785cc03f541394f3bf380caa1c4f06b34" translate="yes" xml:space="preserve">
          <source>Matches a signed 32-bit integer. Doesn&amp;rsquo;t match &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, or &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">匹配一个有符号的32位整数。与 &lt;code&gt;Infinity&lt;/code&gt; ， &lt;code&gt;-Infinity&lt;/code&gt; 或 &lt;code&gt;NaN&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="9d55b78a97aa87168c5a2b7cd2af65d299629b2f" translate="yes" xml:space="preserve">
          <source>Matches an Object with the given keys, with values matching the given patterns. If any &lt;em&gt;pattern&lt;/em&gt; is a &lt;code&gt;Match.Maybe&lt;/code&gt; or &lt;code&gt;Match.Optional&lt;/code&gt;, that key does not need to exist in the object. The value may not contain any keys not listed in the pattern. The value must be a plain Object with no special prototype.</source>
          <target state="translated">将对象与给定的键匹配，其值与给定的模式匹配。如果任何&lt;em&gt;模式&lt;/em&gt;是 &lt;code&gt;Match.Maybe&lt;/code&gt; 或 &lt;code&gt;Match.Optional&lt;/code&gt; ，则该键不需要在对象中存在。该值不能包含模式中未列出的任何键。该值必须是没有特殊原型的普通对象。</target>
        </trans-unit>
        <trans-unit id="0f391c5569cdace62bd6748c6a0789a7f56045e5" translate="yes" xml:space="preserve">
          <source>Matches an Object with the given keys; the value may also have other keys with arbitrary values.</source>
          <target state="translated">用给定的键匹配一个对象;该值也可以有其他任意值的键。</target>
        </trans-unit>
        <trans-unit id="9e41ba767baa22b5b4ffa8b240da42727e6dc807" translate="yes" xml:space="preserve">
          <source>Matches any element that is an instance of that type.</source>
          <target state="translated">匹配任何属于该类型实例的元素。</target>
        </trans-unit>
        <trans-unit id="1507b874f0d3213f7c9c80574235ff4d72992e38" translate="yes" xml:space="preserve">
          <source>Matches any plain Object with any keys; equivalent to &lt;code&gt;Match.ObjectIncluding({})&lt;/code&gt;.</source>
          <target state="translated">将任何普通对象与任何键匹配；等效于 &lt;code&gt;Match.ObjectIncluding({})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1b557a9bc68663eb48f6403424b0549919157ea" translate="yes" xml:space="preserve">
          <source>Matches any value that matches at least one of the provided patterns.</source>
          <target state="translated">匹配任何符合至少一个提供的模式的值。</target>
        </trans-unit>
        <trans-unit id="add75212619bba1e4e5fef214807c4ad984cefdc" translate="yes" xml:space="preserve">
          <source>Matches any value.</source>
          <target state="translated">匹配任何数值。</target>
        </trans-unit>
        <trans-unit id="1521c460c4a6bf7385a64ba3716af0b414637cb0" translate="yes" xml:space="preserve">
          <source>Matches either &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;em&gt;pattern&lt;/em&gt;. If used in an object, matches only if the key is not set as opposed to the value being set to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;. This set of conditions was chosen because &lt;code&gt;undefined&lt;/code&gt; arguments to Meteor Methods are converted to &lt;code&gt;null&lt;/code&gt; when sent over the wire.</source>
          <target state="translated">匹配 &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 或&lt;em&gt;pattern&lt;/em&gt;。如果在对象中使用，则仅在未设置键（而不是将值设置为 &lt;code&gt;undefined&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; )时匹配。之所以选择这组条件，是因为通过网络发送时，流星方法的 &lt;code&gt;undefined&lt;/code&gt; 参数将转换为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbcb9e3b7d26f7500e2b86622cced9536d2c04fa" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#each}}&lt;/code&gt; in templates.</source>
          <target state="translated">匹配模板中 &lt;code&gt;{{#each}}&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="8e2b2f29e295a676f308a0a5e268e66292a03a29" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#if}}&lt;/code&gt; in templates.</source>
          <target state="translated">匹配模板中 &lt;code&gt;{{#if}}&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="927530b6acb62459cc6c80eeef299ac47e6bc087" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#unless}}&lt;/code&gt; in templates.</source>
          <target state="translated">匹配模板中 &lt;code&gt;{{#unless}}&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="d7c0d4b376351b7a9d91084b58ebe7d5b0a9dd9f" translate="yes" xml:space="preserve">
          <source>Matches the type of events, such as &lt;code&gt;'click'&lt;/code&gt;, separated by a forward slash, like so &lt;code&gt;'touchend/mouseup/keyup'&lt;/code&gt;.</source>
          <target state="translated">匹配事件类型，例如 &lt;code&gt;'click'&lt;/code&gt; ，以正斜杠分隔，例如 &lt;code&gt;'touchend/mouseup/keyup'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01403bbf57c3b114bdd15163c025084dfcf83ab6" translate="yes" xml:space="preserve">
          <source>Maximum number of results to return</source>
          <target state="translated">返回的最大结果数量</target>
        </trans-unit>
        <trans-unit id="368712eec67f68ec4ac017d1e1ea7bd41c9d602e" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds to wait for the request before failing. There is no timeout by default.</source>
          <target state="translated">请求失败前等待的最长时间,以毫秒为单位。默认情况下没有超时。</target>
        </trans-unit>
        <trans-unit id="3640bfaf55a8b64e0a4b999bf8aab62358ffc594" translate="yes" xml:space="preserve">
          <source>Meetup with &lt;code&gt;accounts-meetup&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;accounts-meetup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="278e0c7fb567feb534ddeb9f1aef82842151f497" translate="yes" xml:space="preserve">
          <source>Meetup: &lt;a href=&quot;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&lt;/a&gt;</source>
          <target state="translated">聚会：&lt;a href=&quot;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http&lt;/a&gt;：//www.meetup.com/meetup_api/auth/#oauth2-scopes</target>
        </trans-unit>
        <trans-unit id="76f62f75fd4a31bcef8bf46f7fc6938cf1e4e0e5" translate="yes" xml:space="preserve">
          <source>Meetup: &lt;a href=&quot;https://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&lt;/a&gt;</source>
          <target state="translated">聚会：&lt;a href=&quot;https://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http&lt;/a&gt;：//www.meetup.com/meetup_api/auth/#oauth2-scopes</target>
        </trans-unit>
        <trans-unit id="0d917cfc79a74f9cf135d7cefcfc6eb4811d9b76" translate="yes" xml:space="preserve">
          <source>Message-ID for this message; otherwise, will be set to a random value</source>
          <target state="translated">该消息的消息ID;否则,将被设置为一个随机值。</target>
        </trans-unit>
        <trans-unit id="da963b969942172b48c67a368a10a3a7ce182a0b" translate="yes" xml:space="preserve">
          <source>Message-ID this message is replying to</source>
          <target state="translated">该消息所回复的消息ID。</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="3df1a8a24cd0d57dda9fa6bba80b035ddc0ceafb" translate="yes" xml:space="preserve">
          <source>Meteor</source>
          <target state="translated">Meteor</target>
        </trans-unit>
        <trans-unit id="dd21f8919461768eb8ff2a40d07d620042782584" translate="yes" xml:space="preserve">
          <source>Meteor 1.4.2.x or before: Android SDK Tools v.23 (&lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-macosx.zip&quot;&gt;mac&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-linux.zip&quot;&gt;linux&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-windows.zip&quot;&gt;windows&lt;/a&gt;)</source>
          <target state="translated">Meteor 1.4.2.x或更低版本：Android SDK Tools v.23（&lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-macosx.zip&quot;&gt;mac&lt;/a&gt;，&lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-linux.zip&quot;&gt;linux&lt;/a&gt;，&lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-windows.zip&quot;&gt;Windows&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d1529c4bce36bb1d5933ec60cbe61f988b11d72e" translate="yes" xml:space="preserve">
          <source>Meteor 1.4.3.1 or later: Android SDK Tools v.25.&lt;strong&gt;2&lt;/strong&gt;.x (&lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip&quot;&gt;mac&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-linux.zip&quot;&gt;linux&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-windows.zip&quot;&gt;windows&lt;/a&gt;) or v.26.0.0 or later</source>
          <target state="translated">流星1.4.3.1或更高版本：Android SDK工具v.25。&lt;strong&gt;2&lt;/strong&gt; .x（&lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip&quot;&gt;mac&lt;/a&gt;，&lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-linux.zip&quot;&gt;linux&lt;/a&gt;，&lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-windows.zip&quot;&gt;windows&lt;/a&gt;）或v.26.0.0或更高版本</target>
        </trans-unit>
        <trans-unit id="da5f26ed41e3c616d9aa6f3645aee3451bd6e0e7" translate="yes" xml:space="preserve">
          <source>Meteor &lt;strong&gt;embraces the ecosystem&lt;/strong&gt;, bringing the best parts of the extremely active JavaScript community to you in a careful and considered way.</source>
          <target state="translated">Meteor &lt;strong&gt;拥抱着生态系统&lt;/strong&gt;，以谨慎周到的方式为您带来了活跃的JavaScript社区的最佳组成部分。</target>
        </trans-unit>
        <trans-unit id="1bfdb862eb1eada1f03b0722eb29cd6cbe5cd46e" translate="yes" xml:space="preserve">
          <source>Meteor Cordova integration</source>
          <target state="translated">Meteor Cordoba整合</target>
        </trans-unit>
        <trans-unit id="243d7f32de828a9d019240dd3674f1d15cc5e668" translate="yes" xml:space="preserve">
          <source>Meteor Developer Accounts with &lt;code&gt;accounts-meteor-developer&lt;/code&gt;</source>
          <target state="translated">流星开发者帐户，带有 &lt;code&gt;accounts-meteor-developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cd12013f9adcc91d557160d0de5d4ab92d6c816" translate="yes" xml:space="preserve">
          <source>Meteor Documentation</source>
          <target state="translated">流星文件</target>
        </trans-unit>
        <trans-unit id="a94d11ed4fe72db0b2bb1e32e5e23c8a0e9d1f5d" translate="yes" xml:space="preserve">
          <source>Meteor Methods have several features which aren&amp;rsquo;t immediately obvious, but every complex app will need them at some point. These features were added incrementally over several years in a backwards-compatible fashion, so unlocking the full capabilities of Methods requires a good amount of boilerplate. In this article we will first show you all of the code you need to write for each feature, then the next section will talk about a Method wrapper package we have developed to make it easier.</source>
          <target state="translated">流星方法具有一些功能，这些功能并不是立即显而易见的，但是每个复杂的应用程序在某些时候都将需要它们。这些功能在过去几年中以向后兼容的方式逐步增加，因此要解锁Methods的全部功能，需要大量的模板。在本文中，我们将首先向您展示为每个功能编写的所有代码，然后在下一节中，我们将讨论为简化它而开发的Method包装器程序包。</target>
        </trans-unit>
        <trans-unit id="ace5631ae5cf9280a9c77af56d8fc72f86ded554" translate="yes" xml:space="preserve">
          <source>Meteor Up</source>
          <target state="translated">流星向上</target>
        </trans-unit>
        <trans-unit id="3c130ee8434c0f82a7d473b654f9f0b47a1390be" translate="yes" xml:space="preserve">
          <source>Meteor Up has multiple projects so select what is best for your project:</source>
          <target state="translated">Meteor Up有多个项目,所以选择最适合你的项目。</target>
        </trans-unit>
        <trans-unit id="77d45d8ff2ea2e16619b146bafdc49ffe78788b4" translate="yes" xml:space="preserve">
          <source>Meteor Up, often referred to as &amp;ldquo;mupx&amp;rdquo; or &amp;ldquo;mup&amp;rdquo;, is a third-party open-source tool that can be used to deploy Meteor application to any online server over SSH. It handles some of the essential deployment requirements, but you will still need to do a lot of work to get your load balancing and version updates working smoothly. It&amp;rsquo;s essentially a way to automate the manual steps of using &lt;code&gt;meteor build&lt;/code&gt; and putting that bundle on your server.</source>
          <target state="translated">Meteor Up，通常称为&amp;ldquo; mupx&amp;rdquo;或&amp;ldquo; mup&amp;rdquo;，是第三方开源工具，可用于通过SSH将Meteor应用程序部署到任何在线服务器。它可以满足一些基本的部署要求，但是您仍然需要做很多工作才能使负载平衡和版本更新顺利进行。从本质上讲，这是一种自动化使用 &lt;code&gt;meteor build&lt;/code&gt; 并将该捆绑包放到服务器上的手动步骤的方法。</target>
        </trans-unit>
        <trans-unit id="b6f13051c054ac9f7467b0e0a532664b80df5de5" translate="yes" xml:space="preserve">
          <source>Meteor allows you to &lt;code&gt;import&lt;/code&gt; not only JavaScript in your application, but also CSS and HTML to control load order:</source>
          <target state="translated">Meteor 不仅可以在应用程序中 &lt;code&gt;import&lt;/code&gt; JavaScript，还可以导入 CSS和HTML来控制加载顺序：</target>
        </trans-unit>
        <trans-unit id="8a5e16cea47484b003dd766bca5ab501c11f291d" translate="yes" xml:space="preserve">
          <source>Meteor allows you to develop in &lt;strong&gt;one language&lt;/strong&gt;, JavaScript, in all environments: application server, web browser, and mobile device.</source>
          <target state="translated">Meteor允许您在以下所有环境中使用&lt;strong&gt;一种语言&lt;/strong&gt;，JavaScript 进行开发：应用程序服务器，Web浏览器和移动设备。</target>
        </trans-unit>
        <trans-unit id="818fd0ab8ec03b9c48d5dd707aa628078e84574e" translate="yes" xml:space="preserve">
          <source>Meteor also has a special &amp;ldquo;insecure mode&amp;rdquo; for quickly prototyping new applications. In insecure mode, if you haven&amp;rsquo;t set up any &lt;code&gt;allow&lt;/code&gt; or &lt;code&gt;deny&lt;/code&gt; rules on a collection, then all users have full write access to the collection. This is the only effect of insecure mode. If you call &lt;code&gt;allow&lt;/code&gt; or &lt;code&gt;deny&lt;/code&gt; at all on a collection, even &lt;code&gt;Posts.allow({})&lt;/code&gt;, then access is checked just like normal on that collection. &lt;strong&gt;New Meteor projects start in insecure mode by default.&lt;/strong&gt; To turn it off just run in your terminal:</source>
          <target state="translated">流星还具有一种特殊的&amp;ldquo;不安全模式&amp;rdquo;，可以快速对新应用程序进行原型制作。在不安全模式下，如果您没有在集合上设置任何 &lt;code&gt;allow&lt;/code&gt; 或 &lt;code&gt;deny&lt;/code&gt; 规则，则所有用户都对该集合具有完全写权限。这是不安全模式的唯一效果。如果您对某个集合甚至是 &lt;code&gt;Posts.allow({})&lt;/code&gt; 都调用了 &lt;code&gt;allow&lt;/code&gt; 或 &lt;code&gt;deny&lt;/code&gt; ，则就像对该集合一样，对访问进行检查。&lt;strong&gt;默认情况下，新Meteor项目以不安全模式启动。&lt;/strong&gt;要关闭它，只需在您的终端中运行：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e5aabeba695fa2a207c42c14faeb64ad2b9b8b5" translate="yes" xml:space="preserve">
          <source>Meteor also supports the standard ES2015 modules &lt;code&gt;export&lt;/code&gt; syntax:</source>
          <target state="translated">流星还支持标准的ES2015模块 &lt;code&gt;export&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="cda78c507086a6556c1ba2b2d33b8d52bc0ba8d3" translate="yes" xml:space="preserve">
          <source>Meteor and React</source>
          <target state="translated">流星和反应</target>
        </trans-unit>
        <trans-unit id="5d2f38c1fb00234ee93eaddb350cd5a424b3ca41" translate="yes" xml:space="preserve">
          <source>Meteor code style</source>
          <target state="translated">流星码样式</target>
        </trans-unit>
        <trans-unit id="65870eadebb1f904b46844bb0111cf57c1fb2735" translate="yes" xml:space="preserve">
          <source>Meteor comes with a default MongoDB collection for user data. It&amp;rsquo;s stored in the database under the name &lt;code&gt;users&lt;/code&gt;, and is accessible in your code through &lt;code&gt;Meteor.users&lt;/code&gt;. The schema of a user document in this collection will depend on which login service was used to create the account. Here&amp;rsquo;s an example of a user that created their account with &lt;code&gt;accounts-password&lt;/code&gt;:</source>
          <target state="translated">Meteor随附了用于用户数据的默认MongoDB集合。它以 &lt;code&gt;users&lt;/code&gt; 名存储在数据库中，可通过 &lt;code&gt;Meteor.users&lt;/code&gt; 在代码中访问。此集合中用户文档的架构将取决于用于创建帐户的登录服务。这是一个用户使用 &lt;code&gt;accounts-password&lt;/code&gt; 创建帐户的示例：</target>
        </trans-unit>
        <trans-unit id="fe1f42393c72fc1bd41a5a35f99cc8385e5c5774" translate="yes" xml:space="preserve">
          <source>Meteor comes with a secure and fully-featured password login system out of the box. To use it, add the package:</source>
          <target state="translated">流星自带安全功能齐全的密码登录系统,开箱即用。要使用它,请添加包。</target>
        </trans-unit>
        <trans-unit id="ac8330eeb7bf7d085cea3343a0687067ebe39fc1" translate="yes" xml:space="preserve">
          <source>Meteor comes with npm bundled so that you can type &lt;code&gt;meteor npm&lt;/code&gt; without worrying about installing it yourself. If you like, you can also use a globally installed npm to manage your packages.</source>
          <target state="translated">流星捆绑了npm，因此您可以键入 &lt;code&gt;meteor npm&lt;/code&gt; 而不必担心自己安装。如果愿意，还可以使用全局安装的npm来管理软件包。</target>
        </trans-unit>
        <trans-unit id="8de35b36912c0fe7b7a36db1bd4bd63acdd04730" translate="yes" xml:space="preserve">
          <source>Meteor comes with npm bundled so that you can type meteor npm without worrying about installing it yourself. If you like, you can also use a globally installed npm command.</source>
          <target state="translated">Meteor自带npm捆绑,所以你可以输入meteor npm,而不用担心自己安装。如果你喜欢,你也可以使用全局安装的npm命令。</target>
        </trans-unit>
        <trans-unit id="622fb646d4fc620ba4099776436a3bf63a96d3a5" translate="yes" xml:space="preserve">
          <source>Meteor does not downgrade transitive dependencies unless it&amp;rsquo;s necessary. This means that if running &lt;code&gt;meteor add A&lt;/code&gt; upgrades A&amp;rsquo;s parent package X to a new version, your project will continue to use X at the new version even after you run &lt;code&gt;meteor remove A&lt;/code&gt;.</source>
          <target state="translated">除非必要，否则Meteor不会降级可传递依赖项。这意味着，如果运行 &lt;code&gt;meteor add A&lt;/code&gt; 会将A的父包X升级到新版本，则即使您运行 &lt;code&gt;meteor remove A&lt;/code&gt; ，您的项目仍将继续使用X的新版本。</target>
        </trans-unit>
        <trans-unit id="cd40caf26a2846d8fbea4238ac3759079862fa82" translate="yes" xml:space="preserve">
          <source>Meteor gathers all your JavaScript files, excluding anything under the &lt;code&gt;client&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, and &lt;code&gt;private&lt;/code&gt; subdirectories, and loads them into a Node.js server instance. In Meteor, your server code runs in a single thread per request, not in the asynchronous callback style typical of Node.</source>
          <target state="translated">Meteor会收集所有JavaScript文件（不包括 &lt;code&gt;client&lt;/code&gt; ， &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 子目录下的任何内容），并将它们加载到Node.js服务器实例中。在Meteor中，您的服务器代码在每个请求中都在单个线程中运行，而不是以Node典型的异步回调样式运行。</target>
        </trans-unit>
        <trans-unit id="6581a00bac055c2176bd6f2f80efcc8bce406dbd" translate="yes" xml:space="preserve">
          <source>Meteor has a simple dependency tracking system which allows it to automatically rerun templates and other computations whenever &lt;a href=&quot;#session&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; variables, database queries, and other data sources change.</source>
          <target state="translated">流星有一个简单的依赖跟踪系统，当&lt;a href=&quot;#session&quot;&gt; &lt;code&gt;Session&lt;/code&gt; &lt;/a&gt;变量，数据库查询和其他数据源发生更改时，它可以自动重新运行模板和其他计算。</target>
        </trans-unit>
        <trans-unit id="9e8b5af5b5910144199c1f9b748072910d741067" translate="yes" xml:space="preserve">
          <source>Meteor has a test mode for packages called &lt;code&gt;meteor test-packages&lt;/code&gt;. If you are in a package&amp;rsquo;s directory, you can run</source>
          <target state="translated">Meteor对包的测试模式称为 &lt;code&gt;meteor test-packages&lt;/code&gt; 。如果您在软件包的目录中，则可以运行</target>
        </trans-unit>
        <trans-unit id="34c672dd3b48e4849e25b120306f2632a1d15d1f" translate="yes" xml:space="preserve">
          <source>Meteor implements a couple of compilers as Core packages, good examples would be the &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/templating&quot;&gt;Blaze templating&lt;/a&gt; package and the &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/ecmascript&quot;&gt;ecmascript&lt;/a&gt; package (compiles ES2015+ to JavaScript that can run in the browsers).</source>
          <target state="translated">Meteor实现了一些作为Core软件包的编译器，很好的例子是&lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/templating&quot;&gt;Blaze模板&lt;/a&gt;软件包和&lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/ecmascript&quot;&gt;ecmascript&lt;/a&gt;软件包（将ES2015 +编译为可在浏览器中运行的JavaScript）。</target>
        </trans-unit>
        <trans-unit id="ae9d577a85a05f47b12654451a1c802401cb6cee" translate="yes" xml:space="preserve">
          <source>Meteor integrates with &lt;a href=&quot;https://cordova.apache.org&quot;&gt;Cordova&lt;/a&gt;, a well-known Apache open source project, to build mobile apps from the same codebase you use to create regular web apps. With the Cordova integration in Meteor, you can take your existing app and run it on an iOS or Android device with a few simple commands.</source>
          <target state="translated">Meteor与著名的Apache开源项目&lt;a href=&quot;https://cordova.apache.org&quot;&gt;Cordova&lt;/a&gt;集成，以使用与创建常规Web应用程序相同的代码库构建移动应用程序。借助Meteor中的Cordova集成，您可以使用一些简单的命令将现有应用程序运行在iOS或Android设备上。</target>
        </trans-unit>
        <trans-unit id="a2bbf64eab1a1cb0273969a1de5135824254b9af" translate="yes" xml:space="preserve">
          <source>Meteor introduces two new types of JavaScript errors: &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_error&quot;&gt;&lt;code&gt;Meteor.Error&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt;. These and the regular JavaScript &lt;code&gt;Error&lt;/code&gt; type should be used in different situations:</source>
          <target state="translated">Meteor引入了两种新的JavaScript错误类型：&lt;a href=&quot;http://docs.meteor.com/#/full/meteor_error&quot;&gt; &lt;code&gt;Meteor.Error&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt; &lt;code&gt;ValidationError&lt;/code&gt; &lt;/a&gt;。这些和常规JavaScript &lt;code&gt;Error&lt;/code&gt; 类型应在不同情况下使用：</target>
        </trans-unit>
        <trans-unit id="de77907e46004848291278b95b568cdd87126c78" translate="yes" xml:space="preserve">
          <source>Meteor is a &lt;em&gt;full-stack&lt;/em&gt; framework for building JavaScript applications. This means Meteor applications differ from most applications in that they include code that runs on the client, inside a web browser or Cordova mobile app, code that runs on the server, inside a &lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; container, and &lt;em&gt;common&lt;/em&gt; code that runs in both environments. The &lt;a href=&quot;build-tool&quot;&gt;Meteor build tool&lt;/a&gt; allows you to easily specify what JavaScript code, including any supporting UI templates, CSS rules, and static assets, to run in each environment using a combination of ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; and the Meteor build system &lt;a href=&quot;#load-order&quot;&gt;default file load order&lt;/a&gt; rules.</source>
          <target state="translated">Meteor是用于构建JavaScript应用程序的&lt;em&gt;全栈&lt;/em&gt;框架。这意味着Meteor应用程序与大多数应用程序的不同之处在于，它们包括在客户端，Web浏览器或Cordova移动应用程序内运行的代码，在服务器上，&lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;容器内运行的代码以及在两种环境中运行的&lt;em&gt;通用&lt;/em&gt;代码。 。使用&lt;a href=&quot;build-tool&quot;&gt;Meteor构建工具&lt;/a&gt;，您可以结合使用ES2015 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 以及Meteor构建系统&lt;a href=&quot;#load-order&quot;&gt;默认文件加载顺序&lt;/a&gt;规则，轻松指定要在每种环境中运行的JavaScript代码，包括所有支持的UI模板，CSS规则和静态资产。</target>
        </trans-unit>
        <trans-unit id="d1d092a7e4c438e1e29efa1d3cdd4a7db53494b6" translate="yes" xml:space="preserve">
          <source>Meteor is a &lt;em&gt;full-stack&lt;/em&gt; framework for building JavaScript applications. This means Meteor applications differ from most applications in that they include code that runs on the client, inside a web browser or Cordova mobile app, code that runs on the server, inside a &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; container, and &lt;em&gt;common&lt;/em&gt; code that runs in both environments. The &lt;a href=&quot;build-tool&quot;&gt;Meteor build tool&lt;/a&gt; allows you to easily specify what JavaScript code, including any supporting UI templates, CSS rules, and static assets, to run in each environment using a combination of ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; and the Meteor build system &lt;a href=&quot;#load-order&quot;&gt;default file load order&lt;/a&gt; rules.</source>
          <target state="translated">Meteor是用于构建JavaScript应用程序的&lt;em&gt;全栈&lt;/em&gt;框架。这意味着Meteor应用程序与大多数应用程序的不同之处在于，它们包括在客户端，Web浏览器或Cordova移动应用程序内运行的代码，在服务器上，&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;容器内运行的代码以及在两种环境中运行的&lt;em&gt;通用&lt;/em&gt;代码。 。使用&lt;a href=&quot;build-tool&quot;&gt;Meteor构建工具&lt;/a&gt;，您可以结合使用ES2015 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 以及Meteor构建系统&lt;a href=&quot;#load-order&quot;&gt;默认文件加载顺序&lt;/a&gt;规则，轻松指定要在每种环境中运行的JavaScript代码，包括所有支持的UI模板，CSS规则和静态资产。</target>
        </trans-unit>
        <trans-unit id="51edf72fa6d304993cf008cb8e2913d19d8454ce" translate="yes" xml:space="preserve">
          <source>Meteor is a full-stack JavaScript platform for developing modern web and mobile applications. Meteor includes a key set of technologies for building connected-client reactive applications, a build tool, and a curated set of packages from the Node.js and general JavaScript community.</source>
          <target state="translated">Meteor是一个用于开发现代Web和移动应用的全栈JavaScript平台,它包括一套用于构建连接-客户端反应式应用的关键技术,一个构建工具,以及一套来自Node.js和一般JavaScript社区的精选包。Meteor包括一套用于构建连接客户端反应式应用的关键技术,一个构建工具,以及一套来自Node.js和一般JavaScript社区的精选包。</target>
        </trans-unit>
        <trans-unit id="bf17e9b8b6003d5ca76c5189f826948a2610cad9" translate="yes" xml:space="preserve">
          <source>Meteor is an open source platform, and you can run the apps that you make with Meteor anywhere just like regular Node.js applications. But operating Meteor apps &lt;em&gt;correctly&lt;/em&gt;, so that your apps work for everyone, can be tricky if you are managing your infrastructure manually. This is why we recommend running production Meteor apps on Galaxy.</source>
          <target state="translated">Meteor是一个开源平台，您可以像常规Node.js应用程序一样在任何地方运行使用Meteor创建的应用程序。但是，如果您手动管理基础架构，则&lt;em&gt;正确&lt;/em&gt;操作Meteor应用程序（使您的应用程序对所有人适用）可能会很棘手。这就是为什么我们建议在Galaxy上运行生产Meteor应用程序的原因。</target>
        </trans-unit>
        <trans-unit id="96caf87214977232d7aebb2b24e1cc114e10ce2a" translate="yes" xml:space="preserve">
          <source>Meteor is built from the ground up on the Distributed Data Protocol (DDP) to allow data transfer in both directions. Building a Meteor app doesn&amp;rsquo;t require you to set up REST endpoints to serialize and send data. Instead you create &lt;em&gt;publication&lt;/em&gt; endpoints that can push data from server to client.</source>
          <target state="translated">流星完全基于分布式数据协议（DDP）构建，以允许双向数据传输。构建Meteor应用程序不需要您设置REST端点来序列化和发送数据。相反，您创建可以将数据从服务器推送到客户端的&lt;em&gt;发布&lt;/em&gt;终结点。</target>
        </trans-unit>
        <trans-unit id="5bf9e464d9aa4352e16c8429850f8877bb399bd2" translate="yes" xml:space="preserve">
          <source>Meteor methods and publish functions can take arbitrary &lt;a href=&quot;#ejson&quot;&gt;EJSON&lt;/a&gt; types as arguments, but most functions expect their arguments to be of a particular type. &lt;code&gt;check&lt;/code&gt; is a lightweight function for checking that arguments and other values are of the expected type. For example:</source>
          <target state="translated">流星方法和发布函数可以将任意&lt;a href=&quot;#ejson&quot;&gt;EJSON&lt;/a&gt;类型用作参数，但是大多数函数期望它们的参数属于特定类型。 &lt;code&gt;check&lt;/code&gt; 是一个轻量级函数，用于检查参数和其他值是否为预期的类型。例如：</target>
        </trans-unit>
        <trans-unit id="5663c316e8ce97f460dde562bca82c3b321315ff" translate="yes" xml:space="preserve">
          <source>Meteor officially supports three user interface (UI) rendering libraries, &lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt;, &lt;a href=&quot;react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;http://www.angular-meteor.com&quot;&gt;Angular&lt;/a&gt;. Blaze was created as part of Meteor when it launched in 2011, React was created by Facebook in 2013, and Angular was created by Google in 2010. All three have been used successfully by large production apps. Blaze is the easiest to learn and has the most full-stack Meteor packages, but React and Angular are more developed and have larger communities.</source>
          <target state="translated">Meteor正式支持三个用户界面（UI）渲染库&lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt;，&lt;a href=&quot;react&quot;&gt;React&lt;/a&gt;和&lt;a href=&quot;http://www.angular-meteor.com&quot;&gt;Angular&lt;/a&gt;。Blaze是在2011年推出时作为Meteor的一部分而创建的，React是由Facebook在2013年创建的，而Angular是由Google在2010年创建的。这三个产品已成功用于大型生产应用程序。Blaze是最容易学习的，并且具有最多的全堆栈Meteor软件包，但是React和Angular更发达，并且具有更大的社区。</target>
        </trans-unit>
        <trans-unit id="f28e547125663964d5541f6a226999ebfb2a6daf" translate="yes" xml:space="preserve">
          <source>Meteor packages can also depend on plugins downloaded from Git:</source>
          <target state="translated">Meteor包也可以依赖从Git下载的插件。</target>
        </trans-unit>
        <trans-unit id="7077d19db8fe997f3430dce2bb21eea1390e9abd" translate="yes" xml:space="preserve">
          <source>Meteor packages can also depend on plugins installed from the local file system, although this probably only makes sense for local packages:</source>
          <target state="translated">Meteor包也可以依赖从本地文件系统安装的插件,尽管这可能只对本地包有意义。</target>
        </trans-unit>
        <trans-unit id="bdf4cbe607e00159702181bc49b119f054ac4169" translate="yes" xml:space="preserve">
          <source>Meteor packages can include &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm packages&lt;/a&gt; to use JavaScript code from outside the Meteor package ecosystem or to include JavaScript code with native dependencies. Use &lt;a href=&quot;http://docs.meteor.com/#/full/Npm-depends&quot;&gt;Npm.depends&lt;/a&gt; at the top level of your &lt;code&gt;package.js&lt;/code&gt; file. For example, here&amp;rsquo;s how you would include the &lt;code&gt;github&lt;/code&gt; npm package:</source>
          <target state="translated">Meteor软件包可以包括&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm软件包，&lt;/a&gt;以使用Meteor软件包生态系统外部的JavaScript代码或包含具有本机依赖性的JavaScript代码。在 &lt;code&gt;package.js&lt;/code&gt; 文件的顶层使用&lt;a href=&quot;http://docs.meteor.com/#/full/Npm-depends&quot;&gt;Npm.depends&lt;/a&gt;。例如，这是您包括 &lt;code&gt;github&lt;/code&gt; npm软件包的方法：</target>
        </trans-unit>
        <trans-unit id="2d679b0fb2f845898bff4caa571974dfc4cc8a3c" translate="yes" xml:space="preserve">
          <source>Meteor packages can include NPM packages and Cordova plugins by using &lt;code&gt;Npm.depends&lt;/code&gt; and &lt;code&gt;Cordova.depends&lt;/code&gt; in the &lt;code&gt;package.js&lt;/code&gt; file.</source>
          <target state="translated">流星包可以通过使用包括NPM包和科尔多瓦插件 &lt;code&gt;Npm.depends&lt;/code&gt; 和 &lt;code&gt;Cordova.depends&lt;/code&gt; 在 &lt;code&gt;package.js&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="09e6ba951b93be1b2a299362c4d4b9cb62fef2ad" translate="yes" xml:space="preserve">
          <source>Meteor packages can provide build plugins - programs that integrate with the build tool Isobuild used to compile and bundle your application.</source>
          <target state="translated">Meteor包可以提供构建插件--与构建工具Isobuild集成的程序,用于编译和捆绑你的应用程序。</target>
        </trans-unit>
        <trans-unit id="c1bdd06e18dbd9296aa1ba3318bfb440a5026638" translate="yes" xml:space="preserve">
          <source>Meteor packages that this plugin uses, independent of the packages specified in &lt;a href=&quot;#pack_onUse&quot;&gt;api.onUse&lt;/a&gt;.</source>
          <target state="translated">此插件使用的Meteor软件包，独立于&lt;a href=&quot;#pack_onUse&quot;&gt;api.onUse中&lt;/a&gt;指定的软件包。</target>
        </trans-unit>
        <trans-unit id="e25684491469c9f03cbfa6207259e67da6e24280" translate="yes" xml:space="preserve">
          <source>Meteor provides &lt;strong&gt;full stack reactivity&lt;/strong&gt;, allowing your UI to seamlessly reflect the true state of the world with minimal development effort.</source>
          <target state="translated">Meteor提供了&lt;strong&gt;完整的堆栈反应性&lt;/strong&gt;，使您的UI可以以最少的开发工作量无缝地反映世界的真实状态。</target>
        </trans-unit>
        <trans-unit id="d65bc85012972d54322447846f125d4d5a67100e" translate="yes" xml:space="preserve">
          <source>Meteor reads a &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;&lt;code&gt;mobile-config.js&lt;/code&gt;&lt;/a&gt; file in the root of your app directory during build, and uses the settings specified there to generate Cordova&amp;rsquo;s &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html&quot;&gt;&lt;code&gt;config.xml&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在构建期间，Meteor会在您的应用程序目录的根目录中读取&lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt; &lt;code&gt;mobile-config.js&lt;/code&gt; &lt;/a&gt;文件，并使用在那里指定的设置来生成Cordova的&lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html&quot;&gt; &lt;code&gt;config.xml&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6511c3efed7f3caaabd83d68361e0a813a362fd9" translate="yes" xml:space="preserve">
          <source>Meteor releases are divided into tracks. While only MDG members can publish to the default Meteor track, anyone can create a track of their own and publish to it. Running &lt;code&gt;meteor update&lt;/code&gt; without specifying the &lt;code&gt;--release&lt;/code&gt; option will not cause the user to switch tracks.</source>
          <target state="translated">流星释放分为多个轨道。虽然只有MDG成员可以发布到默认的Meteor轨道，但是任何人都可以创建自己的轨道并将其发布。在不指定 &lt;code&gt;--release&lt;/code&gt; 选项的情况下运行 &lt;code&gt;meteor update&lt;/code&gt; 不会导致用户切换音轨。</target>
        </trans-unit>
        <trans-unit id="7a58b4455aee0385024d8fc645bf4a00b41318c7" translate="yes" xml:space="preserve">
          <source>Meteor resources</source>
          <target state="translated">流星资源</target>
        </trans-unit>
        <trans-unit id="bcff1bfda93f22e8cff6cb981d9efe91fa193399" translate="yes" xml:space="preserve">
          <source>Meteor stores data in &lt;em&gt;collections&lt;/em&gt;. To get started, declare a collection with &lt;code&gt;new Mongo.Collection&lt;/code&gt;.</source>
          <target state="translated">流星将数据存储在&lt;em&gt;集合中&lt;/em&gt;。首先，使用 &lt;code&gt;new Mongo.Collection&lt;/code&gt; 声明一个集合。</target>
        </trans-unit>
        <trans-unit id="671497c52a053216f31c850cc2fae3ce817f1a74" translate="yes" xml:space="preserve">
          <source>Meteor supports &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;&lt;/a&gt;, which provide a straightforward approach to asynchronously wait for the module to be ready without the need to provide a callback:</source>
          <target state="translated">Meteor支持&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; &lt;/a&gt;，它们提供了一种简单的方法来异步等待模块准备就绪，而无需提供回调：</target>
        </trans-unit>
        <trans-unit id="82b0c6e9fee08d7d3e163629dd1571bc7b693ba1" translate="yes" xml:space="preserve">
          <source>Meteor supports &lt;a href=&quot;https://www.meteor.com/install&quot;&gt;OS X, Windows, and Linux&lt;/a&gt;.</source>
          <target state="translated">Meteor支持&lt;a href=&quot;https://www.meteor.com/install&quot;&gt;OS X，Windows和Linux&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8646d034a0e9c771564258a5cde50fca9007a59a" translate="yes" xml:space="preserve">
          <source>Meteor supports all built-in EJSON data types in publishers, method arguments and results, Mongo databases, and &lt;a href=&quot;#session&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; variables.</source>
          <target state="translated">Meteor支持发布者中的所有内置EJSON数据类型，方法参数和结果，Mongo数据库以及&lt;a href=&quot;#session&quot;&gt; &lt;code&gt;Session&lt;/code&gt; &lt;/a&gt;变量。</target>
        </trans-unit>
        <trans-unit id="e644c60aa896d13c6207e6898170e1a196b3d5a2" translate="yes" xml:space="preserve">
          <source>Meteor supports hot code push on both browser and mobile clients, but the process on mobile is a bit different. In a browser, reloading the app will re-request assets from the server, and the server will respond with the most recent versions. Because Cordova apps rely on locally stored assets however, hot code push on mobile is a two step process:</source>
          <target state="translated">Meteor支持在浏览器和移动客户端上进行热码推送,但移动端流程有些不同。在浏览器中,重新加载应用会从服务器上重新请求资产,服务器会用最新的版本来响应。不过由于Cordova应用依赖于本地存储的资产,因此移动端热代码推送是一个两步走的过程。</target>
        </trans-unit>
        <trans-unit id="c3aec489fa142ac02b682826632843eb77923a0b" translate="yes" xml:space="preserve">
          <source>Meteor tracks the database writes performed by methods, both on the client and the server, and does not invoke &lt;code&gt;asyncCallback&lt;/code&gt; until all of the server&amp;rsquo;s writes replace the stub&amp;rsquo;s writes in the local cache. In some cases, there can be a lag between the method&amp;rsquo;s return value being available and the writes being visible: for example, if another method still outstanding wrote to the same document, the local cache may not be up to date until the other method finishes as well. If you want to process the method&amp;rsquo;s result as soon as it arrives from the server, even if the method&amp;rsquo;s writes are not available yet, you can specify an &lt;code&gt;onResultReceived&lt;/code&gt; callback to &lt;a href=&quot;#meteor_apply&quot;&gt;&lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Meteor跟踪客户端和服务器上由方法执行的数据库写入，并且直到所有服务器的写入都替换了本地缓存中的存根的写入后， &lt;code&gt;asyncCallback&lt;/code&gt; 才会调用asyncCallback。在某些情况下，该方法的返回值可用和可见的写入之间可能会有时滞：例如，如果另一个方法仍未完成写入同一文档的操作，则本地缓存可能不会更新，直到另一个方法完成也一样如果您希望在方法结果从服务器到达后立即进行处理，即使该方法的写操作尚不可用，也可以为&lt;a href=&quot;#meteor_apply&quot;&gt; &lt;code&gt;Meteor.apply&lt;/code&gt; &lt;/a&gt;指定一个 &lt;code&gt;onResultReceived&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="f31fc630a33738a8f1baff2cd0d6c9cb5fe8460f" translate="yes" xml:space="preserve">
          <source>Meteor uses &lt;strong&gt;data on the wire&lt;/strong&gt;, meaning the server sends data, not HTML, and the client renders it.</source>
          <target state="translated">流星使用&lt;strong&gt;网络上的数据&lt;/strong&gt;，这意味着服务器发送数据而不是HTML，而客户端呈现数据。</target>
        </trans-unit>
        <trans-unit id="eddf000e5c12d8489ce3a16f29274bcb4fa097d9" translate="yes" xml:space="preserve">
          <source>Meteor uses WKWebView by default, on both iOS 8 and iOS 9. WKWebView is part of the modern WebKit API introduced in iOS 8, and replaces UIWebView, which has been in iOS from the beginning. Its main benefit is that it runs in a separate process, allowing for much higher JavaScript performance (3&amp;ndash;4x in some benchmarks!) because it can take advantage of Just-In-Time compilation (which UIWebView, running in the same process as your app, cannot do for security reasons).</source>
          <target state="translated">Meteor默认在iOS 8和iOS 9上都使用WKWebView。WKWebView是iOS 8中引入的现代WebKit API的一部分，并取代了从一开始就在iOS中使用的UIWebView。它的主要优点是它在单独的进程中运行，从而可以提高JavaScript性能（在某些基准测试中是3-4倍！），因为它可以利用即时编译（UIWebView与您在同一进程中运行）的优势。应用程序，出于安全原因无法执行）。</target>
        </trans-unit>
        <trans-unit id="c67fb04e65af57e0942f1c6e9f69d0780976afc2" translate="yes" xml:space="preserve">
          <source>Meteor uses global environment variables to keep track of things like the current request&amp;rsquo;s user. To make sure these variables have the right values, you need to use &lt;code&gt;Meteor.setTimeout&lt;/code&gt; instead of &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;Meteor.setInterval&lt;/code&gt; instead of &lt;code&gt;setInterval&lt;/code&gt;.</source>
          <target state="translated">流星使用全局环境变量来跟踪诸如当前请求的用户之类的事件。为了确保这些变量具有正确的值，您需要使用 &lt;code&gt;Meteor.setTimeout&lt;/code&gt; 而不是 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;Meteor.setInterval&lt;/code&gt; 而不是 &lt;code&gt;setInterval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="807920c1371b318801a7af6bdc5d02f77b93ffc1" translate="yes" xml:space="preserve">
          <source>Meteor will emit a warning message if you call &lt;code&gt;Meteor.publish&lt;/code&gt; in a project that includes the &lt;code&gt;autopublish&lt;/code&gt; package. Your publish function will still work.</source>
          <target state="translated">如果在包含 &lt;code&gt;autopublish&lt;/code&gt; 程序包的项目中调用 &lt;code&gt;Meteor.publish&lt;/code&gt; ，Meteor将发出警告消息。您的发布功能仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="8119116d05b89e0fbaeffbd333b61e6f70dd0faf" translate="yes" xml:space="preserve">
          <source>Meteor will load all files outside of any directory named &lt;code&gt;imports/&lt;/code&gt; in the application using the &lt;a href=&quot;#load-order&quot;&gt;default file load order&lt;/a&gt; rules (also called &amp;ldquo;eager evaluation or loading&amp;rdquo;). It is recommended that you create exactly two eagerly loaded files, &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt;, in order to define explicit entry points for both the client and the server. Meteor ensures that any file in any directory named &lt;code&gt;server/&lt;/code&gt; will only be available on the server, and likewise for files in any directory named &lt;code&gt;client/&lt;/code&gt;. This also precludes trying to &lt;code&gt;import&lt;/code&gt; a file to be used on the server from any directory named &lt;code&gt;client/&lt;/code&gt; even if it is nested in an &lt;code&gt;imports/&lt;/code&gt; directory and vice versa for importing client files from &lt;code&gt;server/&lt;/code&gt;.</source>
          <target state="translated">流星将使用&lt;a href=&quot;#load-order&quot;&gt;默认的文件加载顺序&lt;/a&gt;规则（也称为&amp;ldquo;急切评估或加载&amp;rdquo;）在应用程序中的任何名为 &lt;code&gt;imports/&lt;/code&gt; 目录之外加载所有文件。建议您只创建两个急切加载的文件 &lt;code&gt;client/main.js&lt;/code&gt; 和 &lt;code&gt;server/main.js&lt;/code&gt; ，以便为客户端和服务器定义显式入口点。 Meteor确保任何名为 &lt;code&gt;server/&lt;/code&gt; 目录中的任何文件仅在服务器上可用，并且同样适用于任何名为 &lt;code&gt;client/&lt;/code&gt; 目录中的文件。这也排除了尝试从名为 &lt;code&gt;client/&lt;/code&gt; 任何目录中 &lt;code&gt;import&lt;/code&gt; 要在服务器上使用的文件的方法，即使该文件嵌套在 &lt;code&gt;imports/&lt;/code&gt; 目录，反之亦然，用于从 &lt;code&gt;server/&lt;/code&gt; 导入客户端文件。</target>
        </trans-unit>
        <trans-unit id="b6829e9613e070e75617b5ccb27a68d37a423231" translate="yes" xml:space="preserve">
          <source>Meteor&amp;rsquo;s accounts system, as implemented in &lt;code&gt;accounts-base&lt;/code&gt;, also includes a database collection and generic functions for getting data about users.</source>
          <target state="translated">Meteor的帐户系统（在 &lt;code&gt;accounts-base&lt;/code&gt; 中实现）还包括一个数据库集合和用于获取有关用户数据的通用功能。</target>
        </trans-unit>
        <trans-unit id="08c6f3fa20a8415ad65b0f5c79ead6da92588e69" translate="yes" xml:space="preserve">
          <source>Meteor&amp;rsquo;s package system relies heavily on &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;, or SemVer. When one package declares a dependency on another, it always comes with a version constraint. These version constraints are then solved by Meteor&amp;rsquo;s industrial-grade Version Solver to arrive at a set of package versions that meet all of the requirements, or display a helpful error if there is no solution.</source>
          <target state="translated">流星的软件包系统严重依赖于&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&lt;/a&gt;（SemVer）。当一个程序包声明对另一个程序包的依赖性时，它总是带有版本约束。然后，由Meteor的工业级版本求解器解决这些版本约束，以得到满足所有要求的一组软件包版本，如果没有解决方案，则显示有用的错误。</target>
        </trans-unit>
        <trans-unit id="af0362ea71023af3e615464c8f037487143585e4" translate="yes" xml:space="preserve">
          <source>Meteor.Error for general runtime errors</source>
          <target state="translated">Meteor.Error用于一般运行时错误</target>
        </trans-unit>
        <trans-unit id="4aadc3fc5b546a289dad2f0693f7b66e72441cc5" translate="yes" xml:space="preserve">
          <source>Meteor.Error()</source>
          <target state="translated">Meteor.Error()</target>
        </trans-unit>
        <trans-unit id="d4cc1e7ed1b973f97dd6714895ce83c51675ced2" translate="yes" xml:space="preserve">
          <source>Meteor.absoluteUrl()</source>
          <target state="translated">Meteor.absoluteUrl()</target>
        </trans-unit>
        <trans-unit id="0d8773377cda7d8a99cb875093b32741009b0ca4" translate="yes" xml:space="preserve">
          <source>Meteor.apply()</source>
          <target state="translated">Meteor.apply()</target>
        </trans-unit>
        <trans-unit id="77dad143857566d01a653381fbb8d025e549ad3c" translate="yes" xml:space="preserve">
          <source>Meteor.call()</source>
          <target state="translated">Meteor.call()</target>
        </trans-unit>
        <trans-unit id="0939c90d1f7dd43c8654524f3f5c33400573a1bd" translate="yes" xml:space="preserve">
          <source>Meteor.clearInterval()</source>
          <target state="translated">Meteor.clearInterval()</target>
        </trans-unit>
        <trans-unit id="c237c633cb43c07eee5b60f480864de2f1d97899" translate="yes" xml:space="preserve">
          <source>Meteor.clearTimeout()</source>
          <target state="translated">Meteor.clearTimeout()</target>
        </trans-unit>
        <trans-unit id="7e07ea9e9425fb47f6bc102e2a17e349bc70455f" translate="yes" xml:space="preserve">
          <source>Meteor.defer()</source>
          <target state="translated">Meteor.defer()</target>
        </trans-unit>
        <trans-unit id="8fc572e07173895dbea5891f0d979f9e387f680b" translate="yes" xml:space="preserve">
          <source>Meteor.disconnect()</source>
          <target state="translated">Meteor.disconnect()</target>
        </trans-unit>
        <trans-unit id="561f405850c385bce5b2df81da1807aeed2aaa67" translate="yes" xml:space="preserve">
          <source>Meteor.isClient</source>
          <target state="translated">Meteor.isClient</target>
        </trans-unit>
        <trans-unit id="ae034b221300628241c91a1f26acfd358aaab4d7" translate="yes" xml:space="preserve">
          <source>Meteor.isCordova</source>
          <target state="translated">Meteor.isCordova</target>
        </trans-unit>
        <trans-unit id="3942ec8d6ecd3d0b6937b7104aae67dea924f411" translate="yes" xml:space="preserve">
          <source>Meteor.isDevelopment</source>
          <target state="translated">Meteor.isDevelopment</target>
        </trans-unit>
        <trans-unit id="5a82fc98812d1aa942b6fb563821412553a06334" translate="yes" xml:space="preserve">
          <source>Meteor.isProduction</source>
          <target state="translated">Meteor.isProduction</target>
        </trans-unit>
        <trans-unit id="a6bbc79e7d7dc097558d3c953b18e6a076540d20" translate="yes" xml:space="preserve">
          <source>Meteor.isServer</source>
          <target state="translated">Meteor.isServer</target>
        </trans-unit>
        <trans-unit id="6d7458ce16fd2ffb534430ce85a633fa579c0762" translate="yes" xml:space="preserve">
          <source>Meteor.loggingIn()</source>
          <target state="translated">Meteor.loggingIn()</target>
        </trans-unit>
        <trans-unit id="e2113779a4855fb021df229c053eac1ea2561724" translate="yes" xml:space="preserve">
          <source>Meteor.loginWith&amp;lt;ExternalService&amp;gt;()</source>
          <target state="translated">Meteor.loginWith&amp;lt;ExternalService&amp;gt;()</target>
        </trans-unit>
        <trans-unit id="e1a14c40ea7ded5931f7942e186aee3207bf8c5f" translate="yes" xml:space="preserve">
          <source>Meteor.loginWithPassword()</source>
          <target state="translated">Meteor.loginWithPassword()</target>
        </trans-unit>
        <trans-unit id="e344707515a186f9974ebcb912fe7c662420252a" translate="yes" xml:space="preserve">
          <source>Meteor.logout()</source>
          <target state="translated">Meteor.logout()</target>
        </trans-unit>
        <trans-unit id="3a714634c44fa5d73a29e5df69bda19b241a7f79" translate="yes" xml:space="preserve">
          <source>Meteor.logoutOtherClients()</source>
          <target state="translated">Meteor.logoutOtherClients()</target>
        </trans-unit>
        <trans-unit id="e75691cc5f35d016e0cd07c5c5d528f7a1617966" translate="yes" xml:space="preserve">
          <source>Meteor.methods()</source>
          <target state="translated">Meteor.methods()</target>
        </trans-unit>
        <trans-unit id="900b1430563c5681e21cfe8770d26c75a9392406" translate="yes" xml:space="preserve">
          <source>Meteor.onConnection()</source>
          <target state="translated">Meteor.onConnection()</target>
        </trans-unit>
        <trans-unit id="fb0079d862912ab78cf8c5163fe37f8a60885bf1" translate="yes" xml:space="preserve">
          <source>Meteor.publish()</source>
          <target state="translated">Meteor.publish()</target>
        </trans-unit>
        <trans-unit id="d99872c9f02080c0aae3377dde058fc8f6d2889a" translate="yes" xml:space="preserve">
          <source>Meteor.reconnect()</source>
          <target state="translated">Meteor.reconnect()</target>
        </trans-unit>
        <trans-unit id="64dd1fa0e20e44a1fb38600980f9b0d37c1cd709" translate="yes" xml:space="preserve">
          <source>Meteor.release</source>
          <target state="translated">Meteor.release</target>
        </trans-unit>
        <trans-unit id="e64925f5a980a2252e298baed01b37aaa61465ff" translate="yes" xml:space="preserve">
          <source>Meteor.setInterval()</source>
          <target state="translated">Meteor.setInterval()</target>
        </trans-unit>
        <trans-unit id="815694ee82ceecd72d9e93ab60fae2eedd1a0c6e" translate="yes" xml:space="preserve">
          <source>Meteor.setTimeout()</source>
          <target state="translated">Meteor.setTimeout()</target>
        </trans-unit>
        <trans-unit id="ba2102fbf82f103db1da7582866ed3ada03dc121" translate="yes" xml:space="preserve">
          <source>Meteor.settings</source>
          <target state="translated">Meteor.settings</target>
        </trans-unit>
        <trans-unit id="2d4b8695404782424e7b3c2f3f61129f3a958c49" translate="yes" xml:space="preserve">
          <source>Meteor.startup()</source>
          <target state="translated">Meteor.startup()</target>
        </trans-unit>
        <trans-unit id="a61e3207119d6f273986a69802bd7fe15ae58f8d" translate="yes" xml:space="preserve">
          <source>Meteor.status()</source>
          <target state="translated">Meteor.status()</target>
        </trans-unit>
        <trans-unit id="77464e4fc05769aabd6e39abbc88d173567bd689" translate="yes" xml:space="preserve">
          <source>Meteor.subscribe()</source>
          <target state="translated">Meteor.subscribe()</target>
        </trans-unit>
        <trans-unit id="7deff7923efc426b5111ec4f7c8a82969854f577" translate="yes" xml:space="preserve">
          <source>Meteor.user()</source>
          <target state="translated">Meteor.user()</target>
        </trans-unit>
        <trans-unit id="63e289df9644b4b356504bb7e26d3e2f6cd38704" translate="yes" xml:space="preserve">
          <source>Meteor.userId()</source>
          <target state="translated">Meteor.userId()</target>
        </trans-unit>
        <trans-unit id="36595238e1b0a055672957d3d82c24e43ee546a8" translate="yes" xml:space="preserve">
          <source>Meteor.users</source>
          <target state="translated">Meteor.users</target>
        </trans-unit>
        <trans-unit id="bc5a36619b50e1d38c2d24124df237c51a7ad136" translate="yes" xml:space="preserve">
          <source>Meteor.wrapAsync()</source>
          <target state="translated">Meteor.wrapAsync()</target>
        </trans-unit>
        <trans-unit id="5bbe6124b80ed6bbe9b9bb1bd6b9cb332918a336" translate="yes" xml:space="preserve">
          <source>Method and publication names should be camelCased, and namespaced to the module they are in:</source>
          <target state="translated">方法和出版物的名称应该用camelCasing,并与它们所在的模块同名同距。</target>
        </trans-unit>
        <trans-unit id="18754adb324b714a265e93bb8a9892892ff9ee0a" translate="yes" xml:space="preserve">
          <source>Method arguments</source>
          <target state="translated">方法参数</target>
        </trans-unit>
        <trans-unit id="622bbe9f33bc995ded33a1832ef7920b26b24a56" translate="yes" xml:space="preserve">
          <source>Method call lifecycle</source>
          <target state="translated">方法调用生命周期</target>
        </trans-unit>
        <trans-unit id="f071fb1667befe69dfec18039004040034de7107" translate="yes" xml:space="preserve">
          <source>Method retries</source>
          <target state="translated">方法重试</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d750257e6d0b55cfcf2687b67ae92d5cc4894132" translate="yes" xml:space="preserve">
          <source>Methods always run and return in order</source>
          <target state="translated">方法总是按顺序运行和返回</target>
        </trans-unit>
        <trans-unit id="16415baf3677dc9253511aa3b73013aaa2707cf0" translate="yes" xml:space="preserve">
          <source>Methods and publications</source>
          <target state="translated">方法和出版物</target>
        </trans-unit>
        <trans-unit id="a866114a75b2af0c0a38c76418558d7e8e1339b4" translate="yes" xml:space="preserve">
          <source>Methods and publish functions that do not need to validate their arguments can simply run &lt;code&gt;check(arguments, [Match.Any])&lt;/code&gt; to satisfy the &lt;code&gt;audit-argument-checks&lt;/code&gt; coverage checker.</source>
          <target state="translated">不需要验证其参数的方法和发布功能可以简单地运行 &lt;code&gt;check(arguments, [Match.Any])&lt;/code&gt; 来满足 &lt;code&gt;audit-argument-checks&lt;/code&gt; 覆盖率检查器。</target>
        </trans-unit>
        <trans-unit id="508d1301350f0abb3ae65e31982d83b9ca4d5c67" translate="yes" xml:space="preserve">
          <source>Methods are Meteor&amp;rsquo;s remote procedure call (RPC) system, used to save user input events and data that come from the client. If you&amp;rsquo;re familiar with REST APIs or HTTP, you can think of them like POST requests to your server, but with many nice features optimized for building a modern web application. Later on in this article, we&amp;rsquo;ll go into detail about some of the benefits you get from Methods that you wouldn&amp;rsquo;t get from an HTTP endpoint.</source>
          <target state="translated">方法是Meteor的远程过程调用（RPC）系统，用于保存用户输入事件和来自客户端的数据。如果您熟悉REST API或HTTP，则可以将它们视为对服务器的POST请求，但具有许多为构建现代Web应用程序而优化的出色功能。在本文的后面，我们将详细介绍从HTTP端点无法获得的&amp;ldquo;方法&amp;rdquo;带来的一些好处。</target>
        </trans-unit>
        <trans-unit id="061098e399b34cdada88994d6cbcfc4b02827458" translate="yes" xml:space="preserve">
          <source>Methods are remote functions that Meteor clients can invoke with &lt;a href=&quot;#Meteor-call&quot;&gt;&lt;code&gt;Meteor.call&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">方法是Meteor客户端可以通过&lt;a href=&quot;#Meteor-call&quot;&gt; &lt;code&gt;Meteor.call&lt;/code&gt; &lt;/a&gt;调用的远程函数。</target>
        </trans-unit>
        <trans-unit id="fb280178f7d6e3321a3a09a78e9ece3f0a79a21d" translate="yes" xml:space="preserve">
          <source>Methods are the way your Meteor server accepts inputs and data from the outside world, so it&amp;rsquo;s natural that they are the most important topic for security. If you don&amp;rsquo;t properly secure your Methods, users can end up modifying your database in unexpected ways - editing other people&amp;rsquo;s documents, deleting data, or messing up your database schema causing the app to crash.</source>
          <target state="translated">方法是您的Meteor服务器从外界接收输入和数据的方式，因此自然而然地，它们是安全性中最重要的主题。如果您不能适当地保护自己的方法，则用户最终可能会以意想不到的方式修改数据库-编辑其他人的文档，删除数据或弄乱数据库架构，导致应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="01f91c4cc82c28ac4c7207da72cf66a7b7ea7324" translate="yes" xml:space="preserve">
          <source>Methods can be useful to fetch the result of a complex computation from the server that doesn&amp;rsquo;t need to update when the server data changes. The biggest disadvantage of fetching data through Methods is that the data won&amp;rsquo;t be automatically loaded into Minimongo, Meteor&amp;rsquo;s client-side data cache, so you&amp;rsquo;ll need to manage the lifecycle of that data manually.</source>
          <target state="translated">方法可以用于从服务器获取复杂计算的结果，该服务器不需要在服务器数据更改时进行更新。通过Methods获取数据的最大缺点是，数据不会自动加载到Meteor的客户端数据缓存Minimongo中，因此您需要手动管理该数据的生命周期。</target>
        </trans-unit>
        <trans-unit id="e336436c208c43eb9921e0cf266b407a85c564a2" translate="yes" xml:space="preserve">
          <source>Methods use synchronous-style APIs, but are non-blocking</source>
          <target state="translated">方法使用同步风格的API,但是非阻塞的。</target>
        </trans-unit>
        <trans-unit id="55f90f3f74aa801ab84a7cff0c63efa869fee8bf" translate="yes" xml:space="preserve">
          <source>Migrating from a version older than 1.4?</source>
          <target state="translated">从1.4以上的版本迁移?</target>
        </trans-unit>
        <trans-unit id="e4daf8fb0f30e313a7b35e4b31478bad358e26d0" translate="yes" xml:space="preserve">
          <source>Migrating to Meteor 1.5</source>
          <target state="translated">迁移到Meteor 1.5</target>
        </trans-unit>
        <trans-unit id="f2d76073a74e56240cad448ab8373867d9e1a902" translate="yes" xml:space="preserve">
          <source>Migrating to a new schema</source>
          <target state="translated">迁移到一个新的模式</target>
        </trans-unit>
        <trans-unit id="88d36257186ae5e2f885a7eb78bc96e6d09472eb" translate="yes" xml:space="preserve">
          <source>Migrating unencrypted user tokens</source>
          <target state="translated">迁移未加密的用户令牌</target>
        </trans-unit>
        <trans-unit id="7a3ea5ae4bbcb0b6c68d07df01c97a3626e4c95d" translate="yes" xml:space="preserve">
          <source>Minification</source>
          <target state="translated">Minification</target>
        </trans-unit>
        <trans-unit id="8d0e818b697016e40293625615945bcac317f180" translate="yes" xml:space="preserve">
          <source>Minification usually happens when you &lt;code&gt;meteor deploy&lt;/code&gt; or &lt;code&gt;meteor build&lt;/code&gt; your app. If you have an error in production that you suspect is related to minification, you can run the minified version of your app locally with &lt;code&gt;meteor --production&lt;/code&gt;.</source>
          <target state="translated">缩小通常发生在 &lt;code&gt;meteor deploy&lt;/code&gt; 或 &lt;code&gt;meteor build&lt;/code&gt; 应用程序时。如果您怀疑生产中存在与缩小相关的错误，则可以使用 &lt;code&gt;meteor --production&lt;/code&gt; 在本地运行应用的缩小版本。</target>
        </trans-unit>
        <trans-unit id="3146f9e3c154ef4dd9ed27afbf87d9638c94ca49" translate="yes" xml:space="preserve">
          <source>Minifier plugin - compiles lots of built CSS or JS files into one or more minified files, for example &lt;code&gt;standard-minifiers&lt;/code&gt;. Only one minifier can handle each of &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;css&lt;/code&gt;.</source>
          <target state="translated">Minifier插件-将许多内置的CSS或JS文件编译为一个或多个缩小的文件，例如 &lt;code&gt;standard-minifiers&lt;/code&gt; 。 &lt;code&gt;js&lt;/code&gt; 和 &lt;code&gt;css&lt;/code&gt; 中的每一个都只能使用一个minifier 。</target>
        </trans-unit>
        <trans-unit id="c3343772e496a59c3d2fba9fe4453e7fbbfc5dab" translate="yes" xml:space="preserve">
          <source>Minifiers</source>
          <target state="translated">Minifiers</target>
        </trans-unit>
        <trans-unit id="2c3dfe2b2c5231090cbc7c87aa86fe2d197eaced" translate="yes" xml:space="preserve">
          <source>Minifiers run last after the sources has been compiled and JavaScript code has been linked. Minifiers are only ran for the client programs (&lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;web.cordova&lt;/code&gt;).</source>
          <target state="translated">压缩程序在编译源和链接JavaScript代码之后最后运行。缩小器仅针对客户端程序（ &lt;code&gt;web.browser&lt;/code&gt; 和 &lt;code&gt;web.cordova&lt;/code&gt; ）运行。</target>
        </trans-unit>
        <trans-unit id="42fc784f35bb827de39e489a4fcb483804ace508" translate="yes" xml:space="preserve">
          <source>Minify JavaScript and CSS files. Can also include concatenation of all files.</source>
          <target state="translated">对JavaScript和CSS文件进行最小化。也可以包括所有文件的连接。</target>
        </trans-unit>
        <trans-unit id="c5493b32c30d73b72b0cbdedacc87c5f4057323e" translate="yes" xml:space="preserve">
          <source>Minimongo doesn&amp;rsquo;t currently have indexes. It&amp;rsquo;s rare for this to be an issue, since it&amp;rsquo;s unusual for a client to have enough data that an index is worthwhile.</source>
          <target state="translated">Minimongo当前没有索引。这很少是一个问题，因为对于客户而言，拥有足够的数据值得索引是很罕见的。</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">缺页</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="190ebeb2bab5571e36599c42851b575528e7a0ee" translate="yes" xml:space="preserve">
          <source>Mobile Configuration</source>
          <target state="translated">移动配置</target>
        </trans-unit>
        <trans-unit id="ad8215f6e4b427525de4a97bb7b22e0ced268f2a" translate="yes" xml:space="preserve">
          <source>Mocking the database</source>
          <target state="translated">嘲讽数据库</target>
        </trans-unit>
        <trans-unit id="b174cc9a3c071b04298bd329afff0b7f4c1f88cb" translate="yes" xml:space="preserve">
          <source>Modify documents that match &lt;code&gt;selector&lt;/code&gt; according to &lt;code&gt;modifier&lt;/code&gt; (see &lt;a href=&quot;#modifiers&quot;&gt;modifier documentation&lt;/a&gt;).</source>
          <target state="translated">修改文档匹配 &lt;code&gt;selector&lt;/code&gt; 根据 &lt;code&gt;modifier&lt;/code&gt; （见&lt;a href=&quot;#modifiers&quot;&gt;修改文档&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0f6b56411a7ed678e49b6ed317fd66480700469d" translate="yes" xml:space="preserve">
          <source>Modify documents that match &lt;code&gt;selector&lt;/code&gt; according to &lt;code&gt;modifier&lt;/code&gt;, or insert a document if no documents were modified. &lt;code&gt;upsert&lt;/code&gt; is the same as calling &lt;code&gt;update&lt;/code&gt; with the &lt;code&gt;upsert&lt;/code&gt; option set to true, except that the return value of &lt;code&gt;upsert&lt;/code&gt; is an object that contain the keys &lt;code&gt;numberAffected&lt;/code&gt; and &lt;code&gt;insertedId&lt;/code&gt;. (&lt;code&gt;update&lt;/code&gt; returns only the number of affected documents.)</source>
          <target state="translated">根据 &lt;code&gt;modifier&lt;/code&gt; 修改与 &lt;code&gt;selector&lt;/code&gt; 匹配的文档，如果没有文档被修改，则插入一个文档。 &lt;code&gt;upsert&lt;/code&gt; 是与调用 &lt;code&gt;update&lt;/code&gt; 与 &lt;code&gt;upsert&lt;/code&gt; 选项设置为true，不同之处在于返回值 &lt;code&gt;upsert&lt;/code&gt; 是包含密钥的对象 &lt;code&gt;numberAffected&lt;/code&gt; 和 &lt;code&gt;insertedId&lt;/code&gt; 。 （ &lt;code&gt;update&lt;/code&gt; 仅返回受影响的文档数。）</target>
        </trans-unit>
        <trans-unit id="db986bd327f629e2a385aadbaf1f352c2c4e6f94" translate="yes" xml:space="preserve">
          <source>Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys &lt;code&gt;numberAffected&lt;/code&gt; (the number of documents modified) and &lt;code&gt;insertedId&lt;/code&gt; (the unique _id of the document that was inserted, if any).</source>
          <target state="translated">修改集合中的一个或多个文档，如果找不到匹配的文档，则插入一个或多个文档。返回一个对象，其键值为 &lt;code&gt;numberAffected&lt;/code&gt; （已修改的文档数）和 &lt;code&gt;insertedId&lt;/code&gt; （已插入的文档的唯一_id，如果有）。</target>
        </trans-unit>
        <trans-unit id="1e384a3ad74ff8496f32ecac56c82471e2e8014d" translate="yes" xml:space="preserve">
          <source>Modify one or more documents in the collection. Returns the number of matched documents.</source>
          <target state="translated">修改集合中的一个或多个文档。返回匹配文档的数量。</target>
        </trans-unit>
        <trans-unit id="75e24952216a7b88df3445cd5dc18c966ae272a5" translate="yes" xml:space="preserve">
          <source>Modular application structure</source>
          <target state="translated">模块化应用结构</target>
        </trans-unit>
        <trans-unit id="18c5a8e973a1250af694a05743d210ba96778b85" translate="yes" xml:space="preserve">
          <source>Modular package structure</source>
          <target state="translated">模块化包装结构</target>
        </trans-unit>
        <trans-unit id="6ff315972a626a7a0f17ca1b3f61c033038b8957" translate="yes" xml:space="preserve">
          <source>Modules and CoffeeScript</source>
          <target state="translated">模块和CoffeeScript</target>
        </trans-unit>
        <trans-unit id="32300c4f236449c8a9a0f8cb0e2339a88cd67b27" translate="yes" xml:space="preserve">
          <source>Momentum works by overriding the way that child HTML elements appear and disappear. In this case, when the list component goes into the &lt;code&gt;editing&lt;/code&gt; state, the &lt;code&gt;.nav-group&lt;/code&gt; disappears, and the &lt;code&gt;form&lt;/code&gt; appears. Momentum takes care of the job of making sure that both items fade, making the change a lot clearer.</source>
          <target state="translated">动量通过覆盖子HTML元素的出现和消失方式来起作用。在这种情况下，当列表组件进入 &lt;code&gt;editing&lt;/code&gt; 状态时， &lt;code&gt;.nav-group&lt;/code&gt; 消失，并且出现 &lt;code&gt;form&lt;/code&gt; 。动量负责确保两个项目都褪色，使更改更清晰。</target>
        </trans-unit>
        <trans-unit id="dd3816603141611d449f74374acc0b44ea825610" translate="yes" xml:space="preserve">
          <source>Mongo-Style Modifiers</source>
          <target state="translated">蒙哥风格的修改器</target>
        </trans-unit>
        <trans-unit id="426968907ee4c661185189d83fe0b5f3cfe4ea54" translate="yes" xml:space="preserve">
          <source>Mongo-Style Selectors</source>
          <target state="translated">蒙哥风格的选择器</target>
        </trans-unit>
        <trans-unit id="403a96d96cd4007b5f9dba3bc4dc51cf9ad3c7c1" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#allow()</source>
          <target state="translated">Mongo.Collection#allow()</target>
        </trans-unit>
        <trans-unit id="819a964024d9e625cbd73d9b903727928aa11a8b" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#deny()</source>
          <target state="translated">Mongo.Collection#deny()</target>
        </trans-unit>
        <trans-unit id="effa701f500d6f6fc26c55c68172e7698274c35a" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#find()</source>
          <target state="translated">Mongo.Collection#find()</target>
        </trans-unit>
        <trans-unit id="b25ba0aa3a8c25104c36dd5166732d2b1de3720d" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#findOne()</source>
          <target state="translated">Mongo.Collection#findOne()</target>
        </trans-unit>
        <trans-unit id="68f08f83473fb80c1a0724efa0147d7af93853d3" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#insert()</source>
          <target state="translated">Mongo.Collection#insert()</target>
        </trans-unit>
        <trans-unit id="09fdeae653fe2cbbad46c318a8bf88b9fb424377" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#rawCollection()</source>
          <target state="translated">Mongo.Collection#rawCollection()</target>
        </trans-unit>
        <trans-unit id="ae611f13bc2ef6134e81b8c8af290aced7ad2c46" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#rawDatabase()</source>
          <target state="translated">Mongo.Collection#rawDatabase()</target>
        </trans-unit>
        <trans-unit id="624d1bd6d1408df952311ca1057dac04b3d19b23" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#remove()</source>
          <target state="translated">Mongo.Collection#remove()</target>
        </trans-unit>
        <trans-unit id="eb3a8211701c9e272329d841283008d86a33ffc0" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#update()</source>
          <target state="translated">Mongo.Collection#update()</target>
        </trans-unit>
        <trans-unit id="56bc62e60f196f47258e9c3402566390231dfcd7" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#upsert()</source>
          <target state="translated">Mongo.Collection#upsert()</target>
        </trans-unit>
        <trans-unit id="af76893984d73b11a88694f1bca0b28566df0845" translate="yes" xml:space="preserve">
          <source>Mongo.Collection()</source>
          <target state="translated">Mongo.Collection()</target>
        </trans-unit>
        <trans-unit id="952816abaef4256fabcc1c106931547087231b58" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#count()</source>
          <target state="translated">Mongo.Cursor#count()</target>
        </trans-unit>
        <trans-unit id="103cc844f56d727d0f983a9e6c60bb85ec4fc64d" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#fetch()</source>
          <target state="translated">Mongo.Cursor#fetch()</target>
        </trans-unit>
        <trans-unit id="ffa461ccfccb5a879bf19a007472b2ec03247603" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#forEach()</source>
          <target state="translated">Mongo.Cursor#forEach()</target>
        </trans-unit>
        <trans-unit id="c98655f9f338bae3092079502ad8371e8a12b858" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#map()</source>
          <target state="translated">Mongo.Cursor#map()</target>
        </trans-unit>
        <trans-unit id="dc67d54326d23a41329032526df8b6f42f2bb48e" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#observe()</source>
          <target state="translated">Mongo.Cursor#observe()</target>
        </trans-unit>
        <trans-unit id="5421802ac115b1c0d4c1b9de931cdd84fd76473d" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#observeChanges()</source>
          <target state="translated">Mongo.Cursor#observeChanges()</target>
        </trans-unit>
        <trans-unit id="3424ac63ca72550911ed0e726d6f41bd0ee6d389" translate="yes" xml:space="preserve">
          <source>Mongo.ObjectID()</source>
          <target state="translated">Mongo.ObjectID()</target>
        </trans-unit>
        <trans-unit id="16666385ac1a46ae21d9d2238177647a13d1010c" translate="yes" xml:space="preserve">
          <source>MongoDB Atlas</source>
          <target state="translated">MongoDB Atlas</target>
        </trans-unit>
        <trans-unit id="bef47610df62f40e6bd8aa528575f38506b563e7" translate="yes" xml:space="preserve">
          <source>MongoDB collections in Meteor</source>
          <target state="translated">Meteor中的MongoDB集合</target>
        </trans-unit>
        <trans-unit id="aeb56478d8b42f0d4156d4ba6e248c2558dd4c58" translate="yes" xml:space="preserve">
          <source>MongoDB options</source>
          <target state="translated">MongoDB选项</target>
        </trans-unit>
        <trans-unit id="55dea6bb872565cbc674dd20c5bb7742909f0eba" translate="yes" xml:space="preserve">
          <source>MongoDB server URL. Give a fully qualified URL (or comma-separated list of URLs) like &lt;code&gt;MONGO_URL=&quot;mongodb://user:password@myserver.com:10139&quot;&lt;/code&gt;. For more information see the &lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string/&quot;&gt;MongoDB docs&lt;/a&gt;.</source>
          <target state="translated">MongoDB服务器URL。提供完全限定的URL（或逗号分隔的URL列表），例如 &lt;code&gt;MONGO_URL=&quot;mongodb://user:password@myserver.com:10139&quot;&lt;/code&gt; 。有关更多信息，请参阅&lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string/&quot;&gt;MongoDB文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa1fe623d0de8fd9f60cdf9f186bfc24c039cc41" translate="yes" xml:space="preserve">
          <source>MongoDB server oplog URL. If you&amp;rsquo;re using a replica set (which you should), construct this url like so: &lt;code&gt;MONGO_OPLOG_URL=&quot;mongodb://user:password@myserver.com:10139/local?replicaSet=(your replica set)&amp;amp;authSource=(your auth source)&quot;&lt;/code&gt;</source>
          <target state="translated">MongoDB服务器操作日志URL。如果您正在使用副本集（应使用该副本集），请按照以下方式构造此网址： &lt;code&gt;MONGO_OPLOG_URL=&quot;mongodb://user:password@myserver.com:10139/local?replicaSet=(your replica set)&amp;amp;authSource=(your auth source)&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1310f92c30dcf2f7680d59a32d87ab2e98e74e18" translate="yes" xml:space="preserve">
          <source>Monitoring &amp;amp; Automated alerting</source>
          <target state="translated">监控和自动警报</target>
        </trans-unit>
        <trans-unit id="d73861ddb7ddc8090ca44a4726071f6383364ad2" translate="yes" xml:space="preserve">
          <source>Monitoring users via analytics</source>
          <target state="translated">通过分析监测用户</target>
        </trans-unit>
        <trans-unit id="c69b02ac94bc0260ecda0498527f0b72ae3828b4" translate="yes" xml:space="preserve">
          <source>Monitoring with Galaxy</source>
          <target state="translated">用Galaxy监测</target>
        </trans-unit>
        <trans-unit id="22342104f67e1d6d2c64d62a7c1eeaf0783fc2f6" translate="yes" xml:space="preserve">
          <source>Monitoring your application</source>
          <target state="translated">监控您的应用程序</target>
        </trans-unit>
        <trans-unit id="695ef98c498ee7dea7f7c357b8b6a71dfac1aad1" translate="yes" xml:space="preserve">
          <source>Most applications do not need to be aware of these Views, but they offer a way to understand and customize Meteor&amp;rsquo;s rendering behavior for more advanced applications and packages.</source>
          <target state="translated">大多数应用程序不需要了解这些视图，但是它们提供了一种方法，可以了解和自定义Meteor对更高级的应用程序和程序包的渲染行为。</target>
        </trans-unit>
        <trans-unit id="942e42b00acfc3b52b50f7e1c5d0e8b80ca997a6" translate="yes" xml:space="preserve">
          <source>Most events bubble up the document tree from their originating element. For example, &lt;code&gt;'click p'&lt;/code&gt; catches a click anywhere in a paragraph, even if the click originated on a link, span, or some other element inside the paragraph. The originating element of the event is available as the &lt;code&gt;target&lt;/code&gt; property, while the element that matched the selector and is currently handling it is called &lt;code&gt;currentTarget&lt;/code&gt;.</source>
          <target state="translated">大多数事件都会从其原始元素中冒出文档树。例如， &lt;code&gt;'click p'&lt;/code&gt; 捕获段落中任何位置的点击，即使该点击源自该段落中的链接，跨度或其他元素。事件的原始元素可用作 &lt;code&gt;target&lt;/code&gt; 属性，而与选择器匹配并正在处理的元素称为 &lt;code&gt;currentTarget&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbb6b6b3be8f8cd31ff05b4428c0ebd753b27b89" translate="yes" xml:space="preserve">
          <source>Mouse click on any element, including a link, button, form control, or div. Use &lt;code&gt;preventDefault()&lt;/code&gt; to prevent a clicked link from being followed. Some ways of activating an element from the keyboard also fire &lt;code&gt;click&lt;/code&gt;.</source>
          <target state="translated">鼠标单击任何元素，包括链接，按钮，表单控件或div。使用 &lt;code&gt;preventDefault()&lt;/code&gt; 防止跟踪单击的链接。通过键盘激活元素的某些方法也会触发 &lt;code&gt;click&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="306ba80fb8f82e7c351b85043f19fc23501191e8" translate="yes" xml:space="preserve">
          <source>Multiple behaviors of this type can be composed by wrapping a template in multiple wrappers, or creating a meta-wrapper that combines multiple wrapper templates.</source>
          <target state="translated">该类型的多个行为可以通过将一个模板包装在多个包装器中,或者创建一个结合多个包装器模板的元包装器来组成。</target>
        </trans-unit>
        <trans-unit id="fa65ee10ceaf1abb58c989309fea8fd944f1eea0" translate="yes" xml:space="preserve">
          <source>Multiple emails</source>
          <target state="translated">多封邮件</target>
        </trans-unit>
        <trans-unit id="85992c4111bef3333392aaf52d57566a52bf0cb4" translate="yes" xml:space="preserve">
          <source>Multiple shells can be attached to the same server. If no server is currently available, &lt;code&gt;meteor shell&lt;/code&gt; will keep trying to connect until it succeeds.</source>
          <target state="translated">可以将多个外壳连接到同一服务器。如果当前没有可用的服务器， &lt;code&gt;meteor shell&lt;/code&gt; 将继续尝试连接，直到成功为止。</target>
        </trans-unit>
        <trans-unit id="448a053124160f6f1059a05225fca6a7656eb0de" translate="yes" xml:space="preserve">
          <source>Mutators can get very long when you want to hook in multiple times.</source>
          <target state="translated">当你想多次钩入时,突变器会变得非常长。</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="translated">名称解析</target>
        </trans-unit>
        <trans-unit id="89ec332a2a605fc21f490b4b2ef3b68bfe2a10cc" translate="yes" xml:space="preserve">
          <source>Name data contexts to template inclusions</source>
          <target state="translated">将数据上下文命名为模板内含物</target>
        </trans-unit>
        <trans-unit id="6a5d1b44bbadf994e1218c12a25565126cc0e1f9" translate="yes" xml:space="preserve">
          <source>Name of a package, or array of package names, with an optional @version component for each.</source>
          <target state="translated">包的名称,或包名的数组,每个包都有一个可选的@版本组件。</target>
        </trans-unit>
        <trans-unit id="fb8d986b0519ac3511f5a1c2767dc3a9c6dfd929" translate="yes" xml:space="preserve">
          <source>Name of method to invoke</source>
          <target state="translated">要调用的方法名称</target>
        </trans-unit>
        <trans-unit id="4b65326960915ff5fc848780e42d693870c8c10b" translate="yes" xml:space="preserve">
          <source>Name of the object to export, or an array of object names.</source>
          <target state="translated">要导出的对象的名称,或对象名称的数组。</target>
        </trans-unit>
        <trans-unit id="fabe4dddf9f588f51f734143664f61d57f7c533b" translate="yes" xml:space="preserve">
          <source>Name of the subscription. Matches the name of the server's &lt;code&gt;publish()&lt;/code&gt; call.</source>
          <target state="translated">订阅名称。与服务器的 &lt;code&gt;publish()&lt;/code&gt; 调用的名称匹配。</target>
        </trans-unit>
        <trans-unit id="dc0542cba9ef0e0b2c3f5af68e5417f36222e7d5" translate="yes" xml:space="preserve">
          <source>Namespacing and CoffeeScript</source>
          <target state="translated">命名间距和CoffeeScript</target>
        </trans-unit>
        <trans-unit id="1a066b19fd168cdbb28dc5446b16019355410536" translate="yes" xml:space="preserve">
          <source>Native features with Cordova plugins</source>
          <target state="translated">使用Cordova插件的本地功能</target>
        </trans-unit>
        <trans-unit id="25739935628f0457ed28044d72717ee02227949d" translate="yes" xml:space="preserve">
          <source>Nested computations are stopped automatically when their enclosing computation is rerun.</source>
          <target state="translated">嵌套计算在其外层计算重新运行时自动停止。</target>
        </trans-unit>
        <trans-unit id="75645b76ce0ad8de07758b3bf2fdaa2b277fee39" translate="yes" xml:space="preserve">
          <source>Nested sub-expressions</source>
          <target state="translated">嵌套的子表达式</target>
        </trans-unit>
        <trans-unit id="9b113cad4ad0a91d8cc7f30db6437cae8d87e0b1" translate="yes" xml:space="preserve">
          <source>Never pass the current user ID as an argument.</source>
          <target state="translated">切勿将当前用户ID作为参数传递。</target>
        </trans-unit>
        <trans-unit id="465642a186a5afb094d1db1577bd2adf570fe62f" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;--production&lt;/code&gt; flag to deploy!</source>
          <target state="translated">切勿使用 &lt;code&gt;--production&lt;/code&gt; 标志进行部署！</target>
        </trans-unit>
        <trans-unit id="0add9c970b96e1af80d63b0bbe09179a767a52d1" translate="yes" xml:space="preserve">
          <source>New users with an email address will receive an address verification email.</source>
          <target state="translated">拥有电子邮件地址的新用户将收到一封地址验证邮件。</target>
        </trans-unit>
        <trans-unit id="c6c601aa6d7f5bd28717d734ead36f86dc2b0fec" translate="yes" xml:space="preserve">
          <source>Next, you can run zipalign on it to optimize the APK:</source>
          <target state="translated">接下来,你可以在上面运行zipalign来优化APK。</target>
        </trans-unit>
        <trans-unit id="4ac595d95e7fe6ec3a6bb510ecf61cb998fb9735" translate="yes" xml:space="preserve">
          <source>No matter which of these modules is imported first, the order of the &lt;code&gt;console.log&lt;/code&gt; calls will always be:</source>
          <target state="translated">无论首先导入哪个模块， &lt;code&gt;console.log&lt;/code&gt; 调用的顺序始终为：</target>
        </trans-unit>
        <trans-unit id="ce1335e03beac0a4b72b6bf3e276532780184d5d" translate="yes" xml:space="preserve">
          <source>Node 0.10.43 for &lt;em&gt;Meteor 1.3.x and earlier&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;流星1.3.x和更早版本的&lt;/em&gt;节点0.10.43&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ecc776838a6f35d6cf71f613eb81adf3346eb9fc" translate="yes" xml:space="preserve">
          <source>Node 4.6.2 for &lt;em&gt;Meteor 1.4.x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;流星1.4.x的&lt;/em&gt;节点4.6.2&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b9a656b4d3308b88b74ba2452e5362c768a0e87" translate="yes" xml:space="preserve">
          <source>Normally, when the Meteor client connects to the server, the first thing it does is pass the &lt;em&gt;login resume token&lt;/em&gt; to re-establish a previous login. However, when these callbacks from the email flow are triggered, the resume token is not sent until your code signals that it has finished handling the request by calling the &lt;code&gt;done&lt;/code&gt; function that is passed into the registered callback. This means that if you were previously logged in as user A, and then you clicked the reset password link for user B, but then you cancelled the password reset flow by calling &lt;code&gt;done()&lt;/code&gt;, the client would log in as A again.</source>
          <target state="translated">通常，当Meteor客户端连接到服务器时，它要做的第一件事就是传递&lt;em&gt;登录恢复令牌&lt;/em&gt;以重新建立以前的登录。但是，当触发来自电子邮件流的这些回调时，将不会发送恢复令牌，直到您的代码通过调用传递到已注册的回调中的 &lt;code&gt;done&lt;/code&gt; 函数来表明信号已完成对请求的处理为止。这意味着，如果您以前以用户A的身份登录，然后单击了用户B的重置密码链接，但是随后通过调用 &lt;code&gt;done()&lt;/code&gt; 取消了密码重置流程，则客户端将再次以A身份登录。</target>
        </trans-unit>
        <trans-unit id="b21b40132e53c70d421f4694203a48f7396a0012" translate="yes" xml:space="preserve">
          <source>Normally, when you make changes (like writing to the database), their impact (like updating the DOM) is delayed until the system is idle. This keeps things predictable &amp;mdash; you can know that the DOM won&amp;rsquo;t go changing out from under your code as it runs. It&amp;rsquo;s also one of the things that makes Meteor fast.</source>
          <target state="translated">通常，进行更改（如写入数据库）时，其影响（如更新DOM）会延迟到系统空闲为止。这使事情可预测-您可以知道DOM在运行时不会从您的代码下更改。这也是使Meteor快速运行的原因之一。</target>
        </trans-unit>
        <trans-unit id="fe16e62334d4b43bbbde630a900a8fdcda76d394" translate="yes" xml:space="preserve">
          <source>Note also that the client example does not end up calling any methods of the &lt;code&gt;sink&lt;/code&gt; object, because &lt;code&gt;ReactDOM.hydrate&lt;/code&gt; has its own similar API. In fact, you are not even required to use the &lt;code&gt;onPageLoad&lt;/code&gt; API on the client, if you have your own ideas about how the client should do its rendering.</source>
          <target state="translated">还要注意，客户端示例最终不会调用接收 &lt;code&gt;sink&lt;/code&gt; 对象的任何方法，因为 &lt;code&gt;ReactDOM.hydrate&lt;/code&gt; 有其自己的相似API。实际上，如果您对客户端应如何呈现呈现有自己的见解，甚至不需要在客户端上使用 &lt;code&gt;onPageLoad&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="db239fbe6d178da413343ff7926fe42c6236debc" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;container components&amp;rdquo; are analogous to the &amp;ldquo;smart components&amp;rdquo; and &amp;ldquo;presentational components&amp;rdquo; to the &amp;ldquo;reusable components&amp;rdquo; in the pattern we document in the &lt;a href=&quot;http://guide.meteor.com/ui-ux.html#components&quot;&gt;UI/UX article&lt;/a&gt;, if you&amp;rsquo;d like to read more about how this philosophy relates to Meteor.</source>
          <target state="translated">请注意，如果您想了解更多有关此哲学原理的信息，&amp;ldquo;容器组件&amp;rdquo;类似于我们在&lt;a href=&quot;http://guide.meteor.com/ui-ux.html#components&quot;&gt;UI / UX文章中&lt;/a&gt;记录的模式中的&amp;ldquo;智能组件&amp;rdquo;和&amp;ldquo;表示性组件&amp;rdquo;与&amp;ldquo;可重用组件&amp;rdquo; 类似。流星。</target>
        </trans-unit>
        <trans-unit id="82f46ec92266100b6f49d97b7f318b8f4e3c996a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;AccountsClient&lt;/code&gt; is currently available only on the client, due to its use of browser APIs such as &lt;code&gt;window.localStorage&lt;/code&gt;. In principle, though, it might make sense to establish a client connection from one server to another remote accounts server. Please &lt;a href=&quot;https://github.com/meteor/meteor/wiki/Contributing-to-Meteor#feature-requests&quot;&gt;let us know&lt;/a&gt; if you find yourself needing this server-to-server functionality.</source>
          <target state="translated">请注意，由于使用了诸如 &lt;code&gt;window.localStorage&lt;/code&gt; 之类的浏览器API，因此 &lt;code&gt;AccountsClient&lt;/code&gt; 当前仅在客户端上可用。但是，从原则上讲，建立从一台服务器到另一台远程帐户服务器的客户端连接可能是有意义的。如果您发现自己需要此服务器到服务器功能，请&lt;a href=&quot;https://github.com/meteor/meteor/wiki/Contributing-to-Meteor#feature-requests&quot;&gt;告知我们&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6dfc941de3deccb84a36c0d91d3bc706177900b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;checkNpmVersions&lt;/code&gt; will only output a warning if the user has installed a incompatible version of the npm package. So your &lt;code&gt;require&lt;/code&gt; call may not give you what you expect. This is consistent with npm&amp;rsquo;s handling of &lt;a href=&quot;http://blog.npmjs.org/post/110924823920/npm-weekly-5&quot;&gt;peer dependencies&lt;/a&gt;.</source>
          <target state="translated">请注意，仅当用户安装了不兼容版本的npm软件包时， &lt;code&gt;checkNpmVersions&lt;/code&gt; 才会输出警告。因此，您的 &lt;code&gt;require&lt;/code&gt; 呼叫可能无法满足您的期望。这与npm处理对&lt;a href=&quot;http://blog.npmjs.org/post/110924823920/npm-weekly-5&quot;&gt;等方依赖项&lt;/a&gt;是一致的。</target>
        </trans-unit>
        <trans-unit id="11331f055374343a8c037eae52c5f0b06f97dc7f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; (and &lt;code&gt;todo&lt;/code&gt; above) are only added to scope in the template; they &lt;em&gt;are not&lt;/em&gt; added to the data context. Specifically this means that inside helpers and event handlers, you cannot access them with &lt;code&gt;this.name&lt;/code&gt; or &lt;code&gt;this.color&lt;/code&gt;. If you need to access them inside a helper, you should pass them in as an argument (like we do with &lt;code&gt;(todoArgs todo)&lt;/code&gt; above).</source>
          <target state="translated">请注意， &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;color&lt;/code&gt; （以及上面的 &lt;code&gt;todo&lt;/code&gt; ）仅添加到模板中的范围；它们&lt;em&gt;不会&lt;/em&gt;添加到数据上下文中。具体来说，这意味着在帮助器和事件处理程序内部，您无法使用 &lt;code&gt;this.name&lt;/code&gt; 或 &lt;code&gt;this.color&lt;/code&gt; 访问它们。如果需要在帮助器内部访问它们，则应将它们作为参数传递（就像我们在上面的 &lt;code&gt;(todoArgs todo)&lt;/code&gt; 中所做的那样）。</target>
        </trans-unit>
        <trans-unit id="64fa95e6a6c26b4ce90059b22cbdedaf6f81cf18" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;react-mounter&lt;/code&gt; automatically mounts the layout component on a &lt;code&gt;#react-root&lt;/code&gt; node, which you can change by using the &lt;code&gt;withOptions()&lt;/code&gt; function.</source>
          <target state="translated">请注意， &lt;code&gt;react-mounter&lt;/code&gt; 会自动在 &lt;code&gt;#react-root&lt;/code&gt; 节点上安装布局组件，您可以使用 &lt;code&gt;withOptions()&lt;/code&gt; 函数进行更改。</target>
        </trans-unit>
        <trans-unit id="f9f0a5447399965abb8d4c9baec9d529cb47602f" translate="yes" xml:space="preserve">
          <source>Note that Spacebars is very forgiving of &lt;code&gt;null&lt;/code&gt; values. It will not complain if you try to access a property on a &lt;code&gt;null&lt;/code&gt; value (for instance &lt;code&gt;foo.bar&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; is not defined), but instead simply treats it also as null. However there are exceptions to this&amp;mdash;trying to call a &lt;code&gt;null&lt;/code&gt; function, or doing the same &lt;em&gt;within&lt;/em&gt; a helper will lead to exceptions.</source>
          <target state="translated">请注意，空格键非常宽容 &lt;code&gt;null&lt;/code&gt; 值。如果您尝试访问一个 &lt;code&gt;null&lt;/code&gt; 值的属性（例如，如果未定义 &lt;code&gt;foo&lt;/code&gt; ,则为 &lt;code&gt;foo.bar&lt;/code&gt; ），它将不会抱怨，而是将其也视为空值。但是，有一些例外情况-尝试调用 &lt;code&gt;null&lt;/code&gt; 函数或&lt;em&gt;在&lt;/em&gt;帮助程序中执行相同操作将导致例外情况。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28761ac4cf9a41ad91ef956579c3b2c5b383c79e" translate="yes" xml:space="preserve">
          <source>Note that all of the values in &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;queryParams&lt;/code&gt; are always strings since URLs don&amp;rsquo;t have any way of encoding data types. For example, if you wanted a parameter to represent a number, you might need to use &lt;code&gt;parseInt(value, 10)&lt;/code&gt; to convert it when you access it.</source>
          <target state="translated">请注意，由于URL无法对数据类型进行编码，因此 &lt;code&gt;params&lt;/code&gt; 和 &lt;code&gt;queryParams&lt;/code&gt; 中的所有值始终为字符串。例如，如果希望参数代表数字，则在访问它时可能需要使用 &lt;code&gt;parseInt(value, 10)&lt;/code&gt; 进行转换。</target>
        </trans-unit>
        <trans-unit id="0d276990631279d27074f63d34a46c03cd9d519c" translate="yes" xml:space="preserve">
          <source>Note that arrow function use with Mocha &lt;a href=&quot;http://mochajs.org/#arrow-functions&quot;&gt;is discouraged&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;http://mochajs.org/#arrow-functions&quot;&gt;不建议&lt;/a&gt;在Mocha中使用箭头功能。</target>
        </trans-unit>
        <trans-unit id="e759ddd9d1f7f0ac2090153f2ef7fc6db7669065" translate="yes" xml:space="preserve">
          <source>Note that arrow function use with Mocha &lt;a href=&quot;https://mochajs.org/#arrow-functions&quot;&gt;is discouraged&lt;/a&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;https://mochajs.org/#arrow-functions&quot;&gt;不建议&lt;/a&gt;在Mocha中使用箭头功能。</target>
        </trans-unit>
        <trans-unit id="f302455ffe257d4ecb081d2b56bd7f83773edefb" translate="yes" xml:space="preserve">
          <source>Note that dynamic calls to &lt;code&gt;require()&lt;/code&gt; (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles.</source>
          <target state="translated">请注意，无法正确分析对 &lt;code&gt;require()&lt;/code&gt; 的动态调用（其中要求的名称可以在运行时更改），这可能会导致客户端捆绑包损坏。</target>
        </trans-unit>
        <trans-unit id="c294ffc6fd67a8ebf46ee7f6c41c4a21e59f6ef5" translate="yes" xml:space="preserve">
          <source>Note that dynamic calls to &lt;code&gt;require()&lt;/code&gt; (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles. This is also discussed in &lt;a href=&quot;http://guide.meteor.com/structure.html#using-require&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">请注意，无法正确分析对 &lt;code&gt;require()&lt;/code&gt; 的动态调用（其中要求的名称可以在运行时更改），这可能会导致客户端捆绑包损坏。本&lt;a href=&quot;http://guide.meteor.com/structure.html#using-require&quot;&gt;指南中&lt;/a&gt;也对此进行了讨论。</target>
        </trans-unit>
        <trans-unit id="bc12c26db946350d18381d4c7cdc23beaa80e6b1" translate="yes" xml:space="preserve">
          <source>Note that files don&amp;rsquo;t need a &lt;code&gt;module.exports&lt;/code&gt; if they&amp;rsquo;re required like &lt;code&gt;routes.js&lt;/code&gt; is in this example, without assignment to any variable. The code in &lt;code&gt;routes.js&lt;/code&gt; will simply be included and executed in place of the above &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="translated">请注意，如果像本例中的 &lt;code&gt;module.exports&lt;/code&gt; 这样需要文件，则不需要模块 &lt;code&gt;routes.js&lt;/code&gt; ，而无需分配任何变量。可以简单地包含并执行 &lt;code&gt;routes.js&lt;/code&gt; 中的代码来代替上面的 &lt;code&gt;require&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="93cadc118af776bae6d3b4b2c7e609960d989eb5" translate="yes" xml:space="preserve">
          <source>Note that imports use relative paths, and include the file extension at the end of the file name.</source>
          <target state="translated">请注意,导入时使用相对路径,并在文件名末尾包含文件扩展名。</target>
        </trans-unit>
        <trans-unit id="792581652d1867279afe8225562a1571c2c368a3" translate="yes" xml:space="preserve">
          <source>Note that in Meteor&amp;rsquo;s publication and subscription system, it&amp;rsquo;s totally fine to publish the same document multiple times with different fields - they will get merged internally and the client will see a consistent document with all of the fields together. So if you just added one custom field, you should just write a publication with that one field. Let&amp;rsquo;s look at an example of how we might publish the &lt;code&gt;initials&lt;/code&gt; field from above:</source>
          <target state="translated">请注意，在Meteor的发布和订阅系统中，可以使用不同的字段多次发布同一文档是完全可以的-它们将在内部合并，并且客户将看到一个统一的文档，其中包含所有字段。因此，如果只添加了一个自定义字段，则应该只使用该字段编写出版物。让我们看一下如何从上方发布 &lt;code&gt;initials&lt;/code&gt; 字段的示例：</target>
        </trans-unit>
        <trans-unit id="6c40f369c466f5021002784e961ac858a5965f39" translate="yes" xml:space="preserve">
          <source>Note that simple string interpolations like this will always escape any HTML for you, so you don&amp;rsquo;t need to perform safety checks for XSS.</source>
          <target state="translated">请注意，像这样的简单字符串插值将始终为您转义任何HTML，因此您无需对XSS执行安全检查。</target>
        </trans-unit>
        <trans-unit id="a50be106236522bd9c0ff0d317ebdbb7c00309f0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;import&lt;/code&gt; is &lt;code&gt;from 'meteor/my-modular-package'&lt;/code&gt;, not &lt;code&gt;from 'my-modular-package'&lt;/code&gt;. Meteor package identifier strings must include the prefix &lt;code&gt;meteor/...&lt;/code&gt; to disambiguate them from npm packages.</source>
          <target state="translated">请注意， &lt;code&gt;import&lt;/code&gt; 是 &lt;code&gt;from 'meteor/my-modular-package'&lt;/code&gt; ，而不是 &lt;code&gt;from 'my-modular-package'&lt;/code&gt; 。流星软件包标识符字符串必须包含前缀 &lt;code&gt;meteor/...&lt;/code&gt; 才能将它们与npm软件包区分开。</target>
        </trans-unit>
        <trans-unit id="b2a93f74c7794a12b902d8c5ffa4cf2e28e05905" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;listId&lt;/code&gt; returned by the list method (which is the one generated by the client stub) is guaranteed to be the same as the one generated on the server, due to &lt;a href=&quot;methods#consistent-id-generation&quot;&gt;the way that Meteor generates IDs&lt;/a&gt; and ensures they are the same between client and server.</source>
          <target state="translated">请注意，由于&lt;a href=&quot;methods#consistent-id-generation&quot;&gt;Meteor生成ID&lt;/a&gt;并确保客户端之间的ID相同，因此list方法返回的 &lt;code&gt;listId&lt;/code&gt; （由客户端存根生成的listId）保证与在服务器上生成的listId相同。和服务器。</target>
        </trans-unit>
        <trans-unit id="d815d0d77091af5ad8eb7632fd7ec45cbbfd6b87" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onPageLoad&lt;/code&gt; callback function is allowed to return a &lt;code&gt;Promise&lt;/code&gt; if it needs to do any asynchronous work, and thus may be implemented by an &lt;code&gt;async&lt;/code&gt; function (as in the client case above).</source>
          <target state="translated">请注意，如果 &lt;code&gt;onPageLoad&lt;/code&gt; 回调函数需要执行任何异步工作，则它可以返回 &lt;code&gt;Promise&lt;/code&gt; ，因此可以由 &lt;code&gt;async&lt;/code&gt; 函数实现（如上述客户端情况）。</target>
        </trans-unit>
        <trans-unit id="4abf3fed06099d51d6f7e7e36eef0c059f0e028a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;user&lt;/code&gt; object provided doesn&amp;rsquo;t have an &lt;code&gt;_id&lt;/code&gt; field yet. If you need to do something with the new user&amp;rsquo;s ID inside this function, a useful trick can be to generate the ID yourself:</source>
          <target state="translated">请注意，提供的 &lt;code&gt;user&lt;/code&gt; 对象还没有 &lt;code&gt;_id&lt;/code&gt; 字段。如果您需要在此函数中对新用户的ID进行操作，则有用的技巧可以是自己生成ID：</target>
        </trans-unit>
        <trans-unit id="d3ffd8f15ff7a4206edb0285c3853031336366e6" translate="yes" xml:space="preserve">
          <source>Note that the Meteor release version number is mostly a marketing artifact - the core Meteor packages themselves typically don&amp;rsquo;t share this version number. This means packages can only depend on specific versions of the packages inside a Meteor release, but can&amp;rsquo;t depend on a specific release itself. We have a helpful shorthand api called &lt;a href=&quot;http://docs.meteor.com/#/full/pack_versions&quot;&gt;&lt;code&gt;api.versionsFrom&lt;/code&gt;&lt;/a&gt; that handles this for you by automatically filling in package version numbers from a particular release:</source>
          <target state="translated">请注意，Meteor发行版本号主要是市场营销产品-核心Meteor软件包本身通常不共享此版本号。这意味着软件包只能依赖于Meteor发行版中软件包的特定版本，而不能取决于特定发行版本身。我们有一个有用的速记api，称为&lt;a href=&quot;http://docs.meteor.com/#/full/pack_versions&quot;&gt; &lt;code&gt;api.versionsFrom&lt;/code&gt; &lt;/a&gt;，它通过自动填写特定发行版的软件包版本号来为您处理：</target>
        </trans-unit>
        <trans-unit id="08fc6ead1fab45341f05e7389a1516ae47ccbe70" translate="yes" xml:space="preserve">
          <source>Note that the above two points interact in a way that can be surprising! If &lt;code&gt;foo&lt;/code&gt; is a template helper function that returns another template, then &lt;code&gt;{{&amp;gt;foo bar}}&lt;/code&gt; will &lt;em&gt;first&lt;/em&gt; push &lt;code&gt;bar&lt;/code&gt; onto the data context stack &lt;em&gt;then&lt;/em&gt; call &lt;code&gt;foo()&lt;/code&gt;, due to the way this line is expanded as shown above. You will need to use &lt;code&gt;Template.parentData(1)&lt;/code&gt; to access the original context. This differs from regular helper calls like &lt;code&gt;{{foo bar}}&lt;/code&gt;, in which &lt;code&gt;bar&lt;/code&gt; is passed as a parameter rather than pushed onto the data context stack.</source>
          <target state="translated">请注意，以上两点相互作用的方式可能令人惊讶！如果 &lt;code&gt;foo&lt;/code&gt; 是返回另一个模板的模板帮助器函数，则 &lt;code&gt;{{&amp;gt;foo bar}}&lt;/code&gt; 将&lt;em&gt;首先&lt;/em&gt;将 &lt;code&gt;bar&lt;/code&gt; 推入数据上下文堆栈，&lt;em&gt;然后&lt;/em&gt;调用 &lt;code&gt;foo()&lt;/code&gt; ，这是因为此行的扩展方式如上所示。您将需要使用 &lt;code&gt;Template.parentData(1)&lt;/code&gt; 来访问原始上下文。这与诸如 &lt;code&gt;{{foo bar}}&lt;/code&gt; 之类的常规帮助程序调用不同，在常规帮助程序调用中， &lt;code&gt;bar&lt;/code&gt; 作为参数传递而不是被推入数据上下文堆栈。</target>
        </trans-unit>
        <trans-unit id="fbbecc58e880b83f20dd8d3074ed3ef53362a97b" translate="yes" xml:space="preserve">
          <source>Note that the argument to &lt;code&gt;#unless&lt;/code&gt; (the condition) becomes the data context in the &lt;code&gt;unless&lt;/code&gt; template and is accessed via &lt;code&gt;this&lt;/code&gt;. However, it would not work very well if this data context was visible to &lt;code&gt;Template.contentBlock&lt;/code&gt;, which is supplied by the user of &lt;code&gt;unless&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;#unless&lt;/code&gt; （条件）的参数成为 &lt;code&gt;unless&lt;/code&gt; 模板中的数据上下文，并通过 &lt;code&gt;this&lt;/code&gt; 进行访问。但是，如果 &lt;code&gt;Template.contentBlock&lt;/code&gt; 可以看到此数据上下文，则该效果就不会很好， &lt;code&gt;unless&lt;/code&gt; 用户提供。</target>
        </trans-unit>
        <trans-unit id="884589830f37017e057a6fe2a2cb843e31a9ba15" translate="yes" xml:space="preserve">
          <source>Note that the mergebox operates at the level of top-level fields, so if two subscriptions publish nested fields (e.g. sub1 publishes &lt;code&gt;doc.a.b = 7&lt;/code&gt; and sub2 publishes &lt;code&gt;doc.a.c = 8&lt;/code&gt;), then the &amp;ldquo;merged&amp;rdquo; document might not look as you expect (in this case &lt;code&gt;doc.a = {c: 8}&lt;/code&gt;, if sub2 happens second).</source>
          <target state="translated">请注意，mergebox在顶级字段级别操作，因此，如果两个订阅发布嵌套字段（例如sub1发布 &lt;code&gt;doc.a.b = 7&lt;/code&gt; ，sub2发布 &lt;code&gt;doc.a.c = 8&lt;/code&gt; ），则&amp;ldquo;合并的&amp;rdquo;文档可能看起来不像您期望的（在这种情况下 &lt;code&gt;doc.a = {c: 8}&lt;/code&gt; ，如果sub2发生在第二位）。</target>
        </trans-unit>
        <trans-unit id="9be0709239c592dd52ce0c0fae8792fb7b9173b3" translate="yes" xml:space="preserve">
          <source>Note that the schema is different when users register with different login services. There are a few things to be aware of when dealing with this collection:</source>
          <target state="translated">请注意,当用户使用不同的登录服务注册时,模式是不同的。在处理这个集合时,有一些事情需要注意。</target>
        </trans-unit>
        <trans-unit id="eb0913f962e9e0be162efe1f8d4b737e668e85f2" translate="yes" xml:space="preserve">
          <source>Note that the version solver also has a concept of &amp;ldquo;gravity&amp;rdquo; - when many solutions are possible for a certain set of dependencies, it always selects the oldest possible version. This is helpful if you are trying to develop a package to ship to lots of users, since it ensures your package will be compatible with the lowest common denominator of a dependency. If your package needs a newer version than is currently being selected for a certain dependency, you need to update your &lt;code&gt;package.js&lt;/code&gt; to have a newer version constraint.</source>
          <target state="translated">请注意，版本求解器还具有&amp;ldquo;引力&amp;rdquo;的概念-当对于一组特定的依赖项可能有许多解决方案时，它总是选择最早的版本。如果您尝试开发一个程序包以运送给许多用户，这将很有帮助，因为它可以确保您的程序包与依赖项的最低公分母兼容。如果您的程序包需要比当前为某个依赖项选择的版本更高的版本，则需要更新 &lt;code&gt;package.js&lt;/code&gt; 以使其具有新的版本约束。</target>
        </trans-unit>
        <trans-unit id="02a50208d8a75b80f387cf64a9878f40a28fbc6d" translate="yes" xml:space="preserve">
          <source>Note that there a few caveats:</source>
          <target state="translated">注意,有一些注意事项。</target>
        </trans-unit>
        <trans-unit id="d59ec0b1608b7a8f47fa3339fa7de7cc9d4a89ba" translate="yes" xml:space="preserve">
          <source>Note that there are some exceptions to this second rule. A common one is &lt;code&gt;Meteor.user()&lt;/code&gt;&amp;mdash;although this is strictly speaking subscribed to (automatically usually), it&amp;rsquo;s typically over-complicated to pass it through the component hierarchy as an argument to each component. However keep in mind it&amp;rsquo;s best not to use it in too many places as it makes components harder to test.</source>
          <target state="translated">请注意，第二条规则有些例外。常见的是 &lt;code&gt;Meteor.user()&lt;/code&gt; －尽管严格来说（通常是自动地）订阅了它，但将其作为每个组件的参数传递给组件层次结构通常过于复杂。但是请记住，最好不要在太多地方使用它，因为它会使组件更难测试。</target>
        </trans-unit>
        <trans-unit id="c71167324d950d0a6ff2b27f2935d963a3d668a2" translate="yes" xml:space="preserve">
          <source>Note that there is a benefit to restricting the places you access the current user to make your UI more testable and modular. Read more about this in the &lt;a href=&quot;ui-ux#global-stores&quot;&gt;UI article&lt;/a&gt;.</source>
          <target state="translated">请注意，限制访问当前用户的位置以使UI更具可测试性和模块化是有好处的。在&lt;a href=&quot;ui-ux#global-stores&quot;&gt;UI文章中&lt;/a&gt;阅读有关此内容的更多信息。</target>
        </trans-unit>
        <trans-unit id="c51adc30d6eb693757b85dc37dcc6afa69ab976b" translate="yes" xml:space="preserve">
          <source>Note that there is another test command in the Meteor tool; &lt;code&gt;meteor test-packages&lt;/code&gt; is a way of testing Atmosphere packages, which is discussed in the &lt;a href=&quot;https://guide.meteor.com/writing-packages.html#testing&quot;&gt;Writing Packages article&lt;/a&gt;.</source>
          <target state="translated">请注意，&amp;ldquo;流星&amp;rdquo;工具中还有另一个测试命令。 &lt;code&gt;meteor test-packages&lt;/code&gt; 是一种测试Atmosphere包的方法，有关&lt;a href=&quot;https://guide.meteor.com/writing-packages.html#testing&quot;&gt;写作包一文中&lt;/a&gt;有讨论。</target>
        </trans-unit>
        <trans-unit id="545dc436496696fdfc589d432602147dfa408c3c" translate="yes" xml:space="preserve">
          <source>Note that these restrictions mean you will have to explicitly allow loading &lt;code&gt;data:&lt;/code&gt; URLs. For example, to allow loading &lt;code&gt;data:&lt;/code&gt; URLs in iframes you would add:</source>
          <target state="translated">请注意，这些限制意味着您将必须明确允许加载 &lt;code&gt;data:&lt;/code&gt; URL。例如，要允许加载 &lt;code&gt;data:&lt;/code&gt; iframe中的网址，您需要添加：</target>
        </trans-unit>
        <trans-unit id="4f8ec097736539acca8b3c2f8245f00e4b7789fc" translate="yes" xml:space="preserve">
          <source>Note that this code sample uses the &lt;a href=&quot;methods#validated-method&quot;&gt;ValidatedMethod package recommended in the Methods article&lt;/a&gt;. If you aren&amp;rsquo;t using that package, you can use the name as the property passed to &lt;code&gt;Meteor.methods&lt;/code&gt;.</source>
          <target state="translated">请注意，此代码示例使用&lt;a href=&quot;methods#validated-method&quot;&gt;&amp;ldquo;方法&amp;rdquo;文章中推荐&lt;/a&gt;的ValidatedMethod包。如果您不使用该软件包，则可以将名称用作传递给 &lt;code&gt;Meteor.methods&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="ea45ed0c2e9e4f66096c4f89efbeded41baae4b0" translate="yes" xml:space="preserve">
          <source>Note that this package is based on &lt;strong&gt;mailcomposer 4&lt;/strong&gt;, so make sure to refer to &lt;a href=&quot;https://github.com/nodemailer/mailcomposer/blob/v4.0.1/README.md&quot;&gt;the documentation&lt;/a&gt; for that version when using the &lt;code&gt;attachments&lt;/code&gt; or &lt;code&gt;mailComposer&lt;/code&gt; options.</source>
          <target state="translated">请注意，该软件包基于&lt;strong&gt;mailcomposer 4&lt;/strong&gt;，因此在使用 &lt;code&gt;attachments&lt;/code&gt; 或 &lt;code&gt;mailComposer&lt;/code&gt; 选项时，请确保参考该版本&lt;a href=&quot;https://github.com/nodemailer/mailcomposer/blob/v4.0.1/README.md&quot;&gt;的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbd1ee7264593915397aac36c8e2e69b77f9f954" translate="yes" xml:space="preserve">
          <source>Note that user documents &amp;ndash; ones that you would normally query with &lt;code&gt;Meteor.users.find()&lt;/code&gt; &amp;ndash; will be available as the key &lt;code&gt;users&lt;/code&gt; on the dictionary passed from a &lt;code&gt;PublicationCollector.collect()&lt;/code&gt; call. See the &lt;a href=&quot;https://github.com/johanbrook/meteor-publication-collector/blob/master/tests/publication-collector.test.js&quot;&gt;tests&lt;/a&gt; in the package for more details.</source>
          <target state="translated">请注意，用户文档（通常使用 &lt;code&gt;Meteor.users.find()&lt;/code&gt; 查询的用户文档）将作为通过 &lt;code&gt;PublicationCollector.collect()&lt;/code&gt; 调用传递的词典上的关键 &lt;code&gt;users&lt;/code&gt; 提供。有关更多详细信息，请参见包装中的&lt;a href=&quot;https://github.com/johanbrook/meteor-publication-collector/blob/master/tests/publication-collector.test.js&quot;&gt;测试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97d83ef52447c8fa719b5ee359b297daea157b9a" translate="yes" xml:space="preserve">
          <source>Note that using keyword arguments to helpers is a little awkward, so in general it&amp;rsquo;s usually easier to avoid them. This feature was included for historical reasons to match the way keyword arguments work in Handlebars.</source>
          <target state="translated">请注意，对帮助者使用关键字参数有点尴尬，因此通常通常更容易避免使用它们。出于历史原因，包含此功能是为了匹配在Handlebars中关键字参数的工作方式。</target>
        </trans-unit>
        <trans-unit id="fc57862243e6a3d2a7698b732f35407da9b99cb1" translate="yes" xml:space="preserve">
          <source>Note that we can check for multiple roles at once, and if someone has a role in the &lt;code&gt;GLOBAL_GROUP&lt;/code&gt;, they are considered as having that role in every group. In this case, the groups were by category ID, but you could use any unique identifier to make a group.</source>
          <target state="translated">请注意，我们可以一次检查多个角色，如果某人在 &lt;code&gt;GLOBAL_GROUP&lt;/code&gt; 中具有某个角色，则认为他们在每个组中都具有该角色。在这种情况下，分组是按类别ID进行的，但是您可以使用任何唯一的标识符组成一个分组。</target>
        </trans-unit>
        <trans-unit id="0c59729aa03179ea61172e1be10c7284817526e8" translate="yes" xml:space="preserve">
          <source>Note that we could make this migration faster by using an &lt;a href=&quot;https://docs.mongodb.org/v2.6/aggregation/&quot;&gt;Aggregation&lt;/a&gt; to gather the initial set of todo counts.</source>
          <target state="translated">请注意，我们可以通过使用&lt;a href=&quot;https://docs.mongodb.org/v2.6/aggregation/&quot;&gt;聚合&lt;/a&gt;来收集待办事项计数的初始集合，从而加快迁移速度。</target>
        </trans-unit>
        <trans-unit id="d5200147dc768e2ecdf4b6fad0c110f14babfbd2" translate="yes" xml:space="preserve">
          <source>Note that we explicitly set the &lt;code&gt;Meteor.users&lt;/code&gt; query fields, as &lt;code&gt;publish-composite&lt;/code&gt; publishes all of the returned cursors to the client and re-runs the child computations whenever the cursor changes.</source>
          <target state="translated">请注意，我们明确设置了 &lt;code&gt;Meteor.users&lt;/code&gt; 查询字段，因为 &lt;code&gt;publish-composite&lt;/code&gt; 会将所有返回的游标发布到客户端，并在游标更改时重新运行子计算。</target>
        </trans-unit>
        <trans-unit id="e18a74dc4da8ae8659fde058ae25d096ddd9b335" translate="yes" xml:space="preserve">
          <source>Note that we have specified a password reset route. Normally, we would have to configure Meteor&amp;rsquo;s accounts system to send this route in password reset emails, but the &lt;code&gt;useraccounts:flow-routing&lt;/code&gt; package does it for us. &lt;a href=&quot;#email-flows&quot;&gt;Read more about configuring email flows below.&lt;/a&gt;</source>
          <target state="translated">请注意，我们已经指定了密码重置路径。通常，我们必须配置Meteor的帐户系统，以通过密码重置电子邮件发送此路由，但是 &lt;code&gt;useraccounts:flow-routing&lt;/code&gt; 软件包会为我们完成此操作。&lt;a href=&quot;#email-flows&quot;&gt;在下面阅读有关配置电子邮件流的更多信息。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e340fac5190d8fa1d00913a56be97e7c49556b" translate="yes" xml:space="preserve">
          <source>Note that we only handled the mutators we actually use in the application&amp;mdash;we don&amp;rsquo;t deal with all possible ways the todo count on a list could change. For example, if you changed the &lt;code&gt;listId&lt;/code&gt; on a todo item, it would need to change the &lt;code&gt;incompleteCount&lt;/code&gt; of &lt;em&gt;two&lt;/em&gt; lists. However, since our application doesn&amp;rsquo;t do this, we don&amp;rsquo;t handle it in the denormalizer.</source>
          <target state="translated">请注意，我们只处理了我们在应用程序中实际使用的变体-我们并未处理列表上待办事项计数可能改变的所有可能方式。例如，如果你改变了 &lt;code&gt;listId&lt;/code&gt; 上待办事项，那就需要改变 &lt;code&gt;incompleteCount&lt;/code&gt; 的&lt;em&gt;2名&lt;/em&gt;列表。但是，由于我们的应用程序不执行此操作，因此我们不会在非规范化器中对其进行处理。</target>
        </trans-unit>
        <trans-unit id="028811cff2ee5ae313cd61a9676aaaf382947bb6" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve exported a client-side symbol &lt;code&gt;generateData&lt;/code&gt; which is a promisified version of the method call, which makes it simpler to use this sequentially in tests.</source>
          <target state="translated">请注意，我们已经导出了客户端符号 &lt;code&gt;generateData&lt;/code&gt; ，它是方法调用的承诺版本，这使得在测试中顺序使用它更为简单。</target>
        </trans-unit>
        <trans-unit id="fcfcc0c37fe95dd2bcc756e40a58d73c0a695a01" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fields&lt;/code&gt; are specified, only changes to the included fields will trigger callbacks in &lt;code&gt;observe&lt;/code&gt;, &lt;code&gt;observeChanges&lt;/code&gt; and invalidations in reactive computations using this cursor. Careful use of &lt;code&gt;fields&lt;/code&gt; allows for more fine-grained reactivity for computations that don&amp;rsquo;t depend on an entire document.</source>
          <target state="translated">请注意，当指定 &lt;code&gt;fields&lt;/code&gt; 时，仅对包含字段的更改将触发使用此光标的 &lt;code&gt;observe&lt;/code&gt; ， &lt;code&gt;observeChanges&lt;/code&gt; 和无效计算中的回调。谨慎使用 &lt;code&gt;fields&lt;/code&gt; 可为不依赖整个文档的计算提供更细粒度的反应性。</target>
        </trans-unit>
        <trans-unit id="c295a388ba5bb73377425610a4543f94fcb272ee" translate="yes" xml:space="preserve">
          <source>Note that while the Method is defined on the client, the actual secret logic is only accessible from the server. Keep in mind that code inside &lt;code&gt;if (Meteor.isServer)&lt;/code&gt; blocks is still sent to the client, it is just not executed. So don&amp;rsquo;t put any secret code in there.</source>
          <target state="translated">请注意，虽然在客户端上定义了方法，但是只能从服务器访问实际的秘密逻辑。请记住， &lt;code&gt;if (Meteor.isServer)&lt;/code&gt; 块中的代码仍然发送给客户端，则不会执行。因此，请勿在其中放置任何秘密代码。</target>
        </trans-unit>
        <trans-unit id="676c56d9e000c0c0d4c59b390c203c4403f79727" translate="yes" xml:space="preserve">
          <source>Note that you can also install Chimp as a &lt;code&gt;devDependency&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt; but you may run into problems deploying your application as it includes binary dependencies. You can avoid such problems by running &lt;code&gt;meteor npm prune&lt;/code&gt; to remove non-production dependencies before deploying.</source>
          <target state="translated">请注意，您还可以在 &lt;code&gt;package.json&lt;/code&gt; &lt;code&gt;devDependency&lt;/code&gt; Chimp作为devDependency安装，但是由于它包含二进制依赖性，因此在部署应用程序时可能会遇到问题。您可以通过在部署前运行 &lt;code&gt;meteor npm prune&lt;/code&gt; 删除非生产依赖性来避免此类问题。</target>
        </trans-unit>
        <trans-unit id="9c139b70a7c79fcccbfe21055b18c13e0fa9042f" translate="yes" xml:space="preserve">
          <source>Note: Ensure that you have secure backups of your keystore (&lt;code&gt;~/.keystore&lt;/code&gt; is the default). If you publish an app to the Play Store and then lose the key with which you signed your app, you will not be able to publish any updates to your app, since you must always sign all versions of your app with the same key.</source>
          <target state="translated">注意：确保您具有密钥库的安全备份（默认为 &lt;code&gt;~/.keystore&lt;/code&gt; ）。如果您将某个应用发布到Play商店，然后丢失了用来签署该应用的密钥，则您将无法发布该应用的任何更新，因为您必须始终使用同一密钥对所有版本的应用进行签名。</target>
        </trans-unit>
        <trans-unit id="035e37e04f4175f2374f5dcc2b6cf06bbdd1d271" translate="yes" xml:space="preserve">
          <source>Note: If multiple Meteor packages add the same Cordova plugin but at different versions, there is no clear way of telling which version will end up being installed. Plugins added to your project directly however, will always override versions of the same plugin added as a dependency of packages.</source>
          <target state="translated">注意:如果多个Meteor包添加了相同的Cordova插件,但在不同的版本,没有明确的方法告诉你最终安装的是哪个版本。然而,直接添加到你的项目中的插件,总是会覆盖作为依赖包添加的同一插件的版本。</target>
        </trans-unit>
        <trans-unit id="39819a23f3cc7b66b2e98d1d9a40fe90c0cadf50" translate="yes" xml:space="preserve">
          <source>Note: If you haven&amp;rsquo;t previously developed iOS apps, or haven&amp;rsquo;t used the connected device for development, a series of dialogs and warnings may appear as Xcode resolves code signing issues. It may also prompt you for permission to access the key in your keychain. See &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html#//apple_ref/doc/uid/TP40012582-CH27-SW4&quot;&gt;Apple&amp;rsquo;s instructions&lt;/a&gt; for more information. You will also need to join the &lt;a href=&quot;https://developer.apple.com/programs/&quot;&gt;Apple Developer Program&lt;/a&gt; to deploy your app on the Apple iOS App Store.</source>
          <target state="translated">注意：如果您以前未开发过iOS应用程序，或者尚未使用连接的设备进行开发，则Xcode解决代码签名问题时，可能会出现一系列对话框和警告。它还可能会提示您允许访问钥匙串中的钥匙。有关更多信息，请参阅&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html#//apple_ref/doc/uid/TP40012582-CH27-SW4&quot;&gt;Apple的说明&lt;/a&gt;。您还需要加入&lt;a href=&quot;https://developer.apple.com/programs/&quot;&gt;Apple Developer Program，&lt;/a&gt;才能在Apple iOS App Store上部署您的应用程序。</target>
        </trans-unit>
        <trans-unit id="a14ac80a5ac061149a27a2700dfe219219fdec9a" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re using older version of Meteor, you may also need to install an older version of Android SDK, for example with the Android SDK Manager that comes with Android Studio.</source>
          <target state="translated">注意：如果您使用的是旧版的Meteor，则可能还需要安装旧版的Android SDK，例如，使用Android Studio随附的Android SDK Manager。</target>
        </trans-unit>
        <trans-unit id="5cc7b510ece2c6ccec5177032f3b2cf962a42712" translate="yes" xml:space="preserve">
          <source>Note: Packages can only access their own assets. If you need to read the assets of a different package, or of the enclosing app, you need to get a reference to that package&amp;rsquo;s &lt;code&gt;Assets&lt;/code&gt; object.</source>
          <target state="translated">注意：包只能访问自己的资产。如果您需要读取其他程序包或随附应用程序的 &lt;code&gt;Assets&lt;/code&gt; ，则需要获取对该程序包的Assets对象的引用。</target>
        </trans-unit>
        <trans-unit id="55e71576e444e611aadfa22689c504d789350e30" translate="yes" xml:space="preserve">
          <source>Note: Packages with &lt;code&gt;lazy&lt;/code&gt; main modules cannot use &lt;code&gt;api.export&lt;/code&gt; to export global symbols to other packages/apps. Also, prior to Meteor 1.4.4.2 it is neccessary to explicitly name the file containing the module: &lt;code&gt;import &quot;meteor/&amp;lt;package name&amp;gt;/client.js&quot;&lt;/code&gt;.</source>
          <target state="translated">注意：具有 &lt;code&gt;lazy&lt;/code&gt; 主模块的软件包不能使用 &lt;code&gt;api.export&lt;/code&gt; 将全局符号导出到其他软件包/应用程序。同样，在Meteor 1.4.4.2之前，有必要显式命名包含模块的文件： &lt;code&gt;import &quot;meteor/&amp;lt;package name&amp;gt;/client.js&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2c9ddec9456dd0e816d18f0ed939daa1d9f5567" translate="yes" xml:space="preserve">
          <source>Note: Prior to Meteor 1.4.2, &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; was simply &lt;code&gt;PACKAGE_DIRS&lt;/code&gt;. For compatibility reasons, developers should use &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; going forward.</source>
          <target state="translated">注意：在Meteor 1.4.2之前， &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; 只是 &lt;code&gt;PACKAGE_DIRS&lt;/code&gt; 。出于兼容性原因，开发人员应继续使用 &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3cb6b6e3876fb61ac8daaf652acd7d8f45139da9" translate="yes" xml:space="preserve">
          <source>Note: Since we need to access context on &lt;code&gt;this&lt;/code&gt; we need to use the &lt;code&gt;function() {}&lt;/code&gt; form for publications rather than the ES2015 &lt;code&gt;() =&amp;gt; {}&lt;/code&gt;. You can disable the arrow function linting rule for publication files with &lt;code&gt;eslint-disable prefer-arrow-callback&lt;/code&gt;. A future version of the publication API will work more nicely with ES2015.</source>
          <target state="translated">注意：由于需要访问上下文， &lt;code&gt;this&lt;/code&gt; 需要使用 &lt;code&gt;function() {}&lt;/code&gt; 形式进行发布，而不要使用ES2015 &lt;code&gt;() =&amp;gt; {}&lt;/code&gt; 。您可以使用 &lt;code&gt;eslint-disable prefer-arrow-callback&lt;/code&gt; 发布文件的箭头功能linting规则。将来版本的发布API将与ES2015更好地配合。</target>
        </trans-unit>
        <trans-unit id="988ef8f0c805ab181194f85d300b6976bdc58a02" translate="yes" xml:space="preserve">
          <source>Note: You don&amp;rsquo;t have to do this if you&amp;rsquo;re using &lt;code&gt;useraccounts&lt;/code&gt;. It disables the regular Meteor client-side account creation functions for you and does custom validation.</source>
          <target state="translated">注意：如果您使用的是 &lt;code&gt;useraccounts&lt;/code&gt; ，则不必这样做。它会为您禁用常规的Meteor客户端帐户创建功能，并执行自定义验证。</target>
        </trans-unit>
        <trans-unit id="840b63131bfe381e1e921ba9e151de57467f386c" translate="yes" xml:space="preserve">
          <source>Note: in a larger application, given that the todos themselves are a part of a list, it might make sense to group both of these domains into a single larger &amp;ldquo;list&amp;rdquo; module. The Todos example is small enough that we need to separate these only to demonstrate modularity.</source>
          <target state="translated">注意：在较大的应用程序中，鉴于待办事项本身是列表的一部分，将这两个域都组合为一个较大的&amp;ldquo;列表&amp;rdquo;模块可能是有意义的。Todos示例足够小，我们仅需将它们分开以展示模块化即可。</target>
        </trans-unit>
        <trans-unit id="f565ae64e9a95cf65b05d8c3af6eff5a687558cf" translate="yes" xml:space="preserve">
          <source>Nothing in the Meteor guide is &lt;em&gt;required&lt;/em&gt; to build a Meteor application&amp;mdash;you can certainly use the platform in ways that contradict the principles and patterns of the guide. However, the guide is an attempt to document best practices and community conventions, so we hope that the majority of the Meteor community will benefit from adopting the practices documented here.</source>
          <target state="translated">构建Meteor应用程序&lt;em&gt;不需要&lt;/em&gt; Meteor指南中的任何内容-您当然可以以与指南的原理和模式相抵触的方式使用该平台。但是，该指南试图记录最佳实践和社区惯例，因此我们希望流星社区的大多数将从采用此处记录的实践中受益。</target>
        </trans-unit>
        <trans-unit id="badfb943d8601c2984dcaa8b030270c131e1174b" translate="yes" xml:space="preserve">
          <source>Notice that in this component we are also accessing the global client-side state store &lt;code&gt;FlowRouter&lt;/code&gt;, which we wrap in a instance method called &lt;code&gt;getListId()&lt;/code&gt;. This instance method is called both from the &lt;code&gt;autorun&lt;/code&gt; in &lt;code&gt;onCreated&lt;/code&gt;, and from the &lt;code&gt;listIdArray&lt;/code&gt; helper:</source>
          <target state="translated">请注意，在此组件中，我们还访问了全局客户端状态存储 &lt;code&gt;FlowRouter&lt;/code&gt; ，我们将其包装在名为 &lt;code&gt;getListId()&lt;/code&gt; 的实例方法中。这个实例方法是从所谓的两个 &lt;code&gt;autorun&lt;/code&gt; 在 &lt;code&gt;onCreated&lt;/code&gt; ，并从 &lt;code&gt;listIdArray&lt;/code&gt; 帮手：</target>
        </trans-unit>
        <trans-unit id="8b772971430bc5be5a9a6196e94ad8e641dfe8f8" translate="yes" xml:space="preserve">
          <source>Notice that this is just the normal JavaScript syntax for declaring a variable that is local or global. Meteor scans your source code for global variable assignments and generates a wrapper that makes sure that your globals don&amp;rsquo;t escape their appropriate namespace.</source>
          <target state="translated">请注意，这只是声明局部变量或全局变量的普通JavaScript语法。Meteor会在源代码中扫描全局变量分配，并生成一个包装程序，以确保您的全局变量不会转义其适当的名称空间。</target>
        </trans-unit>
        <trans-unit id="6b3aef94b7846ada34d09773d8a11b96bc941c45" translate="yes" xml:space="preserve">
          <source>Notice that we called the component to be rendered &lt;code&gt;Lists_show_page&lt;/code&gt; (rather than &lt;code&gt;Lists_show&lt;/code&gt;). This indicates that this template is rendered directly by a Flow Router action and forms the &amp;lsquo;top&amp;rsquo; of the rendering hierarchy for this URL.</source>
          <target state="translated">注意，我们将要渲染的组件称为 &lt;code&gt;Lists_show_page&lt;/code&gt; （而不是 &lt;code&gt;Lists_show&lt;/code&gt; ）。这表示此模板是由流路由器操作直接呈现的，并构成此URL呈现层次结构的&amp;ldquo;顶部&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ed7b51de0c92c0bddd64aff183ec7a9a4e404763" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;left-pad&lt;/code&gt; is included in your &lt;code&gt;package.json&lt;/code&gt;, and the code has been downloaded to &lt;code&gt;node_modules/left_pad/&lt;/code&gt;. Add the new directory to source control with:</source>
          <target state="translated">现在 &lt;code&gt;left-pad&lt;/code&gt; 包含在 &lt;code&gt;package.json&lt;/code&gt; 中，并且代码已下载到 &lt;code&gt;node_modules/left_pad/&lt;/code&gt; 。使用以下命令将新目录添加到源代码管理：</target>
        </trans-unit>
        <trans-unit id="3f17930a739be5d85a97a9f947f14783999c6ccb" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;server.js&lt;/code&gt; and &lt;code&gt;client.js&lt;/code&gt; can import other files from the package source directory, even if those files have not been added using the &lt;code&gt;api.addFiles&lt;/code&gt; function.</source>
          <target state="translated">现在，即使没有使用 &lt;code&gt;api.addFiles&lt;/code&gt; 函数添加这些文件， &lt;code&gt;server.js&lt;/code&gt; 和 &lt;code&gt;client.js&lt;/code&gt; 也可以从包源目录中导入其他文件。</target>
        </trans-unit>
        <trans-unit id="4fe266c65dea7ef67a5f8d4dfd4744acf9124103" translate="yes" xml:space="preserve">
          <source>Now apps that include this package can do:</source>
          <target state="translated">现在,包含这个包的应用可以做到。</target>
        </trans-unit>
        <trans-unit id="3fa0781f8231e2d6a7a3d68cec2957c10dc140a7" translate="yes" xml:space="preserve">
          <source>Now calling the Method is as simple as calling a JavaScript function:</source>
          <target state="translated">现在调用Method就像调用一个JavaScript函数一样简单。</target>
        </trans-unit>
        <trans-unit id="266ca65aa2ddddba3fc94df5a25062f132143c6b" translate="yes" xml:space="preserve">
          <source>Now just open your app, follow the configuration steps, and you&amp;rsquo;re good to go - if you&amp;rsquo;ve done the &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/adding-user-accounts&quot;&gt;Meteor tutorial&lt;/a&gt;, you&amp;rsquo;ve already seen this in action. Of course, in a production application, you probably want a more custom user interface and some logic to have a more tailored UX, but that&amp;rsquo;s why we have the rest of this guide.</source>
          <target state="translated">现在只需打开您的应用程序，按照配置步骤操作，就可以了-如果您已经完成了&lt;a href=&quot;https://www.meteor.com/tutorials/blaze/adding-user-accounts&quot;&gt;Meteor教程&lt;/a&gt;，那么您已经看到了这一功能。当然，在生产应用程序中，您可能想要一个更自定义的用户界面和一些逻辑，以拥有一个量身定制的UX，但这就是我们拥有本指南其余部分的原因。</target>
        </trans-unit>
        <trans-unit id="dfadb11907bcf09c8efb15a9cadf25f26125810f" translate="yes" xml:space="preserve">
          <source>Now that the routes are setup on the server, they can be accessed from the browser (e.g. &lt;code&gt;example.com/reset-password&lt;/code&gt;). To create links to these routes in a template, it&amp;rsquo;s best to use a helper method provided by the router. For Flow Router, the &lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt;&lt;code&gt;arillo:flow-router-helpers&lt;/code&gt;&lt;/a&gt; package provides a &lt;code&gt;pathFor&lt;/code&gt; helper for just this purpose. Once installed, the following is possible in a template:</source>
          <target state="translated">现在已经在服务器上设置了路由，可以从浏览器访问它们（例如 &lt;code&gt;example.com/reset-password&lt;/code&gt; ）。要在模板中创建到这些路由的链接，最好使用路由器提供的帮助器方法。对于Flow Router，&lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt; &lt;code&gt;arillo:flow-router-helpers&lt;/code&gt; &lt;/a&gt;软件包为此目的提供了一个 &lt;code&gt;pathFor&lt;/code&gt; 助手使用。安装完成后，模板中可能包含以下内容：</target>
        </trans-unit>
        <trans-unit id="822de0027eb75347ecda5b8adbcdb6fd9d50b088" translate="yes" xml:space="preserve">
          <source>Now that we have placed all files inside the &lt;code&gt;imports/&lt;/code&gt; directory, let&amp;rsquo;s think about how best to organize our code using modules. It makes sense to put all code that runs when your app starts in an &lt;code&gt;imports/startup&lt;/code&gt; directory. Another good idea is splitting data and business logic from UI rendering code. We suggest using directories called &lt;code&gt;imports/api&lt;/code&gt; and &lt;code&gt;imports/ui&lt;/code&gt; for this logical split.</source>
          <target state="translated">现在，我们已将所有文件放置在 &lt;code&gt;imports/&lt;/code&gt; 目录中，让我们考虑如何最好地使用模块来组织代码。将将应用程序启动时运行的所有代码都放在 &lt;code&gt;imports/startup&lt;/code&gt; 目录中是有意义的。另一个好主意是从UI渲染代码中分离数据和业务逻辑。我们建议对此逻辑拆分使用名为 &lt;code&gt;imports/api&lt;/code&gt; 和 &lt;code&gt;imports/ui&lt;/code&gt; 的目录。</target>
        </trans-unit>
        <trans-unit id="207c8efa237ee7afa85bb139ec83441157995981" translate="yes" xml:space="preserve">
          <source>Now that you are familiar with the basic API of Simple Schema, it&amp;rsquo;s worth considering a few of the constraints of the Meteor data system that can influence the design of your data schema. Although generally speaking you can build a Meteor data schema much like any MongoDB data schema, there are some important details to keep in mind.</source>
          <target state="translated">既然您已经熟悉了简单模式的基本API，就值得考虑流星数据系统的一些约束，这些约束会影响数据模式的设计。尽管通常来说，您可以像构建任何MongoDB数据架构一样构建Meteor数据架构，但是要记住一些重要的细节。</target>
        </trans-unit>
        <trans-unit id="b2415a74e85f893d12486fe84c1d6f4d5237cd33" translate="yes" xml:space="preserve">
          <source>Now that you have the access token, you need to actually make a request to the appropriate API. Here you have two options:</source>
          <target state="translated">现在你已经有了访问令牌,你需要实际向相应的API发出请求。这里你有两个选择。</target>
        </trans-unit>
        <trans-unit id="ad193fb9138049e8ee81187783bd11d3de48574e" translate="yes" xml:space="preserve">
          <source>Now that you have this package, you can use helpers in your templates to display a link to a certain route. For example, in the Todos example app, our nav links look like:</source>
          <target state="translated">现在你已经有了这个包,你可以在你的模板中使用助记符来显示某个路线的链接。例如,在Todos示例应用中,我们的导航链接看起来像。</target>
        </trans-unit>
        <trans-unit id="d05915f91cde27b03edcf5e9433a8e2a92edc63b" translate="yes" xml:space="preserve">
          <source>Now that you know that the user is attempting to reset their password, set an initial password, or verify their email, you should display an appropriate UI to allow them to do so. For example, you might want to show a page with a form for the user to enter their new password.</source>
          <target state="translated">现在你知道用户正在尝试重置他们的密码,设置初始密码,或者验证他们的电子邮件,你应该显示一个适当的UI来让他们这样做。例如,你可能想显示一个带有表单的页面,让用户输入他们的新密码。</target>
        </trans-unit>
        <trans-unit id="d60aeee85fcdbde7a8a3292996eddb16b8698ac7" translate="yes" xml:space="preserve">
          <source>Now users of your package can import the symbol with:</source>
          <target state="translated">现在,你的包的用户可以导入符号与。</target>
        </trans-unit>
        <trans-unit id="646aa81c4daa41e903b20d08dccfefb42d9e9d23" translate="yes" xml:space="preserve">
          <source>Now we can attach helpers to documents, it&amp;rsquo;s simple to define a helper that fetches related documents</source>
          <target state="translated">现在我们可以将帮助程序附加到文档，定义定义了获取相关文档的帮助程序很简单</target>
        </trans-unit>
        <trans-unit id="976eaa97e9cf3169da70f260e662cfd3b4dd63aa" translate="yes" xml:space="preserve">
          <source>Now we can easily find all the todos for a list:</source>
          <target state="translated">现在,我们可以很容易地找到一个列表的所有待办事项。</target>
        </trans-unit>
        <trans-unit id="ef330ff4a9076f7c91003e65863c6eb967f7566c" translate="yes" xml:space="preserve">
          <source>Now we can run the tests with &lt;code&gt;meteor npm test&lt;/code&gt;.</source>
          <target state="translated">现在我们可以使用 &lt;code&gt;meteor npm test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ea65ac5d2b8d2196556f7141a258249192cfde3" translate="yes" xml:space="preserve">
          <source>Now we have a schema, how do we use it?</source>
          <target state="translated">现在我们有了一个模式,我们如何使用它?</target>
        </trans-unit>
        <trans-unit id="aa15df2c85f6af550bcc27502427dc8434822821" translate="yes" xml:space="preserve">
          <source>Now we understand how to define routes and access information about the current route, we are in a position to do what you usually want to do when a user accesses a route&amp;mdash;render a user interface to the screen that represents it.</source>
          <target state="translated">现在，我们了解了如何定义路线和访问有关当前路线的信息，我们可以执行用户访问路线时通常要执行的操作-将用户界面呈现到代表该路线的屏幕上。</target>
        </trans-unit>
        <trans-unit id="5267e95fd26270fb10fc686a7b3f0594b35acb8d" translate="yes" xml:space="preserve">
          <source>Now you can access &lt;code&gt;this.todo&lt;/code&gt; inside &lt;code&gt;Todos_item&lt;/code&gt; event handlers and helpers.</source>
          <target state="translated">现在，您可以在 &lt;code&gt;Todos_item&lt;/code&gt; 事件处理程序和帮助器中访问 &lt;code&gt;this.todo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43347d8449fb86f6793f729d6e976c40d2bdb2f3" translate="yes" xml:space="preserve">
          <source>Now you can edit the package, commit, and push, and your teammates will get your version of the package. To ensure that your package doesn&amp;rsquo;t get overwritten during an &lt;code&gt;npm update&lt;/code&gt;, change the default &lt;a href=&quot;https://docs.npmjs.com/misc/semver#caret-ranges-123-025-004&quot;&gt;caret version range&lt;/a&gt; in your &lt;code&gt;package.json&lt;/code&gt; to an exact version.</source>
          <target state="translated">现在，您可以编辑程序包，提交和推送，您的队友将获得您的程序包版本。为了确保您的软件包在 &lt;code&gt;npm update&lt;/code&gt; 期间不会被覆盖，请将 &lt;code&gt;package.json&lt;/code&gt; 中的默认&lt;a href=&quot;https://docs.npmjs.com/misc/semver#caret-ranges-123-025-004&quot;&gt;插入符号版本范围&lt;/a&gt;更改为确切的版本。</target>
        </trans-unit>
        <trans-unit id="8e94a5f60ef845c8fa131a2af08f79c2c69106bd" translate="yes" xml:space="preserve">
          <source>Now you can invoke this helper with &lt;code&gt;{{foo}}&lt;/code&gt; in the template defined with &lt;code&gt;&amp;lt;template name=&quot;myTemplate&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，您可以在 &lt;code&gt;&amp;lt;template name=&quot;myTemplate&quot;&amp;gt;&lt;/code&gt; 定义的模板中使用 &lt;code&gt;{{foo}}&lt;/code&gt; 来调用此帮助程序。</target>
        </trans-unit>
        <trans-unit id="cee8ff0c0a31ebc8d5d3632d61d0e0a89d1f35ec" translate="yes" xml:space="preserve">
          <source>Now your code becomes a bit simpler:</source>
          <target state="translated">现在你的代码变得更简单了。</target>
        </trans-unit>
        <trans-unit id="9f20e2ab259b720e366ab691310bf2293b2ccbc8" translate="yes" xml:space="preserve">
          <source>Now your users&amp;rsquo; apps will continue receiving hot code pushes. However, they won&amp;rsquo;t get the new version of the Cordova plugin until they update from the app store. In this case, that&amp;rsquo;s okay, because we only updated a patch version, so the &lt;code&gt;cordova-plugin-camera&lt;/code&gt; API didn&amp;rsquo;t change. But if you had added a new plugin, like &lt;code&gt;cordova-plugin-gyroscope&lt;/code&gt;, and changed your Javascript to call &lt;code&gt;navigator.gyroscope.getCurrent()&lt;/code&gt;, then when the old apps get the new JS code, they will throw the error: &lt;code&gt;Uncaught TypeError: Cannot read property 'getCurrent' of undefined&lt;/code&gt;.</source>
          <target state="translated">现在，您用户的应用程序将继续接收热代码推送。但是，只有从应用商店更新后，他们才能获得Cordova插件的新版本。在这种情况下，没关系，因为我们仅更新了补丁程序版本，因此 &lt;code&gt;cordova-plugin-camera&lt;/code&gt; API不变。但是，如果您添加了新的插件（例如 &lt;code&gt;cordova-plugin-gyroscope&lt;/code&gt; )，并将Java语言更改为调用 &lt;code&gt;navigator.gyroscope.getCurrent()&lt;/code&gt; ，则当旧应用获取新的JS代码时，它们将引发错误： &lt;code&gt;Uncaught TypeError: Cannot read property 'getCurrent' of undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cec615992c41a764006a8aef341f6a5c1a7ffb8b" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;accounts-facebook&lt;/code&gt; will be able to find that API key and Facebook login will work properly.</source>
          <target state="translated">现在， &lt;code&gt;accounts-facebook&lt;/code&gt; 将能够找到该API密钥，并且Facebook登录将正常工作。</target>
        </trans-unit>
        <trans-unit id="933897b29c318fda73422be92f1dbe88c2df4fbd" translate="yes" xml:space="preserve">
          <source>Now, if you fetch data using a Method, you can put into this collection:</source>
          <target state="translated">现在,如果你使用Method获取数据,你可以把这个集合。</target>
        </trans-unit>
        <trans-unit id="9b74d4e18faa0cdac3fcd363ee43ec890efffab7" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say you wanted to check if someone was allowed to delete a particular forum post:</source>
          <target state="translated">现在，假设您要检查是否允许某人删除特定的论坛帖子：</target>
        </trans-unit>
        <trans-unit id="2af8d4bcc2e3e0deeeba9ac257b11c64b30c580d" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s write some JavaScript to handle this form nicely:</source>
          <target state="translated">现在，让我们编写一些JavaScript来很好地处理此表单：</target>
        </trans-unit>
        <trans-unit id="8e55e6c6972017ace2706c15ecf84d201dd64b4e" translate="yes" xml:space="preserve">
          <source>Now, on running on Windows, the usual node modules &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; expect to get a DOS path. To assist you to write correct code, the &lt;code&gt;Plugin&lt;/code&gt; symbol provides its own versions of &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; that you can use instead (note that all methods on &lt;code&gt;fs&lt;/code&gt; are fiberized and sync versions prefer using Fibers rather than freezing the whole event loop).</source>
          <target state="translated">现在，在Windows上运行时，通常的节点模块 &lt;code&gt;fs&lt;/code&gt; 和 &lt;code&gt;path&lt;/code&gt; 希望获得DOS路径。为了帮助您编写正确的代码， &lt;code&gt;Plugin&lt;/code&gt; 符号提供了自己的 &lt;code&gt;fs&lt;/code&gt; 版本和您可以使用的 &lt;code&gt;path&lt;/code&gt; （请注意， &lt;code&gt;fs&lt;/code&gt; 上的所有方法都是纤维化的，并且同步版本更喜欢使用Fibers而不是冻结整个事件循环）。</target>
        </trans-unit>
        <trans-unit id="de133ac50673099a62de8bb19140b3871ca52b8f" translate="yes" xml:space="preserve">
          <source>Now, we can call this simple function to determine if a particular user is allowed to edit this list:</source>
          <target state="translated">现在,我们可以调用这个简单的函数来确定某个用户是否被允许编辑这个列表。</target>
        </trans-unit>
        <trans-unit id="243f8c30482c7afc35db1d5c12b7ee2af7917f7b" translate="yes" xml:space="preserve">
          <source>Now, we need to configure the package with our Google Analytics key (the package also supports a large variety of other providers, check out the &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;documentation on Atmosphere&lt;/a&gt;). Pass it in as part of &lt;a href=&quot;#environment&quot;&gt;&lt;em&gt;Meteor settings&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">现在，我们需要使用Google Analytics（分析）密钥配置该程序包（该程序包还支持大量其他提供商，请查看&lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;Atmosphere上&lt;/a&gt;的文档）。作为&lt;a href=&quot;#environment&quot;&gt;&lt;em&gt;流星设置的&lt;/em&gt;&lt;/a&gt;一部分传递：</target>
        </trans-unit>
        <trans-unit id="20b4ed3981502de2e2adf9a35402f25870f2eeac" translate="yes" xml:space="preserve">
          <source>Now, you can sign the APK:</source>
          <target state="translated">现在,你可以签署APK。</target>
        </trans-unit>
        <trans-unit id="3a278e0d7616c87b141f0dddb4ea2f20431d86bd" translate="yes" xml:space="preserve">
          <source>Now, you might be wondering what good the &lt;code&gt;modules&lt;/code&gt; package is without the &lt;code&gt;ecmascript&lt;/code&gt; package, since &lt;code&gt;ecmascript&lt;/code&gt; enables &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax. By itself, the &lt;code&gt;modules&lt;/code&gt; package provides the CommonJS &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; primitives that may be familiar if you&amp;rsquo;ve ever written Node code, and the &lt;code&gt;ecmascript&lt;/code&gt; package simply compiles &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements to CommonJS. The &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; primitives also allow Node modules to run within Meteor application code without modification. Furthermore, keeping &lt;code&gt;modules&lt;/code&gt; separate allows us to use &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; in places where using &lt;code&gt;ecmascript&lt;/code&gt; is tricky, such as the implementation of the &lt;code&gt;ecmascript&lt;/code&gt; package itself.</source>
          <target state="translated">现在，您可能想知道没有 &lt;code&gt;ecmascript&lt;/code&gt; 软件包的 &lt;code&gt;modules&lt;/code&gt; 包有什么好处，因为 &lt;code&gt;ecmascript&lt;/code&gt; 启用了 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 语法。 &lt;code&gt;modules&lt;/code&gt; 包本身提供了CommonJS &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;exports&lt;/code&gt; 原语（如果您曾经编写过Node代码，可能会很熟悉），而 &lt;code&gt;ecmascript&lt;/code&gt; 包仅将 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 语句编译为CommonJS。的 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; 的原语还允许节点模块无需修改流星应用程序代码中运行。此外，保持 &lt;code&gt;modules&lt;/code&gt; 分开允许我们使用 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;exports&lt;/code&gt; 的地方使用 &lt;code&gt;ecmascript&lt;/code&gt; 是棘手的，如实施 &lt;code&gt;ecmascript&lt;/code&gt; 包本身。</target>
        </trans-unit>
        <trans-unit id="71f74bba5f33a9d96d40a539150b810907ad33cc" translate="yes" xml:space="preserve">
          <source>Npm.depends()</source>
          <target state="translated">Npm.depends()</target>
        </trans-unit>
        <trans-unit id="e8316712a9a3315e031ca25c52b866ca8e4dd506" translate="yes" xml:space="preserve">
          <source>Npm.require</source>
          <target state="translated">Npm.require</target>
        </trans-unit>
        <trans-unit id="bd435600ec8b895b6a417198c49a8648125b7011" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait before calling function</source>
          <target state="translated">调用函数前等待的毫秒数。</target>
        </trans-unit>
        <trans-unit id="7605a5480c1ff4569d72023551211e89e95caea9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait between each function call.</source>
          <target state="translated">每次函数调用之间等待的毫秒数。</target>
        </trans-unit>
        <trans-unit id="8117159cb84b2356bcd7eba57411e351b99bcc3f" translate="yes" xml:space="preserve">
          <source>Number of results to skip at the beginning</source>
          <target state="translated">开始时要跳过的结果数量</target>
        </trans-unit>
        <trans-unit id="1806954e5411ad670e0fbd92643d34942dcf64ae" translate="yes" xml:space="preserve">
          <source>Numeric HTTP result status code, or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="translated">数字HTTP结果状态代码，或在错误时为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ec93f8987bc272ccffa8ce5330227b7ad595fd" translate="yes" xml:space="preserve">
          <source>OAuth login</source>
          <target state="translated">OAuth登录</target>
        </trans-unit>
        <trans-unit id="8176214d76b768ce951c721f257e68ce23db0f63" translate="yes" xml:space="preserve">
          <source>Occasionally, you may need to wait for data to become ready before it&amp;rsquo;s time to attach the plugin (although typically it&amp;rsquo;s a better idea to use a sub-component in this use case). To do so, you can setup an &lt;code&gt;autorun&lt;/code&gt; in the &lt;code&gt;onRendered()&lt;/code&gt; callback. For instance, in the &lt;code&gt;Lists_show_page&lt;/code&gt; component, we want to wait until the subscription for the list is ready (i.e. the todos have rendered) before we hide the launch screen:</source>
          <target state="translated">有时，您可能需要等待数据准备就绪才可以连接插件（尽管通常在此用例中使用子组件是一个更好的主意）。为此，您可以在 &lt;code&gt;onRendered()&lt;/code&gt; 回调中设置 &lt;code&gt;autorun&lt;/code&gt; 。例如，在 &lt;code&gt;Lists_show_page&lt;/code&gt; 组件中，我们要等到列表的订阅准备就绪（即待办事项已渲染）之后再隐藏启动屏幕：</target>
        </trans-unit>
        <trans-unit id="960b908bd16253af47c0f3825d9aef7e3c59869d" translate="yes" xml:space="preserve">
          <source>Of course in this scenario, you also need to be prepared for the server to fail, and again, indicate it to the user somehow.</source>
          <target state="translated">当然,在这种情况下,你还需要做好服务器失败的准备,再次以某种方式向用户表明。</target>
        </trans-unit>
        <trans-unit id="b45d04320ea3eb52cfab363837be0fa6fad1cdb7" translate="yes" xml:space="preserve">
          <source>Of course, calling &lt;code&gt;FlowRouter.go()&lt;/code&gt;, will always work, so unless you are trying to optimize for a specific situation it&amp;rsquo;s better to use that.</source>
          <target state="translated">当然，调用 &lt;code&gt;FlowRouter.go()&lt;/code&gt; 始终可以，因此，除非您尝试针对特定情况进行优化，否则最好使用它。</target>
        </trans-unit>
        <trans-unit id="26b57e258d7bb3f9ae229f4836280daf9ea9b387" translate="yes" xml:space="preserve">
          <source>Of course, we might find that we need to share this functionality between multiple pages of our app that require access control. We can easily share functionality between templates by wrapping them in a wrapper &amp;ldquo;layout&amp;rdquo; component which includes the behavior we want.</source>
          <target state="translated">当然，我们可能会发现我们需要在需要访问控制的应用程序的多个页面之间共享此功能。通过将模板包装在包含所需行为的包装&amp;ldquo;布局&amp;rdquo;组件中，我们可以轻松地在模板之间共享功能。</target>
        </trans-unit>
        <trans-unit id="2aea2e03ff924675060b7a8cb2fe04ea7326b52c" translate="yes" xml:space="preserve">
          <source>Of note here:</source>
          <target state="translated">这里要注意的是:</target>
        </trans-unit>
        <trans-unit id="138d82367af244892a0d51b98002680207912518" translate="yes" xml:space="preserve">
          <source>Of particular interest in this test is the following:</source>
          <target state="translated">在这个测试中,特别值得关注的是:</target>
        </trans-unit>
        <trans-unit id="18bbab6b1013657cad2554e317018c172391050a" translate="yes" xml:space="preserve">
          <source>Often it&amp;rsquo;s sensible to create a set of data to run your test against. You can use standard &lt;code&gt;insert()&lt;/code&gt; calls against your collections to do this, but often it&amp;rsquo;s easier to create &lt;em&gt;factories&lt;/em&gt; which help encode random test data. A great package to use to do this is &lt;a href=&quot;https://atmospherejs.com/dburles/factory&quot;&gt;&lt;code&gt;dburles:factory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，创建一组数据以运行测试是明智的。您可以对集合使用标准的 &lt;code&gt;insert()&lt;/code&gt; 调用来执行此操作，但是通常可以更轻松地创建有助于对随机测试数据进行编码的&lt;em&gt;工厂&lt;/em&gt;。&lt;a href=&quot;https://atmospherejs.com/dburles/factory&quot;&gt; &lt;code&gt;dburles:factory&lt;/code&gt; &lt;/a&gt;是用于执行此操作的绝佳软件包。</target>
        </trans-unit>
        <trans-unit id="ce371ca468f2ad5bc96714235a13afc604dae6cb" translate="yes" xml:space="preserve">
          <source>Often when you are dealing with templates or UI components, you&amp;rsquo;ll have several closely coupled files to manage. They could be two or more of HTML, CSS, and JavaScript files. In this case, we recommend putting these together in the same directory with the same name:</source>
          <target state="translated">通常，在处理模板或UI组件时，将需要管理几个紧密耦合的文件。它们可以是HTML，CSS和JavaScript文件中的两个或多个。在这种情况下，我们建议将它们放在相同名称的同一目录中：</target>
        </trans-unit>
        <trans-unit id="f69514bafa9d3c2c2947421f4615271aa4903f57" translate="yes" xml:space="preserve">
          <source>Often, a complicated accounts system is not the first thing you want to build when you&amp;rsquo;re starting out with a new app, so it&amp;rsquo;s useful to have something you can just drop in quickly. This is where &lt;code&gt;accounts-ui&lt;/code&gt; comes in - it&amp;rsquo;s just one line that you drop into your app to get an accounts system. To add it:</source>
          <target state="translated">通常，复杂的帐户系统并不是您在开始使用新应用程序时首先要构建的东西，因此拥有可以快速投入使用的东西很有用。这就是 &lt;code&gt;accounts-ui&lt;/code&gt; 的用处，它只是您放入应用程序以获取帐户系统的一行。要添加它：</target>
        </trans-unit>
        <trans-unit id="1d4c5e395b72c1f07599cd0399f4828ff5800a04" translate="yes" xml:space="preserve">
          <source>Often, however, a publication is more general. For example in the Todos example application, we create a &lt;code&gt;todos.inList&lt;/code&gt; publication, which publishes all the todos in a list. Although in the application we only use this in one place (in the &lt;code&gt;Lists_show&lt;/code&gt; template), in a larger app, there&amp;rsquo;s a good chance we might need to access all the todos for a list in other places. So putting the publication in the &lt;code&gt;todos&lt;/code&gt; package is a sensible approach.</source>
          <target state="translated">但是，出版物通常更为笼统。例如，在Todos示例应用程序中，我们创建一个 &lt;code&gt;todos.inList&lt;/code&gt; 发布，该发布将所有待办事项发布在一个列表中。尽管在应用程序中我们仅在一个位置（在 &lt;code&gt;Lists_show&lt;/code&gt; 模板中）使用此功能，但是在较大的应用程序中，我们很有可能需要在其他位置访问列表的所有待办事项。因此，将出版物放入 &lt;code&gt;todos&lt;/code&gt; 软件包中是一种明智的方法。</target>
        </trans-unit>
        <trans-unit id="443325ce9612c1f8f84b168f82ed27323cc08986" translate="yes" xml:space="preserve">
          <source>Often, users might want to associate multiple email addresses with the same account. &lt;code&gt;accounts-password&lt;/code&gt; addresses this case by storing the email addresses as an array in the user collection. There are some handy API methods to deal with &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-addEmail&quot;&gt;adding&lt;/a&gt;, &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-removeEmail&quot;&gt;removing&lt;/a&gt;, and &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-verifyEmail&quot;&gt;verifying&lt;/a&gt; emails.</source>
          <target state="translated">通常，用户可能希望将多个电子邮件地址与同一帐户关联。 &lt;code&gt;accounts-password&lt;/code&gt; 通过将电子邮件地址作为数组存储在用户集合中来解决这种情况。有一些便捷的API方法可以处理&lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-addEmail&quot;&gt;添加&lt;/a&gt;，&lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-removeEmail&quot;&gt;删除&lt;/a&gt;和&lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-verifyEmail&quot;&gt;验证&lt;/a&gt;电子邮件。</target>
        </trans-unit>
        <trans-unit id="cfe7e55941971a1d98a397fe624783a92e229249" translate="yes" xml:space="preserve">
          <source>Often, you just want to go to a new route programmatically when a user has completed a certain action. Above we saw a case (creating a new list) when we wanted to do it &lt;em&gt;optimistically&lt;/em&gt;&amp;mdash;i.e. before we hear back from the server that the Method succeeded. We can do this because we reasonably expect that the Method will succeed in almost all cases (see the &lt;a href=&quot;ui-ux#optimistic-ui&quot;&gt;UI/UX article&lt;/a&gt; for further discussion of this).</source>
          <target state="translated">通常，您只想在用户完成某项操作后以编程方式转到新路线。在上方，我们看到了一个案例（正在创建一个新列表），当我们想要&lt;em&gt;乐观地&lt;/em&gt;进行操作时（即，在我们从服务器那里听到方法成功之前）。我们之所以这样做，是因为我们有理由期望该方法在几乎所有情况下都能成功（有关此问题的进一步讨论，请参见&lt;a href=&quot;ui-ux#optimistic-ui&quot;&gt;UI / UX文章&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="81ee0c69e8974262677cd343bb41661a9b5a61d7" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy&lt;/a&gt;, configuration of SSL is automatic. &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;See the help article about SSL on Galaxy&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy上&lt;/a&gt;，SSL的配置是自动的。&lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;请参阅有关Galaxy上SSL的帮助文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff75ad65adb6098a8b59abd3b05217c7c50ef265" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy&lt;/a&gt;, simply enable the &amp;ldquo;Force HTTPS&amp;rdquo; setting on a specific domain in the &amp;ldquo;Domains &amp;amp; Encryption&amp;rdquo; section of the application&amp;rsquo;s &amp;ldquo;Settings&amp;rdquo; tab.</source>
          <target state="translated">在&lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy上&lt;/a&gt;，只需在应用程序的&amp;ldquo;设置&amp;rdquo;标签的&amp;ldquo;域和加密&amp;rdquo;部分中的特定域上启用&amp;ldquo;强制HTTPS&amp;rdquo;设置。</target>
        </trans-unit>
        <trans-unit id="a6d7796e5019fcc386bffcd860dfc592908312df" translate="yes" xml:space="preserve">
          <source>On Android</source>
          <target state="translated">在安卓系统上</target>
        </trans-unit>
        <trans-unit id="745c33bff0bc1fb981e36089f400ab76b32c5456" translate="yes" xml:space="preserve">
          <source>On Linux, you may want to use your distribution&amp;rsquo;s package manager to install a JDK; on Ubuntu, you can even use &lt;a href=&quot;#ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt; to install Android Studio and all dependencies at the same time.</source>
          <target state="translated">在Linux上，您可能需要使用发行版的软件包管理器来安装JDK。在Ubuntu上，您甚至可以使用&lt;a href=&quot;#ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt;同时安装Android Studio和所有依赖项。</target>
        </trans-unit>
        <trans-unit id="55cc237045e85e650876e95e2cc7456466fb8057" translate="yes" xml:space="preserve">
          <source>On OS X or Linux? Install the latest official Meteor release from your terminal:</source>
          <target state="translated">在OS X或Linux上?从您的终端安装最新的官方Meteor版本。</target>
        </trans-unit>
        <trans-unit id="5102fbdab1d89c3f4fb9dee7829cc0235edf341e" translate="yes" xml:space="preserve">
          <source>On Windows? &lt;a href=&quot;https://install.meteor.com/windows&quot;&gt;Download the official Meteor installer here&lt;/a&gt;.</source>
          <target state="translated">在Windows上？&lt;a href=&quot;https://install.meteor.com/windows&quot;&gt;在此处下载官方的Meteor安装程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5916ddb1f1b9cd570ff40f702eadb51ab338d9fc" translate="yes" xml:space="preserve">
          <source>On a client, &lt;code&gt;startup&lt;/code&gt; callbacks from packages will be called first, followed by &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; templates from your &lt;code&gt;.html&lt;/code&gt; files, followed by your application code.</source>
          <target state="translated">在客户端上，将首先调用来自程序包的 &lt;code&gt;startup&lt;/code&gt; 回调，然后调用 &lt;code&gt;.html&lt;/code&gt; 文件中的 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 模板，然后调用您的应用程序代码。</target>
        </trans-unit>
        <trans-unit id="f8503b506f6d1a70b0005bb3f49c7990a8ab813a" translate="yes" xml:space="preserve">
          <source>On a server, the function will run as soon as the server process is finished starting. On a client, the function will run as soon as the DOM is ready. Code wrapped in &lt;code&gt;Meteor.startup&lt;/code&gt; always runs after all app files have loaded, so you should put code here if you want to access shared variables from other files.</source>
          <target state="translated">在服务器上，该功能将在服务器进程启动完成后立即运行。在客户端上，该功能将在DOM准备就绪后立即运行。包装在 &lt;code&gt;Meteor.startup&lt;/code&gt; 中的代码始终在所有应用程序文件加载后运行，因此如果要访问其他文件中的共享变量，则应在此处放置代码。</target>
        </trans-unit>
        <trans-unit id="a6b3b76df1a9c7e83fb8d23a045c930341389f58" translate="yes" xml:space="preserve">
          <source>On iOS</source>
          <target state="translated">在iOS上</target>
        </trans-unit>
        <trans-unit id="48bc0a44f00af07795c39abeed16277ade7db908" translate="yes" xml:space="preserve">
          <source>On iOS, these settings also control &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;Application Transport Security (ATS)&lt;/a&gt;, which is an OS level mechanism to enforce security best practices new to iOS 9. If the server you&amp;rsquo;re connecting to does not (yet) fulfill these requirements, you can use additional options to override them for specific domains:</source>
          <target state="translated">在iOS上，这些设置还控制&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;应用程序传输安全性（ATS）&lt;/a&gt;，这是一种OS级机制，用于强制实施iOS 9新增的安全性最佳实践。如果您要连接的服务器（尚未）满足这些要求，则可以使用覆盖特定域的其他选项：</target>
        </trans-unit>
        <trans-unit id="14ed91aceae241220b95e4a7ec1cb3333a380100" translate="yes" xml:space="preserve">
          <source>On the client (and on the server if you specify a &lt;code&gt;connection&lt;/code&gt;), a Minimongo instance is created. Minimongo is essentially an in-memory, non-persistent implementation of Mongo in pure JavaScript. It serves as a local cache that stores just the subset of the database that this client is working with. Queries (&lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;) on these collections are served directly out of this cache, without talking to the server.</source>
          <target state="translated">在客户端（如果指定了 &lt;code&gt;connection&lt;/code&gt; ，则在服务器上）上，将创建一个Minimongo实例。Minimongo本质上是纯JavaScript中Mongo的内存内非持久实现。它用作本地缓存，仅存储此客户端正在使用的数据库的子集。这些集合中的查询（&lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;）直接从此缓存中提供，而无需与服务器通信。</target>
        </trans-unit>
        <trans-unit id="0ea13373e5b7461a0fea906787132de7016126dc" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;insert&lt;/code&gt; never blocks. If you do not provide a callback and the insert fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; arguments. In an error case, &lt;code&gt;result&lt;/code&gt; is undefined. If the insert is successful, &lt;code&gt;error&lt;/code&gt; is undefined and &lt;code&gt;result&lt;/code&gt; is the new document ID.</source>
          <target state="translated">在客户端上，从不 &lt;code&gt;insert&lt;/code&gt; 。如果不提供回调，并且服务器上的插入操作失败，则Meteor将向控制台记录警告。如果提供回调，Meteor将使用 &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 参数调用该函数。在错误情况下， &lt;code&gt;result&lt;/code&gt; 是不确定的。如果插入成功，则 &lt;code&gt;error&lt;/code&gt; 是未定义的， &lt;code&gt;result&lt;/code&gt; 是新的文档ID。</target>
        </trans-unit>
        <trans-unit id="1add8ef2291c9805d7d0586624b13276048d4749" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;remove&lt;/code&gt; never blocks. If you do not provide a callback and the remove fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of removed documents if the remove was successful.</source>
          <target state="translated">在客户端上，从不 &lt;code&gt;remove&lt;/code&gt; 块。如果不提供回调，并且服务器上的删除失败，则Meteor将向控制台记录警告。如果提供回调，如果发生错误，Meteor将使用错误参数调用该函数，如果成功删除，则第二个参数指示已删除文档的数量。</target>
        </trans-unit>
        <trans-unit id="653bd726229efe922f3f27fea407f7150676e99d" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;update&lt;/code&gt; never blocks. If you do not provide a callback and the update fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of affected documents if the update was successful.</source>
          <target state="translated">在客户端上， &lt;code&gt;update&lt;/code&gt; 永不阻塞。如果不提供回调，并且服务器上的更新失败，则Meteor将向控制台记录警告。如果提供了回调，如果发生错误，Meteor将使用错误参数调用该函数，如果更新成功，则第二个参数指示受影响的文档数。</target>
        </trans-unit>
        <trans-unit id="7f32fe2ee0817474a372e1e8ae52fe646847b731" translate="yes" xml:space="preserve">
          <source>On the client, if you do not pass a callback and you are not inside a stub, &lt;code&gt;call&lt;/code&gt; will return &lt;code&gt;undefined&lt;/code&gt;, and you will have no way to get the return value of the method. That is because the client doesn&amp;rsquo;t have fibers, so there is not actually any way it can block on the remote execution of a method.</source>
          <target state="translated">在客户端上，如果没有传递回调并且不在存根内部，则 &lt;code&gt;call&lt;/code&gt; 将返回 &lt;code&gt;undefined&lt;/code&gt; ，并且您将无法获取该方法的返回值。那是因为客户端没有光纤，所以实际上没有任何方法可以阻止方法的远程执行。</target>
        </trans-unit>
        <trans-unit id="97e318b871fc493987aefa000d7f3a7136f5052b" translate="yes" xml:space="preserve">
          <source>On the client, there is no direct connection to the MongoDB database, and in fact a synchronous API to it is not possible (nor probably what you want). Instead, on the client, a collection is a client side &lt;em&gt;cache&lt;/em&gt; of the database. This is achieved thanks to the &lt;a href=&quot;https://github.com/meteor/meteor/blob/master/packages/minimongo/README.md&quot;&gt;Minimongo&lt;/a&gt; library&amp;mdash;an in-memory, all JS, implementation of the MongoDB API. What this means is that on the client, when you write:</source>
          <target state="translated">在客户端上，没有与MongoDB数据库的直接连接，实际上，无法实现同步API（也可能不是您想要的）。相反，在客户端上，集合是数据库的客户端&lt;em&gt;缓存&lt;/em&gt;。这要归功于&lt;a href=&quot;https://github.com/meteor/meteor/blob/master/packages/minimongo/README.md&quot;&gt;Minimongo&lt;/a&gt;库，它是MongoDB API的内存中所有JS实现。这意味着在客户端上，当您编写时：</target>
        </trans-unit>
        <trans-unit id="dabc972369f4679d0d16a9b81ce1e1d06eda62fd" translate="yes" xml:space="preserve">
          <source>On the client, there will be a period of time between when the page loads and when the published data arrives from the server during which your client-side collections will be empty.</source>
          <target state="translated">在客户端,从页面加载到发布的数据从服务器到达之间会有一段时间,在这段时间内,你的客户端集合将是空的。</target>
        </trans-unit>
        <trans-unit id="b9ec4151f0542bf8935bb2a110772a88b9a893dd" translate="yes" xml:space="preserve">
          <source>On the client, this function logs in as the newly created user on successful completion. On the server, it returns the newly created user id.</source>
          <target state="translated">在客户端,该函数在成功完成后以新创建的用户身份登录。在服务器上,它返回新创建的用户ID。</target>
        </trans-unit>
        <trans-unit id="8a5acb33293d0313393c048ad638bfd92083e717" translate="yes" xml:space="preserve">
          <source>On the client, this function must be used asynchronously by passing a callback. Note that some browsers first send an &lt;code&gt;OPTIONS&lt;/code&gt; request before sending your request (in order to &lt;a href=&quot;http://stackoverflow.com/a/21783145/627729&quot;&gt;determine CORS headers&lt;/a&gt;).</source>
          <target state="translated">在客户端上，必须通过传递回调来异步使用此函数。请注意，某些浏览器在发送请求之前首先发送 &lt;code&gt;OPTIONS&lt;/code&gt; 请求（以&lt;a href=&quot;http://stackoverflow.com/a/21783145/627729&quot;&gt;确定CORS标头&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eaa20a28cb68276279b27461a27f53147dae5e83" translate="yes" xml:space="preserve">
          <source>On the client, this function must be used asynchronously by passing a callback. Note that some browsers first send an &lt;code&gt;OPTIONS&lt;/code&gt; request before sending your request (in order to &lt;a href=&quot;https://stackoverflow.com/a/21783145/627729&quot;&gt;determine CORS headers&lt;/a&gt;).</source>
          <target state="translated">在客户端上，必须通过传递回调来异步使用此函数。请注意，某些浏览器会先发送 &lt;code&gt;OPTIONS&lt;/code&gt; 请求，然后再发送您的请求（以&lt;a href=&quot;https://stackoverflow.com/a/21783145/627729&quot;&gt;确定CORS标头&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f6015e9b264ea9ff2daa1abf8a9e9b7b5a860b16" translate="yes" xml:space="preserve">
          <source>On the client, this will be called before the request is sent to allow for more direct manipulation of the underlying XMLHttpRequest object, which will be passed as the first argument. If the callback returns &lt;code&gt;false&lt;/code&gt;, the request will be not be send.</source>
          <target state="translated">在客户端上，将在发送请求之前调用此方法，以允许对底层XMLHttpRequest对象进行更直接的操作，该对象将作为第一个参数传递。如果回调返回 &lt;code&gt;false&lt;/code&gt; ，则不会发送请求。</target>
        </trans-unit>
        <trans-unit id="1f7d237318e434537f8ec0c2f087b87006b011e9" translate="yes" xml:space="preserve">
          <source>On the client, this will be the subset of the fields in the document that are published from the server (other fields won&amp;rsquo;t be available on the client). By default the server publishes &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;emails&lt;/code&gt;, and &lt;code&gt;profile&lt;/code&gt; (writable by user). See &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; for more on the fields used in user documents.</source>
          <target state="translated">在客户端上，这将是从服务器发布的文档中字段的子集（其他字段在客户端上将不可用）。默认情况下，服务器发布 &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;emails&lt;/code&gt; 和 &lt;code&gt;profile&lt;/code&gt; （可由用户写）。有关用户文档中使用的字段的更多信息，请参见&lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2d839a5a01227378d21989e056a5be46677e1e2" translate="yes" xml:space="preserve">
          <source>On the client, when you write the same line:</source>
          <target state="translated">在客户端上,当你写下同一行。</target>
        </trans-unit>
        <trans-unit id="afc1de8aec8fa06b9632e01b0701442486bb1392" translate="yes" xml:space="preserve">
          <source>On the client, you must pass &lt;code&gt;password&lt;/code&gt; and at least one of &lt;code&gt;username&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt; &amp;mdash; enough information for the user to be able to log in again later. If there are existing users with a username or email only differing in case, &lt;code&gt;createUser&lt;/code&gt; will fail. The callback&amp;rsquo;s &lt;code&gt;error.reason&lt;/code&gt; will be &lt;code&gt;'Username already exists.'&lt;/code&gt; or &lt;code&gt;'Email already exists.'&lt;/code&gt; In the latter case, the user can then either &lt;a href=&quot;accounts#Meteor-loginWithPassword&quot;&gt;login&lt;/a&gt; or &lt;a href=&quot;#Accounts-resetPassword&quot;&gt;reset their password&lt;/a&gt;.</source>
          <target state="translated">在客户端上，您必须传递 &lt;code&gt;password&lt;/code&gt; 以及 &lt;code&gt;username&lt;/code&gt; 或 &lt;code&gt;email&lt;/code&gt; 中的至少一个-足够的信息，以便用户以后可以再次登录。如果现有用户的用户名或电子邮件仅大小写不同，则 &lt;code&gt;createUser&lt;/code&gt; 将失败。回调的 &lt;code&gt;error.reason&lt;/code&gt; 将为 &lt;code&gt;'Username already exists.'&lt;/code&gt; 或 &lt;code&gt;'Email already exists.'&lt;/code&gt; 在后一种情况下，用户可以&lt;a href=&quot;accounts#Meteor-loginWithPassword&quot;&gt;登录&lt;/a&gt;或&lt;a href=&quot;#Accounts-resetPassword&quot;&gt;重设密码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18b15d1837ab6667c5f26cca3924bb3bef7af828" translate="yes" xml:space="preserve">
          <source>On the client: Meteor.userId()</source>
          <target state="translated">在客户端。Meteor.userId()</target>
        </trans-unit>
        <trans-unit id="e70822c537a9fd52312380b690a86d83c519fbcf" translate="yes" xml:space="preserve">
          <source>On the server (if you do not specify a &lt;code&gt;connection&lt;/code&gt;), a collection with that name is created on a backend Mongo server. When you call methods on that collection on the server, they translate directly into normal Mongo operations (after checking that they match your &lt;a href=&quot;#allow&quot;&gt;access control rules&lt;/a&gt;).</source>
          <target state="translated">在服务器上（如果未指定 &lt;code&gt;connection&lt;/code&gt; ），将在后端Mongo服务器上创建具有该名称的集合。当您在服务器上的该集合上调用方法时，它们将直接转换为正常的Mongo操作（在检查它们是否符合您的&lt;a href=&quot;#allow&quot;&gt;访问控制规则之后&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="07cfa1e9f8084a6cee89fcc56f5fbc9ed13cbb02" translate="yes" xml:space="preserve">
          <source>On the server however, the reactivity is limited to the behavior of the cursors you return from your publish functions. You&amp;rsquo;ll see any changes to the data that matches their queries, but &lt;em&gt;their queries will never change&lt;/em&gt;.</source>
          <target state="translated">但是，在服务器上，反应性仅限于从发布函数返回的游标的行为。您将看到与他们的查询相匹配的数据的任何更改，但是&lt;em&gt;他们的查询将永远不会更改&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0188c1ac7dbe4df73596a2a5c139b6b174f2a38c" translate="yes" xml:space="preserve">
          <source>On the server only, use the &lt;code&gt;oauthSecretKey&lt;/code&gt; option to &lt;code&gt;Accounts.config&lt;/code&gt;:</source>
          <target state="translated">仅在服务器上，对 &lt;code&gt;Accounts.config&lt;/code&gt; 使用 &lt;code&gt;oauthSecretKey&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="491c408bd602bf3e10630383bfb209018a4398c1" translate="yes" xml:space="preserve">
          <source>On the server, &lt;code&gt;HTTP.call&lt;/code&gt; is implemented by using the &lt;a href=&quot;https://www.npmjs.com/package/request&quot;&gt;npm &lt;code&gt;request&lt;/code&gt; module&lt;/a&gt;. Any options in this object will be passed directly to the &lt;code&gt;request&lt;/code&gt; invocation.</source>
          <target state="translated">在服务器上，使用&lt;a href=&quot;https://www.npmjs.com/package/request&quot;&gt;npm &lt;/a&gt; &lt;code&gt;request&lt;/code&gt; 模块实现 &lt;code&gt;HTTP.call&lt;/code&gt; 。该对象中的所有选项都将直接传递给 &lt;code&gt;request&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="4db290b2da5ce768449136be2535c12a1d9d531e" translate="yes" xml:space="preserve">
          <source>On the server, each connection has a different logged in user, so there is no global logged-in user state by definition. Since Meteor tracks the environment for each Method call, you can still use the &lt;code&gt;Meteor.userId()&lt;/code&gt; global, which returns a different value depending on which Method you call it from, but you can run into edge cases when dealing with asynchronous code. Also, &lt;code&gt;Meteor.userId()&lt;/code&gt; won&amp;rsquo;t work inside publications.</source>
          <target state="translated">在服务器上，每个连接都有一个不同的登录用户，因此根据定义，没有全局登录用户状态。由于Meteor会跟踪每个Method调用的环境，因此您仍然可以使用 &lt;code&gt;Meteor.userId()&lt;/code&gt; 全局值，该方法会返回不同的值，具体取决于您从哪个Method调用它，但是在处理异步代码时可能会遇到麻烦。另外， &lt;code&gt;Meteor.userId()&lt;/code&gt; 在发布中不起作用。</target>
        </trans-unit>
        <trans-unit id="85b8d6e4706ac22cf150547bdeb601b257863668" translate="yes" xml:space="preserve">
          <source>On the server, if &lt;code&gt;callback&lt;/code&gt; yields, other calls to &lt;code&gt;callback&lt;/code&gt; may occur while the first call is waiting. If strict sequential execution is necessary, use &lt;code&gt;forEach&lt;/code&gt; instead.</source>
          <target state="translated">在服务器上，如果产生 &lt;code&gt;callback&lt;/code&gt; ，则在等待第一个调用时可能会发生其他对 &lt;code&gt;callback&lt;/code&gt; 的调用。如果需要严格的顺序执行，请改用 &lt;code&gt;forEach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="429e978e9c94b620b3df5a646f8b2a8e4940810a" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;insert&lt;/code&gt; blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;insert&lt;/code&gt; still returns the ID immediately. Once the insert completes (or fails), the callback is called with error and result arguments. In an error case, &lt;code&gt;result&lt;/code&gt; is undefined. If the insert is successful, &lt;code&gt;error&lt;/code&gt; is undefined and &lt;code&gt;result&lt;/code&gt; is the new document ID.</source>
          <target state="translated">在服务器上，如果不提供回调，则 &lt;code&gt;insert&lt;/code&gt; 块，直到数据库确认该写入为止；否则，如果出现问题，则引发异常。如果提供回调， &lt;code&gt;insert&lt;/code&gt; 仍将立即返回ID。插入完成（或失败）后，将使用错误和结果参数调用回调。在错误情况下， &lt;code&gt;result&lt;/code&gt; 是不确定的。如果插入成功，则 &lt;code&gt;error&lt;/code&gt; 是未定义的， &lt;code&gt;result&lt;/code&gt; 是新的文档ID。</target>
        </trans-unit>
        <trans-unit id="54ab8cd4ba0db8afe0cfc9fb9618c22dca4f8eb2" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;remove&lt;/code&gt; blocks until the database acknowledges the write and then returns the number of removed documents, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;remove&lt;/code&gt; returns immediately. Once the remove completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of removed documents if the remove was successful.</source>
          <target state="translated">在服务器上，如果不提供回调，则 &lt;code&gt;remove&lt;/code&gt; 块，直到数据库确认该写入，然后返回删除的文档数，或者在出现问题时引发异常。如果提供回调，请立即 &lt;code&gt;remove&lt;/code&gt; 返回值。删除完成后，如果失败，则使用单个错误参数调用回调，如果删除成功，则使用第二个参数指示已删除文档的数量。</target>
        </trans-unit>
        <trans-unit id="7c1870dc195b5ee5604038af911f1b80fc9cc9e1" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;update&lt;/code&gt; blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;update&lt;/code&gt; returns immediately. Once the update completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of affected documents if the update was successful.</source>
          <target state="translated">在服务器上，如果不提供回调，请 &lt;code&gt;update&lt;/code&gt; 块，直到数据库确认该写入为止；否则，如果发生错误，则引发异常。如果您提供回调，则 &lt;code&gt;update&lt;/code&gt; 将立即返回。更新完成后，如果失败，则使用单个错误参数调用回调，如果更新成功，则使用第二个参数指示受影响的文档数。</target>
        </trans-unit>
        <trans-unit id="9bc201ea30a89331d1489d61b245e00670bd2573" translate="yes" xml:space="preserve">
          <source>On the server, methods from a given client run one at a time. The N+1th invocation from a client won&amp;rsquo;t start until the Nth invocation returns. However, you can change this by calling &lt;code&gt;this.unblock&lt;/code&gt;. This will allow the N+1th invocation to start running in a new fiber.</source>
          <target state="translated">在服务器上，来自给定客户端的方法一次运行一个。在第N次调用返回之前，不会开始从客户端进行第N + 1次调用。但是，您可以通过调用 &lt;code&gt;this.unblock&lt;/code&gt; 来更改此设置。这将允许第N + 1次调用开始在新的光纤中运行。</target>
        </trans-unit>
        <trans-unit id="cbc320393f69d85c371bb36999f2bd55b3c7baf3" translate="yes" xml:space="preserve">
          <source>On the server, the &lt;code&gt;func&lt;/code&gt; callback receives a single argument with the object below. On the client, no arguments are passed.</source>
          <target state="translated">在服务器上， &lt;code&gt;func&lt;/code&gt; 回调接收带有下面对象的单个参数。在客户端上，不传递任何参数。</target>
        </trans-unit>
        <trans-unit id="89c1586aa0c2031c351f98738c84314090bb14a7" translate="yes" xml:space="preserve">
          <source>On the server, the callbacks get a single argument, the same attempt info object as &lt;a href=&quot;#accounts_validateloginattempt&quot;&gt;&lt;code&gt;validateLoginAttempt&lt;/code&gt;&lt;/a&gt;. On the client, the callback argument is an object containing a single &lt;code&gt;error&lt;/code&gt; property set to the &lt;code&gt;Error&lt;/code&gt;-object which was received from the failed login attempt.</source>
          <target state="translated">在服务器上，回调仅获得一个参数，即与&lt;a href=&quot;#accounts_validateloginattempt&quot;&gt; &lt;code&gt;validateLoginAttempt&lt;/code&gt; &lt;/a&gt;相同的尝试信息对象。在客户端上，回调参数是一个对象，其中包含一个 &lt;code&gt;error&lt;/code&gt; 属性，该属性设置为从失败的登录尝试接收到的 &lt;code&gt;Error&lt;/code&gt; -object。</target>
        </trans-unit>
        <trans-unit id="44e718ef4d66951ac14b1cc8841a9c2faf603125" translate="yes" xml:space="preserve">
          <source>On the server, this function can be run either synchronously or asynchronously. If the callback is omitted, it runs synchronously and the results are returned once the request completes successfully. If the request was not successful, an error is thrown. This is useful when making server-to-server HTTP API calls from within Meteor methods, as the method can succeed or fail based on the results of the synchronous HTTP call. In this case, consider using &lt;a href=&quot;#method_unblock&quot;&gt;&lt;code&gt;this.unblock()&lt;/code&gt;&lt;/a&gt; to allow other methods on the same connection to run in the mean time.</source>
          <target state="translated">在服务器上，该功能可以同步或异步运行。如果省略了回调，则该回调将同步运行，并在请求成功完成后返回结果。如果请求不成功，则会引发错误。当从Meteor方法中进行服务器到服务器的HTTP API调用时，此方法很有用，因为该方法根据同步HTTP调用的结果而成功或失败。在这种情况下，请考虑使用&lt;a href=&quot;#method_unblock&quot;&gt; &lt;code&gt;this.unblock()&lt;/code&gt; &lt;/a&gt;允许同一连接上的其他方法同时运行。</target>
        </trans-unit>
        <trans-unit id="70e2f7a9ecd3c311b66026bbc208b1960fe15249" translate="yes" xml:space="preserve">
          <source>On the server, this will fetch the record from the database. To improve the latency of a method that uses the user document multiple times, save the returned record to a variable instead of re-calling &lt;code&gt;Meteor.user()&lt;/code&gt;.</source>
          <target state="translated">在服务器上，这将从数据库中获取记录。要提高多次使用用户文档的方法的延迟，请将返回的记录保存到变量中，而不是重新调用 &lt;code&gt;Meteor.user()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51a986b23985cfc7e29562bb2a712203a4504c44" translate="yes" xml:space="preserve">
          <source>On the server, we use the same technique of importing all the startup code in &lt;code&gt;imports/startup/server/index.js&lt;/code&gt;:</source>
          <target state="translated">在服务器上，我们使用相同的技术将所有启动代码 &lt;code&gt;imports/startup/server/index.js&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da923ccab281f74aa36b079065608464d121bd29" translate="yes" xml:space="preserve">
          <source>On the server, you do not need to specify &lt;code&gt;password&lt;/code&gt;, but the user will not be able to log in until it has a password (eg, set with &lt;a href=&quot;#accounts_setpassword&quot;&gt;&lt;code&gt;Accounts.setPassword&lt;/code&gt;&lt;/a&gt;). To create an account without a password on the server and still let the user pick their own password, call &lt;code&gt;createUser&lt;/code&gt; with the &lt;code&gt;email&lt;/code&gt; option and then call &lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt;&lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt;&lt;/a&gt;. This will send the user an email with a link to set their initial password.</source>
          <target state="translated">在服务器上，您不需要指定 &lt;code&gt;password&lt;/code&gt; ，但是只有在用户输入密码后（例如，使用&lt;a href=&quot;#accounts_setpassword&quot;&gt; &lt;code&gt;Accounts.setPassword&lt;/code&gt; 进行&lt;/a&gt;设置），用户才能登录。要在服务器上创建一个没有密码的帐户并仍然让用户选择自己的密码，请使用 &lt;code&gt;email&lt;/code&gt; 选项调用 &lt;code&gt;createUser&lt;/code&gt; ，然后调用&lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt; &lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt; &lt;/a&gt;。这将向用户发送一封电子邮件，其中包含用于设置其初始密码的链接。</target>
        </trans-unit>
        <trans-unit id="46faa89b0fbc4115f7f4811b4569fdd7a346daf0" translate="yes" xml:space="preserve">
          <source>On the server: this.userId</source>
          <target state="translated">在服务器上:this.userId</target>
        </trans-unit>
        <trans-unit id="44e01a4cda4b433ec03752b4587a42ca1d9aee41" translate="yes" xml:space="preserve">
          <source>Once a module is fetched dynamically from the server, it is cached permanently on the client and additional requests for the same version of the module will not incur the round-trip request to the server. If the module is changed then a fresh copy will always be retrieved from the server.</source>
          <target state="translated">一旦一个模块从服务器上动态获取,它就会被永久缓存在客户端,对同一版本的模块的额外请求将不会引起对服务器的往返请求。如果模块被更改,那么将始终从服务器上获取一个新的副本。</target>
        </trans-unit>
        <trans-unit id="5126f3bcfb9239690a7e3b739eba4ac9d3cc23ef" translate="yes" xml:space="preserve">
          <source>Once a user has visited a Meteor application for the first time and the application has been cached, on subsequent visits the web page loads faster because the browser can load the application out of the cache without contacting the server first.</source>
          <target state="translated">一旦用户第一次访问Meteor应用,并且应用已经被缓存,在后续的访问中,网页的加载速度会更快,因为浏览器可以从缓存中加载应用,而不需要先联系服务器。</target>
        </trans-unit>
        <trans-unit id="ca107596881d6b20257fbc20a6164119f3ec317a" translate="yes" xml:space="preserve">
          <source>Once a user is logged into your app with one of the methods described above, it is useful to be able to identify which user is logged in, and get the data provided during the registration process.</source>
          <target state="translated">一旦用户用上述的一种方法登录到你的应用中,能够识别出是哪个用户登录的,并获得注册过程中提供的数据是很有用的。</target>
        </trans-unit>
        <trans-unit id="b3297f83bd8f9951ac215ba7e4a1c6167cbe66f8" translate="yes" xml:space="preserve">
          <source>Once enabled, view the application in a web-browser as usual (e.g. &lt;code&gt;http://localhost:3000/&lt;/code&gt;) and the chart will be displayed on top of the application.</source>
          <target state="translated">启用后，照常在网络浏览器中查看该应用程序（例如 &lt;code&gt;http://localhost:3000/&lt;/code&gt; ），该图表将显示在该应用程序的顶部。</target>
        </trans-unit>
        <trans-unit id="2533b6541866ff4914792590e5df2e6bc1eb1c54" translate="yes" xml:space="preserve">
          <source>Once installed, you&amp;rsquo;ll be able to import the &lt;code&gt;withTracker&lt;/code&gt; function, which allows you to create a &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.by86emv9b&quot;&gt;container component&lt;/a&gt; which provides data to your presentational components.</source>
          <target state="translated">安装完成后，您将能够导入 &lt;code&gt;withTracker&lt;/code&gt; 函数，该函数可让您创建一个&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.by86emv9b&quot;&gt;容器组件&lt;/a&gt;，该组件为您的演示组件提供数据。</target>
        </trans-unit>
        <trans-unit id="b67d613887650758e15f19b06c6a5f36853067c8" translate="yes" xml:space="preserve">
          <source>Once that template exists, we can simply wrap our &lt;code&gt;Lists_show_page&lt;/code&gt;:</source>
          <target state="translated">该模板存在后，我们可以简单地包装 &lt;code&gt;Lists_show_page&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="518704cb2e96bb183f262fdaec85e1f23718b579" translate="yes" xml:space="preserve">
          <source>Once the Method has finished running on the server, it sends a &lt;code&gt;result&lt;/code&gt; message to the client with the Method ID generated in step 2, and the return value itself. The client stores this for later use, but &lt;em&gt;doesn&amp;rsquo;t call the Method callback yet&lt;/em&gt;. If you pass the &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_apply&quot;&gt;&lt;code&gt;onResultReceived&lt;/code&gt; option to &lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt;, that callback is fired.</source>
          <target state="translated">一旦方法在服务器上完成运行，它就会将 &lt;code&gt;result&lt;/code&gt; 消息与步骤2中生成的方法ID和返回值本身一起发送给客户端。客户端将其存储以供以后使用，但&lt;em&gt;尚未调用Method回调&lt;/em&gt;。如果将&lt;a href=&quot;http://docs.meteor.com/#/full/meteor_apply&quot;&gt; &lt;code&gt;onResultReceived&lt;/code&gt; 选项 &lt;code&gt;Meteor.apply&lt;/code&gt; &lt;/a&gt;传递给Meteor.apply，则会触发该回调。</target>
        </trans-unit>
        <trans-unit id="e5f45093103cdeb6f86503596e29067b6099beff" translate="yes" xml:space="preserve">
          <source>Once the state dictionary has been created we can access it from helpers and modify it in event handlers (see the code snippet above).</source>
          <target state="translated">一旦创建了状态字典,我们就可以从帮助程序中访问它,并在事件处理程序中修改它(见上面的代码片段)。</target>
        </trans-unit>
        <trans-unit id="347c43bf77a2e13e82e0b560b35bac5a9376f97e" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve attached this helper to the &lt;code&gt;Lists&lt;/code&gt; collection, every time we fetch a list from the database (on the client or server), it will have a &lt;code&gt;.isPrivate()&lt;/code&gt; function available:</source>
          <target state="translated">一旦将此帮助程序附加到 &lt;code&gt;Lists&lt;/code&gt; 集合，每次我们从数据库（在客户端或服务器上）获取列表时，它将具有一个 &lt;code&gt;.isPrivate()&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="e932fec5060640656d7330ec7f00490b7967c3bf" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the staging release, release the &lt;em&gt;exact same&lt;/em&gt; version to production.</source>
          <target state="translated">对分段发布感到满意后，将&lt;em&gt;完全相同的&lt;/em&gt;版本发布到生产环境。</target>
        </trans-unit>
        <trans-unit id="a79bba56d135c41c83bd6533395e726d2300f863" translate="yes" xml:space="preserve">
          <source>Once you are setup with Galaxy, deployment is simple (just re-run the &lt;code&gt;meteor deploy&lt;/code&gt; command above), and scaling is even easier&amp;mdash;simply log into galaxy.meteor.com, and scale instantly from there.</source>
          <target state="translated">一旦使用Galaxy进行设置，部署就很简单（只需重新运行上面的 &lt;code&gt;meteor deploy&lt;/code&gt; 命令），扩展就更容易了-只需登录galaxy.meteor.com，然后从那里立即进行扩展。</target>
        </trans-unit>
        <trans-unit id="d567acddad201ed3ca8ae40b9e92daa2588d7e9e" translate="yes" xml:space="preserve">
          <source>Once you configure routing according to &lt;a href=&quot;#useraccounts-customizing-routes&quot;&gt;the section below&lt;/a&gt;, you&amp;rsquo;ll want to remove this inclusion.</source>
          <target state="translated">根据&lt;a href=&quot;#useraccounts-customizing-routes&quot;&gt;以下部分&lt;/a&gt;配置路由后，您将希望删除此包含项。</target>
        </trans-unit>
        <trans-unit id="495554e141ec4fb979c87f48a245cd122a124f3c" translate="yes" xml:space="preserve">
          <source>Once you have your account you can log in and log out from the command line, and check your username with &lt;code&gt;meteor whoami&lt;/code&gt;.</source>
          <target state="translated">拥有帐户后，您可以从命令行登录和注销，然后使用 &lt;code&gt;meteor whoami&lt;/code&gt; 检查您的用户名。</target>
        </trans-unit>
        <trans-unit id="b0b6798a5ef1f56f315834a343e71297556b86a0" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve built and tested your Meteor application, you need to put it online to show it to the world. Deploying a Meteor application is similar to deploying any other websocket-based Node.js app, but is different in some of the specifics.</source>
          <target state="translated">一旦构建并测试了Meteor应用程序，就需要将其在线展示给全世界。部署Meteor应用程序类似于部署任何其他基于websocket的Node.js应用程序，但是在某些特定方面有所不同。</target>
        </trans-unit>
        <trans-unit id="8e9d02714832708eb544d6a7629765641536185d" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve done that, it&amp;rsquo;s easy to &lt;a href=&quot;http://galaxy-guide.meteor.com/deploy-guide.html&quot;&gt;deploy to Galaxy&lt;/a&gt;. You just need to &lt;a href=&quot;http://galaxy-guide.meteor.com/environment-variables.html&quot;&gt;add some environment variables to your settings file&lt;/a&gt; to point it at your MongoDB, and you can deploy with:</source>
          <target state="translated">完成此操作后，很容易将其&lt;a href=&quot;http://galaxy-guide.meteor.com/deploy-guide.html&quot;&gt;部署到Galaxy&lt;/a&gt;。您只需要向&lt;a href=&quot;http://galaxy-guide.meteor.com/environment-variables.html&quot;&gt;设置文件中添加一些环境变量，以将&lt;/a&gt;其指向您的MongoDB，即可使用以下方法进行部署：</target>
        </trans-unit>
        <trans-unit id="8340eb82f46c8b657e390886dfec30a56bdd7b50" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve gotten your initial prototype up and running with &lt;code&gt;accounts-ui&lt;/code&gt;, you&amp;rsquo;ll want to move to something more powerful and configurable so that you can better integrate your login flow with the rest of your app. The &lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md&quot;&gt;&lt;code&gt;useraccounts&lt;/code&gt; family of packages&lt;/a&gt; is the most powerful set of accounts management UI controls available for Meteor today. If you need even more customization, you can also roll your own system, but it&amp;rsquo;s worth trying &lt;code&gt;useraccounts&lt;/code&gt; first.</source>
          <target state="translated">一旦完成了最初的原型并使用 &lt;code&gt;accounts-ui&lt;/code&gt; 运行后，您将希望转而使用更强大和可配置的工具，以便更好地将登录流与应用程序的其余部分集成。该&lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md&quot;&gt; &lt;code&gt;useraccounts&lt;/code&gt; 家庭套餐&lt;/a&gt;是最强大的一套针对当今流星账户管理UI控件。如果您需要更多的自定义，也可以滚动自己的系统，但是首先尝试使用用户 &lt;code&gt;useraccounts&lt;/code&gt; 是值得的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
