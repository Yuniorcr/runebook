<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="009c795e3111448694cc3dc957f4b70c8f03b727" translate="yes" xml:space="preserve">
          <source>Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.</source>
          <target state="translated">识别任何JavaScript值的基元类型的模块。输出一个函数,返回一个带有作为参数传递的值的类型的字符串。</target>
        </trans-unit>
        <trans-unit id="6dc759ef821892268cbe7edeb6bcf5abc7a031f8" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;JestWorker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be53179917b8757ad3b5f547e48374b67d70e70" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;Worker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="translated">用于任务并行化的模块。导出一个采用Node.js模块路径的类 &lt;code&gt;Worker&lt;/code&gt; ，并让您像调用类方法一样调用模块的导出方法，返回一个Promise，当指定的方法在派生进程中完成其执行时，它会解析。</target>
        </trans-unit>
        <trans-unit id="5123a0149608b8f62ab410c929a918587d7bbf79" translate="yes" xml:space="preserve">
          <source>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</source>
          <target state="translated">被映射到别名的模块,无论是否启用了自动锁定,默认都是解除锁定的。</target>
        </trans-unit>
        <trans-unit id="400881ff44dd95e53d5b70de2d221304a209dd8b" translate="yes" xml:space="preserve">
          <source>Modules that are mocked with &lt;code&gt;jest.mock&lt;/code&gt; are mocked only for the file that calls &lt;code&gt;jest.mock&lt;/code&gt;. Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.</source>
          <target state="translated">用 &lt;code&gt;jest.mock&lt;/code&gt; 模拟的模块仅针对调用 &lt;code&gt;jest.mock&lt;/code&gt; 的文件模拟。另一个导入模块的文件将获得原始实现，即使该文件在模拟该模块的测试文件之后运行。</target>
        </trans-unit>
        <trans-unit id="bb101179b6d768145f738342dfe298b98e4b70e0" translate="yes" xml:space="preserve">
          <source>More Resources</source>
          <target state="translated">更多资源</target>
        </trans-unit>
        <trans-unit id="2028778347f5faaf24a3510ff5fbd1a91da38244" translate="yes" xml:space="preserve">
          <source>More about serializers API can be found &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format/README.md#serialize&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7a524aa43cd2033804e07ac0567266d5069451" translate="yes" xml:space="preserve">
          <source>More information can be found at &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;上找到更多信息。</target>
        </trans-unit>
        <trans-unit id="fde45e0d5214ab7d193c97e2773574aa18d36ca8" translate="yes" xml:space="preserve">
          <source>More information on Node debugging can be found &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">有关节点调试的更多信息，请参见&lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25a40503253892e6560d8d5c69a4720093cc2ba6" translate="yes" xml:space="preserve">
          <source>More information on how snapshot testing works and why we built it can be found on the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;release blog post&lt;/a&gt;. We recommend reading &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;this blog post&lt;/a&gt; to get a good sense of when you should use snapshot testing. We also recommend watching this &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;egghead video&lt;/a&gt; on Snapshot Testing with Jest.</source>
          <target state="translated">有关快照测试如何工作以及我们为何构建快照的更多信息，请参见&lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;发布博客文章&lt;/a&gt;。我们建议您阅读&lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;此博客文章&lt;/a&gt;，以更好地了解何时应使用快照测试。我们还建议您在&amp;ldquo;用Jest进行快照测试&amp;rdquo;上观看这个&lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;笨蛋视频&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f58721cb66c8644aaf7f808a07bb173fa203cd2" translate="yes" xml:space="preserve">
          <source>Most commonly this is being caused by conflicting Promise implementations. Consider replacing the global promise implementation with your own, for example &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; and/or consolidate the used Promise libraries to a single one.</source>
          <target state="translated">最常见的原因是Promise实现冲突。考虑用您自己的全局诺言实现替换，例如 &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; 和/或将使用过的Promise库合并为一个库。</target>
        </trans-unit>
        <trans-unit id="d5fa9ec15923cf5a4447d89705061f4895a3a460" translate="yes" xml:space="preserve">
          <source>Most likely your glob patterns are not matching any files. Refer to the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; documentation to ensure your globs are compatible.</source>
          <target state="translated">您的全局模式很可能与任何文件都不匹配。请参阅&lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt;文档，以确保您的glob兼容。</target>
        </trans-unit>
        <trans-unit id="e06083df81e4470b804ff5d773dde170c25982a4" translate="yes" xml:space="preserve">
          <source>Most of the differences are explained in &lt;a href=&quot;https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs&quot;&gt;Node's documentation&lt;/a&gt;, but in addition to the things mentioned there, Jest injects a special variable into all executed files - the &lt;a href=&quot;jest-object&quot;&gt;&lt;code&gt;jest&lt;/code&gt; object&lt;/a&gt;. To access this object in ESM, you need to import it from the &lt;code&gt;@jest/globals&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70aff9a2e6d1a508cc94211f970a06aadb07a7f" translate="yes" xml:space="preserve">
          <source>Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.</source>
          <target state="translated">大多数现实世界的例子实际上涉及到在依赖组件上获取一个模拟函数并配置它,但技术是一样的。在这些情况下,尽量避免在任何没有直接测试的函数中实现逻辑的诱惑。</target>
        </trans-unit>
        <trans-unit id="1743857a25bf614f38c27b820f8398e3eb15e127" translate="yes" xml:space="preserve">
          <source>Most ways of comparing numbers have matcher equivalents.</source>
          <target state="translated">大多数比较数字的方法都有匹配器等价物。</target>
        </trans-unit>
        <trans-unit id="07d9d7323ef86fe85fd1d7687235aac297bdcdee" translate="yes" xml:space="preserve">
          <source>Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.</source>
          <target state="translated">接下来,让我们配置Jest来优雅地处理资产文件,如样式表和图像。通常情况下,这些文件在测试中并不是特别有用,所以我们可以安全地将它们模拟出来。但是,如果你使用的是CSS模块,那么最好为你的className查找模拟一个代理。</target>
        </trans-unit>
        <trans-unit id="0cd213a32f05bcc17b41830bc252640d32af3383" translate="yes" xml:space="preserve">
          <source>No default</source>
          <target state="translated">无缺省</target>
        </trans-unit>
        <trans-unit id="069541cf8be1f0d43b5c179ab178c1af971111c3" translate="yes" xml:space="preserve">
          <source>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing &lt;code&gt;--updateSnapshot&lt;/code&gt;. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.</source>
          <target state="translated">不，从Jest 20开始，如果Jest在CI系统中运行而未显式传递 &lt;code&gt;--updateSnapshot&lt;/code&gt; ,则不会自动写入Jest中的快照。预计所有快照都是在CI上运行的代码的一部分，并且由于新快照会自动通过，因此它们不应通过在CI系统上运行的测试。建议始终提交所有快照并将其保留在版本控制中。</target>
        </trans-unit>
        <trans-unit id="2c8a846eddb8681ebf180cd4b3a87cddb1fe5a15" translate="yes" xml:space="preserve">
          <source>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</source>
          <target state="translated">这些形式中没有一种是特别优越的,你可以在一个代码库中甚至在一个文件中混合和匹配它们。这只是取决于你觉得哪种风格能让你的测试更简单。</target>
        </trans-unit>
        <trans-unit id="593dc274bf37fc96d1260b84eb4792e03219586d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;column&lt;/code&gt; is 0-indexed while &lt;code&gt;line&lt;/code&gt; is not.</source>
          <target state="translated">请注意， &lt;code&gt;column&lt;/code&gt; 是0索引的，而 &lt;code&gt;line&lt;/code&gt; 则不是。</target>
        </trans-unit>
        <trans-unit id="92f6cb372e87dfa7e7a0186add10026144aaa046" translate="yes" xml:space="preserve">
          <source>Note that due to its experimental nature there are many bugs and missing features in Jest's implementation, both known and unknown. You should check out the &lt;a href=&quot;https://github.com/facebook/jest/issues/9430&quot;&gt;tracking issue&lt;/a&gt; and the &lt;a href=&quot;https://github.com/facebook/jest/labels/ES%20Modules&quot;&gt;label&lt;/a&gt; on the issue tracker for the latest status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbb94ab3f435207f3668ea824069ffb13ba8524" translate="yes" xml:space="preserve">
          <source>Note that the mock can't be an arrow function because calling &lt;code&gt;new&lt;/code&gt; on an arrow function is not allowed in JavaScript. So this won't work:</source>
          <target state="translated">请注意，模拟不能是箭头函数，因为JavaScript中不允许在箭头函数上调用 &lt;code&gt;new&lt;/code&gt; 。所以这行不通：</target>
        </trans-unit>
        <trans-unit id="35e09d6f70cb52a597a44fb09de97ecc2bafcf55" translate="yes" xml:space="preserve">
          <source>Note that the top-level &lt;code&gt;beforeEach&lt;/code&gt; is executed before the &lt;code&gt;beforeEach&lt;/code&gt; inside the &lt;code&gt;describe&lt;/code&gt; block. It may help to illustrate the order of execution of all hooks.</source>
          <target state="translated">需要注意的是顶级 &lt;code&gt;beforeEach&lt;/code&gt; 是之前执行 &lt;code&gt;beforeEach&lt;/code&gt; 里面的 &lt;code&gt;describe&lt;/code&gt; 块。这可能有助于说明所有挂钩的执行顺序。</target>
        </trans-unit>
        <trans-unit id="dab00f8f32e989ec35b0b0ca3de5a6325b1623eb" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;v8&lt;/code&gt; is considered experimental. This uses V8's builtin code coverage rather than one based on Babel. It is not as well tested, and it has also improved in the last few releases of Node. Using the latest versions of node (v14 at the time of this writing) will yield better results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5317a3a7e7d23a56315a8874c449817c31ad8a0c" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">请注意，如果您在此处指定一个全局参考值（如对象或数组），并且某些代码在运行测试过程中对该值进行了更改，则该更改将&lt;em&gt;不会&lt;/em&gt;在其他测试文件的测试运行中持续存在。另外， &lt;code&gt;globals&lt;/code&gt; 对象必须是json可序列化的，因此不能用于指定全局函数。为此，您应该使用 &lt;code&gt;setupFiles&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b104c13194e34da09ed53bf72fc268a0c3110ad" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition, the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that, you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc786612e42a25f8f3750696a48a69840f36cd3" translate="yes" xml:space="preserve">
          <source>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to &lt;a href=&quot;asynchronous#promises&quot;&gt;tell Jest to wait&lt;/a&gt; by returning the unwrapped assertion.</source>
          <target state="translated">请注意，由于您仍在测试Promise，因此测试仍然是异步的。因此，您需要通过返回未包装的断言来&lt;a href=&quot;asynchronous#promises&quot;&gt;告诉Jest等待&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9794622b767437b0ecae517257f9db04f7adf32d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your &lt;code&gt;package.json&lt;/code&gt; is located unless you specify a custom &lt;code&gt;rootDir&lt;/code&gt; option in your configuration.</source>
          <target state="translated">注意： &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 是一个特殊标记，将Jest替换为项目的根。在大多数情况下，除非您在配置中指定了自定义 &lt;code&gt;rootDir&lt;/code&gt; 选项，否则它将是 &lt;code&gt;package.json&lt;/code&gt; 所在的文件夹。</target>
        </trans-unit>
        <trans-unit id="628dafac3ccff711682a19552f96e64d7e9e0c0e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;.toEqual&lt;/code&gt; won't perform a &lt;em&gt;deep equality&lt;/em&gt; check for two errors. Only the &lt;code&gt;message&lt;/code&gt; property of an Error is considered for equality. It is recommended to use the &lt;code&gt;.toThrow&lt;/code&gt; matcher for testing against errors.</source>
          <target state="translated">注意： &lt;code&gt;.toEqual&lt;/code&gt; 不会对两个错误执行&lt;em&gt;深度相等&lt;/em&gt;检查。仅考虑Error 的 &lt;code&gt;message&lt;/code&gt; 属性是否相等。建议使用 &lt;code&gt;.toThrow&lt;/code&gt; 匹配器进行错误测试。</target>
        </trans-unit>
        <trans-unit id="7613acf3a264c0259c7e5490495960bb2558a069" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;babel-jest&lt;/code&gt; is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the &lt;code&gt;transform&lt;/code&gt; configuration option:</source>
          <target state="translated">注意：安装Jest时会自动安装 &lt;code&gt;babel-jest&lt;/code&gt; ,如果项目中存在babel配置，它将自动转换文件。为了避免这种现象，您可以显式重置 &lt;code&gt;transform&lt;/code&gt; 配置选项：</target>
        </trans-unit>
        <trans-unit id="d063b0b7dc564c8180bc1b9d7afb5ca825c92c4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;test.concurrent&lt;/code&gt; is considered experimental - see &lt;a href=&quot;https://github.com/facebook/jest/labels/Area%3A%20Concurrent&quot;&gt;here&lt;/a&gt; for details on missing features and other issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bf41dd30024dc8f6a9cf73cdb3281441a7c127" translate="yes" xml:space="preserve">
          <source>Note: For more complex webpack configurations, you may also want to investigate projects such as: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;.</source>
          <target state="translated">注意：对于更复杂的Webpack配置，您可能还需要研究以下项目：&lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5ee4f891332fe29d99fc8b7113be07b4978e5d9" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;strong&gt;promise is returned&lt;/strong&gt; from &lt;code&gt;test&lt;/code&gt;, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you &lt;strong&gt;provide an argument to the test function&lt;/strong&gt;, usually called &lt;code&gt;done&lt;/code&gt;. This could be handy when you want to test callbacks. See how to test async code &lt;a href=&quot;asynchronous#callbacks&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">注意：如果从 &lt;code&gt;test&lt;/code&gt; &lt;strong&gt;返回&lt;/strong&gt;了&lt;strong&gt;承诺&lt;/strong&gt;，则Jest将等待承诺解决，然后再完成测试。如果您&lt;strong&gt;向test函数提供参数&lt;/strong&gt;（通常称为 &lt;code&gt;done&lt;/code&gt; )，Jest也会等待。当您要测试回调时，这可能很方便。&lt;a href=&quot;asynchronous#callbacks&quot;&gt;在此处&lt;/a&gt;查看如何测试异步代码。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2c9e685037a098f7ab5cab7e553edaf0c09711f" translate="yes" xml:space="preserve">
          <source>Note: In order to mock properly, Jest needs &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; to be in the same scope as the &lt;code&gt;require/import&lt;/code&gt; statement.</source>
          <target state="translated">注意：为了正确进行模拟，Jest需要将 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 与 &lt;code&gt;require/import&lt;/code&gt; 语句置于同一范围内。</target>
        </trans-unit>
        <trans-unit id="9fc7ec9481edc4a64cc4cee9fd0a5b4e7d421cf5" translate="yes" xml:space="preserve">
          <source>Note: Jest caches files to speed up test execution. If you updated .babelrc and Jest is still not working, try running Jest with &lt;code&gt;--no-cache&lt;/code&gt;.</source>
          <target state="translated">注意：Jest缓存文件以加快测试执行速度。如果您更新了.babelrc，而Jest仍然无法运行，请尝试使用 &lt;code&gt;--no-cache&lt;/code&gt; 运行Jest 。</target>
        </trans-unit>
        <trans-unit id="18499d47a5d29c4202e6b0823b51b2cc1f3a7091" translate="yes" xml:space="preserve">
          <source>Note: Jest documentation uses &lt;code&gt;yarn&lt;/code&gt; commands, but &lt;code&gt;npm&lt;/code&gt; will also work. You can compare &lt;code&gt;yarn&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands in the &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn docs, here&lt;/a&gt;.</source>
          <target state="translated">注意：Jest文档使用 &lt;code&gt;yarn&lt;/code&gt; 命令，但是 &lt;code&gt;npm&lt;/code&gt; 也可以使用。您可以在&lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn文档中&lt;/a&gt;比较 &lt;code&gt;yarn&lt;/code&gt; 和 &lt;code&gt;npm&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="5cff4d7445c3ba40f87a1439f00a6eba64d370e9" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example it's &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with page prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="translated">注意：快照直接作用于您呈现的数据&amp;ndash;在我们的示例中，它是 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 组件，并传递了页面属性。这意味着，即使任何其他文件在 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 组件中缺少props（Say， &lt;code&gt;App.js&lt;/code&gt; ），它也将通过测试，因为该测试不知道 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 组件的用法且范围有限仅链接到 &lt;code&gt;Link.react.js&lt;/code&gt; 。另外，在其他快照测试中使用不同的道具渲染相同的组件不会影响第一个组件，因为这些测试彼此之间并不了解。</target>
        </trans-unit>
        <trans-unit id="6496fae13ef766903ec9c79181224c2df30885e8" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with &lt;code&gt;page&lt;/code&gt; prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866607a189359968f5ff8b001676f89035486e7b" translate="yes" xml:space="preserve">
          <source>Note: This function is not available when using modern fake timers implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58fe2211cffb9e77307ff7a8d198bd500bab696" translate="yes" xml:space="preserve">
          <source>Note: This function is only available when using modern fake timers implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a20c17aceb39b181c11f8ff4c0ad0c423d32862" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;code&gt;maxConcurrency&lt;/code&gt; in configuration to prevents Jest from executing more than the specified amount of tests at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f87616f2342dfb53f7c81b06d94dec773c92c7" translate="yes" xml:space="preserve">
          <source>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</source>
          <target state="translated">注意:你必须将代码包裹在一个函数中,否则将不会捕捉到错误,断言也会失败。</target>
        </trans-unit>
        <trans-unit id="6eb20dc9b8a75cec38d02e8f54a09a224da2b36c" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="translated">注意：-- &lt;code&gt;--runInBand&lt;/code&gt; cli选项可确保Jest在同一进程中运行测试，而不是为各个测试生成进程。通常，Jest可并行化跨进程的测试运行，但是很难同时调试多个进程。</target>
        </trans-unit>
        <trans-unit id="96194ed3517159111cf9532affab238e70f5eef6" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs the test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4023ed8bfb6fa137e2322c83d2fb6a7bdccaa7cc" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. &lt;code&gt;(request, options)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a5108cffe44c788bf001c5788a68bdfb2e0028" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as options is the jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. (request, options).</source>
          <target state="translated">注意:作为选项传递的defaultResolver是jest默认的解析器,当你写你的自定义解析器时可能会有用。它的参数与您的自定义参数相同,例如(request,options)。</target>
        </trans-unit>
        <trans-unit id="08a800e5165f53b98f96928e40e168f030f156c8" translate="yes" xml:space="preserve">
          <source>Note: the function that throws an exception needs to be invoked within a wrapping function otherwise the &lt;code&gt;toThrow&lt;/code&gt; assertion will fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63519bb0bd54e1b894cccdf4f3af7852ef618bb7" translate="yes" xml:space="preserve">
          <source>Note: the nth argument must be positive integer starting from 1.</source>
          <target state="translated">注意:第n个参数必须是1开始的正整数。</target>
        </trans-unit>
        <trans-unit id="dc782aff0e671f43d928b262fb2a1ad60df35d44" translate="yes" xml:space="preserve">
          <source>Notice that Proxy is enabled in Node 6 by default. If you are not on Node 6 yet, make sure you invoke Jest using &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt;.</source>
          <target state="translated">请注意，默认情况下在节点6中启用了代理。如果尚未在节点6上，请确保使用 &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt; 调用Jest 。</target>
        </trans-unit>
        <trans-unit id="97d92ee85a42081babf70348e9395eeb01e66cc8" translate="yes" xml:space="preserve">
          <source>Now imagine an implementation of &lt;code&gt;request.js&lt;/code&gt; that goes to the network and fetches some user data:</source>
          <target state="translated">现在，想象一下一个 &lt;code&gt;request.js&lt;/code&gt; 实现，该实现进入网络并获取一些用户数据：</target>
        </trans-unit>
        <trans-unit id="bb60cb13af7d9fd41f600f4cb00d4bff107937d6" translate="yes" xml:space="preserve">
          <source>Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:</source>
          <target state="translated">现在让我们使用React的测试渲染器和Jest的快照功能与组件进行交互,并捕获渲染后的输出并创建一个快照文件。</target>
        </trans-unit>
        <trans-unit id="7ce0f103deaf5dc6dbc56bf66214617663420f57" translate="yes" xml:space="preserve">
          <source>Now let's write a test for our async functionality.</source>
          <target state="translated">现在让我们为我们的异步功能写一个测试。</target>
        </trans-unit>
        <trans-unit id="4759fbb62123d73c1226706f0f4d34666a8582b0" translate="yes" xml:space="preserve">
          <source>Now that Jest knows how to process our files, we need to tell it how to &lt;em&gt;find&lt;/em&gt; them. For webpack's &lt;code&gt;modulesDirectories&lt;/code&gt;, and &lt;code&gt;extensions&lt;/code&gt; options there are direct analogs in Jest's &lt;code&gt;moduleDirectories&lt;/code&gt; and &lt;code&gt;moduleFileExtensions&lt;/code&gt; options.</source>
          <target state="translated">既然Jest知道如何处理我们的文件，我们就需要告诉它如何&lt;em&gt;找到&lt;/em&gt;它们。对于webpack的 &lt;code&gt;modulesDirectories&lt;/code&gt; 和 &lt;code&gt;extensions&lt;/code&gt; 选项，Jest的 &lt;code&gt;moduleDirectories&lt;/code&gt; 和 &lt;code&gt;moduleFileExtensions&lt;/code&gt; 选项中有直接的类似物。</target>
        </trans-unit>
        <trans-unit id="e5a5de53298548d7d54ae3ca8e892f7df5aa2243" translate="yes" xml:space="preserve">
          <source>Now we write our test. Note that we need to explicitly tell that we want to mock the &lt;code&gt;fs&lt;/code&gt; module because it&amp;rsquo;s a core Node module:</source>
          <target state="translated">现在我们编写测试。请注意，由于它是核心Node模块，因此我们需要明确告知我们要模拟 &lt;code&gt;fs&lt;/code&gt; 模块：</target>
        </trans-unit>
        <trans-unit id="46a5c027241fe1614d4396220914efc2314503e5" translate="yes" xml:space="preserve">
          <source>Now, every time the snapshot test case runs, &lt;code&gt;Date.now()&lt;/code&gt; will return &lt;code&gt;1482363367071&lt;/code&gt; consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.</source>
          <target state="translated">现在，每次运行快照测试用例时， &lt;code&gt;Date.now()&lt;/code&gt; 将始终返回 &lt;code&gt;1482363367071&lt;/code&gt; 。无论何时运行测试，都将为此组件生成相同的快照。</target>
        </trans-unit>
        <trans-unit id="f5e6490929905f7bc8af5ccef9bf48f8668b1460" translate="yes" xml:space="preserve">
          <source>Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the &lt;code&gt;jest.mock(...)&lt;/code&gt; function to automatically mock the axios module.</source>
          <target state="translated">现在，为了在不实际访问API的情况下测试该方法（从而创建缓慢而脆弱的测试），我们可以使用 &lt;code&gt;jest.mock(...)&lt;/code&gt; 函数自动模拟axios模块。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="8d3eb6284bfb714ab8ca96c009bf8ad9c4fc7252" translate="yes" xml:space="preserve">
          <source>Object types are checked to be equal. e.g. A class instance with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will not equal a literal object with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">检查对象类型是否相等。例如，具有字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的类实例将不等于具有字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的文字对象。</target>
        </trans-unit>
        <trans-unit id="f2176a8ab6b1e30ac16f60c568568a437d540248" translate="yes" xml:space="preserve">
          <source>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</source>
          <target state="translated">通常,在你要快照的对象中,有一些字段会被生成(比如ID和Dates)。如果你尝试快照这些对象,它们会在每次运行时强制快照失败。</target>
        </trans-unit>
        <trans-unit id="6ffecdf0087875891dd611103daecc4d8bcf8763" translate="yes" xml:space="preserve">
          <source>Often this is useful when you want to clean up a mock's usage data between two assertions.</source>
          <target state="translated">当你想清理两个断言之间的mock的使用数据时,这通常是有用的。</target>
        </trans-unit>
        <trans-unit id="79cd3f6e68b0a9656087292d49bbeda556ae6d96" translate="yes" xml:space="preserve">
          <source>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.</source>
          <target state="translated">通常在编写测试时,你有一些设置工作需要在测试运行前进行,而你有一些整理工作需要在测试运行后进行。Jest提供了帮助函数来处理这些工作。</target>
        </trans-unit>
        <trans-unit id="4f3d546a97573ddf0fe581d729e6b000ed006545" translate="yes" xml:space="preserve">
          <source>Oftentimes, you'll want to set this to &lt;code&gt;'src'&lt;/code&gt; or &lt;code&gt;'lib'&lt;/code&gt;, corresponding to where in your repository the code is stored.</source>
          <target state="translated">通常，您需要将其设置为 &lt;code&gt;'src'&lt;/code&gt; 或 &lt;code&gt;'lib'&lt;/code&gt; ，与代码在存储库中的存储位置相对应。</target>
        </trans-unit>
        <trans-unit id="c12f3f3ee865af90cac56dabeb84091b38861136" translate="yes" xml:space="preserve">
          <source>On occasion there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="translated">有时候，自动生成的模拟模块系统通常无法满足您的测试需求。通常，在这种情况下，您应该编写一个更适合所讨论模块的&lt;a href=&quot;manual-mocks&quot;&gt;手动模拟&lt;/a&gt;程序。但是，在极少数情况下，即使是手动模拟也不适合您的目的，因此您需要在测试中自行构建模拟。</target>
        </trans-unit>
        <trans-unit id="ccd4436c2d3d88fb5477ef92425da0b5c05ebca6" translate="yes" xml:space="preserve">
          <source>On occasion, there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833be118eff717aa421c7c29043719c42065791" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want &lt;code&gt;axios.get('/users.json')&lt;/code&gt; to return a fake response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef0b229d34fbb64b6540632318f3fdbaa2280e6" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.</source>
          <target state="translated">一旦对模块进行了模拟，我们就可以为 &lt;code&gt;.get&lt;/code&gt; 提供一个 &lt;code&gt;mockResolvedValue&lt;/code&gt; ，以返回我们要对测试进行断言的数据。实际上，我们说的是我们希望axios.get（'/ users.json'）返回假响应。</target>
        </trans-unit>
        <trans-unit id="e0fd8cdd8b9b5a8885d7339d6a566088a20fe3d5" translate="yes" xml:space="preserve">
          <source>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</source>
          <target state="translated">进入交互式快照模式后,Jest将一次一次地对失败的快照进行逐步测试,并给您审查失败输出的机会。</target>
        </trans-unit>
        <trans-unit id="7ffee35fa0cdfd66f92f9f207350deb369bb338b" translate="yes" xml:space="preserve">
          <source>Once you're finished, Jest will give you a summary before returning back to watch mode:</source>
          <target state="translated">一旦你完成了,Jest会给你一个总结,然后再回到观看模式。</target>
        </trans-unit>
        <trans-unit id="04e3f29cab1cd3970d5e34742e1c9209c2a454b6" translate="yes" xml:space="preserve">
          <source>Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you &lt;a href=&quot;asynchronous&quot;&gt;test asynchronous code&lt;/a&gt;.</source>
          <target state="translated">了解了可用的匹配器之后，下一步就是检查Jest如何让您&lt;a href=&quot;asynchronous&quot;&gt;测试异步代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="911829cb001fba297a8440e3959d077dc4ad2675" translate="yes" xml:space="preserve">
          <source>One example when this is useful is when you want to mock a module differently within the same file:</source>
          <target state="translated">这很有用的一个例子是,当你想在同一个文件中以不同的方式模拟一个模块。</target>
        </trans-unit>
        <trans-unit id="44d433b060d5be5e5cb29585b03e7a39cbe16040" translate="yes" xml:space="preserve">
          <source>One of the files matching the &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob has less than 90% statement coverage.</source>
          <target state="translated">与 &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; 全局文件匹配的文件之一的语句覆盖率不到90％。</target>
        </trans-unit>
        <trans-unit id="33de0273fb385ef534431d972ca028ab9fae9e00" translate="yes" xml:space="preserve">
          <source>One or more subsequent rows of data supplied as template literal expressions using &lt;code&gt;${value}&lt;/code&gt; syntax.</source>
          <target state="translated">使用 &lt;code&gt;${value}&lt;/code&gt; 语法作为模板文字表达式提供的一或多个后续数据行。</target>
        </trans-unit>
        <trans-unit id="cfce43d345326fcdf5172027f076645beb3b6bbb" translate="yes" xml:space="preserve">
          <source>One such situation can arise if we intentionally change the address the Link component in our example is pointing to.</source>
          <target state="translated">如果我们故意改变例子中Link组件指向的地址,就会出现这样一种情况。</target>
        </trans-unit>
        <trans-unit id="8c3971f2be369ec67c710b4572f1ea126ad557a5" translate="yes" xml:space="preserve">
          <source>One-Time Setup</source>
          <target state="translated">一次性设置</target>
        </trans-unit>
        <trans-unit id="883b26a66c75d25a769cffa672f3388d833b2cc4" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run in that test file, since it is run with &lt;code&gt;test.only&lt;/code&gt;.</source>
          <target state="translated">由于该测试文件是通过 &lt;code&gt;test.only&lt;/code&gt; 运行的，因此只有&amp;ldquo;正在下雨&amp;rdquo;的测试将在该测试文件中运行。</target>
        </trans-unit>
        <trans-unit id="00991593a9f4d31e6c4dd6dbb447ea1e1f468c00" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run, since the other test is run with &lt;code&gt;test.skip&lt;/code&gt;.</source>
          <target state="translated">因为其他测试是使用 &lt;code&gt;test.skip&lt;/code&gt; 运行的，所以仅将运行&amp;ldquo;正在下雨&amp;rdquo;的测试。</target>
        </trans-unit>
        <trans-unit id="749db9a1ae125917392d1a5146e4c6d00c14a9d3" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide &lt;code&gt;steps&lt;/code&gt;, so it will run &lt;code&gt;steps&lt;/code&gt; amount of next timeouts/intervals.</source>
          <target state="translated">（可选）您可以提供 &lt;code&gt;steps&lt;/code&gt; ，因此它将运行下一次超时/间隔的 &lt;code&gt;steps&lt;/code&gt; 数量。</target>
        </trans-unit>
        <trans-unit id="920bdedd844899cd5664de8cfd74adb5d459a38e" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">（可选）您可以提供 &lt;code&gt;timeout&lt;/code&gt; （以毫秒为单位），以指定中止之前要等待的时间。&lt;em&gt;注意：默认超时为5秒。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4bf57bdba6d591e8cfd0266e8b8c0a594cbd7d55" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait for each row before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">（可选）您可以提供 &lt;code&gt;timeout&lt;/code&gt; （以毫秒为单位），以指定中止每行之前等待多长时间。&lt;em&gt;注意：默认超时为5秒。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="5c52bc127f7b5826340dcf7c16bf51e0c271179b" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">或&lt;a href=&quot;https://www.npmjs.com/&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d89d40959e0d933e8af9e53128924505cd140e00" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/package/jest&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371316f168eab595bc4ea7391514a4fa0fe1808f" translate="yes" xml:space="preserve">
          <source>Or if you'd like to create your own manual mock, you can do something like this:</source>
          <target state="translated">或者如果你想创建自己的手动模拟,你可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="5e431292d05ab6b8e395a562d7c86a6ac7fe933b" translate="yes" xml:space="preserve">
          <source>Or through JavaScript:</source>
          <target state="translated">或通过JavaScript。</target>
        </trans-unit>
        <trans-unit id="6885f402c4ee1de5eff12b5e007bf6c788da9b3e" translate="yes" xml:space="preserve">
          <source>Or through TypeScript (if &lt;code&gt;ts-node&lt;/code&gt; is installed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a0778a7a6879004009864ebf95b81c7e7732d5" translate="yes" xml:space="preserve">
          <source>Order of execution of describe and test blocks</source>
          <target state="translated">描述和测试块的执行顺序</target>
        </trans-unit>
        <trans-unit id="489864adf35b7b6f389f08017e013d2e99fa910a" translate="yes" xml:space="preserve">
          <source>Otherwise, please see our &lt;a href=&quot;getting-started#using-typescript&quot;&gt;Getting Started&lt;/a&gt; guide for to get setup with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a3dd308dd30f061fa22d50cb21bc2220dcf9c9" translate="yes" xml:space="preserve">
          <source>Our mocked class will need to provide any member functions (&lt;code&gt;playSoundFile&lt;/code&gt; in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.</source>
          <target state="translated">我们的模拟类将需要提供在测试期间将被调用的任何成员函数（在示例中为 &lt;code&gt;playSoundFile&lt;/code&gt; ），否则，调用不存在的函数会出错。但是我们可能还希望监视这些方法的调用，以确保使用预期的参数来调用它们。</target>
        </trans-unit>
        <trans-unit id="bfc5a5b4ca8f80ee77043098ef9ffc04d559ec8c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;debugger;&lt;/code&gt; statement in any of your tests, and then, in your project's directory, run:</source>
          <target state="translated">放置一个 &lt;code&gt;debugger;&lt;/code&gt; 您的任何测试中的语句，然后在项目的目录中运行：</target>
        </trans-unit>
        <trans-unit id="2d313b13f95b5bdfa47176161df9d9aac0aea191" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the resulting configuration must be JSON-serializable.</source>
          <target state="translated">请记住,最终的配置必须是可序列化的JSON。</target>
        </trans-unit>
        <trans-unit id="af206380956fb62af6fa59d92f109cd9641063d0" translate="yes" xml:space="preserve">
          <source>Please note that if you use arrow functions in your classes, they will &lt;em&gt;not&lt;/em&gt; be part of the mock. The reason for that is that arrow functions are not present on the object's prototype, they are merely properties holding a reference to a function.</source>
          <target state="translated">请注意，如果您在类中使用箭头函数，则它们&lt;em&gt;不会&lt;/em&gt;成为模拟的一部分。这样做的原因是，箭头函数不存在于对象的原型中，它们只是持有对该函数的引用的属性。</target>
        </trans-unit>
        <trans-unit id="a1e1312206132e72928ab543d2089ca56fc8c1f3" translate="yes" xml:space="preserve">
          <source>Please note that we currently don't support &lt;code&gt;jest.mock&lt;/code&gt; in a clean way in ESM, but that is something we intend to add proper support for in the future. Follow &lt;a href=&quot;https://github.com/facebook/jest/issues/10025&quot;&gt;this issue&lt;/a&gt; for updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c438f6772aa6520819506e7fbe99852dd87fd5" translate="yes" xml:space="preserve">
          <source>Plugins can be customized via your Jest configuration.</source>
          <target state="translated">插件可以通过你的Jest配置来定制。</target>
        </trans-unit>
        <trans-unit id="93e78b672f965eb7c8293baebd2be38d992a6655" translate="yes" xml:space="preserve">
          <source>Preset configuration</source>
          <target state="translated">预设配置</target>
        </trans-unit>
        <trans-unit id="bfb26311747a6131c77f1e75e89e1da90925579c" translate="yes" xml:space="preserve">
          <source>Presets may also be relative filesystem paths.</source>
          <target state="translated">预设也可以是相对的文件系统路径。</target>
        </trans-unit>
        <trans-unit id="86d670142d92672ef1ecead31bfb2615a86fbfe5" translate="yes" xml:space="preserve">
          <source>Presets may also be relative to filesystem paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33521f1e271c7d1369654933da9149112fe4281c" translate="yes" xml:space="preserve">
          <source>Prevent tests from printing messages through the console.</source>
          <target state="translated">防止测试通过控制台打印信息。</target>
        </trans-unit>
        <trans-unit id="0507f30be4f8c196c99ce7be2cba62397164f331" translate="yes" xml:space="preserve">
          <source>Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use &lt;code&gt;test.concurrent&lt;/code&gt;.</source>
          <target state="translated">防止Jest同时执行超过指定数量的测试。仅影响使用 &lt;code&gt;test.concurrent&lt;/code&gt; 的测试。</target>
        </trans-unit>
        <trans-unit id="7719ba43ff57b175fbd95f647e624ca1e3e38f9d" translate="yes" xml:space="preserve">
          <source>Print debugging info about your Jest config.</source>
          <target state="translated">打印Jest配置的调试信息。</target>
        </trans-unit>
        <trans-unit id="169d23ffa6beb8bf0a8b932fddc3a716b615997f" translate="yes" xml:space="preserve">
          <source>Print your Jest config and then exits.</source>
          <target state="translated">打印你的Jest配置,然后退出。</target>
        </trans-unit>
        <trans-unit id="a45ae5d1d90ee0d31bb43f56d9dee1beb6b5a14a" translate="yes" xml:space="preserve">
          <source>Prints the test results in JSON. This mode will send all other test output and user messages to stderr.</source>
          <target state="translated">打印JSON格式的测试结果。该模式将把所有其他测试输出和用户信息发送到stderr。</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="d3f60bcc6f5c4f59593f0501aca5c6e1a0e647d3" translate="yes" xml:space="preserve">
          <source>Property Matchers</source>
          <target state="translated">属性匹配器</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b305ac456a0fe1de47f68c0f2dcb4be5edf55137" translate="yes" xml:space="preserve">
          <source>React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:</source>
          <target state="translated">React 16会因为检查元素类型的方式而触发这些警告,而被模拟的模块也无法通过这些检查。你的选择是</target>
        </trans-unit>
        <trans-unit id="695d1116170755340f94ec3beb1f24f668859e58" translate="yes" xml:space="preserve">
          <source>Recommended config names:</source>
          <target state="translated">推荐配置名。</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="84641ce3545468aef6d9992e246ecc28023bd7fa" translate="yes" xml:space="preserve">
          <source>Removes any pending timers from the timer system.</source>
          <target state="translated">从定时器系统中删除任何待定的定时器。</target>
        </trans-unit>
        <trans-unit id="571be88936b979291213a8fc1300d3eb34583940" translate="yes" xml:space="preserve">
          <source>Render as a custom element. DOM &quot;custom elements&quot; aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.</source>
          <target state="translated">渲染为自定义元素。DOM &quot;自定义元素 &quot;没有被检查任何东西,不应该发出警告。它们是小写的,而且名字里有一个破折号。</target>
        </trans-unit>
        <trans-unit id="456b6bb3ce6f2e6632c5f1e8d9ca1d06e7f178b9" translate="yes" xml:space="preserve">
          <source>Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:</source>
          <target state="translated">渲染为文本。这样你在快照中就看不到传递给mock组件的道具了,但这很直接。</target>
        </trans-unit>
        <trans-unit id="1e70132872e75d10f3ccbb11c8b73d9f202669fd" translate="yes" xml:space="preserve">
          <source>Rendered snapshot:</source>
          <target state="translated">渲染的快照。</target>
        </trans-unit>
        <trans-unit id="3cd1c22168650ecd82a31a115bed21a42399c269" translate="yes" xml:space="preserve">
          <source>Repeating Setup For Many Tests</source>
          <target state="translated">多次测试的重复设置</target>
        </trans-unit>
        <trans-unit id="5add9c1dfb47ec8100a0659f89d63ed952ac6c86" translate="yes" xml:space="preserve">
          <source>Replacing the mock using &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt;&lt;code&gt;mockImplementation()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt;&lt;code&gt;mockImplementationOnce()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt; &lt;code&gt;mockImplementation()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt; &lt;code&gt;mockImplementationOnce()&lt;/code&gt; &lt;/a&gt;替换模拟</target>
        </trans-unit>
        <trans-unit id="19baff0fd9598875b3df0c02954246d178653887" translate="yes" xml:space="preserve">
          <source>Resets all information stored in the &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt; arrays.</source>
          <target state="translated">重置存储在&lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt;数组中的所有信息。</target>
        </trans-unit>
        <trans-unit id="9c4baf164f97d04496389992c7c5da13fbb245ae" translate="yes" xml:space="preserve">
          <source>Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.</source>
          <target state="translated">重置模块注册表--所有所需模块的缓存。这对于隔离测试之间可能发生冲突的本地状态的模块很有用。</target>
        </trans-unit>
        <trans-unit id="4ee7cc0bddf7c5a4ef8549ea7c38c8d601b2255d" translate="yes" xml:space="preserve">
          <source>Resets the state of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt;&lt;code&gt;.mockReset()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">重置所有模拟的状态。等效于在每个&lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt; &lt;code&gt;.mockReset()&lt;/code&gt; &lt;/a&gt;函数上调用.mockReset（）。</target>
        </trans-unit>
        <trans-unit id="46554c07d0e0360541685d38d9047e14f0a0601e" translate="yes" xml:space="preserve">
          <source>Respect Browserify's &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt; in &lt;code&gt;package.json&lt;/code&gt; when resolving modules. Some modules export different versions based on whether they are operating in Node or a browser.</source>
          <target state="translated">尊重Browserify的&lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt; &lt;code&gt;&quot;browser&quot;&lt;/code&gt; 领域&lt;/a&gt;中 &lt;code&gt;package.json&lt;/code&gt; 解析模块时。某些模块根据它们是在Node还是在浏览器中运行而导出不同的版本。</target>
        </trans-unit>
        <trans-unit id="27aceef5796ab8d68aed06c602f37330d5a900d4" translate="yes" xml:space="preserve">
          <source>Restores all mocks back to their original value. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt;&lt;code&gt;.mockRestore()&lt;/code&gt;&lt;/a&gt; on every mocked function. Beware that &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;; other mocks will require you to manually restore them.</source>
          <target state="translated">将所有模拟恢复为原始值。等效于在每个&lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt; &lt;code&gt;.mockRestore()&lt;/code&gt; &lt;/a&gt;函数上调用.mockRestore（）。当心 &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; 仅在使用 &lt;code&gt;jest.spyOn&lt;/code&gt; 创建模拟时才有效；其他模拟将要求您手动还原它们。</target>
        </trans-unit>
        <trans-unit id="8ddb9b055cad613e29453fa554de9f36c7d6c8dd" translate="yes" xml:space="preserve">
          <source>Retry with &lt;a href=&quot;cli#--cache&quot;&gt;&lt;code&gt;--no-cache&lt;/code&gt;&lt;/a&gt;. Jest caches transformed module files to speed up test execution. If you are using your own custom transformer, consider adding a &lt;code&gt;getCacheKey&lt;/code&gt; function to it: &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;cli#--cache&quot;&gt; &lt;code&gt;--no-cache&lt;/code&gt; &lt;/a&gt;重试。Jest缓存转换后的模块文件以加快测试执行速度。如果使用自己的自定义转换器，请考虑向其添加 &lt;code&gt;getCacheKey&lt;/code&gt; 函数：&lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;Relay中的getCacheKey&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="156ec26504d2692465a0d8ff00489f7b36d9fa41" translate="yes" xml:space="preserve">
          <source>Returns a boolean (or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for handling asynchronous operations) to specify if a test should be run or not.</source>
          <target state="translated">返回一个布尔值（或 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; 用于处理异步操作），以指定是否应该运行测试。</target>
        </trans-unit>
        <trans-unit id="5d66ba4a66cb6cf526e2e08e5bcc4265e970107d" translate="yes" xml:space="preserve">
          <source>Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.</source>
          <target state="translated">返回一个模拟模块,而不是实际模块,绕过所有关于模块是否需要的检查。</target>
        </trans-unit>
        <trans-unit id="9da978b2f0e20c11e4aa75b10631e43a25e02ab4" translate="yes" xml:space="preserve">
          <source>Returns a new, unused &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;. Optionally takes a mock implementation.</source>
          <target state="translated">返回一个新的未使用的&lt;a href=&quot;mock-function-api&quot;&gt;模拟函数&lt;/a&gt;。（可选）采用模拟实现。</target>
        </trans-unit>
        <trans-unit id="a1acf18173b267510a46851d55a523216adab36c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;jest&lt;/code&gt; object for chaining.</source>
          <target state="translated">返回用于链接的 &lt;code&gt;jest&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d08519e49635fb031179ab7f05284949daef9383" translate="yes" xml:space="preserve">
          <source>Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.</source>
          <target state="translated">返回实际的模块而不是mock,绕过所有关于模块是否应该收到mock实现的检查。</target>
        </trans-unit>
        <trans-unit id="2add96bbc9e9900cf433a5f2ebe6d67cb4660cf1" translate="yes" xml:space="preserve">
          <source>Returns the mock name string set by calling &lt;code&gt;mockFn.mockName(value)&lt;/code&gt;.</source>
          <target state="translated">返回通过调用 &lt;code&gt;mockFn.mockName(value)&lt;/code&gt; 设置的模拟名称字符串。</target>
        </trans-unit>
        <trans-unit id="dd9336539157509732381e95d2e9b2f4ceef9877" translate="yes" xml:space="preserve">
          <source>Returns the number of fake timers still left to run.</source>
          <target state="translated">返回仍在运行的假定时器的数量。</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="641d1b198a65bb1bd4728078175e361d73f060b6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;yarn test&lt;/code&gt; to run tests with Jest.</source>
          <target state="translated">运行 &lt;code&gt;yarn test&lt;/code&gt; 以使用Jest运行测试。</target>
        </trans-unit>
        <trans-unit id="7306d688c7598b3d294777df07da99e3d93d653c" translate="yes" xml:space="preserve">
          <source>Run All Timers</source>
          <target state="translated">运行所有定时器</target>
        </trans-unit>
        <trans-unit id="30ad8b68bab570303d35cefd0d73cf6056dbfc2d" translate="yes" xml:space="preserve">
          <source>Run Pending Timers</source>
          <target state="translated">运行等待的计时器</target>
        </trans-unit>
        <trans-unit id="c89b3947b20f77096b75ca74d8fccf7526f1872b" translate="yes" xml:space="preserve">
          <source>Run all tests (default):</source>
          <target state="translated">运行所有测试(默认)。</target>
        </trans-unit>
        <trans-unit id="02b363bdd7980fccab5552af0568d148195655d4" translate="yes" xml:space="preserve">
          <source>Run all tests affected by file changes in the last commit made. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">运行所有在上一次提交中受文件更改影响的测试。行为类似于 &lt;code&gt;--onlyChanged&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52304e948d18e9a280f733e321f8b5e058bbed9d" translate="yes" xml:space="preserve">
          <source>Run only the tests of the specified projects. Jest uses the attribute &lt;code&gt;displayName&lt;/code&gt; in the configuration to identify each project. If you use this option, you should provide a &lt;code&gt;displayName&lt;/code&gt; to all your projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcaa420e9fe3c70be68c6d8ee7d82ab5720e907" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with a pattern or filename:</source>
          <target state="translated">只运行用模式或文件名指定的测试。</target>
        </trans-unit>
        <trans-unit id="92d791c05598e8218af4368bc378173046cea720" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with their exact paths.</source>
          <target state="translated">只运行指定了准确路径的测试。</target>
        </trans-unit>
        <trans-unit id="23686a3a58e4a1259f35510a9d0252c4f6745f24" translate="yes" xml:space="preserve">
          <source>Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt;&lt;code&gt;projects&lt;/code&gt;&lt;/a&gt; configuration option. Note that if configuration files are found in the specified paths, &lt;em&gt;all&lt;/em&gt; projects specified within those configuration files will be run.</source>
          <target state="translated">从指定路径中的一个或多个项目运行测试；也有路径问题。此选项与&lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt; &lt;code&gt;projects&lt;/code&gt; &lt;/a&gt;配置选项的CLI等效。请注意，如果在指定路径中找到配置文件，则将运行那些配置文件中指定的&lt;em&gt;所有&lt;/em&gt;项目。</target>
        </trans-unit>
        <trans-unit id="f9ddd0d105f6204c8e90c3adf874ea7bc2b26987" translate="yes" xml:space="preserve">
          <source>Run tests related to &lt;code&gt;path/to/fileA.js&lt;/code&gt; and &lt;code&gt;path/to/fileB.js&lt;/code&gt;:</source>
          <target state="translated">运行与 &lt;code&gt;path/to/fileA.js&lt;/code&gt; 和 &lt;code&gt;path/to/fileB.js&lt;/code&gt; 相关的测试：</target>
        </trans-unit>
        <trans-unit id="2de5d0d69fc805a58b350e937e2690429d2970e2" translate="yes" xml:space="preserve">
          <source>Run tests related to changed files based on hg/git (uncommitted files):</source>
          <target state="translated">基于hg/git(未提交的文件)运行与更改文件相关的测试。</target>
        </trans-unit>
        <trans-unit id="a44ae954d1ab8ef98e8adfe8b4785726ef8e4670" translate="yes" xml:space="preserve">
          <source>Run tests that match this spec name (match against the name in &lt;code&gt;describe&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;, basically).</source>
          <target state="translated">运行与此规范名称匹配的 &lt;code&gt;test&lt;/code&gt; （基本上与 &lt;code&gt;describe&lt;/code&gt; 或test中的名称匹配）。</target>
        </trans-unit>
        <trans-unit id="3250ade6678b3bc2a1ae0933ebec438d66c4c65a" translate="yes" xml:space="preserve">
          <source>Run tests with specified reporters. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Reporter options&lt;/a&gt; are not available via CLI. Example with multiple reporters:</source>
          <target state="translated">使用指定的报告程序运行测试。&lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;记者选项&lt;/a&gt;无法通过CLI使用。多个报告者的示例：</target>
        </trans-unit>
        <trans-unit id="1e9d71147bb217981f158928624c5b13a6be2ead" translate="yes" xml:space="preserve">
          <source>Run watch mode:</source>
          <target state="translated">运行手表模式。</target>
        </trans-unit>
        <trans-unit id="6317e775f03f11757290b5bce78a11c48721ccd6" translate="yes" xml:space="preserve">
          <source>Running from command line</source>
          <target state="translated">从命令行运行</target>
        </trans-unit>
        <trans-unit id="3d642ff91fd7ebdca37f4b2895153e438af4b378" translate="yes" xml:space="preserve">
          <source>Running from the command line</source>
          <target state="translated">从命令行运行</target>
        </trans-unit>
        <trans-unit id="437a88c377620b15b1bd26b6489ffe7cf9e58772" translate="yes" xml:space="preserve">
          <source>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">在这个文件中的所有测试完成后运行一个函数。如果函数返回一个承诺或者是一个生成器,Jest会等待该承诺解析后再继续。</target>
        </trans-unit>
        <trans-unit id="50450676d930383c48d2ec3efefa163347c39da6" translate="yes" xml:space="preserve">
          <source>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">在这个文件中的每个测试完成后运行一个函数。如果函数返回一个承诺或者是一个生成器,Jest会等待该承诺解析后再继续。</target>
        </trans-unit>
        <trans-unit id="44b753442cff11f6ed337230a6a654b466728c0d" translate="yes" xml:space="preserve">
          <source>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</source>
          <target state="translated">在这个文件中的任何测试运行之前运行一个函数。如果函数返回一个承诺或者是一个生成器,Jest 会等待该承诺解析后再运行测试。</target>
        </trans-unit>
        <trans-unit id="57284652d7931aab5ea782fa00d26cf2b4c59502" translate="yes" xml:space="preserve">
          <source>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</source>
          <target state="translated">在这个文件中的每个测试运行之前运行一个函数。如果函数返回一个承诺或者是一个生成器,Jest会等待该承诺解析后再运行测试。</target>
        </trans-unit>
        <trans-unit id="8886a35ac5b619bcc55c828058cdaa29e97376a1" translate="yes" xml:space="preserve">
          <source>Runs failed tests n-times until they pass or until the max number of retries is exhausted. This only works with &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt;!</source>
          <target state="translated">n次运行失败的测试，直到它们通过或直到最大重试次数用完为止。这仅适用于&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;开玩笑的马戏团&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="b2614c8f6a2b7cb20f551e055799e18e1ea7d981" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2884236a5a7d1409f769ed84cceee98770e2aba" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">运行与自提供分支以来所做的更改相关的测试。如果当前分支与给定分支有所不同，则将仅测试本地所做的更改。行为类似于 &lt;code&gt;--onlyChanged&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdee9094809cabf1a25af1ca3211f475ddc04a54" translate="yes" xml:space="preserve">
          <source>Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">运行与当前更改和上一次提交中所做的更改相关的测试。行为类似于 &lt;code&gt;--onlyChanged&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea13653cdec671f745362f34fcd64c3406b64c75" translate="yes" xml:space="preserve">
          <source>Scoped modules can be mocked by creating a file in a directory structure that matches the name of the scoped module. For example, to mock a scoped module called &lt;code&gt;@scope/project-name&lt;/code&gt;, create a file at &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt;, creating the &lt;code&gt;@scope/&lt;/code&gt; directory accordingly.</source>
          <target state="translated">可以通过在目录结构中创建一个与作用域模块名称匹配的文件来模拟作用域模块。例如，要模拟一个称为 &lt;code&gt;@scope/project-name&lt;/code&gt; 的作用域模块，请在 &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt; 上创建一个文件，并相应地创建 &lt;code&gt;@scope/&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="cbc636498e1c269635cd060804fe4bc4c5cc9f77" translate="yes" xml:space="preserve">
          <source>Scoping</source>
          <target state="translated">Scoping</target>
        </trans-unit>
        <trans-unit id="211a5b2321ab26457503f06cb4dc7556791fc7d0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;configuring Jest&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;配置Jest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efddd22422ff36c5396f782f1486c33090e561a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</source>
          <target state="translated">请参阅&lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;创建表API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f34a9c66618a8a38e77218fa386d8ca82390118e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0f8c5b32a609f4f0cc5792e1d82420240d67f10" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;documentation&lt;/a&gt; for details (configuring MongoDB version, etc).</source>
          <target state="translated">有关详细信息，请参阅&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;文档&lt;/a&gt;（配置MongoDB版本等）。</target>
        </trans-unit>
        <trans-unit id="85e1678b6936236b6f910c2ee40e764fd5fd5efb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac033bc12bf7544e09b943fc85a55ee0e0eb5bb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Help&lt;/a&gt;.</source>
          <target state="translated">请参阅&amp;ldquo; &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;帮助&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bd8f6623cb0bd7f5cbd56dab7f5f02bfe1b459a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;automock&lt;/code&gt; section of &lt;a href=&quot;configuration#automock-boolean&quot;&gt;configuration&lt;/a&gt; for more information</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;configuration#automock-boolean&quot;&gt;配置的自动&lt;/a&gt; &lt;code&gt;automock&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="b6f206289cb851ace292e1546d209054802eb0c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#testregex-string--arraystring&quot;&gt;&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">另请参见&lt;a href=&quot;#testregex-string--arraystring&quot;&gt; &lt;code&gt;testRegex&lt;/code&gt; [string | array &amp;lt;string&amp;gt;]&lt;/a&gt;，但是请注意，您不能同时指定两个选项。</target>
        </trans-unit>
        <trans-unit id="94efbf6a114ebb2635afd14dc7211a7f961c8a16" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; package for details of the patterns you can specify.</source>
          <target state="translated">有关可以指定的模式的详细信息，请参见&lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;微匹配&lt;/a&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="532a50a063dc36d0a8534a18dcaf4a0125d0cb62" translate="yes" xml:space="preserve">
          <source>Set the current system time used by fake timers. Simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.g. timers to fire; they will fire exactly as they would have done without the call to &lt;code&gt;jest.setSystemTime()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ea98380b0e9ec8f2989a621cea9a7e764e463" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds.</source>
          <target state="translated">设置测试和before/after hooks的默认超时间隔,单位为毫秒。</target>
        </trans-unit>
        <trans-unit id="7ef9a41019d98dcd7087734f625109563be77315" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds. This only affects the test file from which this function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acda40898a579d06db8797d3cdaca2b2ddebd7e" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;'test'&lt;/code&gt; if it's not already set to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c094b57443ef1dac1663cfc0d2869275b9ac2e1" translate="yes" xml:space="preserve">
          <source>Sets the path to the &lt;a href=&quot;https://prettier.io/&quot;&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/a&gt; node module used to update inline snapshots.</source>
          <target state="translated">设置用于更新嵌入式快照的&lt;a href=&quot;https://prettier.io/&quot;&gt; &lt;code&gt;prettier&lt;/code&gt; &lt;/a&gt;节点模块的路径。</target>
        </trans-unit>
        <trans-unit id="03632ef1c76d8a3790f3ba38329aa3105012b7ef" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="translated">将此值设置为 &lt;code&gt;fake&lt;/code&gt; 允许对诸如 &lt;code&gt;setTimeout&lt;/code&gt; 之类的功能使用false计时器。当一段代码设置了我们不想在测试中等待的长时间超时时，伪计时器非常有用。</target>
        </trans-unit>
        <trans-unit id="ef5d59a2f86331bc4671ba4a54ae325b17ae045f" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;legacy&lt;/code&gt; or &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="5f07ec3fe4ba8082e43fef02f2b4d5d1a2a1d466" translate="yes" xml:space="preserve">
          <source>Setup and Teardown</source>
          <target state="translated">设置和拆卸</target>
        </trans-unit>
        <trans-unit id="24b1a600607b12b94694aa1cdc63d96c8b7a540d" translate="yes" xml:space="preserve">
          <source>Setup with Create React App</source>
          <target state="translated">使用创建React应用程序进行设置</target>
        </trans-unit>
        <trans-unit id="9e9d9e60fd56a1f1ea8ea643530acaeb4d062997" translate="yes" xml:space="preserve">
          <source>Setup without Create React App</source>
          <target state="translated">在不创建React应用的情况下进行设置</target>
        </trans-unit>
        <trans-unit id="822b3a2435ec58cb5bc9376be9ad2eeac55edc92" translate="yes" xml:space="preserve">
          <source>Should snapshot files be committed?</source>
          <target state="translated">快照文件是否应该提交?</target>
        </trans-unit>
        <trans-unit id="492eafbaea4c259f43100935024f5e3a182f7170" translate="yes" xml:space="preserve">
          <source>Should your plugin attempt to overwrite a reserved key, Jest will error out with a descriptive message, something like:</source>
          <target state="translated">如果你的插件试图覆盖一个保留的密钥,Jest会用一个描述性的信息出错,比如说。</target>
        </trans-unit>
        <trans-unit id="bd51fd0dd8cd830d4a42fc531c55cdfccd2ac812" translate="yes" xml:space="preserve">
          <source>Show the help information, similar to this page.</source>
          <target state="translated">显示帮助信息,类似于这个页面。</target>
        </trans-unit>
        <trans-unit id="fb22048fa6d1f11cbc46a0377600ca142853ad0a" translate="yes" xml:space="preserve">
          <source>Similarly webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="translated">同样的WebPack的 &lt;code&gt;resolve.root&lt;/code&gt; 选项的功能，如设置 &lt;code&gt;NODE_PATH&lt;/code&gt; 环境变量，您可以设置，或使用的 &lt;code&gt;modulePaths&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="7adebe990936d6de8e229a12d896004b38f87428" translate="yes" xml:space="preserve">
          <source>Similarly, webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b6800d4211e291c95387e4b2e79446e622a4f0" translate="yes" xml:space="preserve">
          <source>Since Jest 22.1.0+, the &lt;code&gt;jest.spyOn&lt;/code&gt; method takes an optional third argument of &lt;code&gt;accessType&lt;/code&gt; that can be either &lt;code&gt;'get'&lt;/code&gt; or &lt;code&gt;'set'&lt;/code&gt;, which proves to be useful when you want to spy on a getter or a setter, respectively.</source>
          <target state="translated">从Jest 22.1.0+开始， &lt;code&gt;jest.spyOn&lt;/code&gt; 方法采用 &lt;code&gt;accessType&lt;/code&gt; 的可选第三个参数，该参数可以是 &lt;code&gt;'get'&lt;/code&gt; 或 &lt;code&gt;'set'&lt;/code&gt; ，当您分别监视getter或setter时，这被证明是有用的。</target>
        </trans-unit>
        <trans-unit id="4f8bae34a73e1f4213cb283f5a11b822ba4dc217" translate="yes" xml:space="preserve">
          <source>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</source>
          <target state="translated">因为后面描述的正是输出的预期,所以什么时候出错就更清楚了。</target>
        </trans-unit>
        <trans-unit id="b9678530810438e60dd8aa3f6aa12c28ea2f3f1c" translate="yes" xml:space="preserve">
          <source>Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.</source>
          <target state="translated">由于我们刚刚更新了我们的组件,使其指向一个不同的地址,因此我们有理由期待这个组件的快照发生变化。我们的快照测试用例失败了,因为我们更新组件的快照不再与这个测试用例的快照工件相匹配。</target>
        </trans-unit>
        <trans-unit id="540cf57482add7abae948ebe3f5722e703011e20" translate="yes" xml:space="preserve">
          <source>Since we'd like our tests to avoid actually hitting the disk (that's pretty slow and fragile), we create a manual mock for the &lt;code&gt;fs&lt;/code&gt; module by extending an automatic mock. Our manual mock will implement custom versions of the &lt;code&gt;fs&lt;/code&gt; APIs that we can build on for our tests:</source>
          <target state="translated">由于我们希望测试避免实际击中磁盘（这非常缓慢且脆弱），因此我们通过扩展自动模拟为 &lt;code&gt;fs&lt;/code&gt; 模块创建手动模拟。我们的手动模拟将实现可用于测试的 &lt;code&gt;fs&lt;/code&gt; API的自定义版本：</target>
        </trans-unit>
        <trans-unit id="66842e9da141137fe7352a0a53d93d8d95043a5c" translate="yes" xml:space="preserve">
          <source>Snapshot Test</source>
          <target state="translated">快照测试</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">快照测试</target>
        </trans-unit>
        <trans-unit id="89df76fc07cdab1a593d1520d1e485a89eaa0758" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Jest</source>
          <target state="translated">使用Jest进行快照测试</target>
        </trans-unit>
        <trans-unit id="133546ab2de371a152f49c68a57605cf66823f74" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Mocks, Enzyme and React 16</source>
          <target state="translated">使用Mocks、Enzyme和React 16进行快照测试。</target>
        </trans-unit>
        <trans-unit id="5a16d1671f06c1b79f4ca90da446bf86ec30018f" translate="yes" xml:space="preserve">
          <source>Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</source>
          <target state="translated">快照文件必须始终代表它们所覆盖的模块的当前状态。因此,如果你在合并两个分支时,遇到快照文件的冲突,你可以手动解决冲突,或者通过运行Jest并检查结果来更新快照文件。</target>
        </trans-unit>
        <trans-unit id="e2f67f68de52f1c63bdae4635f588faaa8a269e7" translate="yes" xml:space="preserve">
          <source>Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest blog&lt;/a&gt;.</source>
          <target state="translated">快照测试和视觉回归测试是测试UI的两种不同方法，它们具有不同的用途。视觉回归测试工具获取网页的屏幕截图，并逐像素比较生成的图像。使用Snapshot，测试值可以序列化，存储在文本文件中，并使用diff算法进行比较。有很多折衷考虑，我们在&lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest博客中&lt;/a&gt;列出了构建快照测试的原因。</target>
        </trans-unit>
        <trans-unit id="67c5ace60d5fc8adf8135b3fa0469ad4f55990c3" translate="yes" xml:space="preserve">
          <source>Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.</source>
          <target state="translated">快照测试只是Jest附带的20多个断言中的一个。快照测试的目的不是为了取代现有的单元测试,而是为了提供额外的价值,使测试无痛。在某些场景下,快照测试有可能消除对特定功能集(如React组件)单元测试的需求,但它们也可以一起工作。</target>
        </trans-unit>
        <trans-unit id="d78cced32db30f3bf1c92f37bcc6a46c7cbbb0b3" translate="yes" xml:space="preserve">
          <source>Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.</source>
          <target state="translated">每当你想确保你的UI不会发生意外变化时,快照测试是一个非常有用的工具。</target>
        </trans-unit>
        <trans-unit id="46a65a578f3ba45c38c2f4b67393d191767bfc07" translate="yes" xml:space="preserve">
          <source>Snapshots are a fantastic tool for identifying unexpected interface changes within your application &amp;ndash; whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</source>
          <target state="translated">快照是一种出色的工具，可用于识别应用程序中意外的界面更改-无论该界面是API响应，UI，日志还是错误消息。与任何测试策略一样，为了有效地使用它们，您应该了解一些最佳实践和准则。</target>
        </trans-unit>
        <trans-unit id="c478e2f51e8e2add8d79e6f37e7ed46eb64562f2" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to allow transpiling such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f682ce988a8d01605c894c6eb3963ca0cc76e8b" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to whitelist such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="translated">有时会发生（尤其是在React Native或TypeScript项目中）第三方模块发布为未编译的情况。由于默认情况下不会转换 &lt;code&gt;node_modules&lt;/code&gt; 内部的所有文件，因此Jest将无法理解这些模块中的代码，从而导致语法错误。为了克服这个问题，您可以使用 &lt;code&gt;transformIgnorePatterns&lt;/code&gt; 将此类模块列入白名单。您可以在&lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide中&lt;/a&gt;找到一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="e2b30ccb8fda73d533a0e969bafd118c24c88742" translate="yes" xml:space="preserve">
          <source>Sometimes you need to provide a more complex manual mock. For example if you'd like to forward the prop types or static fields of a native component to a mock, you can return a different React component from a mock through this helper from jest-react-native:</source>
          <target state="translated">有时你需要提供一个更复杂的手动mock。例如,如果你想将原生组件的道具类型或静态字段转发给mock,你可以通过jest-react-native的这个帮助程序从mock中返回不同的React组件。</target>
        </trans-unit>
        <trans-unit id="695c0e7e9d729e27f87cadca0070a18d74fc0abb" translate="yes" xml:space="preserve">
          <source>Sort test path alphabetically.</source>
          <target state="translated">按字母顺序排列测试路径。</target>
        </trans-unit>
        <trans-unit id="e68b54695ab9a614c999727da57981ffa8733914" translate="yes" xml:space="preserve">
          <source>Specifies notification mode. Requires &lt;code&gt;notify: true&lt;/code&gt;.</source>
          <target state="translated">指定通知方式。需要 &lt;code&gt;notify: true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3484b5172e046d75121af3f84a8f20757a6f1353" translate="yes" xml:space="preserve">
          <source>Specify preset in your Jest configuration:</source>
          <target state="translated">在Jest配置中指定预设。</target>
        </trans-unit>
        <trans-unit id="072147ce4032ecb883aadc972685fb5dc5cab93b" translate="yes" xml:space="preserve">
          <source>Spying on methods of our class</source>
          <target state="translated">监视我们类的方法</target>
        </trans-unit>
        <trans-unit id="3e66bbc94f94d5c9febbf71967e8a53cc9c379f0" translate="yes" xml:space="preserve">
          <source>Spying on the constructor</source>
          <target state="translated">监视构造者</target>
        </trans-unit>
        <trans-unit id="024a38d0b03fcbf63acc93daff4e631c67675d3b" translate="yes" xml:space="preserve">
          <source>Starting from react-native version 0.38, a Jest setup is included by default when running &lt;code&gt;react-native init&lt;/code&gt;. The following configuration should be automatically added to your package.json file:</source>
          <target state="translated">从react-native版本0.38开始，运行 &lt;code&gt;react-native init&lt;/code&gt; 时默认包括Jest设置。以下配置应自动添加到您的package.json文件中：</target>
        </trans-unit>
        <trans-unit id="1991c5175326e4c289d97fffe85eadf0791dd3bd" translate="yes" xml:space="preserve">
          <source>Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="translated">静态ES6模块导入被提升到文件的顶部，因此我们必须使用 &lt;code&gt;import()&lt;/code&gt; 动态导入它们。</target>
        </trans-unit>
        <trans-unit id="28f738d61989d25363252d6dd69c2b75719b7de9" translate="yes" xml:space="preserve">
          <source>Still unresolved?</source>
          <target state="translated">还是没有解决?</target>
        </trans-unit>
        <trans-unit id="6c6f5518d1fa80f650e491adb2e489a09a7f982c" translate="yes" xml:space="preserve">
          <source>Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with &lt;code&gt;jest.fn&lt;/code&gt; or the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method on mock functions.</source>
          <target state="translated">不过，在某些情况下，超越指定返回值的功能并完全替换模拟功能的实现是有用的。这可以通过对模拟函数使用 &lt;code&gt;jest.fn&lt;/code&gt; 或 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 方法来完成。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="bcc358b3aaafb093f4a2baf42f0160bfb2bfd061" translate="yes" xml:space="preserve">
          <source>Suppose we have a class that fetches users from our API. The class uses &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; to call the API then returns the &lt;code&gt;data&lt;/code&gt; attribute which contains all the users:</source>
          <target state="translated">假设我们有一个从API获取用户的类。该类使用&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt;调用API，然后返回包含所有用户的 &lt;code&gt;data&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="3a4bc60f3a09d9eb5a73886f79212b0e558b15ec" translate="yes" xml:space="preserve">
          <source>Syntactic sugar function for:</source>
          <target state="translated">合成糖功能为:</target>
        </trans-unit>
        <trans-unit id="ae135cb4bf99d2d69cbac3f5fd417c5399be204b" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example you can override options given to &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="translated">测试环境选项，这些选项将传递给 &lt;code&gt;testEnvironment&lt;/code&gt; 。相关选项取决于环境。例如，您可以覆盖为&lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom提供的&lt;/a&gt;选项，例如 &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c29c26bd3478b20af1cf0e7c6178529d8355ed9c" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example, you can override options given to &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55666a28ff3618a6bc88a5a3086460692f20399" translate="yes" xml:space="preserve">
          <source>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</source>
          <target state="translated">测试文件通常在收集代码覆盖时被忽略。有了这个选项,你可以覆盖这个行为,并将其他忽略的文件包含在代码覆盖范围内。</target>
        </trans-unit>
        <trans-unit id="32a2b6bfc1cb248afcfe7c96a42e9a946326cac4" translate="yes" xml:space="preserve">
          <source>Test files run inside a &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;, which slows calls to global context properties (e.g. &lt;code&gt;Math&lt;/code&gt;). With this option you can specify extra properties to be defined inside the vm for faster lookups.</source>
          <target state="translated">测试文件在&lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;内部运行，这会减慢对全局上下文属性（例如 &lt;code&gt;Math&lt;/code&gt; ）的调用。使用此选项，您可以指定要在vm中定义的其他属性，以加快查找速度。</target>
        </trans-unit>
        <trans-unit id="da102bd566881f332f6aa321d898e870666704cb" translate="yes" xml:space="preserve">
          <source>Testing Asynchronous Code</source>
          <target state="translated">测试异步代码</target>
        </trans-unit>
        <trans-unit id="b4b91ec445494c8e5c6d2ecedd86aa56ac5179b5" translate="yes" xml:space="preserve">
          <source>Testing React Apps</source>
          <target state="translated">测试React应用</target>
        </trans-unit>
        <trans-unit id="5987105ad86879109c74631bcc686434d71992ae" translate="yes" xml:space="preserve">
          <source>Testing React Native Apps</source>
          <target state="translated">测试React Native应用</target>
        </trans-unit>
        <trans-unit id="225fc2b10e9a9ea9b701c17da2b76bad93c7b747" translate="yes" xml:space="preserve">
          <source>Testing Web Frameworks</source>
          <target state="translated">测试Web框架</target>
        </trans-unit>
        <trans-unit id="b228c0a462e4fbc62499ce73feb2a8eb75c4bd39" translate="yes" xml:space="preserve">
          <source>Tests are Extremely Slow on Docker and/or Continuous Integration (CI) server.</source>
          <target state="translated">在Docker和/或持续集成(CI)服务器上,测试速度极慢。</target>
        </trans-unit>
        <trans-unit id="c2d1541959da20e20096a585a0538d9010954c98" translate="yes" xml:space="preserve">
          <source>Tests are Failing and You Don't Know Why</source>
          <target state="translated">测试失败了,你却不知道为什么?</target>
        </trans-unit>
        <trans-unit id="3c8e525d4231c4190be70b1ad66cd616c6e2aa0f" translate="yes" xml:space="preserve">
          <source>Tests must be defined synchronously for Jest to be able to collect your tests.</source>
          <target state="translated">必须同步定义测试,Jest才能收集你的测试。</target>
        </trans-unit>
        <trans-unit id="ba7f8377fd3129e903838676530e75e431a41733" translate="yes" xml:space="preserve">
          <source>That module can also contain a &lt;code&gt;getCacheKey&lt;/code&gt; function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</source>
          <target state="translated">该模块还可以包含 &lt;code&gt;getCacheKey&lt;/code&gt; 函数，以生成高速缓存键，以确定逻辑是否已更改，并且依赖于该逻辑的任何高速缓存的工件都应丢弃。</target>
        </trans-unit>
        <trans-unit id="11a78e492a9e9e7ac361c24117bfb5e811bddb35" translate="yes" xml:space="preserve">
          <source>That's all there is to it! You can even update the snapshots with &lt;code&gt;--updateSnapshot&lt;/code&gt; or using the &lt;code&gt;u&lt;/code&gt; key in &lt;code&gt;--watch&lt;/code&gt; mode.</source>
          <target state="translated">这里的所有都是它的！您甚至可以使用 &lt;code&gt;--updateSnapshot&lt;/code&gt; 或在 &lt;code&gt;--watch&lt;/code&gt; 模式下使用 &lt;code&gt;u&lt;/code&gt; 键来更新快照。</target>
        </trans-unit>
        <trans-unit id="fa64459e4e03b6885bddfefb159ed4eb86b6825b" translate="yes" xml:space="preserve">
          <source>That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.</source>
          <target state="translated">就是这样!webpack是一个复杂而灵活的工具,所以你可能需要做一些调整来处理你的特定应用程序的需求。幸运的是,对于大多数项目来说,Jest应该有足够的灵活性来处理你的webpack配置。</target>
        </trans-unit>
        <trans-unit id="7c3361ad0e93e6bc1e1c3de2667211b364b378cd" translate="yes" xml:space="preserve">
          <source>The 4 ways to create an ES6 class mock</source>
          <target state="translated">创建ES6类模拟的4种方法</target>
        </trans-unit>
        <trans-unit id="95c25a4fa34143b1216d44b01d41f9f29688f727" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt;&lt;code&gt;clearMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to clear mocks automatically between tests.</source>
          <target state="translated">该&lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt; &lt;code&gt;clearMocks&lt;/code&gt; &lt;/a&gt;配置选项可用于测试之间自动清除嘲弄。</target>
        </trans-unit>
        <trans-unit id="06c017e6536e5d9f6110e8d0080ca094a5e9ea11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="translated">的&lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt; &lt;code&gt;moduleNameMapper&lt;/code&gt; &lt;/a&gt;可用于一个模块路径映射到不同的模块。默认情况下，预设将所有图像映射到图像存根模块，但是如果找不到模块，则此配置选项可以帮助您：</target>
        </trans-unit>
        <trans-unit id="f7bf3050b5718b4b2d1e33abd9a62cda9462e096" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string--arraystring&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d9df38ccbce3dc2ed35e993bc8900c35030ec6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt;&lt;code&gt;restoreMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to restore mocks automatically between tests.</source>
          <target state="translated">该&lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt; &lt;code&gt;restoreMocks&lt;/code&gt; &lt;/a&gt;配置选项可用于测试之间自动恢复嘲笑。</target>
        </trans-unit>
        <trans-unit id="de8e5c7bbe65466e0240efdae7e25dee3a9f754c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to specify which files shall be transformed by Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1fd9f27ef141c8e346e850781739fd26da2e8bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to whitelist or blacklist files from being transformed with Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="translated">该&lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt; &lt;code&gt;transformIgnorePatterns&lt;/code&gt; &lt;/a&gt;选项可用于白名单或黑名单的文件从巴贝尔被转化。不幸的是，许多react-native npm模块在发布之前并未预编译其源代码。</target>
        </trans-unit>
        <trans-unit id="5fcd870eb6449696a26dbe9a35105b1b3f0eb6a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; file has less than 100% coverage.</source>
          <target state="translated">该 &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; 文件有少于100％的覆盖率。</target>
        </trans-unit>
        <trans-unit id="a4b1bdae91ac8b4ba9e5526619539ee09ec8ff0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/components&lt;/code&gt; directory has less than 40% branch or statement coverage.</source>
          <target state="translated">该 &lt;code&gt;./src/components&lt;/code&gt; 目录有小于40％或分支语句覆盖。</target>
        </trans-unit>
        <trans-unit id="afcc7bfb1a0f92aed03ab154b1ea46d01fb61f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.assertions(2)&lt;/code&gt; call ensures that both callbacks actually get called.</source>
          <target state="translated">该 &lt;code&gt;expect.assertions(2)&lt;/code&gt; 调用确保了回调实际上被调用。</target>
        </trans-unit>
        <trans-unit id="8801cb3154dc90b6dabeb0f8d6adc04b7c96a994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.hasAssertions()&lt;/code&gt; call ensures that the &lt;code&gt;prepareState&lt;/code&gt; callback actually gets called.</source>
          <target state="translated">该 &lt;code&gt;expect.hasAssertions()&lt;/code&gt; 调用确保 &lt;code&gt;prepareState&lt;/code&gt; 回调实际上被调用。</target>
        </trans-unit>
        <trans-unit id="6c3326411c984dac96e58b8dd16be60c0de3724a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect&lt;/code&gt; function is used every time you want to test a value. You will rarely call &lt;code&gt;expect&lt;/code&gt; by itself. Instead, you will use &lt;code&gt;expect&lt;/code&gt; along with a &quot;matcher&quot; function to assert something about a value.</source>
          <target state="translated">该 &lt;code&gt;expect&lt;/code&gt; 功能用于要测试的值每次。您很少 &lt;code&gt;expect&lt;/code&gt; 自己叫期望。取而代之的是，您将使用 &lt;code&gt;expect&lt;/code&gt; 和&amp;ldquo; matcher&amp;rdquo;函数来声明某个值。</target>
        </trans-unit>
        <trans-unit id="6594bb5f273e5a4f7094c361061889db4f707818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function should return an iterable (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, etc.) with the dependencies found in the code.</source>
          <target state="translated">该 &lt;code&gt;extract&lt;/code&gt; 函数应当返回一个可迭代（ &lt;code&gt;Array&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 等）中的代码中发现的依赖关系。</target>
        </trans-unit>
        <trans-unit id="5539a986bbbbf8c351471c1981c9549b0ae07121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; command line runner has a number of useful options. You can run &lt;code&gt;jest --help&lt;/code&gt; to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt; options can also be specified through the CLI.</source>
          <target state="translated">该 &lt;code&gt;jest&lt;/code&gt; 命令行转轮具有许多有用的选项。您可以运行 &lt;code&gt;jest --help&lt;/code&gt; 来查看所有可用选项。下面显示的许多选项也可以一起以所需的方式运行测试。还可以通过CLI指定Jest的每个&lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="8cb0dc4d98327301d27ed47332b5824609aeec5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior.</source>
          <target state="translated">的 &lt;code&gt;jest&lt;/code&gt; 对象自动在每个测试文件内的范围。 &lt;code&gt;jest&lt;/code&gt; 对象中的方法有助于创建模拟并让您控制Jest的整体行为。</target>
        </trans-unit>
        <trans-unit id="71d9b4d1b6d2fe2af134fea43560b4e2597cb34d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior. It can also be imported explicitly by via &lt;code&gt;import {jest} from '@jest/globals'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b8cc683ede161fc025b891451a1f71de3a0d36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mockImplementation&lt;/code&gt; method is useful when you need to define the default implementation of a mock function that is created from another module:</source>
          <target state="translated">当您需要定义从另一个模块创建的模拟函数的默认实现时， &lt;code&gt;mockImplementation&lt;/code&gt; 方法很有用：</target>
        </trans-unit>
        <trans-unit id="f414ca5debc72d67a32f4e6f4214b85eb7903c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; property contains the value that was thrown or returned. &lt;code&gt;value&lt;/code&gt; is undefined when &lt;code&gt;type === 'incomplete'&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;value&lt;/code&gt; 属性包含被抛出或返回的值。当 &lt;code&gt;type === 'incomplete'&lt;/code&gt; 时， &lt;code&gt;value&lt;/code&gt; 是不确定的。</target>
        </trans-unit>
        <trans-unit id="60ae20badadde4a0ac472d6382213bf5645d769e" translate="yes" xml:space="preserve">
          <source>The Chrome Developer Tools will be displayed, and a breakpoint will be set at the first line of the Jest CLI script (this is done to give you time to open the developer tools and to prevent Jest from executing before you have time to do so). Click the button that looks like a &quot;play&quot; button in the upper right hand side of the screen to continue execution. When Jest executes the test that contains the &lt;code&gt;debugger&lt;/code&gt; statement, execution will pause and you can examine the current scope and call stack.</source>
          <target state="translated">将显示Chrome开发者工具，并在Jest CLI脚本的第一行设置一个断点（这样做是为了让您有时间打开开发者工具，并在有时间之前阻止Jest执行） 。单击屏幕右上角看起来像&amp;ldquo;播放&amp;rdquo;按钮的按钮以继续执行。当Jest执行包含 &lt;code&gt;debugger&lt;/code&gt; 语句的测试时，执行将暂停，您可以检查当前作用域并调用堆栈。</target>
        </trans-unit>
        <trans-unit id="cdefcc002eddfb7f6c28f9c7a1871357f57fe794" translate="yes" xml:space="preserve">
          <source>The Jest Object</source>
          <target state="translated">Jest对象</target>
        </trans-unit>
        <trans-unit id="af5336b9f0d6a51b49389a0b7ed3fd6e4c3872c6" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="translated">内置于 &lt;code&gt;react-native&lt;/code&gt; 中的Jest预设带有一些应用于react-native存储库的默认模拟。但是，某些本机组件或第三方组件依赖于要呈现的本机代码。在这种情况下，Jest的手动模拟系统可以帮助模拟基础实现。</target>
        </trans-unit>
        <trans-unit id="e84d67c7006e50386362acd2af1cef9b46290e6c" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However, some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2453c12b4a4f24fbc05ce1e4c46073678639c15d" translate="yes" xml:space="preserve">
          <source>The Jest watch plugin system provides a way to hook into specific parts of Jest and to define watch mode menu prompts that execute code on key press. Combined, these features allow you to develop interactive experiences custom for your workflow.</source>
          <target state="translated">Jest手表插件系统提供了一种方法,可以挂入Jest的特定部分,并定义手表模式的菜单提示,在按键时执行代码。结合这些功能,您可以为您的工作流程定制开发交互式体验。</target>
        </trans-unit>
        <trans-unit id="9caca20f4fce1e72a9edd33743ac65377cd25c74" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;expect&lt;/code&gt; should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</source>
          <target state="translated">给个说法 &lt;code&gt;expect&lt;/code&gt; 应该是你的代码产生的价值，任何参数的匹配应该是正确的值。如果将它们混合使用，您的测试仍然可以使用，但是关于失败的测试的错误消息看起来很奇怪。</target>
        </trans-unit>
        <trans-unit id="8cc68f24cef4585983c9f185a90ee734f90aa8ae" translate="yes" xml:space="preserve">
          <source>The class may optionally expose a &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该类可以选择公开一个 &lt;code&gt;handleTestEvent&lt;/code&gt; 方法以绑定到&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt; &lt;code&gt;jest-circus&lt;/code&gt; &lt;/a&gt;触发的事件。</target>
        </trans-unit>
        <trans-unit id="421f185691a20ea0fadf51a0d254c03ed3247afa" translate="yes" xml:space="preserve">
          <source>The class may optionally expose an asynchronous &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;. Normally, &lt;code&gt;jest-circus&lt;/code&gt; test runner would pause until a promise returned from &lt;code&gt;handleTestEvent&lt;/code&gt; gets fulfilled, &lt;strong&gt;except for the next events&lt;/strong&gt;: &lt;code&gt;start_describe_definition&lt;/code&gt;, &lt;code&gt;finish_describe_definition&lt;/code&gt;, &lt;code&gt;add_hook&lt;/code&gt;, &lt;code&gt;add_test&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; (for the up-to-date list you can look at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts&quot;&gt;SyncEvent type in the types definitions&lt;/a&gt;). That is caused by backward compatibility reasons and &lt;code&gt;process.on('unhandledRejection', callback)&lt;/code&gt; signature, but that usually should not be a problem for most of the use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505efbd4b63a11e029fe3900fcf34d5ab8217315" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples/async&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可从&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples / async获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61f42c40ba4012116e65e0172c4574798fdcc3a1" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples/enzyme&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可在&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples / enzyme上找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e772aeae1e1e3865bc4cf9718bec60261ce607b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples/jquery&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可从&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples / jquery获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e7eb572425bcca3655b70ad564fc1692cbc457f" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples/manual-mocks&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可从&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples / manual-mocks获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0665793600a54f70d63deadff14baccb32f7bff" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples/react-native&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可在&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples / react-native中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9347a0f5e3be6b1f8c7f0c4795c7b215bb18ebd4" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples/react-testing-library&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可在&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples / react-testing-library中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b032ec230190e1c4fc446fee9c02430a5dbbd77b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples/snapshot&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可从&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples / snapshot获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc4f949fe92e0d8c8e3b3a03859bac8aa481d502" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples/timer&lt;/a&gt;.</source>
          <target state="translated">该示例的代码可在&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples / timer上找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f12a555ea8e1761a86877b27341850cacd56ac73" translate="yes" xml:space="preserve">
          <source>The community around Jest is working hard to make the testing experience even greater.</source>
          <target state="translated">围绕着Jest的社区正在努力使测试体验更加出色。</target>
        </trans-unit>
        <trans-unit id="7585ea7c7f78a15b022764598b8197c90e7876b0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should output its coverage files.</source>
          <target state="translated">Jest 应输出其覆盖文件的目录。</target>
        </trans-unit>
        <trans-unit id="376f21d7672ef7ba555cd8e4de07656368d480d0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should store its cached dependency information.</source>
          <target state="translated">Jest 应存储其缓存的依赖信息的目录。</target>
        </trans-unit>
        <trans-unit id="b455adf26e8057d7ba70aa7e64159f9222cf09e6" translate="yes" xml:space="preserve">
          <source>The easiest way to debug Jest tests in &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; is using &lt;code&gt;Jest run/debug configuration&lt;/code&gt;. It will launch tests and automatically attach debugger.</source>
          <target state="translated">在&lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm中&lt;/a&gt;调试Jest测试的最简单方法是使用 &lt;code&gt;Jest run/debug configuration&lt;/code&gt; 。它将启动测试并自动附加调试器。</target>
        </trans-unit>
        <trans-unit id="9c5fa79dfce65458f929b1ce12610301e9cf3865" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestcreatemockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.createMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbe9621df2404d5fbb33e2600044e0b27c47481" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.genMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="translated">此处显示的示例模拟使用&lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt; &lt;code&gt;jest.genMockFromModule&lt;/code&gt; &lt;/a&gt;生成自动模拟，并覆盖其默认行为。这是推荐的方法，但完全是可选的。如果您根本不想使用自动模拟，则可以从模拟文件中导出自己的函数。完全手动模拟的一个缺点是它们是手动的-这意味着您必须在它们模拟更改的模块时随时手动更新它们。因此，最好在满足您的需求时使用或扩展自动模拟。</target>
        </trans-unit>
        <trans-unit id="2508586aa35287e8b27df6e110475235bd694e90" translate="yes" xml:space="preserve">
          <source>The exit code Jest returns on test failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a4a43d898d3af6802055c9164972d36548014d" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">第一个参数是测试名称；第二个参数是包含要测试的期望的函数。第三个参数（可选）是 &lt;code&gt;timeout&lt;/code&gt; （以毫秒为单位），用于指定中止之前要等待的时间。&lt;em&gt;注意：默认超时是5秒。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2bbf7bf0829c4a7923096dc1c283c4faad2abdf7" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6838de5b16cb59f34f7a719f1e8d3453345e067e" translate="yes" xml:space="preserve">
          <source>The first time this test is run, Jest creates a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;snapshot file&lt;/a&gt; that looks like this:</source>
          <target state="translated">第一次运行此测试时，Jest创建一个&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;快照文件&lt;/a&gt;，如下所示：</target>
        </trans-unit>
        <trans-unit id="1492463266cc80f52fcf093c60f36ae239754aca" translate="yes" xml:space="preserve">
          <source>The following example contains a &lt;code&gt;houseForSale&lt;/code&gt; object with nested properties. We are using &lt;code&gt;toHaveProperty&lt;/code&gt; to check for the existence and values of various properties in the object.</source>
          <target state="translated">以下示例包含带有嵌套属性的 &lt;code&gt;houseForSale&lt;/code&gt; 对象。我们使用 &lt;code&gt;toHaveProperty&lt;/code&gt; 来检查对象中各种属性的存在和值。</target>
        </trans-unit>
        <trans-unit id="6b2cf0dc88bf9d13b702ff5e6f3622ae5afb3db3" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;es6-class-mocks&quot;&gt;Jest mock classes work with JavaScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30789d18cf6d3429a995f05a497818957e194817" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;mock-functions&quot;&gt;Jest mock functions work with JavaScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f734d3eeaab81fca3e29f3523738b60fc7cd77" translate="yes" xml:space="preserve">
          <source>The following is a visualization of the default regex:</source>
          <target state="translated">以下是默认的regex的可视化。</target>
        </trans-unit>
        <trans-unit id="47cef9c94451278775edf865a9789b6d6b64cf3f" translate="yes" xml:space="preserve">
          <source>The following keys for built-in functionality &lt;strong&gt;can be overwritten&lt;/strong&gt; :</source>
          <target state="translated">内置功能的以下键&lt;strong&gt;可以被覆盖&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="d021e17efe498d997940dd70ef8fa277b5a2e9cd" translate="yes" xml:space="preserve">
          <source>The function being tested adds an event listener on the &lt;code&gt;#button&lt;/code&gt; DOM element, so we need to set up our DOM correctly for the test. Jest ships with &lt;code&gt;jsdom&lt;/code&gt; which simulates a DOM environment as if you were in the browser. This means that every DOM API that we call can be observed in the same way it would be observed in a browser!</source>
          <target state="translated">被测试的函数在 &lt;code&gt;#button&lt;/code&gt; DOM元素上添加了一个事件侦听器，因此我们需要为测试正确设置DOM。 Jest附带了 &lt;code&gt;jsdom&lt;/code&gt; ，它可以像在浏览器中一样模拟DOM环境。这意味着我们调用的每个DOM API的观察方式都可以与浏览器中观察到的方式相同！</target>
        </trans-unit>
        <trans-unit id="6596e95c4d26bf49becdf01cb51e6fc651959a04" translate="yes" xml:space="preserve">
          <source>The function should either return a path to the module that should be resolved or throw an error if the module can't be found.</source>
          <target state="translated">该函数应该返回一个应该被解析的模块的路径,或者在找不到模块的情况下抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="aab58f520069315bb0a84d63dee876237963ccad" translate="yes" xml:space="preserve">
          <source>The glob patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;.</source>
          <target state="translated">Jest使用的全局模式来检测测试文件。默认情况下，它会在 &lt;code&gt;__tests__&lt;/code&gt; 文件夹中查找 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.jsx&lt;/code&gt; ， &lt;code&gt;.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; 文件，以及带有 &lt;code&gt;.test&lt;/code&gt; 或 &lt;code&gt;.spec&lt;/code&gt; 后缀的任何文件（例如 &lt;code&gt;Component.test.js&lt;/code&gt; 或 &lt;code&gt;Component.spec.js&lt;/code&gt; ） 。它还会找到名为 &lt;code&gt;test.js&lt;/code&gt; 或 &lt;code&gt;spec.js&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="1723fc61e3e4203902e2769fce84e0f47e6816e8" translate="yes" xml:space="preserve">
          <source>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</source>
          <target state="translated">我们的目标是在拉取请求中轻松地审查快照,并反对在测试套件失败时重新生成快照的习惯,而不是检查其失败的根本原因。</target>
        </trans-unit>
        <trans-unit id="2689ebeac189b738f558285371fec779e8a24bfd" translate="yes" xml:space="preserve">
          <source>The jest-community org maintains an &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt; list of great projects and resources related to Jest, this includes all projects not just the ones in the jest-community org.</source>
          <target state="translated">jest-community组织维护着一个&lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;很棒的jest&lt;/a&gt;列表，其中包含与Jest相关的重要项目和资源，其中包括所有项目，而不仅仅是jest-community组织中的项目。</target>
        </trans-unit>
        <trans-unit id="327140711518544eb69d91ed359d0f86086c942f" translate="yes" xml:space="preserve">
          <source>The manual mock equivalent of this would be:</source>
          <target state="translated">相当于人工模拟的是。</target>
        </trans-unit>
        <trans-unit id="968ed8d3094b9f92af942c92765f9081682130bf" translate="yes" xml:space="preserve">
          <source>The module factory function passed to &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; can be a HOF that returns a function*. This will allow calling &lt;code&gt;new&lt;/code&gt; on the mock. Again, this allows you to inject different behavior for testing, but does not provide a way to spy on calls.</source>
          <target state="translated">传递给 &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; 的模块工厂函数可以是返回函数*的HOF。这将允许在模拟中调用 &lt;code&gt;new&lt;/code&gt; 。同样，这允许您注入不同的行为进行测试，但没有提供监视呼叫的方法。</target>
        </trans-unit>
        <trans-unit id="4376614c6f08aa0261023a608b95c6492b8e9525" translate="yes" xml:space="preserve">
          <source>The most common asynchronous pattern is callbacks.</source>
          <target state="translated">最常见的异步模式是回调。</target>
        </trans-unit>
        <trans-unit id="0274127a2409aa50ab0b03082620b24a366d505d" translate="yes" xml:space="preserve">
          <source>The most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).</source>
          <target state="translated">这个API最常见的用途是指定一个给定的测试打算测试的模块(因此不希望被自动嘲讽)。</target>
        </trans-unit>
        <trans-unit id="6cba2620d821c40d1a35b89d6a989fe10a704a0f" translate="yes" xml:space="preserve">
          <source>The most useful ones are &lt;code&gt;matcherHint&lt;/code&gt;, &lt;code&gt;printExpected&lt;/code&gt; and &lt;code&gt;printReceived&lt;/code&gt; to format the error messages nicely. For example, take a look at the implementation for the &lt;code&gt;toBe&lt;/code&gt; matcher:</source>
          <target state="translated">最有用的是 &lt;code&gt;matcherHint&lt;/code&gt; ， &lt;code&gt;printExpected&lt;/code&gt; 和 &lt;code&gt;printReceived&lt;/code&gt; ,用于很好地格式化错误消息。例如，看一下 &lt;code&gt;toBe&lt;/code&gt; 匹配器的实现：</target>
        </trans-unit>
        <trans-unit id="e952463962a1b689236ab9f6e17c97ccd482a4f3" translate="yes" xml:space="preserve">
          <source>The native timer functions (i.e., &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;) are less than ideal for a testing environment since they depend on real time to elapse. Jest can swap out timers with functions that allow you to control the passage of time. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Great Scott!&lt;/a&gt;</source>
          <target state="translated">本地计时器函数（即 &lt;code&gt;setTimeout&lt;/code&gt; ， &lt;code&gt;setInterval&lt;/code&gt; ， &lt;code&gt;clearTimeout&lt;/code&gt; ， &lt;code&gt;clearInterval&lt;/code&gt; ）对于测试环境而言并不理想，因为它们依赖于经过的实时时间。笑话可以用允许您控制时间流逝的功能交换计时器。&lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;伟大的斯科特！&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c7bd0e4ffc67ba49a20c3a2e181946f66fdd8b6" translate="yes" xml:space="preserve">
          <source>The next time you run Jest, &lt;code&gt;tree&lt;/code&gt; will be evaluated, and a snapshot will be written as an argument to &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;:</source>
          <target state="translated">下次运行Jest时，将对 &lt;code&gt;tree&lt;/code&gt; 进行评估，并且会将快照作为 &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; 的参数写入：</target>
        </trans-unit>
        <trans-unit id="5b848fe1137b4b9b68da4deb8ef3d11d697c37f6" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="translated">下次运行测试时，渲染的输出将与先前创建的快照进行比较。快照应与代码更改一起提交。当快照测试失败时，您需要检查它是有意还是无意的更改。如果需要进行更改，则可以使用 &lt;code&gt;jest -u&lt;/code&gt; 调用Jest 以覆盖现有快照。</target>
        </trans-unit>
        <trans-unit id="c0aa57bf091fdb92d54cdb2b0d3bc7f67e93ff89" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d0785b2c19153a1443fb7a2b373d5989af5d74" translate="yes" xml:space="preserve">
          <source>The number of seconds after which a test is considered as slow and reported as such in the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31eaed7b5b436b050c922084e63b820147d0c79" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument has default value &lt;code&gt;2&lt;/code&gt; which means the criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="translated">可选的 &lt;code&gt;numDigits&lt;/code&gt; 参数具有默认值 &lt;code&gt;2&lt;/code&gt; ，这表示标准为 &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; （即 &lt;code&gt;10 ** -2 / 2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="64715c706a809e691edcf14fa2f1881885671388" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument limits the number of digits to check &lt;strong&gt;after&lt;/strong&gt; the decimal point. For the default value &lt;code&gt;2&lt;/code&gt;, the test criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0899f14809b1bdd6ebd980d7e7260be1575887" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first.</source>
          <target state="translated">定义映射的顺序很重要。模式要一个一个地检查,直到有一个适合为止。应先列出最具体的规则。</target>
        </trans-unit>
        <trans-unit id="5b6e6db2c1f69ef0831d7bfa5c2ddb80fbc9eeba" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5b04e8fcaf70465aadc92771f5000507ea04a5" translate="yes" xml:space="preserve">
          <source>The path to a module that can resolve test&amp;lt;-&amp;gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</source>
          <target state="translated">可以解析test &amp;lt;-&amp;gt; snapshot路径的模块的路径。此配置选项使您可以自定义Jest在磁盘上存储快照文件的位置。</target>
        </trans-unit>
        <trans-unit id="af95718edc02b7821b4e9e81772f5338985c3a20" translate="yes" xml:space="preserve">
          <source>The path to a module that runs some code to configure or set up the testing framework before each test. Beware that files imported by the setup script will not be mocked during testing.</source>
          <target state="translated">模块的路径,它在每次测试前运行一些代码来配置或设置测试框架。注意,设置脚本导入的文件在测试过程中不会被嘲讽。</target>
        </trans-unit>
        <trans-unit id="4431569135edde52cd7dc8cd910c15a768e3e1b1" translate="yes" xml:space="preserve">
          <source>The pattern or patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;. See also &lt;a href=&quot;#testmatch-arraystring&quot;&gt;&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">Jest用于检测测试文件的模式。默认情况下，它会在 &lt;code&gt;__tests__&lt;/code&gt; 文件夹中查找 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.jsx&lt;/code&gt; ， &lt;code&gt;.ts&lt;/code&gt; 和 &lt;code&gt;.tsx&lt;/code&gt; 文件，以及带有 &lt;code&gt;.test&lt;/code&gt; 或 &lt;code&gt;.spec&lt;/code&gt; 后缀的任何文件（例如 &lt;code&gt;Component.test.js&lt;/code&gt; 或 &lt;code&gt;Component.spec.js&lt;/code&gt; ） 。它还会找到名为 &lt;code&gt;test.js&lt;/code&gt; 或 &lt;code&gt;spec.js&lt;/code&gt; 的文件。另请参见&lt;a href=&quot;#testmatch-arraystring&quot;&gt; &lt;code&gt;testMatch&lt;/code&gt; &lt;/a&gt; [array &amp;lt;string&amp;gt;]，但请注意，您不能同时指定两个选项。</target>
        </trans-unit>
        <trans-unit id="ac24fd9dddf51302b5efc36ff27838314425a460" translate="yes" xml:space="preserve">
          <source>The preset sets up the environment and is very opinionated and based on what we found to be useful at Facebook. All of the configuration options can be overwritten just as they can be customized when no preset is used.</source>
          <target state="translated">预设设置环境,很有意见,是基于我们在Facebook发现的有用的东西。所有的配置选项都可以被覆盖,就像没有使用预设时可以定制一样。</target>
        </trans-unit>
        <trans-unit id="ac31d1cab716f57b4c0ab81a14ecb8cc6af7f1f3" translate="yes" xml:space="preserve">
          <source>The problem is that the test will complete as soon as &lt;code&gt;fetchData&lt;/code&gt; completes, before ever calling the callback.</source>
          <target state="translated">问题在于，在调用回调之前，测试将在 &lt;code&gt;fetchData&lt;/code&gt; 完成后立即完成。</target>
        </trans-unit>
        <trans-unit id="9c9c92c829ae1b54b1e9c5e404efb1cc15d27456" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="translated">该项目的功能也可以用于运行多种配置或多&lt;a href=&quot;#runner-string&quot;&gt;亚军&lt;/a&gt;。为此，您可以传递一组配置对象。例如，要在Jest的同一调用中运行测试和ESLint（通过&lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="891a6640064d264d47e092465eed82ba702c8606" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d777c2e867accda0c769689ff6458c1a1f2898ad" translate="yes" xml:space="preserve">
          <source>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your &lt;code&gt;package.json&lt;/code&gt; and want the root directory to be the root of your repo, the value for this config param will default to the directory of the &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Jest应该在其中扫描测试和模块的根目录。如果将Jest配置放入 &lt;code&gt;package.json&lt;/code&gt; 中,并希望根目录成为仓库的根目录，则此配置参数的值将默认为 &lt;code&gt;package.json&lt;/code&gt; 的目录。</target>
        </trans-unit>
        <trans-unit id="a722fbdccf79dd6f0ade849e2e9aba5e205e8984" translate="yes" xml:space="preserve">
          <source>The second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:</source>
          <target state="translated">第二个参数可以用来指定正在运行的显式模块工厂,而不是使用Jest的自动锁定功能。</target>
        </trans-unit>
        <trans-unit id="ea2159726c801a056456ea23b7ba004e04675c0c" translate="yes" xml:space="preserve">
          <source>The simplest way to test a value is with exact equality.</source>
          <target state="translated">检验一个值的最简单的方法是用完全相等。</target>
        </trans-unit>
        <trans-unit id="89fdf05ff2117139335a3d62f43a887b7ae92045" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in this case, it's &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="translated">快照工件应与代码更改一起提交，并在代码检查过程中进行检查。 Jest使用&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;漂亮格式&lt;/a&gt;在代码检查期间使快照易于阅读。在随后的测试运行中，Jest会将渲染的输出与先前的快照进行比较。如果它们匹配，则测试将通过。如果它们不匹配，则测试运行器在您的代码中发现了一个错误（在本例中为 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 组件），该错误应予以修复，或者实现已更改，并且快照需要更新。</target>
        </trans-unit>
        <trans-unit id="1a331b33d493c1f842342392e5e84852aa3f9212" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451807d753aa7848105f4c86ff05582eb86d15a2" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bd3296b403f0c79b1219e068c720003979038e" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="translated">将用于测试的测试环境。Jest中的默认环境是通过&lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;的类似于浏览器的环境。如果要构建节点服务，则可以使用 &lt;code&gt;node&lt;/code&gt; 选项来使用类似节点的环境。</target>
        </trans-unit>
        <trans-unit id="83a5c50498cba1f5866a682bd859dafc3028b89d" translate="yes" xml:space="preserve">
          <source>The test environment used for all tests. This can point to any file or node module. Examples: &lt;code&gt;jsdom&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;path/to/my-environment.js&lt;/code&gt;.</source>
          <target state="translated">用于所有测试的测试环境。这可以指向任何文件或节点模块。例如： &lt;code&gt;jsdom&lt;/code&gt; ， &lt;code&gt;node&lt;/code&gt; 或 &lt;code&gt;path/to/my-environment.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d4908fe8da50856a80634fb387ecf713015308b" translate="yes" xml:space="preserve">
          <source>The test for this function will look this way:</source>
          <target state="translated">这个函数的测试将是这样的。</target>
        </trans-unit>
        <trans-unit id="73d8c22714027dd5317a0ccf3a9114cb6f10cf4c" translate="yes" xml:space="preserve">
          <source>The test runner module must export a function with the following signature:</source>
          <target state="translated">测试运行模块必须输出一个具有以下签名的函数:</target>
        </trans-unit>
        <trans-unit id="29baec25ad18f1066c1ae3baa55f05cb1bcb3277" translate="yes" xml:space="preserve">
          <source>The third argument can be used to create virtual mocks &amp;ndash; mocks of modules that don't exist anywhere in the system:</source>
          <target state="translated">第三个参数可用于创建虚拟模拟-系统中不存在的模块模拟​​：</target>
        </trans-unit>
        <trans-unit id="06b3722bc66e669d036905e4f6b2a5bdde949a1d" translate="yes" xml:space="preserve">
          <source>The transform script was changed or Babel was updated and the changes aren't being recognized by Jest?</source>
          <target state="translated">变换脚本被改变了,或者巴别更新了,改变的内容没有被Jest识别?</target>
        </trans-unit>
        <trans-unit id="ca9dbda065b378b7864401a6ebb986bd5f6ee7e2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">该 &lt;code&gt;.rejects&lt;/code&gt; 助手的工作方式类似于 &lt;code&gt;.resolves&lt;/code&gt; 帮手。如果兑现了承诺，则测试将自动失败。</target>
        </trans-unit>
        <trans-unit id="5b03b539d200edd998532b7ea7db20e6e130b6ab" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail. &lt;code&gt;expect.assertions(number)&lt;/code&gt; is not required but recommended to verify that a certain number of &lt;a href=&quot;expect#expectassertionsnumber&quot;&gt;assertions&lt;/a&gt; are called during a test. It is otherwise easy to forget to &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; the &lt;code&gt;.resolves&lt;/code&gt; assertions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb453830c3d6aec96f0b7405572bb292c7ef9964" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;@babel/preset-typescript&lt;/code&gt; to the list of presets in your &lt;code&gt;babel.config.js&lt;/code&gt;.</source>
          <target state="translated">然后将 &lt;code&gt;@babel/preset-typescript&lt;/code&gt; &lt;code&gt;babel.config.js&lt;/code&gt; 添加到babel.config.js中的预设列表中。</target>
        </trans-unit>
        <trans-unit id="70a1108a97f09cf114548ba44e232397dc6dda32" translate="yes" xml:space="preserve">
          <source>Then all your className lookups on the styles object will be returned as-is (e.g., &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt;). This is pretty handy for React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;.</source>
          <target state="translated">然后，您在styles对象上的所有className查找将按原样返回（例如， &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt; ）。这对于React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;非常方便。</target>
        </trans-unit>
        <trans-unit id="7fd2e2b8e86105641b83aa873750ac3f07a7e6d6" translate="yes" xml:space="preserve">
          <source>Then attach VS Code's debugger using the following &lt;code&gt;launch.json&lt;/code&gt; config:</source>
          <target state="translated">然后使用以下 &lt;code&gt;launch.json&lt;/code&gt; 配置附加VS Code的调试器：</target>
        </trans-unit>
        <trans-unit id="e2ebdb0fca325019ed94f96f98ebfc6dc5ffe770" translate="yes" xml:space="preserve">
          <source>Then we need a custom Test Environment for puppeteer</source>
          <target state="translated">那么我们需要为puppeteer定制一个测试环境。</target>
        </trans-unit>
        <trans-unit id="91f5afaec66d498efbeae8c4a2a41bd0c4feb389" translate="yes" xml:space="preserve">
          <source>Then you will see warnings in the console:</source>
          <target state="translated">然后你会在控制台看到警告。</target>
        </trans-unit>
        <trans-unit id="e559c23353ae644c58d965edecd0976830cfc4b2" translate="yes" xml:space="preserve">
          <source>Then, create a file named &lt;code&gt;sum.test.js&lt;/code&gt;. This will contain our actual test:</source>
          <target state="translated">然后，创建一个名为 &lt;code&gt;sum.test.js&lt;/code&gt; 的文件。这将包含我们的实际测试：</target>
        </trans-unit>
        <trans-unit id="490b7879f324bbb8130b919839cb28e4ee52a87d" translate="yes" xml:space="preserve">
          <source>There are a number of helpful tools exposed on &lt;code&gt;this.utils&lt;/code&gt; primarily consisting of the exports from &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt;&lt;code&gt;jest-matcher-utils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;this.utils&lt;/code&gt; 上有很多有用的工具，主要包括&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt; &lt;code&gt;jest-matcher-utils&lt;/code&gt; &lt;/a&gt;的导出。</target>
        </trans-unit>
        <trans-unit id="ce3ddc7ca2ed0e64f9ff4f568a1875d4a36fac12" translate="yes" xml:space="preserve">
          <source>There are also scenarios where you might have a recursive timer -- that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop&amp;hellip; so something like &lt;code&gt;jest.runAllTimers()&lt;/code&gt; is not desirable. For these cases you might use &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt;:</source>
          <target state="translated">在某些情况下，您可能具有递归计时器-这是一个在自己的回调中设置新计时器的计时器。对于这些，运行所有计时器将是一个无休止的循环&amp;hellip;&amp;hellip;因此不希望使用诸如 &lt;code&gt;jest.runAllTimers()&lt;/code&gt; 之类的东西。对于这些情况，您可以使用 &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8062c6b456eff0aa9aea644bdb6882897bba1ab7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code的&lt;/a&gt;内置&lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;调试器&lt;/a&gt;调试Jest测试有多种方法。</target>
        </trans-unit>
        <trans-unit id="a0eee51d034df763b8fd5499614ddfe4723acc15" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built-in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f73f9113b29102310bf6ae603463dfb6eed9cda" translate="yes" xml:space="preserve">
          <source>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a &lt;code&gt;src/&lt;/code&gt; directory in your repo), but prevent it from accessing the rest of the repo.</source>
          <target state="translated">有时候，您只希望Jest在单个子目录中进行搜索（例如在您的存储库中有 &lt;code&gt;src/&lt;/code&gt; 目录的情况下），但阻止它访问存储库的其余部分。</target>
        </trans-unit>
        <trans-unit id="0b73bd505ade591eff51524741c24e46983c0ab6" translate="yes" xml:space="preserve">
          <source>There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a &lt;a href=&quot;manual-mocks&quot;&gt;&lt;code&gt;manual mock&lt;/code&gt;&lt;/a&gt; to override a module dependency.</source>
          <target state="translated">有两种模拟函数的方法：通过创建要在测试代码中使用的模拟函数，或编写&lt;a href=&quot;manual-mocks&quot;&gt; &lt;code&gt;manual mock&lt;/code&gt; &lt;/a&gt;来覆盖模块依赖性。</target>
        </trans-unit>
        <trans-unit id="cb812ec7da9105ae82712a4e1f280b3919c21f67" translate="yes" xml:space="preserve">
          <source>There is a less verbose way using &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail.</source>
          <target state="translated">使用 &lt;code&gt;resolves&lt;/code&gt; 来将已兑现的承诺的价值与任何其他匹配项一起解包的方式比较简单。如果诺言被拒绝，则声明将失败。</target>
        </trans-unit>
        <trans-unit id="d3bc98afc16f0c3f67ba16dbd3f93d1dbca283cf" translate="yes" xml:space="preserve">
          <source>There is an alternate form of &lt;code&gt;test&lt;/code&gt; that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called &lt;code&gt;done&lt;/code&gt;. Jest will wait until the &lt;code&gt;done&lt;/code&gt; callback is called before finishing the test.</source>
          <target state="translated">有另一种 &lt;code&gt;test&lt;/code&gt; 形式可以解决此问题。不要将测试放在带有空参数的函数中，而应使用一个名为 &lt;code&gt;done&lt;/code&gt; 的参数。Jest将等待直到 &lt;code&gt;done&lt;/code&gt; 回调被调用，然后再完成测试。</target>
        </trans-unit>
        <trans-unit id="38513f64442e40688964ff51c98714e3662f0ad9" translate="yes" xml:space="preserve">
          <source>There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:</source>
          <target state="translated">在使用Enzyme和React 16+时,围绕快照测试有一个注意事项。如果你使用下面的样式模拟出一个模块。</target>
        </trans-unit>
        <trans-unit id="45969bbe3aaa0e36ec651be5c3c1e2bc6f21618e" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies.</source>
          <target state="translated">不需要加载任何依赖关系。</target>
        </trans-unit>
        <trans-unit id="feaa8cf5e94e8af347c21dcc253b06efd78e08cf" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies. Puppeteer's &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; classes will automatically be exposed</source>
          <target state="translated">无需加载任何依赖项。Puppeteer的 &lt;code&gt;page&lt;/code&gt; 和 &lt;code&gt;browser&lt;/code&gt; 类将自动公开</target>
        </trans-unit>
        <trans-unit id="205f02d2ffd73f73e820d056d16ae760c3445b0d" translate="yes" xml:space="preserve">
          <source>These helper functions and properties can be found on &lt;code&gt;this&lt;/code&gt; inside a custom matcher:</source>
          <target state="translated">这些辅助功能和性能上可以找到 &lt;code&gt;this&lt;/code&gt; 自定义匹配里面：</target>
        </trans-unit>
        <trans-unit id="6b60550c5bbaa39ef042c5fe44f0a413fa65b5bf" translate="yes" xml:space="preserve">
          <source>These matchers are sugar for common forms of inspecting the &lt;code&gt;.mock&lt;/code&gt; property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:</source>
          <target state="translated">这些匹配器是检查 &lt;code&gt;.mock&lt;/code&gt; 属性的常用形式的糖。如果这更符合您的口味，或者您需要执行更具体的操作，则始终可以自己手动执行此操作：</target>
        </trans-unit>
        <trans-unit id="9d8fa2963a415398720fb864829eb323209ccbff" translate="yes" xml:space="preserve">
          <source>These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:</source>
          <target state="translated">这些mock成员在测试中非常有用,可以断言这些函数是如何被调用、实例化或返回的。</target>
        </trans-unit>
        <trans-unit id="421ccddd05618e2071d86e6bbbe14f0b2076576e" translate="yes" xml:space="preserve">
          <source>These options let you control Jest's behavior in your &lt;code&gt;package.json&lt;/code&gt; file. The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</source>
          <target state="translated">这些选项使您可以控制 &lt;code&gt;package.json&lt;/code&gt; 文件中Jest的行为。Jest的理念是默认情况下运行良好，但是有时您只需要更多的配置功能即可。</target>
        </trans-unit>
        <trans-unit id="fcaea31195ac296456fff13bc787d5eef5067d3d" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</source>
          <target state="translated">这些模式字符串与完整路径匹配。使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来包含项目根目录的路径，以防止它意外忽略在可能具有不同根目录的不同环境中的所有文件。</target>
        </trans-unit>
        <trans-unit id="17b10be41180956fbf5d08f1f6d6c3f7a2db71c5" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">这些模式字符串与完整路径匹配。使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来包含项目根目录的路径，以防止它意外忽略在可能具有不同根目录的不同环境中的所有文件。示例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="005b28d7accf90e223dee1c8e7ebc452b6213877" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt;.</source>
          <target state="translated">这些模式字符串与完整路径匹配。使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来包含项目根目录的路径，以防止它意外忽略在可能具有不同根目录的不同环境中的所有文件。示例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b61d73386d7f1dedf935b736a15ddf6e38555ac" translate="yes" xml:space="preserve">
          <source>These patterns match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">这些模式与完整路径匹配。使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来包含项目根目录的路径，以防止它意外忽略在可能具有不同根目录的不同环境中的所有文件。示例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c464bdbe395120d407822fbb18f9738c9a02965a" translate="yes" xml:space="preserve">
          <source>Third-party plugins are also forbidden to overwrite a key reserved already by another third-party plugin present earlier in the configured plugins list (&lt;code&gt;watchPlugins&lt;/code&gt; array setting). When this happens, you&amp;rsquo;ll also get an error message that tries to help you fix that:</source>
          <target state="translated">也禁止第三方插件覆盖已配置的插件列表（ &lt;code&gt;watchPlugins&lt;/code&gt; 数组设置）中先前存在的另一个第三方插件已经保留的密钥。发生这种情况时，您还会收到一条错误消息，尝试帮助您解决此问题：</target>
        </trans-unit>
        <trans-unit id="ea26b0157e1130ece50df7d1c6b1515a7cc72eba" translate="yes" xml:space="preserve">
          <source>This allows your test file to import the actual &lt;code&gt;Response&lt;/code&gt; object from &lt;code&gt;node-fetch&lt;/code&gt;, rather than a mocked version. This means the test will now pass correctly.</source>
          <target state="translated">这允许您的测试文件从 &lt;code&gt;node-fetch&lt;/code&gt; 而不是模拟版本导入实际的 &lt;code&gt;Response&lt;/code&gt; 对象。这意味着测试现在将正确通过。</target>
        </trans-unit>
        <trans-unit id="6c57d62e399034f0a7b381de3e7d5f645f9ad504" translate="yes" xml:space="preserve">
          <source>This ensures that a value matches the most recent snapshot. Check out &lt;a href=&quot;snapshot-testing&quot;&gt;the Snapshot Testing guide&lt;/a&gt; for more information.</source>
          <target state="translated">这样可以确保值与最新快照匹配。请查看&lt;a href=&quot;snapshot-testing&quot;&gt;快照测试指南&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="dac9e840fc23ac31d800f8538975040bb9ecac74" translate="yes" xml:space="preserve">
          <source>This example also shows how you can nest multiple asymmetric matchers, with &lt;code&gt;expect.stringMatching&lt;/code&gt; inside the &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">这个例子也说明了如何能够嵌套多个不对称的匹配，与 &lt;code&gt;expect.stringMatching&lt;/code&gt; 里面 &lt;code&gt;expect.arrayContaining&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b58eb0d982c4ebd2168b0b47532f786470fd666" translate="yes" xml:space="preserve">
          <source>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</source>
          <target state="translated">此示例配置将在根目录以及示例目录下的每个文件夹中运行 Jest。您可以在同一个Jest实例中运行无限量的项目。</target>
        </trans-unit>
        <trans-unit id="07d5008923646b5de183b191e7806d1642e368f2" translate="yes" xml:space="preserve">
          <source>This is a deep-equality function that will return &lt;code&gt;true&lt;/code&gt; if two objects have the same values (recursively).</source>
          <target state="translated">这是一个深等式函数，如果两个对象具有相同的值（递归），则该函数将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8787606ea91f4fa45b63964dfe671fe216f1f18b" translate="yes" xml:space="preserve">
          <source>This is especially useful for checking arrays or strings size.</source>
          <target state="translated">这对于检查数组或字符串大小特别有用。</target>
        </trans-unit>
        <trans-unit id="daedbdf3b3c492eb985c9a318c876db267766311" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;createMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6bb81a22b9aea2dc501ec88e58677f39b608e1" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;genMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="translated">这是怎么 &lt;code&gt;genMockFromModule&lt;/code&gt; 会嘲笑下列数据类型：</target>
        </trans-unit>
        <trans-unit id="3773feba2fd857753eb4d289910186bb5075a5d0" translate="yes" xml:space="preserve">
          <source>This is just a taste. For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">这只是一种味道。有关匹配器的完整列表，请参阅&lt;a href=&quot;expect&quot;&gt;参考文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b91b6036665a31c72c932de515d167cc3324bf18" translate="yes" xml:space="preserve">
          <source>This is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; callbacks executed. See the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; doc for more information.</source>
          <target state="translated">这通常对于在测试期间同步执行setTimeouts很有用，以便同步断言某些行为，这些行为仅在 &lt;code&gt;setTimeout()&lt;/code&gt; 或 &lt;code&gt;setInterval()&lt;/code&gt; 回调执行后才会发生。有关更多信息，请参见&lt;a href=&quot;timer-mocks&quot;&gt;Timers模拟&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="b7d7c1519ae2cf4a773f1afd649832547d401f24" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some global setup state that is shared across tests.</source>
          <target state="translated">如果你想清理一些跨测试共享的全局设置状态,这通常很有用。</target>
        </trans-unit>
        <trans-unit id="f38502aacbc947736082f8a6708a41145ca79655" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some temporary state that is created by each test.</source>
          <target state="translated">如果你想清理一些由每个测试创建的临时状态,这通常是有用的。</target>
        </trans-unit>
        <trans-unit id="f0881bf0bef2a66191cfe13dc0ddb9fc67b1b880" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to reset some global state that will be used by many tests.</source>
          <target state="translated">如果你想重置一些将被许多测试使用的全局状态,这通常是有用的。</target>
        </trans-unit>
        <trans-unit id="c9eaf0b51489505b8e52db0ac5e52495ccfe19ba" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to set up some global state that will be used by many tests.</source>
          <target state="translated">如果你想设置一些全局状态,而这些全局状态将被许多测试所使用,这通常是有用的。</target>
        </trans-unit>
        <trans-unit id="72cca58df7454651ff7a323dceaea7ab640b298b" translate="yes" xml:space="preserve">
          <source>This is useful for scenarios such as one where the module being tested schedules a &lt;code&gt;setTimeout()&lt;/code&gt; whose callback schedules another &lt;code&gt;setTimeout()&lt;/code&gt; recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.</source>
          <target state="translated">这对于以下情况很有用，例如被测试的模块调度 &lt;code&gt;setTimeout()&lt;/code&gt; ,而其回调递归调度另一个 &lt;code&gt;setTimeout()&lt;/code&gt; （这意味着调度永不停止）。在这些情况下，一次可以一步一步地向前运行很有用。</target>
        </trans-unit>
        <trans-unit id="3a5ea63e8ffdad93e9fef81bb115e6f5cff87758" translate="yes" xml:space="preserve">
          <source>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit &lt;code&gt;jest.mock()&lt;/code&gt;/&lt;code&gt;jest.unmock()&lt;/code&gt; calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</source>
          <target state="translated">这对于一些几乎总是被用作实现细节的常用&amp;ldquo;实用程序&amp;rdquo;模块很有用（例如下划线/破折号等）。通常，最佳做法是使此列表尽可能小，并在各个测试中始终使用显式的 &lt;code&gt;jest.mock()&lt;/code&gt; / &lt;code&gt;jest.unmock()&lt;/code&gt; 调用。明确的每次测试设置使测试的其他读者更容易推断出测试将运行的环境。</target>
        </trans-unit>
        <trans-unit id="511f2fbaf8920a0608d26d5165905f63a5d73c88" translate="yes" xml:space="preserve">
          <source>This is useful when you want to completely reset a &lt;em&gt;mock&lt;/em&gt; back to its initial state. (Note that resetting a &lt;em&gt;spy&lt;/em&gt; will result in a function with no return value).</source>
          <target state="translated">当您要将&lt;em&gt;模拟&lt;/em&gt;完全重置回其初始状态时，这很有用。（请注意，重置&lt;em&gt;间谍&lt;/em&gt;将导致没有返回值的函数）。</target>
        </trans-unit>
        <trans-unit id="c8d37ce85710fb471d0b215386de8769da78ab05" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that extends the automatic mock's behavior.</source>
          <target state="translated">当您要创建扩展自动模拟行为的&lt;a href=&quot;manual-mocks&quot;&gt;手动模拟时&lt;/a&gt;，这很有用。</target>
        </trans-unit>
        <trans-unit id="d837db43e33775ed71a2885c71c5a5602ed7202b" translate="yes" xml:space="preserve">
          <source>This is useful when you want to mock functions in certain test cases and restore the original implementation in others.</source>
          <target state="translated">当你想在某些测试用例中模拟函数,并在其他测试用例中恢复原始实现时,这很有用。</target>
        </trans-unit>
        <trans-unit id="990db4730f558f16c2dc74a09c332aa10da16053" translate="yes" xml:space="preserve">
          <source>This is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as &quot;implementation details&quot; of the module, then you likely do not want to mock them.</source>
          <target state="translated">当你想模拟的依赖项数量远远少于不想模拟的依赖项数量时,这通常是有用的。例如,如果你正在为一个模块编写测试,该模块使用了大量的依赖关系,这些依赖关系可以合理地归类为模块的 &quot;实现细节&quot;,那么你很可能不想模拟它们。</target>
        </trans-unit>
        <trans-unit id="2cd58fa126aba532c56c9309e162bd465bef920f" translate="yes" xml:space="preserve">
          <source>This isn't required - you can write the &lt;code&gt;test&lt;/code&gt; blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</source>
          <target state="translated">这不是必需的-您可以直接在顶层编写 &lt;code&gt;test&lt;/code&gt; 块。但是，如果您希望将测试组织成组，这将很方便。</target>
        </trans-unit>
        <trans-unit id="bc38e9460c76ac869bfb97b729c4bebd9601d3e9" translate="yes" xml:space="preserve">
          <source>This matcher also accepts a string, which it will try to match:</source>
          <target state="translated">这个匹配器也接受一个字符串,它将尝试匹配。</target>
        </trans-unit>
        <trans-unit id="35176ec62e10ad24d9e5bf5b4f422f755d6dc150" translate="yes" xml:space="preserve">
          <source>This means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.</source>
          <target state="translated">这意味着,如果有任何定时器已被安排(但尚未执行),它们将被清除,以后将永远没有机会执行。</target>
        </trans-unit>
        <trans-unit id="688cc7c951b98d9e176b0ce89e8ee57961515438" translate="yes" xml:space="preserve">
          <source>This option allow comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">此选项允许 &lt;code&gt;package.json&lt;/code&gt; 中的注释。在 &lt;code&gt;package.json&lt;/code&gt; 中的任何位置包括注释文本作为此键的值。</target>
        </trans-unit>
        <trans-unit id="e53db60be3e9be7e40274cb356ffc5b833ed548f" translate="yes" xml:space="preserve">
          <source>This option allows comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f12b52eb11d088de9a4fec28160df38ac92acd" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an &lt;code&gt;extract&lt;/code&gt; function. E.g.:</source>
          <target state="translated">此选项允许使用自定义依赖项提取器。它必须是导出具有 &lt;code&gt;extract&lt;/code&gt; 功能的对象的节点模块。例如：</target>
        </trans-unit>
        <trans-unit id="7387fe3f611db301893ec5bf7cc4bbe625475ab6" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">此选项允许使用自定义全局设置模块，该模块导出一个异步功能，该功能在所有测试套件之前被触发一次。此函数获取Jest的 &lt;code&gt;globalConfig&lt;/code&gt; 对象作为参数。</target>
        </trans-unit>
        <trans-unit id="f462a8db0f13013cff3f25a99166d1df5cc7a9d9" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">此选项允许使用自定义的全局拆卸模块，该模块可导出异步功能，该功能在所有测试套件之后都会触发一次。此函数获取Jest的 &lt;code&gt;globalConfig&lt;/code&gt; 对象作为参数。</target>
        </trans-unit>
        <trans-unit id="38a9ab5d714461ae4a524d403260c43d23431747" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom resolver. This resolver must be a node module that exports a function expecting a string as the first argument for the path to resolve and an object with the following structure as the second argument:</source>
          <target state="translated">这个选项允许使用自定义的解析器,这个解析器必须是一个节点模块,它输出一个函数,期望以字符串作为解析路径的第一个参数,并输出一个对象作为第二个参数,这个对象的结构如下。这个解析器必须是一个节点模块,它输出的函数的第一个参数是字符串,作为要解析的路径,第二个参数是一个具有以下结构的对象。</target>
        </trans-unit>
        <trans-unit id="840ac7a9f3696ee6876dcc9f096bc867ff39672e" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</source>
          <target state="translated">这个选项允许使用一个自定义的结果处理器。这个处理程序必须是一个节点模块,它输出一个函数,期望用以下结构的对象作为第一个参数并返回它。</target>
        </trans-unit>
        <trans-unit id="5252ecd1f3fe162f8ab624586087da822d3f2adb" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551495954b791bddca5765dca30e41d9a29511c6" translate="yes" xml:space="preserve">
          <source>This option allows use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="translated">这个选项允许使用自定义测试运行器。默认为jasmine2。可以通过指定测试运行器实现的路径来提供自定义测试运行器。</target>
        </trans-unit>
        <trans-unit id="44d88dc72d1af311d80a8540431e21118807550c" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</source>
          <target state="translated">此选项允许您使用自定义运行器,而不是Jest的默认测试运行器。运行器的例子包括:</target>
        </trans-unit>
        <trans-unit id="f5d6d08e3a74b9984da0a1564cf8f546a76f4a82" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom sequencer instead of Jest's default. &lt;code&gt;sort&lt;/code&gt; may optionally return a Promise.</source>
          <target state="translated">此选项允许您使用自定义音序器而不是Jest的默认音序器。 &lt;code&gt;sort&lt;/code&gt; 可以有选择地返回Promise。</target>
        </trans-unit>
        <trans-unit id="c90ce340f3088fe9972394e67acc0935ff513e5d" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">此选项使您可以使用自定义监视插件。&lt;a href=&quot;watch-plugins&quot;&gt;在此处&lt;/a&gt;阅读有关watch插件的更多信息。</target>
        </trans-unit>
        <trans-unit id="01827b8a7366fbc8b3065a863a5d386474ea1e78" translate="yes" xml:space="preserve">
          <source>This option allows you to use custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a29c38f33c668ab5c982f199af3ff02856c863a" translate="yes" xml:space="preserve">
          <source>This option sets the URL for the jsdom environment. It is reflected in properties such as &lt;code&gt;location.href&lt;/code&gt;.</source>
          <target state="translated">此选项设置jsdom环境的URL。它反映在诸如 &lt;code&gt;location.href&lt;/code&gt; 之类的属性中。</target>
        </trans-unit>
        <trans-unit id="d6bd84ad18e9b644594d518b7f4d72e5c10823c4" translate="yes" xml:space="preserve">
          <source>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</source>
          <target state="translated">这个选项告诉Jest,您测试中的所有导入模块都应该被自动模拟。您的测试中使用的所有模块将有一个替换的实现,保留API的表面。</target>
        </trans-unit>
        <trans-unit id="98e2dcf1f1c275210f7dbe5eb1535d1ff6f9f4c3" translate="yes" xml:space="preserve">
          <source>This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.</source>
          <target state="translated">这通常不应该是你的选择,因为有用的警告可能会丢失。然而,在某些情况下,例如当测试react-native的组件时,我们会将react-native的标签渲染到DOM中,许多警告都是无关紧要的。另一个选择是对 console.warning 进行刷新,抑制特定的警告。</target>
        </trans-unit>
        <trans-unit id="360362a3cbe9313d68d1cf19949c3804d1f4ed87" translate="yes" xml:space="preserve">
          <source>This test used &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;toBe&lt;/code&gt; to test that two values were exactly identical. To learn about the other things that Jest can test, see &lt;a href=&quot;using-matchers&quot;&gt;Using Matchers&lt;/a&gt;.</source>
          <target state="translated">该测试使用的 &lt;code&gt;expect&lt;/code&gt; 和 &lt;code&gt;toBe&lt;/code&gt; 测试两个值均完全相同。要了解Jest可以测试的其他内容，请参阅《&lt;a href=&quot;using-matchers&quot;&gt;使用匹配器》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6e9bf3c4c1c53fe256faefd1ca6b822f3ed81ba" translate="yes" xml:space="preserve">
          <source>This will add a line in the watch mode menu &lt;em&gt;(&lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="translated">这将在监视模式菜单中添加一行&lt;em&gt;（ &lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt; ）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f973bafbc6c9d08f6e504faea0ed8253ab2995f" translate="yes" xml:space="preserve">
          <source>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as &lt;code&gt;global&lt;/code&gt;, as a &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</source>
          <target state="translated">这将用于配置覆盖结果的最低阈值实施。阈值可以指定为 &lt;code&gt;global&lt;/code&gt; ，&lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;以及目录或文件路径。如果没有达到阈值，玩笑将失败。指定为正数的阈值是所需的最小百分比。指定为负数的阈值表示允许的未发现实体的最大数量。</target>
        </trans-unit>
        <trans-unit id="57f790c5005121416e8c2fd8ea8acb72b8b2e025" translate="yes" xml:space="preserve">
          <source>This will be used to configure the behavior of &lt;code&gt;jest-haste-map&lt;/code&gt;, Jest's internal file crawler/cache system. The following options are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b781fa5a1c5086d94b94b3ea9ed32876793c2c2" translate="yes" xml:space="preserve">
          <source>This will collect coverage information for all the files inside the project's &lt;code&gt;rootDir&lt;/code&gt;, except the ones that match &lt;code&gt;**/node_modules/**&lt;/code&gt; or &lt;code&gt;**/vendor/**&lt;/code&gt;.</source>
          <target state="translated">这将收集项目 &lt;code&gt;rootDir&lt;/code&gt; 中所有文件的覆盖率信息，与 &lt;code&gt;**/node_modules/**&lt;/code&gt; 或 &lt;code&gt;**/vendor/**&lt;/code&gt; 匹配的文件除外。</target>
        </trans-unit>
        <trans-unit id="90cf7fb35e518c105a5552c6219ed3a42ba97b15" translate="yes" xml:space="preserve">
          <source>This will let us inspect usage of our mocked class, using &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt;: &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; or near-equivalent: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</source>
          <target state="translated">这将使我们能够使用 &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt; 来检查模拟类的用法： &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; 或近似等效： &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209071c8d9163c6dfec4225f989d2e729c2933ea" translate="yes" xml:space="preserve">
          <source>This will override default reporters:</source>
          <target state="translated">这将覆盖默认的报告器。</target>
        </trans-unit>
        <trans-unit id="1ce9f7467129f03386e85416d9a79207d3f3cd66" translate="yes" xml:space="preserve">
          <source>This will print something like this:</source>
          <target state="translated">这将打印出这样的东西。</target>
        </trans-unit>
        <trans-unit id="0128c1ff802183c48e311ffffeefd6c4c9feb5e7" translate="yes" xml:space="preserve">
          <source>This will render the component as &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; with all of its props in the snapshot output. See also &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;caveats around Enzyme and React 16&lt;/a&gt;.</source>
          <target state="translated">这会将组件呈现为 &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; ，并将其所有道具显示在快照输出中。另请参阅有关&lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;Enzyme和React 16的注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="031037a615f9d64385b25800b6c16eb718e695ad" translate="yes" xml:space="preserve">
          <source>This will run Jest in a Node process that an external debugger can connect to. Note that the process will pause until the debugger has connected to it.</source>
          <target state="translated">这将在外部调试器可以连接到的Node进程中运行Jest。请注意,该进程将暂停,直到调试器连接到它。</target>
        </trans-unit>
        <trans-unit id="ff1252de72d76270d68e2df9f8a951026c2b21af" translate="yes" xml:space="preserve">
          <source>This will throw &lt;strong&gt;&lt;em&gt;TypeError: _soundPlayer2.default is not a constructor&lt;/em&gt;&lt;/strong&gt;, unless the code is transpiled to ES5, e.g. by &lt;code&gt;@babel/preset-env&lt;/code&gt;. (ES5 doesn't have arrow functions nor classes, so both will be transpiled to plain functions.)</source>
          <target state="translated">这将引发&lt;strong&gt;&lt;em&gt;TypeError：_soundPlayer2.default不是构造函数&lt;/em&gt;&lt;/strong&gt;，除非将代码例如 &lt;code&gt;@babel/preset-env&lt;/code&gt; 转换为ES5 。（ES5没有箭头函数或类，因此它们都将被转换为普通函数。）</target>
        </trans-unit>
        <trans-unit id="a06ab4358a87cc38d323a6fe966b85af4c53ee66" translate="yes" xml:space="preserve">
          <source>This will use custom reporter in addition to default reporters that Jest provides:</source>
          <target state="translated">这将在Jest提供的默认报告器之外使用自定义报告器。</target>
        </trans-unit>
        <trans-unit id="5c615ded93f646fc52958cfb01c7b4ab285ef4d0" translate="yes" xml:space="preserve">
          <source>This works if &lt;code&gt;window.matchMedia()&lt;/code&gt; is used in a function (or method) which is invoked in the test. If &lt;code&gt;window.matchMedia()&lt;/code&gt; is executed directly in the tested file, Jest reports the same error. In this case, the solution is to move the manual mock into a separate file and include this one in the test &lt;strong&gt;before&lt;/strong&gt; the tested file:</source>
          <target state="translated">如果在测试中调用的函数（或方法）中使用 &lt;code&gt;window.matchMedia()&lt;/code&gt; ,则此方法有效。如果在测试的文件中直接执行 &lt;code&gt;window.matchMedia()&lt;/code&gt; ，Jest报告相同的错误。在这种情况下，解决方案是将手动模拟放到一个单独的文件中，并在测试&lt;strong&gt;之前&lt;/strong&gt;将其包含在测试文件中：</target>
        </trans-unit>
        <trans-unit id="0bce8231bb2ded7244230db592d5f3864c807820" translate="yes" xml:space="preserve">
          <source>Timer Mocks</source>
          <target state="translated">定时器模拟</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="2ae1e08337e0c3fff9724e42846cabe84620ef36" translate="yes" xml:space="preserve">
          <source>To add a key to the watch menu, implement the &lt;code&gt;getUsageInfo&lt;/code&gt; method, returning a key and the prompt:</source>
          <target state="translated">要将键添加到监视菜单，请实现 &lt;code&gt;getUsageInfo&lt;/code&gt; 方法，返回键和提示：</target>
        </trans-unit>
        <trans-unit id="47b39578e06150847a8bca907a560548f45db25e" translate="yes" xml:space="preserve">
          <source>To attach the built-in debugger, run your tests as aforementioned:</source>
          <target state="translated">要附加内置的调试器,按上述方法运行你的测试。</target>
        </trans-unit>
        <trans-unit id="ecb87b5a4ec9578d9ae035bd9525d7f9a0bbc2d6" translate="yes" xml:space="preserve">
          <source>To automatically launch and attach to a process running your tests, use the following configuration:</source>
          <target state="translated">要自动启动并附加到运行测试的进程,请使用以下配置。</target>
        </trans-unit>
        <trans-unit id="8ef0aac5dc160f7cae3d13500ae91ad9928ac0f1" translate="yes" xml:space="preserve">
          <source>To build your own please visit the &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer&lt;/a&gt; section</source>
          <target state="translated">要构建自己的文件，请访问&amp;ldquo; &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;自定义变压器&amp;rdquo;&lt;/a&gt;部分</target>
        </trans-unit>
        <trans-unit id="aacf02378e2b38f25b6b3e4a83d574f8e35ceb32" translate="yes" xml:space="preserve">
          <source>To clear the record of calls to the mock constructor function and its methods, we call &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;mockClear()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;beforeEach()&lt;/code&gt; function:</source>
          <target state="translated">为了清除对模拟构造函数及其方法调用的记录，我们在 &lt;code&gt;beforeEach()&lt;/code&gt; 函数中调用&lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;mockClear()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="bbcbbcf6e6e23076d275df0fe406a4a0a2189298" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces, write:</source>
          <target state="translated">要比较浮点数，可以使用 &lt;code&gt;toBeGreaterThan&lt;/code&gt; 。例如，如果要测试 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 返回的值大于10盎司，请编写：</target>
        </trans-unit>
        <trans-unit id="f788e1ff5eca8835f05697583466e13f0b6a83d4" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces, write:</source>
          <target state="translated">要比较浮点数，可以使用 &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; 。例如，如果要测试 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 返回的值至少为12盎司，请编写：</target>
        </trans-unit>
        <trans-unit id="3630a179a57250195ccd7b5b31b4f9f6faacbab0" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces, write:</source>
          <target state="translated">要比较浮点数，可以使用 &lt;code&gt;toBeLessThan&lt;/code&gt; 。例如，如果要测试 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 返回的值小于20盎司，请编写：</target>
        </trans-unit>
        <trans-unit id="7bc35d8ccb0dac837113cbb13a4a6a626da1b19b" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces, write:</source>
          <target state="translated">要比较浮点数，可以使用 &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; 。例如，如果要测试 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 返回最多12盎司的值，请编写：</target>
        </trans-unit>
        <trans-unit id="8488371ee9451e1b8abe49379e43d2abac066b15" translate="yes" xml:space="preserve">
          <source>To connect your watch plugin to Jest, add its path under &lt;code&gt;watchPlugins&lt;/code&gt; in your Jest configuration:</source>
          <target state="translated">要将您的监视插件连接到Jest， &lt;code&gt;watchPlugins&lt;/code&gt; 在Jest配置中的watchPlugins下添加其路径：</target>
        </trans-unit>
        <trans-unit id="c020af932b115a7543d8e80249a02617ab77e279" translate="yes" xml:space="preserve">
          <source>To debug in Google Chrome (or any Chromium-based browser), open your browser and go to &lt;code&gt;chrome://inspect&lt;/code&gt; and click on &quot;Open Dedicated DevTools for Node&quot;, which will give you a list of available node instances you can connect to. Click on the address displayed in the terminal (usually something like &lt;code&gt;localhost:9229&lt;/code&gt;) after running the above command, and you will be able to debug Jest using Chrome's DevTools.</source>
          <target state="translated">要在Google Chrome（或任何基于Chromium的浏览器）中进行调试，请打开浏览器并转到 &lt;code&gt;chrome://inspect&lt;/code&gt; ，然后单击&amp;ldquo;打开用于节点的专用DevTools&amp;rdquo;，这将为您提供可以连接到的可用节点实例的列表。 。运行上述命令后，单击显示在终端上的地址（通常类似于 &lt;code&gt;localhost:9229&lt;/code&gt; ），您将能够使用Chrome的DevTools调试Jest。</target>
        </trans-unit>
        <trans-unit id="b40318402328b187f84e5d748dc7567c2272d612" translate="yes" xml:space="preserve">
          <source>To enable async/await in your project, install &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt; and enable the feature in your &lt;code&gt;babel.config.js&lt;/code&gt; file.</source>
          <target state="translated">要在项目中启用异步/等待，请安装&lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt;并在 &lt;code&gt;babel.config.js&lt;/code&gt; 文件中启用该功能。</target>
        </trans-unit>
        <trans-unit id="302ab4340db66b28bf4eeafaae3f85ad66b05f81" translate="yes" xml:space="preserve">
          <source>To ensure that a manual mock and its real implementation stay in sync, it might be useful to require the real module using &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt;&lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt;&lt;/a&gt; in your manual mock and amending it with mock functions before exporting it.</source>
          <target state="translated">为了确保手动模拟与其实际实现保持同步，在导出手动模拟之前，需要在手动模拟中使用&lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt; &lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt; &lt;/a&gt;的实际模块并使用模拟功能对其进行修改，这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="d68306f89da229b2b38be29155f82cf63d2fefff" translate="yes" xml:space="preserve">
          <source>To get around problems like this, Jest provides the &lt;code&gt;jest.requireActual&lt;/code&gt; helper. To make the above test work, make the following change to the imports in the test file:</source>
          <target state="translated">为了解决此类问题，Jest提供了 &lt;code&gt;jest.requireActual&lt;/code&gt; 助手。要使上述测试生效，请对测试文件中的导入进行以下更改：</target>
        </trans-unit>
        <trans-unit id="11fabe8d8570a5bb7d31d77eddfbad12fd7006ea" translate="yes" xml:space="preserve">
          <source>To handle key press events from the key returned by &lt;code&gt;getUsageInfo&lt;/code&gt;, you can implement the &lt;code&gt;run&lt;/code&gt; method. This method returns a &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; that can be resolved when the plugin wants to return control to Jest. The &lt;code&gt;boolean&lt;/code&gt; specifies if Jest should rerun the tests after it gets the control back.</source>
          <target state="translated">要处理 &lt;code&gt;getUsageInfo&lt;/code&gt; 返回的键中的按键事件，可以实现 &lt;code&gt;run&lt;/code&gt; 方法。此方法返回 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; ，当插件要将控制权返回给Jest时可以解决。该 &lt;code&gt;boolean&lt;/code&gt; 指定是否应玩笑重新运行该测试中，它取得了控制权交还给之后。</target>
        </trans-unit>
        <trans-unit id="90daa538926bb277438f39b2435beb57540f0d66" translate="yes" xml:space="preserve">
          <source>To inject nested object values use you can supply a keyPath i.e. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</source>
          <target state="translated">要注入嵌套对象值，可以使用keyPath即 &lt;code&gt;$variable.path.to.value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="970630451f28f37da628f2cf8fe84113808b5a54" translate="yes" xml:space="preserve">
          <source>To make a dependency explicit instead of implicit, you can call &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt;&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt;&lt;/a&gt; to add a module for an individual test file instead of adding its path to &lt;code&gt;snapshotSerializers&lt;/code&gt; in Jest configuration.</source>
          <target state="translated">要使依赖关系显式而不是隐式，可以调用&lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt; &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; &lt;/a&gt;为单个测试文件添加模块，而不是在Jest配置中将其路径添加到 &lt;code&gt;snapshotSerializers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cd5137812be95f283926c769870dc2156199426" translate="yes" xml:space="preserve">
          <source>To make this work with Jest you need to update your Jest configuration with this: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt;.</source>
          <target state="translated">要使用Jest进行此操作，您需要使用以下命令更新Jest配置： &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="579190d7cd820daa4fd8a13a589227f7e2eaf9e7" translate="yes" xml:space="preserve">
          <source>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</source>
          <target state="translated">为了解决这个问题,我们需要更新我们的快照工件。你可以用一个标志来运行Jest,告诉它重新生成快照。</target>
        </trans-unit>
        <trans-unit id="ce42fc860995230ab9f043725c3815bd5aecd9d4" translate="yes" xml:space="preserve">
          <source>To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.</source>
          <target state="translated">为了测试这个函数,我们可以使用一个mock函数,并检查mock的状态,以确保回调按预期被调用。</target>
        </trans-unit>
        <trans-unit id="5fe8e22ac596d3e8399b1774c9a6d272aedb50d5" translate="yes" xml:space="preserve">
          <source>To transform your existing tests, navigate to the project containing the tests and run:</source>
          <target state="translated">要转换现有的测试,请导航到包含测试的项目并运行。</target>
        </trans-unit>
        <trans-unit id="aa8c2a8d1b80b426924e3a346cf5aa28210292b8" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">要使用&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;，请通过 &lt;code&gt;yarn&lt;/code&gt; 安装所需的依赖项：</target>
        </trans-unit>
        <trans-unit id="4946751d041e4c3281bd74994c81b3a3ffb0fde6" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ff297d04a3d2c50427a66fd27f8359258dbfcd" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;my-serializer-module&lt;/code&gt; as a serializer, configuration would be as follows:</source>
          <target state="translated">要将 &lt;code&gt;my-serializer-module&lt;/code&gt; 用作序列化器，配置如下：</target>
        </trans-unit>
        <trans-unit id="244873608d8f270057c41ef22dd861ecd2f588e8" translate="yes" xml:space="preserve">
          <source>To use snapshot testing inside of your custom matcher you can import &lt;code&gt;jest-snapshot&lt;/code&gt; and use it from within your matcher.</source>
          <target state="translated">要在自定义匹配器中使用快照测试，您可以导入 &lt;code&gt;jest-snapshot&lt;/code&gt; 并在匹配器中使用它。</target>
        </trans-unit>
        <trans-unit id="24551f54e6dc91a01a872c5230741bbe5ab3d386" translate="yes" xml:space="preserve">
          <source>To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in &lt;code&gt;my-custom-environment.js&lt;/code&gt; in some subfolder of your project, then the annotation might looke like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8bcde3184680e702bef641e43c9e47fee12e79" translate="yes" xml:space="preserve">
          <source>To write a test-runner, export a class with which accepts &lt;code&gt;globalConfig&lt;/code&gt; in the constructor, and has a &lt;code&gt;runTests&lt;/code&gt; method with the signature:</source>
          <target state="translated">编写测试亚军，出口与接受类 &lt;code&gt;globalConfig&lt;/code&gt; 在构造函数中，并具有 &lt;code&gt;runTests&lt;/code&gt; 方法与签名：</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="2aa91be80e98aceeddfc910352453386480fb849" translate="yes" xml:space="preserve">
          <source>Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.</source>
          <target state="translated">用于提取和解析JavaScript文件顶部注释的工具。输出各种函数来处理注释块中的数据。</target>
        </trans-unit>
        <trans-unit id="b2489dcd056dffceaf32fcd13112faa56f6733de" translate="yes" xml:space="preserve">
          <source>Tool for identifying modified files in a git/hg repository. Exports two functions:</source>
          <target state="translated">用于识别 git/hg 仓库中的修改文件的工具。输出两个函数。</target>
        </trans-unit>
        <trans-unit id="bba6cd68031555a8aa461d4b5c0878aad6420744" translate="yes" xml:space="preserve">
          <source>Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:</source>
          <target state="translated">用于验证用户提交的配置的工具。输出一个函数,该函数需要两个参数:用户的配置和一个包含配置示例和其他选项的对象。返回值是一个包含两个属性的对象。</target>
        </trans-unit>
        <trans-unit id="49e105a4ea6033c274af2894a4fcb5d0e03e7eb5" translate="yes" xml:space="preserve">
          <source>Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a &quot;pretty-printed&quot; string illustrating the difference between the two arguments.</source>
          <target state="translated">用于可视化数据变化的工具。输出一个函数,比较任意类型的两个值,并返回一个 &quot;漂亮的打印 &quot;字符串,说明两个参数之间的差异。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="6bce18334982e1e09a6fddd7fb83bd243818a5bd" translate="yes" xml:space="preserve">
          <source>Try running Jest with &lt;a href=&quot;cli#--watchman&quot;&gt;&lt;code&gt;--no-watchman&lt;/code&gt;&lt;/a&gt; or set the &lt;code&gt;watchman&lt;/code&gt; configuration option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试使用&lt;a href=&quot;cli#--watchman&quot;&gt; &lt;code&gt;--no-watchman&lt;/code&gt; &lt;/a&gt; watchman运行Jest 或将 &lt;code&gt;watchman&lt;/code&gt; 配置选项设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5c112e63b4110470aacee270c74bf17085f1c78" translate="yes" xml:space="preserve">
          <source>Try using the debugging support built into Node. Note: This will only work in Node.js 8+.</source>
          <target state="translated">尝试使用Node内置的调试支持。注意:这只适用于Node.js 8+。</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="88ebf4f8084b9e64c1280cb83273c9798bb6700b" translate="yes" xml:space="preserve">
          <source>Uh oh, something went wrong? Use this guide to resolve issues with Jest.</source>
          <target state="translated">啊哦,出了什么问题?使用本指南来解决Jest的问题。</target>
        </trans-unit>
        <trans-unit id="aed4821821385ee1bab0a8cb0c2780d5e1b4df72" translate="yes" xml:space="preserve">
          <source>Unresolved Promises</source>
          <target state="translated">未解决的承诺</target>
        </trans-unit>
        <trans-unit id="bb0295c9e03b394a6c931085d1d4692dabdf5136" translate="yes" xml:space="preserve">
          <source>Updating Snapshots</source>
          <target state="translated">更新快照</target>
        </trans-unit>
        <trans-unit id="53431747077771927601efb2109e96aa6b694e10" translate="yes" xml:space="preserve">
          <source>Usage is similar to the module factory function, except that you can omit the second argument from &lt;code&gt;jest.mock()&lt;/code&gt;, and you must import the mocked method into your test file, since it is no longer defined there. Use the original module path for this; don't include &lt;code&gt;__mocks__&lt;/code&gt;.</source>
          <target state="translated">用法与模块工厂功能相似，不同之处在于您可以从 &lt;code&gt;jest.mock()&lt;/code&gt; 中省略第二个参数，并且必须将模拟方法导入测试文件，因为该方法不再在那里定义。为此，请使用原始模块路径。不要包括 &lt;code&gt;__mocks__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b944d8872fd4ee30de2cd74c68ff456d47e22c9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to refer to &lt;a href=&quot;#rootdir-string&quot;&gt;&lt;code&gt;rootDir&lt;/code&gt;&lt;/a&gt; value if you want to use file paths.</source>
          <target state="translated">如果要使用文件路径，请使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来引用&lt;a href=&quot;#rootdir-string&quot;&gt; &lt;code&gt;rootDir&lt;/code&gt; &lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="965fbdc0ee9e136c141ea84e0657f2fdfba937b0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--watchAll=false&lt;/code&gt; to explicitly disable the watch mode. Note that in most CI environments, this is automatically handled for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271c57d8c405fa9198756ec5064bbb4c3a46ab5a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.rejects&lt;/code&gt; to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</source>
          <target state="translated">使用 &lt;code&gt;.rejects&lt;/code&gt; 可以取消承诺被拒绝的原因，以便可以链接任何其他匹配器。如果兑现了承诺，则声明将失败。</target>
        </trans-unit>
        <trans-unit id="ff4d09b1ab22e18857563408d1fce004b2fe79a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBe&lt;/code&gt; to compare primitive values or to check referential identity of object instances. It calls &lt;code&gt;Object.is&lt;/code&gt; to compare values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">使用 &lt;code&gt;.toBe&lt;/code&gt; 比较原始值或检查对象实例的引用身份。它调用 &lt;code&gt;Object.is&lt;/code&gt; 来比较值，这对于测试比 &lt;code&gt;===&lt;/code&gt; 严格相等运算符甚至更好。</target>
        </trans-unit>
        <trans-unit id="67ef92856838e5751e399698b48aa87c7d8163a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeDefined&lt;/code&gt; to check that a variable is not undefined. For example, if you want to check that a function &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; returns &lt;em&gt;something&lt;/em&gt;, you can write:</source>
          <target state="translated">使用 &lt;code&gt;.toBeDefined&lt;/code&gt; 检查变量是否未定义。例如，如果要检查 &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; 函数是否返回了&lt;em&gt;某些内容&lt;/em&gt;，可以编写：</target>
        </trans-unit>
        <trans-unit id="f81a87ad40dde8019daa6911a9c4296bf8a5d015" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeFalsy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">当您不在乎值是什么并且想要确保值在布尔上下文中为false时，请使用 &lt;code&gt;.toBeFalsy&lt;/code&gt; 。例如，假设您有一些类似于以下内容的应用程序代码：</target>
        </trans-unit>
        <trans-unit id="50aa6948737b4375185feeebf13f13dbe3451e19" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; to check that an object is an instance of a class. This matcher uses &lt;code&gt;instanceof&lt;/code&gt; underneath.</source>
          <target state="translated">使用 &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; 检查对象是否是类的实例。该匹配器在下面使用 &lt;code&gt;instanceof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93a0ac0f3d847ffa6b85c3555bc23bce0abae9d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeNaN&lt;/code&gt; when checking a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">当检查值为 &lt;code&gt;NaN&lt;/code&gt; 时，请使用 &lt;code&gt;.toBeNaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e05d177a2e90b6b046b4b02a5621b8f26893024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeTruthy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">当您不在乎值是什么并且想要确保值在布尔上下文中为true时，请使用 &lt;code&gt;.toBeTruthy&lt;/code&gt; 。例如，假设您有一些类似于以下内容的应用程序代码：</target>
        </trans-unit>
        <trans-unit id="c167d5affa8fa782feb54d90f30b85615f390e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeUndefined&lt;/code&gt; to check that a variable is undefined. For example, if you want to check that a function &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt; for the &lt;code&gt;'octopus'&lt;/code&gt; flavor, because there is no good octopus-flavored drink:</source>
          <target state="translated">使用 &lt;code&gt;.toBeUndefined&lt;/code&gt; 检查变量是否未定义。例如，如果您要检查功能 &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; 是否为 &lt;code&gt;'octopus'&lt;/code&gt; 味返回 &lt;code&gt;undefined&lt;/code&gt; ，因为没有好的章鱼味饮料：</target>
        </trans-unit>
        <trans-unit id="a934298864a7697607ca428a7e4d71c72de7efbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContain&lt;/code&gt; when you want to check that an item is in an array. For testing the items in the array, this uses &lt;code&gt;===&lt;/code&gt;, a strict equality check. &lt;code&gt;.toContain&lt;/code&gt; can also check whether a string is a substring of another string.</source>
          <target state="translated">当您要检查项目是否在数组中时，请使用 &lt;code&gt;.toContain&lt;/code&gt; 。为了测试数组中的项目，它使用 &lt;code&gt;===&lt;/code&gt; ，即严格的相等性检查。 &lt;code&gt;.toContain&lt;/code&gt; 还可以检查一个字符串是否是另一个字符串的子字符串。</target>
        </trans-unit>
        <trans-unit id="bd36fedc663beba2df99e661929cac1ca55d82a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContainEqual&lt;/code&gt; when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</source>
          <target state="translated">当您要检查数组中是否包含具有特定结构和值的项目时，请使用 &lt;code&gt;.toContainEqual&lt;/code&gt; 。为了测试数组中的项目，此匹配器递归地检查所有字段的相等性，而不是检查对象标识。</target>
        </trans-unit>
        <trans-unit id="2892f11bab4090104beb941f4d3d44f139cd4a21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toEqual&lt;/code&gt; to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls &lt;code&gt;Object.is&lt;/code&gt; to compare primitive values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">使用 &lt;code&gt;.toEqual&lt;/code&gt; 递归比较对象实例的所有属性（也称为&amp;ldquo;深度&amp;rdquo;相等）。它调用 &lt;code&gt;Object.is&lt;/code&gt; 比较原始值，这对于测试比 &lt;code&gt;===&lt;/code&gt; 严格相等运算符甚至更好。</target>
        </trans-unit>
        <trans-unit id="22f31877b97035b92fb10441a1a3485e65903b49" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; to ensure that a mock function got called.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; 以确保调用了模拟函数。</target>
        </trans-unit>
        <trans-unit id="dfcaf02f56b10c94ecc202b3c8d9087baccb5181" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; to ensure that a mock function got called exact number of times.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; 以确保模拟函数被调用的确切次数。</target>
        </trans-unit>
        <trans-unit id="6c8d2793887755a171ad2f5be4f1a01fc5c6e2d5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; to ensure that a mock function was called with specific arguments.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; 确保使用特定参数调用了模拟函数。</target>
        </trans-unit>
        <trans-unit id="4be0de20431e47e5724878c19b00a0321ac838e1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; 测试模拟函数最后返回的特定值。如果对模拟函数的最后一次调用引发了错误，则无论您提供什么值作为预期的返回值，该匹配器都将失败。</target>
        </trans-unit>
        <trans-unit id="7001ece11621c6dd7371042298806dcb68ab8bdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLength&lt;/code&gt; to check that an object has a &lt;code&gt;.length&lt;/code&gt; property and it is set to a certain numeric value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveLength&lt;/code&gt; 来检查对象是否具有 &lt;code&gt;.length&lt;/code&gt; 属性并将其设置为某个数值。</target>
        </trans-unit>
        <trans-unit id="4a20c538c65f701e8900dd32f27f93e926fbf397" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; 测试模拟函数为第n次调用返回的特定值。如果对模拟函数的第n次调用引发错误，则无论您提供什么值作为期望的返回值，此匹配器都将失败。</target>
        </trans-unit>
        <trans-unit id="bc794bedf39c69791593b20f2971ba46bf591e64" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveProperty&lt;/code&gt; to check if property at provided reference &lt;code&gt;keyPath&lt;/code&gt; exists for an object. For checking deeply nested properties in an object you may use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;dot notation&lt;/a&gt; or an array containing the keyPath for deep references.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveProperty&lt;/code&gt; 检查提供的参考 &lt;code&gt;keyPath&lt;/code&gt; 处的对象属性是否存在。要检查对象中的深层嵌套属性，可以使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;点表示法&lt;/a&gt;或包含keyPath的数组作为深层引用。</target>
        </trans-unit>
        <trans-unit id="5c5db22f649bb5e433fce75313e71f348fcdbe60" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; 以确保模拟函数成功返回确切次数（即未引发错误）。对模拟函数的任何引发错误的调用均不计入该函数返回的次数。</target>
        </trans-unit>
        <trans-unit id="00cc15ef74e3e3bbb9d04e26768f906229227777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; to ensure that a mock function returned a specific value.</source>
          <target state="translated">使用 &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; 以确保模拟函数返回特定值。</target>
        </trans-unit>
        <trans-unit id="3403bfc7d77f929d8284a0b531fb242672320cf2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatch&lt;/code&gt; to check that a string matches a regular expression.</source>
          <target state="translated">使用 &lt;code&gt;.toMatch&lt;/code&gt; 检查字符串是否与正则表达式匹配。</target>
        </trans-unit>
        <trans-unit id="6aa577eec7c4f8e335bb974a5ba8a04b9b825d62" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatchObject&lt;/code&gt; to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">使用 &lt;code&gt;.toMatchObject&lt;/code&gt; 来检查JavaScript对象是否与对象属性的子集匹配。它将接收到的对象与预期对象中&lt;strong&gt;没有的&lt;/strong&gt;属性进行匹配。</target>
        </trans-unit>
        <trans-unit id="43d74a2c2c927835dbc06a10fe0a834ecd3cf583" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toStrictEqual&lt;/code&gt; to test that objects have the same types as well as structure.</source>
          <target state="translated">使用 &lt;code&gt;.toStrictEqual&lt;/code&gt; 来测试对象具有相同的类型和结构。</target>
        </trans-unit>
        <trans-unit id="60e9ea675b7707c4a125a8d5da6124d2b7dfa82a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrow&lt;/code&gt; to test that a function throws when it is called. For example, if we want to test that &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; throws, because octopus flavor is too disgusting to drink, we could write:</source>
          <target state="translated">使用 &lt;code&gt;.toThrow&lt;/code&gt; 来测试函数在调用时是否抛出。例如，如果我们想测试一下 &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; 抛出的食物，因为章鱼的味道太恶心而无法饮用，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="b8835c8692fc22c521a477117dec692aecc544e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">使用 &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; 来测试函数在调用时抛出与最新快照匹配的错误。</target>
        </trans-unit>
        <trans-unit id="8656cd1667dc531479d8b4cb204dd90a1579844f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">使用 &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; 来测试函数在调用时抛出与最新快照匹配的错误。</target>
        </trans-unit>
        <trans-unit id="0440b25bd05f6a2e3c56826df198b652d25c12c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.each&lt;/code&gt; if you keep duplicating the same test suites with different data. &lt;code&gt;describe.each&lt;/code&gt; allows you to write the test suite once and pass data in.</source>
          <target state="translated">如果您继续使用不同的数据复制相同的测试套件，请使用 &lt;code&gt;describe.each&lt;/code&gt; 。 &lt;code&gt;describe.each&lt;/code&gt; 允许您编写一次测试套件并传递数据。</target>
        </trans-unit>
        <trans-unit id="ef60fa41c287f5e40cf5103947099b8fe473bb0e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.only.each&lt;/code&gt; if you want to only run specific tests suites of data driven tests.</source>
          <target state="translated">如果只想运行数据驱动测试的特定测试套件，请使用 &lt;code&gt;describe.only.each&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cedc27af374f9505722e2e0748157f331b8c1a04" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.skip.each&lt;/code&gt; if you want to stop running a suite of data driven tests.</source>
          <target state="translated">如果要停止运行一组数据驱动的测试，请使用 &lt;code&gt;describe.skip.each&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d406a9d711b46330782be9bc2cb621080a4ae6f6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;react-test-renderer&lt;/code&gt;. The test renderer doesn't care about element types and will happily accept e.g. &lt;code&gt;SomeComponent&lt;/code&gt;. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.</source>
          <target state="translated">使用 &lt;code&gt;react-test-renderer&lt;/code&gt; 。测试渲染器不在乎元素类型，并会愉快地接受例如 &lt;code&gt;SomeComponent&lt;/code&gt; 。您可以使用测试渲染器检查快照，并使用酶单独检查组件行为。</target>
        </trans-unit>
        <trans-unit id="7e3d957c7581b38a6f6d9efe05f990ae9f8f779c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</source>
          <target state="translated">使用 &lt;code&gt;resolves&lt;/code&gt; 来解开已兑现承诺的价值，以便可以链接任何其他匹配器。如果诺言被拒绝，则声明失败。</target>
        </trans-unit>
        <trans-unit id="1345114e2fd1c60a6d60edc7450f9a4afadae484" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in, the tests are all run asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef6514f1b68a3a68401c341c0da426d04e4aa20" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.only.each&lt;/code&gt; if you want to only run specific tests with different test data concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263222bc2f899a0d715a6fab20c766f111044fc2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.skip.each&lt;/code&gt; if you want to stop running a collection of asynchronous data driven tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e28dd2d14db9066d63653631068e696eab675f0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent&lt;/code&gt; if you want the test to run concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afb7e6906f2b3257d85cde9c36efa5c6e5bcbfc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in.</source>
          <target state="translated">如果您继续使用不同的数据复制相同的测试，请使用 &lt;code&gt;test.each&lt;/code&gt; 。 &lt;code&gt;test.each&lt;/code&gt; 允许您编写一次测试并传递数据。</target>
        </trans-unit>
        <trans-unit id="5ed7e082f3c3b04fc36bc3b9da1fb4c701925c6d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.only.each&lt;/code&gt; if you want to only run specific tests with different test data.</source>
          <target state="translated">如果只想使用不同的测试数据运行特定的测试，请使用 &lt;code&gt;test.only.each&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a662231e654755bb86491a61d19bfda30bf8dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.skip.each&lt;/code&gt; if you want to stop running a collection of data driven tests.</source>
          <target state="translated">如果要停止运行数据驱动的测试集合，请使用 &lt;code&gt;test.skip.each&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04f44ceaa0fcfd12976de28307ac74bab48f40fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.todo&lt;/code&gt; when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</source>
          <target state="translated">计划编写测试时，请使用 &lt;code&gt;test.todo&lt;/code&gt; 。这些测试将在最后的摘要输出中突出显示，因此您知道仍需要执行多少测试。</target>
        </trans-unit>
        <trans-unit id="72b53cf691901a7f6c7db879139a7d5cc2a021bd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeCloseTo&lt;/code&gt; to compare floating point numbers for approximate equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67135d0a79cc68d7ce480429610bb2f2628671fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThan&lt;/code&gt; to compare &lt;code&gt;received &amp;gt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3930db7617a0eec776a6b70b86ff9f67aaf7165d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;gt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c60b4cd3422307c10fbc69a5ebc0d409a25e545" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThan&lt;/code&gt; to compare &lt;code&gt;received &amp;lt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ee9741a4bceeea1bf6f12bd38538086556426e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;lt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67497066b431f7970b52aff03e2267c3031fe3af" translate="yes" xml:space="preserve">
          <source>Use it in your Jest config file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759c0eb81e3b691ac63ce62826c9faeffd303147" translate="yes" xml:space="preserve">
          <source>Use jest-dynamodb Preset</source>
          <target state="translated">使用is-dynamodb预设</target>
        </trans-unit>
        <trans-unit id="7194dde7b6fdc7725f8efc98a8775cd0fe57fa0a" translate="yes" xml:space="preserve">
          <source>Use jest-mongodb Preset</source>
          <target state="translated">使用is-mongodb预设</target>
        </trans-unit>
        <trans-unit id="d6629ac509cad69b4360ba597e78efb90888b162" translate="yes" xml:space="preserve">
          <source>Use jest-puppeteer Preset</source>
          <target state="translated">使用jest-puppeteer预设</target>
        </trans-unit>
        <trans-unit id="8859f21b394eb7bddbe02c98d39f3c5d61b96c00" translate="yes" xml:space="preserve">
          <source>Use this configuration option to add custom reporters to Jest. A custom reporter is a class that implements &lt;code&gt;onRunStart&lt;/code&gt;, &lt;code&gt;onTestStart&lt;/code&gt;, &lt;code&gt;onTestResult&lt;/code&gt;, &lt;code&gt;onRunComplete&lt;/code&gt; methods that will be called when any of those events occurs.</source>
          <target state="translated">使用此配置选项将自定义报告程序添加到Jest。定制报告程序是一个类，它实现 &lt;code&gt;onRunStart&lt;/code&gt; ， &lt;code&gt;onTestStart&lt;/code&gt; ， &lt;code&gt;onTestResult&lt;/code&gt; 和 &lt;code&gt;onRunComplete&lt;/code&gt; 方法，这些方法在发生任何这些事件时将被调用。</target>
        </trans-unit>
        <trans-unit id="0ce722d28dd2ac22869f544554814473ced27729" translate="yes" xml:space="preserve">
          <source>Useful to create async mock functions that will always reject:</source>
          <target state="translated">用于创建总是拒绝的异步模拟函数。</target>
        </trans-unit>
        <trans-unit id="82fe22471a3c89a8a884379e2a589a9b9393684f" translate="yes" xml:space="preserve">
          <source>Useful to mock async functions in async tests:</source>
          <target state="translated">在异步测试中模拟异步函数很有用。</target>
        </trans-unit>
        <trans-unit id="4d6f5093469250351be715bab11328d708148671" translate="yes" xml:space="preserve">
          <source>Useful to resolve different values over multiple async calls:</source>
          <target state="translated">对解决多个异步调用的不同值很有用。</target>
        </trans-unit>
        <trans-unit id="8386651610226fd04ae64f938ef5bbd0efe279f3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;describe.skip&lt;/code&gt; is often a cleaner alternative to temporarily commenting out a chunk of tests.</source>
          <target state="translated">使用 &lt;code&gt;describe.skip&lt;/code&gt; 通常是临时注释掉大量测试的更干净的选择。</target>
        </trans-unit>
        <trans-unit id="8da013e9c1193b5fd4e55adc4f5c72966bc2f345" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;jest.doMock()&lt;/code&gt; with ES6 imports requires additional steps. Follow these if you don't want to use &lt;code&gt;require&lt;/code&gt; in your tests:</source>
          <target state="translated">将 &lt;code&gt;jest.doMock()&lt;/code&gt; 与ES6导入一起使用需要其他步骤。如果您不想在测试中使用 &lt;code&gt;require&lt;/code&gt; ，请遵循以下步骤：</target>
        </trans-unit>
        <trans-unit id="5b7ceb252455569b8991c8fe4bfba034672b82cf" translate="yes" xml:space="preserve">
          <source>Using Babel</source>
          <target state="translated">使用Babel</target>
        </trans-unit>
        <trans-unit id="ad353105ab08c29227ad5d0775b29687a1b718c7" translate="yes" xml:space="preserve">
          <source>Using Matchers</source>
          <target state="translated">使用匹配器</target>
        </trans-unit>
        <trans-unit id="8c578fdee5f39cae171b3ae3dc5e52be3eb3db63" translate="yes" xml:space="preserve">
          <source>Using TypeScript</source>
          <target state="translated">使用TypeScript</target>
        </trans-unit>
        <trans-unit id="e2b797adce82409b798a1e85b5f20128645a30c7" translate="yes" xml:space="preserve">
          <source>Using a mock function</source>
          <target state="translated">使用模拟函数</target>
        </trans-unit>
        <trans-unit id="fdad49cc59429141e7cc6464244c820172f9da4a" translate="yes" xml:space="preserve">
          <source>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</source>
          <target state="translated">对浮点数使用完全平等是个坏主意。四舍五入意味着直观的东西会失败。例如,这个测试就失败了。</target>
        </trans-unit>
        <trans-unit id="3dfac5af5bd078779708abe2d31733f55ae203b9" translate="yes" xml:space="preserve">
          <source>Using parcel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56e8185a2d6c77ca4726dcd2b55295a60bd2572" translate="yes" xml:space="preserve">
          <source>Using webpack</source>
          <target state="translated">使用webpack</target>
        </trans-unit>
        <trans-unit id="a5bf7b56e0fe9da5b66e110d7867887929aa794f" translate="yes" xml:space="preserve">
          <source>Using with DynamoDB</source>
          <target state="translated">与DynamoDB一起使用</target>
        </trans-unit>
        <trans-unit id="ad43d620306250954a4a631c111cb745bc0804de" translate="yes" xml:space="preserve">
          <source>Using with ES module imports</source>
          <target state="translated">使用ES模块导入</target>
        </trans-unit>
        <trans-unit id="44be8a58330b5c23182d2274fdfd6efbdf4e83a9" translate="yes" xml:space="preserve">
          <source>Using with MongoDB</source>
          <target state="translated">与MongoDB一起使用</target>
        </trans-unit>
        <trans-unit id="785e92a5d24055ece246e1162c6d740443f3f058" translate="yes" xml:space="preserve">
          <source>Using with npm scripts</source>
          <target state="translated">使用npm脚本</target>
        </trans-unit>
        <trans-unit id="094d8ae70af4304a0d4b4a837d18e1de8f8424c0" translate="yes" xml:space="preserve">
          <source>Using with puppeteer</source>
          <target state="translated">与木偶人一起使用</target>
        </trans-unit>
        <trans-unit id="62915756095c500af390187568578de70abf9244" translate="yes" xml:space="preserve">
          <source>Using with webpack</source>
          <target state="translated">与webpack一起使用</target>
        </trans-unit>
        <trans-unit id="2f6a259c826a5d9735d5a64063f1b31e207c2685" translate="yes" xml:space="preserve">
          <source>Using with webpack 2</source>
          <target state="translated">与webpack 2一起使用</target>
        </trans-unit>
        <trans-unit id="e92e8a4901b69fac997e23f82569d015987ccae6" translate="yes" xml:space="preserve">
          <source>Using with yarn</source>
          <target state="translated">使用纱线</target>
        </trans-unit>
        <trans-unit id="41c1155f49d57702ee239db81113c543bd9591e4" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't check code using &lt;code&gt;test.only&lt;/code&gt; into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</source>
          <target state="translated">通常，您不会在源代码控制中使用 &lt;code&gt;test.only&lt;/code&gt; 来检查代码，而是将其用于调试，并在修复损坏的测试后将其删除。</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="4af321d3223afd7ac8763fbd38707f1b871aa01e" translate="yes" xml:space="preserve">
          <source>Warning: If we want to mock Node's core modules (e.g.: &lt;code&gt;fs&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;), then explicitly calling e.g. &lt;code&gt;jest.mock('path')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;, because core Node modules are not mocked by default.</source>
          <target state="translated">警告：如果我们想嘲笑节点的核心模块（如： &lt;code&gt;fs&lt;/code&gt; 或 &lt;code&gt;path&lt;/code&gt; ），则显式调用如 &lt;code&gt;jest.mock('path')&lt;/code&gt; 是&lt;strong&gt;必需的&lt;/strong&gt;，因为核心节点模块默认情况下不嘲笑。</target>
        </trans-unit>
        <trans-unit id="d0993b420d1ece1c116d94df1eb882929103aacb" translate="yes" xml:space="preserve">
          <source>Watch Menu Integration</source>
          <target state="translated">观察菜单集成</target>
        </trans-unit>
        <trans-unit id="77162c2c5b3f4537b5a429cc13193176c9944f13" translate="yes" xml:space="preserve">
          <source>Watch Plugin Interface</source>
          <target state="translated">观看插件界面</target>
        </trans-unit>
        <trans-unit id="730cb1589addfecd42b5dc91914d54090940dd7b" translate="yes" xml:space="preserve">
          <source>Watch Plugins</source>
          <target state="translated">观看插件</target>
        </trans-unit>
        <trans-unit id="1b41755710b08ba989fe2719763a7cc16cd093cd" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the &lt;code&gt;--watch&lt;/code&gt; option.</source>
          <target state="translated">监视文件中的更改，并在发生更改时重新运行所有测试。如果只想重新运行依赖于已更改文件的测试，请使用 &lt;code&gt;--watch&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="0f500e5f9a091c5d91b9402809c2e1bfb82401f3" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the &lt;code&gt;--watchAll&lt;/code&gt; option instead.</source>
          <target state="translated">监视文件是否有更改，并重新运行与更改的文件相关的测试。如果要在文件更改后重新运行所有测试，请改用 &lt;code&gt;--watchAll&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6a33b701f8666961875a562f2fa71a7405de7c06" translate="yes" xml:space="preserve">
          <source>Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.</source>
          <target state="translated">观察模式还可以指定一个文件的名称或路径,以关注一组特定的测试。</target>
        </trans-unit>
        <trans-unit id="acd93772ed153d854aedd488090f5c82e983b44d" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;code&gt;q&lt;/code&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff9902a15b762dc90c7266ccddd98d2b3f64e24" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;q&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.&lt;/q&gt;</source>
          <target state="translated">监视插件YourFaultyPlugin尝试注册key &lt;q&gt;，该&lt;/q&gt;密钥&lt;q&gt;在内部保留用于退出监视模式。请更改此插件的配置密钥。&lt;/q&gt;</target>
        </trans-unit>
        <trans-unit id="a673577265e6ead99e3c23f76e5f29409c5b7d10" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key</source>
          <target state="translated">Watch插件YourFaultyPlugin和TheirFaultyPlugin都试图注册密钥。</target>
        </trans-unit>
        <trans-unit id="570ca6efbd4ac29fbe2679f4f54ef1e9c4dfefbc" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key &lt;code&gt;x&lt;/code&gt;. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a8e0b7b820fac76887499e0730014073b6942fc" translate="yes" xml:space="preserve">
          <source>Watchman Issues</source>
          <target state="translated">守望者问题</target>
        </trans-unit>
        <trans-unit id="58ed43a0f07990c616800d6e405003e52deb7101" translate="yes" xml:space="preserve">
          <source>We are mocking &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; so that our test doesn't make a real network request but instead resolves to mock data locally. This ensures that our test can complete in milliseconds rather than seconds and guarantees a fast unit test iteration speed.</source>
          <target state="translated">我们正在 &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; 以便我们的测试不会发出真正的网络请求，而是解析为在本地模拟数据。这样可以确保我们的测试可以在几毫秒而不是几秒钟内完成，并确保快速的单元测试迭代速度。</target>
        </trans-unit>
        <trans-unit id="39fcaf5408d64ca526faacb5d58f9141c191b735" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;jest.mock('../request')&lt;/code&gt; to tell Jest to use our manual mock. &lt;code&gt;it&lt;/code&gt; expects the return value to be a Promise that is going to be resolved. You can chain as many Promises as you like and call &lt;code&gt;expect&lt;/code&gt; at any time, as long as you return a Promise at the end.</source>
          <target state="translated">我们调用 &lt;code&gt;jest.mock('../request')&lt;/code&gt; 告诉Jest使用我们的手动模拟。 &lt;code&gt;it&lt;/code&gt; 期望返回值是一个将要解决的Promise。您可以随意链接任意数量的Promises，并在任何时候致电 &lt;code&gt;expect&lt;/code&gt; ，只要您最后返回Promise。</target>
        </trans-unit>
        <trans-unit id="69b678bb69e79c49e5b0a08e85e9a17993259892" translate="yes" xml:space="preserve">
          <source>We could test this error gets thrown in several ways:</source>
          <target state="translated">我们可以通过几种方式来测试这个错误的抛出。</target>
        </trans-unit>
        <trans-unit id="0bd52959384de0efc9e324b40ef0a059ef8e64cd" translate="yes" xml:space="preserve">
          <source>We have to specify the &lt;code&gt;__esModule: true&lt;/code&gt; property (see the &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; API for more information).</source>
          <target state="translated">我们必须指定 &lt;code&gt;__esModule: true&lt;/code&gt; 属性（有关更多信息，请参见&lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; API）。</target>
        </trans-unit>
        <trans-unit id="58e30d514b365fc2673e994c86e9d1067f92cb36" translate="yes" xml:space="preserve">
          <source>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving &quot;ts&quot; and/or &quot;tsx&quot; to the beginning of the array.</source>
          <target state="translated">我们建议将项目中最常用的扩展名放在左边,所以如果你使用TypeScript,你可以考虑将 &quot;ts &quot;和/或 &quot;tsx &quot;移到数组的开头。</target>
        </trans-unit>
        <trans-unit id="49cfe85b5d9f91e87c2bb6c4919d6422b42d36a2" translate="yes" xml:space="preserve">
          <source>We'll use a contrived example of a class that plays sound files, &lt;code&gt;SoundPlayer&lt;/code&gt;, and a consumer class which uses that class, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;. We'll mock &lt;code&gt;SoundPlayer&lt;/code&gt; in our tests for &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;.</source>
          <target state="translated">我们将使用一个 &lt;code&gt;SoundPlayer&lt;/code&gt; 示例，该示例播放声音文件的类SoundPlayer和使用该类的消费者类 &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; 。我们会嘲笑 &lt;code&gt;SoundPlayer&lt;/code&gt; 在我们的测试中 &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a570bfe57d90629aa64647c14bb9b9299f88f21" translate="yes" xml:space="preserve">
          <source>We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.</source>
          <target state="translated">我们告诉Jest忽略与样式表或图片扩展名相匹配的文件,而要求我们的mock文件。你可以调整正则表达式来匹配你的webpack配置所处理的文件类型。</target>
        </trans-unit>
        <trans-unit id="6e27e07bef6adeae0276f0cd001319eb48d71a2c" translate="yes" xml:space="preserve">
          <source>What is the performance of snapshot testing regarding speed and size of the generated files?</source>
          <target state="translated">快照测试关于生成文件的速度和大小的表现如何?</target>
        </trans-unit>
        <trans-unit id="3bc8902ad3e552d6e229d9ad2fb118f5b3735490" translate="yes" xml:space="preserve">
          <source>What's the difference between snapshot testing and visual regression testing?</source>
          <target state="translated">快照测试和可视化回归测试有什么区别?</target>
        </trans-unit>
        <trans-unit id="18c42c157f8a61af5c55926418fd204e7a9c5be1" translate="yes" xml:space="preserve">
          <source>When Jest runs your test to collect the &lt;code&gt;test&lt;/code&gt;s it will not find any because we have set the definition to happen asynchronously on the next tick of the event loop.</source>
          <target state="translated">当Jest运行测试以收集 &lt;code&gt;test&lt;/code&gt; ，将找不到任何内容，因为我们已将定义设置为在事件循环的下一个周期异步发生。</target>
        </trans-unit>
        <trans-unit id="66a712f9c4762f8fb45d196c8b569be5ba0595bc" translate="yes" xml:space="preserve">
          <source>When a conflict happens</source>
          <target state="translated">当冲突发生时</target>
        </trans-unit>
        <trans-unit id="6ddcfa27c2af8b12d25959aeb81f42c8a1e31340" translate="yes" xml:space="preserve">
          <source>When a manual mock exists for a given module, Jest's module system will use that module when explicitly calling &lt;code&gt;jest.mock('moduleName')&lt;/code&gt;. However, when &lt;code&gt;automock&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the manual mock implementation will be used instead of the automatically created mock, even if &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; is not called. To opt out of this behavior you will need to explicitly call &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; in tests that should use the actual module implementation.</source>
          <target state="translated">当给定模块存在手动模拟时，Jest的模块系统将在显式调用 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 时使用该模块。但是，当 &lt;code&gt;automock&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，即使未调用 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; ，也会使用手动模拟实现而不是自动创建的模拟。要退出此行为，您将需要在应该使用实际模块实现的测试中显式调用 &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f71f327fabbf5c0637780926759d884ef99d4c6f" translate="yes" xml:space="preserve">
          <source>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience.</source>
          <target state="translated">当一个断言失败时,错误消息应该给用户尽可能多的信号,以便他们能够快速解决他们的问题。你应该制作一个精确的失败消息,以确保你的自定义断言的用户有一个良好的开发者体验。</target>
        </trans-unit>
        <trans-unit id="92e3cf49c2e3a6035ec045cc54417bfd2ccb1023" translate="yes" xml:space="preserve">
          <source>When mocking time, &lt;code&gt;Date.now()&lt;/code&gt; will also be mocked. If you for some reason need access to the real current time, you can invoke this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8bace675f1044daa5589643fe0fa171a34a422" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;projects&lt;/code&gt; configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</source>
          <target state="translated">当为 &lt;code&gt;projects&lt;/code&gt; 配置提供一系列路径或全局模式时，Jest将在所有指定项目中同时运行测试。这对于monorepos或同时处理多个项目非常有用。</target>
        </trans-unit>
        <trans-unit id="000d78fbd56ae8d851f29ec24ab5707f75357361" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with &lt;code&gt;mockImplementationOnce&lt;/code&gt;, it will execute the default implementation set with &lt;code&gt;jest.fn&lt;/code&gt; (if it is defined):</source>
          <target state="translated">当 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 函数用完了用嘲笑ImplementationOnce定义的实现时，它将执行用 &lt;code&gt;jest.fn&lt;/code&gt; 设置的默认实现（如果已定义）：</target>
        </trans-unit>
        <trans-unit id="af9f009231011568611cfa6e9ad01b0075f8a8f9" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; or &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; if they were called:</source>
          <target state="translated">当模拟函数用完了用嘲笑ImplementationOnce定义的实现时，它将调用 &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; 或 &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; 来调用默认实现集：</target>
        </trans-unit>
        <trans-unit id="efd67d9a5d58ddfafd6576c76e2d2b45c6a9f072" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.</source>
          <target state="translated">当这个API被调用时,所有悬而未决的宏任务和微任务将被执行。如果这些任务本身安排了新的任务,那么这些任务将不断被耗尽,直到队列中没有更多的任务剩余。</target>
        </trans-unit>
        <trans-unit id="a158c79d89cb2f08512d4bfd3dd789cc435d27dc" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending micro-tasks that have been queued via &lt;code&gt;process.nextTick&lt;/code&gt; will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.</source>
          <target state="translated">调用此API时，将执行已通过 &lt;code&gt;process.nextTick&lt;/code&gt; 排队的所有暂挂微任务。此外，如果这些微任务本身计划了新的微任务，则这些微任务将不断耗尽，直到队列中没有更多的微任务为止。</target>
        </trans-unit>
        <trans-unit id="de6b8c35376469c436481e4abc3ac0840d106da8" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="translated">调用此API时，所有计时器都会提前 &lt;code&gt;msToRun&lt;/code&gt; 毫秒。已通过 &lt;code&gt;setTimeout()&lt;/code&gt; 或 &lt;code&gt;setInterval()&lt;/code&gt; 排队的所有待处理的&amp;ldquo;宏任务&amp;rdquo;，将在此时间范围内执行。此外，如果这些宏任务安排了将在同一时间范围内执行的新宏任务，则将执行这些宏任务，直到队列中没有剩余的宏任务为止，这些宏任务应在 &lt;code&gt;msToRun&lt;/code&gt; 毫秒内运行。</target>
        </trans-unit>
        <trans-unit id="6a3d81ee3b01c0089e78905262e5dca231d9597b" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dca7721cf62aeb16db42f482a108cce06f06d2" translate="yes" xml:space="preserve">
          <source>When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with &lt;code&gt;--updateSnapshot&lt;/code&gt;.</source>
          <target state="translated">提供此选项后，Jest将假定它在CI环境中运行。遇到新快照时，这会更改行为。它不会通过自动存储新快照的常规行为，而是会使测试失败并要求Jest与 &lt;code&gt;--updateSnapshot&lt;/code&gt; 一起运行。</target>
        </trans-unit>
        <trans-unit id="ea2ae246f66a28582d68b56f98e9832a105b042f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;mock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">使用 &lt;code&gt;babel-jest&lt;/code&gt; 时，对 &lt;code&gt;mock&lt;/code&gt; 调用将自动提升到代码块的顶部。如果要明确避免此行为，请使用此方法。</target>
        </trans-unit>
        <trans-unit id="18b0443351a14618ca1bcb5f6aa3542dc98f4cfe" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;unmock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">使用 &lt;code&gt;babel-jest&lt;/code&gt; 时，对 &lt;code&gt;unmock&lt;/code&gt; 的调用将自动提升到代码块的顶部。如果要明确避免此行为，请使用此方法。</target>
        </trans-unit>
        <trans-unit id="f978d44fe3f641d915d3d23a0599b90ede804e61" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--config&lt;/code&gt; option, the JSON file must not contain a &quot;jest&quot; key:</source>
          <target state="translated">使用 &lt;code&gt;--config&lt;/code&gt; 选项时，JSON文件中不得包含&amp;ldquo;笑话&amp;rdquo;键：</target>
        </trans-unit>
        <trans-unit id="04fedd264e30315e94d0bfc357d0d1a8b0ecd6f0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;factory&lt;/code&gt; parameter for an ES6 module with a default export, the &lt;code&gt;__esModule: true&lt;/code&gt; property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named &lt;code&gt;default&lt;/code&gt; from the export object:</source>
          <target state="translated">将 &lt;code&gt;factory&lt;/code&gt; 参数用于具有默认导出功能的ES6模块时，需要指定 &lt;code&gt;__esModule: true&lt;/code&gt; 属性。该属性通常由Babel / TypeScript生成，但是在此需要手动设置。导入默认导出时，这是从导出对象导入名为 &lt;code&gt;default&lt;/code&gt; 的属性的指令：</target>
        </trans-unit>
        <trans-unit id="2d001438addabfdc9a62c0bd086018e034d25a28" translate="yes" xml:space="preserve">
          <source>When we require that module in our tests, explicitly calling &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;.</source>
          <target state="translated">当我们需要在我们的测试，模块，显式调用 &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; 是&lt;strong&gt;必需的&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="703ab40aa1656fee5bd7fb985cc5ca7e7af24578" translate="yes" xml:space="preserve">
          <source>When you are debugging a large test file, you will often only want to run a subset of tests. You can use &lt;code&gt;.only&lt;/code&gt; to specify which tests are the only ones you want to run in that test file.</source>
          <target state="translated">在调试大型测试文件时，通常只需要运行一部分测试。您可以使用 &lt;code&gt;.only&lt;/code&gt; 来指定哪些测试是您要在该测试文件中运行的唯一测试。</target>
        </trans-unit>
        <trans-unit id="7d76e8040b92fed0c690e41513159f4832164a34" translate="yes" xml:space="preserve">
          <source>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use &lt;code&gt;test.skip&lt;/code&gt; to specify some tests to skip.</source>
          <target state="translated">当您维护大型代码库时，有时可能会发现由于某种原因而暂时中断的测试。如果要跳过运行此测试，但又不想删除此代码，则可以使用 &lt;code&gt;test.skip&lt;/code&gt; 指定一些要跳过的测试。</target>
        </trans-unit>
        <trans-unit id="8d417a3cdc1c802c0f3ae5fcb03331fd9db749a0" translate="yes" xml:space="preserve">
          <source>When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method:</source>
          <target state="translated">当您需要重新创建模拟函数的复杂行为以使多个函数调用产生不同的结果时，请使用 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="0933ea7e8d1f77a530a24c9128f18fb45e5eb8fc" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;jest&lt;/code&gt; with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt;. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">当您使用参数运行 &lt;code&gt;jest&lt;/code&gt; 时，该参数将被视为正则表达式以与项目中的文件匹配。通过提供模式可以运行测试套件。将仅拾取并执行与模式匹配的文件。根据您的终端，您可能需要引用以下参数： &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt; 。在Windows上，您将需要使用 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符或将 &lt;code&gt;\&lt;/code&gt; 用作 &lt;code&gt;\\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68715485bd1666aefca572f144099e2aa37bff4b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;jest&lt;/code&gt;, this will produce an output file like this:</source>
          <target state="translated">当您运行 &lt;code&gt;yarn test&lt;/code&gt; 或 &lt;code&gt;jest&lt;/code&gt; 时，将产生如下输出文件：</target>
        </trans-unit>
        <trans-unit id="a48c34ee84029428f3840a2f252c786c6d129c3b" translate="yes" xml:space="preserve">
          <source>When you're writing tests, you often need to check that values meet certain conditions. &lt;code&gt;expect&lt;/code&gt; gives you access to a number of &quot;matchers&quot; that let you validate different things.</source>
          <target state="translated">在编写测试时，通常需要检查值是否符合某些条件。 &lt;code&gt;expect&lt;/code&gt; 使您可以访问许多&amp;ldquo;匹配器&amp;rdquo;，以使您可以验证不同的内容。</target>
        </trans-unit>
        <trans-unit id="1895f1fdbdf511f9d8c3b27d739559dc512e7472" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6727f0146af0d44b58e9f9d090e4a61fff19955d" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling. Defaults to &lt;code&gt;true&lt;/code&gt;. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35131e0d0e9059a4bd01bbcebb7af6e82ca76302" translate="yes" xml:space="preserve">
          <source>Whether to use the cache. Defaults to true. Disable the cache using &lt;code&gt;--no-cache&lt;/code&gt;. &lt;em&gt;Note: the cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.&lt;/em&gt;</source>
          <target state="translated">是否使用缓存。默认为true。使用 &lt;code&gt;--no-cache&lt;/code&gt; 禁用缓存。&lt;em&gt;注意：只有在遇到与缓存有关的问题时，才应禁用缓存。平均而言，禁用缓存会使Jest至少慢两倍。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83164f909bcd8fc7ba78df4e824b24177b294067" translate="yes" xml:space="preserve">
          <source>Whether to use watchman for file crawling. Defaults to true. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="translated">是否使用监视程序进行文件爬网。默认为true。使用 &lt;code&gt;--no-watchman&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="a1d2275b123b75427db7b2987318a2d50b013b7a" translate="yes" xml:space="preserve">
          <source>While Jest is most of the time extremely fast on modern multi-core computers with fast SSDs, it may be slow on certain setups as our users &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;have&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;discovered&lt;/a&gt;.</source>
          <target state="translated">虽然玩笑是大部分时间非常快的现代多核计算机具有快速的固态硬盘，它可能是缓慢的某些设置为我们的用户&lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;已经&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;发现了&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c1e359c575a75195c82ced579ca21229a1a43b9" translate="yes" xml:space="preserve">
          <source>While we generally recommend using the same version of every Jest package, this workaround will allow you to continue using the latest version of Jest with Babel 6 for now.</source>
          <target state="translated">虽然我们通常建议使用每个 Jest 软件包的相同版本,但这个变通方法将允许您继续使用最新版本的 Jest 与 Babel 6。</target>
        </trans-unit>
        <trans-unit id="0ab9c7998614f26e4eb6805b1167e05ce5311b6e" translate="yes" xml:space="preserve">
          <source>Will result in this error:</source>
          <target state="translated">将导致这个错误。</target>
        </trans-unit>
        <trans-unit id="5924ea10aaabb62ee9bc1364ab2d6c8d39fa4316" translate="yes" xml:space="preserve">
          <source>With all the things set up, we can now write our tests like this:</source>
          <target state="translated">有了所有的设置,我们现在可以这样写我们的测试。</target>
        </trans-unit>
        <trans-unit id="f75c7b6834fbac10e18f4c82ab03776229eb74e2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;.</source>
          <target state="translated">借助&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt;和&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; API，Jest可以与&lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;顺利配合使用。</target>
        </trans-unit>
        <trans-unit id="09d67fc0b64d61790fbe51d618d9c01a71c9767f" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;.</source>
          <target state="translated">借助&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt;和&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; API，Jest可以与&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;配合使用。</target>
        </trans-unit>
        <trans-unit id="efe0a1fdb2d38cad4bc73937febc9018ab5dfa08" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;.</source>
          <target state="translated">借助&lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup / Teardown&lt;/a&gt;和&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; API，Jest可以与&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;一起顺利使用。</target>
        </trans-unit>
        <trans-unit id="65847eb738fbe06a57caae0a366f5485491b7ed4" translate="yes" xml:space="preserve">
          <source>With the warnings out of the way, this is how you activate ESM support in your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a7d359c8bb23694d685fdf6e2b5cde46a49ff3" translate="yes" xml:space="preserve">
          <source>Write test results to a file when the &lt;code&gt;--json&lt;/code&gt; option is also specified. The returned JSON structure is documented in &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor&lt;/a&gt;.</source>
          <target state="translated">当还指定了 &lt;code&gt;--json&lt;/code&gt; 选项时，将测试结果写入文件。返回的JSON结构记录在&lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">编写测试</target>
        </trans-unit>
        <trans-unit id="694bf05e5891dd2e709b08f7b1d50372246946ee" translate="yes" xml:space="preserve">
          <source>Write your test</source>
          <target state="translated">写下你的测试</target>
        </trans-unit>
        <trans-unit id="94ba98a24cca1fad5979f2e2b8b87aa24d441f8b" translate="yes" xml:space="preserve">
          <source>Writing tests using the &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; syntax is also possible. Here is how you'd write the same examples from before:</source>
          <target state="translated">也可以使用 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 语法编写测试。这是您之前编写相同示例的方式：</target>
        </trans-unit>
        <trans-unit id="13442293f45d32c9c4218756254e61b25c456f59" translate="yes" xml:space="preserve">
          <source>Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</source>
          <target state="translated">是的,所有的快照文件应该和它们所覆盖的模块及其测试一起提交。它们应该被视为测试的一部分,类似于Jest中任何其他断言的价值。事实上,快照代表了源模块在任何给定时间点的状态。这样一来,当源模块被修改时,Jest就可以知道与之前的版本相比有什么变化。它还可以在代码审查时提供很多额外的上下文,审查人员可以更好地研究你的修改。</target>
        </trans-unit>
        <trans-unit id="5059d1df734052fa39f05d1a230ebef9c450fdf6" translate="yes" xml:space="preserve">
          <source>Yes, as well as with any other test.</source>
          <target state="translated">是的,和其他任何测试一样。</target>
        </trans-unit>
        <trans-unit id="933a2cbd693a2fc8e1c7cc9d0a79a6433195d072" translate="yes" xml:space="preserve">
          <source>You avoid limits to configuration that might cause you to eject from &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;.</source>
          <target state="translated">您避免了可能导致您从&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;弹出的配置限制。</target>
        </trans-unit>
        <trans-unit id="406cbbf63f4fe22d5b8ccaa5240411c1502ac6c2" translate="yes" xml:space="preserve">
          <source>You can also hook up puppeteer from scratch. The basic idea is to:</source>
          <target state="translated">你也可以从头开始勾搭木偶人。基本思路是:。</target>
        </trans-unit>
        <trans-unit id="35aff70317c576091536adc5e1a43d87f6a53f1b" translate="yes" xml:space="preserve">
          <source>You can also nest &lt;code&gt;describe&lt;/code&gt; blocks if you have a hierarchy of tests:</source>
          <target state="translated">如果您具有测试层次结构，则还可以嵌套 &lt;code&gt;describe&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="ecbf1217eb1b7413e5ac5532b9f18df62cd10cea" translate="yes" xml:space="preserve">
          <source>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the &lt;code&gt;toMatchObject&lt;/code&gt; sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to &lt;code&gt;arrayContaining&lt;/code&gt;, which allows for extra elements in the received array.</source>
          <target state="translated">您还可以传递对象数组，在这种情况下，仅当接收到的数组中的每个对象与预期数组中的对应对象匹配（在上述 &lt;code&gt;toMatchObject&lt;/code&gt; 意义上）时，该方法才返回true 。如果要检查两个数组的元素数量是否匹配，这 &lt;code&gt;arrayContaining&lt;/code&gt; ，这与arrayContaining相反，后者允许接收的数组中有其他元素。</target>
        </trans-unit>
        <trans-unit id="33e631cdb46e5194143ae6343251d5d4abeebe0e" translate="yes" xml:space="preserve">
          <source>You can also test for the opposite of a matcher:</source>
          <target state="translated">你也可以测试匹配器的反面。</target>
        </trans-unit>
        <trans-unit id="766ae758010f2b190e41fbbc693bc28b84e8247c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;.resolves&lt;/code&gt; matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">您还可以在 &lt;code&gt;.resolves&lt;/code&gt; 语句中使用.resolves匹配器，Jest将等待该诺言得以解决。如果承诺被拒绝，则测试将自动失败。</target>
        </trans-unit>
        <trans-unit id="c23acb6b8a75eb059d0bf1a92f11f8a674f5b5ac" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; to add a module that formats application-specific data structures.</source>
          <target state="translated">您可以调用 &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; 来添加格式化特定于应用程序的数据结构的模块。</target>
        </trans-unit>
        <trans-unit id="b0148d2ae9957ac3475428862737e46004f4bc04" translate="yes" xml:space="preserve">
          <source>You can check if an array or iterable contains a particular item using &lt;code&gt;toContain&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;toContain&lt;/code&gt; 检查数组或可迭代项是否包含特定项：</target>
        </trans-unit>
        <trans-unit id="2d51d93712488643fb65c1c14ffe4c74aaa71d14" translate="yes" xml:space="preserve">
          <source>You can check strings against regular expressions with &lt;code&gt;toMatch&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;toMatch&lt;/code&gt; 根据正则表达式检查字符串：</target>
        </trans-unit>
        <trans-unit id="e25edb586f40e9238795e2ba9b6c0d4c65291a8a" translate="yes" xml:space="preserve">
          <source>You can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:</source>
          <target state="translated">您可以挑选 Jest 的特定功能,并将其作为独立的软件包使用。以下是可用包的列表。</target>
        </trans-unit>
        <trans-unit id="42fd15afca8b3c0e27f3602b1bb8b499e91c1c6b" translate="yes" xml:space="preserve">
          <source>You can collect coverage from those files with setting &lt;code&gt;forceCoverageMatch&lt;/code&gt;.</source>
          <target state="translated">您可以通过设置 &lt;code&gt;forceCoverageMatch&lt;/code&gt; 从这些文件收集覆盖率。</target>
        </trans-unit>
        <trans-unit id="0087ca484c125dc235349950ec51d13f3336f610" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;.resolves&lt;/code&gt; or &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">您可以将 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 与 &lt;code&gt;.resolves&lt;/code&gt; 或 &lt;code&gt;.rejects&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="d20f2b42e97c65aaef925a2c6a3961d0c033857b" translate="yes" xml:space="preserve">
          <source>You can create your own module that will be used for setting up the test environment. The module must export a class with &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt; and &lt;code&gt;runScript&lt;/code&gt; methods. You can also pass variables from this module to your test suites by assigning them to &lt;code&gt;this.global&lt;/code&gt; object &amp;ndash; this will make them available in your test suites as global variables.</source>
          <target state="translated">您可以创建自己的模块，该模块将用于设置测试环境。该模块必须使用 &lt;code&gt;setup&lt;/code&gt; ， &lt;code&gt;teardown&lt;/code&gt; 和 &lt;code&gt;runScript&lt;/code&gt; 方法导出一个类。您还可以通过将变量分配给 &lt;code&gt;this.global&lt;/code&gt; 对象，将变量从该模块传递到测试套件&amp;ndash;这将使它们在测试套件中作为全局变量可用。</target>
        </trans-unit>
        <trans-unit id="1ef2f94dd57c5898c7b5cdef5978ab020627b6d9" translate="yes" xml:space="preserve">
          <source>You can match properties against values or against matchers.</source>
          <target state="translated">您可以将属性与值或匹配器进行匹配。</target>
        </trans-unit>
        <trans-unit id="f8d7a47b61e8074001017d01760195a44daa7d92" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="translated">您可以选择为您的模拟函数提供一个名称,它将代替 &quot;jest.fn()&quot;显示在测试错误输出中。如果您想在测试输出中快速识别报告错误的模拟函数,请使用这个名称。</target>
        </trans-unit>
        <trans-unit id="62ba1633de645d2b4f3bdc636d51dbe0464a51e7" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in the test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141547ac2059520c584383a103038c5f0023150f" translate="yes" xml:space="preserve">
          <source>You can pass configuration to a transformer like &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; For example, to configure babel-jest for non-default behavior, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</source>
          <target state="translated">您可以将配置传递到 &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; 例如，将babel-jest配置为非默认行为， &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="800cb883045942cfd5bb4081f8af395b4c78910d" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;hint&lt;/code&gt; string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate &lt;strong&gt;multiple&lt;/strong&gt; snapshots in a &lt;strong&gt;single&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; block. Jest sorts snapshots by name in the corresponding &lt;code&gt;.snap&lt;/code&gt; file.</source>
          <target state="translated">您可以提供一个可选的 &lt;code&gt;hint&lt;/code&gt; 字符串参数，该参数附加在测试名称之后。虽然玩笑总是附加一个数在快照名称的末尾，不是数字来区分简短的描述暗示可能更为有用&lt;strong&gt;多个&lt;/strong&gt;在一个快照&lt;strong&gt;单个&lt;/strong&gt; &lt;code&gt;it&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 块。 Jest在相应的 &lt;code&gt;.snap&lt;/code&gt; 文件中按名称对快照进行排序。</target>
        </trans-unit>
        <trans-unit id="4cc4d175319a45a401106b9809e576146487b0b9" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;propertyMatchers&lt;/code&gt; object argument, which has asymmetric matchers as values of a subset of expected properties, &lt;strong&gt;if&lt;/strong&gt; the received value will be an &lt;strong&gt;object&lt;/strong&gt; instance. It is like &lt;code&gt;toMatchObject&lt;/code&gt; with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</source>
          <target state="translated">您可以提供一个可选的 &lt;code&gt;propertyMatchers&lt;/code&gt; 对象参数，&lt;strong&gt;如果&lt;/strong&gt;接收的值将是一个&lt;strong&gt;对象&lt;/strong&gt;实例，&lt;strong&gt;则&lt;/strong&gt;该参数具有不对称匹配器作为期望属性子集的值。就像 &lt;code&gt;toMatchObject&lt;/code&gt; 一样，为子集的属性设置了灵活的条件，随后是快照测试，作为其余属性的精确条件。</target>
        </trans-unit>
        <trans-unit id="342a9b14684325992d5ff139401436ae7682dd1a" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;value&lt;/code&gt; argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the &lt;code&gt;toEqual&lt;/code&gt; matcher).</source>
          <target state="translated">您可以提供一个可选的 &lt;code&gt;value&lt;/code&gt; 参数来比较接收到的属性值（递归地用于对象实例的所有属性，也称为深度相等，例如 &lt;code&gt;toEqual&lt;/code&gt; 匹配器）。</target>
        </trans-unit>
        <trans-unit id="ecc5cea913bac7656555fb5571fc70b6c18f354b" translate="yes" xml:space="preserve">
          <source>You can provide an optional argument to test that a specific error is thrown:</source>
          <target state="translated">你可以提供一个可选的参数来测试是否会抛出一个特定的错误。</target>
        </trans-unit>
        <trans-unit id="c0387678f500b8dabacd6ece5ed81ebc2dad87e6" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-changed-files&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;自述文件中&lt;/a&gt;了解有关 &lt;code&gt;jest-changed-files&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="a117882f05bee0eb2692567e191ce66d663578e1" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-docblock&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;自述文件中&lt;/a&gt;了解有关 &lt;code&gt;jest-docblock&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="46c165debafb7322f712fc6e454196637356e378" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-validate&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;自述文件中&lt;/a&gt;了解有关 &lt;code&gt;jest-validate&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="2867c6d937c4005f8963139f59e55ad836a6852b" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-worker&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;自述文件中&lt;/a&gt;了解有关 &lt;code&gt;jest-worker&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="d429e36c0ed20b800a39f032d046273b4cea53be" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;pretty-format&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;自述文件中&lt;/a&gt;了解有关 &lt;code&gt;pretty-format&lt;/code&gt; 的更多信息。</target>
        </trans-unit>
        <trans-unit id="f91698c99b451b48fdef94d8133ba660ee4beb14" translate="yes" xml:space="preserve">
          <source>You can replace all of the above mocks in order to change the implementation, for a single test or all tests, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; on the existing mock.</source>
          <target state="translated">您可以替换现有的所有模拟，以更改单个测试或所有测试的实现，方法是在现有模拟上调用 &lt;code&gt;mockImplementation()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563bf00a2d98bb36c45fffa7a2f6aab090a1748e" translate="yes" xml:space="preserve">
          <source>You can retrieve Jest's default options to expand them if needed:</source>
          <target state="translated">如果需要的话,您可以检索Jest的默认选项来扩展它们。</target>
        </trans-unit>
        <trans-unit id="31bd27fefd08851ca3968f0ceda8045022a66264" translate="yes" xml:space="preserve">
          <source>You can run Jest directly from the CLI (if it's globally available in your &lt;code&gt;PATH&lt;/code&gt;, e.g. by &lt;code&gt;yarn global add jest&lt;/code&gt; or &lt;code&gt;npm install jest --global&lt;/code&gt;) with a variety of useful options.</source>
          <target state="translated">您可以使用多种有用的选项直接从CLI直接运行Jest（如果它在 &lt;code&gt;PATH&lt;/code&gt; 中是全局可用的，例如通过 &lt;code&gt;yarn global add jest&lt;/code&gt; 或 &lt;code&gt;npm install jest --global&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bef775ff4d1e2656f1b8b8b28d2f88eef6be39e0" translate="yes" xml:space="preserve">
          <source>You can see an example of using Jest with TypeScript in our &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/typescript&quot;&gt;GitHub repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f225c905306c2c0014f6ff2fdd68b6007152b521" translate="yes" xml:space="preserve">
          <source>You can try out this functionality by cloning the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;snapshot example&lt;/a&gt;, modifying the &lt;code&gt;Link&lt;/code&gt; component, and running Jest.</source>
          <target state="translated">您可以通过克隆&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;快照示例&lt;/a&gt;，修改 &lt;code&gt;Link&lt;/code&gt; 组件并运行Jest 来试用此功能。</target>
        </trans-unit>
        <trans-unit id="a5ed2e627ad2f097c8fe5c0666910c34f57925f1" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.only&lt;/code&gt; if you want to run only one describe block:</source>
          <target state="translated">仅当您只想运行一个describe块时才可以使用 &lt;code&gt;describe.only&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="221b7b5d130528a59256d65bc2c5c5ab8c11adbb" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.skip&lt;/code&gt; if you do not want to run a particular describe block:</source>
          <target state="translated">如果不想运行特定的describe块，可以使用 &lt;code&gt;describe.skip&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="29de8e17dc9a604ab72ee70bda29920afbd2d460" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;expect.extend&lt;/code&gt; to add your own matchers to Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher:</source>
          <target state="translated">您可以使用 &lt;code&gt;expect.extend&lt;/code&gt; 将自己的匹配器添加到Jest。例如，假设您正在测试数字实用程序库，并且经常断言数字出现在其他数字的特定范围内。您可以将其抽象为 &lt;code&gt;toBeWithinRange&lt;/code&gt; 匹配器：</target>
        </trans-unit>
        <trans-unit id="ce0b3ff83dde595fbf23f5b27e23e12d03a726e9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedClass&lt;/code&gt; to represent a class that has been replaced by a Jest mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883638c32cfdbaf6b10f47ce10c2b95fc3e1af40" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedFunction&lt;/code&gt; to represent a function that has been replaced by a Jest mock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414d019cf0872729a505b6b1f50111cb1ce5b29d" translate="yes" xml:space="preserve">
          <source>You can use an &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 Proxy&lt;/a&gt; to mock &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6代理&lt;/a&gt;来模拟&lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS模块&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e0ca37e74baa1f002bba25e20997f296e5781557" translate="yes" xml:space="preserve">
          <source>You can use it instead of a literal value:</source>
          <target state="translated">你可以用它来代替文字值。</target>
        </trans-unit>
        <trans-unit id="c085c131693a018bbc7ee86b6ff86c3192e859b0" translate="yes" xml:space="preserve">
          <source>You could comment the test out, but it's often a bit nicer to use &lt;code&gt;test.skip&lt;/code&gt; because it will maintain indentation and syntax highlighting.</source>
          <target state="translated">您可以将测试注释掉，但是使用 &lt;code&gt;test.skip&lt;/code&gt; 通常会更好一些，因为它将保留缩进和语法突出显示。</target>
        </trans-unit>
        <trans-unit id="5359ed25529846e45ba23e420d5b9e5c6713de18" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">您可以编写 &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt; ，但是最好避免在代码中直接引用 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ba59aa451c75435f919998f9ebfc1c5a8dd95b2" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">您可以编写 &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt; ，但是最好避免在代码中直接引用 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ed689c2ae9512a449e124212b726dc5d4e0c96" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; to use react-testing-library.</source>
          <target state="translated">您必须运行 &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; 才能使用react-testing-library。</target>
        </trans-unit>
        <trans-unit id="c2580df5ede4388981be8693d0eb04cda44e78ad" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; to use Enzyme. If you are using a React version below 15.5.0, you will also need to install &lt;code&gt;react-addons-test-utils&lt;/code&gt;.</source>
          <target state="translated">您必须运行 &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; 才能使用Enzyme。如果您使用的React版本低于15.5.0，则还需要安装 &lt;code&gt;react-addons-test-utils&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ab8163799282eb2cd2bcd483eb50ba23a2e1feb" translate="yes" xml:space="preserve">
          <source>You make the dependency explicit instead of implicit.</source>
          <target state="translated">你让依赖关系显式而不是隐式。</target>
        </trans-unit>
        <trans-unit id="08d47da002fb02d0ffc5edc25d616083fbc6a387" translate="yes" xml:space="preserve">
          <source>You may also want to install the &lt;a href=&quot;https://www.npmjs.com/package/@types/jest&quot;&gt;&lt;code&gt;@types/jest&lt;/code&gt;&lt;/a&gt; module for the version of Jest you're using. This will help provide full typing when writing your tests with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c38db17ba138256cbd5a96be8f1e6dc538f5fa8" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;getErrors&lt;/code&gt; returns, specifically - it might return &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt;, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</source>
          <target state="translated">您可能不在乎 &lt;code&gt;getErrors&lt;/code&gt; 返回的内容，特别是-它可能返回 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ，并且您的代码仍然可以正常工作。因此，如果您想测试一下喝La Croix后没有错误，可以这样写：</target>
        </trans-unit>
        <trans-unit id="c89edf49de3c63952efdcc592f2e40d0e91b763b" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;thirstInfo&lt;/code&gt; returns, specifically - it might return &lt;code&gt;true&lt;/code&gt; or a complex object, and your code would still work. So if you want to test that &lt;code&gt;thirstInfo&lt;/code&gt; will be truthy after drinking some La Croix, you could write:</source>
          <target state="translated">您可能不在乎 &lt;code&gt;thirstInfo&lt;/code&gt; 返回什么，特别是-它可能返回 &lt;code&gt;true&lt;/code&gt; 或复杂的对象，并且您的代码仍然可以工作。因此，如果您想在喝了La Croix后测试 &lt;code&gt;thirstInfo&lt;/code&gt; 是否真实，则可以这样写：</target>
        </trans-unit>
        <trans-unit id="17b4764286d414a473eaaf4d566a76ce25182294" translate="yes" xml:space="preserve">
          <source>You should use the matcher that most precisely corresponds to what you want your code to be doing.</source>
          <target state="translated">你应该使用最精确地对应于你的代码要做的事情的匹配器。</target>
        </trans-unit>
        <trans-unit id="7f37219870fbd51ab28f12639a113236e2ba5334" translate="yes" xml:space="preserve">
          <source>You will find a number of example test cases in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; folder on GitHub. You can also learn from the excellent tests used by the &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;, and &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; projects.</source>
          <target state="translated">您可以在GitHub上的&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt; &lt;code&gt;examples&lt;/code&gt; &lt;/a&gt;文件夹中找到许多示例测试用例。您还可以从&lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;，&lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;和&lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt;项目使用的出色测试中学习。</target>
        </trans-unit>
        <trans-unit id="d7eb67e376c7a0795313a9464135b5632741a836" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;package.json&lt;/code&gt; should look something like this (where &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; is the actual latest version number for the package). Please add the scripts and jest configuration entries:</source>
          <target state="translated">您的 &lt;code&gt;package.json&lt;/code&gt; 应该看起来像这样（其中 &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; 是该软件包的实际最新版本号）。请添加脚本和玩笑配置条目：</target>
        </trans-unit>
        <trans-unit id="ec89bd1c5f68c024aeca6e9e14636486318a74fe" translate="yes" xml:space="preserve">
          <source>Your test will want to mock the &lt;code&gt;fetch&lt;/code&gt; function so that we can be sure that it gets called without actually making the network request. However, you'll also need to mock the return value of &lt;code&gt;fetch&lt;/code&gt; with a &lt;code&gt;Response&lt;/code&gt; (wrapped in a &lt;code&gt;Promise&lt;/code&gt;), as our function uses it to grab the created user's ID. So you might initially try writing a test like this:</source>
          <target state="translated">您的测试将要模拟 &lt;code&gt;fetch&lt;/code&gt; 函数，以便我们可以确保在没有实际发出网络请求的情况下调用它。但是，您还需要使用 &lt;code&gt;Response&lt;/code&gt; （包装在 &lt;code&gt;Promise&lt;/code&gt; 中）来模拟 &lt;code&gt;fetch&lt;/code&gt; 的返回值，因为我们的函数使用它来获取创建的用户ID。因此，您最初可能会尝试编写如下测试：</target>
        </trans-unit>
        <trans-unit id="1175cedc7032117d3657edf28dbe7bb9385d7c5c" translate="yes" xml:space="preserve">
          <source>Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.</source>
          <target state="translated">你的测试应该是确定性的。在一个没有变化的组件上多次运行相同的测试,每次都应该产生相同的结果。你有责任确保你生成的快照不包含特定平台或其他非确定性数据。</target>
        </trans-unit>
        <trans-unit id="2f17fc980285f8ffe0be9e33ef7152af13254fe8" translate="yes" xml:space="preserve">
          <source>afterAll()</source>
          <target state="translated">afterAll()</target>
        </trans-unit>
        <trans-unit id="fb268a1811f730c2067165b083e360322d72f477" translate="yes" xml:space="preserve">
          <source>afterEach()</source>
          <target state="translated">afterEach()</target>
        </trans-unit>
        <trans-unit id="9ad6d2fa2c7de85e6b6dd37cd6a886c8f07ad319" translate="yes" xml:space="preserve">
          <source>async-to-gen</source>
          <target state="translated">async-to-gen</target>
        </trans-unit>
        <trans-unit id="bd90b357192cd27b16a70b7698bb14ee20cba402" translate="yes" xml:space="preserve">
          <source>awesome-jest</source>
          <target state="translated">awesome-jest</target>
        </trans-unit>
        <trans-unit id="d09b0fbfb51ee1470bcc585dd8ce8dfa55e488df" translate="yes" xml:space="preserve">
          <source>beforeAll()</source>
          <target state="translated">beforeAll()</target>
        </trans-unit>
        <trans-unit id="c70978f19975e8b38cf044b33e31fad2d272183a" translate="yes" xml:space="preserve">
          <source>beforeEach()</source>
          <target state="translated">beforeEach()</target>
        </trans-unit>
        <trans-unit id="740e438d6d95b968c3b9aaa798d54c124e64790b" translate="yes" xml:space="preserve">
          <source>close puppeteer with Global Teardown</source>
          <target state="translated">关闭木偶人与全球拆迁</target>
        </trans-unit>
        <trans-unit id="53cdcf56a867665dc933b593cb499286aadcbc80" translate="yes" xml:space="preserve">
          <source>connect to puppeteer from each Test Environment</source>
          <target state="translated">从每个测试环境连接到puppeteer</target>
        </trans-unit>
        <trans-unit id="25509aa65c3b573b5425ab6624df82134524f006" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8244e80092f3c12d77f6dd509da0f653409320b" translate="yes" xml:space="preserve">
          <source>describe()</source>
          <target state="translated">describe()</target>
        </trans-unit>
        <trans-unit id="398a5e26f7d6ff23078ffbb871957ca77291b3e7" translate="yes" xml:space="preserve">
          <source>describe.each()</source>
          <target state="translated">describe.each()</target>
        </trans-unit>
        <trans-unit id="4f24a48da5c59a6bd3845bdb54350e1d1d0ee38d" translate="yes" xml:space="preserve">
          <source>describe.only()</source>
          <target state="translated">describe.only()</target>
        </trans-unit>
        <trans-unit id="f11fce8c9ed55e7be7b2cbcc6e46f524b949f14e" translate="yes" xml:space="preserve">
          <source>describe.only.each()</source>
          <target state="translated">describe.only.each()</target>
        </trans-unit>
        <trans-unit id="c3382b09895d6af2c9e821d96ad003e58d4b96de" translate="yes" xml:space="preserve">
          <source>describe.skip()</source>
          <target state="translated">describe.skip()</target>
        </trans-unit>
        <trans-unit id="2c446c6cd1bf47770ef8c7d1bd166c465eedf771" translate="yes" xml:space="preserve">
          <source>describe.skip.each()</source>
          <target state="translated">describe.skip.each()</target>
        </trans-unit>
        <trans-unit id="fcf239e7993ef571d39b364c0de3fda8a3ae0c81" translate="yes" xml:space="preserve">
          <source>error class: error object is &lt;strong&gt;instance of&lt;/strong&gt; class</source>
          <target state="translated">错误类：错误对象是类的&lt;strong&gt;实例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7851c6709a8adac9e962eee4f13a4ff8d35c84c6" translate="yes" xml:space="preserve">
          <source>error object: error message is &lt;strong&gt;equal to&lt;/strong&gt; the message property of the object</source>
          <target state="translated">错误对象：错误消息&lt;strong&gt;等于&lt;/strong&gt;对象的message属性</target>
        </trans-unit>
        <trans-unit id="a00f641af4b4bd382b037a5599ec8c6bd2a58a7a" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jest</source>
          <target state="translated">eslint-plugin-jest</target>
        </trans-unit>
        <trans-unit id="3aede15b1d5d318f2bf628e79d06cd5ec821f235" translate="yes" xml:space="preserve">
          <source>expect()</source>
          <target state="translated">expect()</target>
        </trans-unit>
        <trans-unit id="c531f8f49210f5c5cc7e56c0bcf8809390d60182" translate="yes" xml:space="preserve">
          <source>expect.addSnapshotSerializer()</source>
          <target state="translated">expect.addSnapshotSerializer()</target>
        </trans-unit>
        <trans-unit id="73052babf147d5ab7087790cf489001a5fe6adef" translate="yes" xml:space="preserve">
          <source>expect.any()</source>
          <target state="translated">expect.any()</target>
        </trans-unit>
        <trans-unit id="041f3593b4cfc38ec52995cb888e8d017339e912" translate="yes" xml:space="preserve">
          <source>expect.anything()</source>
          <target state="translated">expect.anything()</target>
        </trans-unit>
        <trans-unit id="b1648f49219a878c2221460718595da8c398b8b3" translate="yes" xml:space="preserve">
          <source>expect.arrayContaining()</source>
          <target state="translated">expect.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="07105ad3d99570c6ffdfd4ccea4770093ccd6589" translate="yes" xml:space="preserve">
          <source>expect.assertions()</source>
          <target state="translated">expect.assertions()</target>
        </trans-unit>
        <trans-unit id="cf206af29db6d448d19d0b2896ed0f7be77ca4b2" translate="yes" xml:space="preserve">
          <source>expect.extend()</source>
          <target state="translated">expect.extend()</target>
        </trans-unit>
        <trans-unit id="bef0c4a5294c45e4f23630650c298423d2b0033a" translate="yes" xml:space="preserve">
          <source>expect.hasAssertions()</source>
          <target state="translated">expect.hasAssertions()</target>
        </trans-unit>
        <trans-unit id="a4b4f299cc5121ba5bb42d780d793dd0d208d5d1" translate="yes" xml:space="preserve">
          <source>expect.not.arrayContaining()</source>
          <target state="translated">expect.not.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="cd369cc867e384fabaa81e31b91e2ec5e06cb648" translate="yes" xml:space="preserve">
          <source>expect.not.objectContaining()</source>
          <target state="translated">expect.not.objectContaining()</target>
        </trans-unit>
        <trans-unit id="c3e51c2efa41f651e0f4da6911e099a7e6ae1ca4" translate="yes" xml:space="preserve">
          <source>expect.not.stringContaining()</source>
          <target state="translated">expect.not.stringContaining()</target>
        </trans-unit>
        <trans-unit id="1146b5bca92b76c491171096be15657da9f28d46" translate="yes" xml:space="preserve">
          <source>expect.not.stringMatching()</source>
          <target state="translated">expect.not.stringMatching()</target>
        </trans-unit>
        <trans-unit id="a323da51fabb3d791f0b36ac04909baab7f19868" translate="yes" xml:space="preserve">
          <source>expect.objectContaining()</source>
          <target state="translated">expect.objectContaining()</target>
        </trans-unit>
        <trans-unit id="05a9b81e11194231b386c00515a14089ffa1ab48" translate="yes" xml:space="preserve">
          <source>expect.stringContaining()</source>
          <target state="translated">expect.stringContaining()</target>
        </trans-unit>
        <trans-unit id="64a818d5f4128d542c68ad3e5b52cf9cb07239c5" translate="yes" xml:space="preserve">
          <source>expect.stringMatching()</source>
          <target state="translated">expect.stringMatching()</target>
        </trans-unit>
        <trans-unit id="5b53271817c17d31475c2601f79c760d8c18c932" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;toEqual&lt;/code&gt; 或 &lt;code&gt;toBeCalledWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14fdeea7a02add9f25f4b254a8109cebfb41a968" translate="yes" xml:space="preserve">
          <source>jest</source>
          <target state="translated">jest</target>
        </trans-unit>
        <trans-unit id="399f3e6c7d355276f40f586cacf83580961e34e9" translate="yes" xml:space="preserve">
          <source>jest --bail</source>
          <target state="translated">诨诨</target>
        </trans-unit>
        <trans-unit id="7728f73469dcbf23ae8e337f07d557f5387051c2" translate="yes" xml:space="preserve">
          <source>jest --cache</source>
          <target state="translated">是 --缓存</target>
        </trans-unit>
        <trans-unit id="a4aa246751c414496487d54530974546f8e2e1a7" translate="yes" xml:space="preserve">
          <source>jest --changedFilesWithAncestor</source>
          <target state="translated">jest -changedFilesWithAncestor</target>
        </trans-unit>
        <trans-unit id="e4435b17b912dad78333d9c715e558d3c202ab34" translate="yes" xml:space="preserve">
          <source>jest --changedSince</source>
          <target state="translated">jest -changedSince</target>
        </trans-unit>
        <trans-unit id="b5261799c92dd14f3365e36279542409dc1f4470" translate="yes" xml:space="preserve">
          <source>jest --ci</source>
          <target state="translated">jest --ci</target>
        </trans-unit>
        <trans-unit id="18b3b63f5ed9f4cb059fbdfa287a7092d2bd46c8" translate="yes" xml:space="preserve">
          <source>jest --clearCache</source>
          <target state="translated">jest --clearCache</target>
        </trans-unit>
        <trans-unit id="6b45786c23204e16069d34c716fc3df38b6aa6b3" translate="yes" xml:space="preserve">
          <source>jest --collectCoverageFrom</source>
          <target state="translated">jest --collectCoverageFrom</target>
        </trans-unit>
        <trans-unit id="16739578c7f61b7a8f8542434d00d6ab09963e57" translate="yes" xml:space="preserve">
          <source>jest --colors</source>
          <target state="translated">jest --颜色</target>
        </trans-unit>
        <trans-unit id="16996765a63984335bd12471e86885562b954705" translate="yes" xml:space="preserve">
          <source>jest --config</source>
          <target state="translated">jest --config</target>
        </trans-unit>
        <trans-unit id="ecd47d28d6d16f7e198f7bb676071b8de7aa625f" translate="yes" xml:space="preserve">
          <source>jest --coverage</source>
          <target state="translated">笑话--覆盖面</target>
        </trans-unit>
        <trans-unit id="200e04fecf37753c77869affc65b05074a843073" translate="yes" xml:space="preserve">
          <source>jest --debug</source>
          <target state="translated">是 --debug</target>
        </trans-unit>
        <trans-unit id="d0896a807b1438960db7baa7a96cc00d29eb6fbf" translate="yes" xml:space="preserve">
          <source>jest --detectOpenHandles</source>
          <target state="translated">是 --detectOpenHandles</target>
        </trans-unit>
        <trans-unit id="1edb0e7b6eaef88efb6ed9a604136e0b2dc3df91" translate="yes" xml:space="preserve">
          <source>jest --env</source>
          <target state="translated">是 --env</target>
        </trans-unit>
        <trans-unit id="8a0f943b937dcd72c06bfe59afe73fb4a1f31d48" translate="yes" xml:space="preserve">
          <source>jest --errorOnDeprecated</source>
          <target state="translated">jest --errorOnDeprecated --errorOnDeprecated.</target>
        </trans-unit>
        <trans-unit id="451e3f27037c6eaedc5c0ee1528d6ecd3860ad73" translate="yes" xml:space="preserve">
          <source>jest --expand</source>
          <target state="translated">jest --expand</target>
        </trans-unit>
        <trans-unit id="75a8e4a783be5089515d60538e7e8125cdd33fe3" translate="yes" xml:space="preserve">
          <source>jest --findRelatedTests</source>
          <target state="translated">jest --findRelatedTests(查找相关测试)</target>
        </trans-unit>
        <trans-unit id="4959c728768cddd33ed24149b8756c30f1461b6c" translate="yes" xml:space="preserve">
          <source>jest --forceExit</source>
          <target state="translated">jest --forceExit</target>
        </trans-unit>
        <trans-unit id="e7042ae5c15d17e9dfb626d3b992b070a2b33ac3" translate="yes" xml:space="preserve">
          <source>jest --help</source>
          <target state="translated">诨名--帮助</target>
        </trans-unit>
        <trans-unit id="2b44f9af93a63dbc353bdbb59b8977473460ea15" translate="yes" xml:space="preserve">
          <source>jest --init</source>
          <target state="translated">jest --init</target>
        </trans-unit>
        <trans-unit id="b472735c07ba84430b5dcc73a9578211df4a2c7a" translate="yes" xml:space="preserve">
          <source>jest --json</source>
          <target state="translated">jest --json</target>
        </trans-unit>
        <trans-unit id="67842930eb4c451f524a5334d5d9987f944c0b62" translate="yes" xml:space="preserve">
          <source>jest --lastCommit</source>
          <target state="translated">jest --lastCommit</target>
        </trans-unit>
        <trans-unit id="5ef4898fedf76393b34edae0c0c9eb5f9becbdb5" translate="yes" xml:space="preserve">
          <source>jest --listTests</source>
          <target state="translated">jest --listTests</target>
        </trans-unit>
        <trans-unit id="68a8e8c37228016d5b69d8f98bc9033444f6dcfc" translate="yes" xml:space="preserve">
          <source>jest --logHeapUsage</source>
          <target state="translated">jest --logHeapUsage</target>
        </trans-unit>
        <trans-unit id="34e1461f0465c9780fed87f508481d93f147883c" translate="yes" xml:space="preserve">
          <source>jest --maxConcurrency</source>
          <target state="translated">jest --maxConcurrency</target>
        </trans-unit>
        <trans-unit id="ff2ced6c82113057178b44c26a4df8d1cfcde5ad" translate="yes" xml:space="preserve">
          <source>jest --maxWorkers</source>
          <target state="translated">jest --maxWorkers</target>
        </trans-unit>
        <trans-unit id="8c8c93cffedf5f51fbf6769d1b9f4b08296e0a72" translate="yes" xml:space="preserve">
          <source>jest --noStackTrace</source>
          <target state="translated">jest --noStackTrace</target>
        </trans-unit>
        <trans-unit id="07fe4de480c74eb982dfd2fc1ffabbc5e8000f9a" translate="yes" xml:space="preserve">
          <source>jest --notify</source>
          <target state="translated">jest --notify</target>
        </trans-unit>
        <trans-unit id="777939208a77b6ed85265bb3541e0aaf5212fbb3" translate="yes" xml:space="preserve">
          <source>jest --onlyChanged</source>
          <target state="translated">jest --onlyChanged</target>
        </trans-unit>
        <trans-unit id="39d9ffe9fc23f87610839ef7d3409e4bdcaeb08c" translate="yes" xml:space="preserve">
          <source>jest --outputFile</source>
          <target state="translated">jest --输出文件</target>
        </trans-unit>
        <trans-unit id="709a7d88446a6c333c370abdc7cbc81e5007aeb4" translate="yes" xml:space="preserve">
          <source>jest --passWithNoTests</source>
          <target state="translated">jest --passWithNoTests --passWithNoTests</target>
        </trans-unit>
        <trans-unit id="c01b9e323723244523c23d1edd20bbd8fa1fad8b" translate="yes" xml:space="preserve">
          <source>jest --projects</source>
          <target state="translated">jest --项目</target>
        </trans-unit>
        <trans-unit id="28ccc63c68da10265b442f6ddb719c32cb336d21" translate="yes" xml:space="preserve">
          <source>jest --reporters</source>
          <target state="translated">jest ----报告员</target>
        </trans-unit>
        <trans-unit id="64629dd6eadf22a13bedf72b140ffb326b3adf10" translate="yes" xml:space="preserve">
          <source>jest --runInBand</source>
          <target state="translated">jest --runInBand</target>
        </trans-unit>
        <trans-unit id="6d7004d9e45fbe7afc81b68d019a0999a9bc0c7c" translate="yes" xml:space="preserve">
          <source>jest --runTestsByPath</source>
          <target state="translated">jest --runTestsByPath</target>
        </trans-unit>
        <trans-unit id="096d835c379fd03e494f9bdb3bd4cbf0d83b2f71" translate="yes" xml:space="preserve">
          <source>jest --setupTestFrameworkScriptFile</source>
          <target state="translated">jest --setupTestFramework脚本文件</target>
        </trans-unit>
        <trans-unit id="940e5b5b259afe41c7f972448e3b14ae829486ab" translate="yes" xml:space="preserve">
          <source>jest --showConfig</source>
          <target state="translated">jest --showConfig</target>
        </trans-unit>
        <trans-unit id="a19e9fb882999e3c40b7635bba97bd9c793f3561" translate="yes" xml:space="preserve">
          <source>jest --silent</source>
          <target state="translated">戏言--沉默</target>
        </trans-unit>
        <trans-unit id="3116d8e92505df6e40aa26ca10c8d3a5aefaf6af" translate="yes" xml:space="preserve">
          <source>jest --testLocationInResults</source>
          <target state="translated">jest --testLocationInResults</target>
        </trans-unit>
        <trans-unit id="8a07b564f31bb6e6c96720d77231a8a1e45f39e3" translate="yes" xml:space="preserve">
          <source>jest --testNamePattern</source>
          <target state="translated">jest --testNamePattern</target>
        </trans-unit>
        <trans-unit id="4de2b306577ed62d6f8717e3427fffb985e1b43b" translate="yes" xml:space="preserve">
          <source>jest --testPathIgnorePatterns</source>
          <target state="translated">jest --testPathIgnorePatterns.</target>
        </trans-unit>
        <trans-unit id="c6d599e9db1d5b8b8b9b1e34af131cc7a609574c" translate="yes" xml:space="preserve">
          <source>jest --testPathPattern</source>
          <target state="translated">jest --testPathPattern.</target>
        </trans-unit>
        <trans-unit id="f1e05395a90bfd20cc69363133868bb63d439c51" translate="yes" xml:space="preserve">
          <source>jest --testRunner</source>
          <target state="translated">jest --testRunner</target>
        </trans-unit>
        <trans-unit id="a107d7a62c0faae9d219c603e662cbdfb1168139" translate="yes" xml:space="preserve">
          <source>jest --testSequencer</source>
          <target state="translated">jest --testSequencer</target>
        </trans-unit>
        <trans-unit id="c7ef133f2b7dc919c3ad71da9cce4c6ffd6cd868" translate="yes" xml:space="preserve">
          <source>jest --testTimeout</source>
          <target state="translated">jest --testTimeout</target>
        </trans-unit>
        <trans-unit id="855f8a66c2044d0c0aa8ce263401b44fa1019b06" translate="yes" xml:space="preserve">
          <source>jest --updateSnapshot</source>
          <target state="translated">jest --updateSnapshot</target>
        </trans-unit>
        <trans-unit id="4ea12447858a50cdd5c983e5da4ab87dbdf7bf88" translate="yes" xml:space="preserve">
          <source>jest --useStderr</source>
          <target state="translated">jest --useStderr</target>
        </trans-unit>
        <trans-unit id="f073ca0513417405f3d24492d3c2e48be87f71de" translate="yes" xml:space="preserve">
          <source>jest --verbose</source>
          <target state="translated">戏言</target>
        </trans-unit>
        <trans-unit id="8144cdc86e9d7837063cedb0371d26f3eec4e393" translate="yes" xml:space="preserve">
          <source>jest --version</source>
          <target state="translated">jest --version</target>
        </trans-unit>
        <trans-unit id="24a92c60d5aa0d0bc0a04e89176cbe3de81ca593" translate="yes" xml:space="preserve">
          <source>jest --watch</source>
          <target state="translated">戏言--观看</target>
        </trans-unit>
        <trans-unit id="4a0c8c57a84aa98a2040ae7e753c42a9d15607d0" translate="yes" xml:space="preserve">
          <source>jest --watchAll</source>
          <target state="translated">jest --watchAll</target>
        </trans-unit>
        <trans-unit id="8357ee4077e5c430d196688e7e00e4f2b5298f39" translate="yes" xml:space="preserve">
          <source>jest --watchman</source>
          <target state="translated">戏言--守望者</target>
        </trans-unit>
        <trans-unit id="8dac8b8cbde7c22969d69a11d630521076ff0471" translate="yes" xml:space="preserve">
          <source>jest-changed-files</source>
          <target state="translated">jest-changed-files</target>
        </trans-unit>
        <trans-unit id="b54512fd3b9795a4772b2657ce0156724195ce07" translate="yes" xml:space="preserve">
          <source>jest-codemods</source>
          <target state="translated">jest-codemods</target>
        </trans-unit>
        <trans-unit id="4d0ba9791c912565a89e87ec93cd71cdc4b75579" translate="yes" xml:space="preserve">
          <source>jest-diff</source>
          <target state="translated">jest-diff</target>
        </trans-unit>
        <trans-unit id="fae57be3b9d4c6db0129364d146af1ae34bc4571" translate="yes" xml:space="preserve">
          <source>jest-docblock</source>
          <target state="translated">jest-docblock</target>
        </trans-unit>
        <trans-unit id="33815f7eafadf66bdf82b692a5d7500e04bdcf17" translate="yes" xml:space="preserve">
          <source>jest-extended</source>
          <target state="translated">jest-extended</target>
        </trans-unit>
        <trans-unit id="7a5cb26800c7666578e96bedb106ca6c76db8288" translate="yes" xml:space="preserve">
          <source>jest-get-type</source>
          <target state="translated">jest-get-type</target>
        </trans-unit>
        <trans-unit id="9930457414d8318490b519406b0d01e0c0af9388" translate="yes" xml:space="preserve">
          <source>jest-validate</source>
          <target state="translated">jest-validate</target>
        </trans-unit>
        <trans-unit id="74459ea621c5c89c1a6a8777f420f08a699ce618" translate="yes" xml:space="preserve">
          <source>jest-worker</source>
          <target state="translated">jest-worker</target>
        </trans-unit>
        <trans-unit id="b5268823984999cb437a77b35d87876782899202" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersByTime()</source>
          <target state="translated">jest.advanceTimersByTime()</target>
        </trans-unit>
        <trans-unit id="4f84712675c1d51a3df5e0c8bc41ac8a5291b5b5" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersToNextTimer()</source>
          <target state="translated">jest.advanceTimersToNextTimer()</target>
        </trans-unit>
        <trans-unit id="926befda6fecbd4a52674619f3af9b0e7f68fc1e" translate="yes" xml:space="preserve">
          <source>jest.clearAllMocks()</source>
          <target state="translated">jest.clearAllMocks()</target>
        </trans-unit>
        <trans-unit id="4222fbb57b1accc14807b98d10122439d4ff5022" translate="yes" xml:space="preserve">
          <source>jest.clearAllTimers()</source>
          <target state="translated">jest.clearAllTimers()</target>
        </trans-unit>
        <trans-unit id="c805b56432a104b93bac2f37dc3d95d0ee13d1ef" translate="yes" xml:space="preserve">
          <source>jest.disableAutomock()</source>
          <target state="translated">jest.disableAutomock()</target>
        </trans-unit>
        <trans-unit id="37431f3778ecbfb714d3adbd0be802b5c721c30f" translate="yes" xml:space="preserve">
          <source>jest.doMock()</source>
          <target state="translated">jest.doMock()</target>
        </trans-unit>
        <trans-unit id="e1eb654d0e6f9a86254eb54aacafc37839145bc6" translate="yes" xml:space="preserve">
          <source>jest.dontMock()</source>
          <target state="translated">jest.dontMock()</target>
        </trans-unit>
        <trans-unit id="96a8a03defe83d958b13a8db1048b48645fd3459" translate="yes" xml:space="preserve">
          <source>jest.enableAutomock()</source>
          <target state="translated">jest.enableAutomock()</target>
        </trans-unit>
        <trans-unit id="63706588ece2fbb5ee1cbc26ed3cd9b3394a2aa3" translate="yes" xml:space="preserve">
          <source>jest.fn()</source>
          <target state="translated">jest.fn()</target>
        </trans-unit>
        <trans-unit id="5219ae476b088f3b68bcaf6bf0a3ebfe1cd29904" translate="yes" xml:space="preserve">
          <source>jest.genMockFromModule()</source>
          <target state="translated">jest.genMockFromModule()</target>
        </trans-unit>
        <trans-unit id="def17227de8f296f563b72986222dc177bb11d6d" translate="yes" xml:space="preserve">
          <source>jest.getTimerCount()</source>
          <target state="translated">jest.getTimerCount()</target>
        </trans-unit>
        <trans-unit id="124a77d3e596a96e5e22131aaf874ab0b85168bc" translate="yes" xml:space="preserve">
          <source>jest.isMockFunction()</source>
          <target state="translated">jest.isMockFunction()</target>
        </trans-unit>
        <trans-unit id="f59381d1be107811c5f127861c8b25779aac8d08" translate="yes" xml:space="preserve">
          <source>jest.isolateModules()</source>
          <target state="translated">jest.isolateModules()</target>
        </trans-unit>
        <trans-unit id="7fa6adb6c9fe552d5205372a422e3d7869a09385" translate="yes" xml:space="preserve">
          <source>jest.mock()</source>
          <target state="translated">jest.mock()</target>
        </trans-unit>
        <trans-unit id="ea788268b388e4e34786b83b59c434649a2880ba" translate="yes" xml:space="preserve">
          <source>jest.requireActual()</source>
          <target state="translated">jest.requireActual()</target>
        </trans-unit>
        <trans-unit id="eb1640f83eb73de04420583fd51286a6f8f26358" translate="yes" xml:space="preserve">
          <source>jest.requireMock()</source>
          <target state="translated">jest.requireMock()</target>
        </trans-unit>
        <trans-unit id="d6eb5ae9749a1f0bfe615e87dae5660439f11371" translate="yes" xml:space="preserve">
          <source>jest.resetAllMocks()</source>
          <target state="translated">jest.resetAllMocks()</target>
        </trans-unit>
        <trans-unit id="f5adc7f97ed3055597a83e098ddd8044c1732177" translate="yes" xml:space="preserve">
          <source>jest.resetModules()</source>
          <target state="translated">jest.resetModules()</target>
        </trans-unit>
        <trans-unit id="3fafd64547192fe4a73efe5ad2a0deadac3f3422" translate="yes" xml:space="preserve">
          <source>jest.restoreAllMocks()</source>
          <target state="translated">jest.restoreAllMocks()</target>
        </trans-unit>
        <trans-unit id="a948703e7207e3be8661bf6365a632c32226671e" translate="yes" xml:space="preserve">
          <source>jest.retryTimes()</source>
          <target state="translated">jest.retryTimes()</target>
        </trans-unit>
        <trans-unit id="b8ce73ec4b14b469bb28764f3a8c3d19e82ac7b6" translate="yes" xml:space="preserve">
          <source>jest.runAllImmediates()</source>
          <target state="translated">jest.runAllImmediates()</target>
        </trans-unit>
        <trans-unit id="53af7c8ab5fc7e913ecfb6a326b3610f64160176" translate="yes" xml:space="preserve">
          <source>jest.runAllTicks()</source>
          <target state="translated">jest.runAllTicks()</target>
        </trans-unit>
        <trans-unit id="bdd7917ff7ed9b0c8f251b4ed7bfa4aaf2b6152b" translate="yes" xml:space="preserve">
          <source>jest.runAllTimers()</source>
          <target state="translated">jest.runAllTimers()</target>
        </trans-unit>
        <trans-unit id="5f8881d3c2fa2e3c3978c63711cfc41587308941" translate="yes" xml:space="preserve">
          <source>jest.runOnlyPendingTimers()</source>
          <target state="translated">jest.runOnlyPendingTimers()</target>
        </trans-unit>
        <trans-unit id="115ea6be6949d8073195cf40a89a2c53d963f31a" translate="yes" xml:space="preserve">
          <source>jest.setMock()</source>
          <target state="translated">jest.setMock()</target>
        </trans-unit>
        <trans-unit id="e38a82fd2d18d144fa8049c3a4042f3947d71db8" translate="yes" xml:space="preserve">
          <source>jest.setTimeout()</source>
          <target state="translated">jest.setTimeout()</target>
        </trans-unit>
        <trans-unit id="4a21c582c06cb9f55c32d6a0da8083dbef2d04a4" translate="yes" xml:space="preserve">
          <source>jest.spyOn()</source>
          <target state="translated">jest.spyOn()</target>
        </trans-unit>
        <trans-unit id="e51942569d340db8459bde0b3a57da7a3ae5bd19" translate="yes" xml:space="preserve">
          <source>jest.unmock()</source>
          <target state="translated">jest.unmock()</target>
        </trans-unit>
        <trans-unit id="7bdcc5f2e0051948cd9175cbfd47b9f3a5c8a112" translate="yes" xml:space="preserve">
          <source>jest.useFakeTimers()</source>
          <target state="translated">jest.useFakeTimers()</target>
        </trans-unit>
        <trans-unit id="567a022c7ff0ed1eeecf66243bfb760f39f98839" translate="yes" xml:space="preserve">
          <source>jest.useRealTimers()</source>
          <target state="translated">jest.useRealTimers()</target>
        </trans-unit>
        <trans-unit id="d6c73ed242e8279bf8b5008c49164ea76ecca716" translate="yes" xml:space="preserve">
          <source>launch &amp;amp; file the websocket endpoint of puppeteer with Global Setup</source>
          <target state="translated">使用Global Setup启动并归档puppeteer的websocket端点</target>
        </trans-unit>
        <trans-unit id="c5534dc1bf91cfa3f571372cc1df1fde4778c65c" translate="yes" xml:space="preserve">
          <source>matching the files that coverage info needs to be collected from.</source>
          <target state="translated">匹配需要收集覆盖信息的文件。</target>
        </trans-unit>
        <trans-unit id="bdaf39bbe2e8ce24d626e5d939f2687b7925a111" translate="yes" xml:space="preserve">
          <source>mockFn.getMockName()</source>
          <target state="translated">mockFn.getMockName()</target>
        </trans-unit>
        <trans-unit id="76ba86f80a3975694b82876ec035c67727b880ce" translate="yes" xml:space="preserve">
          <source>mockFn.mock.calls</source>
          <target state="translated">mockFn.mock.calls</target>
        </trans-unit>
        <trans-unit id="b8f5e098751b2e1a0b0c994fa0e253d7b6667585" translate="yes" xml:space="preserve">
          <source>mockFn.mock.instances</source>
          <target state="translated">mockFn.mock.instances</target>
        </trans-unit>
        <trans-unit id="37a607803e67bc8f0e277c4bad07d899cb8e68ee" translate="yes" xml:space="preserve">
          <source>mockFn.mock.results</source>
          <target state="translated">mockFn.mock.results</target>
        </trans-unit>
        <trans-unit id="d7884cf2e18f52e2befafea1329cc93891d01d0e" translate="yes" xml:space="preserve">
          <source>mockFn.mockClear()</source>
          <target state="translated">mockFn.mockClear()</target>
        </trans-unit>
        <trans-unit id="b1a1dc73ee86a9db45f473726c03a5d44e7d6e00" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementation()</source>
          <target state="translated">mockFn.mockImplementation()</target>
        </trans-unit>
        <trans-unit id="705599d736e3f800c387b8732532a981208d86f3" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementationOnce()</source>
          <target state="translated">mockFn.mockImplementationOnce()</target>
        </trans-unit>
        <trans-unit id="b15f7560dc442cfe559991bd028b3593dbedcfa3" translate="yes" xml:space="preserve">
          <source>mockFn.mockName()</source>
          <target state="translated">mockFn.mockName()</target>
        </trans-unit>
        <trans-unit id="cbee5a4253c363dd81a99f99a7171fe30ca56500" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValue()</source>
          <target state="translated">mockFn.mockRejectedValue()</target>
        </trans-unit>
        <trans-unit id="f0f879d05ce665721a5b420f915a6b799a9261b3" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValueOnce()</source>
          <target state="translated">mockFn.mockRejectedValueOnce()</target>
        </trans-unit>
        <trans-unit id="6379aa11d6a3d7b94b0cabd0ea38f28a5ac0a66b" translate="yes" xml:space="preserve">
          <source>mockFn.mockReset()</source>
          <target state="translated">mockFn.mockReset()</target>
        </trans-unit>
        <trans-unit id="e5f5a2cc9780e616fb57bcbabbb5e1b492e59a7c" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValue()</source>
          <target state="translated">mockFn.mockResolvedValue()</target>
        </trans-unit>
        <trans-unit id="a610c3278d44712a00c28aba1ba0a5f4c56f4602" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValueOnce()</source>
          <target state="translated">mockFn.mockResolvedValueOnce()</target>
        </trans-unit>
        <trans-unit id="93b4b4162d3f8f9f6743942f1582c22d36cf0434" translate="yes" xml:space="preserve">
          <source>mockFn.mockRestore()</source>
          <target state="translated">mockFn.mockRestore()</target>
        </trans-unit>
        <trans-unit id="b89668bf6eee3709904c8e914501f15481a0ec32" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnThis()</source>
          <target state="translated">mockFn.mockReturnThis()</target>
        </trans-unit>
        <trans-unit id="8406d4374df6cedb0774c198a5e18305079be058" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValue()</source>
          <target state="translated">mockFn.mockReturnValue()</target>
        </trans-unit>
        <trans-unit id="91d18268f60b6021a577b531532180c54eed125c" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValueOnce()</source>
          <target state="translated">mockFn.mockReturnValueOnce()</target>
        </trans-unit>
        <trans-unit id="110fd2eef67d470b905e3f770bc78bf0e48c4532" translate="yes" xml:space="preserve">
          <source>moduleNameMapper</source>
          <target state="translated">moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f398e82965b003d86545395906bc58c426a160f4" translate="yes" xml:space="preserve">
          <source>or the following for Windows:</source>
          <target state="translated">或Windows的以下内容。</target>
        </trans-unit>
        <trans-unit id="2e4e9d9ce9649c8da277337be899d54f4b10f016" translate="yes" xml:space="preserve">
          <source>pretty-format</source>
          <target state="translated">pretty-format</target>
        </trans-unit>
        <trans-unit id="b41c94dc77a8359c700e959dbc3271747436b9b8" translate="yes" xml:space="preserve">
          <source>react-testing-library</source>
          <target state="translated">react-testing-library</target>
        </trans-unit>
        <trans-unit id="6096aad9326ad51aa7277852583cdbbd0063c505" translate="yes" xml:space="preserve">
          <source>regular expression: error message &lt;strong&gt;matches&lt;/strong&gt; the pattern</source>
          <target state="translated">正则表达式：错误消息&lt;strong&gt;与&lt;/strong&gt;模式&lt;strong&gt;匹配&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="564cb4d408b58135c97baa36f450885bf9df5afd" translate="yes" xml:space="preserve">
          <source>renamed from &lt;code&gt;runTimersToTime&lt;/code&gt; to &lt;code&gt;advanceTimersByTime&lt;/code&gt; in Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</source>
          <target state="translated">从更名 &lt;code&gt;runTimersToTime&lt;/code&gt; 到 &lt;code&gt;advanceTimersByTime&lt;/code&gt; 开玩笑&lt;strong&gt;22.0.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b081d67ddd0df4286abac590611b195d5398dfcd" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</source>
          <target state="translated">在Jest &lt;strong&gt;22.0.0+中&lt;/strong&gt;重命名&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="694331c0b9e2b5401cd9005a2f8016a7f0913ff5" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;26.0.0+&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa765d3c5cf61960d9c86c450acc1e2d6113a622" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">改写 &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; 如 &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12ee99b45418f1c182987feaff420ab1c0a53144" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">改写 &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; 如 &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="648a633ae93664b145f1de2382bce78296d0d025" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">改写 &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; 如 &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4f197332e08a233e78868954dc8a7424597d992" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">改写 &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; 如 &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98551bd9aa53f809816b1e04556754e5dbd233c3" translate="yes" xml:space="preserve">
          <source>setupFiles</source>
          <target state="translated">setupFiles</target>
        </trans-unit>
        <trans-unit id="cab3c689753017d9ed1c9833b41212afcceb0268" translate="yes" xml:space="preserve">
          <source>string: error message &lt;strong&gt;includes&lt;/strong&gt; the substring</source>
          <target state="translated">字符串：错误消息&lt;strong&gt;包含&lt;/strong&gt;子字符串</target>
        </trans-unit>
        <trans-unit id="1a13bd67d53c6ca5d0ba854cc1c6d8e1dc4db3cb" translate="yes" xml:space="preserve">
          <source>test()</source>
          <target state="translated">test()</target>
        </trans-unit>
        <trans-unit id="96bc193802c9de785826750faae2c6bc85cbfbb8" translate="yes" xml:space="preserve">
          <source>test.each()</source>
          <target state="translated">test.each()</target>
        </trans-unit>
        <trans-unit id="5d3becd10c06347f68018bdfb99aca7f0ac8047e" translate="yes" xml:space="preserve">
          <source>test.only()</source>
          <target state="translated">test.only()</target>
        </trans-unit>
        <trans-unit id="ab30dfd5db9a31603c2e47fbd6881ec8dab86d26" translate="yes" xml:space="preserve">
          <source>test.only.each()</source>
          <target state="translated">test.only.each()</target>
        </trans-unit>
        <trans-unit id="1176e40f403020d9366a6b52b73ff551f31b1814" translate="yes" xml:space="preserve">
          <source>test.skip()</source>
          <target state="translated">test.skip()</target>
        </trans-unit>
        <trans-unit id="f1d908eaf6e6e7fa35622b4b43d6a8af1a3c660e" translate="yes" xml:space="preserve">
          <source>test.skip.each()</source>
          <target state="translated">test.skip.each()</target>
        </trans-unit>
        <trans-unit id="74875a7933e712e5381bd416043bfb0b6616a91e" translate="yes" xml:space="preserve">
          <source>test.todo()</source>
          <target state="translated">test.todo()</target>
        </trans-unit>
        <trans-unit id="f4cea10a1c0dc3c50965ee387dece60500be5cff" translate="yes" xml:space="preserve">
          <source>to match a property in &lt;code&gt;objectContaining&lt;/code&gt; or &lt;code&gt;toMatchObject&lt;/code&gt;</source>
          <target state="translated">匹配 &lt;code&gt;objectContaining&lt;/code&gt; 或 &lt;code&gt;toMatchObject&lt;/code&gt; 中的属性</target>
        </trans-unit>
        <trans-unit id="b1d3d79ec58192bdcdaff5e0ab0b7fbca133543f" translate="yes" xml:space="preserve">
          <source>to match an element in &lt;code&gt;arrayContaining&lt;/code&gt;</source>
          <target state="translated">匹配 &lt;code&gt;arrayContaining&lt;/code&gt; 中的元素</target>
        </trans-unit>
        <trans-unit id="3556cfc1ba0721081f3f93c076211e40ef1a22b9" translate="yes" xml:space="preserve">
          <source>transformIgnorePatterns customization</source>
          <target state="translated">变换IgnorePatterns自定义</target>
        </trans-unit>
        <trans-unit id="fc220be1ad7bd8b6a9feda6f6ba1285b333e98e2" translate="yes" xml:space="preserve">
          <source>vscode-jest</source>
          <target state="translated">vscode-jest</target>
        </trans-unit>
        <trans-unit id="5218cb6aea807d0d643ecaa0be3719b154b08685" translate="yes" xml:space="preserve">
          <source>webpack 2 offers native support for ES modules. However, Jest runs in Node, and thus requires ES modules to be transpiled to CommonJS modules. As such, if you are using webpack 2, you most likely will want to configure Babel to transpile ES modules to CommonJS modules only in the &lt;code&gt;test&lt;/code&gt; environment.</source>
          <target state="translated">webpack 2为ES模块提供了本机支持。但是，Jest在Node中运行，因此需要将ES模块转换为CommonJS模块。因此，如果您使用的是webpack 2，则很可能希望将Babel配置为仅在 &lt;code&gt;test&lt;/code&gt; 环境中将ES模块转换为CommonJS模块。</target>
        </trans-unit>
        <trans-unit id="5ebedacdf66fa11ed6c1f1cd9d9b0e19efbf3b58" translate="yes" xml:space="preserve">
          <source>you can use:</source>
          <target state="translated">你可以使用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
