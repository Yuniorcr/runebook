<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="8039a41e04b2332bb9a1e006d40250afbf96b442" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2019 Facebook, Inc. and its affiliates.</source>
          <target state="translated">&amp;copy;2019 Facebook，Inc.及其分支机构。</target>
        </trans-unit>
        <trans-unit id="42901a148f0c2acfd77b86f41286ab7555b1a83f" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020 Facebook, Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8733204266bf9ef9d139b9cd40bbd88f570127e5" translate="yes" xml:space="preserve">
          <source>(default: &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt;)</source>
          <target state="translated">（默认值： &lt;code&gt;[ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[jt]s?(x)&quot; ]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e44ebb5582c56abe12f2669212eb5c60e8d4853b" translate="yes" xml:space="preserve">
          <source>* Module factory function must return a function</source>
          <target state="translated">*模块工厂功能必须返回一个功能</target>
        </trans-unit>
        <trans-unit id="11a99659b9799607d24f99d1703d405ff90c24fb" translate="yes" xml:space="preserve">
          <source>. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="translated">。请更改其中一个有冲突的插件的密钥配置，以避免重叠。</target>
        </trans-unit>
        <trans-unit id="af6ed7ba3a77d9c9041d1f9f34a1c12b90a41d5b" translate="yes" xml:space="preserve">
          <source>.not</source>
          <target state="translated">.not</target>
        </trans-unit>
        <trans-unit id="37f06d3dd43811fb4a3a366255d459cfd648f809" translate="yes" xml:space="preserve">
          <source>.rejects</source>
          <target state="translated">.rejects</target>
        </trans-unit>
        <trans-unit id="3a41b0fffb37be03170b7fc364408f5627fb6783" translate="yes" xml:space="preserve">
          <source>.resolves</source>
          <target state="translated">.resolves</target>
        </trans-unit>
        <trans-unit id="676b70f0ba2473d03d5c38bd58a4c33f141c1881" translate="yes" xml:space="preserve">
          <source>.toBe()</source>
          <target state="translated">.toBe()</target>
        </trans-unit>
        <trans-unit id="32a2cc64ae6a3e2a930d047916b812fe4b5d0e88" translate="yes" xml:space="preserve">
          <source>.toBeCloseTo()</source>
          <target state="translated">.toBeCloseTo()</target>
        </trans-unit>
        <trans-unit id="99ce778367e3457801132fbd52692b493aa35f2b" translate="yes" xml:space="preserve">
          <source>.toBeDefined()</source>
          <target state="translated">.toBeDefined()</target>
        </trans-unit>
        <trans-unit id="9b3929ba1aa6dd0ddf943ca0e147dbc91d13488d" translate="yes" xml:space="preserve">
          <source>.toBeFalsy()</source>
          <target state="translated">.toBeFalsy()</target>
        </trans-unit>
        <trans-unit id="8d1c7e785d4737e92e5db59d84e589ec79a15f1a" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThan()</source>
          <target state="translated">.toBeGreaterThan()</target>
        </trans-unit>
        <trans-unit id="f276b89d8cc696f904c15a937aa2c4f57049c9d8" translate="yes" xml:space="preserve">
          <source>.toBeGreaterThanOrEqual()</source>
          <target state="translated">.toBeGreaterThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="6bff9db7ccc5307cb1baba71f20f8dcb5eca7313" translate="yes" xml:space="preserve">
          <source>.toBeInstanceOf()</source>
          <target state="translated">.toBeInstanceOf()</target>
        </trans-unit>
        <trans-unit id="647d1cf6ca2e0af2106268548794474115aea36d" translate="yes" xml:space="preserve">
          <source>.toBeLessThan()</source>
          <target state="translated">.toBeLessThan()</target>
        </trans-unit>
        <trans-unit id="ea2494b392db9dcab4645d97c83fd9a2182286e4" translate="yes" xml:space="preserve">
          <source>.toBeLessThanOrEqual()</source>
          <target state="translated">.toBeLessThanOrEqual()</target>
        </trans-unit>
        <trans-unit id="720a4c5d8244f39f9f666e702c0e3852b57afea2" translate="yes" xml:space="preserve">
          <source>.toBeNaN()</source>
          <target state="translated">.toBeNaN()</target>
        </trans-unit>
        <trans-unit id="f0c9793c8f304879d82d7089132a47ef6cfb8593" translate="yes" xml:space="preserve">
          <source>.toBeNull()</source>
          <target state="translated">.toBeNull()</target>
        </trans-unit>
        <trans-unit id="077ff246559a6d00501b8fa5b20b80ff03301608" translate="yes" xml:space="preserve">
          <source>.toBeTruthy()</source>
          <target state="translated">.toBeTruthy()</target>
        </trans-unit>
        <trans-unit id="98663990dec7535feda7d7a24ff1693d1049c82f" translate="yes" xml:space="preserve">
          <source>.toBeUndefined()</source>
          <target state="translated">.toBeUndefined()</target>
        </trans-unit>
        <trans-unit id="7d1504d2c8e2ced7a503f0d02d0ca0a94cd67568" translate="yes" xml:space="preserve">
          <source>.toContain()</source>
          <target state="translated">.toContain()</target>
        </trans-unit>
        <trans-unit id="4bcc79e6f40ce4c5625a5d71c2dbc2a433e04c9c" translate="yes" xml:space="preserve">
          <source>.toContainEqual()</source>
          <target state="translated">.toContainEqual()</target>
        </trans-unit>
        <trans-unit id="26decec7a3cac6d27508b590d0ba65718d5b2de4" translate="yes" xml:space="preserve">
          <source>.toEqual()</source>
          <target state="translated">.toEqual()</target>
        </trans-unit>
        <trans-unit id="4e3793133f260880cc150fb12b6d7f1c053f3550" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalled()</source>
          <target state="translated">.toHaveBeenCalled()</target>
        </trans-unit>
        <trans-unit id="00772fdde0f479a0db9548a093488dcfd5588cc9" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledTimes()</source>
          <target state="translated">.toHaveBeenCalledTimes()</target>
        </trans-unit>
        <trans-unit id="1dfa8f19daae4c3dc83cbec00ad04f332c9915ae" translate="yes" xml:space="preserve">
          <source>.toHaveBeenCalledWith()</source>
          <target state="translated">.toHaveBeenCalledWith()</target>
        </trans-unit>
        <trans-unit id="5959332ef495a103a4ccdc29a0e15aa7a7565d05" translate="yes" xml:space="preserve">
          <source>.toHaveBeenLastCalledWith()</source>
          <target state="translated">.toHaveBeenLastCalledWith()</target>
        </trans-unit>
        <trans-unit id="a3a97daff76f81f78afb83c331fc23947a78f45c" translate="yes" xml:space="preserve">
          <source>.toHaveBeenNthCalledWith()</source>
          <target state="translated">.toHaveBeenNthCalledWith()</target>
        </trans-unit>
        <trans-unit id="0c161a4b9f0d771ccd327f65278e09178b507795" translate="yes" xml:space="preserve">
          <source>.toHaveLastReturnedWith()</source>
          <target state="translated">.toHaveLastReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a0443d967f32f1308634aa976c0d469385693824" translate="yes" xml:space="preserve">
          <source>.toHaveLength()</source>
          <target state="translated">.toHaveLength()</target>
        </trans-unit>
        <trans-unit id="794f45b9cd4158e59c5c292424191e68bf89e18e" translate="yes" xml:space="preserve">
          <source>.toHaveNthReturnedWith()</source>
          <target state="translated">.toHaveNthReturnedWith()</target>
        </trans-unit>
        <trans-unit id="a6dd5320db9ee9d51d1c8e22c168ba712935f3bb" translate="yes" xml:space="preserve">
          <source>.toHaveProperty()</source>
          <target state="translated">.toHaveProperty()</target>
        </trans-unit>
        <trans-unit id="44f8374b7809b36963550595e06fff53b46f64bb" translate="yes" xml:space="preserve">
          <source>.toHaveReturned()</source>
          <target state="translated">.toHaveReturned()</target>
        </trans-unit>
        <trans-unit id="e3c3d3edd9ad715908bf398891fb02d0c3c4932a" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedTimes()</source>
          <target state="translated">.toHaveReturnedTimes()</target>
        </trans-unit>
        <trans-unit id="a5111ab06a437a3308c64674fc8fd62826ee0969" translate="yes" xml:space="preserve">
          <source>.toHaveReturnedWith()</source>
          <target state="translated">.toHaveReturnedWith()</target>
        </trans-unit>
        <trans-unit id="2e70316fe3608fd8ec3c03f9f87028c2c8363a05" translate="yes" xml:space="preserve">
          <source>.toMatch()</source>
          <target state="translated">.toMatch()</target>
        </trans-unit>
        <trans-unit id="73905b27654bb05043f04e3456080771951db1fd" translate="yes" xml:space="preserve">
          <source>.toMatchInlineSnapshot()</source>
          <target state="translated">.toMatchInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dd215f94d457250f89ee5c13cffb1d58a988815c" translate="yes" xml:space="preserve">
          <source>.toMatchObject()</source>
          <target state="translated">.toMatchObject()</target>
        </trans-unit>
        <trans-unit id="7f8b4f8d30db6de4b405874a76c6a2f72c9f3142" translate="yes" xml:space="preserve">
          <source>.toMatchSnapshot()</source>
          <target state="translated">.toMatchSnapshot()</target>
        </trans-unit>
        <trans-unit id="67a75a5640e37db5bf286c0733cf73807148ddcc" translate="yes" xml:space="preserve">
          <source>.toStrictEqual()</source>
          <target state="translated">.toStrictEqual()</target>
        </trans-unit>
        <trans-unit id="daf6eadfb4ea82a0e7b370d4eb7e4e557cfec7c3" translate="yes" xml:space="preserve">
          <source>.toThrow()</source>
          <target state="translated">.toThrow()</target>
        </trans-unit>
        <trans-unit id="821616a911f93e7076cfbb743c648b0dc07240e2" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingInlineSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingInlineSnapshot()</target>
        </trans-unit>
        <trans-unit id="dfc790de4e060a8cb2c6a3f3d9107f894635d8e4" translate="yes" xml:space="preserve">
          <source>.toThrowErrorMatchingSnapshot()</source>
          <target state="translated">.toThrowErrorMatchingSnapshot()</target>
        </trans-unit>
        <trans-unit id="d02f00544c5410b45100d8c26dc869d32c374dae" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;describe.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">1. &lt;code&gt;describe.each(table)(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aecc5ed68c24be66ca9a5ece9cd01a2c281ca41" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;test.concurrent.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad05971b070fbc37cf9c07f4fcefdbfe80d469c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;test.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">1. &lt;code&gt;test.each(table)(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ce2deb0fd00df7e1bc70232ca6e95f15b442ea2" translate="yes" xml:space="preserve">
          <source>1. Treat snapshots as code</source>
          <target state="translated">1.把快照当成代码</target>
        </trans-unit>
        <trans-unit id="fa3a6811ab29a636472dbcf19ebed735d5088990" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;describe.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">2. &lt;code&gt;describe.each`table`(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b75a3366a8db9089a72d0ba997e8d4a109021d13" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;test.concurrent.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d60d82552a2ba8086d2f9a363a55553cd0161d" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;test.each`table`(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">2. &lt;code&gt;test.each`table`(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0759e7d1939c65b0a51804dcf5e0e9eff89e699a" translate="yes" xml:space="preserve">
          <source>2. Tests should be deterministic</source>
          <target state="translated">2.测试应是确定性的</target>
        </trans-unit>
        <trans-unit id="4054a23d3f0fea28f4ad5c16a5e2746a51ebdac4" translate="yes" xml:space="preserve">
          <source>3. Use descriptive snapshot names</source>
          <target state="translated">3.使用描述性的快照名称</target>
        </trans-unit>
        <trans-unit id="ac9eeb7d2d7d6604e6579b4bb05bc0610e1c1293" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://niralar.com/testing-hapi-js-with-jest/&quot;&gt;Testing Hapi.js With Jest&lt;/a&gt; by Niralar (&lt;a href=&quot;http://sivasankar.in/&quot;&gt;Sivasankar&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d3cdecff2c457d98abdf63eb1eed93ccea97ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/&quot;&gt;How to test Express.js with Jest and Supertest&lt;/a&gt; by Albert Gao (&lt;a href=&quot;https://twitter.com/albertgao&quot;&gt;@albertgao&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://www.albertgao.xyz/2017/05/24/how-to-test-expressjs-with-jest-and-supertest/&quot;&gt;如何使用&lt;/a&gt; Albert Gao（&lt;a href=&quot;https://twitter.com/albertgao&quot;&gt;@albertgao&lt;/a&gt;）的Jest和Supertest 测试Express.js</target>
        </trans-unit>
        <trans-unit id="4df494206c7fb512291d9c26b280d086c8f68221" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/&quot;&gt;Testing Vue.js components with Jest&lt;/a&gt; by Alex Jover Morales (&lt;a href=&quot;https://twitter.com/alexjoverm&quot;&gt;@alexjoverm&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/&quot;&gt;使用&lt;/a&gt; Alex Jover Morales（&lt;a href=&quot;https://twitter.com/alexjoverm&quot;&gt;@alexjoverm&lt;/a&gt;）的Jest测试Vue.js组件</target>
        </trans-unit>
        <trans-unit id="46bd0f6a51fa91fdbce16a47fc80eb5895c7a46b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://dwatow.github.io/2019/08-14-angularjs/angular-jest/?fbclid=IwAR2SrqYg_o6uvCQ79FdNPeOxs86dUqB6pPKgd9BgnHt1kuIDRyRM-ch11xg&quot;&gt;AngularJS Unit Tests with Jest Actions (Traditional Chinese)&lt;/a&gt; by Chris Wang (&lt;a href=&quot;https://github.com/dwatow&quot;&gt;@dwatow&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56b908cf5de025f16168813fe23530da4086bf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://engineering.talentpair.com/running-angularjs-tests-with-jest-49d0cc9c6d26&quot;&gt;Running AngularJS Tests with Jest&lt;/a&gt; by Ben Brandt (&lt;a href=&quot;https://twitter.com/benjaminbrandt&quot;&gt;@benjaminbrandt&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://engineering.talentpair.com/running-angularjs-tests-with-jest-49d0cc9c6d26&quot;&gt;&lt;/a&gt;通过Ben Brandt（&lt;a href=&quot;https://twitter.com/benjaminbrandt&quot;&gt;@benjaminbrandt&lt;/a&gt;）的Jest运行AngularJS测试</target>
        </trans-unit>
        <trans-unit id="a5396961ac6b2c5f21f3d0317ec9f09404d9af19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/jest-community&quot;&gt;jest-community&lt;/a&gt; is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/jest-community&quot;&gt;jest-community&lt;/a&gt;是一个新的GitHub组织，用于由Jest维护者和合作者策划的高质量Jest附加项。它已经包含了一些我们最喜欢的项目，仅举几例：</target>
        </trans-unit>
        <trans-unit id="b99bce60cd49efb888fea268162f85d4db8fc8b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;Jest DynamoDB&lt;/a&gt; provides all required configuration to run your tests using DynamoDB.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;Jest DynamoDB&lt;/a&gt;提供了使用DynamoDB运行测试所需的所有必需配置。</target>
        </trans-unit>
        <trans-unit id="5b359adbc76ca4d01768ec6507a7cd0a41449b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;Jest MongoDB&lt;/a&gt; provides all required configuration to run your tests using MongoDB.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;Jest MongoDB&lt;/a&gt;提供了使用MongoDB运行测试所需的所有配置。</target>
        </trans-unit>
        <trans-unit id="bb9813ff97e2bfab1d3620d9cd0c674d6c319235" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Jest Puppeteer&lt;/a&gt; provides all required configuration to run your tests using Puppeteer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;Jest Puppeteer&lt;/a&gt;提供了所有必需的配置，以使用Puppeteer运行测试。</target>
        </trans-unit>
        <trans-unit id="d1e5d6a58c8bec76b77a3d04abb1b2a26fc4087e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@kentaromiura_the_js_guy/jest-for-all-episode-1-vue-js-d616bccbe186#.d573vrce2&quot;&gt;Jest for all: Episode 1 &amp;mdash; Vue.js&lt;/a&gt; by Cristian Carlesso (&lt;a href=&quot;https://twitter.com/kentaromiura&quot;&gt;@kentaromiura&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@kentaromiura_the_js_guy/jest-for-all-episode-1-vue-js-d616bccbe186#.d573vrce2&quot;&gt;为所有人开玩笑：第1集&amp;mdash;&lt;/a&gt; Cristian Carlesso的Vue.js（&lt;a href=&quot;https://twitter.com/kentaromiura&quot;&gt;@kentaromiura&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="fd5742738a051dfb6af1d4fff2bcc31ff0ec9ba9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251&quot;&gt;Testing an AngularJS app with Jest&lt;/a&gt; by Matthieu Lux (&lt;a href=&quot;https://twitter.com/Swiip&quot;&gt;@Swiip&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/aya-experience/testing-an-angularjs-app-with-jest-3029a613251&quot;&gt;&lt;/a&gt;用Matthieu Lux（&lt;a href=&quot;https://twitter.com/Swiip&quot;&gt;@Swiip&lt;/a&gt;）的Jest测试AngularJS应用</target>
        </trans-unit>
        <trans-unit id="8a8c0a5d3a823c18229e23ca4494e3567d0bcdc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redux.js.org/recipes/writing-tests&quot;&gt;Writing Tests&lt;/a&gt; by Redux docs</source>
          <target state="translated">&lt;a href=&quot;https://redux.js.org/recipes/writing-tests&quot;&gt;&lt;/a&gt;Redux docs 编写测试</target>
        </trans-unit>
        <trans-unit id="55111a72c4fd1cefa5bb8c3683ca9b7e0a70243d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest&quot;&gt;How to Test React and MobX with Jest&lt;/a&gt; by Will Stern (&lt;a href=&quot;https://twitter.com/willsterndev&quot;&gt;@willsterndev&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://semaphoreci.com/community/tutorials/how-to-test-react-and-mobx-with-jest&quot;&gt;如何&lt;/a&gt;用Will Stern（&lt;a href=&quot;https://twitter.com/willsterndev&quot;&gt;@willsterndev&lt;/a&gt;）的Jest测试React和MobX</target>
        </trans-unit>
        <trans-unit id="a1dc5efbde32a79edd41672fa8c329e3f032fc7d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://testing-library.com/docs/react-testing-library/example-intro&quot;&gt;Testing ReactJS components with Jest&lt;/a&gt; by Kent C. Dodds (&lt;a href=&quot;https://twitter.com/kentcdodds&quot;&gt;@kentcdodds&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb86efcd4fb0536b2d852e06deaf03e53e7a7f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.gatsbyjs.org/docs/unit-testing/&quot;&gt;Unit Testing&lt;/a&gt; by GatsbyJS docs</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/docs/unit-testing/&quot;&gt;&lt;/a&gt;GatsbyJS docs进行的单元测试</target>
        </trans-unit>
        <trans-unit id="d81eac7c1a1ce0cc4e092235c95a04493ca09f53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.xfive.co/blog/testing-angular-faster-jest/&quot;&gt;Testing Angular faster with Jest&lt;/a&gt; by Michał Pierzchała (&lt;a href=&quot;https://twitter.com/thymikee&quot;&gt;@thymikee&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://www.xfive.co/blog/testing-angular-faster-jest/&quot;&gt;用&lt;/a&gt;&lt;a href=&quot;https://twitter.com/thymikee&quot;&gt;MichałPierzchała&lt;/a&gt;（@thymikee）的Jest更快地测试Angular</target>
        </trans-unit>
        <trans-unit id="f07fb064a1ca3650efef1c76fcbb075693e99c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;troubleshooting&quot;&gt;Troubleshoot&lt;/a&gt; problems with Jest.</source>
          <target state="translated">&lt;a href=&quot;troubleshooting&quot;&gt;解决&lt;/a&gt; Jest的问题。</target>
        </trans-unit>
        <trans-unit id="443213bdc808a3fc65945784503fb0ee5e83725f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;tutorial-react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;tutorial-react-native&quot;&gt;React Native&lt;/a&gt; components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of &lt;a href=&quot;https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts&quot;&gt;snapshotting CLI output&lt;/a&gt; in the Jest repo.</source>
          <target state="translated">&lt;a href=&quot;tutorial-react&quot;&gt;React&lt;/a&gt;和&lt;a href=&quot;tutorial-react-native&quot;&gt;React Native&lt;/a&gt;组件是快照测试的一个很好的用例。但是，快照可以捕获任何可序列化的值，因此在目标测试输出是否正确时都应使用快照。Jest存储库包含许多测试Jest本身的输出，Jest的断言库的输出以及来自Jest代码库各个部分的日志消息的示例。请参阅Jest存储库中的&lt;a href=&quot;https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts&quot;&gt;CLI输出快照&lt;/a&gt;示例。</target>
        </trans-unit>
        <trans-unit id="35a5ed3d96a7d19aaa272ea4066717b8d7f08ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%#&lt;/code&gt; - Index of the test case.</source>
          <target state="translated">&lt;code&gt;%#&lt;/code&gt; -测试用例的索引。</target>
        </trans-unit>
        <trans-unit id="99439ec715d56673a87763600a5604708e1c38d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%%&lt;/code&gt; - single percent sign ('%'). This does not consume an argument.</source>
          <target state="translated">&lt;code&gt;%%&lt;/code&gt; -单个百分号（'％'）。这不消耗参数。</target>
        </trans-unit>
        <trans-unit id="be58a859ecea37f16b1baf755a833c937911e03a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;- Number.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; -数字。</target>
        </trans-unit>
        <trans-unit id="0210f4fcea5c1914a2ac951e9e76cb6796c46080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f&lt;/code&gt; - Floating point value.</source>
          <target state="translated">&lt;code&gt;%f&lt;/code&gt; -浮点值。</target>
        </trans-unit>
        <trans-unit id="55ee086a73fac1a68641f364d883a401f6667b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%i&lt;/code&gt; - Integer.</source>
          <target state="translated">&lt;code&gt;%i&lt;/code&gt; -整数。</target>
        </trans-unit>
        <trans-unit id="e01cf6855d89e736222379d96cb8f8c24d6b9544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%j&lt;/code&gt; - JSON.</source>
          <target state="translated">&lt;code&gt;%j&lt;/code&gt; -JSON。</target>
        </trans-unit>
        <trans-unit id="bab6bb51afc0fd48dceefb2aac9b600984e09b3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%o&lt;/code&gt; - Object.</source>
          <target state="translated">&lt;code&gt;%o&lt;/code&gt; -对象。</target>
        </trans-unit>
        <trans-unit id="3ae24f8fcf878ada51ee4c476c8d990172aa5ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;pretty-format&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; - &lt;a href=&quot;https://www.npmjs.com/package/pretty-format&quot;&gt;漂亮的格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6e26914b39d77aae13dc19308b1d95ba59e4ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;- String.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; -字符串。</target>
        </trans-unit>
        <trans-unit id="6549287d9dfc46e5e451bf23de875efc1b0450ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;''&lt;/code&gt; if matcher was not called with a promise modifier</source>
          <target state="translated">&lt;code&gt;''&lt;/code&gt; 如果没有用promise修饰符调用匹配器</target>
        </trans-unit>
        <trans-unit id="1d41bf2fd44861b9c5446bf7dcb05135d69e1d25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'incomplete'&lt;/code&gt; - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.</source>
          <target state="translated">&lt;code&gt;'incomplete'&lt;/code&gt; -表示呼叫尚未完成。如果您从模拟函数本身内部或模拟所调用的函数内部测试结果，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="3fe7dd9e456ce9a56ae609395aa81b172994f38f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'rejects'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.rejects&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'rejects'&lt;/code&gt; 如果使用promise &lt;code&gt;.rejects&lt;/code&gt; 修饰符调用匹配器，则&amp;ldquo;拒绝&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e00498ab57db7b93c2f28b7b12b8f7e1c69000f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'resolves'&lt;/code&gt; if matcher was called with the promise &lt;code&gt;.resolves&lt;/code&gt; modifier</source>
          <target state="translated">&lt;code&gt;'resolves'&lt;/code&gt; 如果使用promise &lt;code&gt;.resolves&lt;/code&gt; 修饰符调用匹配器，则&amp;ldquo;解决&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="adefff17f597de4d74805fd1199cf58fdab871d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'return'&lt;/code&gt; - Indicates that the call completed by returning normally.</source>
          <target state="translated">&lt;code&gt;'return'&lt;/code&gt; return'-表示通过正常返回已完成呼叫。</target>
        </trans-unit>
        <trans-unit id="076c5e0b99835c5f259fd2816ec766e57cb2d86e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'throw'&lt;/code&gt; - Indicates that the call completed by throwing a value.</source>
          <target state="translated">&lt;code&gt;'throw'&lt;/code&gt; -表示通过抛出一个值来完成呼叫。</target>
        </trans-unit>
        <trans-unit id="95e4e052d6f73f13eb9f5bf76796d91d0771e5d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.mock&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;.mock&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3243a3eefd59ed3b1ef0411f8d2f9ef7ab6b869c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.resolves&lt;/code&gt; / &lt;code&gt;.rejects&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aab89721f62c7711b7a39834e73ed2a7fa36b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.toBeNull()&lt;/code&gt; is the same as &lt;code&gt;.toBe(null)&lt;/code&gt; but the error messages are a bit nicer. So use &lt;code&gt;.toBeNull()&lt;/code&gt; when you want to check that something is null.</source>
          <target state="translated">&lt;code&gt;.toBeNull()&lt;/code&gt; 与 &lt;code&gt;.toBe(null)&lt;/code&gt; 相同，但错误消息要好一些。因此，当您要检查是否为空时，请使用 &lt;code&gt;.toBeNull()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="104f305e00b892ddcf1d06c035b10b5490d792af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; [string]</target>
        </trans-unit>
        <trans-unit id="f7ca0bd8979a7f74cc25cbae3dbe74989087d213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always&lt;/code&gt;: always send a notification.</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; ：始终发送通知。</target>
        </trans-unit>
        <trans-unit id="8c6c44f3653f92b2c1c2a5de58ace2813f45e746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="022d50ac602b48aff9f8d8e67b52ebc38346cad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;automock&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;automock&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="0783465e37770f804a3fa338742cb29285642410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bail&lt;/code&gt; [number | boolean]</source>
          <target state="translated">&lt;code&gt;bail&lt;/code&gt; [数字| 布尔值]</target>
        </trans-unit>
        <trans-unit id="5edc8e7748215afb6eeb00b3979bb3727afd5bb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; can handle asynchronous code in the same ways that &lt;a href=&quot;asynchronous&quot;&gt;tests can handle asynchronous code&lt;/a&gt; - they can either take a &lt;code&gt;done&lt;/code&gt; parameter or return a promise. For example, if &lt;code&gt;initializeCityDatabase()&lt;/code&gt; returned a promise that resolved when the database was initialized, we would want to return that promise:</source>
          <target state="translated">&lt;code&gt;beforeEach&lt;/code&gt; 和 &lt;code&gt;afterEach&lt;/code&gt; 可以以与&lt;a href=&quot;asynchronous&quot;&gt;测试可以处理异步代码&lt;/a&gt;相同的方式来处理异步代码 -它们可以采用 &lt;code&gt;done&lt;/code&gt; 参数或返回诺言。例如，如果 &lt;code&gt;initializeCityDatabase()&lt;/code&gt; 返回了在初始化数据库时已解决的promise，我们将希望返回该promise：</target>
        </trans-unit>
        <trans-unit id="1aa76bca50406a98255ef02e9f43968260d65f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;browser&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;browser&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="5c365dba5039284274be41ec97d6931d406d1c7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; (clears filter patterns)</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; （清除过滤器图案）</target>
        </trans-unit>
        <trans-unit id="3a96c151e6639e8670e9bdbe30a8b6c06780e8a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheDirectory&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;cacheDirectory&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="7b5729d52a372a388e905516712336cc35653473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change&lt;/code&gt;: send a notification when the status changed.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; ：状态更改时发送通知。</target>
        </trans-unit>
        <trans-unit id="1e923e514d0d8eba3a5d4f42d5c2bb45b0c5de03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clearMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;clearMocks&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="363b6e4c7928db931e518577b11324769a502b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverage&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;collectCoverage&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="77d5f07893a1fda7fc63a1840bbc82b25e18b917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collectCoverageFrom&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;collectCoverageFrom&lt;/code&gt; [array]</target>
        </trans-unit>
        <trans-unit id="22dfb0112951b3b9a5c84109d6afdb9cd84b9777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageDirectory&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;coverageDirectory&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="90eaa41d832548eff8171bf51ba277dd76c6cade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="aecb7be43881b3eeda0756f75c31493d74e428a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; seems to not have any effect.</source>
          <target state="translated">&lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; 似乎没有任何作用。</target>
        </trans-unit>
        <trans-unit id="2212d328766792b35ee8159c2356c029c079182d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageProvider&lt;/code&gt; [string]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7341d7d879c20c26b4133a17744e8ff76387fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageReporters&lt;/code&gt; [array&amp;lt;string | [string, options]&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15415f908cbcc6f834bd96ab5ea0dd1791a0e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageReporters&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;coverageReporters&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="dc39b0fdbc72c893cbb45f06a4c77dc964c9da51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coverageThreshold&lt;/code&gt; [object]</source>
          <target state="translated">&lt;code&gt;coverageThreshold&lt;/code&gt; [对象]</target>
        </trans-unit>
        <trans-unit id="afc66e291a919f7f83c445c247998df66d9ff548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dependencyExtractor&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;dependencyExtractor&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="578ea51611cafa4df7fdc64d59c1dcb405fe8410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe(name, fn)&lt;/code&gt; creates a block that groups together several related tests. For example, if you have a &lt;code&gt;myBeverage&lt;/code&gt; object that is supposed to be delicious but not sour, you could test it with:</source>
          <target state="translated">&lt;code&gt;describe(name, fn)&lt;/code&gt; 创建一个将几个相关测试组合在一起的块。例如，如果您有一个 &lt;code&gt;myBeverage&lt;/code&gt; 对象，该对象应该是美味的而不是酸的，则可以使用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="a747ebf25a9f2fa370e23024faca41ba1a337dab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.each&lt;/code&gt; 可用两个API：</target>
        </trans-unit>
        <trans-unit id="f9a624922279c16d34d13a44532e2a44816d8022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.only.each&lt;/code&gt; 具有两个API：</target>
        </trans-unit>
        <trans-unit id="be072a39475c0433ea29c8a3f3e03e51b6441308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;describe.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;describe.skip.each&lt;/code&gt; 可用两个API：</target>
        </trans-unit>
        <trans-unit id="77bc66969f1fd3507a08fc8554e866f921a0340f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;displayName&lt;/code&gt; [string, object]</source>
          <target state="translated">&lt;code&gt;displayName&lt;/code&gt; [字符串，对象]</target>
        </trans-unit>
        <trans-unit id="99ae6ab4c9dd50d862bc15af0f07ad924c3ea872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errorOnDeprecated&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;errorOnDeprecated&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="16d7cc8c63e72f5826c1d66754d6907d67dd5b1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.any(constructor)&lt;/code&gt; matches anything that was created with the given constructor. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a number:</source>
          <target state="translated">&lt;code&gt;expect.any(constructor)&lt;/code&gt; 匹配使用给定构造函数创建的任何内容。您可以在 &lt;code&gt;toEqual&lt;/code&gt; 或 &lt;code&gt;toBeCalledWith&lt;/code&gt; 中使用它，而不是使用文字值。例如，如果要检查是否使用数字调用了模拟函数：</target>
        </trans-unit>
        <trans-unit id="7b048d4335638b4d1ce30d9e4cea456559c9b724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.anything()&lt;/code&gt; matches anything but &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can use it inside &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt; instead of a literal value. For example, if you want to check that a mock function is called with a non-null argument:</source>
          <target state="translated">&lt;code&gt;expect.anything()&lt;/code&gt; 匹配 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 之外的任何内容。您可以在 &lt;code&gt;toEqual&lt;/code&gt; 或 &lt;code&gt;toBeCalledWith&lt;/code&gt; 中使用它，而不是使用文字值。例如，如果要检查是否使用非空参数调用了模拟函数：</target>
        </trans-unit>
        <trans-unit id="d07e62eaf69f9b58e4a6fd2e376c27adf3aa7352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.arrayContaining(array)&lt;/code&gt; matches a received array which contains all of the elements in the expected array. That is, the expected array is a &lt;strong&gt;subset&lt;/strong&gt; of the received array. Therefore, it matches a received array which contains elements that are &lt;strong&gt;not&lt;/strong&gt; in the expected array.</source>
          <target state="translated">&lt;code&gt;expect.arrayContaining(array)&lt;/code&gt; 匹配接收的数组，该数组包含期望数组中的所有元素。即，期望的数组是接收到的数组的&lt;strong&gt;子集&lt;/strong&gt;。因此，它与接收的数组匹配，该数组包含&lt;strong&gt;不在&lt;/strong&gt;预期数组中的元素。</target>
        </trans-unit>
        <trans-unit id="9ad1cdf0d05ab1b5153ed2dc2199661f84a10214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.assertions(number)&lt;/code&gt; verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="translated">&lt;code&gt;expect.assertions(number)&lt;/code&gt; 验证在测试期间是否调用了一定数量的断言。在测试异步代码时，这通常很有用，以确保实际调用了回调中的断言。</target>
        </trans-unit>
        <trans-unit id="0e7c7a571b63f72abaf51ebbecf601d2e3857d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.extend&lt;/code&gt; also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called &lt;code&gt;toBeDivisibleByExternalValue&lt;/code&gt;, where the divisible number is going to be pulled from an external source.</source>
          <target state="translated">&lt;code&gt;expect.extend&lt;/code&gt; 还支持异步匹配器。异步匹配器返回Promise，因此您需要等待返回的值。让我们使用示例匹配器来说明它们的用法。我们将实现一个名为 &lt;code&gt;toBeDivisibleByExternalValue&lt;/code&gt; 的匹配器，在该匹配器中，将要从外部来源提取可除数。</target>
        </trans-unit>
        <trans-unit id="e5b19b7b55164bf0bc4a0774f7d5a9823dfb8d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.hasAssertions()&lt;/code&gt; verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called.</source>
          <target state="translated">&lt;code&gt;expect.hasAssertions()&lt;/code&gt; 验证在测试期间至少调用了一个断言。在测试异步代码时，这通常很有用，以确保实际调用了回调中的断言。</target>
        </trans-unit>
        <trans-unit id="14ec136e4c871d2955ba2a5ffdb1ec1f46d7ec62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.arrayContaining(array)&lt;/code&gt; matches a received array which does not contain all of the elements in the expected array. That is, the expected array &lt;strong&gt;is not a subset&lt;/strong&gt; of the received array.</source>
          <target state="translated">&lt;code&gt;expect.not.arrayContaining(array)&lt;/code&gt; 匹配接收的数组，该数组不包含期望数组中的所有元素。也就是说，期望的数组&lt;strong&gt;不是&lt;/strong&gt;接收到的数组&lt;strong&gt;的子集&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6547e93ef4972ca16b59d2de583bdf5f8e164aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.objectContaining(object)&lt;/code&gt; matches any received object that does not recursively match the expected properties. That is, the expected object &lt;strong&gt;is not a subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">&lt;code&gt;expect.not.objectContaining(object)&lt;/code&gt; 与任何未递归匹配预期属性的接收对象匹配。即，预期对象&lt;strong&gt;不是&lt;/strong&gt;所接收对象&lt;strong&gt;的子集&lt;/strong&gt;。因此，它与接收的对象匹配，该对象包含的属性&lt;strong&gt;不在&lt;/strong&gt;预期的对象中。</target>
        </trans-unit>
        <trans-unit id="e1a42e0113413fc40756feea32923e172a36b6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringContaining(string)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not contain the exact expected string.</source>
          <target state="translated">&lt;code&gt;expect.not.stringContaining(string)&lt;/code&gt; 如果不是字符串，或者字符串不包含确切的预期字符串，则Expect.not.stringContaining（string）与接收到的值匹配。</target>
        </trans-unit>
        <trans-unit id="ce80cb6e4909d7c37e766e9b73b0bb99a177ade6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.not.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression.</source>
          <target state="translated">&lt;code&gt;expect.not.stringMatching(string | regexp)&lt;/code&gt; 如果不是字符串，或者它是与期望的字符串或正则表达式不匹配的字符串，则Expect.not.stringMatching（string | regexp）与接收到的值匹配。</target>
        </trans-unit>
        <trans-unit id="875e89312fa291d9bbe18c260d1ae180219d97dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.objectContaining(object)&lt;/code&gt; matches any received object that recursively matches the expected properties. That is, the expected object is a &lt;strong&gt;subset&lt;/strong&gt; of the received object. Therefore, it matches a received object which contains properties that &lt;strong&gt;are present&lt;/strong&gt; in the expected object.</source>
          <target state="translated">&lt;code&gt;expect.objectContaining(object)&lt;/code&gt; 匹配任何递归匹配期望属性的接收对象。即，预期对象是所接收对象的&lt;strong&gt;子集&lt;/strong&gt;。因此，它与包含预期对象&lt;strong&gt;中存在的&lt;/strong&gt;属性的接收对象匹配。</target>
        </trans-unit>
        <trans-unit id="873bd2740b6f065fa8199240ea0887a8832c981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringContaining(string)&lt;/code&gt; matches the received value if it is a string that contains the exact expected string.</source>
          <target state="translated">&lt;code&gt;expect.stringContaining(string)&lt;/code&gt; 如果它是一个包含确切预期字符串的字符串，则Expect.stringContaining（string）与接收到的值匹配。</target>
        </trans-unit>
        <trans-unit id="5b225d15ea2692d7f596ad71d130a9431391d603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect.stringMatching(string | regexp)&lt;/code&gt; matches the received value if it is a string that matches the expected string or regular expression.</source>
          <target state="translated">&lt;code&gt;expect.stringMatching(string | regexp)&lt;/code&gt; 如果它是与期望的字符串或正则表达式匹配的字符串，则Expect.stringMatching（string | regexp）与接收到的值匹配。</target>
        </trans-unit>
        <trans-unit id="9601c02013ee7ce5f87da30784a1f36318a5dbff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extraGlobals&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;extraGlobals&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="5f0eae8733557670105e5264b5a44c22eff4ea60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure-change&lt;/code&gt;: send a notification when tests fail or once when it passes.</source>
          <target state="translated">&lt;code&gt;failure-change&lt;/code&gt; ：在测试失败或通过一次时发送通知。</target>
        </trans-unit>
        <trans-unit id="731d19bd21f0367438f616985a2ff9bb56ea0ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;failure&lt;/code&gt;: send a notification when tests fail.</source>
          <target state="translated">&lt;code&gt;failure&lt;/code&gt; ：测试失败时发送通知。</target>
        </trans-unit>
        <trans-unit id="3447be7228fe480161197c25ed455c836a34b766" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findRepos&lt;/code&gt; returns a promise that resolves to a set of repositories contained in the specified path.</source>
          <target state="translated">&lt;code&gt;findRepos&lt;/code&gt; 返回一个promise，该promise解析为指定路径中包含的一组存储库。</target>
        </trans-unit>
        <trans-unit id="5d9914d2c07c082d0ed34f77e91705dbe4bbc7ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; ： &lt;code&gt;Function&lt;/code&gt; 要运行的测试套件，该函数将接收每一行中的参数作为函数参数。</target>
        </trans-unit>
        <trans-unit id="298953e98c7eb6b4e3d57c99810d04acf9d73464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the suite of tests to be ran, this is the function that will receive the test data object.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; ： &lt;code&gt;Function&lt;/code&gt; 要运行的测试套件，这是将接收测试数据对象的功能。</target>
        </trans-unit>
        <trans-unit id="e88d37f959b170e185fc1765849810e31a008cad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the parameters in each row as function arguments, &lt;strong&gt;this will have to be an asynchronous function&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f031349e7b8aa21079964750e0087a33dee28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the parameters in each row as function arguments.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; ： &lt;code&gt;Function&lt;/code&gt; 测试是跑步，这是将每一行中收到的参数作为函数参数的功能。</target>
        </trans-unit>
        <trans-unit id="2984ab4b58b8bc7917002986b3e4bf5c88458ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the test data object, &lt;strong&gt;this will have to be an asynchronous function&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cbe17bb99201c9dc1c9f5c72dd39428e462a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt;: &lt;code&gt;Function&lt;/code&gt; the test to be ran, this is the function that will receive the test data object.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; ： &lt;code&gt;Function&lt;/code&gt; 测试是RAN，这是将接收的测试数据对象的功能。</target>
        </trans-unit>
        <trans-unit id="2604eaf97f1d7be032bcf96b602a694fcf53fdf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceCoverageMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;forceCoverageMatch&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a16227a95685b1c6861bbb5288faab8f371516cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getChangedFilesForRoots&lt;/code&gt; returns a promise that resolves to an object with the changed files and repos.</source>
          <target state="translated">&lt;code&gt;getChangedFilesForRoots&lt;/code&gt; 返回一个承诺，该承诺将解析为具有更改后的文件和存储库的对象。</target>
        </trans-unit>
        <trans-unit id="df6948e0922a81f820a7782be1ef9bc1512a6b41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalConfig&lt;/code&gt;: A representation of Jest's current global configuration</source>
          <target state="translated">&lt;code&gt;globalConfig&lt;/code&gt; ：Jest当前全局配置的表示形式</target>
        </trans-unit>
        <trans-unit id="0ff896286fbcbc481378aeb8259b08bea7f02d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalSetup&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;globalSetup&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="fadaa8f683b3b302e2e7f420e35e198d8dd3816e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globalTeardown&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;globalTeardown&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="231b0edd70628d81723e0ee3029c6b4ff4d9110c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;globals&lt;/code&gt; [object]</source>
          <target state="translated">&lt;code&gt;globals&lt;/code&gt; [对象]</target>
        </trans-unit>
        <trans-unit id="b098b2d9da9708ff9da0d38f84a27a261ab078ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasDeprecationWarnings&lt;/code&gt;, a boolean indicating whether the submitted configuration has deprecation warnings,</source>
          <target state="translated">&lt;code&gt;hasDeprecationWarnings&lt;/code&gt; ，一个布尔值，指示提交的配置是否具有弃用警告，</target>
        </trans-unit>
        <trans-unit id="168717e446575bf3ec4978416afcabfb8701ecd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haste&lt;/code&gt; [object]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db064ee6440350f7fb0be817c2c86fd657c31ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; (updates non-matching snapshots interactively)</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; （以交互方式更新不匹配的快照）</target>
        </trans-unit>
        <trans-unit id="47f259d5680796990604275e6728a88c23c30f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;injectGlobals&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7667493d35310459ba4d865785385e0fa44f0893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isValid&lt;/code&gt;, a boolean indicating whether the configuration is correct or not.</source>
          <target state="translated">&lt;code&gt;isValid&lt;/code&gt; ，一个布尔值，指示配置是否正确。</target>
        </trans-unit>
        <trans-unit id="0e5dc5a7429bd64277c1cfe59c3fd4435cc5ab10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.MockedClass&lt;/code&gt; is available in the &lt;code&gt;@types/jest&lt;/code&gt; module from version &lt;code&gt;24.9.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a7c0f221cdda4b5acafbaa997a1b5cfe32d605" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.MockedFunction&lt;/code&gt; is available in the &lt;code&gt;@types/jest&lt;/code&gt; module from version &lt;code&gt;24.9.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63029f3c42dcfdbd97e5adf642c885fad142d9ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.isolateModules(fn)&lt;/code&gt; goes a step further than &lt;code&gt;jest.resetModules()&lt;/code&gt; and creates a sandbox registry for the modules that are loaded inside the callback function. This is useful to isolate specific modules for every test so that local module state doesn't conflict between tests.</source>
          <target state="translated">&lt;code&gt;jest.isolateModules(fn)&lt;/code&gt; 比 &lt;code&gt;jest.resetModules()&lt;/code&gt; 更进一步，并为在回调函数中加载的模块创建沙箱注册表。这对于隔离每个测试的特定模块很有用，这样本地模块的状态就不会在测试之间发生冲突。</target>
        </trans-unit>
        <trans-unit id="d068ec96dd088b722efa247006c3a09b717017e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; takes a &lt;strong&gt;module factory&lt;/strong&gt; argument. A module factory is a function that returns the mock.</source>
          <target state="translated">&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; 采用&lt;strong&gt;模块工厂&lt;/strong&gt;参数。模块工厂是一个返回模拟的函数。</target>
        </trans-unit>
        <trans-unit id="90135d2aaad054e086325b1d57dde7c03baf6197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: Modifies the plugin key.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; ：修改插件密钥。</target>
        </trans-unit>
        <trans-unit id="e3e41eef750008fd3d9034f9f24ad5c5b838e31f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxConcurrency&lt;/code&gt; [number]</source>
          <target state="translated">&lt;code&gt;maxConcurrency&lt;/code&gt; [数字]</target>
        </trans-unit>
        <trans-unit id="e71100c6b326e78ca130e91a087d319bbd82f524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mockImplementation&lt;/code&gt; can also be used to mock class constructors:</source>
          <target state="translated">&lt;code&gt;mockImplementation&lt;/code&gt; 也可以用来模拟类的构造函数：</target>
        </trans-unit>
        <trans-unit id="e5ac877b649f4b1baf1b0db360ca8a145e29d584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleDirectories&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleDirectories&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a817d22cd4c1efa6fa7dba67c371451f4f6a3e40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleFileExtensions&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleFileExtensions&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="fb213ec185952a1d2e01b63cdfea932216826d7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleNameMapper&lt;/code&gt; [object&amp;lt;string, string | array&amp;lt;string&amp;gt;&amp;gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dbb493ef5de10d974140f3a1a68b88e828b841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;moduleNameMapper&lt;/code&gt; [object&amp;lt;string, string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;moduleNameMapper&lt;/code&gt; [对象&amp;lt;字符串，字符串&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9c30cf8163e2afdc999bcd7e41dcbb5851bb1e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;modulePathIgnorePatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="8d5f993e08e79688971f5c75776fe7729160b62a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modulePaths&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;modulePaths&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d3482e861b97dc8c4ad438b0fde5c9836aa35e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test block.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ： &lt;code&gt;String&lt;/code&gt; 测试块的标题。</target>
        </trans-unit>
        <trans-unit id="6c07e542178b2102b5826b97ac09964d210344a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test plan.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ： &lt;code&gt;String&lt;/code&gt; 测试计划的标题。</target>
        </trans-unit>
        <trans-unit id="6decfba5457add1abca3f7eefd904378908c40d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the suite title from the tagged template expressions.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ： &lt;code&gt;String&lt;/code&gt; 测试套件的标题，使用 &lt;code&gt;$variable&lt;/code&gt; 将测试数据从已标记的模板表达式注入到套件标题中。</target>
        </trans-unit>
        <trans-unit id="8efc7da2c3955c0b1cbac2ceaa166cfe2e82166b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test suite.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ： &lt;code&gt;String&lt;/code&gt; 测试套件的标题。</target>
        </trans-unit>
        <trans-unit id="6c1df03cf669a34600d3198e548795a6077ea6b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: &lt;code&gt;String&lt;/code&gt; the title of the test, use &lt;code&gt;$variable&lt;/code&gt; to inject test data into the test title from the tagged template expressions.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; ： &lt;code&gt;String&lt;/code&gt; 测试的标题，使用 &lt;code&gt;$variable&lt;/code&gt; 从标记的模板表达式中将测试数据注入到测试标题中。</target>
        </trans-unit>
        <trans-unit id="a7ed76fb5c443ad0c959e448b56418dc71e556c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;notify&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="6684ce050bf906e6380898754ff7da6938b703c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notifyMode&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;notifyMode&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="6bd057db2f09c38e1e5b40068f877b8183233331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; (test filename pattern)</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; （测试文件名模式）</target>
        </trans-unit>
        <trans-unit id="4e0c00c34cdc9a83d325ba92d761bc183ce4449f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preset&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;preset&lt;/code&gt; [字串]</target>
        </trans-unit>
        <trans-unit id="7f06be9be723c01ad4d3dbe06ff030523f7706bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prettierPath&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;prettierPath&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="3f43923b4de0a956fd5a89860c63dea4513942ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printer&lt;/code&gt; is a function that serializes a value using existing plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4505df26dc3d3a9cb7331fc60b4a4af4b244e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects: Array&amp;lt;config: ProjectConfig, testPaths: Array&amp;lt;string&amp;gt;&lt;/code&gt;: Includes all the test paths that Jest is watching.</source>
          <target state="translated">&lt;code&gt;projects: Array&amp;lt;config: ProjectConfig, testPaths: Array&amp;lt;string&amp;gt;&lt;/code&gt; ：包括Jest正在监视的所有测试路径。</target>
        </trans-unit>
        <trans-unit id="7e98a5e7e066d6b8bfb3e0e2aa91fa1576bb9d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;projects&lt;/code&gt; [array&amp;lt;string | ProjectConfig&amp;gt;]</source>
          <target state="translated">&lt;code&gt;projects&lt;/code&gt; [array &amp;lt;string | ProjectConfig&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="5b3c05f3ce8e21d04bb61eb33e6e4c93ba2018c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prompt&lt;/code&gt;: Allows user to customize the text in the plugin prompt.</source>
          <target state="translated">&lt;code&gt;prompt&lt;/code&gt; ：允许用户自定义插件提示中的文本。</target>
        </trans-unit>
        <trans-unit id="306725cc0ea4676fa203b49def3e6bf0647bc9e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; (quits)</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; （退出）</target>
        </trans-unit>
        <trans-unit id="21cf61c19fe87ba0d4595c865ab1260b42f36bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt; ships with a Jest preset, so the &lt;code&gt;jest.preset&lt;/code&gt; field of your &lt;code&gt;package.json&lt;/code&gt; should point to &lt;code&gt;react-native&lt;/code&gt;. The preset is a node environment that mimics the environment of a React Native app. Because it doesn't load any DOM or browser APIs, it greatly improves Jest's startup time.</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; 附带一个Jest预设，因此 &lt;code&gt;package.json&lt;/code&gt; 的 &lt;code&gt;jest.preset&lt;/code&gt; 字段应指向 &lt;code&gt;react-native&lt;/code&gt; 。预设是一个模仿React Native应用程序环境的节点环境。由于它不加载任何DOM或浏览器API，因此大大缩短了Jest的启动时间。</target>
        </trans-unit>
        <trans-unit id="fc8b23880a197c5f759c183cce18fb93d6fa1266" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reporters&lt;/code&gt; [array&amp;lt;moduleName | [moduleName, options]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;reporters&lt;/code&gt; [array &amp;lt;moduleName | [moduleName，选项]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="453d841d74b238a64faf3df95c585d289aa91e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;resetMocks&lt;/code&gt; [布尔值]</target>
        </trans-unit>
        <trans-unit id="1ac59f04d9734d7de733a2f890c1829d2243af0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetModules&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;resetModules&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="d82390a2391bf5fe68298d3c71d952e9f3396ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolver&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;resolver&lt;/code&gt; [string]</target>
        </trans-unit>
        <trans-unit id="95d7428212c791b1c98fa85a623f2916661a109d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restoreMocks&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;restoreMocks&lt;/code&gt; [布尔]</target>
        </trans-unit>
        <trans-unit id="116364b62ec3e96c831f81af2e20649d42921165" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDir&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="b69cb276d844fde73a287c56443b24c85290f772" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roots&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;roots&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="b31ac4f04b533e37944cd96caa5c49c10dc74438" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runner&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;runner&lt;/code&gt; [string]</target>
        </trans-unit>
        <trans-unit id="06b042371a36ef0f59de8c40ae970a1ae12fe9cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serialize&lt;/code&gt; is a function that serializes a value using existing plugins.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 是使用现有插件序列化值的功能。</target>
        </trans-unit>
        <trans-unit id="1f7906f5769192dc093bd74f15955d14c8f44353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFiles&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;setupFiles&lt;/code&gt; [数组]</target>
        </trans-unit>
        <trans-unit id="ad182506adf7a1eda3a2fe924a5d6b3ce10e38db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; [array]</source>
          <target state="translated">&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; [array]</target>
        </trans-unit>
        <trans-unit id="43fbd518311c38cec2a05d13e7fc1f39717d244a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slowTestThreshold&lt;/code&gt; [number]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6822a7af0f792c1be02fee0e6557b5f9aa6aa50d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotResolver&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;snapshotResolver&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="020e33ceb836b81269226d47390ae8d910dd3d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;snapshotSerializers&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;snapshotSerializers&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="8ba6dc074f7173c4e5c921c96d6172ca341c31c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success-change&lt;/code&gt;: send a notification when tests pass or once when it fails.</source>
          <target state="translated">&lt;code&gt;success-change&lt;/code&gt; ：测试通过时或失败时发送一次通知。</target>
        </trans-unit>
        <trans-unit id="b6809288cd383ca526de3a95e82dc40029d2ea62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;: send a notification when tests pass.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; ：测试通过时发送通知。</target>
        </trans-unit>
        <trans-unit id="cf4992aa1211cf11eace0fd6194105fe6e748c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt; (test name pattern)</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; （测试名称模式）</target>
        </trans-unit>
        <trans-unit id="2c76e7cef2f994e9bc4b2ffa8fc15c6a863909e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; ： &lt;code&gt;Array&lt;/code&gt; 与被传入的参数数组的 &lt;code&gt;fn&lt;/code&gt; 每一行。</target>
        </trans-unit>
        <trans-unit id="317ad841253c3821eea1c4c55994b13ecd8b83d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Array&lt;/code&gt; of Arrays with the arguments that are passed into the test &lt;code&gt;fn&lt;/code&gt; for each row.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; ： &lt;code&gt;Array&lt;/code&gt; 与被传递到测试的参数阵列的 &lt;code&gt;fn&lt;/code&gt; 为每一行。</target>
        </trans-unit>
        <trans-unit id="78df167d8e2f5e6ab08bd9f9210c72a24c886744" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt;: &lt;code&gt;Tagged Template Literal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; ：带 &lt;code&gt;Tagged Template Literal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ef31fc209febe97d980ae37638eb5b2a4facb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.concurrent.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcda95e9b0529fc2b61bc7a8dbc3dc2c6bc4d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.concurrent.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e1d6a253e014572f876870f47a7bf8881a6a9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.concurrent.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2da762274f49442e7234edf6edec01553d27cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.each&lt;/code&gt; 有两个API可用：</target>
        </trans-unit>
        <trans-unit id="0ee264ff7856e51845623e3380548e788bd1f445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.only.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.only.each&lt;/code&gt; 具有两个API：</target>
        </trans-unit>
        <trans-unit id="3170d96d60bef9c8c8d61879742230e8abe3b3cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test.skip.each&lt;/code&gt; is available with two APIs:</source>
          <target state="translated">&lt;code&gt;test.skip.each&lt;/code&gt; 具有两个API：</target>
        </trans-unit>
        <trans-unit id="221510c066b929b735e5b28457b54416069c92c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironment&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="b44ab06de94eab7f0f3caa84b84945368e2009db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testEnvironmentOptions&lt;/code&gt; [Object]</source>
          <target state="translated">&lt;code&gt;testEnvironmentOptions&lt;/code&gt; [对象]</target>
        </trans-unit>
        <trans-unit id="a93c2fb39aa7e1638720795eae5bfa244798169e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testFailureExitCode&lt;/code&gt; [number]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d7ac195113b99da222c32b46f9f8233407fc14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testMatch&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d243b3891f943423546e59235dcdd8d976817d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testPathIgnorePatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="2ff12f0b18e5c1f64dc7329625443fae51cefdfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;testRegex&lt;/code&gt; [字符串| 数组&amp;lt;字符串&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="17522f05ab6d628a3f251e9b900e451c21411a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testResultsProcessor&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testResultsProcessor&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="b5b73f8cad03992f278bb6a0f26575821f4b0243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testRunner&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testRunner&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="3d21b02e2144b96e6faf94901f49db32825d01c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testSequencer&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testSequencer&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="9fae6874a6857c8913b77a9e7a66b382096704e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testTimeout&lt;/code&gt; [number]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749944ba3e96affa2798b2be0c8f9bdc7c202c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;testURL&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;testURL&lt;/code&gt; [字串]</target>
        </trans-unit>
        <trans-unit id="5c6c63d8dee4860bbe8b897df46edc678e1919d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timers&lt;/code&gt; [string]</source>
          <target state="translated">&lt;code&gt;timers&lt;/code&gt; [字符串]</target>
        </trans-unit>
        <trans-unit id="4a070639a8870b012e0b8c57d45e65d109ab4512" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBe&lt;/code&gt; uses &lt;code&gt;Object.is&lt;/code&gt; to test exact equality. If you want to check the value of an object, use &lt;code&gt;toEqual&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;toBe&lt;/code&gt; 使用 &lt;code&gt;Object.is&lt;/code&gt; 测试完全相等。如果要检查对象的值，请改用 &lt;code&gt;toEqual&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d6b12ce5ef3f1a643ddde1103fc34b4841b2288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeDefined&lt;/code&gt; is the opposite of &lt;code&gt;toBeUndefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeDefined&lt;/code&gt; 与 &lt;code&gt;toBeUndefined&lt;/code&gt; 相反</target>
        </trans-unit>
        <trans-unit id="889cb4e9583e9ce69de99a59a883724a6a884c9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeFalsy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as false</source>
          <target state="translated">&lt;code&gt;toBeFalsy&lt;/code&gt; 匹配 &lt;code&gt;if&lt;/code&gt; 语句视为false的任何内容</target>
        </trans-unit>
        <trans-unit id="4c5324f092772853a6ea4dd06b013577b9f5e80b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeNull&lt;/code&gt; matches only &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeNull&lt;/code&gt; 仅匹配 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3405b1dad40d610da009d8481e79e69e967627b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeTruthy&lt;/code&gt; matches anything that an &lt;code&gt;if&lt;/code&gt; statement treats as true</source>
          <target state="translated">&lt;code&gt;toBeTruthy&lt;/code&gt; 匹配 &lt;code&gt;if&lt;/code&gt; 语句视为true的任何内容</target>
        </trans-unit>
        <trans-unit id="5f24f9d6f2d8651c7998359500de6605bc512b83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBeUndefined&lt;/code&gt; matches only &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toBeUndefined&lt;/code&gt; 仅匹配 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="388131813185919d7c4b9b7ce2e366b3f5c34296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toEqual&lt;/code&gt; recursively checks every field of an object or array.</source>
          <target state="translated">&lt;code&gt;toEqual&lt;/code&gt; 递归检查对象或数组的每个字段。</target>
        </trans-unit>
        <trans-unit id="0f97095c42ff3460af22106bcfc6894981843e89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; [object&amp;lt;string, pathToTransformer | [pathToTransformer, object]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; [object &amp;lt;string，pathToTransformer | [pathToTransformer，对象]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="b32e2b6dc461e4c5c6a8c96613f67aca04ca902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transformIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;transformIgnorePatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="530e289551d0cb4aa78691c9e846cb8a050d78b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; (updates all non-matching snapshots)</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; （更新所有不匹配的快照）</target>
        </trans-unit>
        <trans-unit id="8d05fea48435f8bb30fa51c665fb5ad81d02bcfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmockedModulePathPatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;unmockedModulePathPatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="022b56004e7d1552105c625dc749cbbcb0d70f49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updateConfigAndRun&lt;/code&gt;: Allows you to trigger a test run while the interactive plugin is running.</source>
          <target state="translated">&lt;code&gt;updateConfigAndRun&lt;/code&gt; ：允许您在交互式插件运行时触发测试运行。</target>
        </trans-unit>
        <trans-unit id="7555c9da609a937d25697703fb3b49efefa9685b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt; [boolean]</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; [boolean]</target>
        </trans-unit>
        <trans-unit id="add45525d19083f684e544eb3205026fe6f9e169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;w&lt;/code&gt; (displays watch mode usage / available actions)</source>
          <target state="translated">&lt;code&gt;w&lt;/code&gt; （显示监视模式使用情况/可用动作）</target>
        </trans-unit>
        <trans-unit id="df63f3efa68ef5278ebaa0d9bd8fe291d6f1adce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPathIgnorePatterns&lt;/code&gt; [array&amp;lt;string&amp;gt;]</source>
          <target state="translated">&lt;code&gt;watchPathIgnorePatterns&lt;/code&gt; [array &amp;lt;string&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="a95c27dc635388fdb16992516dd7331adc390021" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchPlugins&lt;/code&gt; [array&amp;lt;string | [string, Object]&amp;gt;]</source>
          <target state="translated">&lt;code&gt;watchPlugins&lt;/code&gt; [array &amp;lt;string | [字符串，对象]&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="91851dffd89e752f2a8e182ae774eeed07101693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;watchman&lt;/code&gt; [boolean]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49a0c0fce1f34eeb9dd0214fd85644975b89abf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note It is recommended to use &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; instead. The &lt;code&gt;jest.mock&lt;/code&gt; API's second argument is a module factory instead of the expected exported module object.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意建议改用&lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt;。该 &lt;code&gt;jest.mock&lt;/code&gt; API的第二个参数是一个模块工厂，而不是预期输出模块对象。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddbe6c8d77331269086ec95d5b210111e1b5ebb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that using &lt;code&gt;'&amp;lt;rootDir&amp;gt;'&lt;/code&gt; as a string token in any other path-based config settings will refer back to this value. So, for example, if you want your &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; config entry to point at the &lt;code&gt;env-setup.js&lt;/code&gt; file at the root of your project, you could set its value to &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/env-setup.js&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;请注意，在任何其他基于路径的配置设置中使用 &lt;code&gt;'&amp;lt;rootDir&amp;gt;'&lt;/code&gt; 作为字符串令牌将引用此值。因此，例如，如果您希望&lt;a href=&quot;#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; &lt;/a&gt;配置条目指向项目根目录下的 &lt;code&gt;env-setup.js&lt;/code&gt; 文件，则可以将其值设置为 &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/env-setup.js&quot;]&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3245e4c0c525edd55a1fcdd702374cc73c464f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;jest.fn(implementation)&lt;/code&gt; is a shorthand for &lt;code&gt;jest.fn().mockImplementation(implementation)&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意： &lt;code&gt;jest.fn(implementation)&lt;/code&gt; 是 &lt;code&gt;jest.fn().mockImplementation(implementation)&lt;/code&gt; 的简写。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09b80413aed034e693fba82c8e6ba876def35e50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; is deprecated in favor of &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：不建议使用 &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; ,而建议使用 &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3469d99eb365107c2b5a8486b65ceb080d7309e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;testRegex&lt;/code&gt; will try to detect test files using the &lt;strong&gt;absolute file path&lt;/strong&gt; therefore having a folder with name that match it will run all the files as tests&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意： &lt;code&gt;testRegex&lt;/code&gt; 将尝试使用&lt;strong&gt;绝对文件路径&lt;/strong&gt;来检测测试文件，因此具有名称与之匹配的文件夹会将所有文件作为测试运行&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ff3531ded2a690b478b53ea6669872105f2983b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: &lt;code&gt;testRegex&lt;/code&gt; will try to detect test files using the &lt;strong&gt;absolute file path&lt;/strong&gt;, therefore, having a folder with a name that matches it will run all the files as tests&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dea36c338e1ec0685907e97bd1e080d581b098" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：仅当您从该项目运行至少一个测试时，才会触发在项目中配置的全局设置模块（使用多项目运行器）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfa556e4ca5fc57d212e06cf6bbf0fe286b5fbdd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: A global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：仅当您从该项目运行至少一个测试时，才会触发在项目中配置的全局拆卸模块（使用多项目运行器）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d02c6dd644e67a3e18203bbf480809bbd1604476" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Any global variables that are defined through &lt;code&gt;globalSetup&lt;/code&gt; can only be read in &lt;code&gt;globalTeardown&lt;/code&gt;. You cannot retrieve globals defined here in your test suites.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：通过 &lt;code&gt;globalSetup&lt;/code&gt; 定义的任何全局变量只能在 &lt;code&gt;globalTeardown&lt;/code&gt; 中读取。您无法在测试套件中检索此处定义的全局变量。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d72424c7302fd6031f30bf655f1399a19b49aca1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;jest.spyOn&lt;/code&gt; also calls the &lt;strong&gt;spied&lt;/strong&gt; method. This is different behavior from most other test libraries. If you want to overwrite the original function, you can use &lt;code&gt;jest.spyOn(object, methodName).mockImplementation(() =&amp;gt; customImplementation)&lt;/code&gt; or &lt;code&gt;object[methodName] = jest.fn(() =&amp;gt; customImplementation);&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：默认情况下， &lt;code&gt;jest.spyOn&lt;/code&gt; 也调用&lt;strong&gt;spied&lt;/strong&gt;方法。这与大多数其他测试库的行为不同。如果要覆盖原始函数，可以使用 &lt;code&gt;jest.spyOn(object, methodName).mockImplementation(() =&amp;gt; customImplementation)&lt;/code&gt; 或 &lt;code&gt;object[methodName] = jest.fn(() =&amp;gt; customImplementation);&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff92012e564f8eaffa118d20c50c70351da45fb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: By default, &lt;code&gt;roots&lt;/code&gt; has a single entry &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; but there are cases where you may want to have multiple roots within one project, for example &lt;code&gt;roots: [&quot;&amp;lt;rootDir&amp;gt;/src/&quot;, &quot;&amp;lt;rootDir&amp;gt;/tests/&quot;]&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：默认情况下， &lt;code&gt;roots&lt;/code&gt; 只有一个条目 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; ,但是在某些情况下，您可能希望在一个项目中拥有多个根目录，例如， &lt;code&gt;roots: [&quot;&amp;lt;rootDir&amp;gt;/src/&quot;, &quot;&amp;lt;rootDir&amp;gt;/tests/&quot;]&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="654f3a05466fc139fdbd676423da234eaeeb606b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: CLI options take precedence over values from the &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：CLI选项优先于&lt;a href=&quot;configuration&quot;&gt;Configuration中的&lt;/a&gt;值。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc547a1465a2bedec561a4ee7304735175d4563a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Core modules, like &lt;code&gt;fs&lt;/code&gt;, are not mocked by default. They can be mocked explicitly, like &lt;code&gt;jest.mock('fs')&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：核心模块，例如 &lt;code&gt;fs&lt;/code&gt; ，默认情况下不被模拟。可以像 &lt;code&gt;jest.mock('fs')&lt;/code&gt; 一样显式地模拟它们。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f88fb518a69761332477b8752972bb36e3b77eb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you are upgrading your react-native application and previously used the &lt;code&gt;jest-react-native&lt;/code&gt; preset, remove the dependency from your &lt;code&gt;package.json&lt;/code&gt; file and change the preset to &lt;code&gt;react-native&lt;/code&gt; instead.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果要升级React-Native应用程序，并且以前使用过 &lt;code&gt;jest-react-native&lt;/code&gt; 预置，请从 &lt;code&gt;package.json&lt;/code&gt; 文件中删除依赖项，然后将预置更改为 &lt;code&gt;react-native&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0830714d92959a808d52247893384954d5e59fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you provide module name without boundaries &lt;code&gt;^$&lt;/code&gt; it may cause hard to spot errors. E.g. &lt;code&gt;relay&lt;/code&gt; will replace all modules which contain &lt;code&gt;relay&lt;/code&gt; as a substring in its name: &lt;code&gt;relay&lt;/code&gt;, &lt;code&gt;react-relay&lt;/code&gt; and &lt;code&gt;graphql-relay&lt;/code&gt; will all be pointed to your stub.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果提供的模块名称无边界 &lt;code&gt;^$&lt;/code&gt; ，可能会导致难以发现错误。例如， &lt;code&gt;relay&lt;/code&gt; 将替换所有包含 &lt;code&gt;relay&lt;/code&gt; 作为其名称中的子字符串的模块： &lt;code&gt;relay&lt;/code&gt; ， &lt;code&gt;react-relay&lt;/code&gt; 和 &lt;code&gt;graphql-relay&lt;/code&gt; 都将指向您的存根。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f81422258f7a098cd45faf5ef4bdd43a45a63cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: If you want to set the timeout for all test files, a good place to do this is in &lt;code&gt;setupFilesAfterEnv&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果要为所有测试文件设置超时，可以在 &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; 中进行设置。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f4dc9d7861274ab2e62663a272189579222ed51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Jest comes with JSDOM@11 by default. Due to JSDOM 12 and newer dropping support for Node 6, Jest is unable to upgrade for the time being. However, you can install a custom &lt;code&gt;testEnvironment&lt;/code&gt; with whichever version of JSDOM you want. E.g. &lt;a href=&quot;https://www.npmjs.com/package/jest-environment-jsdom-thirteen&quot;&gt;jest-environment-jsdom-thirteen&lt;/a&gt;, which has JSDOM@13.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：默认情况下，Jest随附JSDOM @ 11。由于JSDOM 12和对节点6的较新删除支持，Jest目前无法升级。但是，您可以安装定制 &lt;code&gt;testEnvironment&lt;/code&gt; 与取其JSDOM的版本你想要的。例如&lt;a href=&quot;https://www.npmjs.com/package/jest-environment-jsdom-thirteen&quot;&gt;jest-environment-jsdom-thirteen&lt;/a&gt;，它具有JSDOM @ 13。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18cfaa133eaa4a08198b5a6bdaede6aa76594392" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Node modules are automatically mocked when you have a manual mock in place (e.g.: &lt;code&gt;__mocks__/lodash.js&lt;/code&gt;). More info &lt;a href=&quot;manual-mocks#mocking-node-modules&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：当您准备好手动模拟时（例如 &lt;code&gt;__mocks__/lodash.js&lt;/code&gt; ），将自动模拟节点模块。更多信息&lt;a href=&quot;manual-mocks#mocking-node-modules&quot;&gt;在这里&lt;/a&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7b37680e518c9562d1b20b238b957e0975b25f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Setting this option overwrites the default values. Add &lt;code&gt;&quot;text&quot;&lt;/code&gt; or &lt;code&gt;&quot;text-summary&quot;&lt;/code&gt; to see a coverage summary in the console output.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：设置此选项将覆盖默认值。添加 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;text-summary&quot;&lt;/code&gt; 以在控制台输出中查看覆盖率摘要。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd5d7a04d9f60617951367c692c674f878b4d3ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：TestEnvironment是沙盒。每个测试套件将在自己的TestEnvironment中触发设置/拆卸。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c18c919f8dac5a6c8256d9066dc763fe50b700dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The &lt;code&gt;runner&lt;/code&gt; property value can omit the &lt;code&gt;jest-runner-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意： &lt;code&gt;runner&lt;/code&gt; 属性值可以省略包名称的 &lt;code&gt;jest-runner-&lt;/code&gt; 前缀。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcf7dcc966f94fef3966960384230930aced5aa8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：默认的正则表达式匹配在小批量运行时效果很好，但是如果提供了多种模式和/或针对大量测试，则匹配速度会变慢。该选项取代了正则表达式匹配逻辑，从而优化了Jest过滤特定测试文件所花费的时间&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfa9163fcbea16af564621dc70234283c02d3dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The default timeout interval is 5 seconds if this method is not called.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果未调用此方法，则默认超时间隔为5秒。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e63787225224750cba830a505303efd48b28af5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：regex与全名匹配，该全名是测试名及其周围所有describe块的组合。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c2b5593cd2040bc5dc88584b808f0f16c4ca911" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The same caveat concerning transformation of &lt;code&gt;node_modules&lt;/code&gt; as for &lt;code&gt;globalSetup&lt;/code&gt; applies to &lt;code&gt;globalTeardown&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注：有关的转化同样需要注意的 &lt;code&gt;node_modules&lt;/code&gt; 为 &lt;code&gt;globalSetup&lt;/code&gt; 适用于 &lt;code&gt;globalTeardown&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9de8c744892d1e80ade401b930bb5ff3026cf2c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: The values in the &lt;code&gt;watchPlugins&lt;/code&gt; property value can omit the &lt;code&gt;jest-watch-&lt;/code&gt; prefix of the package name.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意： &lt;code&gt;watchPlugins&lt;/code&gt; 属性值中的值可以省略包名称的 &lt;code&gt;jest-watch-&lt;/code&gt; 前缀。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6c45b41431661431ff756e996dd1a842ee53e18" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This does not change the exit code in the case of Jest errors (e.g. invalid configuration).&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b193c345406ce52fa75396583c484af4b0680e02" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This option is only supported using &lt;code&gt;jest-circus&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ef76a1f1ec3f0291cffbabb3da084f7d88dec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This option requires &lt;code&gt;collectCoverage&lt;/code&gt; to be set to true or Jest to be invoked with &lt;code&gt;--coverage&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：此选项要求将 &lt;code&gt;collectCoverage&lt;/code&gt; 设置为true或使用 &lt;code&gt;--coverage&lt;/code&gt; 调用Jest 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="47d1171d233bfb1c984686159fc340c7de69fc8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: When using multi project runner, it's recommended to add a &lt;code&gt;displayName&lt;/code&gt; for each project. This will show the &lt;code&gt;displayName&lt;/code&gt; of a project next to its tests.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：使用多项目运行器时，建议为每个项目添加一个 &lt;code&gt;displayName&lt;/code&gt; 。这将在测试旁边显示项目的 &lt;code&gt;displayName&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b5eabe5b43bec4b22b3493a93c1b7d5c70079a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: When using multi-project runner, it's recommended to add a &lt;code&gt;displayName&lt;/code&gt; for each project. This will show the &lt;code&gt;displayName&lt;/code&gt; of a project next to its tests.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238890f1d64dab554fbd8e7a47a71c12a5527b7a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While &lt;code&gt;rootDir&lt;/code&gt; is mostly used as a token to be re-used in other configuration options, &lt;code&gt;roots&lt;/code&gt; is used by the internals of Jest to locate &lt;strong&gt;test files and source files&lt;/strong&gt;. This applies also when searching for manual mocks for modules from &lt;code&gt;node_modules&lt;/code&gt; (&lt;code&gt;__mocks__&lt;/code&gt; will need to live in one of the &lt;code&gt;roots&lt;/code&gt;).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：尽管 &lt;code&gt;rootDir&lt;/code&gt; 通常用作令牌，以便在其他配置选项中重复使用，但Jest内部人员使用 &lt;code&gt;roots&lt;/code&gt; 来查找&lt;strong&gt;测试文件和源文件&lt;/strong&gt;。当从 &lt;code&gt;node_modules&lt;/code&gt; 搜索模块的手动模拟时，这也适用（ &lt;code&gt;__mocks__&lt;/code&gt; 将需要存在于其中一个 &lt;code&gt;roots&lt;/code&gt; ）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aad471e5c15682503858f775c8abc45c5311d043" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: While code transformation is applied to the linked setup-file, Jest will &lt;strong&gt;not&lt;/strong&gt; transform any code in &lt;code&gt;node_modules&lt;/code&gt;. This is due to the need to load the actual transformers (e.g. &lt;code&gt;babel&lt;/code&gt; or &lt;code&gt;typescript&lt;/code&gt;) to perform transformation.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：将代码转换应用于链接的安装文件时，Jest &lt;strong&gt;不会&lt;/strong&gt;转换 &lt;code&gt;node_modules&lt;/code&gt; 中的任何代码。这是由于需要加载实际的转换器（例如 &lt;code&gt;babel&lt;/code&gt; 或 &lt;code&gt;typescript&lt;/code&gt; ）以执行转换。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a3ae755807348e7fb49961bf4febadf54502822" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: You can pass additional options to the istanbul reporter using the tuple form. For example:&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418af2dac0b05fa2cb9f81b3f930b355f006be8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: a transformer is only run once per file unless the file has changed. During development of a transformer it can be useful to run Jest with &lt;code&gt;--no-cache&lt;/code&gt; to frequently &lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;delete Jest's cache&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：除非文件已更改，否则每个文件转换器仅运行一次。在开发转换器的过程中，使用带有 &lt;code&gt;--no-cache&lt;/code&gt; 的&lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;Jest&lt;/a&gt;来频繁删除Jest的缓存可能是有用的。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11782ca85a139bac465c5ee421062fbc0ff9c11d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: a transformer is only run once per file unless the file has changed. During the development of a transformer it can be useful to run Jest with &lt;code&gt;--no-cache&lt;/code&gt; to frequently &lt;a href=&quot;troubleshooting#caching-issues&quot;&gt;delete Jest's cache&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482df035eced9bdb0040d455527831161176059c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using babel-jest with additional code preprocessors, you have to explicitly define babel-jest as a transformer for your JavaScript code to map &lt;code&gt;.js&lt;/code&gt; files to the babel-jest module.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果将babel-jest与其他代码预处理器一起使用，则必须显式定义babel-jest作为JavaScript代码的转换器，以将 &lt;code&gt;.js&lt;/code&gt; 文件映射到babel-jest模块。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="987bdba952341368e9fdda0bef0beeff5ba6fefd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if you are using the &lt;code&gt;babel-jest&lt;/code&gt; transformer and want to use an additional code preprocessor, keep in mind that when &quot;transform&quot; is overwritten in any way the &lt;code&gt;babel-jest&lt;/code&gt; is not loaded automatically anymore. If you want to use it to compile JavaScript code it has to be explicitly defined. See &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;babel-jest plugin&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：如果您正在使用 &lt;code&gt;babel-jest&lt;/code&gt; 转换器，并且想要使用其他代码预处理器，请记住，以任何方式覆盖&amp;ldquo; transform&amp;rdquo;时， &lt;code&gt;babel-jest&lt;/code&gt; 都不会自动加载。如果要使用它来编译JavaScript代码，则必须明确定义它。参见&lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;babel-jest插件&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f0ca3af28debded1b6575b80dc6e1d40989ed7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOff&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;disableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOff&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：此方法以前称为 &lt;code&gt;autoMockOff&lt;/code&gt; 。使用 &lt;code&gt;babel-jest&lt;/code&gt; 时，对 &lt;code&gt;disableAutomock&lt;/code&gt; 的调用将自动提升到代码块的顶部。如果要明确避免此行为，请使用 &lt;code&gt;autoMockOff&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db84e7f21a1dc5ea39ab8f33265d09f707ee968c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: this method was previously called &lt;code&gt;autoMockOn&lt;/code&gt;. When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;enableAutomock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use &lt;code&gt;autoMockOn&lt;/code&gt; if you want to explicitly avoid this behavior.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;注意：此方法以前称为 &lt;code&gt;autoMockOn&lt;/code&gt; 。使用 &lt;code&gt;babel-jest&lt;/code&gt; 时，对 &lt;code&gt;enableAutomock&lt;/code&gt; 的调用将自动提升到代码块的顶部。如果要明确避免此行为，请使用 &lt;code&gt;autoMockOn&lt;/code&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d66dd026515afbcd809e51a9b29dde09f040d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: when adding additional code transformers, this will overwrite the default config and &lt;code&gt;babel-jest&lt;/code&gt; is no longer automatically loaded. If you want to use it to compile JavaScript or Typescript, it has to be explicitly defined by adding &lt;code&gt;{&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;}&lt;/code&gt; to the transform property. See &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/babel-jest#setup&quot;&gt;babel-jest plugin&lt;/a&gt;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7299bad6f178500fdc51abcc8e1569c344960ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This means when you are using &lt;code&gt;test.each&lt;/code&gt; you cannot set the table asynchronously within a &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;beforeAll&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;注意：&lt;/em&gt;这意味着当您使用 &lt;code&gt;test.each&lt;/code&gt; 时，不能在 &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;beforeAll&lt;/code&gt; 内异步设置表。</target>
        </trans-unit>
        <trans-unit id="241f4f76ffa23db053fa98e7e031ed5504849944" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. &lt;code&gt;[1, 2, 3] -&amp;gt; [[1], [2], [3]]&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;如果传入一维基元数组，则在内部将其映射到表，即 &lt;code&gt;[1, 2, 3] -&amp;gt; [[1], [2], [3]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4754ed111a2e95c412ef07bc2c997fbd065c98bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: If you supply a test callback function then the &lt;code&gt;test.todo&lt;/code&gt; will throw an error. If you have already implemented the test and it is broken and you do not want it to run, then use &lt;code&gt;test.skip&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：如果提供测试回调函数，则 &lt;code&gt;test.todo&lt;/code&gt; 将引发错误。如果您已经实施了该测试并且该测试已损坏并且您不希望其运行，请改用 &lt;code&gt;test.skip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="729bd471822307d2a8eeaa5067f5939172676b34" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In TypeScript, when using &lt;code&gt;@types/jest&lt;/code&gt; for example, you can declare the new &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher like this:</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：在TypeScript中，例如，当使用 &lt;code&gt;@types/jest&lt;/code&gt; ，您可以像这样声明新的 &lt;code&gt;toBeWithinRange&lt;/code&gt; 匹配器：</target>
        </trans-unit>
        <trans-unit id="805558c4459d4279d217184007c9f85365097ba1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The ideal configuration for Babel will depend on your project.&lt;/em&gt; See &lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel's docs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47e6352c36ff3c98347b31a0de45d69527492e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note: Arrow functions won't work&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;注意：箭头功能将不起作用&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bce92dff88fcb38cb2ef321db1576b644934c39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And you're good to go!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;而且你很好走！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f47b7739e2f44e81da3d675dbe29d4cd4cfbea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Babel 6 support&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Babel 6支持&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4ed73bcda472b169441fc4a9dd816aaabf9dc85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Beware:&lt;/strong&gt; Jest uses &lt;a href=&quot;https://github.com/mikaelbr/node-notifier&quot;&gt;node-notifier&lt;/a&gt; to display desktop notifications. On Windows, it creates a new start menu entry on the first use and not display the notification. Notifications will be properly displayed on subsequent runs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d549a077eab38cced620afe6afdb993c9ceab815" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Making your Babel config jest-aware&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使Babel配置变得开玩笑&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3c3de6e563d40a11c1426be3aa604177c1e48e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If the key for your plugin already exists as a default key, your plugin will override that key.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如果您插件的密钥已经作为默认密钥存在，那么您的插件将覆盖该密钥。</target>
        </trans-unit>
        <trans-unit id="77fe3aedc23c7d8702924c934dd835e094300fe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you do call &lt;code&gt;updateConfigAndRun&lt;/code&gt;, your &lt;code&gt;run&lt;/code&gt; method should not resolve to a truthy value, as that would trigger a double-run.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如果确实调用 &lt;code&gt;updateConfigAndRun&lt;/code&gt; ，则 &lt;code&gt;run&lt;/code&gt; 方法不应解析为真实值，因为这将触发两次运行。</target>
        </trans-unit>
        <trans-unit id="e2f90b799d6842bd0a0a8b24f41ee816215aadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The ideal configuration for Babel will depend on your project.&lt;/strong&gt; See &lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel's docs&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;Babel的理想配置将取决于您的项目。&lt;/strong&gt;有关更多详细信息，请参见&lt;a href=&quot;https://babeljs.io/docs/en/&quot;&gt;Babel的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce668cf7d663ed9bc164df218d8d07075d83d288" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Importing a module in a setup file (as specified by &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt;) will prevent mocking for the module in question, as well as all the modules that it imports.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;将模块导入设置文件中（由 &lt;code&gt;setupTestFrameworkScriptFile&lt;/code&gt; 指定）将防止对所讨论的模块及其所导入的所有模块进行模拟。</target>
        </trans-unit>
        <trans-unit id="6e782c9c810486eccfdccdb83eabb6b178a1382e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You just successfully wrote your first test using Jest!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您刚刚使用Jest成功编写了您的第一个测试！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b0bb22c03cbc1ff18563b0958776167824861c6" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with an &lt;code&gt;expand&lt;/code&gt; option. When Jest is called with the &lt;code&gt;--expand&lt;/code&gt; flag, &lt;code&gt;this.expand&lt;/code&gt; can be used to determine if Jest is expected to show full diffs and errors.</source>
          <target state="translated">一个布尔值，用于通知您此匹配器是通过 &lt;code&gt;expand&lt;/code&gt; 选项调用的。当使用 &lt;code&gt;--expand&lt;/code&gt; 标志调用Jest时，此 &lt;code&gt;this.expand&lt;/code&gt; 可用于确定是否期望Jest显示完整的差异和错误。</target>
        </trans-unit>
        <trans-unit id="012dbb44ad2f6ca0c20c7b97c1ddcb94d414c9f2" translate="yes" xml:space="preserve">
          <source>A boolean to let you know this matcher was called with the negated &lt;code&gt;.not&lt;/code&gt; modifier allowing you to display a clear and correct matcher hint (see example code).</source>
          <target state="translated">一个使您知道此匹配器的布尔值，使用否定的 &lt;code&gt;.not&lt;/code&gt; 修饰符调用该布尔值，从而使您可以显示清晰正确的匹配器提示（请参见示例代码）。</target>
        </trans-unit>
        <trans-unit id="af490ebca4384b8349fd5f9297146f2aec7a3fc0" translate="yes" xml:space="preserve">
          <source>A glob pattern relative to</source>
          <target state="translated">一个球状图案相对于</target>
        </trans-unit>
        <trans-unit id="81a9685a5ac9f87da00ac92497aa32a446bf0e5f" translate="yes" xml:space="preserve">
          <source>A glob pattern relative to &lt;code&gt;rootDir&lt;/code&gt; matching the files that coverage info needs to be collected from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b7d8c7a67b8a17e4270a68f699bf890194473c" translate="yes" xml:space="preserve">
          <source>A limitation with the factory parameter is that, since calls to &lt;code&gt;jest.mock()&lt;/code&gt; are hoisted to the top of the file, it's not possible to first define a variable and then use it in the factory. An exception is made for variables that start with the word 'mock'. It's up to you to guarantee that they will be initialized on time! For example, the following will throw an out-of-scope error due to the use of 'fake' instead of 'mock' in the variable declaration:</source>
          <target state="translated">factory参数的局限性在于，由于对 &lt;code&gt;jest.mock()&lt;/code&gt; 的调用被提升到文件的顶部，因此无法先定义变量然后在工厂中使用它。以'mock'开头的变量例外。您有责任保证它们会按时初始化！例如，由于在变量声明中使用'fake'而不是'mock'，以下内容将引发范围外错误：</target>
        </trans-unit>
        <trans-unit id="b38da5fb413d73285571b89440d31882e9fc2da6" translate="yes" xml:space="preserve">
          <source>A list of paths to directories that Jest should use to search for files in.</source>
          <target state="translated">Jest应该用来搜索文件的目录路径列表。</target>
        </trans-unit>
        <trans-unit id="cfcb41fe8954fc025d854be9b9598a2ec86464ce" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment immediately before executing the test code itself.</source>
          <target state="translated">运行一些代码来配置或设置测试环境的模块的路径列表。每个setupFile将在每个测试文件中运行一次。由于每个测试都在自己的环境中运行,所以在执行测试代码本身之前,这些脚本将在测试环境中立即执行。</target>
        </trans-unit>
        <trans-unit id="a1baa33cdf6b5032ccc206f32e87cd88f80ef4e5" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing framework before each test file in the suite is executed. Since &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e1bd291245533c3461bfdd8ed955a870554cea" translate="yes" xml:space="preserve">
          <source>A list of paths to modules that run some code to configure or set up the testing framework before each test. Since &lt;a href=&quot;#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt;&lt;/a&gt; executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment.</source>
          <target state="translated">在每次测试之前，运行一些代码以配置或设置测试框架的模块的路径列表。由于&lt;a href=&quot;#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; &lt;/a&gt;是在环境中安装测试框架之前执行的，因此该脚本文件为您提供了在环境中安装了测试框架之后立即运行一些代码的机会。</target>
        </trans-unit>
        <trans-unit id="418f7a1fe2ae7327be6076c7526644e5f6102913" translate="yes" xml:space="preserve">
          <source>A list of paths to snapshot serializer modules Jest should use for snapshot testing.</source>
          <target state="translated">Jest应该用于快照测试的快照序列器模块的路径列表。</target>
        </trans-unit>
        <trans-unit id="5a46db07aaab9152f5a9b72c5970e6d46fe37d14" translate="yes" xml:space="preserve">
          <source>A list of reporter names that Jest uses when writing coverage reports. Any &lt;a href=&quot;https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib&quot;&gt;istanbul reporter&lt;/a&gt; can be used.</source>
          <target state="translated">Jest在编写覆盖率报告时使用的报告人姓名列表。可以使用任何&lt;a href=&quot;https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib&quot;&gt;伊斯坦布尔记者&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d797858943503ae3b78db0da91254fb350d8f26" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to module names or to arrays of module names that allow to stub out resources, like images or styles with a single module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd310121e376e1ef1248ca973cafa088db8588" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to module names that allow to stub out resources, like images or styles with a single module.</source>
          <target state="translated">一个从正则表达式到模块名的映射,允许用一个模块支取资源,如图片或样式。</target>
        </trans-unit>
        <trans-unit id="afbb4445101ad97243b8289debfa31eaae9f2e48" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files. For example, if you wanted to be able to use a new language feature in your modules or tests that aren't yet supported by node, you might plug in one of many compilers that compile a future version of JavaScript to a current one. Example: see the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;examples/typescript&lt;/a&gt; example or the &lt;a href=&quot;webpack&quot;&gt;webpack tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7d829b1f4fd705d3b5320bfde131a522e2ecc3" translate="yes" xml:space="preserve">
          <source>A map from regular expressions to paths to transformers. A transformer is a module that provides a synchronous function for transforming source files. For example, if you wanted to be able to use a new language feature in your modules or tests that isn't yet supported by node, you might plug in one of many compilers that compile a future version of JavaScript to a current one. Example: see the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;examples/typescript&lt;/a&gt; example or the &lt;a href=&quot;webpack&quot;&gt;webpack tutorial&lt;/a&gt;.</source>
          <target state="translated">从正则表达式到转换器路径的映射。转换器是提供同步功能以转换源文件的模块。例如，如果您希望能够在模块或测试中使用节点尚不支持的新语言功能，则可以插入许多将JavaScript的未来版本编译为当前版本的编译器之一。示例：请参见&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/typescript/package.json#L16&quot;&gt;示例/打字稿&lt;/a&gt;示例或&lt;a href=&quot;webpack&quot;&gt;webpack教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29ea19c50da9069cc4d49aa47baff8528c53ac76" translate="yes" xml:space="preserve">
          <source>A new object will be created each time the mock constructor function is called during tests. To spy on method calls in all of these objects, we populate &lt;code&gt;playSoundFile&lt;/code&gt; with another mock function, and store a reference to that same mock function in our test file, so it's available during tests.</source>
          <target state="translated">每次在测试期间调用模拟构造函数时，都会创建一个新对象。为了监视所有这些对象中的方法调用，我们用另一个模拟函数填充 &lt;code&gt;playSoundFile&lt;/code&gt; ，并将对该相同模拟函数的引用存储在我们的测试文件中，因此在测试期间可用。</target>
        </trans-unit>
        <trans-unit id="160f997798a9fad1ea7cbbac49992e492f385217" translate="yes" xml:space="preserve">
          <source>A number limiting the number of tests that are allowed to run at the same time when using &lt;code&gt;test.concurrent&lt;/code&gt;. Any test above this limit will be queued and executed once a slot is released.</source>
          <target state="translated">一个数字，用于限制使用 &lt;code&gt;test.concurrent&lt;/code&gt; 时允许同时运行的测试数量。一旦释放插槽，任何超过此限制的测试都会排队并执行。</target>
        </trans-unit>
        <trans-unit id="36dc2aec80d27ca5f391ce3fab1f19651dbe2e41" translate="yes" xml:space="preserve">
          <source>A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a &lt;code&gt;jest-preset.json&lt;/code&gt; or &lt;code&gt;jest-preset.js&lt;/code&gt; file at the root.</source>
          <target state="translated">用作Jest配置基础的预设。预设应该指向在根目录下具有 &lt;code&gt;jest-preset.json&lt;/code&gt; 或 &lt;code&gt;jest-preset.js&lt;/code&gt; 文件的npm模块。</target>
        </trans-unit>
        <trans-unit id="371782ecc77ce4aff2f7102c108e974456414ab4" translate="yes" xml:space="preserve">
          <source>A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">在执行测试之前，与所有测试路径匹配的regexp模式字符串。在Windows上，您将需要使用 &lt;code&gt;/&lt;/code&gt; 作为路径分隔符或将 &lt;code&gt;\&lt;/code&gt; 用作 &lt;code&gt;\\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="771c72cf637d4dc2b4dcc0ad878cbe45a19120be" translate="yes" xml:space="preserve">
          <source>A set of global variables that need to be available in all test environments.</source>
          <target state="translated">一组需要在所有测试环境中使用的全局变量。</target>
        </trans-unit>
        <trans-unit id="fb9f21925e50fbc4c20514cc0b67d91ec78b66ca" translate="yes" xml:space="preserve">
          <source>A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js&quot;&gt;example test&lt;/a&gt; for a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js&quot;&gt;Link component&lt;/a&gt;:</source>
          <target state="translated">测试React组件时可以采用类似的方法。您可以使用测试渲染器为React树快速生成可序列化的值，而不是渲染需要构建整个应用程序的图形UI。考虑以下针对&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js&quot;&gt;链接组件的&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js&quot;&gt;示例测试&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8f3f3cc749a42e125fb041eeb2151de773021c2b" translate="yes" xml:space="preserve">
          <source>A string allowing you to display a clear and correct matcher hint:</source>
          <target state="translated">一个字符串,允许你显示一个清晰和正确的匹配器提示。</target>
        </trans-unit>
        <trans-unit id="4b045dcedc246b83978bc16fd0119acaf1bb3450" translate="yes" xml:space="preserve">
          <source>A typical snapshot test case for a mobile app renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.</source>
          <target state="translated">一个典型的移动应用快照测试用例是渲染一个UI组件,获取一个快照,然后将其与存储在测试旁边的参考快照文件进行比较。如果两个快照不匹配,测试就会失败:要么是变化是意外的,要么是参考快照需要更新到UI组件的新版本。</target>
        </trans-unit>
        <trans-unit id="2f659b13f3a9c8ac656b43e9f52f4edde8ac293b" translate="yes" xml:space="preserve">
          <source>A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a27227dfd567fa1e14aded42955e64a1211e71" translate="yes" xml:space="preserve">
          <source>A webpack example</source>
          <target state="translated">一个webpack的例子</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="4a8b7c1d861ff3818c82461eaba792c636764ff9" translate="yes" xml:space="preserve">
          <source>Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself &amp;ndash; the only difference is that the implementation will also be executed when the mock is called.</source>
          <target state="translated">接受应用作模拟实现的函数。模拟本身仍然会记录所有进入的调用以及来自自身的实例&amp;ndash;唯一的区别是，在调用模拟时也会执行实现。</target>
        </trans-unit>
        <trans-unit id="179d3db7494b4a55ec9382c56b083999dab4097c" translate="yes" xml:space="preserve">
          <source>Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.</source>
          <target state="translated">接受一个函数,该函数将作为mock的实现,用于对被模拟函数的一次调用。可以通过链式方式使多个函数调用产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="a9e5417eb3ede5aa3146561fc2e7f28ecffcd802" translate="yes" xml:space="preserve">
          <source>Accepts a string to use in test result output in place of &quot;jest.fn()&quot; to indicate which mock function is being referenced.</source>
          <target state="translated">接受一个字符串,用于在测试结果输出中代替 &quot;jest.fn()&quot;,以指示正在引用哪个模拟函数。</target>
        </trans-unit>
        <trans-unit id="5deee23f2f4af004e724d36935577b403688324b" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more &lt;code&gt;mockReturnValueOnce&lt;/code&gt; values to use, calls will return a value specified by &lt;code&gt;mockReturnValue&lt;/code&gt;.</source>
          <target state="translated">接受一个值，该值将在对模拟函数的一次调用中返回。可以链接起来，以便对模拟函数的后续调用返回不同的值。如果没有更多要使用的 &lt;code&gt;mockReturnValueOnce&lt;/code&gt; 值返回值，则调用将返回由 &lt;code&gt;mockReturnValue&lt;/code&gt; 值指定的值。</target>
        </trans-unit>
        <trans-unit id="3b2e03d6231e5e5d597041e1a89580d10a7c89d6" translate="yes" xml:space="preserve">
          <source>Accepts a value that will be returned whenever the mock function is called.</source>
          <target state="translated">接受一个值,这个值将在每次调用mock函数时返回。</target>
        </trans-unit>
        <trans-unit id="627fd999fe60eb1e9fa61ee59d201b42906b203a" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results.</source>
          <target state="translated">激活测试结果的通知。</target>
        </trans-unit>
        <trans-unit id="56b26cac2f5cd92c194eaf6b35f2ccfb8b632ce9" translate="yes" xml:space="preserve">
          <source>Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.</source>
          <target state="translated">激活测试结果的通知。当你不希望你的意识能够专注于任何事情,除了JavaScript测试时,这是很好的选择。</target>
        </trans-unit>
        <trans-unit id="b2b4d9faf83e823777e17d32c35a1ca5f152a2f8" translate="yes" xml:space="preserve">
          <source>Add the following section to your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">将以下部分添加到您的 &lt;code&gt;package.json&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="b3a19c94e2b8b3963d8f7c38fd24982dd6310852" translate="yes" xml:space="preserve">
          <source>Additional Configuration</source>
          <target state="translated">附加配置</target>
        </trans-unit>
        <trans-unit id="7d97a763f6b6d3194d818e5f34a2dd68b20b1a98" translate="yes" xml:space="preserve">
          <source>Additionally, custom reporters can be configured by passing an &lt;code&gt;options&lt;/code&gt; object as a second argument:</source>
          <target state="translated">此外，可以通过将 &lt;code&gt;options&lt;/code&gt; 对象作为第二个参数传递来配置自定义报告程序：</target>
        </trans-unit>
        <trans-unit id="93f5d5d810fd868ec5f1446605cf43a303b38e7d" translate="yes" xml:space="preserve">
          <source>Additionally, you can substitute captured regex groups using numbered backreferences.</source>
          <target state="translated">此外,您还可以使用编号的反向引用来替换捕获的regex组。</target>
        </trans-unit>
        <trans-unit id="a12f0e8115380c12166066c9e4f273d00f4c44d6" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;location&lt;/code&gt; field to test results. Useful if you want to report the location of a test in a reporter.</source>
          <target state="translated">添加 &lt;code&gt;location&lt;/code&gt; 字段以测试结果。如果要在报告器中报告测试的位置，则很有用。</target>
        </trans-unit>
        <trans-unit id="c7a3d37ab930375cdcd79b34d3b10e75da31c499" translate="yes" xml:space="preserve">
          <source>Advance Timers by Time</source>
          <target state="translated">按时间排列的提前计时器</target>
        </trans-unit>
        <trans-unit id="af9ddf57a7d50c5e6b5eff43535f9164538d33dc" translate="yes" xml:space="preserve">
          <source>Advances all timers by the needed milliseconds so that only the next timeouts/intervals will run.</source>
          <target state="translated">将所有定时器提前所需的毫秒,这样只有下一个超时/间隔才会运行。</target>
        </trans-unit>
        <trans-unit id="cf6e685581823cbf41e050cfa3d4d3efe68f3736" translate="yes" xml:space="preserve">
          <source>After this method is called, all &lt;code&gt;require()&lt;/code&gt;s will return the real versions of each module (rather than a mocked version).</source>
          <target state="translated">调用此方法后，所有 &lt;code&gt;require()&lt;/code&gt; 都将返回每个模块的实际版本（而不是模拟版本）。</target>
        </trans-unit>
        <trans-unit id="42e4edac6675eabca400c0935453060c87c093dd" translate="yes" xml:space="preserve">
          <source>Again, we create a test file in the &lt;code&gt;__tests__/&lt;/code&gt; folder:</source>
          <target state="translated">同样，我们在 &lt;code&gt;__tests__/&lt;/code&gt; 文件夹中创建一个测试文件：</target>
        </trans-unit>
        <trans-unit id="498f0ab72c63ead80a6070eae8d7b90d7385bf05" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;--collectCoverage&lt;/code&gt;. Indicates that test coverage information should be collected and reported in the output. Optionally pass &lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt; to override option set in configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539642d3664ec2813c705bf1656fa80d215afd0" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-b&lt;/code&gt;. Exit the test suite immediately upon &lt;code&gt;n&lt;/code&gt; number of failing test suite. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">别名： &lt;code&gt;-b&lt;/code&gt; 。在 &lt;code&gt;n&lt;/code&gt; 个失败的测试套件后立即退出测试套件。默认为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b8e4f71edefd118d7d38fc0473f59b852337fe6" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-c&lt;/code&gt;. The path to a Jest config file specifying how to find and execute tests. If no &lt;code&gt;rootDir&lt;/code&gt; is set in the config, the directory containing the config file is assumed to be the &lt;code&gt;rootDir&lt;/code&gt; for the project. This can also be a JSON-encoded value which Jest will use as configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f545c267035a3769cec67deb4d85dbdea5ed4279" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-c&lt;/code&gt;. The path to a Jest config file specifying how to find and execute tests. If no &lt;code&gt;rootDir&lt;/code&gt; is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.</source>
          <target state="translated">别名： &lt;code&gt;-c&lt;/code&gt; 。Jest配置文件的路径，该路径指定如何查找和执行测试。如果在配置中未设置 &lt;code&gt;rootDir&lt;/code&gt; ，则假定包含配置文件的目录为项目的rootDir。这也可以是Jest将用作配置的JSON编码值。</target>
        </trans-unit>
        <trans-unit id="d5168880339d67b2e370e60c0c6ab283939bd91e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-e&lt;/code&gt;. Use this flag to show full diffs and errors instead of a patch.</source>
          <target state="translated">别名： &lt;code&gt;-e&lt;/code&gt; 。使用此标志显示完整的差异和错误，而不是补丁。</target>
        </trans-unit>
        <trans-unit id="99493a7a51fd254391a3ebbc240c428c0990c61c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-i&lt;/code&gt;. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.</source>
          <target state="translated">别名： &lt;code&gt;-i&lt;/code&gt; 。在当前进程中串行运行所有测试，而不是创建运行测试的子进程的工作程序池。这对于调试很有用。</target>
        </trans-unit>
        <trans-unit id="2552460fa09d12f47cce10ce54895c78e5d11fe6" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-o&lt;/code&gt;. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).</source>
          <target state="translated">别名： &lt;code&gt;-o&lt;/code&gt; 。尝试根据当前存储库中已更改的文件来确定要运行的测试。仅当您当前正在git / hg存储库中运行测试并且需要静态依赖关系图（即，没有动态要求）时，此方法才有效。</target>
        </trans-unit>
        <trans-unit id="8a0722768635f39bb520a598cac25b8461c84a1e" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-t&lt;/code&gt;. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like &lt;code&gt;&quot;GET /api/posts with auth&quot;&lt;/code&gt;, then you can use &lt;code&gt;jest -t=auth&lt;/code&gt;.</source>
          <target state="translated">别名： &lt;code&gt;-t&lt;/code&gt; 。仅运行名称与正则表达式匹配的测试。例如，假设您只想运行与授权相关的测试，这些测试的名称将类似于 &lt;code&gt;&quot;GET /api/posts with auth&quot;&lt;/code&gt; ，那么您可以使用 &lt;code&gt;jest -t=auth&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa1a34b400f2f90695824c1275bc4ed1fcfc281" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-u&lt;/code&gt;. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with &lt;code&gt;--testNamePattern&lt;/code&gt; to re-record snapshots.</source>
          <target state="translated">别名： &lt;code&gt;-u&lt;/code&gt; 。使用此标志可以重新记录在此测试运行期间失败的每个快照。可以与测试套件模式或 &lt;code&gt;--testNamePattern&lt;/code&gt; 一起使用，以重新记录快照。</target>
        </trans-unit>
        <trans-unit id="0ecc088a9387041c13956d514f3c30314c61256c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-v&lt;/code&gt;. Print the version and exit.</source>
          <target state="translated">别名： &lt;code&gt;-v&lt;/code&gt; 。打印版本并退出。</target>
        </trans-unit>
        <trans-unit id="9514d4a998cf0be55fdd8c1f8b3ab17496d0b427" translate="yes" xml:space="preserve">
          <source>Alias: &lt;code&gt;-w&lt;/code&gt;. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.</source>
          <target state="translated">别名： &lt;code&gt;-w&lt;/code&gt; 。指定工作池为运行测试而产生的最大工作程序数。在单运行模式下，此默认值是计算机上可用的内核数减去主线程的内核数。在监视模式下，这默认为计算机上可用内核的一半，以确保Jest不引人注目并且不会使计算机停止运行。在资源有限的环境（例如CI）中进行调整可能会很有用，但是默认值对于大多数用例而言都足够了。</target>
        </trans-unit>
        <trans-unit id="f293634d4b71e268b9315270803e95d567d5c055" translate="yes" xml:space="preserve">
          <source>All mock functions have this special &lt;code&gt;.mock&lt;/code&gt; property, which is where data about how the function has been called and what the function returned is kept. The &lt;code&gt;.mock&lt;/code&gt; property also tracks the value of &lt;code&gt;this&lt;/code&gt; for each call, so it is possible to inspect this as well:</source>
          <target state="translated">所有模拟函数都具有此特殊的 &lt;code&gt;.mock&lt;/code&gt; 属性，该属性保存有关如何调用函数以及返回的函数的数据。该 &lt;code&gt;.mock&lt;/code&gt; 物业还跟踪的值 &lt;code&gt;this&lt;/code&gt; 对于每个呼叫，所以它可以检查这个问题，以及：</target>
        </trans-unit>
        <trans-unit id="d200710c4a1cb0a5518adeb855b420c9df2492c3" translate="yes" xml:space="preserve">
          <source>All you need in a test file is the &lt;code&gt;test&lt;/code&gt; method which runs a test. For example, let's say there's a function &lt;code&gt;inchesOfRain()&lt;/code&gt; that should be zero. Your whole test could be:</source>
          <target state="translated">测试文件中需要的只是运行测试的 &lt;code&gt;test&lt;/code&gt; 方法。例如，假设有一个函数 &lt;code&gt;inchesOfRain()&lt;/code&gt; 应该为零。您的整个测试可能是：</target>
        </trans-unit>
        <trans-unit id="9c6cdf6ad0cf9e05d26b92de733df230ae967936" translate="yes" xml:space="preserve">
          <source>Allows for a label to be printed along side a test while it is running. This becomes more useful in multiproject repositories where there can be many jest configuration files. This visually tells which project a test belongs to. Here are sample valid values.</source>
          <target state="translated">允许在测试运行时在测试旁边打印标签。这在多项目资源库中变得更加有用,因为在多项目资源库中可以有许多jest配置文件。这可以直观地告诉测试属于哪个项目。以下是有效值的例子。</target>
        </trans-unit>
        <trans-unit id="ec3c69fa3b017ac0bcaefe40085f730e1e89bb78" translate="yes" xml:space="preserve">
          <source>Allows for a label to be printed alongside a test while it is running. This becomes more useful in multi-project repositories where there can be many jest configuration files. This visually tells which project a test belongs to. Here are sample valid values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2d2b88484d26d6b0274df05b58474c9355339d" translate="yes" xml:space="preserve">
          <source>Allows the test suite to pass when no files are found.</source>
          <target state="translated">当没有找到文件时,允许测试套件通过。</target>
        </trans-unit>
        <trans-unit id="8833fbee71692506c4f7dc88add13d227f32d2be" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting&quot;&gt;watchman troubleshooting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee11433796f7928eadda086f2e6317eba0f644e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting.html&quot;&gt;watchman troubleshooting&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://facebook.github.io/watchman/docs/troubleshooting.html&quot;&gt;值班员疑难解答&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d05449ec644146648e1a3867b71af1336f54702e" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.genMockFromModule(moduleName)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ded90d6a8a58f29b63088540765e42efe71e66" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastCalledWith(arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="translated">还要使用别名： &lt;code&gt;.lastCalledWith(arg1, arg2, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72068b84899b93d08efebb5fbde5f86a2871fab0" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.lastReturnedWith(value)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.lastReturnedWith(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="099a9c56b2ffb0e433746f2d5a063a53bf87848e" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthCalledWith(nthCall, arg1, arg2, ...)&lt;/code&gt;</source>
          <target state="translated">还要使用别名： &lt;code&gt;.nthCalledWith(nthCall, arg1, arg2, ...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e71518680860b6335bd23e9b151d1d48ae804594" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.nthReturnedWith(nthCall, value)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.nthReturnedWith(nthCall, value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a976e7b6194d79232f8dd968730fcf8fa8de0bd4" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.runTimersToTime()&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.runTimersToTime()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="395cc025e9320dbca3e418277a47146fbe85a545" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalled()&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toBeCalled()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1b36b77a3b08255bd86abb689d07b9d3cda7cd8" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledTimes(number)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toBeCalledTimes(number)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab40e2a7cc91a41899b406bbf45e995ae8a0ccb3" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toBeCalledWith()&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toBeCalledWith()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f135f1b735c2c08a602b278941f22ef918f12f6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturn()&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toReturn()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc7e9d708812efa106b415eb4de6b5bc6cf9f969" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnTimes(number)&lt;/code&gt;</source>
          <target state="translated">还要使用别名： &lt;code&gt;.toReturnTimes(number)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba2bf1dae2731b6f4c302617ced0c81f8cbe1e1d" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toReturnWith(value)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toReturnWith(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05408f6b685f91d674e7459a4e02a520c37b9ff6" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;.toThrowError(error?)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;.toThrowError(error?)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c1feacec240ab724aed9abf11d8481d5be016bb" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;fdescribe(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;fdescribe(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aa5b0deb73cbf5bf4609fd6f9f31b133a58ef15" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0b5be3bc982588651b6b8ae5b13e8895d0bbd2d" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.concurrent(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d9b12c69589fa55802b57cab67ab14b15bac49" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.concurrent.each(table)(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a637016fe2405c3e1f1b3e077d22ba100d7c626" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.concurrent.only.each(table)(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0858248c0d567d4a023da11423198ed6fbc1f102" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.concurrent.skip.each(table)(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f02580bb5866da485a9c58917275f794f170733" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;it.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it.each(table)(name, fn)&lt;/code&gt; 和 &lt;code&gt;it.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6bb21b7a535407f42cd02fc4332a2d9f72dad24" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;it.todo(name)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86566af6d287f431b2f25caf18aaacdb4fe0fed9" translate="yes" xml:space="preserve">
          <source>Also under the alias: &lt;code&gt;xdescribe(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;xdescribe(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f49a6ff10db6d3abd0202c575a4990526242f321" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;fdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;fdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;fdescribe.each(table)(name, fn)&lt;/code&gt; 和 &lt;code&gt;fdescribe.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df617fb63c786231166be551a69c544fb3bc875f" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt; or &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt; 或 &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aab76bfe379e97812fe97d6c141e7dbe32566eac" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only(name, fn, timeout)&lt;/code&gt;, and &lt;code&gt;fit(name, fn, timeout)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a927b33c56953bae3577b5390aba2c2c4cb3bc" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.only.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;fit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.only.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;fit.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it.only.each(table)(name, fn)&lt;/code&gt; ， &lt;code&gt;fit.each(table)(name, fn)&lt;/code&gt; ， &lt;code&gt;it.only.each`table`(name, fn)&lt;/code&gt; 和 &lt;code&gt;fit.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7b5764e499cb8d78c16305a6528c4899aa522b4" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip(name, fn)&lt;/code&gt; or &lt;code&gt;xit(name, fn)&lt;/code&gt; or &lt;code&gt;xtest(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it.skip(name, fn)&lt;/code&gt; 或 &lt;code&gt;xit(name, fn)&lt;/code&gt; 或 &lt;code&gt;xtest(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e66f0d01b0411f802201c26db0f54fd9cea7984d" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip(name, fn)&lt;/code&gt;, &lt;code&gt;xit(name, fn)&lt;/code&gt;, and &lt;code&gt;xtest(name, fn)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae7b77488478baa85c14484c98a4586556a4adf" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;it.skip.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;xtest.each(table)(name, fn)&lt;/code&gt;, &lt;code&gt;it.skip.each`table`(name, fn)&lt;/code&gt;, &lt;code&gt;xit.each`table`(name, fn)&lt;/code&gt; and &lt;code&gt;xtest.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;it.skip.each(table)(name, fn)&lt;/code&gt; ， &lt;code&gt;xit.each(table)(name, fn)&lt;/code&gt; ， &lt;code&gt;xtest.each(table)(name, fn)&lt;/code&gt; ， &lt;code&gt;it.skip.each`table`(name, fn)&lt;/code&gt; ， &lt;code&gt;xit.each`table`(name, fn)&lt;/code&gt; 和 &lt;code&gt;xtest.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebaf7711efc2429bdcc957d7601bf8b98792f7e8" translate="yes" xml:space="preserve">
          <source>Also under the aliases: &lt;code&gt;xdescribe.each(table)(name, fn)&lt;/code&gt; and &lt;code&gt;xdescribe.each`table`(name, fn)&lt;/code&gt;</source>
          <target state="translated">同样在别名下： &lt;code&gt;xdescribe.each(table)(name, fn)&lt;/code&gt; 和 &lt;code&gt;xdescribe.each`table`(name, fn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09523aba51788d839f21a8368cdbeff7d157bb04" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">或者，您可以将 &lt;code&gt;async/await&lt;/code&gt; 与 &lt;code&gt;.rejects&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="287ce7bb7699bc441de5c565dd6f0ff136cd6f02" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async/await&lt;/code&gt; in combination with &lt;code&gt;.resolves&lt;/code&gt;:</source>
          <target state="translated">或者，您可以将 &lt;code&gt;async/await&lt;/code&gt; 与 &lt;code&gt;.resolves&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="683a48469ae34941c2dfe3c02609cb488fc9cf6e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; in your tests. To write an async test, use the &lt;code&gt;async&lt;/code&gt; keyword in front of the function passed to &lt;code&gt;test&lt;/code&gt;. For example, the same &lt;code&gt;fetchData&lt;/code&gt; scenario can be tested with:</source>
          <target state="translated">另外，您可以在测试中使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 。要编写异步测试，请在传递给 &lt;code&gt;test&lt;/code&gt; 的函数前面使用 &lt;code&gt;async&lt;/code&gt; 关键字。例如，可以使用以下命令测试相同的 &lt;code&gt;fetchData&lt;/code&gt; 方案：</target>
        </trans-unit>
        <trans-unit id="e70e3500483b9c230e96ed71d6eb2850d7817875" translate="yes" xml:space="preserve">
          <source>Although Jest may be considered a React-specific test runner, in fact it is a universal testing platform, with the ability to adapt to any JavaScript library or framework. In this section we'd like to link to community posts and articles about integrating Jest into other popular JS libraries.</source>
          <target state="translated">虽然Jest可能被认为是React专用的测试运行器,但实际上它是一个通用的测试平台,能够适应任何JavaScript库或框架。在本节中,我们想链接到关于将Jest集成到其他流行的JS库中的社区帖子和文章。</target>
        </trans-unit>
        <trans-unit id="7f675838f49f79bd87cbdc6aa6c10ac099c8d1a7" translate="yes" xml:space="preserve">
          <source>Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.</source>
          <target state="translated">虽然可以手动编写快照文件,但那通常是无法接近的。快照有助于弄清测试所覆盖的模块的输出是否发生了变化,而不是一开始就给设计代码提供指导。</target>
        </trans-unit>
        <trans-unit id="aebd1363c6cc98b159d0cd54a133b3010fd2af74" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;.toBe&lt;/code&gt; matcher &lt;strong&gt;checks&lt;/strong&gt; referential identity, it &lt;strong&gt;reports&lt;/strong&gt; a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, to assert whether or not elements are the same instance:</source>
          <target state="translated">尽管 &lt;code&gt;.toBe&lt;/code&gt; 匹配器&lt;strong&gt;检查&lt;/strong&gt;引用身份，但如果断言失败，它将&lt;strong&gt;报告&lt;/strong&gt;值的深层比较。如果属性之间的差异不能帮助您理解测试失败的原因，尤其是在报告较大的情况下，则可以将比较结果移入 &lt;code&gt;expect&lt;/code&gt; 函数。例如，要断言元素是否为同一实例：</target>
        </trans-unit>
        <trans-unit id="5588d7b29731ae809c64e5bdc946641ff8cdc8da" translate="yes" xml:space="preserve">
          <source>Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.</source>
          <target state="translated">总是努力为快照使用描述性的测试和/或快照名称。最好的名称能描述预期的快照内容。这样可以让审查人员在审查过程中更容易验证快照,也可以让任何人在更新之前知道一个过时的快照是否是正确的行为。</target>
        </trans-unit>
        <trans-unit id="bf3cd7d4822e4172301955fdbd34bbf3ead80369" translate="yes" xml:space="preserve">
          <source>An Async Example</source>
          <target state="translated">一个异步实例</target>
        </trans-unit>
        <trans-unit id="6b45a17cec3531985bca09a2f51e8258c6a164d8" translate="yes" xml:space="preserve">
          <source>An ES6 Class Example</source>
          <target state="translated">ES6类实例</target>
        </trans-unit>
        <trans-unit id="9503b02977c75b74fc98515eaf543859ba4a5b20" translate="yes" xml:space="preserve">
          <source>An alternative API to setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, &lt;code&gt;modulePaths&lt;/code&gt; is an array of absolute paths to additional locations to search when resolving modules. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/app/&quot;]&lt;/code&gt;.</source>
          <target state="translated">设置 &lt;code&gt;NODE_PATH&lt;/code&gt; env变量的另一种API ， &lt;code&gt;modulePaths&lt;/code&gt; 是解析模块时要搜索的其他位置的绝对路径的数组。使用 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 字符串标记来包含项目根目录的路径。示例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/app/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c18c5e14d9b27331affd203c3ba0a5ea7a448a7c" translate="yes" xml:space="preserve">
          <source>An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.</source>
          <target state="translated">一个数组,包含对这个模拟函数的所有调用的调用参数,数组中的每一项都是调用时传递的参数数组。数组中的每一项都是调用时传递的参数数组。</target>
        </trans-unit>
        <trans-unit id="a46ce930eedbd7ddf653339853dcb9a903d0d421" translate="yes" xml:space="preserve">
          <source>An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a &lt;code&gt;type&lt;/code&gt; property, and a &lt;code&gt;value&lt;/code&gt; property. &lt;code&gt;type&lt;/code&gt; will be one of the following:</source>
          <target state="translated">一个数组，其中包含对该模拟函数进行的所有调用的结果。该数组中的每个条目都是一个包含 &lt;code&gt;type&lt;/code&gt; 属性和 &lt;code&gt;value&lt;/code&gt; 属性的对象。 &lt;code&gt;type&lt;/code&gt; 将是以下之一：</target>
        </trans-unit>
        <trans-unit id="31d55820d20196b774de801007398d7381eb5e21" translate="yes" xml:space="preserve">
          <source>An array of &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;glob patterns&lt;/a&gt; indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.</source>
          <target state="translated">一组&lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;glob模式，&lt;/a&gt;指示一组应为其收集覆盖率信息的文件。如果文件与指定的glob模式匹配，则即使该文件不存在测试，也将为其收集覆盖率信息，并且在测试套件中从不需要它。</target>
        </trans-unit>
        <trans-unit id="2d3bdf241dff3305fbf27dbe0b111fd6f3b0eab9" translate="yes" xml:space="preserve">
          <source>An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.</source>
          <target state="translated">一个正则函数模式的数组,在观察模式下重新运行测试之前,会对所有源文件路径进行匹配。如果文件路径与任何一个模式匹配,当它被更新时,将不会触发重新运行测试。</target>
        </trans-unit>
        <trans-unit id="b6e893f728a32633130f596bfb0591acef847120" translate="yes" xml:space="preserve">
          <source>An array of directory names to be searched recursively up from the requiring module's location. Setting this option will &lt;em&gt;override&lt;/em&gt; the default, if you wish to still search &lt;code&gt;node_modules&lt;/code&gt; for packages include it along with any other options: &lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;]&lt;/code&gt;</source>
          <target state="translated">从需求模块的位置开始递归搜索的目录名称数组。如果您仍然希望搜索 &lt;code&gt;node_modules&lt;/code&gt; 以查找包含它的软件包以及其他任何选项，则设置此选项将&lt;em&gt;覆盖&lt;/em&gt;默认值： &lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="504281b83c6e81672ff2b065f899819937fcacff" translate="yes" xml:space="preserve">
          <source>An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.</source>
          <target state="translated">您的模块所使用的文件扩展名的数组。如果您需要的模块没有指定文件扩展名,这些是 Jest 将寻找的扩展名,从左到右的顺序。</target>
        </trans-unit>
        <trans-unit id="b68561e3089004cad3aab8c72147f145d5ad00d9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.</source>
          <target state="translated">一个regexp模式字符串的数组,在执行测试前与所有文件路径匹配。如果文件路径与任何模式匹配,则跳过覆盖信息。</target>
        </trans-unit>
        <trans-unit id="87abc2e394f90095864df40d50a17bb32b006523" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be &lt;code&gt;require()&lt;/code&gt;-able in the test environment.</source>
          <target state="translated">在将所有模块路径视为对模块加载器&amp;ldquo;可见&amp;rdquo;之前，已对所有模块路径进行匹配的正则表达式模式字符串数组。如果给定模块的路径与任何模式匹配，则在测试环境中将不是 &lt;code&gt;require()&lt;/code&gt; - able。</target>
        </trans-unit>
        <trans-unit id="f96ebc6e5bdb81dd85cf0fb671eb2514e1041de9" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.</source>
          <target state="translated">一个regexp模式的数组,在模块加载器自动返回模块之前,这些模式会与所有模块进行匹配。如果一个模块的路径匹配了这个列表中的任何一种模式,那么模块加载器将不会自动对其进行嘲讽。</target>
        </trans-unit>
        <trans-unit id="af6404a872edd8e55e2e1adae4ddcdf7e2a10352" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all source file paths before transformation. If the test path matches any of the patterns, it will not be transformed.</source>
          <target state="translated">一个regexp模式字符串的数组,在转换前与所有源文件路径匹配。如果测试路径与任何模式匹配,则不会被转换。</target>
        </trans-unit>
        <trans-unit id="95938a1191b9cbb1d990900f10c57777a2e1ed42" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.</source>
          <target state="translated">一个regexp模式字符串的数组,在执行测试前与所有测试路径进行匹配。如果测试路径与任何模式相匹配,则会被跳过。</target>
        </trans-unit>
        <trans-unit id="79f18094ded093d426110192ffd26b3eb9d01981" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to &lt;code&gt;--testPathPattern&lt;/code&gt;, it will only run those tests with a path that does not match with the provided regexp expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462ad2f4a8409549d0f759cb0132577334a47d4c" translate="yes" xml:space="preserve">
          <source>An array of regexp pattern strings that is tested against all tests paths before executing the test. Contrary to &lt;code&gt;--testPathPattern&lt;/code&gt;, it will only run those test with a path that does not match with the provided regexp expressions.</source>
          <target state="translated">在执行测试之前，针对所有测试路径测试的regexp模式字符串数组。与 &lt;code&gt;--testPathPattern&lt;/code&gt; 相反，它将仅使用与提供的regexp表达式不匹配的路径运行那些测试。</target>
        </trans-unit>
        <trans-unit id="1ada50d1e8326b688b4e15a2802d96af20f6a4b7" translate="yes" xml:space="preserve">
          <source>An array that contains all the object instances that have been instantiated from this mock function using &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">一个数组，其中包含使用 &lt;code&gt;new&lt;/code&gt; 从此模拟函数实例化的所有对象实例。</target>
        </trans-unit>
        <trans-unit id="7c5d2ee3d8eaab26feb4c41b55794ee099a28cca" translate="yes" xml:space="preserve">
          <source>An example of such function can be found in our default &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts&quot;&gt;jasmine2 test runner package&lt;/a&gt;.</source>
          <target state="translated">可以在我们的默认&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/index.ts&quot;&gt;jasmine2测试运行程序包中&lt;/a&gt;找到此类功能的示例。</target>
        </trans-unit>
        <trans-unit id="607f0bc7049c328734f7e81696dd602383afb610" translate="yes" xml:space="preserve">
          <source>And More</source>
          <target state="translated">以及更多</target>
        </trans-unit>
        <trans-unit id="8e09ac014c181587ec460524c0658c52a8de5d93" translate="yes" xml:space="preserve">
          <source>And finally, we have to handle the webpack &lt;code&gt;alias&lt;/code&gt;. For that we can make use of the &lt;code&gt;moduleNameMapper&lt;/code&gt; option again.</source>
          <target state="translated">最后，我们必须处理webpack &lt;code&gt;alias&lt;/code&gt; 。为此，我们可以再次使用 &lt;code&gt;moduleNameMapper&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d2c9c0958208daa2556dd5d31b01c301f6798193" translate="yes" xml:space="preserve">
          <source>And finally, we have to handle the webpack &lt;code&gt;alias&lt;/code&gt;. For that, we can make use of the &lt;code&gt;moduleNameMapper&lt;/code&gt; option again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbc245e76c3e8b9a776e2d6e639bb997d2acd75" translate="yes" xml:space="preserve">
          <source>And it will generate the following snapshot:</source>
          <target state="translated">并且会生成以下快照。</target>
        </trans-unit>
        <trans-unit id="6b3a68e32529c05dce55087b82076e0dc6576f89" translate="yes" xml:space="preserve">
          <source>And the mock files themselves:</source>
          <target state="translated">而模拟文件本身。</target>
        </trans-unit>
        <trans-unit id="8e09000e5c2a6bef346596ec2e0dec0fbf7495a6" translate="yes" xml:space="preserve">
          <source>Angular</source>
          <target state="translated">Angular</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="742a5629f9bbfed1143d85bb3d0a7ea7fc795192" translate="yes" xml:space="preserve">
          <source>Another alternative to expediting test execution time on Continuous Integration Servers such as Travis-CI is to set the max worker pool to ~&lt;em&gt;4&lt;/em&gt;. Specifically on Travis-CI, this can reduce test execution time in half. Note: The Travis CI &lt;em&gt;free&lt;/em&gt; plan available for open source projects only includes 2 CPU cores.</source>
          <target state="translated">对持续集成服务器，如特拉维斯-CI加速测试执行时间另一种方法是将最大工作池设置为〜&lt;em&gt;4&lt;/em&gt;。特别是在Travis-CI上，这可以将测试执行时间减少一半。注意：可用于开源项目的Travis CI &lt;em&gt;免费&lt;/em&gt;计划仅包括2个CPU内核。</target>
        </trans-unit>
        <trans-unit id="5d396fa096245e4ff526d431e1fdc7511c337853" translate="yes" xml:space="preserve">
          <source>Another class of functions that is often considered difficult to test is code that directly manipulates the DOM. Let's see how we can test the following snippet of jQuery code that listens to a click event, fetches some data asynchronously and sets the content of a span.</source>
          <target state="translated">另一类通常被认为难以测试的函数是直接操作DOM的代码。让我们看看如何测试下面这段jQuery代码,它监听一个点击事件,异步获取一些数据,并设置一个span的内容。</target>
        </trans-unit>
        <trans-unit id="893f79ed3ff3f37c6371db618f971f7d16027030" translate="yes" xml:space="preserve">
          <source>Another possibility is use &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt;. When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via setTimeout() or setInterval(), and would be executed during this time frame, will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue that should be run within msToRun milliseconds.</source>
          <target state="translated">另一种可能性是使用 &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt; 。调用此API时，所有计时器都会提前 &lt;code&gt;msToRun&lt;/code&gt; 毫秒。将通过setTimeout（）或setInterval（）排队并在此时间段内执行的所有未决&amp;ldquo;宏任务&amp;rdquo;将被执行。此外，如果这些宏任务计划将在同一时间范围内执行的新宏任务，则将执行这些宏任务，直到队列中没有剩余应在msToRun毫秒内运行的宏任务为止。</target>
        </trans-unit>
        <trans-unit id="e958f896cbf96983eca8579647667623b58bd6bc" translate="yes" xml:space="preserve">
          <source>Another possibility is use &lt;code&gt;jest.advanceTimersByTime(msToRun)&lt;/code&gt;. When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via setTimeout() or setInterval(), and would be executed during this time frame, will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue that should be run within msToRun milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3836d5626c7fcd443d2b13b3c90a168aeac159" translate="yes" xml:space="preserve">
          <source>Another test we might want to write for this module is one that asserts that the callback is called after 1 second. To do this, we're going to use Jest's timer control APIs to fast-forward time right in the middle of the test:</source>
          <target state="translated">我们可能要为这个模块写的另一个测试是,申明回调在1秒后被调用。要做到这一点,我们将使用Jest的定时器控制API,在测试的中间快进时间。</target>
        </trans-unit>
        <trans-unit id="4a103c34b8de331bd76f45b2403f7aed399db936" translate="yes" xml:space="preserve">
          <source>Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with it's value set to an empty string. If the pragma is not present, it will not be present in the object.</source>
          <target state="translated">测试文件中的任何docblock pragma都将被传递给环境构造函数,并可用于每个测试的配置。如果pragma没有值,它将存在于对象中,并将其值设置为一个空字符串。如果pragma不存在,它将不会出现在对象中。</target>
        </trans-unit>
        <trans-unit id="28185007478800c46df321f4963fa9abca12af92" translate="yes" xml:space="preserve">
          <source>Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with its value set to an empty string. If the pragma is not present, it will not be present in the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62674adc2fd45e062316f5e05f5f083ea662d480" translate="yes" xml:space="preserve">
          <source>Any given value that is not a matcher will be checked exactly and saved to the snapshot:</source>
          <target state="translated">任何给定的不是匹配器的值都会被精确检查并保存到快照中。</target>
        </trans-unit>
        <trans-unit id="5c5b7ea7bd8c1a3b846217990f58a7237946847e" translate="yes" xml:space="preserve">
          <source>Any key not used by built-in functionality can be claimed, as you would expect. Try to avoid using keys that are difficult to obtain on various keyboards (e.g. &lt;code&gt;&amp;eacute;&lt;/code&gt;, &lt;code&gt;&amp;euro;&lt;/code&gt;), or not visible by default (e.g. many Mac keyboards do not have visual hints for characters such as &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, etc.)</source>
          <target state="translated">如您所料，可以声明未由内置功能使用的任何密钥。尽量避免使用难以在各种键盘上获得的键（例如 &lt;code&gt;&amp;eacute;&lt;/code&gt; ， &lt;code&gt;&amp;euro;&lt;/code&gt; ）或默认情况下不可见的键（例如，许多Mac键盘没有诸如 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;[&lt;/code&gt; 等] 字符的视觉提示）</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="4565f29db31ebc3ed2837a5c66dc7f7115c60784" translate="yes" xml:space="preserve">
          <source>Are snapshots written automatically on Continuous Integration (CI) systems?</source>
          <target state="translated">持续集成(CI)系统的快照是否会自动写入?</target>
        </trans-unit>
        <trans-unit id="1f735920f6b1287b080ec6ef4f28c968da24737c" translate="yes" xml:space="preserve">
          <source>Arguments can also be mixed:</source>
          <target state="translated">论据也可以是混合的。</target>
        </trans-unit>
        <trans-unit id="b5eb7315732ba1dd9aa54c5447ef8251ac1f1a72" translate="yes" xml:space="preserve">
          <source>Array sparseness is checked. e.g. &lt;code&gt;[, 1]&lt;/code&gt; does not match &lt;code&gt;[undefined, 1]&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="translated">检查数组稀疏性。例如 &lt;code&gt;[, 1]&lt;/code&gt; 当使用 &lt;code&gt;.toStrictEqual&lt;/code&gt; 时 &lt;code&gt;[undefined, 1]&lt;/code&gt; [，1]与[undefined，1]不匹配。</target>
        </trans-unit>
        <trans-unit id="b3bc07f8fe3ae265bc1c65271265c09fffe2ede6" translate="yes" xml:space="preserve">
          <source>Arrays and iterables</source>
          <target state="translated">数组和迭代数</target>
        </trans-unit>
        <trans-unit id="74911a9974788ee31baf4332aa46469914fc0018" translate="yes" xml:space="preserve">
          <source>As a secondary option, an object with the properties &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; can be passed. This allows for a custom configuration of the background color of the displayName. &lt;code&gt;displayName&lt;/code&gt; defaults to white when its value is a string. Jest uses &lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;chalk&lt;/a&gt; to provide the color. As such, all of the valid options for colors supported by chalk are also supported by jest.</source>
          <target state="translated">作为辅助选项，可以传递具有属性 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;color&lt;/code&gt; 的对象。这允许对displayName的背景色进行自定义配置。当其值为字符串时， &lt;code&gt;displayName&lt;/code&gt; 默认为白色。笑话使用&lt;a href=&quot;https://github.com/chalk/chalk&quot;&gt;粉笔&lt;/a&gt;提供颜色。这样，玩笑还支持粉笔支持的所有有效颜色选项。</target>
        </trans-unit>
        <trans-unit id="1ce4c489a4e9ecd6d0287803d6407ac937c080c8" translate="yes" xml:space="preserve">
          <source>As an example to show why this is the case, imagine we wrote a test like so:</source>
          <target state="translated">举个例子来说明为什么会这样,想象一下我们写了一个这样的测试。</target>
        </trans-unit>
        <trans-unit id="5bff98a0df6c56f2756da9281d0404c838a0e295" translate="yes" xml:space="preserve">
          <source>As mentioned previously, Jest uses &lt;a href=&quot;https://yarnpkg.com/en/package/pretty-format&quot;&gt;&lt;code&gt;pretty-format&lt;/code&gt;&lt;/a&gt; to make snapshots human-readable, but you may find it useful to introduce additional tools, like &lt;a href=&quot;https://yarnpkg.com/en/package/eslint-plugin-jest&quot;&gt;&lt;code&gt;eslint-plugin-jest&lt;/code&gt;&lt;/a&gt; with its &lt;a href=&quot;https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md&quot;&gt;&lt;code&gt;no-large-snapshots&lt;/code&gt;&lt;/a&gt; option, or &lt;a href=&quot;https://yarnpkg.com/en/package/snapshot-diff&quot;&gt;&lt;code&gt;snapshot-diff&lt;/code&gt;&lt;/a&gt; with its component snapshot comparison feature, to promote committing short, focused assertions.</source>
          <target state="translated">如前所述，Jest使用&lt;a href=&quot;https://yarnpkg.com/en/package/pretty-format&quot;&gt; &lt;code&gt;pretty-format&lt;/code&gt; &lt;/a&gt;使快照易于阅读，但是您可能会发现引入其他工具很有用，例如&lt;a href=&quot;https://yarnpkg.com/en/package/eslint-plugin-jest&quot;&gt; &lt;code&gt;eslint-plugin-jest&lt;/code&gt; &lt;/a&gt;及其&lt;a href=&quot;https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md&quot;&gt; &lt;code&gt;no-large-snapshots&lt;/code&gt; &lt;/a&gt;选项或&lt;a href=&quot;https://yarnpkg.com/en/package/snapshot-diff&quot;&gt; &lt;code&gt;snapshot-diff&lt;/code&gt; &lt;/a&gt;-diff及其组件快照。比较功能，以促进提交简短，集中的断言。</target>
        </trans-unit>
        <trans-unit id="2edb0f24d18bfcbc00e0c78839a1fdf035ed9311" translate="yes" xml:space="preserve">
          <source>Ask questions and find answers from other Jest users like you. &lt;a href=&quot;http://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; is a Discord chat where a lot of Jest discussion happens. Check out the &lt;a href=&quot;https://discord.gg/MWRhKCj&quot;&gt;#jest&lt;/a&gt; channel.</source>
          <target state="translated">提出问题并从其他像您这样的Jest用户那里找到答案。&lt;a href=&quot;http://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt;是一个Discord聊天，其中发生了许多Jest讨论。查看&lt;a href=&quot;https://discord.gg/MWRhKCj&quot;&gt;#jest&lt;/a&gt;频道。</target>
        </trans-unit>
        <trans-unit id="2572458ae5e40f128dca0cd3474767a4531b8611" translate="yes" xml:space="preserve">
          <source>Ask questions and find answers from other Jest users like you. &lt;a href=&quot;https://www.reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; is a Discord chat where a lot of Jest discussion happens. Check out the &lt;code&gt;#testing&lt;/code&gt; channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc2d7716879ffcf62253d1d725243538c0235af" translate="yes" xml:space="preserve">
          <source>Async Matchers</source>
          <target state="translated">异步匹配器</target>
        </trans-unit>
        <trans-unit id="f56a660f0dad726695b31dda5b8891615117ac6d" translate="yes" xml:space="preserve">
          <source>Async/Await</source>
          <target state="translated">Async/Await</target>
        </trans-unit>
        <trans-unit id="e27221756365cd045960f2e94d5cb617a09fd66c" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt; applications.</source>
          <target state="translated">在Facebook，我们使用Jest测试&lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="395b841bd250360a8d39d43d0cc9468e6a191ff3" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; applications.</source>
          <target state="translated">在Facebook，我们使用Jest测试&lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;应用程序。</target>
        </trans-unit>
        <trans-unit id="26e1ace29ede9b23733efdd41268051e094add77" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9e900581878bcbe2cefc6a34137a0abe301bdd" translate="yes" xml:space="preserve">
          <source>At Facebook, we use Jest to test &lt;a href=&quot;https://reactnative.dev/&quot;&gt;React Native&lt;/a&gt; applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cdaf4152db0f4f16342bd19654aceac0ca1e3e" translate="yes" xml:space="preserve">
          <source>Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use &lt;code&gt;--forceExit&lt;/code&gt; in order for Jest to exit to potentially track down the reason. This implies &lt;code&gt;--runInBand&lt;/code&gt;, making tests run serially. Implemented using &lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt;&lt;code&gt;async_hooks&lt;/code&gt;&lt;/a&gt;, so it only works in Node 8 and newer. This option has a significant performance penalty and should only be used for debugging.</source>
          <target state="translated">尝试收集并打印打开的手柄，以防止Jest干净地退出。在需要使用 &lt;code&gt;--forceExit&lt;/code&gt; 以便Jest退出以潜在地查找原因的情况下，请使用此选项。这意味着 &lt;code&gt;--runInBand&lt;/code&gt; ，使测试按顺序运行。使用&lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt; &lt;code&gt;async_hooks&lt;/code&gt; &lt;/a&gt;实现，因此它仅适用于Node 8和更高版本。此选项会严重影响性能，应仅用于调试。</target>
        </trans-unit>
        <trans-unit id="fb0cd6ac355283d9422b06f96d5ad18438c685d6" translate="yes" xml:space="preserve">
          <source>Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use &lt;code&gt;--forceExit&lt;/code&gt; in order for Jest to exit to potentially track down the reason. This implies &lt;code&gt;--runInBand&lt;/code&gt;, making tests run serially. Implemented using &lt;a href=&quot;https://nodejs.org/api/async_hooks.html&quot;&gt;&lt;code&gt;async_hooks&lt;/code&gt;&lt;/a&gt;. This option has a significant performance penalty and should only be used for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6dc28e5599c9cab49b9e2c317821c7dd774121" translate="yes" xml:space="preserve">
          <source>Authorized configuration keys</source>
          <target state="translated">授权的配置键</target>
        </trans-unit>
        <trans-unit id="116210a421ba183e44c078b53f193cdc6fb43a87" translate="yes" xml:space="preserve">
          <source>Automatic mock</source>
          <target state="translated">自动模拟</target>
        </trans-unit>
        <trans-unit id="0219bef967d8f707c8e0246d4db056aae02a5ccf" translate="yes" xml:space="preserve">
          <source>Automatically clear mock calls and instances before every test. Equivalent to calling &lt;code&gt;jest.clearAllMocks()&lt;/code&gt; before each test. This does not remove any mock implementation that may have been provided.</source>
          <target state="translated">每次测试前自动清除模拟调用和实例。等同于在每次测试之前调用 &lt;code&gt;jest.clearAllMocks()&lt;/code&gt; 。这不会删除可能提供的任何模拟实现。</target>
        </trans-unit>
        <trans-unit id="1087f99cc0f32ae4b69ceb38fb06f0ea54c89a40" translate="yes" xml:space="preserve">
          <source>Automatically reset mock state before every test. Equivalent to calling &lt;code&gt;jest.resetAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.</source>
          <target state="translated">每次测试前自动重置模拟状态。等同于在每次测试之前调用 &lt;code&gt;jest.resetAllMocks()&lt;/code&gt; 。这将导致任何模拟都删除其假实现，但不会恢复其初始实现。</target>
        </trans-unit>
        <trans-unit id="1d4c3e6aeec9cba44ed3be7bda907111f3172875" translate="yes" xml:space="preserve">
          <source>Automatically restore mock state before every test. Equivalent to calling &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.</source>
          <target state="translated">每次测试前自动恢复模拟状态。等同于在每次测试之前调用 &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; 。这将导致所有模拟都删除其假实现并恢复其初始实现。</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="2c6957f4f82498b87545ed7a33f9f93969bbb3e6" translate="yes" xml:space="preserve">
          <source>Based on the &lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-262366820&quot;&gt;findings&lt;/a&gt;, one way to mitigate this issue and improve the speed by up to 50% is to run tests sequentially.</source>
          <target state="translated">根据&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-262366820&quot;&gt;发现&lt;/a&gt;，减轻此问题并将速度提高多达50％的一种方法是依次运行测试。</target>
        </trans-unit>
        <trans-unit id="50f2f862e91add8b90e4a6da877a14f5e16eb9dc" translate="yes" xml:space="preserve">
          <source>Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:</source>
          <target state="translated">根据您的项目,Jest会问您几个问题,并为每个选项创建一个带有简短描述的基本配置文件。</target>
        </trans-unit>
        <trans-unit id="fc6bfef866c16d00ea780b8f331139cb8d28b83d" translate="yes" xml:space="preserve">
          <source>Be sure to return the assertion&amp;mdash;if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; is resolved and then() has a chance to execute the callback.</source>
          <target state="translated">确保返回该断言-如果省略此 &lt;code&gt;return&lt;/code&gt; 语句，则测试将在解析 &lt;code&gt;fetchData&lt;/code&gt; 返回的promise之前完成，然后then（）有机会执行回调。</target>
        </trans-unit>
        <trans-unit id="d3f556e536c0e7e0056301601d7417c65940d6ae" translate="yes" xml:space="preserve">
          <source>Be sure to return the promise - if you omit this &lt;code&gt;return&lt;/code&gt; statement, your test will complete before the promise returned from &lt;code&gt;fetchData&lt;/code&gt; resolves and then() has a chance to execute the callback.</source>
          <target state="translated">确保返回诺言-如果省略此 &lt;code&gt;return&lt;/code&gt; 语句，则测试将在 &lt;code&gt;fetchData&lt;/code&gt; 返回的诺言解析之前完成，然后then（）有机会执行回调。</target>
        </trans-unit>
        <trans-unit id="c6ecb1259845cafdad7669438dfd7169e8aa45a3" translate="yes" xml:space="preserve">
          <source>Because floating point errors are the problem that &lt;code&gt;toBeCloseTo&lt;/code&gt; solves, it does not support big integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9fd1717377fe3279d351011475ce90a698762e" translate="yes" xml:space="preserve">
          <source>Because we don't want to go to the network in our test, we are going to create a manual mock for our &lt;code&gt;request.js&lt;/code&gt; module in the &lt;code&gt;__mocks__&lt;/code&gt; folder (the folder is case-sensitive, &lt;code&gt;__MOCKS__&lt;/code&gt; will not work). It could look something like this:</source>
          <target state="translated">因为我们不想在测试中进入网络，所以我们将在 &lt;code&gt;__mocks__&lt;/code&gt; 文件夹中为 &lt;code&gt;request.js&lt;/code&gt; 模块创建一个手动模拟（该文件夹区分大小写， &lt;code&gt;__MOCKS__&lt;/code&gt; 将不起作用）。它可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="64753a59b275da395d2c1dc8b7dcb455fad7c963" translate="yes" xml:space="preserve">
          <source>Below are the hooks available in Jest.</source>
          <target state="translated">以下是Jest中可用的钩子。</target>
        </trans-unit>
        <trans-unit id="36de90e22d47f94d755a4b1bb70aaddc1bb47593" translate="yes" xml:space="preserve">
          <source>Best Practices</source>
          <target state="translated">最佳做法</target>
        </trans-unit>
        <trans-unit id="a1f0fcd3b8d03992c8b96556ac49a857175afecc" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockClear&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="translated">请注意， &lt;code&gt;mockClear&lt;/code&gt; 会替换 &lt;code&gt;mockFn.mock&lt;/code&gt; ，而不仅是&lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt;。因此，您应避免将 &lt;code&gt;mockFn.mock&lt;/code&gt; 分配给其他变量（无论是否为临时变量），以确保您不会访问陈旧的数据。</target>
        </trans-unit>
        <trans-unit id="2ad04e6eef9bf2fc42e98e2756e7912bce91387b" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockClear&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should, therefore, avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ccb5668e93107bc30b0d906bbc9a8b26f7c56" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockFn.mockRestore&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;. Thus you have to take care of restoration yourself when manually assigning &lt;code&gt;jest.fn()&lt;/code&gt;.</source>
          <target state="translated">注意，仅当使用 &lt;code&gt;jest.spyOn&lt;/code&gt; 创建模拟时， &lt;code&gt;mockFn.mockRestore&lt;/code&gt; 才有效。因此，在手动分配 &lt;code&gt;jest.fn()&lt;/code&gt; 时，您必须自己进行恢复。</target>
        </trans-unit>
        <trans-unit id="4b002ef5dff177f13b0153d72646356c1a85e431" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockReset&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should therefore avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="translated">请注意， &lt;code&gt;mockReset&lt;/code&gt; 会替换 &lt;code&gt;mockFn.mock&lt;/code&gt; ，而不仅仅是&lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt;。因此，您应避免将 &lt;code&gt;mockFn.mock&lt;/code&gt; 分配给其他变量（无论是否为临时变量），以确保您不会访问陈旧的数据。</target>
        </trans-unit>
        <trans-unit id="45ab5240b102de6f13f4287853fb89ddcc0fbac6" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;mockReset&lt;/code&gt; will replace &lt;code&gt;mockFn.mock&lt;/code&gt;, not just &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt;. You should, therefore, avoid assigning &lt;code&gt;mockFn.mock&lt;/code&gt; to other variables, temporary or not, to make sure you don't access stale data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb7bb160ae4e03b6bfacba742441ea7d2e578df" translate="yes" xml:space="preserve">
          <source>Browse the docs</source>
          <target state="translated">浏览文档</target>
        </trans-unit>
        <trans-unit id="276a88c140a6bf7107571e0e3473c859f70d5592" translate="yes" xml:space="preserve">
          <source>Building your constructor function mock using &lt;code&gt;jest.fn().mockImplementation()&lt;/code&gt; makes mocks appear more complicated than they really are. This section shows how you can create your own mocks to illustrate how mocking works.</source>
          <target state="translated">使用 &lt;code&gt;jest.fn().mockImplementation()&lt;/code&gt; 构建构造函数模拟会使模拟看起来比实际复杂。本节说明如何创建自己的模拟，以说明模拟的工作方式。</target>
        </trans-unit>
        <trans-unit id="72789db809aebd98e3793977340fa23a403dd9b2" translate="yes" xml:space="preserve">
          <source>By adding a &lt;code&gt;@jest-environment&lt;/code&gt; docblock at the top of the file, you can specify another environment to be used for all tests in that file:</source>
          <target state="translated">通过在文件顶部添加一个 &lt;code&gt;@jest-environment&lt;/code&gt; docblock，可以在该文件中指定另一个用于所有测试的环境：</target>
        </trans-unit>
        <trans-unit id="b227bd0fddcf4b3afa6c30b1668cca67fe27ba27" translate="yes" xml:space="preserve">
          <source>By combining &lt;code&gt;defaultResolver&lt;/code&gt; and &lt;code&gt;packageFilter&lt;/code&gt; we can implement a &lt;code&gt;package.json&lt;/code&gt; &quot;pre-processor&quot; that allows us to change how the default resolver will resolve modules. For example, imagine we want to use the field &lt;code&gt;&quot;module&quot;&lt;/code&gt; if it is present, otherwise fallback to &lt;code&gt;&quot;main&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00c0a22e2d3c1d15a5077c059224da4a8124a5a" translate="yes" xml:space="preserve">
          <source>By default the jest-react-native preset only processes the project's own source files and react-native. If you have npm dependencies that have to be transformed you can customize this configuration option by including modules other than react-native:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64a054e0008020bcca517ad251114bdd878bd10" translate="yes" xml:space="preserve">
          <source>By default the jest-react-native preset only processes the project's own source files and react-native. If you have npm dependencies that have to be transformed you can customize this configuration option by whitelisting modules other than react-native:</source>
          <target state="translated">默认情况下,jest-react-native预设只处理项目自己的源文件和react-native。如果你有npm的依赖关系需要转换,你可以自定义这个配置选项,将react-native以外的模块列入白名单。</target>
        </trans-unit>
        <trans-unit id="24192876f804f24abf879b9436d1771d8dea9d51" translate="yes" xml:space="preserve">
          <source>By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after &lt;code&gt;n&lt;/code&gt; failures. Setting bail to &lt;code&gt;true&lt;/code&gt; is the same as setting bail to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Jest运行所有测试，并在完成后在控制台中产生所有错误。可以在此处使用bail config选项，以使Jest在 &lt;code&gt;n&lt;/code&gt; 次失败后停止运行测试。将bail设置为 &lt;code&gt;true&lt;/code&gt; 与将bail设置为 &lt;code&gt;1&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="1c18e033ac397507497b08aca298046458436f1b" translate="yes" xml:space="preserve">
          <source>By default, Jest tests complete once they reach the end of their execution. That means this test will &lt;em&gt;not&lt;/em&gt; work as intended:</source>
          <target state="translated">默认情况下，Jest测试将在执行结束时完成。这意味着该测试将&lt;em&gt;无法&lt;/em&gt;按预期进行：</target>
        </trans-unit>
        <trans-unit id="84e08a56bb6409c96440829d4111b8fe08c3fc8c" translate="yes" xml:space="preserve">
          <source>By default, each test file gets its own independent module registry. Enabling &lt;code&gt;resetModules&lt;/code&gt; goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that local module state doesn't conflict between tests. This can be done programmatically using &lt;a href=&quot;jest-object#jestresetmodules&quot;&gt;&lt;code&gt;jest.resetModules()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，每个测试文件都有其自己的独立模块注册表。启用 &lt;code&gt;resetModules&lt;/code&gt; 更进一步，并在运行每个单独的测试之前重置模块注册表。这对于隔离每个测试的模块很有用，这样本地模块的状态就不会在测试之间发生冲突。可以使用&lt;a href=&quot;jest-object#jestresetmodules&quot;&gt; &lt;code&gt;jest.resetModules()&lt;/code&gt; &lt;/a&gt;以编程方式完成此操作。</target>
        </trans-unit>
        <trans-unit id="8754ee581c62c7d43535ecba83d0fa7181c5ff17" translate="yes" xml:space="preserve">
          <source>By default, each test file gets its own independent module registry. Enabling &lt;code&gt;resetModules&lt;/code&gt; goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that the local module state doesn't conflict between tests. This can be done programmatically using &lt;a href=&quot;jest-object#jestresetmodules&quot;&gt;&lt;code&gt;jest.resetModules()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd069e07b719971ba572ee8dd0ce8e0d70313aa8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks apply to every test in a file. You can also group tests together using a &lt;code&gt;describe&lt;/code&gt; block. When they are inside a &lt;code&gt;describe&lt;/code&gt; block, the &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; blocks only apply to the tests within that &lt;code&gt;describe&lt;/code&gt; block.</source>
          <target state="translated">默认情况下， &lt;code&gt;before&lt;/code&gt; 和 &lt;code&gt;after&lt;/code&gt; 块适用于文件中的每个测试。您也可以使用 &lt;code&gt;describe&lt;/code&gt; 块将测试分组在一起。当它们在 &lt;code&gt;describe&lt;/code&gt; 块内时， &lt;code&gt;before&lt;/code&gt; 和 &lt;code&gt;after&lt;/code&gt; 块仅适用于该 &lt;code&gt;describe&lt;/code&gt; 块内的测试。</target>
        </trans-unit>
        <trans-unit id="8ff6b50d4d2916e059b4da78398d7f7528e06bc4" translate="yes" xml:space="preserve">
          <source>By now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.</source>
          <target state="translated">现在你应该对Jest如何帮助你测试你的应用有了很好的了解。如果你有兴趣了解更多,这里有一些相关的东西,你可能想看看。</target>
        </trans-unit>
        <trans-unit id="55ee7b41c21d659b9270bc90149ebea235b5681e" translate="yes" xml:space="preserve">
          <source>Bypassing module mocks</source>
          <target state="translated">绕过模块模拟</target>
        </trans-unit>
        <trans-unit id="90c44908e93edab5744658b1f65e26d8c711f11b" translate="yes" xml:space="preserve">
          <source>Caching Issues</source>
          <target state="translated">缓存问题</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="29ebbaf2a884d1472efa612e0a99881e086b0d45" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; with the module factory parameter</source>
          <target state="translated">使用模块工厂参数调用&lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6fb7b5fdc1cb7e80c6697d89dc59adbcb936cfd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;jest.mock('./sound-player')&lt;/code&gt; returns a useful &quot;automatic mock&quot; you can use to spy on calls to the class constructor and all of its methods. It replaces the ES6 class with a mock constructor, and replaces all of its methods with &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt; that always return &lt;code&gt;undefined&lt;/code&gt;. Method calls are saved in &lt;code&gt;theAutomaticMock.mock.instances[index].methodName.mock.calls&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;jest.mock('./sound-player')&lt;/code&gt; 会返回一个有用的&amp;ldquo;自动模拟&amp;rdquo;，您可以用来监视对类构造函数及其所有方法的调用。它将ES6类替换为模拟构造函数，并将其所有方法替换为始终返回 &lt;code&gt;undefined&lt;/code&gt; 的&lt;a href=&quot;mock-functions&quot;&gt;模拟函数&lt;/a&gt;。方法调用保存在 &lt;code&gt;theAutomaticMock.mock.instances[index].methodName.mock.calls&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20ec8cdd6ae393d85748c5307b9a180fdb961ea" translate="yes" xml:space="preserve">
          <source>Calls to jest.mock are hoisted to the top of the code. You can specify a mock later, e.g. in &lt;code&gt;beforeAll()&lt;/code&gt;, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; (or &lt;code&gt;mockImplementationOnce()&lt;/code&gt;) on the existing mock instead of using the factory parameter. This also allows you to change the mock between tests, if needed:</source>
          <target state="translated">对jest.mock的调用被提升到代码的顶部。您可以稍后指定一个模拟，例如在 &lt;code&gt;beforeAll()&lt;/code&gt; 中，通过在现有模拟上调用 &lt;code&gt;mockImplementation()&lt;/code&gt; （或 &lt;code&gt;mockImplementationOnce()&lt;/code&gt; ）来代替使​​用工厂参数。如果需要，这还允许您在测试之间更改模拟：</target>
        </trans-unit>
        <trans-unit id="47b5e900f807b38adaa6e9c85b7fbbbdc6e0face" translate="yes" xml:space="preserve">
          <source>Camelcase &amp;amp; dashed args support</source>
          <target state="translated">驼峰和虚线args支持</target>
        </trans-unit>
        <trans-unit id="5ceb09d577f5f6169012cae86d6ed0c20f9308f0" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;React Tree Snapshot Testing&lt;/a&gt; for more information on snapshot testing.</source>
          <target state="translated">请查看&lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;React Tree快照测试&lt;/a&gt;以获取有关快照测试的更多信息。</target>
        </trans-unit>
        <trans-unit id="a8ad42e0821d727215f4c5c74225fda2de21bcbc" translate="yes" xml:space="preserve">
          <source>Check out the section on &lt;a href=&quot;snapshot-testing#inline-snapshots&quot;&gt;Inline Snapshots&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请查看&amp;ldquo; &lt;a href=&quot;snapshot-testing#inline-snapshots&quot;&gt;内联快照&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="834816cb4074428815336a2cb6e1928bb56da7fb" translate="yes" xml:space="preserve">
          <source>Choosing a good key</source>
          <target state="translated">选择一把好钥匙</target>
        </trans-unit>
        <trans-unit id="f282371c2a1af22d1e4a9f0b7e80f6cb76f88540" translate="yes" xml:space="preserve">
          <source>Cleaning up between tests</source>
          <target state="translated">测试之间的清理</target>
        </trans-unit>
        <trans-unit id="951b5b48e067f46712c0fc43e2f448c71ed835a5" translate="yes" xml:space="preserve">
          <source>Clears the &lt;code&gt;mock.calls&lt;/code&gt; and &lt;code&gt;mock.instances&lt;/code&gt; properties of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;.mockClear()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">清除所有 &lt;code&gt;mock.calls&lt;/code&gt; 和 &lt;code&gt;mock.instances&lt;/code&gt; 属性。等效于在每个&lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;.mockClear()&lt;/code&gt; &lt;/a&gt;函数上调用.mockClear（）。</target>
        </trans-unit>
        <trans-unit id="d6db6e9b2b18300b8b1943a06238aa498f4d0ffe" translate="yes" xml:space="preserve">
          <source>Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.</source>
          <target state="translated">提交快照并将其作为常规代码审查流程的一部分进行审查。这意味着要像对待项目中其他类型的测试或代码一样对待快照。</target>
        </trans-unit>
        <trans-unit id="5317e60e1477cd7f5e0cf5cbb3fd4f6fbfd42186" translate="yes" xml:space="preserve">
          <source>Common Matchers</source>
          <target state="translated">常见的匹配器</target>
        </trans-unit>
        <trans-unit id="39af2b26c9ee2c162295a79a46bf64f2dcb740b9" translate="yes" xml:space="preserve">
          <source>Community projects under one organisation are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.</source>
          <target state="translated">在一个组织下的社区项目是Jest尝试新想法/技术和方法的好方法。鼓励社区的贡献,并以更快的速度独立发布贡献。</target>
        </trans-unit>
        <trans-unit id="1ac62a488978924e46345706e5701acf535027b1" translate="yes" xml:space="preserve">
          <source>Compatibility issues</source>
          <target state="translated">兼容性问题</target>
        </trans-unit>
        <trans-unit id="647a61b7661823bee3e0fb318ccb983ea06af198" translate="yes" xml:space="preserve">
          <source>Complete example</source>
          <target state="translated">完整的例子</target>
        </trans-unit>
        <trans-unit id="7338817b3b4ee94bffc83800ba5beb8a9de91061" translate="yes" xml:space="preserve">
          <source>Config: //</source>
          <target state="translated">配置://</target>
        </trans-unit>
        <trans-unit id="419b3ad350c5399b2d30683f98566248a0ccc3a0" translate="yes" xml:space="preserve">
          <source>Config: automock</source>
          <target state="translated">配置:自动锁</target>
        </trans-unit>
        <trans-unit id="627e8b1a128fd33accae1330833eabb2bdca8973" translate="yes" xml:space="preserve">
          <source>Config: bail</source>
          <target state="translated">配置:保释</target>
        </trans-unit>
        <trans-unit id="bc5d64a5311bb274fd46a79262ecb43ee3a1e121" translate="yes" xml:space="preserve">
          <source>Config: browser</source>
          <target state="translated">配置:浏览器</target>
        </trans-unit>
        <trans-unit id="4367a209c83015f162fc0ca638a3e053c9041bdb" translate="yes" xml:space="preserve">
          <source>Config: cacheDirectory</source>
          <target state="translated">配置:cacheDirectory</target>
        </trans-unit>
        <trans-unit id="cf5e892834611f65829eeac25c2d08106d23b5a7" translate="yes" xml:space="preserve">
          <source>Config: clearMocks</source>
          <target state="translated">配置:clearMocks</target>
        </trans-unit>
        <trans-unit id="501c70b5aa067226067f0b907eb78a61fccc193d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverage</source>
          <target state="translated">配置:collectCoverage</target>
        </trans-unit>
        <trans-unit id="b208010efbcc655b8d5fcea13db6ce8d2238cf7d" translate="yes" xml:space="preserve">
          <source>Config: collectCoverageFrom</source>
          <target state="translated">配置:collectCoverageFrom</target>
        </trans-unit>
        <trans-unit id="bdf43098f46df2169bb90995abc4f207c9f4654b" translate="yes" xml:space="preserve">
          <source>Config: coverageDirectory</source>
          <target state="translated">配置:覆盖范围目录</target>
        </trans-unit>
        <trans-unit id="e61dfeddb711754aa3eea86892ddac143c1cf750" translate="yes" xml:space="preserve">
          <source>Config: coveragePathIgnorePatterns</source>
          <target state="translated">配置:coveragePathIgnorePatterns。</target>
        </trans-unit>
        <trans-unit id="4dc823be9ce961ce58c7a5bd2c3ede521ec9b22c" translate="yes" xml:space="preserve">
          <source>Config: coverageReporters</source>
          <target state="translated">配置:覆盖率报告器</target>
        </trans-unit>
        <trans-unit id="731365c9b4185412e26d012a648d84274b7ee783" translate="yes" xml:space="preserve">
          <source>Config: coverageThreshold</source>
          <target state="translated">配置:覆盖率阈值</target>
        </trans-unit>
        <trans-unit id="6ddb77352d47cc2ab7211c5bb66e8ea1cf8dbedb" translate="yes" xml:space="preserve">
          <source>Config: dependencyExtractor</source>
          <target state="translated">配置:dependencyExtractor</target>
        </trans-unit>
        <trans-unit id="410a11c871d9b9ac5d1c84224af14915bc5687c9" translate="yes" xml:space="preserve">
          <source>Config: displayName</source>
          <target state="translated">配置:displayName</target>
        </trans-unit>
        <trans-unit id="27317b3ce2dc1add449b8f662db64de41a9e9ae6" translate="yes" xml:space="preserve">
          <source>Config: errorOnDeprecated</source>
          <target state="translated">配置:errorOnDeprecated</target>
        </trans-unit>
        <trans-unit id="fecda0afbc8d772eae7fac9e4ba0b8b1d10e359f" translate="yes" xml:space="preserve">
          <source>Config: extraGlobals</source>
          <target state="translated">配置:extraGlobals</target>
        </trans-unit>
        <trans-unit id="b25f9152c510580dbb37bfa8b225c9b83eec07f3" translate="yes" xml:space="preserve">
          <source>Config: forceCoverageMatch</source>
          <target state="translated">配置:forceCoverageMatch</target>
        </trans-unit>
        <trans-unit id="79761896d6c24e1a388783f8ad0d4cf62e966150" translate="yes" xml:space="preserve">
          <source>Config: globalSetup</source>
          <target state="translated">配置:全球设置</target>
        </trans-unit>
        <trans-unit id="92db96d317bc0181d4c70c0a736f44496f34c5f0" translate="yes" xml:space="preserve">
          <source>Config: globalTeardown</source>
          <target state="translated">配置:globalTeardown</target>
        </trans-unit>
        <trans-unit id="bf2c2049305c4a3db421bc76e052ff49dd5e09c4" translate="yes" xml:space="preserve">
          <source>Config: globals</source>
          <target state="translated">配置:globals</target>
        </trans-unit>
        <trans-unit id="d67799f97ad1d1ba5dbde5c2bbea2d9e7a64e588" translate="yes" xml:space="preserve">
          <source>Config: maxConcurrency</source>
          <target state="translated">配置:maxConcurrency</target>
        </trans-unit>
        <trans-unit id="ba41029a807595561e6313c2154c8d63b551b08f" translate="yes" xml:space="preserve">
          <source>Config: moduleDirectories</source>
          <target state="translated">配置:模块目录</target>
        </trans-unit>
        <trans-unit id="0c69621f31253439feae40f7edb9f987c54a7c60" translate="yes" xml:space="preserve">
          <source>Config: moduleFileExtensions</source>
          <target state="translated">配置:模块文件扩展</target>
        </trans-unit>
        <trans-unit id="e56cc759b41f3e82ba32926a92966a3f498e6902" translate="yes" xml:space="preserve">
          <source>Config: moduleNameMapper</source>
          <target state="translated">配置:模块名称映射器</target>
        </trans-unit>
        <trans-unit id="20a45c51d17976a84164108ba1570ebaa713c2d0" translate="yes" xml:space="preserve">
          <source>Config: modulePathIgnorePatterns</source>
          <target state="translated">配置:模块路径模式</target>
        </trans-unit>
        <trans-unit id="c8dfc9221f178a7e9e50e483363057b29737331d" translate="yes" xml:space="preserve">
          <source>Config: modulePaths</source>
          <target state="translated">配置:模块路径</target>
        </trans-unit>
        <trans-unit id="443a851b039bcd2776957b32886e287fea1ec06b" translate="yes" xml:space="preserve">
          <source>Config: notify</source>
          <target state="translated">配置:通知</target>
        </trans-unit>
        <trans-unit id="17139aeb93d058b72a2aa76ec6bb221cf0bef770" translate="yes" xml:space="preserve">
          <source>Config: notifyMode</source>
          <target state="translated">配置:notifyMode</target>
        </trans-unit>
        <trans-unit id="3caeb9058b4e79e45f4cf9706757269977d12773" translate="yes" xml:space="preserve">
          <source>Config: preset</source>
          <target state="translated">配置:预设</target>
        </trans-unit>
        <trans-unit id="ba5eee9d73aa692050786b2b5d012b9c6430da5f" translate="yes" xml:space="preserve">
          <source>Config: prettierPath</source>
          <target state="translated">配置:prettierPath</target>
        </trans-unit>
        <trans-unit id="de718240490d094a4aca3e67beb56ce24d859f0e" translate="yes" xml:space="preserve">
          <source>Config: projects</source>
          <target state="translated">配置:项目</target>
        </trans-unit>
        <trans-unit id="a12a5c71edd2c879af4190d0ca91fb1c41ed4691" translate="yes" xml:space="preserve">
          <source>Config: reporters</source>
          <target state="translated">配置:记者</target>
        </trans-unit>
        <trans-unit id="05d3f1dda15c90c8537c0ebaae99cc9b6dab6d2c" translate="yes" xml:space="preserve">
          <source>Config: resetMocks</source>
          <target state="translated">配置:resetMocks</target>
        </trans-unit>
        <trans-unit id="00ce92b9cce0a2fc0cfaa6bdc87fca0a67673a92" translate="yes" xml:space="preserve">
          <source>Config: resetModules</source>
          <target state="translated">配置:重置模块</target>
        </trans-unit>
        <trans-unit id="7e342a2f1f10e2ce5223aeb58621bcfcaee80280" translate="yes" xml:space="preserve">
          <source>Config: resolver</source>
          <target state="translated">配置:解析器</target>
        </trans-unit>
        <trans-unit id="4d0db5ef6ee172dca67b2ec98bd9764765247d45" translate="yes" xml:space="preserve">
          <source>Config: restoreMocks</source>
          <target state="translated">配置:restoreMocks</target>
        </trans-unit>
        <trans-unit id="dbda260933b77348b0de3d059fb6eaafcfe9ed04" translate="yes" xml:space="preserve">
          <source>Config: rootDir</source>
          <target state="translated">配置:rootDir</target>
        </trans-unit>
        <trans-unit id="a486beac88a05f5107d2963397c9a097a8b9c53d" translate="yes" xml:space="preserve">
          <source>Config: roots</source>
          <target state="translated">配置:根</target>
        </trans-unit>
        <trans-unit id="15087b6a38a2044fac1d8bca8ed5b732e85be8e9" translate="yes" xml:space="preserve">
          <source>Config: runner</source>
          <target state="translated">配置:亚军</target>
        </trans-unit>
        <trans-unit id="69d7cd6c10e8ee3f4e5933ab036c264a961a3c6f" translate="yes" xml:space="preserve">
          <source>Config: setupFiles</source>
          <target state="translated">配置:setupFiles</target>
        </trans-unit>
        <trans-unit id="2b099bf0ed7f0b70b104f43a494c8a3601d6db3b" translate="yes" xml:space="preserve">
          <source>Config: setupFilesAfterEnv</source>
          <target state="translated">配置:setupFilesAfterEnv</target>
        </trans-unit>
        <trans-unit id="39fceff3400dd04baa7d8cf445ca60d91c4b565d" translate="yes" xml:space="preserve">
          <source>Config: snapshotResolver</source>
          <target state="translated">配置:snapshotResolver</target>
        </trans-unit>
        <trans-unit id="926aa02967cb62919ed24d142e8ab790e7e88f40" translate="yes" xml:space="preserve">
          <source>Config: snapshotSerializers</source>
          <target state="translated">配置:snapshotSerializers</target>
        </trans-unit>
        <trans-unit id="2719c66aea5faa9e87f1dada70059a3cfbc1c722" translate="yes" xml:space="preserve">
          <source>Config: testEnvironment</source>
          <target state="translated">配置:testEnvironment</target>
        </trans-unit>
        <trans-unit id="85e3d1362b32367666c7ee4106cc8a8c49ef9c56" translate="yes" xml:space="preserve">
          <source>Config: testEnvironmentOptions</source>
          <target state="translated">配置:testEnvironmentOptions</target>
        </trans-unit>
        <trans-unit id="a067ac9bbff1c40f63b3c4571746aeb1f2c51ef3" translate="yes" xml:space="preserve">
          <source>Config: testMatch</source>
          <target state="translated">配置:testMatch</target>
        </trans-unit>
        <trans-unit id="6b64c3b85bea8af5d02fcd06f985923761f20605" translate="yes" xml:space="preserve">
          <source>Config: testPathIgnorePatterns</source>
          <target state="translated">配置:testPathIgnorePatterns。</target>
        </trans-unit>
        <trans-unit id="1b4324c80d83474910e2f7ba12475a97f71b780b" translate="yes" xml:space="preserve">
          <source>Config: testRegex</source>
          <target state="translated">配置:testRegex</target>
        </trans-unit>
        <trans-unit id="f3b1317ed93a2645076cae324fc69ab7bd2043de" translate="yes" xml:space="preserve">
          <source>Config: testResultsProcessor</source>
          <target state="translated">配置:testResultsProcessor</target>
        </trans-unit>
        <trans-unit id="ebce535e49ba2d6e77c3ace6f1d4b4d227eb1005" translate="yes" xml:space="preserve">
          <source>Config: testRunner</source>
          <target state="translated">配置:testRunner</target>
        </trans-unit>
        <trans-unit id="14f361d3abf65818229de4fd0fd2b800c7132faa" translate="yes" xml:space="preserve">
          <source>Config: testSequencer</source>
          <target state="translated">配置:testSequencer</target>
        </trans-unit>
        <trans-unit id="a9dcaf483df4a5ad04db7728ded6a4a42efa7cc9" translate="yes" xml:space="preserve">
          <source>Config: testURL</source>
          <target state="translated">配置:testURL</target>
        </trans-unit>
        <trans-unit id="d6decdd2c51010466998366161fed9615c71ed2e" translate="yes" xml:space="preserve">
          <source>Config: timers</source>
          <target state="translated">配置:定时器</target>
        </trans-unit>
        <trans-unit id="710dedba7705ede1b50331e3f82d3159bd25781c" translate="yes" xml:space="preserve">
          <source>Config: transform</source>
          <target state="translated">配置:转换</target>
        </trans-unit>
        <trans-unit id="567cb22f9c7af2b996f4d744bf2d3e97d8f52294" translate="yes" xml:space="preserve">
          <source>Config: transformIgnorePatterns</source>
          <target state="translated">配置:transformIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="7c7d6430c4ac8b493a953f1b57daa83c4cf0b4fc" translate="yes" xml:space="preserve">
          <source>Config: unmockedModulePathPatterns</source>
          <target state="translated">配置:unmockedModulePathPatterns。</target>
        </trans-unit>
        <trans-unit id="1a9f98c1a91d2c94b70a6840de75ff48ff87cde9" translate="yes" xml:space="preserve">
          <source>Config: verbose</source>
          <target state="translated">配置:冗长</target>
        </trans-unit>
        <trans-unit id="cc12f6eb1650abf575ed9f60726c3d8f9776c168" translate="yes" xml:space="preserve">
          <source>Config: watchPathIgnorePatterns</source>
          <target state="translated">配置:watchPathIgnorePatterns。</target>
        </trans-unit>
        <trans-unit id="6264b4990f0b105e5e1586412f25673503f78b81" translate="yes" xml:space="preserve">
          <source>Config: watchPlugins</source>
          <target state="translated">配置:watchPlugins</target>
        </trans-unit>
        <trans-unit id="d0540e863b75a1e450632fdfba93847f16e57dfe" translate="yes" xml:space="preserve">
          <source>Configure Babel to target your current version of Node by creating a &lt;code&gt;babel.config.js&lt;/code&gt; file in the root of your project:</source>
          <target state="translated">通过在项目根目录中创建 &lt;code&gt;babel.config.js&lt;/code&gt; 文件，将Babel配置为以当前版本的Node为目标：</target>
        </trans-unit>
        <trans-unit id="732bdf3d9ce078bf71b612048a4595a4eb70bdff" translate="yes" xml:space="preserve">
          <source>Configure DynamoDB client</source>
          <target state="translated">配置DynamoDB客户端</target>
        </trans-unit>
        <trans-unit id="aa8f1ca94d78bf9bcf623acecc179502fe36fdf4" translate="yes" xml:space="preserve">
          <source>Configuring Jest</source>
          <target state="translated">配置Jest</target>
        </trans-unit>
        <trans-unit id="d69b5f49a85c3bbccb1893393cd0decc9db7f396" translate="yes" xml:space="preserve">
          <source>Configuring Jest to find our files</source>
          <target state="translated">配置Jest来查找我们的文件</target>
        </trans-unit>
        <trans-unit id="f73284b346579e5b9427a96d62cdd35e3340d4d0" translate="yes" xml:space="preserve">
          <source>Consider the following illustrative test file and output:</source>
          <target state="translated">请考虑以下示例性测试文件和输出。</target>
        </trans-unit>
        <trans-unit id="195e9ca7f58f10ad0afe5f1b4587aa7d074cc2bd" translate="yes" xml:space="preserve">
          <source>Consider writing a test case for this &lt;code&gt;createUser&lt;/code&gt; function:</source>
          <target state="translated">考虑为该 &lt;code&gt;createUser&lt;/code&gt; 函数编写一个测试用例：</target>
        </trans-unit>
        <trans-unit id="9c91f8e3106aa40d25ef1aeefb02de0e79715f8d" translate="yes" xml:space="preserve">
          <source>Converting the &lt;a href=&quot;es6-class-mocks#automatic-mock&quot;&gt;ES6 Class automatic mock example&lt;/a&gt; would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7c7b509517031ce2942935f6e6675726c02dcb" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;jest-dynamodb-config.js&lt;/code&gt; and define DynamoDB tables</source>
          <target state="translated">创建 &lt;code&gt;jest-dynamodb-config.js&lt;/code&gt; 并定义DynamoDB表</target>
        </trans-unit>
        <trans-unit id="f072285a90744179b098528df836611fec0f6e77" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; by saving a mock implementation in the &lt;code&gt;__mocks__&lt;/code&gt; folder. This allows you to specify the implementation, and it can be used across test files.</source>
          <target state="translated">通过将模拟实现保存在 &lt;code&gt;__mocks__&lt;/code&gt; 文件夹中来创建&lt;a href=&quot;manual-mocks&quot;&gt;手动模拟&lt;/a&gt;。这使您可以指定实现，并且可以在测试文件中使用它。</target>
        </trans-unit>
        <trans-unit id="68d55c4ef4fb9112ab16e98e11cae9d13ee80e25" translate="yes" xml:space="preserve">
          <source>Creates a mock function similar to &lt;code&gt;jest.fn&lt;/code&gt; but also tracks calls to &lt;code&gt;object[methodName]&lt;/code&gt;. Returns a Jest &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7576c0fd5d12ef5fcd87f993a9d142bd20852f" translate="yes" xml:space="preserve">
          <source>Creates a mock function similar to &lt;code&gt;jest.fn&lt;/code&gt; but also tracks calls to &lt;code&gt;object[methodName]&lt;/code&gt;. Returns a Jest mock function.</source>
          <target state="translated">创建类似于 &lt;code&gt;jest.fn&lt;/code&gt; 的模拟函数，但还跟踪对 &lt;code&gt;object[methodName]&lt;/code&gt; 调用。返回一个Jest模拟函数。</target>
        </trans-unit>
        <trans-unit id="a6af3b0b9c2d9efcee182c5badbf215b13de90d9" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;a href=&quot;mock-functions&quot;&gt;mock function&lt;/a&gt;. The new function has no formal parameters and when called will return &lt;code&gt;undefined&lt;/code&gt;. This functionality also applies to &lt;code&gt;async&lt;/code&gt; functions.</source>
          <target state="translated">创建一个新的&lt;a href=&quot;mock-functions&quot;&gt;模拟函数&lt;/a&gt;。新函数没有形式参数，调用时将返回 &lt;code&gt;undefined&lt;/code&gt; 。此功能也适用于 &lt;code&gt;async&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="9640d8521155bba2bdb848fd8c2529dc7dcc79fa" translate="yes" xml:space="preserve">
          <source>Creates a new class. The interface of the original class is maintained, all of the class member functions and properties will be mocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff88930a91ab80f14f3aebb7fde98a563da17ce4" translate="yes" xml:space="preserve">
          <source>Creates a new deeply cloned object. The object keys are maintained and their values are mocked.</source>
          <target state="translated">创建一个新的深度克隆对象。对象的键被保留,其值被模拟。</target>
        </trans-unit>
        <trans-unit id="499339901a2a6910de0fa6f2ee66c02b0aa8ec88" translate="yes" xml:space="preserve">
          <source>Creates a new empty array, ignoring the original.</source>
          <target state="translated">创建一个新的空数组,忽略原来的数组。</target>
        </trans-unit>
        <trans-unit id="a5763b0dca9136215f4c1bd25d66fda4d413f5fa" translate="yes" xml:space="preserve">
          <source>Creates a new property with the same primitive value as the original property.</source>
          <target state="translated">创建一个与原属性具有相同基元值的新属性。</target>
        </trans-unit>
        <trans-unit id="14a2d117a3682ce4e9ee56f51a4dddf39a8c9887" translate="yes" xml:space="preserve">
          <source>Creates new class. The interface of the original class is maintained, all of the class member functions and properties will be mocked.</source>
          <target state="translated">创建新类。保留原类的接口,所有的类成员函数和属性将被模拟。</target>
        </trans-unit>
        <trans-unit id="c51941f39ba45e54075e0925fb6911178a577498" translate="yes" xml:space="preserve">
          <source>Custom Matchers</source>
          <target state="translated">定制匹配器</target>
        </trans-unit>
        <trans-unit id="54f825aa31c7f89df216a075a2e0407f6b8d69f3" translate="yes" xml:space="preserve">
          <source>Custom Matchers API</source>
          <target state="translated">自定义匹配器API</target>
        </trans-unit>
        <trans-unit id="119759fa773122549b207e8a3a246d10ce0d12df" translate="yes" xml:space="preserve">
          <source>Custom example without jest-puppeteer preset</source>
          <target state="translated">自定义的例子,没有笑话-傀儡师预设。</target>
        </trans-unit>
        <trans-unit id="d21fbbb8afbf0a16c827d47836dcb1856cc7708e" translate="yes" xml:space="preserve">
          <source>Custom reporter modules must define a class that takes a &lt;code&gt;GlobalConfig&lt;/code&gt; and reporter options as constructor arguments:</source>
          <target state="translated">自定义报告程序模块必须定义一个类，该类采用 &lt;code&gt;GlobalConfig&lt;/code&gt; 和报告程序选项作为构造函数参数：</target>
        </trans-unit>
        <trans-unit id="714a39b633fc18946fa5b07fb026f29bf56da631" translate="yes" xml:space="preserve">
          <source>Custom reporters can also force Jest to exit with non-0 code by returning an Error from &lt;code&gt;getLastError()&lt;/code&gt; methods</source>
          <target state="translated">自定义报告程序还可以通过从 &lt;code&gt;getLastError()&lt;/code&gt; 方法返回Error来强制Jest以非0代码退出。</target>
        </trans-unit>
        <trans-unit id="59764a788a550e0bcc7c2f3f06d2271ee9028a6a" translate="yes" xml:space="preserve">
          <source>Custom snapshot matchers</source>
          <target state="translated">自定义快照匹配器</target>
        </trans-unit>
        <trans-unit id="efb96a7111f5d3ea6a3fe4177d7f8a2f59a345b0" translate="yes" xml:space="preserve">
          <source>Custom transformers</source>
          <target state="translated">定制变压器</target>
        </trans-unit>
        <trans-unit id="796036624d60e8855428745a98834ec3d84c8f41" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can add hooks to Jest events. These hooks can be added either with or without having an interactive key in the watch mode menu.</source>
          <target state="translated">自定义手表插件可以向Jest事件添加钩子。这些钩子可以在手表模式菜单中添加或不添加交互式键。</target>
        </trans-unit>
        <trans-unit id="215e1af622d5b72a6cc168c70f4702a398bb2716" translate="yes" xml:space="preserve">
          <source>Custom watch plugins can also add or override functionality to the watch menu by specifying a key/prompt pair in &lt;code&gt;getUsageInfo&lt;/code&gt; method and a &lt;code&gt;run&lt;/code&gt; method for the execution of the key.</source>
          <target state="translated">定制监视插件还可以通过在 &lt;code&gt;getUsageInfo&lt;/code&gt; 方法中指定一个密钥/提示对以及用于执行密钥的 &lt;code&gt;run&lt;/code&gt; 方法来在监视菜单中添加或覆盖功能。</target>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="translated">DOM操作</target>
        </trans-unit>
        <trans-unit id="7d47c567751d80a763336c3531e448b81a834be1" translate="yes" xml:space="preserve">
          <source>DOM Testing</source>
          <target state="translated">DOM测试</target>
        </trans-unit>
        <trans-unit id="47d19ef23ccb3630dfbdcf2345caac51860dc04a" translate="yes" xml:space="preserve">
          <source>Debugging in VS Code</source>
          <target state="translated">在VS代码中调试</target>
        </trans-unit>
        <trans-unit id="97b21e655f77156f74590b9394f284ad276659df" translate="yes" xml:space="preserve">
          <source>Debugging in WebStorm</source>
          <target state="translated">在WebStorm中进行调试</target>
        </trans-unit>
        <trans-unit id="9db8168745ecdc4d2c33dcaaa5800609ce840c96" translate="yes" xml:space="preserve">
          <source>Default timeout of a test in milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8d2a884ab0f628a1f7f94392af6e76fa7a2fc7" translate="yes" xml:space="preserve">
          <source>Default timeout of a test in milliseconds. Default value: 5000.</source>
          <target state="translated">测试的默认超时,单位为毫秒。默认值:5000。</target>
        </trans-unit>
        <trans-unit id="ec5aab0a956d1bf4178fda692ccbf9f96c049d2f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;/tmp/&amp;lt;path&amp;gt;&quot;&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;&quot;/tmp/&amp;lt;path&amp;gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92bb4405a1bd1698f8e13de63202bbb029fb7e5b" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jest-runner&quot;&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;&quot;jest-runner&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47384bd44c204995dd251a440e0f2874c419f943" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;jsdom&quot;&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;&quot;jsdom&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="819cc760e16ea72f302b36952c68bdc74e37fbc0" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'prettier'&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;'prettier'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2e64757bbec7711d7708d7a5ad878780438205" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$&lt;/code&gt; /）（test | spec））\\。[jt] sx？$</target>
        </trans-unit>
        <trans-unit id="3569cdb24d4e3738060acfc3ad2efff4bb497560" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8cdb6bdfb4ddcbbf9350bcc9a8f2c9275878282" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec76f2dc74222beddf4840861fe93e6a26ba78b" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;5000&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3230c6cb67eb67fb80df55aa548813d92e446d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;5&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07d90156b27c53ecc56aef155a22882f9031bbda" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;@jest/test-sequencer&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;@jest/test-sequencer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ec10196844ffb76ab5d5c304aacc13ac2e3cef9" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;&quot;]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6bdd2947707af6afc8184348a64d68f0ddd29ea" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;/node_modules/&quot;, &quot;\\.pnp\\.[^\\\/]+$&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5e027fc76915df0b4b1aa4ee05ea7cf2a7e108" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;/node_modules/&quot;]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[&quot;/node_modules/&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90a0fee6fa4afd6073a2bb2c2c33627e5932f689" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;, &quot;node&quot;]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[&quot;js&quot;, &quot;json&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;, &quot;node&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96347c64af1e884636cd5cac216f125cf26bfaac" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;, &quot;clover&quot;]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[&quot;json&quot;, &quot;lcov&quot;, &quot;text&quot;, &quot;clover&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52bfa7d4e9de2ac8aff5837eee8067bcdd2d8d03" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[&quot;node_modules&quot;]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[&quot;node_modules&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d48cfe315fd247262c98a909a60e72fe1adb7bd" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;['']&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;['']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ffa1281e650e63433a7c2437e7f3068376e6c83" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;[]&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b2f403a7a8a0196ba2b1e131b436bad9608f06" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;failure-change&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;failure-change&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="614188609a5c964071cad1f8bd6a9a468d7e820f" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32578e58095a4c9dc16bbe18810864be9eb55e61" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;http://localhost&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;http://localhost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb7e8f5d26d527a1551f7fbe8540cdd2756856f1" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;jasmine2&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;jasmine2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72af77c264a4ee8b4a40880a27db11fcd236d73d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e59e0f6f5986d77c33cddbccdfb1f46b1dcfe17a" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;real&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;real&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d0b83b26a1706be41ebbd280d1bc7d8f1a895a8" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440b4c5aa1e906e434fd52447e734719e939c93d" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0a3e85c64db816a398ea65177d611529bb029cc" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;{&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da6b7c92470df3b7f4b4cef35bf9321c6095a8" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">默认值： &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5a66f14241f019bfa4af9e9837d93ce753bdfcf" translate="yes" xml:space="preserve">
          <source>Default: The root of the directory containing your Jest config file&lt;em&gt;or&lt;/em&gt; the &lt;code&gt;package.json&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt; if no &lt;code&gt;package.json&lt;/code&gt; is found</source>
          <target state="translated">默认：包含你的玩笑配置文件目录的根目录&lt;em&gt;或&lt;/em&gt;在 &lt;code&gt;package.json&lt;/code&gt; &lt;em&gt;或&lt;/em&gt;在&lt;a href=&quot;http://en.wikipedia.org/wiki/Pwd&quot;&gt; &lt;code&gt;pwd&lt;/code&gt; &lt;/a&gt;，如果没有 &lt;code&gt;package.json&lt;/code&gt; 发现</target>
        </trans-unit>
        <trans-unit id="428819bf9e83cebda50efafb08cd2534c1583949" translate="yes" xml:space="preserve">
          <source>Defaults</source>
          <target state="translated">Defaults</target>
        </trans-unit>
        <trans-unit id="708e979a86993e441e280091f83d90e49fb6e0fb" translate="yes" xml:space="preserve">
          <source>Defining Tests</source>
          <target state="translated">定义测试</target>
        </trans-unit>
        <trans-unit id="8fa37ce3402b9fdda8c547faa8f8a629231c38fc" translate="yes" xml:space="preserve">
          <source>Deletes the Jest cache directory and then exits without running tests. Will delete &lt;code&gt;cacheDirectory&lt;/code&gt; if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling &lt;code&gt;jest --showConfig&lt;/code&gt;. &lt;em&gt;Note: clearing the cache will reduce performance.&lt;/em&gt;</source>
          <target state="translated">删除Jest缓存目录，然后退出而不运行测试。如果传递了选项，将删除 &lt;code&gt;cacheDirectory&lt;/code&gt; 或Jest的默认缓存目录。可以通过调用 &lt;code&gt;jest --showConfig&lt;/code&gt; 来找到默认的缓存目录。&lt;em&gt;注意：清除缓存会降低性能。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d9c3f11c071444f893ad63c8b10640d8dec604b" translate="yes" xml:space="preserve">
          <source>Determines if the given function is a mocked function.</source>
          <target state="translated">确定给定函数是否为模拟函数。</target>
        </trans-unit>
        <trans-unit id="25fde793067d8261eed4bccfb3fd238dad8d6983" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;.toEqual&lt;/code&gt;:</source>
          <target state="translated">与 &lt;code&gt;.toEqual&lt;/code&gt; 的区别：</target>
        </trans-unit>
        <trans-unit id="cc8abd105b53147a8d0383ba5b505ee49226316a" translate="yes" xml:space="preserve">
          <source>Disable warnings all together (should be done in your jest setup file):</source>
          <target state="translated">全部禁用警告(应该在你的jest设置文件中完成)。</target>
        </trans-unit>
        <trans-unit id="ae71b8a8ed202bbaa7e42b1a5bdeb06c2525518d" translate="yes" xml:space="preserve">
          <source>Disables automatic mocking in the module loader.</source>
          <target state="translated">在模块加载器中禁用自动嘲讽。</target>
        </trans-unit>
        <trans-unit id="55e34bb12f80749a80b5838e96b2c150faa45ac0" translate="yes" xml:space="preserve">
          <source>Disables stack trace in test results output.</source>
          <target state="translated">在测试结果输出中禁用堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="1e98b783a42cdc4f4a03ffd64649c5f26f6c011b" translate="yes" xml:space="preserve">
          <source>Display individual test results with the test suite hierarchy.</source>
          <target state="translated">用测试套件的层次结构显示单个测试结果。</target>
        </trans-unit>
        <trans-unit id="d8f3f815fbd922415c3aa6adb4aa4e59a5e04a90" translate="yes" xml:space="preserve">
          <source>Divert all output to stderr.</source>
          <target state="translated">将所有输出转移到stderr。</target>
        </trans-unit>
        <trans-unit id="aaf393e4923d7954d9bc2a84e51b45079ca53939" translate="yes" xml:space="preserve">
          <source>Does code coverage work with snapshot testing?</source>
          <target state="translated">代码覆盖与快照测试有用吗?</target>
        </trans-unit>
        <trans-unit id="94fbd6d73ceaf62001f4cf5b3fc9c82f322ebedc" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockclear&quot;&gt;&lt;code&gt;mockFn.mockClear()&lt;/code&gt;&lt;/a&gt; does, and also removes any mocked return values or implementations.</source>
          <target state="translated">可以做嘲笑&lt;a href=&quot;#mockfnmockclear&quot;&gt; &lt;code&gt;mockFn.mockClear()&lt;/code&gt; &lt;/a&gt;所做的所有事情，还可以删除任何模拟的返回值或实现。</target>
        </trans-unit>
        <trans-unit id="7789e80d5d03d9a660831975a1ab1fb586436891" translate="yes" xml:space="preserve">
          <source>Does everything that &lt;a href=&quot;#mockfnmockreset&quot;&gt;&lt;code&gt;mockFn.mockReset()&lt;/code&gt;&lt;/a&gt; does, and also restores the original (non-mocked) implementation.</source>
          <target state="translated">进行&lt;a href=&quot;#mockfnmockreset&quot;&gt; &lt;code&gt;mockFn.mockReset()&lt;/code&gt; &lt;/a&gt;所做的所有事情，并且还还原原始的（非模拟的）实现。</target>
        </trans-unit>
        <trans-unit id="d8613a53b523abbac39b8070515f3ee0abf3b4d2" translate="yes" xml:space="preserve">
          <source>Does snapshot testing only work with React components?</source>
          <target state="translated">快照测试是否只适用于React组件?</target>
        </trans-unit>
        <trans-unit id="6bef91ef2504e85917d6489193a8b3d0184f65a1" translate="yes" xml:space="preserve">
          <source>Does snapshot testing replace unit testing?</source>
          <target state="translated">快照测试是否会取代单元测试?</target>
        </trans-unit>
        <trans-unit id="7c3003258c19842b6d44deed813b6a58f22ceeab" translate="yes" xml:space="preserve">
          <source>Don't forget to install the &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;babel-preset-jest&lt;/code&gt; packages for this example to work.</source>
          <target state="translated">不要忘记安装 &lt;code&gt;@babel/core&lt;/code&gt; 和 &lt;code&gt;babel-preset-jest&lt;/code&gt; 软件包，此示例可以正常工作。</target>
        </trans-unit>
        <trans-unit id="b50dcc8f4ef764e131e9874eeed3d12dbbb7ac84" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;.toBe&lt;/code&gt; with floating-point numbers. For example, due to rounding, in JavaScript &lt;code&gt;0.2 + 0.1&lt;/code&gt; is not strictly equal to &lt;code&gt;0.3&lt;/code&gt;. If you have floating point numbers, try &lt;code&gt;.toBeCloseTo&lt;/code&gt; instead.</source>
          <target state="translated">不要将 &lt;code&gt;.toBe&lt;/code&gt; 与浮点数一起使用。例如，由于四舍五入，在JavaScript中 &lt;code&gt;0.2 + 0.1&lt;/code&gt; 不严格等于 &lt;code&gt;0.3&lt;/code&gt; 。如果您有浮点数，请改用 &lt;code&gt;.toBeCloseTo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="846c9004ef1bbb7bfccc704a3c8972b52308d069" translate="yes" xml:space="preserve">
          <source>ES6 Class Mocks</source>
          <target state="translated">ES6班模拟</target>
        </trans-unit>
        <trans-unit id="c2e2d49f8d0560f741ac8577a93b663178bd7029" translate="yes" xml:space="preserve">
          <source>ES6 classes are constructor functions with some syntactic sugar. Therefore, any mock for an ES6 class must be a function or an actual ES6 class (which is, again, another function). So you can mock them using &lt;a href=&quot;mock-functions&quot;&gt;mock functions&lt;/a&gt;.</source>
          <target state="translated">ES6类是带有一些语法糖的构造函数。因此，ES6类的任何模拟都必须是一个函数或实际的ES6类（再次是另一个函数）。因此，您可以使用&lt;a href=&quot;mock-functions&quot;&gt;模拟函数&lt;/a&gt;模拟它们。</target>
        </trans-unit>
        <trans-unit id="7a979ca27d4f6a8704957153c1cfba9c7ff2928a" translate="yes" xml:space="preserve">
          <source>Enables automatic mocking in the module loader.</source>
          <target state="translated">在模块加载器中启用自动嘲讽。</target>
        </trans-unit>
        <trans-unit id="a54bd6397692c956d8a24ca7382912f74c27ec19" translate="yes" xml:space="preserve">
          <source>Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.</source>
          <target state="translated">确保你的快照的可读性,保持它们的重点、短小,并使用强制执行这些风格惯例的工具。</target>
        </trans-unit>
        <trans-unit id="6c6165137242ac2de05a56584d9eb719723b240e" translate="yes" xml:space="preserve">
          <source>Ensures that a value matches the most recent snapshot.</source>
          <target state="translated">确保一个值与最近的快照相匹配。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="9d818071488cd0fd15915face926b0ea26228d9d" translate="yes" xml:space="preserve">
          <source>Enzyme</source>
          <target state="translated">Enzyme</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="6e250d15915a7dec07d85e3c69b7afec141c65b4" translate="yes" xml:space="preserve">
          <source>Errors can be handled using the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test:</source>
          <target state="translated">可以使用 &lt;code&gt;.catch&lt;/code&gt; 方法处理错误。确保添加 &lt;code&gt;expect.assertions&lt;/code&gt; 以验证是否调用了一定数量的断言。否则，兑现的诺言将不会使测试失败：</target>
        </trans-unit>
        <trans-unit id="f826b5ac94cc799a13878a1548277703d3b06f87" translate="yes" xml:space="preserve">
          <source>Even if nothing is specified here, the watcher will ignore changes to any hidden files and directories, i.e. files and folders that begin with a dot (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc0f94d2d9aec32c6363119390d09ce3e2d82c5" translate="yes" xml:space="preserve">
          <source>Even though the call to &lt;code&gt;test&lt;/code&gt; will return right away, the test doesn't complete until the promise resolves as well.</source>
          <target state="translated">即使立即返回 &lt;code&gt;test&lt;/code&gt; 调用，但直到承诺也解决后，测试才能完成。</target>
        </trans-unit>
        <trans-unit id="181adc1fd91d7f613b0b29c21d874c50ec7c2a70" translate="yes" xml:space="preserve">
          <source>Every remaining file combined has less than 50% coverage (&lt;code&gt;global&lt;/code&gt;).</source>
          <target state="translated">其余每个文件的总覆盖率不足50％（ &lt;code&gt;global&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cb707350932674779ac756d02c39f235519b003b" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;jest.setup.js&lt;/code&gt; file</source>
          <target state="translated">示例 &lt;code&gt;jest.setup.js&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="aaf7849f7d6f11a7ab97ade4dda544885008f4d9" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; array in a jest.config.js:</source>
          <target state="translated">&lt;code&gt;setupFilesAfterEnv&lt;/code&gt; 中的示例setupFilesAfterEnv数组：</target>
        </trans-unit>
        <trans-unit id="edbaf433fef36ac3533442306ff42b392e258bb9" translate="yes" xml:space="preserve">
          <source>Example in a test:</source>
          <target state="translated">例在测试中。</target>
        </trans-unit>
        <trans-unit id="3724b80ab87b149dfc415f2947aa5d33aebb6cf1" translate="yes" xml:space="preserve">
          <source>Example reporter:</source>
          <target state="translated">记者示例:</target>
        </trans-unit>
        <trans-unit id="2dc6113b2c0f485941bfab51b94f31a114ec2df2" translate="yes" xml:space="preserve">
          <source>Example serializer module:</source>
          <target state="translated">序列器模块示例。</target>
        </trans-unit>
        <trans-unit id="d9c6a3e7251096dba7461d173198c7d8db714d67" translate="yes" xml:space="preserve">
          <source>Example snapshot resolver module:</source>
          <target state="translated">示例快照解析器模块。</target>
        </trans-unit>
        <trans-unit id="07f064f0c6b85d5dffb3101177b89f9992c1c9c7" translate="yes" xml:space="preserve">
          <source>Example test:</source>
          <target state="translated">测试示例:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用实例。</target>
        </trans-unit>
        <trans-unit id="626fc22c2346bdaad6212771621a1be1cbfe161c" translate="yes" xml:space="preserve">
          <source>Example using &lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt;&lt;code&gt;jest.fn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894889ec3b675e7dfe2d09ed5ff1a9d544cb19a2" translate="yes" xml:space="preserve">
          <source>Example using &lt;a href=&quot;jest-object#jestmockmodulename-factory-options&quot;&gt;automatic &lt;code&gt;jest.mock&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="e7ff0674cdf6ffae58fcf1d17cf527103ca0f99c" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/bower_components/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">示例： &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/bower_components/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="be81be2dc796bfe648c0ffaec826677af8dbaae5" translate="yes" xml:space="preserve">
          <source>Examples of dependencies that might be considered &quot;implementation details&quot; are things ranging from language built-ins (e.g. Array.prototype methods) to highly common utility methods (e.g. underscore/lo-dash, array utilities etc) and entire libraries like React.js.</source>
          <target state="translated">可能被认为是 &quot;实现细节 &quot;的依赖关系的例子包括从语言内置(如Array.prototype方法)到非常常见的实用方法(如下划线/lo-dash,数组实用程序等)和整个库,如React.js。</target>
        </trans-unit>
        <trans-unit id="0c49b696e0bea257422332f3a9cc49def2164712" translate="yes" xml:space="preserve">
          <source>Examples of dependencies that might be considered &quot;implementation details&quot; are things ranging from language built-ins (e.g. Array.prototype methods) to highly common utility methods (e.g. underscore/lo-dash, array utilities, etc) and entire libraries like React.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8555073aa38480ab4d24bc6e10b3c3a6d435c74a" translate="yes" xml:space="preserve">
          <source>Examples of such compilers include:</source>
          <target state="translated">这种编译器的例子包括:</target>
        </trans-unit>
        <trans-unit id="416308f6796b161308eac10d19357bbbc2a72314" translate="yes" xml:space="preserve">
          <source>Examples of watch plugins include:</source>
          <target state="translated">手表插件的例子包括:</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="1313d360bb16a7b6138236da32b21f4e7ed7a7ba" translate="yes" xml:space="preserve">
          <source>Executes only the macro task queue (i.e. all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; and &lt;code&gt;setImmediate()&lt;/code&gt;).</source>
          <target state="translated">仅执行宏任务队列（即，由 &lt;code&gt;setTimeout()&lt;/code&gt; 或 &lt;code&gt;setInterval()&lt;/code&gt; 和 &lt;code&gt;setImmediate()&lt;/code&gt; 排队的所有任务）。</target>
        </trans-unit>
        <trans-unit id="3eb459b18680d2e43398c41cf444b3d8402f2523" translate="yes" xml:space="preserve">
          <source>Executes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; up to this point). If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call.</source>
          <target state="translated">仅执行当前待处理的宏任务（即，仅到目前为止由 &lt;code&gt;setTimeout()&lt;/code&gt; 或 &lt;code&gt;setInterval()&lt;/code&gt; 排队的任务）。如果任何当前待处理的宏任务调度了新的宏任务，则这些新任务将不会通过此调用执行。</target>
        </trans-unit>
        <trans-unit id="3c4f4acc11d792baa1caf501e7e5f8ba241c5044" translate="yes" xml:space="preserve">
          <source>Exhausts all tasks queued by &lt;code&gt;setImmediate()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setImmediate()&lt;/code&gt; 由setImmediate（）排队的所有任务。</target>
        </trans-unit>
        <trans-unit id="c4db7db82b90f39ee739e36a7b63a98bed58ed23" translate="yes" xml:space="preserve">
          <source>Exhausts both the &lt;strong&gt;macro&lt;/strong&gt;-task queue (i.e., all tasks queued by &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setInterval()&lt;/code&gt;, and &lt;code&gt;setImmediate()&lt;/code&gt;) and the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="translated">废气两者&lt;strong&gt;宏&lt;/strong&gt; -task队列（即，由排队的所有任务 &lt;code&gt;setTimeout()&lt;/code&gt; ， &lt;code&gt;setInterval()&lt;/code&gt; ，和 &lt;code&gt;setImmediate()&lt;/code&gt; ）和&lt;strong&gt;微&lt;/strong&gt; -task队列（通常是通过接口连接在节点 &lt;code&gt;process.nextTick&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6f8147ef3f4371ae39d61271bddec0259649620d" translate="yes" xml:space="preserve">
          <source>Exhausts the &lt;strong&gt;micro&lt;/strong&gt;-task queue (usually interfaced in node via &lt;code&gt;process.nextTick&lt;/code&gt;).</source>
          <target state="translated">废气的&lt;strong&gt;微&lt;/strong&gt; -task队列（通常是通过接口连接在节点 &lt;code&gt;process.nextTick&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="5ace91ad2cbf9bda63ef9585bd51f774c05c729c" translate="yes" xml:space="preserve">
          <source>Explicitly supplies the mock object that the module system should return for the specified module.</source>
          <target state="translated">明确提供模块系统应该为指定模块返回的mock对象。</target>
        </trans-unit>
        <trans-unit id="bad5808b4c7ea92e7c146eae0b94df7ca7d7179a" translate="yes" xml:space="preserve">
          <source>Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.</source>
          <target state="translated">输出一个函数,将任何JavaScript值转换为人类可读的字符串。支持所有开箱即用的内置JavaScript类型,并允许通过用户定义的插件来扩展应用程序的特定类型。</target>
        </trans-unit>
        <trans-unit id="9fa5941d8206e78d8b9ca13243802ebceaeaed32" translate="yes" xml:space="preserve">
          <source>Express.js</source>
          <target state="translated">Express.js</target>
        </trans-unit>
        <trans-unit id="c7794e96c54b2b405e2be63ffda3e89b9afeb2a1" translate="yes" xml:space="preserve">
          <source>Failed snapshots can also be updated interactively in watch mode:</source>
          <target state="translated">失败的快照也可以在观察模式下交互更新。</target>
        </trans-unit>
        <trans-unit id="e41c8da6c1bdd48b470d7efc6bf68d044e506f33" translate="yes" xml:space="preserve">
          <source>Finally tests would look as follows:</source>
          <target state="translated">最后测试如下:</target>
        </trans-unit>
        <trans-unit id="04d6a7dc26ea6d1316b486419821aae0420ac220" translate="yes" xml:space="preserve">
          <source>Finally we can close the puppeteer instance and clean-up the file</source>
          <target state="translated">最后,我们可以关闭puppeteer实例,并清理文件中的</target>
        </trans-unit>
        <trans-unit id="97e7714725872b9c1984e5322d6f02dd30da60a2" translate="yes" xml:space="preserve">
          <source>Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:</source>
          <target state="translated">最后,为了让大家不那么苛刻地断言mock函数是如何被调用的,我们为大家添加了一些自定义匹配器函数。</target>
        </trans-unit>
        <trans-unit id="83ea460e76f8e03e89080e3127909c8138d82a71" translate="yes" xml:space="preserve">
          <source>Finally, run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;npm run test&lt;/code&gt; and Jest will print this message:</source>
          <target state="translated">最后，运行 &lt;code&gt;yarn test&lt;/code&gt; 或 &lt;code&gt;npm run test&lt;/code&gt; ，Jest将打印以下消息：</target>
        </trans-unit>
        <trans-unit id="bf4e9242ce7c9aedcbc07728e61f3c9ca615c3c8" translate="yes" xml:space="preserve">
          <source>Finally, set &lt;code&gt;jest.config.js&lt;/code&gt; to read from these files. (The &lt;code&gt;jest-puppeteer&lt;/code&gt; preset does something like this under the hood.)</source>
          <target state="translated">最后，将 &lt;code&gt;jest.config.js&lt;/code&gt; 设置为从这些文件读取。（ &lt;code&gt;jest-puppeteer&lt;/code&gt; 预设在后台执行类似的操作。）</target>
        </trans-unit>
        <trans-unit id="c58dd3c63800b63c725f717c03a6e41f1f30ddce" translate="yes" xml:space="preserve">
          <source>Finally, we can close the puppeteer instance and clean-up the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab0f38c4058b80ab0f4c885e3986fc16770c677" translate="yes" xml:space="preserve">
          <source>Finally, we need an environment which supports dynamic importing. Please see &lt;a href=&quot;getting-started#using-babel&quot;&gt;Using Babel&lt;/a&gt; for the initial setup. Then add the plugin &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-dynamic-import-node&quot;&gt;babel-plugin-dynamic-import-node&lt;/a&gt;, or an equivalent, to your Babel config to enable dynamic importing in Node.</source>
          <target state="translated">最后，我们需要一个支持动态导入的环境。请参阅&lt;a href=&quot;getting-started#using-babel&quot;&gt;使用Babel&lt;/a&gt;进行初始设置。然后将插件&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-dynamic-import-node&quot;&gt;babel-plugin-dynamic-import-node&lt;/a&gt;或等效项添加到Babel配置中，以在Node中启用动态导入。</target>
        </trans-unit>
        <trans-unit id="7c40bfe3ca4ca3e6970c1ba2f427bc5cf0ac97e5" translate="yes" xml:space="preserve">
          <source>Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with &lt;code&gt;--coverage&lt;/code&gt; to include a test coverage for the source files, no duplicate &lt;code&gt;--collectCoverageFrom&lt;/code&gt; arguments needed.</source>
          <target state="translated">查找并运行覆盖作为参数传递的源文件的空格分隔列表的测试。对于预提交的钩子集成有用，以运行最少数量的测试。可以与 &lt;code&gt;--coverage&lt;/code&gt; 一起使用，以包括源文件的测试范围，而无需重复的 &lt;code&gt;--collectCoverageFrom&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="6383d1303f59cd8ac9d056a3ec5b8a0155117bc7" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt;</source>
          <target state="translated">首先安装 &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc88fb87447ec13c40c34c214ea754c225ddc5c9" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;@shelf/jest-mongodb&lt;/code&gt;</source>
          <target state="translated">首先安装 &lt;code&gt;@shelf/jest-mongodb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee562eadcf9ddab28fe2316718a764478b89680" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;jest-puppeteer&lt;/code&gt;</source>
          <target state="translated">首先安装 &lt;code&gt;jest-puppeteer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="558ef585a8582382dd2312c86147f35d19fd7f2a" translate="yes" xml:space="preserve">
          <source>First row of variable name column headings separated with &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">变量名列标题的第一行以 &lt;code&gt;|&lt;/code&gt; 分隔</target>
        </trans-unit>
        <trans-unit id="49166127081da4be02dce4127fa195a83c32997f" translate="yes" xml:space="preserve">
          <source>First, enable Babel support in Jest as documented in the &lt;a href=&quot;getting-started#using-babel&quot;&gt;Getting Started&lt;/a&gt; guide.</source>
          <target state="translated">首先，按照&lt;a href=&quot;getting-started#using-babel&quot;&gt;入门指南&lt;/a&gt;中所述在Jest中启用Babel支持。</target>
        </trans-unit>
        <trans-unit id="d16e5d008fce7f05467a9145d4ac16509f499d9f" translate="yes" xml:space="preserve">
          <source>First, install &lt;code&gt;@shelf/jest-dynamodb&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af1d62296d52b040a359728684dbd9d97456583" translate="yes" xml:space="preserve">
          <source>First, install &lt;code&gt;jest-puppeteer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4fc028d306fad456b0b3c8d93f171ca540a302" translate="yes" xml:space="preserve">
          <source>First, you write a test, calling &lt;code&gt;.toMatchInlineSnapshot()&lt;/code&gt; with no arguments:</source>
          <target state="translated">首先，编写一个测试，不带任何参数调用 &lt;code&gt;.toMatchInlineSnapshot()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f28e9e3ebcc459ad6465344f6b958b9cb52a1efe" translate="yes" xml:space="preserve">
          <source>Follow the &lt;a href=&quot;https://twitter.com/fbjest&quot;&gt;Jest Twitter account&lt;/a&gt; and &lt;a href=&quot;https://jestjs.io/blog/&quot;&gt;blog&lt;/a&gt; to find out what's happening in the world of Jest.</source>
          <target state="translated">关注&lt;a href=&quot;https://twitter.com/fbjest&quot;&gt;Jest Twitter帐户&lt;/a&gt;和&lt;a href=&quot;https://jestjs.io/blog/&quot;&gt;博客&lt;/a&gt;，了解Jest世界中正在发生的事情。</target>
        </trans-unit>
        <trans-unit id="7e2083813e47a1016afe216d82d2bb0d3ee2f2cd" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;@types/*&lt;/code&gt; modules it's recommended to try to match the version of the associated module. For example, if you are using &lt;code&gt;26.4.0&lt;/code&gt; of &lt;code&gt;jest&lt;/code&gt; then using &lt;code&gt;26.4.x&lt;/code&gt; of &lt;code&gt;@types/jest&lt;/code&gt; is ideal. In general, try to match the major (&lt;code&gt;26&lt;/code&gt;) and minor (&lt;code&gt;4&lt;/code&gt;) version as closely as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2c453348c56f383fc00c98d57438686b82791f" translate="yes" xml:space="preserve">
          <source>For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">有关匹配器的完整列表，请参阅&lt;a href=&quot;expect&quot;&gt;参考文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="710d3ddee3d05ae5ac4aab2c9b427bcb07986d80" translate="yes" xml:space="preserve">
          <source>For additional Jest matchers maintained by the Jest Community check out &lt;a href=&quot;https://github.com/jest-community/jest-extended&quot;&gt;&lt;code&gt;jest-extended&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关Jest社区维护的其他Jest匹配器，请查看&lt;a href=&quot;https://github.com/jest-community/jest-extended&quot;&gt; &lt;code&gt;jest-extended&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3b2aa71d87b57fd9d29b8331034a72dff8b8da9" translate="yes" xml:space="preserve">
          <source>For an example of how to use Jest with Webpack with React, Redux, and Node, you can view one &lt;a href=&quot;https://github.com/jenniferabowd/jest_react_redux_node_webpack_complex_example&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">有关如何在带有React，Redux和Node的Webpack中使用Jest的示例，可以&lt;a href=&quot;https://github.com/jenniferabowd/jest_react_redux_node_webpack_complex_example&quot;&gt;在此处&lt;/a&gt;查看一个示例。</target>
        </trans-unit>
        <trans-unit id="ff533ca8de12b70302d788874c5ec33c12f132e5" translate="yes" xml:space="preserve">
          <source>For an individual test file, an added module precedes any modules from &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration, which precede the default snapshot serializers for built-in JavaScript types and for React elements. The last module added is the first module tested.</source>
          <target state="translated">对于单个测试文件，添加的模块位于 &lt;code&gt;snapshotSerializers&lt;/code&gt; 配置中的所有模块之前，后者针对内置JavaScript类型和React元素，位于默认快照序列化程序之前。添加的最后一个模块是测试的第一个模块。</target>
        </trans-unit>
        <trans-unit id="3c20f94a38a3d142e50b602bce344f49a6c0fbbf" translate="yes" xml:space="preserve">
          <source>For cases where we have methods that are typically chained (and thus always need to return &lt;code&gt;this&lt;/code&gt;), we have a sugary API to simplify this in the form of a &lt;code&gt;.mockReturnThis()&lt;/code&gt; function that also sits on all mocks:</source>
          <target state="translated">对于通常具有链式方法（因此总是需要返回 &lt;code&gt;this&lt;/code&gt; ）的情况，我们提供了一个含糖的API以 &lt;code&gt;.mockReturnThis()&lt;/code&gt; 函数的形式简化该方法，该函数也位于所有模拟中：</target>
        </trans-unit>
        <trans-unit id="4dcf53a0abd5dceefdabe8547430b633eb5fc312" translate="yes" xml:space="preserve">
          <source>For environments with variable CPUs available, you can use percentage based configuration: &lt;code&gt;--maxWorkers=50%&lt;/code&gt;</source>
          <target state="translated">对于具有可变CPU的环境，可以使用基于百分比的配置：-- &lt;code&gt;--maxWorkers=50%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cc1fa8955d4aa67143d0f4f14e4334b7f680c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;.toEqual&lt;/code&gt; and &lt;code&gt;.toBe&lt;/code&gt; behave differently in this test suite, so all the tests pass:</source>
          <target state="translated">例如， &lt;code&gt;.toEqual&lt;/code&gt; 和 &lt;code&gt;.toBe&lt;/code&gt; 在此测试套件中的行为不同，因此所有测试均通过：</target>
        </trans-unit>
        <trans-unit id="593913af50b6363a01b6e27cb17d3a8f783e3f15" translate="yes" xml:space="preserve">
          <source>For example, Jest ships with several plug-ins to &lt;code&gt;jasmine&lt;/code&gt; that work by monkey-patching the jasmine API. If you wanted to add even more jasmine plugins to the mix (or if you wanted some custom, project-wide matchers for example), you could do so in these modules.</source>
          <target state="translated">例如，Jest附带了几个 &lt;code&gt;jasmine&lt;/code&gt; 插件，它们通过猴子修补茉莉花API起作用。如果您想添加更多的茉莉花插件（例如，如果您想要一些自定义的，项目范围的匹配器），则可以在这些模块中进行。</target>
        </trans-unit>
        <trans-unit id="c97147f311fbef2d76543271148af18e8f65cb90" translate="yes" xml:space="preserve">
          <source>For example, compare:</source>
          <target state="translated">比如,比较。</target>
        </trans-unit>
        <trans-unit id="99b9f410a3e63e11e11d728aa4b998dca59892fd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;getAllFlavors()&lt;/code&gt; returns an array of flavors and you want to be sure that &lt;code&gt;lime&lt;/code&gt; is in there, you can write:</source>
          <target state="translated">例如，如果 &lt;code&gt;getAllFlavors()&lt;/code&gt; 返回一个味觉数组，并且您要确保其中包含 &lt;code&gt;lime&lt;/code&gt; ，则可以编写：</target>
        </trans-unit>
        <trans-unit id="12258129998b33cad901597baea7bc212492df25" translate="yes" xml:space="preserve">
          <source>For example, if both &lt;code&gt;initializeCityDatabase&lt;/code&gt; and &lt;code&gt;clearCityDatabase&lt;/code&gt; returned promises, and the city database could be reused between tests, we could change our test code to:</source>
          <target state="translated">例如，如果 &lt;code&gt;initializeCityDatabase&lt;/code&gt; 和 &lt;code&gt;clearCityDatabase&lt;/code&gt; 都返回了promise，并且城市数据库可以在测试之间重用，则可以将测试代码更改为：</target>
        </trans-unit>
        <trans-unit id="047e33c60bee55f41c10a3ae41e4a59ed4c6ef04" translate="yes" xml:space="preserve">
          <source>For example, if you have a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js&quot;&gt;Clock&lt;/a&gt; component that uses &lt;code&gt;Date.now()&lt;/code&gt;, the snapshot generated from this component will be different every time the test case is run. In this case we can &lt;a href=&quot;mock-functions&quot;&gt;mock the Date.now() method&lt;/a&gt; to return a consistent value every time the test is run:</source>
          <target state="translated">例如，如果您有一个使用 &lt;code&gt;Date.now()&lt;/code&gt; 的&lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js&quot;&gt;Clock&lt;/a&gt;组件，则每次运行测试用例时，从该组件生成的快照都会有所不同。在这种情况下，我们可以&lt;a href=&quot;mock-functions&quot;&gt;模拟Date.now（）方法&lt;/a&gt;以在每次运行测试时返回一致的值：</target>
        </trans-unit>
        <trans-unit id="0c52624003569af07b46970b0fc720da677fe0f5" translate="yes" xml:space="preserve">
          <source>For example, if you have tests in source files named with &lt;code&gt;.t.js&lt;/code&gt; extension as following:</source>
          <target state="translated">例如，如果您在以 &lt;code&gt;.t.js&lt;/code&gt; 扩展名命名的源文件中进行测试，如下所示：</target>
        </trans-unit>
        <trans-unit id="79b8e6df861979cd63ed28c4a41073bec4389d31" translate="yes" xml:space="preserve">
          <source>For example, if you want to respect Browserify's &lt;a href=&quot;https://github.com/browserify/browserify-handbook/blob/master/readme.markdown#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt;, you can use the following configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ce97754ad0ae68a81e69708826f13c59f1a71e" translate="yes" xml:space="preserve">
          <source>For example, if your code depends on a third party native video component called &lt;code&gt;react-native-video&lt;/code&gt; you might want to stub it out with a manual mock like this:</source>
          <target state="translated">例如，如果您的代码依赖于称为&amp;ldquo; &lt;code&gt;react-native-video&lt;/code&gt; &amp;rdquo;的第三方本机视频组件，则可能需要使用如下的手动模拟将其存根：</target>
        </trans-unit>
        <trans-unit id="594cf95e63a36ce4ead65bcac2606fb4793f5b72" translate="yes" xml:space="preserve">
          <source>For example, if your tests call &lt;code&gt;Math&lt;/code&gt; often, you can pass it by setting &lt;code&gt;extraGlobals&lt;/code&gt;.</source>
          <target state="translated">例如，如果您的测试经常调用 &lt;code&gt;Math&lt;/code&gt; ，则可以通过设置 &lt;code&gt;extraGlobals&lt;/code&gt; 传递它。</target>
        </trans-unit>
        <trans-unit id="6c1f5a22319beabdfbabd11912aaeb825ac6e178" translate="yes" xml:space="preserve">
          <source>For example, let's say &lt;code&gt;fetchBeverageList()&lt;/code&gt; returns a promise that is supposed to resolve to a list that has &lt;code&gt;lemon&lt;/code&gt; in it. You can test this with:</source>
          <target state="translated">例如，假设 &lt;code&gt;fetchBeverageList()&lt;/code&gt; 返回一个promise，该promise应该解析为其中包含 &lt;code&gt;lemon&lt;/code&gt; 的列表。您可以使用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="91bf2dd9d08b2408d6850dcb0015666facf63d27" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;drinkFlavor&lt;/code&gt; is coded like this:</source>
          <target state="translated">例如，假设 &lt;code&gt;drinkFlavor&lt;/code&gt; 的编码如下：</target>
        </trans-unit>
        <trans-unit id="1756cef91c9a3477b1322242e385d60cc54ab610" translate="yes" xml:space="preserve">
          <source>For example, let's say that &lt;code&gt;fetchData&lt;/code&gt;, instead of using a callback, returns a promise that is supposed to resolve to the string &lt;code&gt;'peanut butter'&lt;/code&gt;. We could test it with:</source>
          <target state="translated">例如，假设 &lt;code&gt;fetchData&lt;/code&gt; 而不是使用回调，而是返回应被解析为字符串 &lt;code&gt;'peanut butter'&lt;/code&gt; 的promise 。我们可以用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="8f15af66e6a6e677b2e452f62fe482a06d1fa9e2" translate="yes" xml:space="preserve">
          <source>For example, let's say that several tests interact with a database of cities. You have a method &lt;code&gt;initializeCityDatabase()&lt;/code&gt; that must be called before each of these tests, and a method &lt;code&gt;clearCityDatabase()&lt;/code&gt; that must be called after each of these tests. You can do this with:</source>
          <target state="translated">例如，假设几个测试与城市数据库进行交互。您有一个必须在每个测试之前调用的 &lt;code&gt;initializeCityDatabase()&lt;/code&gt; 方法，以及一个必须在每个测试之后调用 &lt;code&gt;clearCityDatabase()&lt;/code&gt; 的方法。您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="ce6dbac819240657572137dc7fbd2f85952399df" translate="yes" xml:space="preserve">
          <source>For example, let's say that we expect an &lt;code&gt;onPress&lt;/code&gt; function to be called with an &lt;code&gt;Event&lt;/code&gt; object, and all we need to verify is that the event has &lt;code&gt;event.x&lt;/code&gt; and &lt;code&gt;event.y&lt;/code&gt; properties. We can do that with:</source>
          <target state="translated">例如，假设我们希望通过 &lt;code&gt;Event&lt;/code&gt; 对象调用 &lt;code&gt;onPress&lt;/code&gt; 函数，而我们需要验证的只是该事件具有 &lt;code&gt;event.x&lt;/code&gt; 和 &lt;code&gt;event.y&lt;/code&gt; 属性。我们可以这样做：</target>
        </trans-unit>
        <trans-unit id="874efdb115adcb599b6389e915c72466eb139681" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a few functions that all deal with state. &lt;code&gt;prepareState&lt;/code&gt; calls a callback with a state object, &lt;code&gt;validateState&lt;/code&gt; runs on that state object, and &lt;code&gt;waitOnState&lt;/code&gt; returns a promise that waits until all &lt;code&gt;prepareState&lt;/code&gt; callbacks complete. We can test this with:</source>
          <target state="translated">例如，假设我们有一些全部处理状态的函数。 &lt;code&gt;prepareState&lt;/code&gt; 调用带有状态对象的回调， &lt;code&gt;validateState&lt;/code&gt; 在该状态对象上运行，并且 &lt;code&gt;waitOnState&lt;/code&gt; 返回一个等待直到所有 &lt;code&gt;prepareState&lt;/code&gt; 回调完成的promise 。我们可以使用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="6b90133a1da2bd721be03a9878aced8ee87402d1" translate="yes" xml:space="preserve">
          <source>For example, let's say that we have a function &lt;code&gt;doAsync&lt;/code&gt; that receives two callbacks &lt;code&gt;callback1&lt;/code&gt; and &lt;code&gt;callback2&lt;/code&gt;, it will asynchronously call both of them in an unknown order. We can test this with:</source>
          <target state="translated">例如，假设我们有一个函数 &lt;code&gt;doAsync&lt;/code&gt; ，它接收两个回调 &lt;code&gt;callback1&lt;/code&gt; 和 &lt;code&gt;callback2&lt;/code&gt; ，它将以未知顺序异步调用它们。我们可以使用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="bbbbc61e2c5d99dfb2d92614d0dd1192b0d88661" translate="yes" xml:space="preserve">
          <source>For example, let's say that you can register a beverage with a &lt;code&gt;register&lt;/code&gt; function, and &lt;code&gt;applyToAll(f)&lt;/code&gt; should apply the function &lt;code&gt;f&lt;/code&gt; to all registered beverages. To make sure this works, you could write:</source>
          <target state="translated">例如，假设您可以使用 &lt;code&gt;register&lt;/code&gt; 函数注册饮料， &lt;code&gt;applyToAll(f)&lt;/code&gt; 应该将函数 &lt;code&gt;f&lt;/code&gt; 应用于所有注册的饮料。为确保此方法有效，您可以编写：</target>
        </trans-unit>
        <trans-unit id="931d136a254e4d07f405b22f0ffa92a1088a08ec" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a &lt;code&gt;fetchData(callback)&lt;/code&gt; function that fetches some data and calls &lt;code&gt;callback(data)&lt;/code&gt; when it is complete. You want to test that this returned data is the string &lt;code&gt;'peanut butter'&lt;/code&gt;.</source>
          <target state="translated">例如，假设您有一个 &lt;code&gt;fetchData(callback)&lt;/code&gt; 函数，该函数可获取一些数据并在完成后调用 &lt;code&gt;callback(data)&lt;/code&gt; 。您想测试返回的数据是否为字符串 &lt;code&gt;'peanut butter'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40273c01c92ebe97ba2ea977841c404bf2c262a8" translate="yes" xml:space="preserve">
          <source>For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:</source>
          <target state="translated">比如说,我们不仅有城市数据库,还有食品数据库。我们可以针对不同的测试做不同的设置。</target>
        </trans-unit>
        <trans-unit id="f5a8741fbad45210a09db8ad6539e976d1dec113" translate="yes" xml:space="preserve">
          <source>For example, let's say you had these tests:</source>
          <target state="translated">例如,假设你做了这些测试。</target>
        </trans-unit>
        <trans-unit id="144429e39562897fbccf4b94d4f8adfc39339a49" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkAll(drink, flavour)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to all available beverages. You might want to check that &lt;code&gt;drink&lt;/code&gt; gets called for &lt;code&gt;'lemon'&lt;/code&gt;, but not for &lt;code&gt;'octopus'&lt;/code&gt;, because &lt;code&gt;'octopus'&lt;/code&gt; flavour is really weird and why would anything be octopus-flavoured? You can do that with this test suite:</source>
          <target state="translated">例如，假设您有一个 &lt;code&gt;drinkAll(drink, flavour)&lt;/code&gt; 函数，该函数具有 &lt;code&gt;drink&lt;/code&gt; 功能并将其应用于所有可用的酒水。您可能想检查一下 &lt;code&gt;drink&lt;/code&gt; 被称为 &lt;code&gt;'lemon'&lt;/code&gt; ，而不是 &lt;code&gt;'octopus'&lt;/code&gt; ，因为 &lt;code&gt;'octopus'&lt;/code&gt; 味道真的很奇怪，为什么章鱼味道呢？您可以使用以下测试套件进行此操作：</target>
        </trans-unit>
        <trans-unit id="fc5e0f3cd06a5bf9c4dca1f40534b4b77ff28e3e" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that takes a &lt;code&gt;drink&lt;/code&gt; function and applies it to array of passed beverages. You might want to check that drink function was called exact number of times. You can do that with this test suite:</source>
          <target state="translated">例如，假设你有一个 &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; ，需要一个功能 &lt;code&gt;drink&lt;/code&gt; 功能，它适用于通过饮料的阵列。您可能要检查饮料功能是否被调用了确切次数。您可以使用以下测试套件进行此操作：</target>
        </trans-unit>
        <trans-unit id="1a18e498dc37e770eebf9088b5657094b5df58eb" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a &lt;code&gt;drinkFlavor&lt;/code&gt; function that throws whenever the flavor is &lt;code&gt;'octopus'&lt;/code&gt;, and is coded like this:</source>
          <target state="translated">例如，假设您有一个 &lt;code&gt;drinkFlavor&lt;/code&gt; 函数，该函数会在口味为 &lt;code&gt;'octopus'&lt;/code&gt; 时抛出该异常，并且其编码如下：</target>
        </trans-unit>
        <trans-unit id="ec0e394a329140aa320ffab5691064eca7211fef" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="translated">例如，假设您有一个返回 &lt;code&gt;true&lt;/code&gt; 的模拟 &lt;code&gt;drink&lt;/code&gt; 。你可以写：</target>
        </trans-unit>
        <trans-unit id="96cb3fce436e959ed4ff1a604e78cbd23c2e2492" translate="yes" xml:space="preserve">
          <source>For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns the name of the beverage that was consumed. You can write:</source>
          <target state="translated">例如，假设您有一个模拟 &lt;code&gt;drink&lt;/code&gt; ，该模拟饮料返回所消费饮料的名称。你可以写：</target>
        </trans-unit>
        <trans-unit id="fc0ef20a9a16b71f44a801db2115dcf4ceaa7ed0" translate="yes" xml:space="preserve">
          <source>For example, the following would create a global &lt;code&gt;__DEV__&lt;/code&gt; variable set to &lt;code&gt;true&lt;/code&gt; in all test environments:</source>
          <target state="translated">例如，以下代码将创建一个在所有测试环境中均设置为 &lt;code&gt;true&lt;/code&gt; 的全局 &lt;code&gt;__DEV__&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="071b4caddeb027fae4504867a5d3ff914e164bce" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise rejects with reason &lt;code&gt;'octopus'&lt;/code&gt;:</source>
          <target state="translated">例如，以下代码测试承诺是否因 &lt;code&gt;'octopus'&lt;/code&gt; 而被拒绝：</target>
        </trans-unit>
        <trans-unit id="5f2a13885f18e36be7159ff50e29caef2aee6935" translate="yes" xml:space="preserve">
          <source>For example, this code tests that the promise resolves and that the resulting value is &lt;code&gt;'lemon'&lt;/code&gt;:</source>
          <target state="translated">例如，下面的代码测试promise可以解决，并且结果值为 &lt;code&gt;'lemon'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bcd7db6ccfa8b4522705daf177fc8fdd66902a9e" translate="yes" xml:space="preserve">
          <source>For example, this code will validate some properties of the &lt;code&gt;can&lt;/code&gt; object:</source>
          <target state="translated">例如，此代码将验证 &lt;code&gt;can&lt;/code&gt; 对象的某些属性：</target>
        </trans-unit>
        <trans-unit id="21990133d4e4885c717a863643a6c3db329fd8fc" translate="yes" xml:space="preserve">
          <source>For example, this preset &lt;code&gt;foo-bar/jest-preset.js&lt;/code&gt; will be configured as follows:</source>
          <target state="translated">例如，此预设 &lt;code&gt;foo-bar/jest-preset.js&lt;/code&gt; 将配置如下：</target>
        </trans-unit>
        <trans-unit id="d25aae8531d1e8531e7ef2e9d4e5ce8e21cb5f02" translate="yes" xml:space="preserve">
          <source>For example, this test passes with a precision of 5 digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75730b175681e09d4947af40aa96097263db660e" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:</source>
          <target state="translated">例如,在以下配置中,如果分支、行和函数的覆盖率低于 80%,或者有超过 10 条未覆盖的语句,jest 将失败。</target>
        </trans-unit>
        <trans-unit id="21691166486d6f854fcdbed969ad08f56c5be3d3" translate="yes" xml:space="preserve">
          <source>For example, with the following configuration:</source>
          <target state="translated">例如,采用以下配置。</target>
        </trans-unit>
        <trans-unit id="1d8bc1522a1c4b58ae364d57035e63c01139aac7" translate="yes" xml:space="preserve">
          <source>For example, you might not know what exactly &lt;code&gt;essayOnTheBestFlavor()&lt;/code&gt; returns, but you know it's a really long string, and the substring &lt;code&gt;grapefruit&lt;/code&gt; should be in there somewhere. You can test this with:</source>
          <target state="translated">例如，您可能不知道 &lt;code&gt;essayOnTheBestFlavor()&lt;/code&gt; 到底返回了什么，但是您知道这是一个很长的字符串，子字符串的 &lt;code&gt;grapefruit&lt;/code&gt; 应该在其中。您可以使用以下方法进行测试：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ff56bde239ab874f2e956a43f1424bb53acc1ac4" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called three times, returning &lt;code&gt;'result1'&lt;/code&gt;, throwing an error, and then returning &lt;code&gt;'result2'&lt;/code&gt;, would have a &lt;code&gt;mock.results&lt;/code&gt; array that looks like this:</source>
          <target state="translated">例如：一个已经调用过三次的模拟函数 &lt;code&gt;f&lt;/code&gt; ，返回 &lt;code&gt;'result1'&lt;/code&gt; ，抛出一个错误，然后返回 &lt;code&gt;'result2'&lt;/code&gt; ，将具有一个 &lt;code&gt;mock.results&lt;/code&gt; 数组，如下所示：</target>
        </trans-unit>
        <trans-unit id="d872a792c7892418e5f9ff3ed51e783257317905" translate="yes" xml:space="preserve">
          <source>For example: A mock function &lt;code&gt;f&lt;/code&gt; that has been called twice, with the arguments &lt;code&gt;f('arg1', 'arg2')&lt;/code&gt;, and then with the arguments &lt;code&gt;f('arg3', 'arg4')&lt;/code&gt;, would have a &lt;code&gt;mock.calls&lt;/code&gt; array that looks like this:</source>
          <target state="translated">例如：一个模拟函数 &lt;code&gt;f&lt;/code&gt; 被调用两次，其参数为 &lt;code&gt;f('arg1', 'arg2')&lt;/code&gt; ，然后参数为 &lt;code&gt;f('arg3', 'arg4')&lt;/code&gt; ，则将具有一个 &lt;code&gt;mock.calls&lt;/code&gt; 数组。看起来像这样：</target>
        </trans-unit>
        <trans-unit id="f1cd0da2a66dfee53a78bdc3fd98cf8483f85a33" translate="yes" xml:space="preserve">
          <source>For example: A mock function that has been instantiated twice would have the following &lt;code&gt;mock.instances&lt;/code&gt; array:</source>
          <target state="translated">例如：被实例化两次的模拟函数将具有以下 &lt;code&gt;mock.instances&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="83c176f04f272523170bec5099eee267107d1f94" translate="yes" xml:space="preserve">
          <source>For floating point equality, use &lt;code&gt;toBeCloseTo&lt;/code&gt; instead of &lt;code&gt;toEqual&lt;/code&gt;, because you don't want a test to depend on a tiny rounding error.</source>
          <target state="translated">对于浮点相等，请使用 &lt;code&gt;toBeCloseTo&lt;/code&gt; 而不是 &lt;code&gt;toEqual&lt;/code&gt; ，因为您不希望测试依赖于微小的舍入误差。</target>
        </trans-unit>
        <trans-unit id="c045e0e7243305deaa4aee87493fdfd39783b37b" translate="yes" xml:space="preserve">
          <source>For stability and safety reasons, only part of the global configuration keys can be updated with &lt;code&gt;updateConfigAndRun&lt;/code&gt;. The current white list is as follows:</source>
          <target state="translated">出于稳定性和安全性考虑，只能使用 &lt;code&gt;updateConfigAndRun&lt;/code&gt; 更新部分全局配置密钥。当前的白名单如下：</target>
        </trans-unit>
        <trans-unit id="69a7c9a4e0245435de418c334db84fd3e1be66eb" translate="yes" xml:space="preserve">
          <source>For the additional information about the options object shape you can refer to &lt;code&gt;CoverageReporterWithOptions&lt;/code&gt; type in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-types/src/Config.ts&quot;&gt;type definitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66fb40c58c7f7d3b21d1398dcbcf990f95330c9" translate="yes" xml:space="preserve">
          <source>For the contrived example, the mock might look like this:</source>
          <target state="translated">对于人为的例子,模拟可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4cf5108e3716a31ac868c82b64f26462d0db96cf" translate="yes" xml:space="preserve">
          <source>For the full list of methods and argument types see &lt;code&gt;Reporter&lt;/code&gt; interface in &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts&quot;&gt;packages/jest-reporters/src/types.ts&lt;/a&gt;</source>
          <target state="translated">有关方法和参数类型的完整列表，请参阅&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-reporters/src/types.ts&quot;&gt;packages / jest-reporters / src / types.ts中的&lt;/a&gt; &lt;code&gt;Reporter&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="f2c50f795c83753fddbef63571049b5a7a72e84b" translate="yes" xml:space="preserve">
          <source>For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:</source>
          <target state="translated">对于这些情况,Jest 允许为任何属性提供非对称匹配器。这些匹配器在快照被写入或测试之前被检查,然后保存到快照文件中,而不是接收到的值。</target>
        </trans-unit>
        <trans-unit id="51b7572af95fd60bcf8235bd8bc18e747afefdc9" translate="yes" xml:space="preserve">
          <source>Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up. &lt;em&gt;Note: This feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use &lt;code&gt;--detectOpenHandles&lt;/code&gt; to help track it down.&lt;/em&gt;</source>
          <target state="translated">所有测试完成运行后，强制Jest退出。当无法充分清理由测试代码设置的资源时，这很有用。&lt;em&gt;注意：此功能是一个逃生舱口盖。如果Jest在测试运行结束时没有退出，则意味着外部资源仍在保留，或者计时器仍在代码中挂起。建议在每次测试后拆除外部资源，以确保Jest可以干净地关闭。您可以使用 &lt;code&gt;--detectOpenHandles&lt;/code&gt; 来帮助跟踪。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2a8a4fbef38bbbe48000abe9f4946c616769cb5" translate="yes" xml:space="preserve">
          <source>Forces test results output highlighting even if stdout is not a TTY.</source>
          <target state="translated">即使stdout不是TTY,也会强制高亮输出测试结果。</target>
        </trans-unit>
        <trans-unit id="73a47003cfd2a3396a2450eecc7022eb5baf66b2" translate="yes" xml:space="preserve">
          <source>Framework Guides</source>
          <target state="translated">框架指南</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="79e9687ea7f127fc79ca8e5c0f48f0aeee5eb4b5" translate="yes" xml:space="preserve">
          <source>From here you can choose to update that snapshot or skip to the next:</source>
          <target state="translated">从这里你可以选择更新该快照或跳到下一个。</target>
        </trans-unit>
        <trans-unit id="61384321378d81043daaf7aa5004f9649b760e53" translate="yes" xml:space="preserve">
          <source>GatsbyJS</source>
          <target state="translated">GatsbyJS</target>
        </trans-unit>
        <trans-unit id="75fabb5a96311113ca298de2d0ecaaa2aae1996e" translate="yes" xml:space="preserve">
          <source>General Advice</source>
          <target state="translated">一般性建议</target>
        </trans-unit>
        <trans-unit id="98ffaf821b2d9a8192a641c430a1e7c2be181a98" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file</source>
          <target state="translated">生成一个基本配置文件</target>
        </trans-unit>
        <trans-unit id="4eff11ad6cc06e2f1ac1a723dc83bfd6e1768cde" translate="yes" xml:space="preserve">
          <source>Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a &lt;code&gt;jest.config.js&lt;/code&gt; file with a short description for each option.</source>
          <target state="translated">生成基本配置文件。根据您的项目，Jest会问您几个问题，这些问题将有助于生成一个 &lt;code&gt;jest.config.js&lt;/code&gt; 文件，其中包含每个选项的简短描述。</target>
        </trans-unit>
        <trans-unit id="f2c15ec8813d8414ee1697eec1942000cc70d8ec" translate="yes" xml:space="preserve">
          <source>Generate unique test titles by positionally injecting parameters with &lt;a href=&quot;https://nodejs.org/api/util.html#util_util_format_format_args&quot;&gt;&lt;code&gt;printf&lt;/code&gt; formatting&lt;/a&gt;:</source>
          <target state="translated">通过使用&lt;a href=&quot;https://nodejs.org/api/util.html#util_util_format_format_args&quot;&gt; &lt;code&gt;printf&lt;/code&gt; 格式&lt;/a&gt;在位置上注入参数来生成唯一的测试标题：</target>
        </trans-unit>
        <trans-unit id="e54dc9738cd540bb6ba39267578b63bf772cd9d8" translate="yes" xml:space="preserve">
          <source>Generating code coverage for test files using Puppeteer is currently not possible if your test uses &lt;code&gt;page.$eval&lt;/code&gt;, &lt;code&gt;page.$$eval&lt;/code&gt; or &lt;code&gt;page.evaluate&lt;/code&gt; as the passed function is executed outside of Jest's scope. Check out &lt;a href=&quot;https://github.com/facebook/jest/issues/7962#issuecomment-495272339&quot;&gt;issue #7962&lt;/a&gt; on GitHub for a workaround.</source>
          <target state="translated">如果您的测试使用 &lt;code&gt;page.$eval&lt;/code&gt; ， &lt;code&gt;page.$$eval&lt;/code&gt; 或 &lt;code&gt;page.evaluate&lt;/code&gt; ，则当前无法使用Puppeteer为测试文件生成代码覆盖，因为传递的函数是在Jest的范围之外执行的。在GitHub上查看&lt;a href=&quot;https://github.com/facebook/jest/issues/7962#issuecomment-495272339&quot;&gt;问题＃7962，&lt;/a&gt;以找到解决方法。</target>
        </trans-unit>
        <trans-unit id="6bd13d25dc262c99d9c8684b86741b04a10d005f" translate="yes" xml:space="preserve">
          <source>Get a deeper insight into testing a working React Native app example by reading the following series: &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-1-snapshots-come-into-play/&quot;&gt;Part 1: Jest &amp;ndash; Snapshot come into play&lt;/a&gt; and &lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-2-redux-snapshots-for-your-actions-and-reducers/&quot;&gt;Part 2: Jest &amp;ndash; Redux Snapshots for your Actions and Reducers&lt;/a&gt;.</source>
          <target state="translated">通过阅读以下系列文章，可以更深入地了解如何测试可正常运行的React Native应用程序示例：&lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-1-snapshots-come-into-play/&quot;&gt;第1部分：Jest &amp;ndash;快照&lt;/a&gt;；&lt;a href=&quot;https://callstack.com/blog/testing-react-native-with-the-new-jest-part-2-redux-snapshots-for-your-actions-and-reducers/&quot;&gt;第2部分：Jest &amp;ndash;用于Actions和Reducers的Redux快照&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="799d464814c35b3c4f2bd970cbd9a5bc23b78618" translate="yes" xml:space="preserve">
          <source>Gets called at the end of every test run. It has the test results as an argument.</source>
          <target state="translated">在每次测试运行结束时被调用。它将测试结果作为参数。</target>
        </trans-unit>
        <trans-unit id="df67fe80f33086b3ebe3ae445504840168a6c71b" translate="yes" xml:space="preserve">
          <source>Gets called whenever there is a change in the file system</source>
          <target state="translated">每当文件系统发生变化时就会被调用。</target>
        </trans-unit>
        <trans-unit id="0521fc5aa1b1f1dced820bdf16633c65d66fda68" translate="yes" xml:space="preserve">
          <source>Given the name of a module, use the automatic mocking system to generate a mocked version of the module for you.</source>
          <target state="translated">给定一个模块的名称,使用自动嘲讽系统为你生成一个模块的嘲讽版本。</target>
        </trans-unit>
        <trans-unit id="3f827c66e7e04723ed3fa1ab0945dff3f10b9b83" translate="yes" xml:space="preserve">
          <source>Globals</source>
          <target state="translated">Globals</target>
        </trans-unit>
        <trans-unit id="66e11c5171519fb11b18776bac2f49b3ef8097c8" translate="yes" xml:space="preserve">
          <source>Go ahead and accept the changes by running the above command. You may also use the equivalent single-character &lt;code&gt;-u&lt;/code&gt; flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.</source>
          <target state="translated">继续并通过运行上述命令接受更改。如果愿意，您也可以使用等效的单字符 &lt;code&gt;-u&lt;/code&gt; 标志重新生成快照。这将为所有失败的快照测试重新生成快照工件。如果由于意外错误而导致快照测试失败，则需要在重新生成快照之前修复该错误，以避免记录有关错误行为的快照。</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="9492d9787956a33e31c7c7ed4f3132bf12917883" translate="yes" xml:space="preserve">
          <source>Guides: Introduction</source>
          <target state="translated">指南。指南:介绍</target>
        </trans-unit>
        <trans-unit id="3a1cb6486159f8fb716bc26925fc1b77ba78c39a" translate="yes" xml:space="preserve">
          <source>Handling Static Assets</source>
          <target state="translated">处理静态资产</target>
        </trans-unit>
        <trans-unit id="6369709b1fbe417fc63d4b35c4dbdfedf548e0b0" translate="yes" xml:space="preserve">
          <source>Hapi.js</source>
          <target state="translated">Hapi.js</target>
        </trans-unit>
        <trans-unit id="4c8c7c374697b9a0908767f6b8abbf4ca28b782b" translate="yes" xml:space="preserve">
          <source>Help:</source>
          <target state="translated">Help:</target>
        </trans-unit>
        <trans-unit id="8590c3106f1d77bf4a9ae5f0686ed9ef3f06f737" translate="yes" xml:space="preserve">
          <source>Here is a brief overview:</source>
          <target state="translated">下面简单介绍一下。</target>
        </trans-unit>
        <trans-unit id="8b82314997735c45eace267e10004814f476844b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterAll&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after all tests run.</source>
          <target state="translated">在这里 &lt;code&gt;afterAll&lt;/code&gt; 确保在所有测试运行后调用 &lt;code&gt;cleanUpDatabase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f53ee15f468af76ea014ce3192ad96c9f2769b46" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;afterEach&lt;/code&gt; ensures that &lt;code&gt;cleanUpDatabase&lt;/code&gt; is called after each test runs.</source>
          <target state="translated">在此， &lt;code&gt;afterEach&lt;/code&gt; 确保每次运行测试后都调用 &lt;code&gt;cleanUpDatabase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f2c6ca85b8f247386b644a9b9448050fb98ba8b" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeAll&lt;/code&gt; ensures that the database is set up before tests run. If setup was synchronous, you could do this without &lt;code&gt;beforeAll&lt;/code&gt;. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.</source>
          <target state="translated">在这里， &lt;code&gt;beforeAll&lt;/code&gt; 确保在测试运行之前已建立数据库。如果设置是同步的，则可以在没有 &lt;code&gt;beforeAll&lt;/code&gt; 的情况下执行此操作。关键是Jest将等待一个诺言解决，因此您也可以进行异步设置。</target>
        </trans-unit>
        <trans-unit id="c986af0e0e93ca9be7580639b72afacb632a1fd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;beforeEach&lt;/code&gt; ensures that the database is reset for each test.</source>
          <target state="translated">在此， &lt;code&gt;beforeEach&lt;/code&gt; 确保为每个测试重置数据库。</target>
        </trans-unit>
        <trans-unit id="a11a344028eaa93e6dbdbf6a41de62398cbc4d4f" translate="yes" xml:space="preserve">
          <source>Here we enable fake timers by calling &lt;code&gt;jest.useFakeTimers();&lt;/code&gt;. This mocks out setTimeout and other timer functions with mock functions. If running multiple tests inside of one file or describe block, &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; can be called before each test manually or with a setup function such as &lt;code&gt;beforeEach&lt;/code&gt;. Not doing so will result in the internal usage counter not being reset.</source>
          <target state="translated">在这里，我们通过调用 &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; 来启用伪定时器。。这将使用模拟功能模拟setTimeout和其他计时器函数。如果在一个文件或描述块内运行多个测试，请 &lt;code&gt;jest.useFakeTimers();&lt;/code&gt; 。可以在每次测试之前手动调用，也可以使用诸如 &lt;code&gt;beforeEach&lt;/code&gt; 之类的设置函数调用。不这样做将导致内部使用计数器不被重置。</target>
        </trans-unit>
        <trans-unit id="3296e4a9a937d655fc487d89d44cc0a7f825b550" translate="yes" xml:space="preserve">
          <source>Here's a complete test file which uses the module factory parameter to &lt;code&gt;jest.mock&lt;/code&gt;:</source>
          <target state="translated">这是一个完整的测试文件，它使用模块工厂参数来 &lt;code&gt;jest.mock&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d23bc1c8fad4267f600ff0f8ca654e743fe48303" translate="yes" xml:space="preserve">
          <source>Here's a contrived example where we have a module that provides a summary of all the files in a given directory. In this case we use the core (built in) &lt;code&gt;fs&lt;/code&gt; module.</source>
          <target state="translated">这是一个人为的示例，其中我们有一个模块，可提供给定目录中所有文件的摘要。在这种情况下，我们使用核心（内置） &lt;code&gt;fs&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="af5096a5f845aa4a2f75149a370a3e6972e98140" translate="yes" xml:space="preserve">
          <source>Here's a contrived example where we have a module that provides a summary of all the files in a given directory. In this case, we use the core (built in) &lt;code&gt;fs&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0ef58a95e5aba79279e07fb2a779d1b19111a2" translate="yes" xml:space="preserve">
          <source>Here's a snapshot matcher that trims a string to store for a given length, &lt;code&gt;.toMatchTrimmedSnapshot(length)&lt;/code&gt;:</source>
          <target state="translated">这是一个快照匹配器，它修剪一个字符串以存储给定长度 &lt;code&gt;.toMatchTrimmedSnapshot(length)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50ca12756b3286d1c69b00aa0dfabdef931475e9" translate="yes" xml:space="preserve">
          <source>Here's an example of the GlobalSetup script</source>
          <target state="translated">下面是GlobalSetup脚本的一个例子。</target>
        </trans-unit>
        <trans-unit id="b0a016b4fe86ae49e4048497e86b5fd1a869d608" translate="yes" xml:space="preserve">
          <source>Here's how to run Jest on files matching &lt;code&gt;my-test&lt;/code&gt;, using &lt;code&gt;config.json&lt;/code&gt; as a configuration file and display a native OS notification after the run:</source>
          <target state="translated">以下是使用 &lt;code&gt;config.json&lt;/code&gt; 作为配置文件在与 &lt;code&gt;my-test&lt;/code&gt; 匹配的文件上运行Jest的方法，并在运行后显示本机OS通知：</target>
        </trans-unit>
        <trans-unit id="aa62494bb2468633777100c6526141484e1a9ce8" translate="yes" xml:space="preserve">
          <source>Here's the code of &lt;a href=&quot;https://github.com/xfumihiro/jest-puppeteer-example&quot;&gt;full working example&lt;/a&gt;.</source>
          <target state="translated">这是&lt;a href=&quot;https://github.com/xfumihiro/jest-puppeteer-example&quot;&gt;完整的示例示例&lt;/a&gt;的代码。</target>
        </trans-unit>
        <trans-unit id="60b880c8aa5a70aa5b6710448f8f53b517ba3960" translate="yes" xml:space="preserve">
          <source>Hooking into Jest</source>
          <target state="translated">钩入Jest</target>
        </trans-unit>
        <trans-unit id="53fb52372b98a249bee2e92c10585f1138a3a8d1" translate="yes" xml:space="preserve">
          <source>How do I resolve conflicts within snapshot files?</source>
          <target state="translated">如何解决快照文件内的冲突?</target>
        </trans-unit>
        <trans-unit id="139e29398f2627a8696250a9f26ea0f35d4fe9da" translate="yes" xml:space="preserve">
          <source>However, if you ran that test you would find that the &lt;code&gt;createUser&lt;/code&gt; function would fail, throwing the error: &lt;code&gt;TypeError: response.text is not a function&lt;/code&gt;. This is because the &lt;code&gt;Response&lt;/code&gt; class you've imported from &lt;code&gt;node-fetch&lt;/code&gt; has been mocked (due to the &lt;code&gt;jest.mock&lt;/code&gt; call at the top of the test file) so it no longer behaves the way it should.</source>
          <target state="translated">但是，如果运行该测试，您会发现 &lt;code&gt;createUser&lt;/code&gt; 函数将失败，并抛出错误： &lt;code&gt;TypeError: response.text is not a function&lt;/code&gt; 。这是因为从 &lt;code&gt;node-fetch&lt;/code&gt; 导入的 &lt;code&gt;Response&lt;/code&gt; 类已经被 &lt;code&gt;jest.mock&lt;/code&gt; （由于测试文件顶部的jest.mock调用），因此它不再具有应有的表现。</target>
        </trans-unit>
        <trans-unit id="19efe36034f27b89bcd3c3adeaf018197cd0f9cb" translate="yes" xml:space="preserve">
          <source>However, there are some &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats&quot;&gt;caveats&lt;/a&gt; to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use &lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest&lt;/a&gt; instead, or just run the TypeScript compiler &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;tsc&lt;/a&gt; separately (or as part of your build process).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a65fb527f26996f958a4c7a7636697c68a57ae" translate="yes" xml:space="preserve">
          <source>However, there are some &lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-typescript.html#caveats&quot;&gt;caveats&lt;/a&gt; to using TypeScript with Babel. Because TypeScript support in Babel is transpilation, Jest will not type-check your tests as they are run. If you want that, you can use &lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest&lt;/a&gt;.</source>
          <target state="translated">但是，将TypeScript与Babel结合使用时有一些&lt;a href=&quot;https://babeljs.io/docs/en/next/babel-plugin-transform-typescript.html#caveats&quot;&gt;注意事项&lt;/a&gt;。由于Babel中对TypeScript的支持是编译，因此Jest在运行测试时不会进行类型检查。如果需要，可以使用&lt;a href=&quot;https://github.com/kulshekhar/ts-jest&quot;&gt;ts-jest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf42de47519a8be85813abc9dbcf79a2336fd084" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the end of the describe block.</source>
          <target state="translated">如果 &lt;code&gt;afterAll&lt;/code&gt; 在 &lt;code&gt;describe&lt;/code&gt; 块内，则它将在describe块的末尾运行。</target>
        </trans-unit>
        <trans-unit id="36d6e89fb8810e2839bb626d3834bcbc4b498e76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;afterEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it only runs after the tests that are inside this describe block.</source>
          <target state="translated">如果 &lt;code&gt;afterEach&lt;/code&gt; 在 &lt;code&gt;describe&lt;/code&gt; 块内，则仅在此describe块内的测试之后运行。</target>
        </trans-unit>
        <trans-unit id="06fd5213f105f4db8f2c74d9197183295af8cfef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeAll&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs at the beginning of the describe block.</source>
          <target state="translated">如果 &lt;code&gt;beforeAll&lt;/code&gt; 在 &lt;code&gt;describe&lt;/code&gt; 块内，则它将在describe块的开头运行。</target>
        </trans-unit>
        <trans-unit id="d48344c733bdd18ab3274d53de4f2dd945448596" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;beforeEach&lt;/code&gt; is inside a &lt;code&gt;describe&lt;/code&gt; block, it runs for each test in the describe block.</source>
          <target state="translated">如果 &lt;code&gt;beforeEach&lt;/code&gt; 在 &lt;code&gt;describe&lt;/code&gt; 块中，则它将为describe块中的每个测试运行。</target>
        </trans-unit>
        <trans-unit id="32b76dca32685624a3199a0eddd88c0e90043e44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done()&lt;/code&gt; is never called, the test will fail (with timeout error), which is what you want to happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c26c494506944de906e943951a2399f7620cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done()&lt;/code&gt; is never called, the test will fail, which is what you want to happen.</source>
          <target state="translated">如果从不调用 &lt;code&gt;done()&lt;/code&gt; ，则测试将失败，这就是您想要发生的情况。</target>
        </trans-unit>
        <trans-unit id="5d1981223ccef65cb683fc43fc578f449a3eee3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;moduleNameMapper&lt;/code&gt; cannot fulfill your requirements, you can use Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that &lt;code&gt;require('logo.jpg');&lt;/code&gt; returns &lt;code&gt;'logo'&lt;/code&gt;) can be written as:</source>
          <target state="translated">如果 &lt;code&gt;moduleNameMapper&lt;/code&gt; 无法满足您的要求，则可以使用Jest的&lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; config选项指定如何转换资产。例如，返回文件基本名的转换器（例如 &lt;code&gt;require('logo.jpg');&lt;/code&gt; 返回 &lt;code&gt;'logo'&lt;/code&gt; ）可以写成：</target>
        </trans-unit>
        <trans-unit id="5df09d1e5934f36cd1398174cf6c7629249a09bf" translate="yes" xml:space="preserve">
          <source>If a promise doesn't resolve at all, this error might be thrown:</source>
          <target state="translated">如果一个承诺根本没有解决,可能会抛出这个错误。</target>
        </trans-unit>
        <trans-unit id="e31564de21c2565396696cb413016ff78b9a87fd" translate="yes" xml:space="preserve">
          <source>If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that &lt;code&gt;test&lt;/code&gt; command to a &lt;code&gt;test.only&lt;/code&gt;:</source>
          <target state="translated">如果测试失败，则要检查的第一件事就是当它是唯一运行的测试时，测试是否失败。要仅使用Jest运行一个测试，请将该 &lt;code&gt;test&lt;/code&gt; 命令临时更改为 &lt;code&gt;test.only&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1368241bb9b6a677c253777f28e276302847afe6" translate="yes" xml:space="preserve">
          <source>If custom reporters are specified, the default Jest reporters will be overridden. To keep default reporters, &lt;code&gt;default&lt;/code&gt; can be passed as a module name.</source>
          <target state="translated">如果指定了自定义报告程序，则默认的Jest报告程序将被覆盖。为了保留默认的报告程序，可以将 &lt;code&gt;default&lt;/code&gt; 作为模块名称传递。</target>
        </trans-unit>
        <trans-unit id="d35c3c8f0f049c2d367440e4fa528eaf56ee5ab8" translate="yes" xml:space="preserve">
          <source>If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the &lt;code&gt;expect&lt;/code&gt; function. For example, use &lt;code&gt;equals&lt;/code&gt; method of &lt;code&gt;Buffer&lt;/code&gt; class to assert whether or not buffers contain the same content:</source>
          <target state="translated">如果属性之间的差异不能帮助您理解测试失败的原因，尤其是在报告较大的情况下，则可以将比较结果移入 &lt;code&gt;expect&lt;/code&gt; 函数。例如，使用 &lt;code&gt;Buffer&lt;/code&gt; 类的 &lt;code&gt;equals&lt;/code&gt; 方法声明缓冲区是否包含相同的内容：</target>
        </trans-unit>
        <trans-unit id="1bc2dfefa6293d5ed410a4a6d3781efdc91701ab" translate="yes" xml:space="preserve">
          <source>If globs or paths are specified alongside &lt;code&gt;global&lt;/code&gt;, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8531076ffab17b1e6a3078dd99ca2b637f2d89a8" translate="yes" xml:space="preserve">
          <source>If globs or paths are specified alongside &lt;code&gt;global&lt;/code&gt;, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, error is returned.</source>
          <target state="translated">如果在 &lt;code&gt;global&lt;/code&gt; 旁边指定了glob或路径，则将从总体coverage中减去匹配路径的coverage数据，并且将独立应用阈值。全局阈值将应用于与该全局匹配的所有文件。如果找不到由path指定的文件，则返回错误。</target>
        </trans-unit>
        <trans-unit id="72a21f6979cdac3c1b9ad4e08a0c6637f2d4dfa2" translate="yes" xml:space="preserve">
          <source>If some code uses a method which JSDOM (the DOM implementation used by Jest) hasn't implemented yet, testing it is not easily possible. This is e.g. the case with &lt;code&gt;window.matchMedia()&lt;/code&gt;. Jest returns &lt;code&gt;TypeError: window.matchMedia is not a function&lt;/code&gt; and doesn't properly execute the test.</source>
          <target state="translated">如果某些代码使用的方法尚未实现JSDOM（Jest使用的DOM实现），则测试起来并不容易。例如 &lt;code&gt;window.matchMedia()&lt;/code&gt; 就是这种情况。开玩笑返回 &lt;code&gt;TypeError: window.matchMedia is not a function&lt;/code&gt; ，并且不能正确执行测试。</target>
        </trans-unit>
        <trans-unit id="3978c298eae11b6cf4d588fb5f9571c0dff90f37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expect&lt;/code&gt; statement fails, it throws an error and &lt;code&gt;done()&lt;/code&gt; is not called. If we want to see in the test log why it failed, we have to wrap &lt;code&gt;expect&lt;/code&gt; in a &lt;code&gt;try&lt;/code&gt; block and pass the error in the &lt;code&gt;catch&lt;/code&gt; block to &lt;code&gt;done&lt;/code&gt;. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by &lt;code&gt;expect(data)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e563bcf7cde030a5bb0b4b33cd3681fd2fe53263" translate="yes" xml:space="preserve">
          <source>If the class is &lt;strong&gt;not&lt;/strong&gt; the default export from the module then you need to return an object with the key that is the same as the class export name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17517ca3e186444904834c38de35490f5610cc1b" translate="yes" xml:space="preserve">
          <source>If the module you are mocking is a Node module (e.g.: &lt;code&gt;lodash&lt;/code&gt;), the mock should be placed in the &lt;code&gt;__mocks__&lt;/code&gt; directory adjacent to &lt;code&gt;node_modules&lt;/code&gt; (unless you configured &lt;a href=&quot;configuration#roots-arraystring&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; to point to a folder other than the project root) and will be &lt;strong&gt;automatically&lt;/strong&gt; mocked. There's no need to explicitly call &lt;code&gt;jest.mock('module_name')&lt;/code&gt;.</source>
          <target state="translated">如果正在嘲笑模块是节点模块（例如： &lt;code&gt;lodash&lt;/code&gt; ），模拟应放置在 &lt;code&gt;__mocks__&lt;/code&gt; 相邻目录 &lt;code&gt;node_modules&lt;/code&gt; （除非你配置&lt;a href=&quot;configuration#roots-arraystring&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt;到指向比项目根以外的文件夹），将被&lt;strong&gt;自动&lt;/strong&gt;嘲笑。无需显式调用 &lt;code&gt;jest.mock('module_name')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="829141299a9251eaf1ce7f20d372e903be5b7bd4" translate="yes" xml:space="preserve">
          <source>If the user provided a custom configuration, it will be passed as an argument to the plugin constructor.</source>
          <target state="translated">如果用户提供了自定义配置,它将作为参数传递给插件构造函数。</target>
        </trans-unit>
        <trans-unit id="537280f51371a1cf4cb4adc52cdfd9e2eb4af343" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;modern&lt;/code&gt;, &lt;a href=&quot;https://github.com/sinonjs/fake-timers&quot;&gt;&lt;code&gt;@sinonjs/fake-timers&lt;/code&gt;&lt;/a&gt; will be used as implementation instead of Jest's own legacy implementation. This will be the default fake implementation in Jest 27.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95717cb6503226f8b4c4d21226d313e3fbd59885" translate="yes" xml:space="preserve">
          <source>If you add a snapshot serializer in individual test files instead of adding it to &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0c525e5e5ddd2de8c8d823c3e142628ec07ed1" translate="yes" xml:space="preserve">
          <source>If you add a snapshot serializer in individual test files instead of to adding it to &lt;code&gt;snapshotSerializers&lt;/code&gt; configuration:</source>
          <target state="translated">如果在单个测试文件中添加快照序列化程序，而不是将其添加到 &lt;code&gt;snapshotSerializers&lt;/code&gt; 配置中：</target>
        </trans-unit>
        <trans-unit id="30fd956763850c31b9ce0b4521be9bc8f3c1c8bb" translate="yes" xml:space="preserve">
          <source>If you are interested in learning more about how Jest works, what the architecture behind the framework is, and how Jest is split up into individual reusable packages, check out this video:</source>
          <target state="translated">如果你有兴趣了解更多关于Jest如何工作,框架背后的架构是什么,以及Jest是如何被分割成各个可重用的包,请查看这个视频。</target>
        </trans-unit>
        <trans-unit id="ff5831fd455a073194363262317001c2ea5e555f" translate="yes" xml:space="preserve">
          <source>If you are new to React, we recommend using &lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;. It is ready to use and &lt;a href=&quot;https://create-react-app.dev/docs/running-tests/#docsNav&quot;&gt;ships with Jest&lt;/a&gt;! You will only need to add &lt;code&gt;react-test-renderer&lt;/code&gt; for rendering snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18026771171516f84ca810200b4fd3d6a03c8bac" translate="yes" xml:space="preserve">
          <source>If you are new to React, we recommend using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;. It is ready to use and &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests#docsNav&quot;&gt;ships with Jest&lt;/a&gt;! You will only need to add &lt;code&gt;react-test-renderer&lt;/code&gt; for rendering snapshots.</source>
          <target state="translated">如果您不熟悉React，建议您使用&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;。它可以随时使用，并&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests#docsNav&quot;&gt;随Jest一起提供&lt;/a&gt;！您只需要添加 &lt;code&gt;react-test-renderer&lt;/code&gt; 来渲染快照。</target>
        </trans-unit>
        <trans-unit id="2a18016808e001b4a11dfaa241f7321f12becaa6" translate="yes" xml:space="preserve">
          <source>If you are seeing coverage output such as...</source>
          <target state="translated">如果你看到的覆盖率输出,如......</target>
        </trans-unit>
        <trans-unit id="6d58a67f6e37bb20fba801c5e4f97af0d9335927" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://create-react-app.dev&quot;&gt;Create React App&lt;/a&gt; then the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript/&quot;&gt;TypeScript template&lt;/a&gt; has everything you need to start writing tests in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3538d9b6ba0bfe52daac18493de01cba0271f06a" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;AVA&lt;/a&gt;, &lt;a href=&quot;https://github.com/chaijs/chai&quot;&gt;Chai&lt;/a&gt;, &lt;a href=&quot;https://github.com/Automattic/expect.js&quot;&gt;Expect.js (by Automattic)&lt;/a&gt;, &lt;a href=&quot;https://github.com/jasmine/jasmine&quot;&gt;Jasmine&lt;/a&gt;, &lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;Mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/thlorenz/proxyquire&quot;&gt;proxyquire&lt;/a&gt;, &lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;Should.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/substack/tape&quot;&gt;Tape&lt;/a&gt; you can use the third-party &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;jest-codemods&lt;/a&gt; to do most of the dirty migration work. It runs a code transformation on your codebase using &lt;a href=&quot;https://github.com/facebook/jscodeshift&quot;&gt;jscodeshift&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;AVA&lt;/a&gt;，&lt;a href=&quot;https://github.com/chaijs/chai&quot;&gt;Chai&lt;/a&gt;，&lt;a href=&quot;https://github.com/Automattic/expect.js&quot;&gt;Expect.js（由Automattic提供）&lt;/a&gt;，&lt;a href=&quot;https://github.com/jasmine/jasmine&quot;&gt;Jasmine&lt;/a&gt;，&lt;a href=&quot;https://github.com/mochajs/mocha&quot;&gt;Mocha&lt;/a&gt;，&lt;a href=&quot;https://github.com/thlorenz/proxyquire&quot;&gt;proxyquire&lt;/a&gt;，&lt;a href=&quot;https://github.com/shouldjs/should.js&quot;&gt;Should.js&lt;/a&gt;或&lt;a href=&quot;https://github.com/substack/tape&quot;&gt;Tape&lt;/a&gt;，则可以使用第三方&lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;jest-codemods&lt;/a&gt;来完成大多数脏迁移工作。它使用&lt;a href=&quot;https://github.com/facebook/jscodeshift&quot;&gt;jscodeshift&lt;/a&gt;在您的代码库上运行代码转换。</target>
        </trans-unit>
        <trans-unit id="16afeeb67bb4f44c59d6fb688fc49403f7d400f9" translate="yes" xml:space="preserve">
          <source>If you are using AVA, Expect.js (by Automattic), Jasmine, Mocha, proxyquire, Should.js or Tape you can automatically migrate with Jest Codemods (see below).</source>
          <target state="translated">如果您正在使用AVA、Expect.js(由Automattic提供)、Jasmine、Mocha、proxyquire、Should.js或Tape,您可以使用Jest Codemods自动迁移(见下文)。</target>
        </trans-unit>
        <trans-unit id="d950d3cb77c0e4d69b966651442d248b368ac31b" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, in the Jest run/debug configuration specify the path to the &lt;code&gt;react-scripts&lt;/code&gt; package in the Jest package field and add &lt;code&gt;--env=jsdom&lt;/code&gt; to the Jest options field.</source>
          <target state="translated">如果您使用Facebook的&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt; &lt;code&gt;create-react-app&lt;/code&gt; &lt;/a&gt;，则在Jest运行/调试配置中，在Jest包字段中指定 &lt;code&gt;react-scripts&lt;/code&gt; 包的路径，并将 &lt;code&gt;--env=jsdom&lt;/code&gt; 添加到Jest选项字段中。</target>
        </trans-unit>
        <trans-unit id="04856c5821d9738bc23d4d6c7e49ea0d12a4e919" translate="yes" xml:space="preserve">
          <source>If you are using Facebook's &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;&lt;code&gt;create-react-app&lt;/code&gt;&lt;/a&gt;, you can debug your Jest tests with the following configuration:</source>
          <target state="translated">如果使用的是Facebook的&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt; &lt;code&gt;create-react-app&lt;/code&gt; &lt;/a&gt;，则可以使用以下配置调试Jest测试：</target>
        </trans-unit>
        <trans-unit id="616d051e539968c48db9eb4e4947c7fe6ae3168c" translate="yes" xml:space="preserve">
          <source>If you are using Jasmine, or a Jasmine like API (for example &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt;), Jest should be mostly compatible, which makes it less complicated to migrate to.</source>
          <target state="translated">如果您使用的是Jasmine或类似Jasmine的API（例如&lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt;），那么Jest应该是大多数兼容的，这使得迁移到它变得不那么复杂。</target>
        </trans-unit>
        <trans-unit id="6a321ef2867f26ae4a6883b3f6fd1258c705b7b4" translate="yes" xml:space="preserve">
          <source>If you define an ES6 class using the same filename as the mocked class in the &lt;code&gt;__mocks__&lt;/code&gt; folder, it will serve as the mock. This class will be used in place of the real class. This allows you to inject a test implementation for the class, but does not provide a way to spy on calls.</source>
          <target state="translated">如果您使用与 &lt;code&gt;__mocks__&lt;/code&gt; 文件夹中的模拟类相同的文件名定义ES6类，则它将用作模拟。该类将代替实际的类。这使您可以为该类注入测试实现，但不能提供监视调用的方法。</target>
        </trans-unit>
        <trans-unit id="bed89a7be5b28b2da511d62933b8c9202a0453c7" translate="yes" xml:space="preserve">
          <source>If you don't need to replace the implementation of the class, this is the easiest option to set up. For example:</source>
          <target state="translated">如果你不需要替换类的实现,这是最容易设置的选项。比如说</target>
        </trans-unit>
        <trans-unit id="785c7b2fc6591165ae39c3fd7d429eea3e2c5ec8" translate="yes" xml:space="preserve">
          <source>If you end up mocking the same modules over and over it is recommended to define these mocks in a separate file and add it to the list of &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">如果最终要 &lt;code&gt;setupFiles&lt;/code&gt; 相同的模块，建议在单独的文件中定义这些模拟并将其添加到setupFiles列表中。</target>
        </trans-unit>
        <trans-unit id="b5a9582bd8b87124ac313d453b396a39ddd21d21" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise a fulfilled promise would not fail the test.</source>
          <target state="translated">如果您希望某个承诺被拒绝，请使用 &lt;code&gt;.catch&lt;/code&gt; 方法。确保添加 &lt;code&gt;expect.assertions&lt;/code&gt; 以验证是否调用了一定数量的断言。否则，兑现承诺就不会使测试失败。</target>
        </trans-unit>
        <trans-unit id="d508e058fa7773fc13858ed4af2eb2bbf552b483" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected use the &lt;code&gt;.rejects&lt;/code&gt; matcher. It works analogically to the &lt;code&gt;.resolves&lt;/code&gt; matcher. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">如果您希望某个承诺被拒绝，请使用 &lt;code&gt;.rejects&lt;/code&gt; 匹配器。它与 &lt;code&gt;.resolves&lt;/code&gt; 匹配器类似。如果诺言得以兑现，则测试将自动失败。</target>
        </trans-unit>
        <trans-unit id="16ce82d40db5254192f2fb9365ee455181a6f2fd" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected, use the &lt;code&gt;.catch&lt;/code&gt; method. Make sure to add &lt;code&gt;expect.assertions&lt;/code&gt; to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a57be96088023cac979ca6091f87f827e5b39ac" translate="yes" xml:space="preserve">
          <source>If you expect a promise to be rejected, use the &lt;code&gt;.rejects&lt;/code&gt; matcher. It works analogically to the &lt;code&gt;.resolves&lt;/code&gt; matcher. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9919159eb0a5f34daf61334b02158349c4deb0ab" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;prettier&lt;/code&gt; installed in a location where Jest can't find it, you can tell Jest how to find it using the &lt;a href=&quot;configuration#prettierpath-string&quot;&gt;&lt;code&gt;&quot;prettierPath&quot;&lt;/code&gt;&lt;/a&gt; configuration property.</source>
          <target state="translated">如果您在Jest找不到的地方安装了 &lt;code&gt;prettier&lt;/code&gt; 东西，则可以使用&lt;a href=&quot;configuration#prettierpath-string&quot;&gt; &lt;code&gt;&quot;prettierPath&quot;&lt;/code&gt; &lt;/a&gt;配置属性告诉Jest如何找到它。</target>
        </trans-unit>
        <trans-unit id="5de2f8ea3278a9069dce525e3076d8f4531a1efb" translate="yes" xml:space="preserve">
          <source>If you have JavaScript files that are transformed by Babel, you can &lt;a href=&quot;getting-started#using-babel&quot;&gt;enable support for Babel&lt;/a&gt; by installing the &lt;code&gt;babel-jest&lt;/code&gt; plugin. Non-Babel JavaScript transformations can be handled with Jest's &lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/a&gt; config option.</source>
          <target state="translated">如果您有由Babel转换的JavaScript文件，则可以通过安装 &lt;code&gt;babel-jest&lt;/code&gt; 插件来&lt;a href=&quot;getting-started#using-babel&quot;&gt;启用对Babel&lt;/a&gt;的支持。可以使用Jest的&lt;a href=&quot;configuration#transform-objectstring-pathtotransformer--pathtotransformer-object&quot;&gt; &lt;code&gt;transform&lt;/code&gt; &lt;/a&gt; config选项处理非Babel JavaScript转换。</target>
        </trans-unit>
        <trans-unit id="7136dd51cf9e180f2a48ca203c9c72141190f47b" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenLastCalledWith&lt;/code&gt; to test what arguments it was last called with. For example, let's say you have a &lt;code&gt;applyToAllFlavors(f)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the last flavor it operates on is &lt;code&gt;'mango'&lt;/code&gt;. You can write:</source>
          <target state="translated">如果您有模拟功能，则可以使用 &lt;code&gt;.toHaveBeenLastCalledWith&lt;/code&gt; 来测试最后一次调用的参数。例如，假设您有一个 &lt;code&gt;applyToAllFlavors(f)&lt;/code&gt; 函数，该函数将 &lt;code&gt;f&lt;/code&gt; 应用于多种风味，并且您想确保在调用它时，其作用的最后一个风味是 &lt;code&gt;'mango'&lt;/code&gt; 。你可以写：</target>
        </trans-unit>
        <trans-unit id="0977c600c362140ee0f11a85d4e0e7f13e18104f" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveBeenNthCalledWith&lt;/code&gt; to test what arguments it was nth called with. For example, let's say you have a &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; function that applies &lt;code&gt;f&lt;/code&gt; to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is &lt;code&gt;'lemon'&lt;/code&gt; and the second one is &lt;code&gt;'octopus'&lt;/code&gt;. You can write:</source>
          <target state="translated">如果您有模拟函数，则可以使用 &lt;code&gt;.toHaveBeenNthCalledWith&lt;/code&gt; 来测试第n次调用了哪些参数。例如，假设您有一个 &lt;code&gt;drinkEach(drink, Array&amp;lt;flavor&amp;gt;)&lt;/code&gt; 函数将 &lt;code&gt;f&lt;/code&gt; 应用于多种口味，并且您想确保在调用它时，其作用的第一个口味是 &lt;code&gt;'lemon'&lt;/code&gt; ，而第二个是 &lt;code&gt;'octopus'&lt;/code&gt; 。你可以写：</target>
        </trans-unit>
        <trans-unit id="993b27fa75c6ccc43f546084c9a5ed3da7f9f9a6" translate="yes" xml:space="preserve">
          <source>If you have a mock function, you can use &lt;code&gt;.toHaveReturned&lt;/code&gt; to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock &lt;code&gt;drink&lt;/code&gt; that returns &lt;code&gt;true&lt;/code&gt;. You can write:</source>
          <target state="translated">如果您有模拟函数，则可以使用 &lt;code&gt;.toHaveReturned&lt;/code&gt; 来测试模拟函数至少一次成功返回（即，未引发错误）。例如，假设您有一个返回 &lt;code&gt;true&lt;/code&gt; 的模拟 &lt;code&gt;drink&lt;/code&gt; 。你可以写：</target>
        </trans-unit>
        <trans-unit id="420b4fbe707501e81837408c0339f7b83dccab03" translate="yes" xml:space="preserve">
          <source>If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with &lt;code&gt;beforeEach&lt;/code&gt;. If you're not sure whether some shared state is being modified, you can also try a &lt;code&gt;beforeEach&lt;/code&gt; that logs data.</source>
          <target state="translated">如果您的测试在作为大型套件的一部分运行时通常会失败，而在单独运行时不会失败，那么最好的选择是其他测试中的某项干扰了该测试。您通常可以通过使用 &lt;code&gt;beforeEach&lt;/code&gt; 清除一些共享状态来解决此问题。如果您不确定是否正在修改某些共享状态，也可以尝试使用 &lt;code&gt;beforeEach&lt;/code&gt; 记录数据。</target>
        </trans-unit>
        <trans-unit id="74bc00736b265df97dcccbb952c16a808f51eb48" translate="yes" xml:space="preserve">
          <source>If you have an existing application you'll need to install a few packages to make everything work well together. We are using the &lt;code&gt;babel-jest&lt;/code&gt; package and the &lt;code&gt;react&lt;/code&gt; babel preset to transform our code inside of the test environment. Also see &lt;a href=&quot;getting-started#using-babel&quot;&gt;using babel&lt;/a&gt;.</source>
          <target state="translated">如果您有现有的应用程序，则需要安装一些软件包才能使所有组件正常运行。我们使用 &lt;code&gt;babel-jest&lt;/code&gt; 包和 &lt;code&gt;react&lt;/code&gt; babel预设在测试环境中转换我们的代码。另请参阅&lt;a href=&quot;getting-started#using-babel&quot;&gt;使用babel&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79990aa85d408f8fcea8c54e5341cb382a83ed88" translate="yes" xml:space="preserve">
          <source>If you have some work you need to do repeatedly for many tests, you can use &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt;.</source>
          <target state="translated">如果您有一些工作需要对许多测试重复进行，则可以使用 &lt;code&gt;beforeEach&lt;/code&gt; 和 &lt;code&gt;afterEach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6133b9892905af7a44bdddcaa575f4c5a48db428" translate="yes" xml:space="preserve">
          <source>If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (&lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;send a PR here&lt;/a&gt;) or if you would like to transfer your project to the jest-community org reach out to one of the owners of the org.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756f402753805d9101cb2dc7198988431ec9ee20" translate="yes" xml:space="preserve">
          <source>If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (&lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;send a PR here&lt;/a&gt;) or if you would like to transfer your project to the jest-community org reachout to one of the owners of the org.</source>
          <target state="translated">如果您有什么值得分享的东西，请随时与我们联系！如果您想将您的项目转移到jest-community组织，则希望将您的项目分享到该组织的所有者（&lt;a href=&quot;https://github.com/jest-community/awesome-jest/pulls&quot;&gt;请在此处发送PR&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d7ae11f48e4c50b3df992e0eb7601afc5a6361a" translate="yes" xml:space="preserve">
          <source>If you know how to test something, &lt;code&gt;.not&lt;/code&gt; lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</source>
          <target state="translated">如果您知道如何测试某些东西， &lt;code&gt;.not&lt;/code&gt; 会让您测试其相反的东西。例如，此代码测试最佳的La Croix口味不是椰子：</target>
        </trans-unit>
        <trans-unit id="55dbb4d3f311b3d4eb68e5741b0d897b72ccb8b5" translate="yes" xml:space="preserve">
          <source>If you like &lt;a href=&quot;http://chaijs.com/&quot;&gt;chai&lt;/a&gt;, you can upgrade to Jest and continue using chai. However, we recommend trying out Jest's assertions and their failure messages. Jest Codemods can migrate from chai (see below).</source>
          <target state="translated">如果您喜欢&lt;a href=&quot;http://chaijs.com/&quot;&gt;chai&lt;/a&gt;，可以升级到Jest并继续使用chai。但是，我们建议尝试Jest的断言及其失败消息。Jest Codemods可以从chai迁移（请参阅下文）。</target>
        </trans-unit>
        <trans-unit id="64089c71545ac9398fafdb10bbce2181a2f6a753" translate="yes" xml:space="preserve">
          <source>If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using babel:</source>
          <target state="translated">如果你需要更高级的功能,你也可以建立自己的变换器。这里是一个使用babel-jest的例子,而不是使用babel。</target>
        </trans-unit>
        <trans-unit id="cf809d0ae36854acd4c893ed1b90996e3a3041cc" translate="yes" xml:space="preserve">
          <source>If you need to restrict your test-runner to only run in serial rather than being executed in parallel your class should have the property &lt;code&gt;isSerial&lt;/code&gt; to be set as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cd566d23f6580c1572508d5f198d62212efb88" translate="yes" xml:space="preserve">
          <source>If you need to restrict your test-runner to only run in serial rather then being executed in parallel your class should have the property &lt;code&gt;isSerial&lt;/code&gt; to be set as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果需要将测试运行程序限制为仅以串行方式运行，而不是并行执行，则您的类应将 &lt;code&gt;isSerial&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="352ca1b438b9b40e3f1f12e8c905d0575ee8ebf8" translate="yes" xml:space="preserve">
          <source>If you only need to run some setup code once, before any tests run, use &lt;code&gt;beforeAll&lt;/code&gt; instead.</source>
          <target state="translated">如果只需要运行一次安装代码，则在运行任何测试之前，请使用 &lt;code&gt;beforeAll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94317cb60ddca24417e48981f19b984506a8617" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;'modern'&lt;/code&gt; as an argument, &lt;a href=&quot;https://github.com/sinonjs/fake-timers&quot;&gt;&lt;code&gt;@sinonjs/fake-timers&lt;/code&gt;&lt;/a&gt; will be used as implementation instead of Jest's own fake timers. This also mocks additional timers like &lt;code&gt;Date&lt;/code&gt;. &lt;code&gt;'modern'&lt;/code&gt; will be the default behavior in Jest 27.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4cf1bd9be869094293df92f2ed1d79a4685bb2" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;npm test&lt;/code&gt;, you can still use the command line arguments by inserting a &lt;code&gt;--&lt;/code&gt; between &lt;code&gt;npm test&lt;/code&gt; and the Jest arguments.</source>
          <target state="translated">如果通过 &lt;code&gt;npm test&lt;/code&gt; 运行Jest ，您仍然可以通过在 &lt;code&gt;npm test&lt;/code&gt; 和Jest参数之间插入 &lt;code&gt;--&lt;/code&gt; 来使用命令行参数。</target>
        </trans-unit>
        <trans-unit id="786fc89b89e2b8432cf8d374c70aa7b7814df7b6" translate="yes" xml:space="preserve">
          <source>If you run Jest via &lt;code&gt;yarn test&lt;/code&gt;, you can pass the command line arguments directly as Jest arguments.</source>
          <target state="translated">如果通过 &lt;code&gt;yarn test&lt;/code&gt; 运行Jest ，则可以直接将命令行参数作为Jest参数传递。</target>
        </trans-unit>
        <trans-unit id="3e9b34c839f0bb4065cf0cbfa5620da9d41b2be8" translate="yes" xml:space="preserve">
          <source>If you use dynamic imports (&lt;code&gt;import('some-file.js').then(module =&amp;gt; ...)&lt;/code&gt;), you need to enable the &lt;code&gt;dynamic-import-node&lt;/code&gt; plugin.</source>
          <target state="translated">如果您使用动态导入（ &lt;code&gt;import('some-file.js').then(module =&amp;gt; ...)&lt;/code&gt; ），则需要启用 &lt;code&gt;dynamic-import-node&lt;/code&gt; 插件。</target>
        </trans-unit>
        <trans-unit id="2e9000a1baf94a23c5eda0e8f5bba72955e96ff9" translate="yes" xml:space="preserve">
          <source>If you want a path to be &lt;a href=&quot;#rootdir-string&quot;&gt;relative to the root directory of your project&lt;/a&gt;, please include &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; inside a path's string, like &lt;code&gt;&quot;&amp;lt;rootDir&amp;gt;/a-configs-folder&quot;&lt;/code&gt;.</source>
          <target state="translated">如果要使路径&lt;a href=&quot;#rootdir-string&quot;&gt;相对于项目的根目录&lt;/a&gt;，请在路径的字符串中包括 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; ，例如 &lt;code&gt;&quot;&amp;lt;rootDir&amp;gt;/a-configs-folder&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="554f70a642fd6f52b957f8ae2bf6f9d1be578ea3" translate="yes" xml:space="preserve">
          <source>If you want to inspect the cache, use &lt;code&gt;--showConfig&lt;/code&gt; and look at the &lt;code&gt;cacheDirectory&lt;/code&gt; value. If you need to clear the cache, use &lt;code&gt;--clearCache&lt;/code&gt;.</source>
          <target state="translated">如果要检查缓存，请使用 &lt;code&gt;--showConfig&lt;/code&gt; 并查看 &lt;code&gt;cacheDirectory&lt;/code&gt; 值。如果需要清除缓存，请使用 &lt;code&gt;--clearCache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fda82da214d4a1bfae2a873dff3fffc4c9acd8c" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup after every test instead of after all tests, use &lt;code&gt;afterEach&lt;/code&gt; instead.</source>
          <target state="translated">如果要在每个测试之后而不是在所有测试之后运行一些清理，请改用 &lt;code&gt;afterEach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e29fce9e0a98c7b27c220dc5f9e52e9dea70cc71" translate="yes" xml:space="preserve">
          <source>If you want to run some cleanup just once, after all of the tests run, use &lt;code&gt;afterAll&lt;/code&gt; instead.</source>
          <target state="translated">如果您只想运行一次清理，则在所有测试运行之后，请使用 &lt;code&gt;afterAll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="985cfb18842dcab5a2061f5fd939e231c11a1190" translate="yes" xml:space="preserve">
          <source>If you want to run something before every test instead of before any test runs, use &lt;code&gt;beforeEach&lt;/code&gt; instead.</source>
          <target state="translated">如果要在每次测试之前而不是在任何测试之前运行 &lt;code&gt;beforeEach&lt;/code&gt; ，请改用beforeEach。</target>
        </trans-unit>
        <trans-unit id="c7c7d4d719f894e809c49dafe7d06515e3345af1" translate="yes" xml:space="preserve">
          <source>If you want to test that a particular function throws an error when it's called, use &lt;code&gt;toThrow&lt;/code&gt;.</source>
          <target state="translated">如果要测试特定函数在调用时引发错误，请使用 &lt;code&gt;toThrow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae46be8c321ca5c25b3e97af2f881175a4ff5492" translate="yes" xml:space="preserve">
          <source>If you want to test whether a particular function throws an error when it's called, use &lt;code&gt;toThrow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa479dc2989b39264cd671e2e1b01fc3bc865c73" translate="yes" xml:space="preserve">
          <source>If you'd like to assert, and manipulate your rendered components you can use &lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt;, &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, or React's &lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;TestUtils&lt;/a&gt;. The following two examples use react-testing-library and Enzyme.</source>
          <target state="translated">如果您想断言并处理渲染的组件，则可以使用&lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt;，&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;或React的&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;TestUtils&lt;/a&gt;。以下两个示例使用了react-testing-library和Enzyme。</target>
        </trans-unit>
        <trans-unit id="00a7aa7ef1101cf18377dc8c7c8f6fbe0afd1763" translate="yes" xml:space="preserve">
          <source>If you'd like to assert, and manipulate your rendered components you can use &lt;a href=&quot;https://github.com/kentcdodds/react-testing-library&quot;&gt;react-testing-library&lt;/a&gt;, &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;, or React's &lt;a href=&quot;https://reactjs.org/docs/test-utils.html&quot;&gt;TestUtils&lt;/a&gt;. The following two examples use react-testing-library and Enzyme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5abb36c3cf78ade7ac7c3e61eaa1bf15a7a6cf" translate="yes" xml:space="preserve">
          <source>If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:</source>
          <target state="translated">如果您想建立一个支持babel的变压器,您也可以使用babel-jest来组成一个变压器,并传递您的自定义配置选项。</target>
        </trans-unit>
        <trans-unit id="0fe8837a1b877e57fa5d26c99f5f76765b57c8f1" translate="yes" xml:space="preserve">
          <source>If you'd like to learn more about running &lt;code&gt;jest&lt;/code&gt; through the command line, take a look at the &lt;a href=&quot;cli&quot;&gt;Jest CLI Options&lt;/a&gt; page.</source>
          <target state="translated">如果您想了解有关通过命令行运行 &lt;code&gt;jest&lt;/code&gt; 的更多信息，请查看&amp;ldquo; &lt;a href=&quot;cli&quot;&gt;Jest CLI选项&amp;rdquo;&lt;/a&gt;页面。</target>
        </trans-unit>
        <trans-unit id="8b70976c9786f6bb152f5a17847893b3ea57a99e" translate="yes" xml:space="preserve">
          <source>If you'd like to limit which snapshot test cases get re-generated, you can pass an additional &lt;code&gt;--testNamePattern&lt;/code&gt; flag to re-record snapshots only for those tests that match the pattern.</source>
          <target state="translated">如果您想限制重新生成哪些快照测试用例，则可以传递一个附加的 &lt;code&gt;--testNamePattern&lt;/code&gt; 标志，以便仅为那些与模式匹配的测试重新记录快照。</target>
        </trans-unit>
        <trans-unit id="493e22a5ff7ebb1b0bac76ca20348fbec098ff61" translate="yes" xml:space="preserve">
          <source>If you'd like to provide additional configuration for every test file, the &lt;a href=&quot;configuration#setupfiles-array&quot;&gt;&lt;code&gt;setupFiles&lt;/code&gt; configuration option&lt;/a&gt; can be used to specify setup scripts.</source>
          <target state="translated">如果您想为每个测试文件提供其他配置，可以使用&lt;a href=&quot;configuration#setupfiles-array&quot;&gt; &lt;code&gt;setupFiles&lt;/code&gt; 配置选项&lt;/a&gt;来指定安装脚本。</target>
        </trans-unit>
        <trans-unit id="904d7d5dbe5dfb9936b463c8afc5fd6ef73f873b" translate="yes" xml:space="preserve">
          <source>If you'd like to test timers, like &lt;code&gt;setTimeout&lt;/code&gt;, take a look at the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; documentation.</source>
          <target state="translated">如果您想测试计时器，例如 &lt;code&gt;setTimeout&lt;/code&gt; ，请查看&lt;a href=&quot;timer-mocks&quot;&gt;Timer模拟&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="41daa174187a45b7973b50bb5da3fd6d898d179a" translate="yes" xml:space="preserve">
          <source>If you'd like to try out Jest with an existing codebase, there are a number of ways to convert to Jest:</source>
          <target state="translated">如果你想用现有的代码库试用Jest,有很多方法可以转换到Jest。</target>
        </trans-unit>
        <trans-unit id="829c5ae35e9a8ea6d6ab4a39e712800c72de37bf" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES module imports&lt;/a&gt; then you'll normally be inclined to put your &lt;code&gt;import&lt;/code&gt; statements at the top of the test file. But often you need to instruct Jest to use a mock before modules use it. For this reason, Jest will automatically hoist &lt;code&gt;jest.mock&lt;/code&gt; calls to the top of the module (before any imports). To learn more about this and see it in action, see &lt;a href=&quot;https://github.com/kentcdodds/how-jest-mocking-works&quot;&gt;this repo&lt;/a&gt;.</source>
          <target state="translated">如果您正在使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES模块导入，&lt;/a&gt;则通常倾向于将 &lt;code&gt;import&lt;/code&gt; 语句放在测试文件的顶部。但是通常您需要指示Jest在模块使用模拟之前使用它。因此，Jest会自动将 &lt;code&gt;jest.mock&lt;/code&gt; 调用提升到模块的顶部（在导入之前）。要了解有关此内容的更多信息并进行实际操作，请参阅&lt;a href=&quot;https://github.com/kentcdodds/how-jest-mocking-works&quot;&gt;此仓库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d61bfdc856da28f2e5fd6d45fca8df20622b57a" translate="yes" xml:space="preserve">
          <source>If your code uses promises, there is a more straightforward way to handle asynchronous tests. Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">如果你的代码使用了承诺,有一个更直接的方法来处理异步测试。从你的测试中返回一个承诺,Jest将等待该承诺解析。如果承诺被拒绝,测试将自动失败。</target>
        </trans-unit>
        <trans-unit id="ccb7cf87b9a1da1c03f262e7f2f52beaa2385481" translate="yes" xml:space="preserve">
          <source>If your test is long running, you may want to consider to increase the timeout by calling &lt;code&gt;jest.setTimeout&lt;/code&gt;</source>
          <target state="translated">如果您的测试长期运行，则可能需要考虑通过调用 &lt;code&gt;jest.setTimeout&lt;/code&gt; 来增加超时时间</target>
        </trans-unit>
        <trans-unit id="83f3aae12099b7ddfe3f20a402b497229b2307ab" translate="yes" xml:space="preserve">
          <source>Import the mock and the mock method shared by all instances:</source>
          <target state="translated">导入所有实例共享的mock和mock方法。</target>
        </trans-unit>
        <trans-unit id="14b1c9735c1b7f4127af7d7ab27db5831ecb658c" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are six falsy values: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt;. Everything else is truthy.</source>
          <target state="translated">在JavaScript中，有六个伪造的值： &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;''&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 。其他一切都是真实的。</target>
        </trans-unit>
        <trans-unit id="8c4ae4f10df6814e92150ee1c7d3a629a5d7abd0" translate="yes" xml:space="preserve">
          <source>In depth: Understanding mock constructor functions</source>
          <target state="translated">深入了解。了解模拟构造函数</target>
        </trans-unit>
        <trans-unit id="4abc59ae50f9e935393cdb945f05ee449764bb87" translate="yes" xml:space="preserve">
          <source>In order to do this you can run tests in the same thread using &lt;a href=&quot;cli#--runinband&quot;&gt;&lt;code&gt;--runInBand&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为此，您可以使用&lt;a href=&quot;cli#--runinband&quot;&gt; &lt;code&gt;--runInBand&lt;/code&gt; &lt;/a&gt;在同一线程中运行测试：</target>
        </trans-unit>
        <trans-unit id="996bbd139f692ff1674caffb9c1a201da9541db8" translate="yes" xml:space="preserve">
          <source>In order to mock a constructor function, the module factory must return a constructor function. In other words, the module factory must be a function that returns a function - a higher-order function (HOF).</source>
          <target state="translated">为了模拟一个构造函数,模块工厂必须返回一个构造函数。换句话说,模块工厂必须是一个返回函数的函数--高阶函数(HOF)。</target>
        </trans-unit>
        <trans-unit id="644861976bcc490e61ef690742a524fc490ebdcc" translate="yes" xml:space="preserve">
          <source>In order to track calls to the constructor, replace the function returned by the HOF with a Jest mock function. Create it with &lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt;&lt;code&gt;jest.fn()&lt;/code&gt;&lt;/a&gt;, and then specify its implementation with &lt;code&gt;mockImplementation()&lt;/code&gt;.</source>
          <target state="translated">为了跟踪对构造函数的调用，请将HOF返回的函数替换为Jest模拟函数。使用&lt;a href=&quot;jest-object#jestfnimplementation&quot;&gt; &lt;code&gt;jest.fn()&lt;/code&gt; &lt;/a&gt;创建它，然后使用 &lt;code&gt;mockImplementation()&lt;/code&gt; 指定其实现。</target>
        </trans-unit>
        <trans-unit id="00fe50509a9a46b66c2c06f2fc7d147da1de4215" translate="yes" xml:space="preserve">
          <source>In other cases you may want to mock a native module that isn't a React component. The same technique can be applied. We recommend inspecting the native module's source code and logging the module when running a react native app on a real device and then modeling a manual mock after the real module.</source>
          <target state="translated">在其他情况下,你可能想模拟一个不是React组件的本地模块。同样的技术也可以应用。我们建议在真实设备上运行react原生应用时,检查原生模块的源代码并记录该模块,然后按照真实模块进行手动模拟。</target>
        </trans-unit>
        <trans-unit id="9102da2371047bd722d0b515b5551f478299aa99" translate="yes" xml:space="preserve">
          <source>In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides &lt;code&gt;beforeAll&lt;/code&gt; and &lt;code&gt;afterAll&lt;/code&gt; to handle this situation.</source>
          <target state="translated">在某些情况下，您只需要在文件开头执行一次设置即可。当设置是异步的时，这尤其麻烦，因此您不能内联。Jest提供了 &lt;code&gt;beforeAll&lt;/code&gt; 和 &lt;code&gt;afterAll&lt;/code&gt; 来处理这种情况。</target>
        </trans-unit>
        <trans-unit id="a0b6c9124da9d2f164e70d048eada927d7685f3e" translate="yes" xml:space="preserve">
          <source>In tests you sometimes need to distinguish between &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.</source>
          <target state="translated">在测试中，您有时需要区分 &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ，但是有时您不想将它们区别对待。Jest包含帮助程序，这些帮助程序使您可以清楚地了解所需内容。</target>
        </trans-unit>
        <trans-unit id="c4ab21507399cfd4363b457758de0b57f09386e5" translate="yes" xml:space="preserve">
          <source>In tests, you sometimes need to distinguish between &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9ae4862f96e5c36ede5f6a99e2b3637ee320d7" translate="yes" xml:space="preserve">
          <source>In that case, Jest will print this output:</source>
          <target state="translated">在这种情况下,Jest将打印这个输出。</target>
        </trans-unit>
        <trans-unit id="5e505a4fa07187d3e2baaecd5d93fb006995c7f2" translate="yes" xml:space="preserve">
          <source>In the WebStorm menu &lt;code&gt;Run&lt;/code&gt; select &lt;code&gt;Edit Configurations...&lt;/code&gt;. Then click &lt;code&gt;+&lt;/code&gt; and select &lt;code&gt;Jest&lt;/code&gt;. Optionally specify the Jest configuration file, additional options, and environment variables. Save the configuration, put the breakpoints in the code, then click the green debug icon to start debugging.</source>
          <target state="translated">在WebStorm菜单 &lt;code&gt;Run&lt;/code&gt; 选择 &lt;code&gt;Edit Configurations...&lt;/code&gt; 。然后单击 &lt;code&gt;+&lt;/code&gt; 并选择 &lt;code&gt;Jest&lt;/code&gt; 。（可选）指定Jest配置文件，其他选项和环境变量。保存配置，将断点放入代码中，然后单击绿色的调试图标以开始调试。</target>
        </trans-unit>
        <trans-unit id="7d0bc725310d5e7375a0939302ec84996aaee195" translate="yes" xml:space="preserve">
          <source>In the above implementation we expect the &lt;code&gt;request.js&lt;/code&gt; module to return a promise. We chain a call to &lt;code&gt;then&lt;/code&gt; to receive the user name.</source>
          <target state="translated">在上面的实现中，我们期望 &lt;code&gt;request.js&lt;/code&gt; 模块返回一个Promise。我们将呼叫链接到， &lt;code&gt;then&lt;/code&gt; 接收用户名。</target>
        </trans-unit>
        <trans-unit id="012333e9af1536e3df2516f188db853da3f9bb65" translate="yes" xml:space="preserve">
          <source>In the above implementation, we expect the &lt;code&gt;request.js&lt;/code&gt; module to return a promise. We chain a call to &lt;code&gt;then&lt;/code&gt; to receive the user name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570678fe1ed00ace674c0422a21ff689d587c77f" translate="yes" xml:space="preserve">
          <source>In these cases, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are effectively syntactic sugar for the same logic as the promises example uses.</source>
          <target state="translated">在这些情况下， &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 实际上是语法上的糖，与应诺示例使用的逻辑相同。</target>
        </trans-unit>
        <trans-unit id="3642d4f1c233bd882101f40614b17fbab7b0347a" translate="yes" xml:space="preserve">
          <source>In these rare scenarios you can use this API to manually fill the slot in the module system's mock-module registry.</source>
          <target state="translated">在这些罕见的情况下,你可以使用这个API来手动填充模块系统的模拟模块注册表中的插槽。</target>
        </trans-unit>
        <trans-unit id="7b652f7f89176ede040fc45adab5e36634e53950" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;toBe&lt;/code&gt; is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things.</source>
          <target state="translated">在这种情况下， &lt;code&gt;toBe&lt;/code&gt; 是匹配器函数。有很多不同的匹配器功能，下面记录，以帮助您测试不同的事物。</target>
        </trans-unit>
        <trans-unit id="182fda0d71d0e8cdad09e61c342e4da86b15010a" translate="yes" xml:space="preserve">
          <source>In this case, mocking &lt;code&gt;matchMedia&lt;/code&gt; in the test file should solve the issue:</source>
          <target state="translated">在这种情况下，在测试文件中 &lt;code&gt;matchMedia&lt;/code&gt; 应该可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="9d3f7577284c9c32a0e3ee6553d857ff29f2f2e7" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;expect(2 + 2)&lt;/code&gt; returns an &quot;expectation&quot; object. You typically won't do much with these expectation objects except call matchers on them. In this code, &lt;code&gt;.toBe(4)&lt;/code&gt; is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.</source>
          <target state="translated">在此代码中， &lt;code&gt;expect(2 + 2)&lt;/code&gt; 返回一个&amp;ldquo; expectation&amp;rdquo;对象。除了这些期望对象之外，您通常不会对这些期望对象做太多事情。在此代码中， &lt;code&gt;.toBe(4)&lt;/code&gt; 是匹配器。当Jest运行时，它将跟踪所有失败的匹配器，以便它可以为您打印出不错的错误消息。</target>
        </trans-unit>
        <trans-unit id="6bcf71eeb459fb4f43d233569cc094471a4a5833" translate="yes" xml:space="preserve">
          <source>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them.</source>
          <target state="translated">在你的测试文件中,Jest 将这些方法和对象都放到了全局环境中。你不需要要求或导入任何东西就可以使用它们。</target>
        </trans-unit>
        <trans-unit id="a578ea82daf305c1543b3602affe1f8cf54ca826" translate="yes" xml:space="preserve">
          <source>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do &lt;code&gt;import {describe, expect, test} from '@jest/globals'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e834252f464672f1c1dbeae76506145773ea65a" translate="yes" xml:space="preserve">
          <source>Indicates that test coverage information should be collected and reported in the output. This option is also aliased by &lt;code&gt;--collectCoverage&lt;/code&gt;.</source>
          <target state="translated">指示应收集测试覆盖率信息并在输出中报告。 &lt;code&gt;--collectCoverage&lt;/code&gt; 也是该选项的别名。</target>
        </trans-unit>
        <trans-unit id="1284d31f44064613a87f5368a4ace1fc81c96bbe" translate="yes" xml:space="preserve">
          <source>Indicates that the module system should never return a mocked version of the specified module from &lt;code&gt;require()&lt;/code&gt; (e.g. that it should always return the real module).</source>
          <target state="translated">指示模块系统永远不要从 &lt;code&gt;require()&lt;/code&gt; 返回指定模块的模拟版本（例如，它应始终返回真实模块）。</target>
        </trans-unit>
        <trans-unit id="525344995f960a29bbb0a0780b82869722611218" translate="yes" xml:space="preserve">
          <source>Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.</source>
          <target state="translated">表示是否应该在运行过程中报告每个单独的测试。执行后,所有的错误也仍然会在底部显示。</target>
        </trans-unit>
        <trans-unit id="51576c8c7f1e583054e7e2cbb71b47efb2a7a617" translate="yes" xml:space="preserve">
          <source>Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution. Note that if there is only one test file being run it will default to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4810b9c6deb3cfc560d1b8be11be54439818a5" translate="yes" xml:space="preserve">
          <source>Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.</source>
          <target state="translated">表示是否应该在执行测试时收集覆盖率信息。因为这样做会在所有执行的文件中加入覆盖率收集声明,所以可能会大大降低测试速度。</target>
        </trans-unit>
        <trans-unit id="63d7e8877d4625671b76b3bbf6e2fe72db6c60e4" translate="yes" xml:space="preserve">
          <source>Indicates which provider should be used to instrument code for coverage. Allowed values are &lt;code&gt;babel&lt;/code&gt; (default) or &lt;code&gt;v8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ffcf9de303be59af5e2e722fc87828180290e8" translate="yes" xml:space="preserve">
          <source>Injecting a test implementation is helpful, but you will probably also want to test whether the class constructor and methods are called with the correct parameters.</source>
          <target state="translated">注入测试实现是很有帮助的,但你可能还想测试类的构造函数和方法是否用正确的参数被调用。</target>
        </trans-unit>
        <trans-unit id="c16df8c50d3d5dd63ff045ec5082a89d1d9864d9" translate="yes" xml:space="preserve">
          <source>Inline Snapshots</source>
          <target state="translated">内联快照</target>
        </trans-unit>
        <trans-unit id="db4c16bd16f6d824e3ae08925279ff7d80be7fa7" translate="yes" xml:space="preserve">
          <source>Inline snapshots are powered by &lt;a href=&quot;https://prettier.io&quot;&gt;Prettier&lt;/a&gt;. To use inline snapshots you must have &lt;code&gt;prettier&lt;/code&gt; installed in your project. Your Prettier configuration will be respected when writing to test files.</source>
          <target state="translated">内联快照由&lt;a href=&quot;https://prettier.io&quot;&gt;Prettier&lt;/a&gt;提供支持。要使用嵌入式快照，您必须在项目中安装 &lt;code&gt;prettier&lt;/code&gt; 快照。写入测试文件时，将使用您的Prettier配置。</target>
        </trans-unit>
        <trans-unit id="8634b51371ce9727d167fddae91a84b3084a1895" translate="yes" xml:space="preserve">
          <source>Inline snapshots behave identically to external snapshots (&lt;code&gt;.snap&lt;/code&gt; files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.</source>
          <target state="translated">内联快照的行为与外部快照（ &lt;code&gt;.snap&lt;/code&gt; 文件）相同，只是快照值会自动写回到源代码中。这意味着您可以享受自动生成的快照的好处，而不必切换到外部文件来确保写入正确的值。</target>
        </trans-unit>
        <trans-unit id="337e2fb497f210adadaa378f0740dc62d228953f" translate="yes" xml:space="preserve">
          <source>Insert Jest's globals (&lt;code&gt;expect&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;describe&lt;/code&gt;, &lt;code&gt;beforeEach&lt;/code&gt; etc.) into the global environment. If you set this to &lt;code&gt;false&lt;/code&gt;, you should import from &lt;code&gt;@jest/globals&lt;/code&gt;, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94217fdf7438c2ec9d5e4178c873dbfe79b8612" translate="yes" xml:space="preserve">
          <source>Install Jest using &lt;a href=&quot;https://yarnpkg.com/en/package/jest&quot;&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;https://yarnpkg.com/en/package/jest&quot;&gt; &lt;code&gt;yarn&lt;/code&gt; &lt;/a&gt;安装Jest ：</target>
        </trans-unit>
        <trans-unit id="6092d383d1cc73be163afe7eb2ce1f7872844a2a" translate="yes" xml:space="preserve">
          <source>Instead of literal property values in the expected object, you can use matchers, &lt;code&gt;expect.anything()&lt;/code&gt;, and so on.</source>
          <target state="translated">可以使用匹配器， &lt;code&gt;expect.anything()&lt;/code&gt; 代替期望对象中的文字属性值。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="9cc2a78e6bbcf2a24971feabf0515729dc411624" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;.toBeCloseTo&lt;/code&gt;. Use &lt;code&gt;numDigits&lt;/code&gt; to control how many digits after the decimal point to check. For example, if you want to be sure that &lt;code&gt;0.2 + 0.1&lt;/code&gt; is equal to &lt;code&gt;0.3&lt;/code&gt; with a precision of 5 decimal digits, you can use this test:</source>
          <target state="translated">而是使用 &lt;code&gt;.toBeCloseTo&lt;/code&gt; 。使用 &lt;code&gt;numDigits&lt;/code&gt; 控制要检查的小数点后位数。例如，如果要确保 &lt;code&gt;0.2 + 0.1&lt;/code&gt; 等于 &lt;code&gt;0.3&lt;/code&gt; ,且精度为5位小数位数，则可以使用以下测试：</target>
        </trans-unit>
        <trans-unit id="3d4c0946e29e0677ed77927a5a5b8175e597a81b" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use fake versions of the standard timer functions (&lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;, &lt;code&gt;nextTick&lt;/code&gt;, &lt;code&gt;setImmediate&lt;/code&gt; and &lt;code&gt;clearImmediate&lt;/code&gt;).</source>
          <target state="translated">指示Jest使用标准计时器函数的伪造版本（ &lt;code&gt;setTimeout&lt;/code&gt; ， &lt;code&gt;setInterval&lt;/code&gt; ， &lt;code&gt;clearTimeout&lt;/code&gt; ， &lt;code&gt;clearInterval&lt;/code&gt; ， &lt;code&gt;nextTick&lt;/code&gt; ， &lt;code&gt;setImmediate&lt;/code&gt; 和 &lt;code&gt;clearImmediate&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="53f0e89b734a053251bf9ba130c561bca653f2ca" translate="yes" xml:space="preserve">
          <source>Instructs Jest to use the real versions of the standard timer functions.</source>
          <target state="translated">指示Jest使用标准定时器功能的真实版本。</target>
        </trans-unit>
        <trans-unit id="580b09d323b391c56988f3afd1aa0348c802898c" translate="yes" xml:space="preserve">
          <source>Interactive Snapshot Mode</source>
          <target state="translated">互动快照模式</target>
        </trans-unit>
        <trans-unit id="6db909d47e7d3c532b0dc512e249b63be5ca7db8" translate="yes" xml:space="preserve">
          <source>Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02513dac2749bb0bea9a23e68783f2f1b43824b8" translate="yes" xml:space="preserve">
          <source>Is it possible to apply test-driven development principles with snapshot testing?</source>
          <target state="translated">是否可以用快照测试来应用测试驱动的开发原则?</target>
        </trans-unit>
        <trans-unit id="c71f5fef9c08b0fbc164d5be4846e0402e7d3f18" translate="yes" xml:space="preserve">
          <source>It fails because in JavaScript, &lt;code&gt;0.2 + 0.1&lt;/code&gt; is actually &lt;code&gt;0.30000000000000004&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9055c96fbca9c47e000ff8c108ec23e99fdd71fc" translate="yes" xml:space="preserve">
          <source>It fails because in JavaScript, &lt;code&gt;0.2 + 0.1&lt;/code&gt; is actually &lt;code&gt;0.30000000000000004&lt;/code&gt;. Sorry.</source>
          <target state="translated">它失败是因为在JavaScript中， &lt;code&gt;0.2 + 0.1&lt;/code&gt; 实际上是 &lt;code&gt;0.30000000000000004&lt;/code&gt; 。抱歉。</target>
        </trans-unit>
        <trans-unit id="7f735d98c06c220d11d75c5397c9c1b8e52c4d4d" translate="yes" xml:space="preserve">
          <source>It is possible to override this setting in individual tests by explicitly calling &lt;code&gt;jest.mock()&lt;/code&gt; at the top of the test file.</source>
          <target state="translated">通过在测试文件顶部显式调用 &lt;code&gt;jest.mock()&lt;/code&gt; ，可以在单个测试中覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="fd7f0fe9fa2e98d6b45b7e85870b6bebb4244c0e" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;expect.arrayContaining&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="6fa06d234ccf0592e6a7833abb4b44564a10ce20" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.objectContaining&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;expect.objectContaining&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="6c45932d1b92f754d3092dcfc07a259652cb482f" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringContaining&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;expect.stringContaining&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="56fdb83f46a304e9e8a0b0082332d015e93ccfd5" translate="yes" xml:space="preserve">
          <source>It is the inverse of &lt;code&gt;expect.stringMatching&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;expect.stringMatching&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="229fd96c0729adbf00e917d7c3abed65d735e457" translate="yes" xml:space="preserve">
          <source>It's also possible to create custom matchers for inline snapshots, the snapshots will be correctly added to the custom matchers. However, inline snapshot will always try to append to the first argument or the second when the first argument is the property matcher, so it's not possible to accept custom arguments in the custom matchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d71d3a81131ff51abfd443e0210b69c77cfc06" translate="yes" xml:space="preserve">
          <source>It's also worth noting that &lt;code&gt;setupFiles&lt;/code&gt; will execute &lt;em&gt;before&lt;/em&gt;&lt;a href=&quot;#setupfilesafterenv-array&quot;&gt;&lt;code&gt;setupFilesAfterEnv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还值得注意的是， &lt;code&gt;setupFiles&lt;/code&gt; 将&lt;em&gt;在&lt;/em&gt;&lt;a href=&quot;#setupfilesafterenv-array&quot;&gt; &lt;code&gt;setupFilesAfterEnv&lt;/code&gt; &lt;/a&gt;&lt;em&gt;之前&lt;/em&gt;执行。</target>
        </trans-unit>
        <trans-unit id="2e57c75a59ba04722961a96e662337fe62d32cd4" translate="yes" xml:space="preserve">
          <source>It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.</source>
          <target state="translated">在JavaScript中,代码异步运行是很常见的。当你有异步运行的代码时,Jest需要知道它正在测试的代码何时完成,然后才能继续进行另一个测试。Jest有几种方法来处理这个问题。</target>
        </trans-unit>
        <trans-unit id="e568a9bbdb9a0508a3a3ef0e439e109837c0942f" translate="yes" xml:space="preserve">
          <source>It's easier to understand this with an example. Let's say you have a method &lt;code&gt;bestLaCroixFlavor()&lt;/code&gt; which is supposed to return the string &lt;code&gt;'grapefruit'&lt;/code&gt;. Here's how you would test that:</source>
          <target state="translated">通过示例更容易理解这一点。假设您有一个 &lt;code&gt;bestLaCroixFlavor()&lt;/code&gt; 方法，该方法应该返回字符串 &lt;code&gt;'grapefruit'&lt;/code&gt; 。这是您将如何测试的方法：</target>
        </trans-unit>
        <trans-unit id="667bf8c3b168c667f3639da763c2b5c80fb59070" translate="yes" xml:space="preserve">
          <source>It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.</source>
          <target state="translated">在引入bug后,很容易发现快照测试失败。当这种情况发生时,请继续修复这个问题,并确保你的快照测试再次通过。现在,让我们来谈谈快照测试由于有意的实现变化而失败的情况。</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="4f48cbea09ae54f44848cf5913f3a8fd18dc1890" translate="yes" xml:space="preserve">
          <source>Jest 24 dropped support for Babel 6. We highly recommend you to upgrade to Babel 7, which is actively maintained. However, if you cannot upgrade to Babel 7, either keep using Jest 23 or upgrade to Jest 24 with &lt;code&gt;babel-jest&lt;/code&gt; locked at version 23, like in the example below:</source>
          <target state="translated">Jest 24放弃了对Babel 6的支持。我们强烈建议您升级到积极维护的Babel 7。但是，如果您无法升级到Babel 7，请继续使用Jest 23或将 &lt;code&gt;babel-jest&lt;/code&gt; 锁定在23版来升级到Jest 24 ，如下例所示：</target>
        </trans-unit>
        <trans-unit id="3c37bbcc2dc087e83d511674c69f117488f9a448" translate="yes" xml:space="preserve">
          <source>Jest CLI Options</source>
          <target state="translated">Jest CLI选项</target>
        </trans-unit>
        <trans-unit id="7b0763aa90e25f9dc7844da6152ce6f3059ffcb2" translate="yes" xml:space="preserve">
          <source>Jest Community</source>
          <target state="translated">Jest社区</target>
        </trans-unit>
        <trans-unit id="ea58238fa3c595c1ac8d7fc4a688da21db96450d" translate="yes" xml:space="preserve">
          <source>Jest Platform</source>
          <target state="translated">Jest平台</target>
        </trans-unit>
        <trans-unit id="b4848b4fe1132599637029a65960f94eb8531822" translate="yes" xml:space="preserve">
          <source>Jest adds the &lt;code&gt;inlineSnapshot&lt;/code&gt; string argument to the matcher in the test file (instead of an external &lt;code&gt;.snap&lt;/code&gt; file) the first time that the test runs.</source>
          <target state="translated">Jest 在第一次运行测试时，将 &lt;code&gt;inlineSnapshot&lt;/code&gt; 字符串参数添加到测试文件（而不是外部 &lt;code&gt;.snap&lt;/code&gt; 文件）中的匹配器。</target>
        </trans-unit>
        <trans-unit id="7a0d7242dfd96ba5446eb996644a2e93256965b7" translate="yes" xml:space="preserve">
          <source>Jest allows third-party plugins to override some of its built-in feature keys, but not all. Specifically, the following keys are &lt;strong&gt;not overwritable&lt;/strong&gt; :</source>
          <target state="translated">Jest允许第三方插件覆盖其某些内置功能键，但不是全部。具体来说，以下密钥&lt;strong&gt;不可重写&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="3db4e21502b1cf82fe4554f5a22adc84d4239482" translate="yes" xml:space="preserve">
          <source>Jest allows you to mock out whole modules in your tests, which can be useful for testing if your code is calling functions from that module correctly. However, sometimes you may want to use parts of a mocked module in your &lt;em&gt;test file&lt;/em&gt;, in which case you want to access the original implementation, rather than a mocked version.</source>
          <target state="translated">Jest允许您在测试中模拟整个模块，这对于测试代码是否正确地从该模块调用函数很有用。但是，有时您可能想在&lt;em&gt;测试文件中&lt;/em&gt;使用模拟模块的一部分，在这种情况下，您要访问原始实现，而不是模拟版本。</target>
        </trans-unit>
        <trans-unit id="a926667eb8c4ae03b1d94701be16eb503a21b695" translate="yes" xml:space="preserve">
          <source>Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem raking that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.</source>
          <target state="translated">Jest 试图扫描您的依赖树一次 (前期),并将其缓存起来,以减轻运行测试时需要进行的一些文件系统扫描。这个配置选项允许您自定义 Jest 在磁盘上存储缓存数据的位置。</target>
        </trans-unit>
        <trans-unit id="66e4080317feae6223beabd2b4f318ae96222967" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://parceljs.org/&quot;&gt;parcel-bundler&lt;/a&gt; to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official &lt;a href=&quot;https://parceljs.org/getting_started.html&quot;&gt;docs&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7217bf7214933a525b967deb724c6b9162cbf15e" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack &lt;em&gt;does&lt;/em&gt; offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.</source>
          <target state="translated">Jest可以用于使用&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;来管理资产，样式和编译的项目中。与其他工具相比，webpack &lt;em&gt;确实&lt;/em&gt;带来了一些独特的挑战，因为它直接与您的应用程序集成以允许管理样式表，图像和字体之类的资产，以及可编译为JavaScript的语言和工具的广泛生态系统。</target>
        </trans-unit>
        <trans-unit id="03f07f770f308cce4d6d71cf7a65755091125d70" translate="yes" xml:space="preserve">
          <source>Jest can be used in projects that use &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the &lt;a href=&quot;webpack&quot;&gt;webpack guide&lt;/a&gt; to get started.</source>
          <target state="translated">Jest可以用于使用&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;来管理资产，样式和编译的项目中。与其他工具相比，webpack确实提供了一些独特的挑战。请参阅&lt;a href=&quot;webpack&quot;&gt;webpack指南&lt;/a&gt;以开始使用。</target>
        </trans-unit>
        <trans-unit id="1e1f86ef9ac3ba9a1094e45789f0246c03864424" translate="yes" xml:space="preserve">
          <source>Jest can be used to mock ES6 classes that are imported into files you want to test.</source>
          <target state="translated">Jest可以用来模拟导入到您要测试的文件中的ES6类。</target>
        </trans-unit>
        <trans-unit id="cf92262b3a746cb5cadf84ee52757121913d4bb5" translate="yes" xml:space="preserve">
          <source>Jest configuration:</source>
          <target state="translated">Jest配置。</target>
        </trans-unit>
        <trans-unit id="d3875a4b049058d09ee11ad3b9257c6fc76e7609" translate="yes" xml:space="preserve">
          <source>Jest executes all describe handlers in a test file &lt;em&gt;before&lt;/em&gt; it executes any of the actual tests. This is another reason to do setup and teardown inside &lt;code&gt;before*&lt;/code&gt; and &lt;code&gt;after*&lt;/code&gt; handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.</source>
          <target state="translated">Jest &lt;em&gt;在&lt;/em&gt;执行任何实际测试&lt;em&gt;之前，先&lt;/em&gt;在测试文件中执行所有描述处理程序。这是 &lt;code&gt;before*&lt;/code&gt; 和 &lt;code&gt;after*&lt;/code&gt; 处理程序中而不是在describe块中进行设置和拆卸的另一个原因。描述块完成后，默认情况下，Jest会按照在收集阶段遇到的顺序依次运行所有测试，等待每个测试完成并整理后再继续。</target>
        </trans-unit>
        <trans-unit id="0de3feadb801fdfceabb49f311df02bb3d2e6317" translate="yes" xml:space="preserve">
          <source>Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the &lt;code&gt;toMatchSnapshot&lt;/code&gt; matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.</source>
          <target state="translated">Jest出于性能考虑而进行了重写，快照测试也不例外。由于快照存储在文本文件中，因此这种测试方式既快速又可靠。Jest为每个调用 &lt;code&gt;toMatchSnapshot&lt;/code&gt; 匹配器的测试文件生成一个新文件。快照的大小非常小：作为参考，Jest代码库本身中所有快照文件的大小都小于300 KB。</target>
        </trans-unit>
        <trans-unit id="d3cecfbd4eff60247088ea6ea3e4cdcc4eadc368" translate="yes" xml:space="preserve">
          <source>Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See &lt;a href=&quot;tutorial-react-native#snapshot-test&quot;&gt;snapshot test tutorial&lt;/a&gt; for more information.</source>
          <target state="translated">Jest具有用于内置JavaScript类型，HTML元素（Jest 20.0.0 +），ImmutableJS（Jest 20.0.0+）和React元素的默认序列化器。有关更多信息，请参见&lt;a href=&quot;tutorial-react-native#snapshot-test&quot;&gt;快照测试教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b8f3b08f9e746db06cf8a8d8eb1728a20518b9e" translate="yes" xml:space="preserve">
          <source>Jest hooks can be attached by implementing the &lt;code&gt;apply&lt;/code&gt; method. This method receives a &lt;code&gt;jestHooks&lt;/code&gt; argument that allows the plugin to hook into specific parts of the lifecycle of a test run.</source>
          <target state="translated">玩笑钩子可以通过 &lt;code&gt;apply&lt;/code&gt; 方法来附加。此方法接收一个 &lt;code&gt;jestHooks&lt;/code&gt; 参数，该参数允许插件挂接到测试运行生命周期的特定部分。</target>
        </trans-unit>
        <trans-unit id="947f4166700a4d645ffc5ea6bf0ec90dab4952a9" translate="yes" xml:space="preserve">
          <source>Jest is a universal testing platform, with the ability to adapt to any JavaScript library or framework. In this section, we'd like to link to community posts and articles about integrating Jest into popular JS libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887d894f29d3f2da709db2398fdd8a706e612180" translate="yes" xml:space="preserve">
          <source>Jest itself is written in &lt;a href=&quot;https://www.typescriptlang.org&quot;&gt;TypeScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78961166274ac390b7c628a0f785ac9679ec16ba" translate="yes" xml:space="preserve">
          <source>Jest supports TypeScript, via Babel. First make sure you followed the instructions on &lt;a href=&quot;#using-babel&quot;&gt;using Babel&lt;/a&gt; above. Next install the &lt;code&gt;@babel/preset-typescript&lt;/code&gt; via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">Jest通过Babel支持TypeScript。首先，请确保您已按照上面有关&lt;a href=&quot;#using-babel&quot;&gt;使用Babel&lt;/a&gt;的说明进行操作。接下来通过 &lt;code&gt;yarn&lt;/code&gt; 安装 &lt;code&gt;@babel/preset-typescript&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bb70b31cde0329217748b185e1bdd2f06fec771e" translate="yes" xml:space="preserve">
          <source>Jest supports TypeScript, via Babel. First, make sure you followed the instructions on &lt;a href=&quot;#using-babel&quot;&gt;using Babel&lt;/a&gt; above. Next, install the &lt;code&gt;@babel/preset-typescript&lt;/code&gt; via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11e203b83dbe47f8f3b7f063d8cc42dbb8c82d0" translate="yes" xml:space="preserve">
          <source>Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df084822eb105d3a7a4cf3edd0cec8b8b50c092a" translate="yes" xml:space="preserve">
          <source>Jest supports both camelcase and dashed arg formats. The following examples will have equal result:</source>
          <target state="translated">Jest 支持驼峰和虚线两种格式的 arg。下面的例子会有相同的结果。</target>
        </trans-unit>
        <trans-unit id="a26bd9497d9f62beebdda3158cf8b5bcd46589c3" translate="yes" xml:space="preserve">
          <source>Jest takes advantage of new features added to Node 6. We recommend that you upgrade to the latest stable release of Node. The minimum supported version is &lt;code&gt;v6.0.0&lt;/code&gt;. Versions &lt;code&gt;0.x.x&lt;/code&gt; and &lt;code&gt;4.x.x&lt;/code&gt; are not supported because the &lt;code&gt;jsdom&lt;/code&gt; version used in Jest doesn't support Node 4. However, if you need to run Jest on Node 4, you can use the &lt;code&gt;testEnvironment&lt;/code&gt; config to use a &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;custom environment&lt;/a&gt; that supports Node 4, such as &lt;a href=&quot;https://yarnpkg.com/en/package/jest-environment-node&quot;&gt;&lt;code&gt;jest-environment-node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Jest利用了Node 6中添加的新功能。我们建议您升级到Node的最新稳定版本。支持的最低版本是 &lt;code&gt;v6.0.0&lt;/code&gt; 。不支持版本 &lt;code&gt;0.x.x&lt;/code&gt; 和 &lt;code&gt;4.x.x&lt;/code&gt; ，因为Jest中使用的 &lt;code&gt;jsdom&lt;/code&gt; 版本不支持节点4。但是，如果需要在节点4上运行Jest，则可以使用 &lt;code&gt;testEnvironment&lt;/code&gt; 配置来使用支持以下内容的&lt;a href=&quot;configuration#testenvironment-string&quot;&gt;自定义环境&lt;/a&gt;：节点4，例如&lt;a href=&quot;https://yarnpkg.com/en/package/jest-environment-node&quot;&gt; &lt;code&gt;jest-environment-node&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="768460f31b776efe5a80d1b9f906e146b73387b9" translate="yes" xml:space="preserve">
          <source>Jest uses &quot;matchers&quot; to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the &lt;a href=&quot;expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; API doc&lt;/a&gt;.</source>
          <target state="translated">Jest使用&amp;ldquo;匹配器&amp;rdquo;让您以不同的方式测试值。本文档将介绍一些常用的匹配器。有关完整列表，请参见&lt;a href=&quot;expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c82af62e3c4f58c048febf072e373b55ced751b5" translate="yes" xml:space="preserve">
          <source>Jest will fail if:</source>
          <target state="translated">杰斯特会失败,如果:</target>
        </trans-unit>
        <trans-unit id="67e59a98c5fb0793e5a8bd46b25470fc7acc51f4" translate="yes" xml:space="preserve">
          <source>Jest will set &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; to &lt;code&gt;'test'&lt;/code&gt; if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.</source>
          <target state="translated">如果未将Jest的 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 设置为 &lt;code&gt;'test'&lt;/code&gt; 则将其设置为&amp;ldquo; test&amp;rdquo;。您可以在配置中使用它来有条件地仅设置Jest所需的编译，例如</target>
        </trans-unit>
        <trans-unit id="72d5c3a199ac87496dc718d131f247923a5cf3ff" translate="yes" xml:space="preserve">
          <source>Jest's configuration can be defined in the &lt;code&gt;package.json&lt;/code&gt; file of your project, or through a &lt;code&gt;jest.config.js&lt;/code&gt; file or through the &lt;code&gt;--config &amp;lt;path/to/js|json&amp;gt;&lt;/code&gt; option. If you'd like to use your &lt;code&gt;package.json&lt;/code&gt; to store Jest's config, the &quot;jest&quot; key should be used on the top level so Jest will know how to find your settings:</source>
          <target state="translated">Jest的配置可以在项目的 &lt;code&gt;package.json&lt;/code&gt; 文件中定义，也可以通过 &lt;code&gt;jest.config.js&lt;/code&gt; 文件或 &lt;code&gt;--config &amp;lt;path/to/js|json&amp;gt;&lt;/code&gt; 选项定义。如果您想使用 &lt;code&gt;package.json&lt;/code&gt; 存储Jest的配置，则应在顶层使用&amp;ldquo; jest&amp;rdquo;键，以便Jest知道如何查找您的设置：</target>
        </trans-unit>
        <trans-unit id="cee5539fa487c25148205422396f2eaffaba45fb" translate="yes" xml:space="preserve">
          <source>Jest's configuration can be defined in the &lt;code&gt;package.json&lt;/code&gt; file of your project, or through a &lt;code&gt;jest.config.js&lt;/code&gt;, or &lt;code&gt;jest.config.ts&lt;/code&gt; file or through the &lt;code&gt;--config &amp;lt;path/to/file.js|ts|cjs|mjs|json&amp;gt;&lt;/code&gt; option. If you'd like to use your &lt;code&gt;package.json&lt;/code&gt; to store Jest's config, the &lt;code&gt;&quot;jest&quot;&lt;/code&gt; key should be used on the top level so Jest will know how to find your settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e22c112121645c276dc7120c07fdacec26f44c5" translate="yes" xml:space="preserve">
          <source>Join the community</source>
          <target state="translated">加入社区</target>
        </trans-unit>
        <trans-unit id="ab922b1d7b4717c074a882c0cc8961b6bee80d98" translate="yes" xml:space="preserve">
          <source>Keeping track of usage (spying on the mock)</source>
          <target state="translated">跟踪使用情况(监视模拟)。</target>
        </trans-unit>
        <trans-unit id="2aeb4bdd1784b8385939c2b4d4425b6e4b8d7dce" translate="yes" xml:space="preserve">
          <source>Keys with &lt;code&gt;undefined&lt;/code&gt; properties are checked. e.g. &lt;code&gt;{a: undefined, b: 2}&lt;/code&gt; does not match &lt;code&gt;{b: 2}&lt;/code&gt; when using &lt;code&gt;.toStrictEqual&lt;/code&gt;.</source>
          <target state="translated">检查具有 &lt;code&gt;undefined&lt;/code&gt; 属性的键。例如 &lt;code&gt;{a: undefined, b: 2}&lt;/code&gt; 当使用 &lt;code&gt;.toStrictEqual&lt;/code&gt; 时，{a：undefined，b：2}与 &lt;code&gt;{b: 2}&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="ee55816ee3b1b4f1a6f30044867a661ab9181c42" translate="yes" xml:space="preserve">
          <source>Lastly, it may occasionally be useful in some tests to be able to clear all of the pending timers. For this, we have &lt;code&gt;jest.clearAllTimers()&lt;/code&gt;.</source>
          <target state="translated">最后，有时在某些测试中能够清除所有未决计时器可能很有用。为此，我们有 &lt;code&gt;jest.clearAllTimers()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a524bb87c02c371357d8cd4517ffca34064b2ab0" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;, &lt;a href=&quot;mock-functions&quot;&gt;Mock Functions&lt;/a&gt;, and more in our in-depth guides.</source>
          <target state="translated">在我们的深入指南中了解有关&lt;a href=&quot;snapshot-testing&quot;&gt;快照测试&lt;/a&gt;，&lt;a href=&quot;mock-functions&quot;&gt;模拟功能&lt;/a&gt;等的更多信息。</target>
        </trans-unit>
        <trans-unit id="4713da2c87e8066c2601dd3ebce0a9e9a2b367bd" translate="yes" xml:space="preserve">
          <source>Learn by example</source>
          <target state="translated">榜样学习</target>
        </trans-unit>
        <trans-unit id="a73e45c2d9e4a09fc058543b28381a8d5615a8a2" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;configuration&quot;&gt;configure Jest&lt;/a&gt;.</source>
          <target state="translated">了解如何&lt;a href=&quot;configuration&quot;&gt;配置Jest&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e7bb758fec5bace28a605b54e391a12fa494eb2" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a Link component that renders hyperlinks:</source>
          <target state="translated">让我们为呈现超链接的Link组件创建&lt;a href=&quot;snapshot-testing&quot;&gt;快照测试&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="482beae4bfaae3f9fde0514bd3872927745e83f4" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;a href=&quot;snapshot-testing&quot;&gt;snapshot test&lt;/a&gt; for a small intro component with a few views and text components and some styles:</source>
          <target state="translated">让我们为一个具有一些视图和文本组件以及某些样式的小型简介组件创建一个&lt;a href=&quot;snapshot-testing&quot;&gt;快照测试&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a993458f25570cd03bfa9e9bce6047cea0775b62" translate="yes" xml:space="preserve">
          <source>Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a &lt;code&gt;sum.js&lt;/code&gt; file:</source>
          <target state="translated">让我们开始编写一个假设函数的测试，该测试将两个数字相加。首先，创建一个 &lt;code&gt;sum.js&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="fcc8a6e48c03e9796bf746a0a520bcf38352c6b3" translate="yes" xml:space="preserve">
          <source>Let's imagine we're testing an implementation of a function &lt;code&gt;forEach&lt;/code&gt;, which invokes a callback for each item in a supplied array.</source>
          <target state="translated">假设我们正在测试 &lt;code&gt;forEach&lt;/code&gt; 函数的实现，该函数将为提供的数组中的每个项目调用一个回调。</target>
        </trans-unit>
        <trans-unit id="062d6ba16b7346d8afbaec636d17b749060ac2a7" translate="yes" xml:space="preserve">
          <source>Let's implement a checkbox which swaps between two labels:</source>
          <target state="translated">让我们实现一个复选框,它可以在两个标签之间交换。</target>
        </trans-unit>
        <trans-unit id="c06fbcda1135b4a2d62c84a73f8043d399406587" translate="yes" xml:space="preserve">
          <source>Let's implement a module that fetches user data from an API and returns the user name.</source>
          <target state="translated">让我们实现一个从API中获取用户数据并返回用户名的模块。</target>
        </trans-unit>
        <trans-unit id="dd426a8b3b04464a96cf78d5aa5692208e8f3496" translate="yes" xml:space="preserve">
          <source>Let's rewrite the test from above using Enzyme instead of react-testing-library. We use Enzyme's &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow renderer&lt;/a&gt; in this example.</source>
          <target state="translated">让我们使用酶而不是react-testing-library从上面重写测试。在此示例中，我们使用酶的&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;浅层渲染器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="157e685f0b5acabc2a4f6b50f0c1c98f974a8a3d" translate="yes" xml:space="preserve">
          <source>Let's start with a common sort of webpack config file and translate it to a Jest setup.</source>
          <target state="translated">让我们从常见的那种webpack配置文件开始,并将其翻译成Jest设置。</target>
        </trans-unit>
        <trans-unit id="3fd38479f084ecddacb918704233c6136d1f9d08" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test runner.</source>
          <target state="translated">让你指定一个自定义的测试运行器。</target>
        </trans-unit>
        <trans-unit id="fd0feff82f64a29645a993d706fca6c82a94899c" translate="yes" xml:space="preserve">
          <source>Lets you specify a custom test sequencer. Please refer to the documentation of the corresponding configuration property for details.</source>
          <target state="translated">可让您指定自定义测试排序器。详情请参考相应配置属性的文档。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="a3dbc9fff53cb18c46d1dbe0926adbfb61c34df0" translate="yes" xml:space="preserve">
          <source>Lists all tests as JSON that Jest will run given the arguments, and exits. This can be used together with &lt;code&gt;--findRelatedTests&lt;/code&gt; to know which tests Jest will run.</source>
          <target state="translated">给定参数，将Jest将运行的所有测试列为JSON，然后退出。可以将它与 &lt;code&gt;--findRelatedTests&lt;/code&gt; 一起使用，以了解Jest将运行哪些测试。</target>
        </trans-unit>
        <trans-unit id="7cf968e7663782a1b2d3370cf3fab9d47ef5ec45" translate="yes" xml:space="preserve">
          <source>Logs the heap usage after every test. Useful to debug memory leaks. Use together with &lt;code&gt;--runInBand&lt;/code&gt; and &lt;code&gt;--expose-gc&lt;/code&gt; in node.</source>
          <target state="translated">每次测试后记录堆使用情况。对调试内存泄漏很有用。在节点中与 &lt;code&gt;--runInBand&lt;/code&gt; 和 &lt;code&gt;--expose-gc&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="3062ee96f10ceb01351b8c1d96e5d36b30dca2e3" translate="yes" xml:space="preserve">
          <source>Look at the full &lt;a href=&quot;api&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="translated">查看完整的&lt;a href=&quot;api&quot;&gt;API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b8e7713a214ac3e151ee1f95eb5b5953bf52353" translate="yes" xml:space="preserve">
          <source>Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.</source>
          <target state="translated">使调用废弃的API抛出有用的错误信息。有助于简化升级过程。</target>
        </trans-unit>
        <trans-unit id="ff5c0e44a12b2c154dbab6ad20eb02b2ebda36df" translate="yes" xml:space="preserve">
          <source>Make sure you are not using the &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; plugin. Jest wraps Istanbul, and therefore also tells Istanbul what files to instrument with coverage collection. When using &lt;code&gt;babel-plugin-istanbul&lt;/code&gt;, every file that is processed by Babel will have coverage collection code, hence it is not being ignored by &lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt;.</source>
          <target state="translated">确保您没有使用 &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; 插件。Jest包装了伊斯坦布尔，因此还告诉伊斯坦布尔要覆盖哪些文件。使用 &lt;code&gt;babel-plugin-istanbul&lt;/code&gt; 时，Babel处理的每个文件都将具有coverage收集代码，因此 &lt;code&gt;coveragePathIgnorePatterns&lt;/code&gt; 不会忽略该文件。</target>
        </trans-unit>
        <trans-unit id="2601b2eb4063a28fa7ddf679595552390f7aaaad" translate="yes" xml:space="preserve">
          <source>Manual Mocks</source>
          <target state="translated">手册模拟</target>
        </trans-unit>
        <trans-unit id="a515a8ca23977a705cfa165109739d0a5188aab8" translate="yes" xml:space="preserve">
          <source>Manual mock</source>
          <target state="translated">手工模拟</target>
        </trans-unit>
        <trans-unit id="24649abe70370a7c2be875cc1bb049c1d2c3120f" translate="yes" xml:space="preserve">
          <source>Manual mock that is another ES6 class</source>
          <target state="translated">手动模拟,是另一个ES6类</target>
        </trans-unit>
        <trans-unit id="44695745ffcdd878a86f104986c6a105e40ebd17" translate="yes" xml:space="preserve">
          <source>Manual mocks are defined by writing a module in a &lt;code&gt;__mocks__/&lt;/code&gt; subdirectory immediately adjacent to the module. For example, to mock a module called &lt;code&gt;user&lt;/code&gt; in the &lt;code&gt;models&lt;/code&gt; directory, create a file called &lt;code&gt;user.js&lt;/code&gt; and put it in the &lt;code&gt;models/__mocks__&lt;/code&gt; directory. Note that the &lt;code&gt;__mocks__&lt;/code&gt; folder is case-sensitive, so naming the directory &lt;code&gt;__MOCKS__&lt;/code&gt; will break on some systems.</source>
          <target state="translated">手动 &lt;code&gt;__mocks__/&lt;/code&gt; 是通过在紧邻模块的__mocks __ /子目录中写入模块来定义的。例如，要在 &lt;code&gt;models&lt;/code&gt; 目录中模拟名为 &lt;code&gt;user&lt;/code&gt; 的模块，请创建一个名为 &lt;code&gt;user.js&lt;/code&gt; 的文件，并将其放在 &lt;code&gt;models/__mocks__&lt;/code&gt; 目录中。请注意， &lt;code&gt;__mocks__&lt;/code&gt; 文件夹区分大小写，因此在某些系统上命名目录 &lt;code&gt;__MOCKS__&lt;/code&gt; 将不起作用。</target>
        </trans-unit>
        <trans-unit id="e6043328f6dbc68531364ede4b70721943facae0" translate="yes" xml:space="preserve">
          <source>Manual mocks are used to stub out functionality with mock data. For example, instead of accessing a remote resource like a website or a database, you might want to create a manual mock that allows you to use fake data. This ensures your tests will be fast and not flaky.</source>
          <target state="translated">手动mock用于用模拟数据来支取功能。例如,您可能希望创建一个手动模拟,允许您使用假数据,而不是访问网站或数据库等远程资源。这确保了你的测试将是快速而不是片面的。</target>
        </trans-unit>
        <trans-unit id="9d4d90d06bd9381fe57041c5e2c6fa49629ba38e" translate="yes" xml:space="preserve">
          <source>Matchers are called with the argument passed to &lt;code&gt;expect(x)&lt;/code&gt; followed by the arguments passed to &lt;code&gt;.yourMatcher(y, z)&lt;/code&gt;:</source>
          <target state="translated">通过传递给 &lt;code&gt;.yourMatcher(y, z)&lt;/code&gt; &lt;code&gt;expect(x)&lt;/code&gt; 的参数，然后传递给.yourMatcher（y，z）的参数来调用匹配器：</target>
        </trans-unit>
        <trans-unit id="9fdeb71c3b04a33085ca1c966123a1422dbbb545" translate="yes" xml:space="preserve">
          <source>Matchers should return an object (or a Promise of an object) with two keys. &lt;code&gt;pass&lt;/code&gt; indicates whether there was a match or not, and &lt;code&gt;message&lt;/code&gt; provides a function with no arguments that returns an error message in case of failure. Thus, when &lt;code&gt;pass&lt;/code&gt; is false, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).yourMatcher()&lt;/code&gt; fails. And when &lt;code&gt;pass&lt;/code&gt; is true, &lt;code&gt;message&lt;/code&gt; should return the error message for when &lt;code&gt;expect(x).not.yourMatcher()&lt;/code&gt; fails.</source>
          <target state="translated">匹配器应使用两个键返回一个对象（或对象的Promise）。 &lt;code&gt;pass&lt;/code&gt; 指示是否存在匹配项，并且 &lt;code&gt;message&lt;/code&gt; 提供不带参数的函数，如果失败，该函数将返回错误消息。因此，当 &lt;code&gt;pass&lt;/code&gt; 为false时，当 &lt;code&gt;expect(x).yourMatcher()&lt;/code&gt; 失败时， &lt;code&gt;message&lt;/code&gt; 应返回错误消息。并且当 &lt;code&gt;pass&lt;/code&gt; 为true时，当 &lt;code&gt;expect(x).not.yourMatcher()&lt;/code&gt; 失败时， &lt;code&gt;message&lt;/code&gt; 应返回错误消息。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="da4dc8d5f890d2faf608d0adbf35adbe19f4f359" translate="yes" xml:space="preserve">
          <source>Migrate your existing tests to Jest by following our &lt;a href=&quot;migration-guide&quot;&gt;migration guide&lt;/a&gt;.</source>
          <target state="translated">按照我们的&lt;a href=&quot;migration-guide&quot;&gt;迁移指南，&lt;/a&gt;将您现有的测试迁移到Jest 。</target>
        </trans-unit>
        <trans-unit id="72ad73c448eb21acf03af42f65ee23278b00d994" translate="yes" xml:space="preserve">
          <source>Migrating to Jest</source>
          <target state="translated">迁移到Jest</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="ce71db8c75c86bd1436468173cd4e8202c9dfc44" translate="yes" xml:space="preserve">
          <source>MobX</source>
          <target state="translated">MobX</target>
        </trans-unit>
        <trans-unit id="c599c38fbea82d50bf4f02778d2c491e8ffb771d" translate="yes" xml:space="preserve">
          <source>Mock Functions</source>
          <target state="translated">模拟函数</target>
        </trans-unit>
        <trans-unit id="82d8638dc8b42629227f73d549ec402ed6ea4163" translate="yes" xml:space="preserve">
          <source>Mock Implementations</source>
          <target state="translated">模拟实施</target>
        </trans-unit>
        <trans-unit id="9b383e089384d87712726a0bf225e81090b828eb" translate="yes" xml:space="preserve">
          <source>Mock Modules</source>
          <target state="translated">模拟模块</target>
        </trans-unit>
        <trans-unit id="dd63f222517c40ccfb13bebc813ecec5f6f4c387" translate="yes" xml:space="preserve">
          <source>Mock Names</source>
          <target state="translated">模拟名称</target>
        </trans-unit>
        <trans-unit id="ac64e00246b5445d75034bf18799b106ce0e9c67" translate="yes" xml:space="preserve">
          <source>Mock Return Values</source>
          <target state="translated">模拟返回值</target>
        </trans-unit>
        <trans-unit id="c3f17e11dc3d6f235c6b3173d2753715c699dccd" translate="yes" xml:space="preserve">
          <source>Mock functions</source>
          <target state="translated">模拟功能</target>
        </trans-unit>
        <trans-unit id="16d7de714d1a0043e564d48599b0d8b9aadf62a1" translate="yes" xml:space="preserve">
          <source>Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with &lt;code&gt;new&lt;/code&gt;, and allowing test-time configuration of return values.</source>
          <target state="translated">Mock函数允许您通过擦除函数的实际实现，捕获对该函数的调用（以及在这些调用中传递的参数），捕获用 &lt;code&gt;new&lt;/code&gt; 实例化时的构造函数实例以及测试时间配置来测试代码之间的链接。返回值。</target>
        </trans-unit>
        <trans-unit id="4b436dfff5ba750a15d49f994af79b7a7a9443b9" translate="yes" xml:space="preserve">
          <source>Mock functions are also known as &quot;spies&quot;, because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with &lt;code&gt;jest.fn()&lt;/code&gt;. If no implementation is given, the mock function will return &lt;code&gt;undefined&lt;/code&gt; when invoked.</source>
          <target state="translated">模拟函数也称为&amp;ldquo;间谍&amp;rdquo;，因为它们使您可以监视由其他代码间接调用的函数的行为，而不仅仅是测试输出。您可以使用 &lt;code&gt;jest.fn()&lt;/code&gt; 创建一个模拟函数。如果未提供实现，则模拟函数在调用时将返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4971c2547d472a78138b8f9d6790ae4e902b5810" translate="yes" xml:space="preserve">
          <source>Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.</source>
          <target state="translated">Mock函数在使用功能延续传递风格的代码中也非常有效。以这种风格编写的代码有助于避免使用复杂的存根来重现它们所代表的真实组件的行为,而是在使用它们之前直接将值注入到测试中。</target>
        </trans-unit>
        <trans-unit id="277426c27099c2bbe1295ec0d37f76535f67bd0f" translate="yes" xml:space="preserve">
          <source>Mock functions can also be used to inject test values into your code during a test:</source>
          <target state="translated">Mock函数也可以用来在测试过程中向你的代码注入测试值。</target>
        </trans-unit>
        <trans-unit id="f73fe7175c7ae1faf0611e3806c81041ff30671f" translate="yes" xml:space="preserve">
          <source>Mock native modules using jest.mock</source>
          <target state="translated">使用jest.mock对本地模块进行模拟。</target>
        </trans-unit>
        <trans-unit id="2082c50c18e1f58690e6d14e16bfce63f4a55ed8" translate="yes" xml:space="preserve">
          <source>Mock timers</source>
          <target state="translated">模拟定时器</target>
        </trans-unit>
        <trans-unit id="e88bc2968cce370e084a967f2ffbedcdd7a9ef95" translate="yes" xml:space="preserve">
          <source>Mock using module factory parameter</source>
          <target state="translated">使用模块工厂参数进行模拟</target>
        </trans-unit>
        <trans-unit id="6de59347c925a26a9ab2dde60fa904ce3606c161" translate="yes" xml:space="preserve">
          <source>Mocking CSS Modules</source>
          <target state="translated">嘲笑CSS模块</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">嘲讽模块</target>
        </trans-unit>
        <trans-unit id="8aca8ac03ce33b333f2207760098a53514b273da" translate="yes" xml:space="preserve">
          <source>Mocking Node modules</source>
          <target state="translated">嘲讽Node模块</target>
        </trans-unit>
        <trans-unit id="00105b8c8ed55ecc038db2f39993e7f1167058b7" translate="yes" xml:space="preserve">
          <source>Mocking methods which are not implemented in JSDOM</source>
          <target state="translated">JSDOM中没有实现的嘲讽方法。</target>
        </trans-unit>
        <trans-unit id="7cc9c9d9decea27c9860b6e9a1b4265a0cfe8dc8" translate="yes" xml:space="preserve">
          <source>Mocking non-default class exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8e30f89b00eb10d649edd097cb8226f41cc84f" translate="yes" xml:space="preserve">
          <source>Mocking user modules</source>
          <target state="translated">嘲讽用户模块</target>
        </trans-unit>
        <trans-unit id="632801c55fe3abd89004fbdb78494e86beec94a0" translate="yes" xml:space="preserve">
          <source>Mocks a module with an auto-mocked version when it is being required. &lt;code&gt;factory&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; are optional. For example:</source>
          <target state="translated">在需要时使用自动模拟的版本模拟模块。 &lt;code&gt;factory&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 是可选的。例如：</target>
        </trans-unit>
        <trans-unit id="79f5b225cffab11e22dc40b6f05abef1d33d1561" translate="yes" xml:space="preserve">
          <source>Modes</source>
          <target state="translated">Modes</target>
        </trans-unit>
        <trans-unit id="009c795e3111448694cc3dc957f4b70c8f03b727" translate="yes" xml:space="preserve">
          <source>Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.</source>
          <target state="translated">识别任何JavaScript值的基元类型的模块。输出一个函数,返回一个带有作为参数传递的值的类型的字符串。</target>
        </trans-unit>
        <trans-unit id="6dc759ef821892268cbe7edeb6bcf5abc7a031f8" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;JestWorker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be53179917b8757ad3b5f547e48374b67d70e70" translate="yes" xml:space="preserve">
          <source>Module used for parallelization of tasks. Exports a class &lt;code&gt;Worker&lt;/code&gt; that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.</source>
          <target state="translated">用于任务并行化的模块。导出一个采用Node.js模块路径的类 &lt;code&gt;Worker&lt;/code&gt; ，并让您像调用类方法一样调用模块的导出方法，返回一个Promise，当指定的方法在派生进程中完成其执行时，它会解析。</target>
        </trans-unit>
        <trans-unit id="5123a0149608b8f62ab410c929a918587d7bbf79" translate="yes" xml:space="preserve">
          <source>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</source>
          <target state="translated">被映射到别名的模块,无论是否启用了自动锁定,默认都是解除锁定的。</target>
        </trans-unit>
        <trans-unit id="400881ff44dd95e53d5b70de2d221304a209dd8b" translate="yes" xml:space="preserve">
          <source>Modules that are mocked with &lt;code&gt;jest.mock&lt;/code&gt; are mocked only for the file that calls &lt;code&gt;jest.mock&lt;/code&gt;. Another file that imports the module will get the original implementation even if it runs after the test file that mocks the module.</source>
          <target state="translated">用 &lt;code&gt;jest.mock&lt;/code&gt; 模拟的模块仅针对调用 &lt;code&gt;jest.mock&lt;/code&gt; 的文件模拟。另一个导入模块的文件将获得原始实现，即使该文件在模拟该模块的测试文件之后运行。</target>
        </trans-unit>
        <trans-unit id="bb101179b6d768145f738342dfe298b98e4b70e0" translate="yes" xml:space="preserve">
          <source>More Resources</source>
          <target state="translated">更多资源</target>
        </trans-unit>
        <trans-unit id="2028778347f5faaf24a3510ff5fbd1a91da38244" translate="yes" xml:space="preserve">
          <source>More about serializers API can be found &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format/README.md#serialize&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7a524aa43cd2033804e07ac0567266d5069451" translate="yes" xml:space="preserve">
          <source>More information can be found at &lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/skovhus/jest-codemods&quot;&gt;https://github.com/skovhus/jest-codemods&lt;/a&gt;上找到更多信息。</target>
        </trans-unit>
        <trans-unit id="fde45e0d5214ab7d193c97e2773574aa18d36ca8" translate="yes" xml:space="preserve">
          <source>More information on Node debugging can be found &lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">有关节点调试的更多信息，请参见&lt;a href=&quot;https://nodejs.org/api/debugger.html&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
