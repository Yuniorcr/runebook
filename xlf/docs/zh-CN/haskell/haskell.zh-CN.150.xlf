<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c16541def5ea587ac69bfcc99daad84a959043da" translate="yes" xml:space="preserve">
          <source>Another valid monoid instance of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; It is defined by multiplication and `1` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的另一个有效的monoid实例是 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; 它通过乘法和&amp;ldquo; 1&amp;rdquo;定义为中性元素：</target>
        </trans-unit>
        <trans-unit id="988994d9ba9baaa058f970931250d478f9f37dc1" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">在呼叫站点消除歧义的另一种方法是使用&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;扩展来指定类型。例如：</target>
        </trans-unit>
        <trans-unit id="94b8325dc71ed2de396f171eb6cf1fb19dcc26f3" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">在呼叫站点消除歧义的另一种方法是使用&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;扩展来指定类型。例如：</target>
        </trans-unit>
        <trans-unit id="c9ca1d00f2ba6c9bdc216ddca02e1e03260d4bda" translate="yes" xml:space="preserve">
          <source>Another way to manipulate the scope is to use the &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command, whose syntax is this:</source>
          <target state="translated">操纵范围的另一种方法是使用&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令，其语法为：</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="55329b02c1416b447df48dea23b5ad00b5ee2f0a" translate="yes" xml:space="preserve">
          <source>Any -On where n &amp;gt; 2 is the same as -O2.</source>
          <target state="translated">n&amp;gt; 2的任何-On与-O2相同。</target>
        </trans-unit>
        <trans-unit id="aed001ecb885bcbc05312253a4102a733b569260" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 的所有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 都立即置于关闭状态。</target>
        </trans-unit>
        <trans-unit id="bcbdf5a60ce9ec92529281711b09ee9755999301" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 的所有 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 都立即置于关闭状态。</target>
        </trans-unit>
        <trans-unit id="796335e1acfa34e32b875adacaa05c0d73b8aa9f" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 的所有 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 都立即置于关闭状态。</target>
        </trans-unit>
        <trans-unit id="e91b45192e9b0774cf7aefe77d4d40c0d29cd8a2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;COMPLETE&lt;/code&gt; sets of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">任何 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;COMPLETE&lt;/code&gt; 集</target>
        </trans-unit>
        <trans-unit id="5dfb3cd648c868b374f6e2677fac36fbe2978a3c" translate="yes" xml:space="preserve">
          <source>Any GHC command-line option that is designated as dynamic (see the table in &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;), may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. To unset an option, you can set the reverse option:</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置&lt;/a&gt;任何指定为动态的GHC命令行选项（请参见&lt;a href=&quot;flags#flag-reference&quot;&gt;标志参考中&lt;/a&gt;的表）。要取消设置选项，可以设置反向选项：</target>
        </trans-unit>
        <trans-unit id="6f5306564b28b058683860c0dbb58f6e1ae386c4" translate="yes" xml:space="preserve">
          <source>Any I/O errors encountered while a handle is semi-closed are simply discarded.</source>
          <target state="translated">当一个句柄处于半关闭状态时,遇到的任何I/O错误都会被简单地丢弃。</target>
        </trans-unit>
        <trans-unit id="0c84ffa38e0d42fe1e3c4aafd67e2a273e5029ca" translate="yes" xml:space="preserve">
          <source>Any arbitrary string, no interpretation or parsing is done.</source>
          <target state="translated">任何任意的字符串,不做任何解释或解析。</target>
        </trans-unit>
        <trans-unit id="0452f2ab13ab3b0881a1a304cec756faecd5a100" translate="yes" xml:space="preserve">
          <source>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</source>
          <target state="translated">任何可以用标准 Haskell 98 语法声明的数据类型也可以用 GADT 风格的语法声明。这种选择在很大程度上是风格上的,但是GADT风格的声明在一个重要的方面有所不同:它们以不同的方式对待数据构造函数的类约束。具体来说,如果给构造函数一个类型类上下文,那么这个上下文是通过模式匹配来提供的。例如</target>
        </trans-unit>
        <trans-unit id="7d3011ab0c7b5aa4a9a177dbc0ce024f6e055225" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">GHCi命令行界面会捕获并打印在语句的评估或执行期间引发的任何异常（有关异常的更多信息，请参见库文档中的&lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="d671ba93c9259d42fd317ba91ce67c391a4d8b7f" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">GHCi命令行界面会捕获并打印在语句的评估或执行过程中引发的任何异常（有关异常的更多信息，请参见库文档中的&lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="f719b6e6c5e275dbf8e07842f21a8f48fe1636e8" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">GHCi命令行界面会捕获并打印在语句的评估或执行过程中引发的任何异常（有关异常的更多信息，请参见库文档中的&lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="fb34342e0a6715040492745b6bae6bc125156350" translate="yes" xml:space="preserve">
          <source>Any expression that has both &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances may be attached to a top-level value binding using an &lt;code&gt;ANN&lt;/code&gt; pragma. In particular, this means you can use &lt;code&gt;ANN&lt;/code&gt; to annotate data constructors (e.g. &lt;code&gt;Just&lt;/code&gt;) as well as normal values (e.g. &lt;code&gt;take&lt;/code&gt;). By way of example, to annotate the function &lt;code&gt;foo&lt;/code&gt; with the annotation &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; you would do this:</source>
          <target state="translated">具有 &lt;code&gt;Typeable&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 实例的任何表达式都可以使用 &lt;code&gt;ANN&lt;/code&gt; 杂注附加到顶级值绑定。特别是，这意味着您可以使用 &lt;code&gt;ANN&lt;/code&gt; 注释数据构造函数（例如 &lt;code&gt;Just&lt;/code&gt; ）以及普通值（例如 &lt;code&gt;take&lt;/code&gt; ）。举例来说，用注解 &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; 来注释函数 &lt;code&gt;foo&lt;/code&gt; ，您可以这样做：</target>
        </trans-unit>
        <trans-unit id="01212113a76fa0770e6b80bde8974e88d8560b27" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">可以使用&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension中&lt;/a&gt;定义的 &lt;code&gt;Extension&lt;/code&gt; 类型中的任何扩展。如果不支持任何请求的扩展名，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="b4b940cc0f6bd9befa4dc2cd571bce369cc78d6f" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">可以使用&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension中&lt;/a&gt;定义的 &lt;code&gt;Extension&lt;/code&gt; 类型中的任何扩展。如果不支持任何请求的扩展名，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="6fe084339688200f9007406f9182c723678a61f9" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">可以使用&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension中&lt;/a&gt;定义的 &lt;code&gt;Extension&lt;/code&gt; 类型中的任何扩展。如果不支持任何请求的扩展名，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="45294fce8a408e067f71fcddc66e44fa9a3aa925" translate="yes" xml:space="preserve">
          <source>Any field width is followed optionally by a precision:</source>
          <target state="translated">任何字段的宽度后面都有一个精度。</target>
        </trans-unit>
        <trans-unit id="ca99cdb1b6224c8f2acca56e49dc80e277ef33e9" translate="yes" xml:space="preserve">
          <source>Any flags are followed optionally by a field width:</source>
          <target state="translated">任何标志后面都有一个可选的字段宽度。</target>
        </trans-unit>
        <trans-unit id="fe6292886945b8678502b2eed862908e6596bec8" translate="yes" xml:space="preserve">
          <source>Any flags not recognized by runghc are automatically passed to GHC. If a flag is recognized by both runghc and GHC but you want to pass it to GHC then you can place it after a &lt;code&gt;--&lt;/code&gt; separator. Flags after the separator are treated as GHC only flags. Alternatively you can use the runghc option &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass any flag or argument directly to GHC.</source>
          <target state="translated">runghc无法识别的所有标志都会自动传递到GHC。如果标志被runghc和GHC识别，但您希望将其传递给GHC，则可以将其放在 &lt;code&gt;--&lt;/code&gt; 分隔符之后。分隔符之后的标志被视为仅GHC标志。或者，您可以使用runghc选项 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 将任何标志或参数直接传递给GHC。</target>
        </trans-unit>
        <trans-unit id="d3a24acb0ed73105a63c6aa8b83c5ce57f71ebe7" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; can be made into an instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; by defining &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过定义 &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt; ，可以将 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 的任何实例制作为 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="c46287c62f0868214d45f152801a23db51bd59d4" translate="yes" xml:space="preserve">
          <source>Any instance should be subject to the following laws:</source>
          <target state="translated">任何实例都应遵守以下法律。</target>
        </trans-unit>
        <trans-unit id="b4adffce07a1e96f7b4aa9f3335793d174570cf6" translate="yes" xml:space="preserve">
          <source>Any modifiers found.</source>
          <target state="translated">任何修改器发现。</target>
        </trans-unit>
        <trans-unit id="5cecd2c65d9c46eca630a92c4797e911edc247d7" translate="yes" xml:space="preserve">
          <source>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a &lt;code&gt;Main&lt;/code&gt; module, the program will also be linked into an executable.</source>
          <target state="translated">可以指定任意数量的源文件名或模块名；GHC将通过遵循这些初始模块的导入来找出程序中的所有模块。然后它将尝试编译每个过时的模块，最后，如果有 &lt;code&gt;Main&lt;/code&gt; 模块，则该程序还将链接到一个可执行文件中。</target>
        </trans-unit>
        <trans-unit id="8a7ee0a6d4ed7c475e886db91c9ca4af5ab7c3c0" translate="yes" xml:space="preserve">
          <source>Any of the command-line options described in the rest of this chapter can be used with &lt;code&gt;--make&lt;/code&gt;, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you&amp;rsquo;ll need to use an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt;).</source>
          <target state="translated">本章其余部分描述的任何命令行选项都可以与 &lt;code&gt;--make&lt;/code&gt; 一起使用，但是请注意，您在命令行上给出的任何选项都将应用于所有编译的源文件，因此如果您希望应用任何选项仅限于单个源文件，您将需要使用 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;#source-file-options&quot;&gt;源文件中的命令行选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4fcac47fb48917b29ef16b080f9169cd49dcd808" translate="yes" xml:space="preserve">
          <source>Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt;. A semi-closed handle becomes closed:</source>
          <target state="translated">由于句柄已关闭而失败的任何操作，如果句柄是半封闭的，则也会失败。唯一的例外是 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 。半封闭手柄将变为封闭状态：</target>
        </trans-unit>
        <trans-unit id="74cf8930fe96c667f6ee4ecd6012b01ea066396e" translate="yes" xml:space="preserve">
          <source>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn&amp;rsquo;t actually import the same orphans.</source>
          <target state="translated">即使从最终实现模块实际上未导入相同的孤儿的情况下，也无条件地考虑了从签名的导入而引入范围的任何孤儿实例。</target>
        </trans-unit>
        <trans-unit id="2fbfab23f62ec3e48e80e1e5422619cb69668f7f" translate="yes" xml:space="preserve">
          <source>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">谓词不匹配的其他任何异常都会重新引发，并可能被封闭的 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 等捕获。</target>
        </trans-unit>
        <trans-unit id="a712b26d1cb0416ca0ddd0555d9306a2c267be27" translate="yes" xml:space="preserve">
          <source>Any precision is followed optionally for Integral types by a width modifier; the only use of this modifier being to set the implicit size of the operand for conversion of a negative operand to unsigned:</source>
          <target state="translated">对于Integral类型,任何精度后面都有一个宽度修饰符;这个修饰符的唯一用途是设置负操作数转换为无符号操作数时操作数的隐含大小。</target>
        </trans-unit>
        <trans-unit id="d8c91f9f9f6e75c41b02098e931d3439ddcf440f" translate="yes" xml:space="preserve">
          <source>Any real interval contains a unique simplest rational; in particular, note that &lt;code&gt;0/1&lt;/code&gt; is the simplest rational of all.</source>
          <target state="translated">任何实际区间都包含唯一的最简单的有理数；特别注意的是 &lt;code&gt;0/1&lt;/code&gt; 是最简单的所有合理的。</target>
        </trans-unit>
        <trans-unit id="bd6fa11933cdfcdc743d92e3ae1b1b26d19d69a2" translate="yes" xml:space="preserve">
          <source>Any single-constructor data is eligible for unpacking; for example</source>
          <target state="translated">任何单一构造体数据都有资格进行解包,例如</target>
        </trans-unit>
        <trans-unit id="a18603a852f4e4b843d8b21962152ae0dc60595e" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 在文件描述符上阻塞的任何线程都将通过引发IO异常来解除阻塞。</target>
        </trans-unit>
        <trans-unit id="769148ddf54673e79970f08b70786bcc3aab11e0" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 在文件描述符上阻塞的任何线程都将通过引发IO异常来解除阻塞。</target>
        </trans-unit>
        <trans-unit id="87c36f7b926ac2fbec6f667eb5439c00c637c3ef" translate="yes" xml:space="preserve">
          <source>Any type that you wish to throw or catch as an exception must be an instance of the &lt;code&gt;Exception&lt;/code&gt; class. The simplest case is a new exception type directly below the root:</source>
          <target state="translated">您希望引发或捕获的任何类型的异常都必须是 &lt;code&gt;Exception&lt;/code&gt; 类的实例。最简单的情况是在根目录正下方的新异常类型：</target>
        </trans-unit>
        <trans-unit id="b1bd8e562d1fefda868c7d1ff0cda571db4a02aa" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩中的任何变量都是绑定的事件，但是在模式中&amp;ldquo;左&amp;rdquo;绑定的变量在范围内。例如，此功能允许在另一个参数的视图中使用函数的一个参数。例如，可以使用视图模式来编写来自&lt;a href=&quot;#pattern-guards&quot;&gt;Pattern &lt;/a&gt; &lt;code&gt;clunky&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="5be3f3400c369b3d8251c242743fa27338956055" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">&amp;ldquo; exp&amp;rdquo;中的任何变量都是绑定的事件，但是在模式中&amp;ldquo;左侧&amp;rdquo;绑定的变量在范围内。例如，此功能允许在另一个参数的视图中使用函数的一个参数。例如，可以使用视图模式来编写来自&lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;模式卫士的&lt;/a&gt; &lt;code&gt;clunky&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="b0f483f182aa56813d1000ce4df4790bcbe905f1" translate="yes" xml:space="preserve">
          <source>Any whitespace which appears outside of either of the quoting and escaping mechanisms, is interpreted as having been added by this special concatenation process to designate where the boundaries are between the original, un-concatenated list of strings. These added whitespace characters are removed from the output.</source>
          <target state="translated">任何出现在引号和转义机制之外的空白字符,都会被解释为是由这个特殊的连接过程添加的,用于指定原始的、未连接的字符串列表之间的边界。这些添加的空白字符会从输出中删除。</target>
        </trans-unit>
        <trans-unit id="86fba8724925018bcafcede041fc92c898e3eb9b" translate="yes" xml:space="preserve">
          <source>AnyclassStrategy</source>
          <target state="translated">AnyclassStrategy</target>
        </trans-unit>
        <trans-unit id="2d219c6ebc1efaae092effbbdcf3fa6d485c6699" translate="yes" xml:space="preserve">
          <source>Anything else throws an exception:</source>
          <target state="translated">其他任何东西都会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="036d8f7bd31769453184842860e1d5ca8c639fff" translate="yes" xml:space="preserve">
          <source>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints.</source>
          <target state="translated">凡是已经有效的约束,而没有标志的:饱和应用于类型类、隐式参数和平等约束。</target>
        </trans-unit>
        <trans-unit id="ad26f77e74f38dbef3399b317d10c13e53d32aa2" translate="yes" xml:space="preserve">
          <source>Anything whose form is not yet known, but the user has declared to have kind &lt;code&gt;Constraint&lt;/code&gt; (for which they need to import it from &lt;code&gt;Data.Kind&lt;/code&gt;). So for example &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; is allowed, as well as examples involving type families:</source>
          <target state="translated">尚不知道其形式，但用户已声明具有种类 &lt;code&gt;Constraint&lt;/code&gt; 的任何内容（需要从 &lt;code&gt;Data.Kind&lt;/code&gt; 导入）。例如， &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; ，以及涉及类型族的示例：</target>
        </trans-unit>
        <trans-unit id="b920fb3adf34d73af2cb7b5c93d8efbc94cd36f7" translate="yes" xml:space="preserve">
          <source>Ap</source>
          <target state="translated">Ap</target>
        </trans-unit>
        <trans-unit id="53d21ca24e640bdf8e7b761f501faaae7e4e72fb" translate="yes" xml:space="preserve">
          <source>Apart from removing intermediate data-structures, encodings can be optimized further by fine-tuning their execution parameters using the functions in &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; and their &quot;inner loops&quot; using the functions in &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;.</source>
          <target state="translated">除了删除中间数据结构，编码可以进一步通过微调优化使用的功能的它们的执行参数&lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;使用功能和他们的&amp;ldquo;内环&amp;rdquo; &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14dc219def5159ae2ab7cfd4d71881c1c3903e70" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;code&gt;:{ ... :}&lt;/code&gt; syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by &lt;code&gt;:set +m&lt;/code&gt;, &lt;code&gt;:set +m&lt;/code&gt; in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</source>
          <target state="translated">除了上述用于多行输入的 &lt;code&gt;:{ ... :}&lt;/code&gt; 语法外，GHCi还具有多行模式，该模式由 &lt;code&gt;:set +m&lt;/code&gt; ， &lt;code&gt;:set +m&lt;/code&gt; 启用，在该模式下，GHCi在当前语句未完成时自动检测并允许要添加的其他行。多行输入以空行终止。例如：</target>
        </trans-unit>
        <trans-unit id="fc4a695f02a8a53a129dcb9ace91e91ee1e7feb9" translate="yes" xml:space="preserve">
          <source>App</source>
          <target state="translated">App</target>
        </trans-unit>
        <trans-unit id="c607b075485b6dc8c400c818769a9c892ea0ffc4" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="f664580544f7f0aa77f101d16e0efbbe807fa6e5" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="e26661dc8c698ec289349a6aeecab4d0a5e5ec82" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="345b0c25bf20f673449b84d7d686b5c70bebf7c2" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="4ebc23e4c1b65a48a70d373d483fafb1ccae8ba3" translate="yes" xml:space="preserve">
          <source>Append two lists, i.e.,</source>
          <target state="translated">附加两个名单,即:</target>
        </trans-unit>
        <trans-unit id="3e0bf0178a1d360f27255c9a7f025fc03359dcd5" translate="yes" xml:space="preserve">
          <source>AppendHandle</source>
          <target state="translated">AppendHandle</target>
        </trans-unit>
        <trans-unit id="374c012a038cea614a313e941a993048c6cf1210" translate="yes" xml:space="preserve">
          <source>AppendMode</source>
          <target state="translated">AppendMode</target>
        </trans-unit>
        <trans-unit id="3916a3175dfaa3fd999b22f53277fe454f6b7b38" translate="yes" xml:space="preserve">
          <source>AppendOnWrite</source>
          <target state="translated">AppendOnWrite</target>
        </trans-unit>
        <trans-unit id="dbe098d861d9a244dfef0444bcf8ab0f87546a7d" translate="yes" xml:space="preserve">
          <source>AppendSymbol</source>
          <target state="translated">AppendSymbol</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="d311231658a1b3353cd77d4859248f1e061c4cc1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="43dbefc4fd00eee5d8e84d6de5dadb9d229d56a1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="f58752dc50f3a1aa349659b655c647ebed7f8f30" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="4bf898ba305639dbde7f1d71fe68cf723d6796d1" translate="yes" xml:space="preserve">
          <source>Application-specific customizations to the user interface.</source>
          <target state="translated">对用户界面进行特定应用的定制。</target>
        </trans-unit>
        <trans-unit id="0b8a1b21fc212c72c3e7976ca547d1f598c5e314" translate="yes" xml:space="preserve">
          <source>Applicative</source>
          <target state="translated">Applicative</target>
        </trans-unit>
        <trans-unit id="c42b346f9e6450034a0b493919801528c343e948" translate="yes" xml:space="preserve">
          <source>Applicative actions</source>
          <target state="translated">适用行动</target>
        </trans-unit>
        <trans-unit id="98c9a7602c91954ae00f88c84bb4db90472de9d3" translate="yes" xml:space="preserve">
          <source>Applicative do-notation desugaring preserves the original semantics, provided that the &lt;code&gt;Applicative&lt;/code&gt; instance satisfies &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; and &lt;code&gt;pure = return&lt;/code&gt; (these are true of all the common monadic types). Thus, you can normally turn on &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; without fear of breaking your program. There is one pitfall to watch out for; see &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;Things to watch out for&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Applicative&lt;/code&gt; 实例满足 &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; 和 &lt;code&gt;pure = return&lt;/code&gt; （在所有常见单子类型中都是这样），则应用符号表示法将保留原始语义。因此，您通常可以打开&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; ,&lt;/a&gt;而不必担心会破坏程序。有一个陷阱需要提防。看&lt;a href=&quot;#applicative-do-pitfall&quot;&gt;提防的事情&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3040a310341680e034eec3985152bc5a9e486ec2" translate="yes" xml:space="preserve">
          <source>Applicative functor formed by adding pure computations to a given applicative functor.</source>
          <target state="translated">在给定的应用型漏斗中加入纯计算而形成的应用型漏斗。</target>
        </trans-unit>
        <trans-unit id="65f268e6aa6cb1e22480a2a575f39395d4e90f10" translate="yes" xml:space="preserve">
          <source>Applicative functors</source>
          <target state="translated">应用型漏斗</target>
        </trans-unit>
        <trans-unit id="e1507c25dc6a64376527010df0e4de108198887a" translate="yes" xml:space="preserve">
          <source>Applicative general combining function</source>
          <target state="translated">适用的一般组合功能</target>
        </trans-unit>
        <trans-unit id="ba83691e2c1dcc5de53cc3e4b25ca28fcf3f9a3b" translate="yes" xml:space="preserve">
          <source>Applicative merge tactic types</source>
          <target state="translated">适用的合并战术类型</target>
        </trans-unit>
        <trans-unit id="3bb211f1db0886c20dbcbe3aec098bfa4c51a870" translate="yes" xml:space="preserve">
          <source>ApplicativeDo</source>
          <target state="translated">ApplicativeDo</target>
        </trans-unit>
        <trans-unit id="a3e4a569ead07c8bc4d8de675cfd615c69dad24a" translate="yes" xml:space="preserve">
          <source>Applied</source>
          <target state="translated">Applied</target>
        </trans-unit>
        <trans-unit id="919e6fc623e0dc282b30825056bd5dda3c4e6c46" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="637b1e1d5c8efd54c8949c6a43abe4555350a327" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="9e82bc67b89a4b9e5b1ef1666971641ffcc4ec35" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="bbb6d3ed7b10d0b6c91c1b6b6102c1501910cf5b" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="b1b160142b2aab409abf2571e6a42ee896b8231e" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表， &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定列表中的所有元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="1bb3df1dee5942308d7549a4ff4e6623460c1a98" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表时， &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 决定列表中的任何元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的； &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="649319403532f404d1828c385726fa18cf17318d" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定列表中的所有元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="96fd46ee7a807ee87c60e5d0b9ca946dc3e911cb" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表时， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 决定列表中的任何元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的； &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="be0613a1194858373863a5914ef44b595dda15fa" translate="yes" xml:space="preserve">
          <source>Applies a type to a function type. Returns: &lt;code&gt;Just u&lt;/code&gt; if the first argument represents a function of type &lt;code&gt;t -&amp;gt; u&lt;/code&gt; and the second argument represents a function of type &lt;code&gt;t&lt;/code&gt;. Otherwise, returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">将类型应用于函数类型。返回： &lt;code&gt;Just u&lt;/code&gt; 如果第一个参数表示的类型的函数 &lt;code&gt;t -&amp;gt; u&lt;/code&gt; ，第二个参数代表的类型的函数 &lt;code&gt;t&lt;/code&gt; 。否则，返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee4a02d62b3b562a9c374f2e31932813920bd3d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;(+1)&lt;/code&gt; to a list, a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;(+1)&lt;/code&gt; 应用于一个列表，一个 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7560eee7a783d22baf2bd6d4444f64f9c9a496fc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; to the second element of a pair:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; 适用于一对的第二个元素：</target>
        </trans-unit>
        <trans-unit id="11040b63f3921092eab408bc2b85dc0c41f9e594" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 应用于 &lt;code&gt;Maybe Int&lt;/code&gt; 。如果我们有 &lt;code&gt;Just n&lt;/code&gt; ，我们想显示底层的 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 。但是，如果我们有 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回空字符串，而不是（例如）&amp;ldquo; Nothing&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="615a1ddaf7551b2a4174858609db8c4f030df5a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 应用于 &lt;code&gt;Maybe Int&lt;/code&gt; 。如果我们有 &lt;code&gt;Just n&lt;/code&gt; ，我们想显示底层的 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 。但是，如果我们有 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回空字符串，而不是（例如）&amp;ldquo; Nothing&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="edd6c71ec52ff9bccf29d84188bba0b21ce69446" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上花 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6b9c8416c76cb38545167e06e3308ec9286dc30" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，请在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ad84cd5aa8118e1f8b36881b3b884a1d00f4857" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 应用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9745cca7883787ea648c32cd3f515d25f4cb991e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">适用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; ，如果布尔是真实的。</target>
        </trans-unit>
        <trans-unit id="96e48ba2760c93e4e34b159d49c1dbbc56799681" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9854504f7be6e574e7bfe679f44b4ee0c6be89cc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上花 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f46147f015f62456e6f042fc1fdd0a4e456ff05" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，请在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d053cfa4369b1863e68c118fa964a1a17e42f125" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 应用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21bdb9c521d1c7d41257920a997db5a1c432b4d7" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">适用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; ，如果布尔是真实的。</target>
        </trans-unit>
        <trans-unit id="83bd5f5c6340c2876e03bdf5c78f42f0045fcd17" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00536f11c69e40c7baa6a53f5c52fe55c8806e5" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;f&lt;/code&gt;-actions in the reverse order.</source>
          <target state="translated">应用 &lt;code&gt;f&lt;/code&gt; 以相反的顺序-actions。</target>
        </trans-unit>
        <trans-unit id="a7fd738556716f25c4a33b181a4727d226b4c919" translate="yes" xml:space="preserve">
          <source>Apply a function to a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; token. When manually applying a function to &lt;code&gt;realWorld#&lt;/code&gt;, it is necessary to use &lt;code&gt;NOINLINE&lt;/code&gt; to prevent semantically undesirable floating. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; is inlined, but only very late in compilation after all floating is complete.</source>
          <target state="translated">将功能应用于 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 令牌。将函数手动应用于 &lt;code&gt;realWorld#&lt;/code&gt; 时，必须使用 &lt;code&gt;NOINLINE&lt;/code&gt; 来防止语义上不希望的浮动。内联 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; ，但是在完成所有浮动之后才在编译的后期进行。</target>
        </trans-unit>
        <trans-unit id="15923e60f19aafe01135e2792144867deb99400e" translate="yes" xml:space="preserve">
          <source>Apply a function to the first element of an optional pair.</source>
          <target state="translated">将一个函数应用于一个可选对的第一个元素。</target>
        </trans-unit>
        <trans-unit id="a5aee8e5a78690a96a71ac571dd01657b03993bb" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the continuation passed to a CPS computation.</source>
          <target state="translated">应用一个函数来转换传递给CPS计算的延续。</target>
        </trans-unit>
        <trans-unit id="35e3f909c25395866110729633dad59aecf7af3c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation.</source>
          <target state="translated">应用一个函数来变换一个继续传递计算的结果。</target>
        </trans-unit>
        <trans-unit id="4ff89ef704740fc048b9ba990998fdecd8670f9c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来转换连续传递计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="d4993fc434940195f4b64a80d66593316a376d43" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来转换连续传递计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="b51211dea86c79bd6e381cda63ad155fa030e446" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation.</source>
          <target state="translated">应用函数来变换选择计算的结果。</target>
        </trans-unit>
        <trans-unit id="119d0767fcb8340ed73d84a60d5eb57b7349f3e5" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来变换选择计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="90c1bc3308702f2e877e752823a6f576e30aa537" translate="yes" xml:space="preserve">
          <source>Apply a transformation to the other computation.</source>
          <target state="translated">对另一个计算进行变换。</target>
        </trans-unit>
        <trans-unit id="6b6f2a899229fc5c6cb94a1a620e95652b86a4f6" translate="yes" xml:space="preserve">
          <source>Apply one equality to another, respectively</source>
          <target state="translated">分别将一个平等应用于另一个平等</target>
        </trans-unit>
        <trans-unit id="3db4052527debed305ed7ac76b5af4b0792839fc" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">当运算符的第二个参数比较懒惰时，将 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于无限结构时终止（在这种情况下，从不使用初始累加器，因此可以将其保留为 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; ，但是 &lt;code&gt;[]&lt;/code&gt; 更清楚）：</target>
        </trans-unit>
        <trans-unit id="afeb81f9b8e9e1466027165d488925a56b444f58" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">当运算符的第二个参数比较懒惰时，将 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于无限结构时终止（在这种情况下，从不使用初始累加器，因此可以将其保留为 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; ，但是 &lt;code&gt;[]&lt;/code&gt; 更清楚）：</target>
        </trans-unit>
        <trans-unit id="5136f3e3a8f7d04f3c546ad5ab418d3fbab0caa7" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">当运算符的第二个参数比较懒惰时，将 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于无限结构时终止（在这种情况下，从不使用初始累加器，因此可以将其保留为 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; ，但是 &lt;code&gt;[]&lt;/code&gt; 更清楚）：</target>
        </trans-unit>
        <trans-unit id="3915aaeccbb6370f41a8ba795caff78447316b72" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;mask&lt;/code&gt; to an exception handler</source>
          <target state="translated">将 &lt;code&gt;mask&lt;/code&gt; 应用于异常处理程序</target>
        </trans-unit>
        <trans-unit id="7940fbb624b272a2fc9b14574cab25dadfa00758" translate="yes" xml:space="preserve">
          <source>Applying functions of dynamic type</source>
          <target state="translated">应用动态类型的函数</target>
        </trans-unit>
        <trans-unit id="753097d2ed6ee6ae143b40cc67535412f863e165" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度整数。与固定大小的整数类型（例如 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )相比， &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型表示整数的整个无限范围。</target>
        </trans-unit>
        <trans-unit id="cea6baf5bc9c5798e19b6c91c89563fb63949b9d" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度整数。与固定大小的整数类型（例如 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )相比， &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型表示整数的整个无限范围。</target>
        </trans-unit>
        <trans-unit id="8d3c6b448377adca963a9a043ce17ad5b59ebdc9" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度整数。与固定大小的整数类型（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )相比， &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型表示整数的整个无限范围。</target>
        </trans-unit>
        <trans-unit id="78c0f892889dcc2a8ebf1f6c5901067143d19b65" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度整数。与固定大小的整数类型（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )相比， &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型表示整数的整个无限范围。</target>
        </trans-unit>
        <trans-unit id="c4918ddd1f06d48d8245e6c5a8235cc03f138f53" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度整数。与固定大小的整数类型（例如 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )相比， &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型表示整数的整个无限范围。</target>
        </trans-unit>
        <trans-unit id="48a6b0961bc685e7241bda505e193149b1b6e1e7" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">任意精度有理数，表示为两个 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的比率。可以使用 &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 运算符来构造有理数。</target>
        </trans-unit>
        <trans-unit id="2f570f682fb6c172cde8b33c6dce79b95de7ed61" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">任意精度有理数，表示为两个 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的比率。可以使用 &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 运算符来构造有理数。</target>
        </trans-unit>
        <trans-unit id="29a35ec82756568480404c0269911333a81119f5" translate="yes" xml:space="preserve">
          <source>Arbitrary-sized tuples</source>
          <target state="translated">任意大小的元组</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="9932a4cb0405a0729daea0726dad5bca21f86edb" translate="yes" xml:space="preserve">
          <source>ArgDescr</source>
          <target state="translated">ArgDescr</target>
        </trans-unit>
        <trans-unit id="ffc2c4751c406dfe729e68e12fca79cd5235bbd5" translate="yes" xml:space="preserve">
          <source>ArgMax</source>
          <target state="translated">ArgMax</target>
        </trans-unit>
        <trans-unit id="ff6dd3f82d1ef3b64409b1d48173a3489bd3a0de" translate="yes" xml:space="preserve">
          <source>ArgMin</source>
          <target state="translated">ArgMin</target>
        </trans-unit>
        <trans-unit id="33b3818348e9a7abc5ad4f8c9119835de808618f" translate="yes" xml:space="preserve">
          <source>ArgMin, ArgMax</source>
          <target state="translated">ArgMin,ArgMax</target>
        </trans-unit>
        <trans-unit id="24257e1e26a78c97f1a7d50aeb70e00749ebb9e9" translate="yes" xml:space="preserve">
          <source>ArgOrder</source>
          <target state="translated">ArgOrder</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="6e753ec7f8245ae5fdc7a8b075baae341353e5ea" translate="yes" xml:space="preserve">
          <source>ArgumentLimit</source>
          <target state="translated">ArgumentLimit</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="41c35f0b16b9faa92a29f4ed3edbe5f0ea7a74af" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the executable</source>
          <target state="translated">要传递给可执行文件的参数</target>
        </trans-unit>
        <trans-unit id="e1cbb100861b9948d58a53b976c856c97d398433" translate="yes" xml:space="preserve">
          <source>Arguments which look like &lt;code&gt;@foo&lt;/code&gt; will be replaced with the contents of file &lt;code&gt;foo&lt;/code&gt;. A gcc-like syntax for response files arguments is expected. This must re-constitute the argument list by doing an inverse of the escaping mechanism done by the calling-program side.</source>
          <target state="translated">看起来像 &lt;code&gt;@foo&lt;/code&gt; 的参数将替换为 &lt;code&gt;foo&lt;/code&gt; 文件的内容。响应文件参数应采用类似gcc的语法。这必须通过执行与调用程序端相反的转义机制来重新构造参数列表。</target>
        </trans-unit>
        <trans-unit id="c4a70a3f41d906934cb39fa13410a07666b58dc9" translate="yes" xml:space="preserve">
          <source>ArithException</source>
          <target state="translated">ArithException</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="bb08cbe0a6134017a6f7cf472ab8010209d07a2f" translate="yes" xml:space="preserve">
          <source>Arithmetic exceptions.</source>
          <target state="translated">算术异常。</target>
        </trans-unit>
        <trans-unit id="a9d7caa767383fc4926cd95d59576ba33ee0a3dc" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">不会检查 &lt;code&gt;Int&lt;/code&gt; 上的算术是否存在 &lt;code&gt;Int&lt;/code&gt; 溢出，因此对 &lt;code&gt;Int&lt;/code&gt; 的所有运算都以&lt;sup&gt;2⟨n⟩&lt;/sup&gt;进行模&lt;sup&gt;运算&lt;/sup&gt;，其中⟨n⟩是 &lt;code&gt;Int&lt;/code&gt; 类型的位大小。&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="202699f8498d7982cc53b20732251548a363465a" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflowoverflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">算术上的 &lt;code&gt;Int&lt;/code&gt; 是选中的overflowoverflow &lt;code&gt;Int&lt;/code&gt; ，等等所有的操作 &lt;code&gt;Int&lt;/code&gt; 发生模2 &lt;sup&gt;⟨n⟩&lt;/sup&gt;其中⟨n⟩是在中位大小 &lt;code&gt;Int&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算术运算</target>
        </trans-unit>
        <trans-unit id="3fecae258b41570e5190fa75b10edfa2c67f433e" translate="yes" xml:space="preserve">
          <source>Arithmetic shift-right operation</source>
          <target state="translated">算术右移操作</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a070934e81973445b297f3e432a70f43cd9eb647" translate="yes" xml:space="preserve">
          <source>Array classes</source>
          <target state="translated">阵列类</target>
        </trans-unit>
        <trans-unit id="1f72bc74b6f28918205f9e6e811785a34a99cae8" translate="yes" xml:space="preserve">
          <source>Array construction</source>
          <target state="translated">阵列结构</target>
        </trans-unit>
        <trans-unit id="b9be2aa72950b9c68024a84de0f4b74e90523e2c" translate="yes" xml:space="preserve">
          <source>Array in which to place the values</source>
          <target state="translated">放置数值的阵列</target>
        </trans-unit>
        <trans-unit id="35664ac437e521792c86de2c050b2b9616ad2f9b" translate="yes" xml:space="preserve">
          <source>Array to resize</source>
          <target state="translated">要调整大小的阵列</target>
        </trans-unit>
        <trans-unit id="55f55ab0f2f0b52c9ee209db3b03b78882aa29c9" translate="yes" xml:space="preserve">
          <source>Array to write from</source>
          <target state="translated">阵列写入</target>
        </trans-unit>
        <trans-unit id="2dfdceb734024f39f314a3c0b8391586228fb921" translate="yes" xml:space="preserve">
          <source>Array#</source>
          <target state="translated">Array#</target>
        </trans-unit>
        <trans-unit id="898837d96f33bff85a3be5478164cfc6afd0eadc" translate="yes" xml:space="preserve">
          <source>ArrayArray#</source>
          <target state="translated">ArrayArray#</target>
        </trans-unit>
        <trans-unit id="592acb75a6da231d0a2a2173d588c93486db96f4" translate="yes" xml:space="preserve">
          <source>ArrayException</source>
          <target state="translated">ArrayException</target>
        </trans-unit>
        <trans-unit id="93c35e8fd0d3491f05295cbaa9fc1ec445fdc9e3" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;Storable&lt;/code&gt; things.</source>
          <target state="translated">可 &lt;code&gt;Storable&lt;/code&gt; 事物的数组。</target>
        </trans-unit>
        <trans-unit id="6f11fdf73ec1f7aec4ea144e79eb109ff942b709" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements</source>
          <target state="translated">带有未装箱元素的数组</target>
        </trans-unit>
        <trans-unit id="9d7392dc546e184e07e6daaacd277a5d43a5c7da" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">具有未装箱元素的数组。的实例 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 提供用于 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 与某些元素类型（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ，等;见 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 类的完整列表）。</target>
        </trans-unit>
        <trans-unit id="641e7befb70fe85093114258ec0852dc24a766bf" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">具有未装箱元素的数组。的实例 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 提供用于 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 与某些元素类型（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ，等;见 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 类的完整列表）。</target>
        </trans-unit>
        <trans-unit id="fa4ab058d3a73e22b09d2ccc980d2abebbfa6f13" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">具有未装箱元素的数组。的实例 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 提供用于 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 与某些元素类型（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ，等;见 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 类的完整列表）。</target>
        </trans-unit>
        <trans-unit id="3a4758c3cc8dac2d76026d0733816741f9b21d43" translate="yes" xml:space="preserve">
          <source>Arrow</source>
          <target state="translated">Arrow</target>
        </trans-unit>
        <trans-unit id="4a7111dcaf1b4237c13ed045e218a14996e9fbe6" translate="yes" xml:space="preserve">
          <source>Arrow application</source>
          <target state="translated">箭头应用</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">方向键</target>
        </trans-unit>
        <trans-unit id="a6216e2bed8396214323ababdee0bc0041b0726d" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">箭头符号（请参阅&lt;a href=&quot;#arrow-notation&quot;&gt;箭头符号&lt;/a&gt;）使用范围内的任何 &lt;code&gt;arr&lt;/code&gt; ， &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;app&lt;/code&gt; ， &lt;code&gt;(|||)&lt;/code&gt; 和 &lt;code&gt;loop&lt;/code&gt; 函数。但是与其他构造不同，这些函数的类型必须与Prelude类型非常紧密地匹配。细节在不断变化。如果要使用此功能，请询问！</target>
        </trans-unit>
        <trans-unit id="55386b3ae61f88d0f525742d799552dd74e88c99" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;arrows#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">箭头符号（请参阅&lt;a href=&quot;arrows#arrow-notation&quot;&gt;箭头符号&lt;/a&gt;）使用范围内的任何 &lt;code&gt;arr&lt;/code&gt; ， &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;app&lt;/code&gt; ， &lt;code&gt;(|||)&lt;/code&gt; 和 &lt;code&gt;loop&lt;/code&gt; 函数。但是与其他构造不同，这些函数的类型必须与Prelude类型非常紧密地匹配。细节在不断变化；如果要使用此功能，请询问！</target>
        </trans-unit>
        <trans-unit id="8f1f0db1f62fbb0e92d1c7e980a5aefb808bd919" translate="yes" xml:space="preserve">
          <source>ArrowApply</source>
          <target state="translated">ArrowApply</target>
        </trans-unit>
        <trans-unit id="3c11beff8b02b8f9cbaa16ca3ab20327c65da1ba" translate="yes" xml:space="preserve">
          <source>ArrowChoice</source>
          <target state="translated">ArrowChoice</target>
        </trans-unit>
        <trans-unit id="47595fe84f8dd1e9405b5200e89860454330a77e" translate="yes" xml:space="preserve">
          <source>ArrowLoop</source>
          <target state="translated">ArrowLoop</target>
        </trans-unit>
        <trans-unit id="e45164f39602039a081dfdb414a58cdcb90fce01" translate="yes" xml:space="preserve">
          <source>ArrowMonad</source>
          <target state="translated">ArrowMonad</target>
        </trans-unit>
        <trans-unit id="31cc2db65fb67d75aaa03855c6522bc61f0c5f08" translate="yes" xml:space="preserve">
          <source>ArrowPlus</source>
          <target state="translated">ArrowPlus</target>
        </trans-unit>
        <trans-unit id="a6cef6a13748337ec64d72cbbfdef1e1d56c28ba" translate="yes" xml:space="preserve">
          <source>ArrowT</source>
          <target state="translated">ArrowT</target>
        </trans-unit>
        <trans-unit id="c5b3adde056c0b01047cb4ee63a6ade2f14b6bf6" translate="yes" xml:space="preserve">
          <source>ArrowZero</source>
          <target state="translated">ArrowZero</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="c27973de6a30851ee83300e482ede863a41f7f94" translate="yes" xml:space="preserve">
          <source>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</source>
          <target state="translated">箭头是John Hughes介绍的单项式的概括。更多细节,请看</target>
        </trans-unit>
        <trans-unit id="50de5e9983b77e93c151fa7abf423177ee062d7f" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 一样，但严格的归约结果在每个步骤中都起作用。</target>
        </trans-unit>
        <trans-unit id="192565b6bc1ac3ccf6bc1023c2ebb1325b5351f9" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; ，但严格的缩减结果在每个步骤中都起作用。</target>
        </trans-unit>
        <trans-unit id="5af372b8d1d974d76bfe10c942fe9d73af03dd9b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;, but with the structure as the primary argument. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; ，但以结构为主要参数。有关不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa8707f2ab83f8daca8094457adcacefc1dfcf09" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; are just binary operators, one might ask what happens if the datatype has more than two constructors, or a constructor with more than two fields. The answer is simple: the operators are used several times, to combine all the constructors and fields as needed. However, users /should not rely on a specific nesting strategy/ for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; being used. The compiler is free to choose any nesting it prefers. (In practice, the current implementation tries to produce a more-or-less balanced nesting, so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 只是二进制运算符，所以您可能会问，如果数据类型具有两个以上的构造函数，或者一个构造函数具有两个以上的字段，会发生什么情况。答案很简单：运算符被多次使用，以根据需要组合所有构造函数和字段。但是，用户不应该依赖于 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 的特定嵌套策略/ 。编译器可以自由选择其喜欢的任何嵌套。 （在实践中，当前实现尝试产生或多或少的平衡嵌套，以便可以从对数而不是线性时间遍历从根到特定组件的数据类型结构。）</target>
        </trans-unit>
        <trans-unit id="d1abb43b60664f44000bb7f5a55f0ee83b119b80" translate="yes" xml:space="preserve">
          <source>As GHC&amp;rsquo;s compilation products don&amp;rsquo;t map perfectly onto DWARF constructs, GHC takes advantage of the extensibility of the DWARF standard to provide additional information.</source>
          <target state="translated">由于GHC的编译产品无法完美地映射到DWARF结构上，因此GHC利用DWARF标准的可扩展性来提供其他信息。</target>
        </trans-unit>
        <trans-unit id="e35067b51e094e56d5ae4f8f876dfb483b8f92fd" translate="yes" xml:space="preserve">
          <source>As a binary semaphore &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt;, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as wait and signal.</source>
          <target state="translated">作为二进制信号量 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt; ，将 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 用作等待和信号。</target>
        </trans-unit>
        <trans-unit id="86cdad137d8956982af57685ad5fdd7f0b7b6c9c" translate="yes" xml:space="preserve">
          <source>As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt;. However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</source>
          <target state="translated">由于&lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;多态性绑定器限制&lt;/a&gt;，在使用 &lt;code&gt;data&lt;/code&gt; 声明的数据类型的数据构造函数中不允许多态性字段。但是，由于 &lt;code&gt;newtype&lt;/code&gt; 数据构造函数应用程序是作为强制而非函数应用程序实现的，因此此限制不适用于 &lt;code&gt;newtype&lt;/code&gt; 数据构造函数内部的字段。因此，类型检查器接受</target>
        </trans-unit>
        <trans-unit id="e1bbfcb820033011b427f73f5d8e7b567bf9a401" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="f93309e1645a680e5a41f639c6d8007d29bdfd58" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="80b0e3a1e8c000dc891586ccc71861ad6328cf11" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="243016489dff72f5ede560d16315ebcafa404bd9" translate="yes" xml:space="preserve">
          <source>As a consequence, zero is represented with a WordArray# whose size is 0.</source>
          <target state="translated">因此,0用一个大小为0的WordArray#表示。</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">作为一个构造函数</target>
        </trans-unit>
        <trans-unit id="5d801d83cd9e0b19d834377699e0695ddc3ca42e" translate="yes" xml:space="preserve">
          <source>As a constructor with record syntax</source>
          <target state="translated">作为记录语法的构造函数</target>
        </trans-unit>
        <trans-unit id="495b629e3096b9e923e5d90d66fa536008c4f084" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">为方便起见，GHC允许您在名称明确时省略引号。但是，我们的经验表明，引号有助于使代码更具可读性，并且不易出错。因此，GHC支持&lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt;，如果您使用不带引号的升级数据构造函数，则会警告您。</target>
        </trans-unit>
        <trans-unit id="9189865da8d3692a10ab79cac723aaeb6eea7be7" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">为方便起见，GHC允许您在名称明确时省略引号。但是，我们的经验表明，引号有助于使代码更具可读性，并且不易出错。因此，GHC支持&lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt;，如果您使用不带引号的升级数据构造函数，则会警告您。</target>
        </trans-unit>
        <trans-unit id="ce1486ef373f517210a834efa7f6eeb842e7f926" translate="yes" xml:space="preserve">
          <source>As a general rule, if a data type has a derived &lt;code&gt;Functor&lt;/code&gt; instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., &lt;code&gt;newtype Id a = Id a&lt;/code&gt;), or (2) occur as the last argument of a type constructor (as in &lt;code&gt;Right&lt;/code&gt; above).</source>
          <target state="translated">通常，如果数据类型具有派生的 &lt;code&gt;Functor&lt;/code&gt; 实例，并且其最后一个类型参数出现在数据声明的右侧，则它要么必须（1）裸露（例如， &lt;code&gt;newtype Id a = Id a&lt;/code&gt; ）或（2）作为类型构造函数的最后一个参数出现（如上 &lt;code&gt;Right&lt;/code&gt; 所示）。</target>
        </trans-unit>
        <trans-unit id="e5b650f5b24353725153d71d0ace5287fade8a17" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">作为调试Parsec解析器的更全面的替代方法，还有不包含&lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec的&lt;/a&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="77de548b67c5a91d54fca9a27ff2e0d7ee04de4b" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">作为用于调试Parsec解析器的更全面的替代方法，还有不包含&lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsec的&lt;/a&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="826ab8729c5c6b675ee7477d0a06b532fb5de96a" translate="yes" xml:space="preserve">
          <source>As a more substantial example of the rules in action, consider</source>
          <target state="translated">作为规则运作的一个更实质性的例子,请考虑到</target>
        </trans-unit>
        <trans-unit id="8478fed6cf150b0bde8267af58280dff83b3ef83" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</source>
          <target state="translated">作为一个快速的例子,这里是一个前端插件,它可以打印传递给它的参数,然后退出。</target>
        </trans-unit>
        <trans-unit id="991de1e28384a51531170b3384f7afcc4d87ef71" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says &amp;lsquo;Hello&amp;rsquo;:</source>
          <target state="translated">举个简单的例子，这是一个简单的插件，它什么都不做，只返回未经修改的原始编译管道，并说&amp;ldquo; Hello&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="85bb4cc8874a7fe78368b1f43fbe3cade8bd0615" translate="yes" xml:space="preserve">
          <source>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), &lt;em&gt;except&lt;/em&gt;&lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;, which really behave differently for the newtype and its representation.</source>
          <target state="translated">扩展的结果是，&lt;em&gt;除了&lt;/em&gt; &lt;code&gt;Show&lt;/code&gt; 和 &lt;code&gt;Read&lt;/code&gt; &lt;em&gt;之外&lt;/em&gt;，对newtype声明中的所有派生实例均进行了统一处理（并且仅通过重用表示类型的字典来实现），&lt;em&gt;但&lt;/em&gt;Show和Read的行为实际上对newtype及其表示形式有所不同。</target>
        </trans-unit>
        <trans-unit id="2f623b893d4cdf977b1e0a124c17974b2bd70476" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;inst_top&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;.</source>
          <target state="translated">结果， &lt;code&gt;inst_top&lt;/code&gt; 将其所有量化和约束放在 &lt;code&gt;opt_forall&lt;/code&gt; 和 &lt;code&gt;opt_context&lt;/code&gt; 的前面。</target>
        </trans-unit>
        <trans-unit id="b46bedb78774bd2cc4f8ff31c4366eaf33f5bd61" translate="yes" xml:space="preserve">
          <source>As a result, it requires approximately twice as much memory as its result to construct its result. For files more than a half of available RAM in size, this may result in memory exhaustion.</source>
          <target state="translated">因此,它所需要的内存大约是其结果的两倍,以构造其结果。对于大小超过可用内存一半的文件,可能导致内存耗尽。</target>
        </trans-unit>
        <trans-unit id="23608896f360a0680014f0f847570a9754d15267" translate="yes" xml:space="preserve">
          <source>As a result, traversal with a function &lt;strong&gt;&lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt;&lt;/strong&gt;, over an input container &lt;strong&gt;&lt;code&gt;t a&lt;/code&gt;&lt;/strong&gt;, yields a list &lt;strong&gt;&lt;code&gt;[t b]&lt;/code&gt;&lt;/strong&gt;, whose length is the product of the lengths of the lists that the function returns for each element of the input container! The individual elements &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; of the container are replaced by each element of &lt;strong&gt;&lt;code&gt;f a&lt;/code&gt;&lt;/strong&gt; in turn:</source>
          <target state="translated">结果，在输入容器&lt;strong&gt; &lt;code&gt;t a&lt;/code&gt; &lt;/strong&gt;上使用函数&lt;strong&gt; &lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt; &lt;/strong&gt;遍历将产生一个列表&lt;strong&gt; &lt;code&gt;[t b]&lt;/code&gt; &lt;/strong&gt;，其长度是该函数为每个元素返回的列表长度的乘积输入容器！容器的各个元素&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;依次由&lt;strong&gt; &lt;code&gt;f a&lt;/code&gt; &lt;/strong&gt;的每个元素替换：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e9d8d378558658c4bde3d6e6c2d01732f382a26" translate="yes" xml:space="preserve">
          <source>As a simple example of an encoding implementation, we show how to efficiently convert the following representation of mixed-data tables to an UTF-8 encoded Comma-Separated-Values (CSV) table.</source>
          <target state="translated">作为一个简单的编码实现的例子,我们展示了如何有效地将以下混合数据表的表示方式转换为UTF-8编码的逗号分隔值(CSV)表。</target>
        </trans-unit>
        <trans-unit id="ca12c18463b6879d5a860720c0092cdccee7f627" translate="yes" xml:space="preserve">
          <source>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</source>
          <target state="translated">由于一个额外的约束通配符足以推断出任何数量的约束,所以在类型签名中只允许有一个,而且它应该在约束列表中排在最后。</target>
        </trans-unit>
        <trans-unit id="ba8ae9d2e67cab36cf8dbfe80e256d78b5863ef7" translate="yes" xml:space="preserve">
          <source>As a workaround, we allow to bind &lt;code&gt;(*)&lt;/code&gt; in prefix form:</source>
          <target state="translated">解决方法是，我们允许以前缀形式绑定 &lt;code&gt;(*)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b52875799ff2828c6eeb24db51f51ce6b5d35654" translate="yes" xml:space="preserve">
          <source>As always, for RTS options that take ⟨size⟩s: If the last character of ⟨size⟩ is a K or k, multiply by 1000; if an M or m, by 1,000,000; if a G or G, by 1,000,000,000. (And any wraparound in the counters is &lt;em&gt;your&lt;/em&gt; fault!)</source>
          <target state="translated">与往常一样，对于采用TSsize⟩s的RTS选项：如果⟨size⟩的最后一个字符是K或k，则乘以1000。如果是M或m，则减1,000,000；如果是G或G，则为1,000,000,000。（而且计数器中的任何环绕都是&lt;em&gt;您的&lt;/em&gt;错！）</target>
        </trans-unit>
        <trans-unit id="99567f4b6e834794323885b782256cd2c328ea5e" translate="yes" xml:space="preserve">
          <source>As always, type synonyms must be fully applied. You cannot, for example, write:</source>
          <target state="translated">一如既往,类型同义词必须完全应用。例如,你不能写。</target>
        </trans-unit>
        <trans-unit id="13c3594421b98bd2bf10cd954eb77cee53d78c7c" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为一个 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不是一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 绕过错误的处理 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，不能被截获 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;prelude&quot;&gt;前奏&lt;/a&gt;。但是，这是 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; ，可以使用&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;函数进行捕获。这意味着添加到 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 中的清除计算（来自&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;）也可以在 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 上正确执行。</target>
        </trans-unit>
        <trans-unit id="9a64b93c54367f32283d34b8466c83c540d04226" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为一个 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不是一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 绕过错误的处理 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，不能被截获 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;prelude&quot;&gt;前奏&lt;/a&gt;。但是，这是 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; ，可以使用&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;函数进行捕获。这意味着添加到 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 中的清除计算（来自&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;）也可以在 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 上正确执行。</target>
        </trans-unit>
        <trans-unit id="39edd1cc6e94c784b4f7e11ad121c08ce0f9db79" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为一个 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不是一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 绕过错误的处理 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，不能被截获 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;prelude&quot;&gt;前奏&lt;/a&gt;。但是，这是 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; ，可以使用&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;函数进行捕获。这意味着添加到 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 中的清除计算（来自&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;）也可以在 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 上正确执行。</target>
        </trans-unit>
        <trans-unit id="7a4cafca22cd8d1a307b13e29242f4d26666e5a9" translate="yes" xml:space="preserve">
          <source>As an example of signaling an error in the error monad &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, consider a safe division function &lt;code&gt;safeDiv x y&lt;/code&gt; that returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the denominator &lt;code&gt;y&lt;/code&gt; is zero and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div`
 y)&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">由于信号在错误的错误的一个例子单子 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; ，考虑安全部门的功能 &lt;code&gt;safeDiv x y&lt;/code&gt; 回返 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 当分母 &lt;code&gt;y&lt;/code&gt; 为零， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div` y)&lt;/code&gt; 除外。例如：</target>
        </trans-unit>
        <trans-unit id="c06e5fe5eaba60d194f35398d388c5324d3e8468" translate="yes" xml:space="preserve">
          <source>As an example which does &lt;em&gt;not&lt;/em&gt; work, consider</source>
          <target state="translated">作为做一个例子&lt;em&gt;不&lt;/em&gt;工作，考虑</target>
        </trans-unit>
        <trans-unit id="6347b158715a28dac26c8c73ed1a2953999b56f9" translate="yes" xml:space="preserve">
          <source>As an example, consider a simple pretty-printer class &lt;code&gt;SPretty&lt;/code&gt;, which outputs pretty strings:</source>
          <target state="translated">例如，考虑一个简单的漂亮打印机类 &lt;code&gt;SPretty&lt;/code&gt; ，它输出漂亮的字符串：</target>
        </trans-unit>
        <trans-unit id="522dfa47c182924ecba88bb21606211e4b6f02fd" translate="yes" xml:space="preserve">
          <source>As an example, consider the following pipeline:</source>
          <target state="translated">举个例子,考虑以下管道。</target>
        </trans-unit>
        <trans-unit id="42d246ca4c667eae440bdea085741dec65a2d440" translate="yes" xml:space="preserve">
          <source>As an example, consider the type of predicate functions &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt;. One such predicate might be &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt;, which classifies integers as to whether they are negative. However, given this predicate, we can re-use it in other situations, providing we have a way to map values &lt;em&gt;to&lt;/em&gt; integers. For instance, we can use the &lt;code&gt;negative&lt;/code&gt; predicate on a person's bank balance to work out if they are currently overdrawn:</source>
          <target state="translated">例如，考虑谓词函数 &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; 的类型。一个这样的谓词可能是 &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt; ，它对整数是否为负数进行了分类。但是，有了这个谓词，只要我们有一种将值映射&lt;em&gt;到&lt;/em&gt;整数的方法，我们就可以在其他情况下重用它。例如，我们可以使用某人的银行余额上的 &lt;code&gt;negative&lt;/code&gt; 谓词来计算当前是否透支了：</target>
        </trans-unit>
        <trans-unit id="9c76375fc08b8bec18373864d63325042996901b" translate="yes" xml:space="preserve">
          <source>As an example, in order to load the plugin exported by &lt;code&gt;Foo.Plugin&lt;/code&gt; in the package &lt;code&gt;foo-ghc-plugin&lt;/code&gt;, and give it the parameter &amp;ldquo;baz&amp;rdquo;, we would invoke GHC like this:</source>
          <target state="translated">例如，为了将 &lt;code&gt;Foo.Plugin&lt;/code&gt; 导出的插件加载到 &lt;code&gt;foo-ghc-plugin&lt;/code&gt; 包中，并为其指定参数&amp;ldquo; baz&amp;rdquo;，我们将像这样调用GHC：</target>
        </trans-unit>
        <trans-unit id="362dc967d86ad4ea9a7d9c73fea6acc2cbd89dbf" translate="yes" xml:space="preserve">
          <source>As an example, let us look at a function &lt;code&gt;encode&lt;/code&gt; that produces a naive, but lossless bit encoding of values of various datatypes. So we are aiming to define a function</source>
          <target state="translated">举个例子，让我们看一个函数 &lt;code&gt;encode&lt;/code&gt; ，它产生各种数据类型的值的幼稚但无损的位编码。因此，我们旨在定义一个功能</target>
        </trans-unit>
        <trans-unit id="33852151126c630432f1fdab8e0ba978ca5481a5" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted &lt;code&gt;IO&lt;/code&gt; monad that we have defined. The restricted &lt;code&gt;IO&lt;/code&gt; monad will only allow a safe subset of &lt;code&gt;IO&lt;/code&gt; actions to be executed. We define the plugin interface so that it requires the plugin module, &lt;code&gt;Danger&lt;/code&gt;, to export a single computation, &lt;code&gt;Danger.runMe&lt;/code&gt;, of type &lt;code&gt;RIO ()&lt;/code&gt;, where &lt;code&gt;RIO&lt;/code&gt; is a monad defined as follows:</source>
          <target state="translated">例如，让我们为插件系统定义一个接口，在该接口上插件作者不受信任，并且可能是恶意的第三方。为此，我们将插件接口限制为纯函数或已定义的受限 &lt;code&gt;IO&lt;/code&gt; monad。受限的 &lt;code&gt;IO&lt;/code&gt; monad将仅允许执行 &lt;code&gt;IO&lt;/code&gt; 操作的安全子集。我们定义插件接口，以便它需要插件模块 &lt;code&gt;Danger&lt;/code&gt; 导出类型为 &lt;code&gt;RIO ()&lt;/code&gt; 的单个计算 &lt;code&gt;Danger.runMe&lt;/code&gt; ，其中 &lt;code&gt;RIO&lt;/code&gt; 是monad，定义如下：</target>
        </trans-unit>
        <trans-unit id="70582809de8cd9e89c6a9bd154c02621c8e3fe1c" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have following special printing module:</source>
          <target state="translated">举个例子,假设我们有以下特殊的打印模块。</target>
        </trans-unit>
        <trans-unit id="6adf45b29a6631ff6d424f3a35e51b0c62f84184" translate="yes" xml:space="preserve">
          <source>As an example, suppose you read a large string, of which you need only a small portion. If you do not use &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt;, the entire original array will be kept alive in memory by the smaller string. Making a copy &quot;breaks the link&quot; to the original array, allowing it to be garbage collected if there are no other live references to it.</source>
          <target state="translated">例如，假设您读取了一个大字符串，而只需要一小部分。如果不使用 &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt; ，则整个原始数组将通过较小的字符串保留在内存中。复制后，将&amp;ldquo;断开链接&amp;rdquo;到原始数组，如果没有其他实时引用，则可以对其进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="d63ea3a1b75b9abed859b37118efd2bdfeda9979" translate="yes" xml:space="preserve">
          <source>As an example, this data declaration:</source>
          <target state="translated">举个例子,这个数据声明:</target>
        </trans-unit>
        <trans-unit id="490082850527086dedfac3775659ee1738c0ae5d" translate="yes" xml:space="preserve">
          <source>As another example, this is the layout for the unboxed version of &lt;code&gt;Maybe a&lt;/code&gt; type, &lt;code&gt;(# (# #) | a #)&lt;/code&gt;:</source>
          <target state="translated">再举一个例子，这是未装箱的 &lt;code&gt;Maybe a&lt;/code&gt; 类型 &lt;code&gt;(# (# #) | a #)&lt;/code&gt; 的布局：</target>
        </trans-unit>
        <trans-unit id="18151bc795d27e140f421a3a96b2c553b0826f0d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">再举一个例子，我们可以考虑一个类型 &lt;code&gt;Set a&lt;/code&gt; 表示一组数据，下令根据 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;Ord&lt;/code&gt; 实例。虽然这将通常是类型安全的考虑 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，有可能是一个 &lt;code&gt;newtype&lt;/code&gt; 且其基本类型有&lt;em&gt;不同的&lt;/em&gt;在各自的编码排序 &lt;code&gt;Ord&lt;/code&gt; 实例。这将导致运行时行为异常。因此， &lt;code&gt;Set&lt;/code&gt; 数据类型的作者希望其参数处于标称角色。这将通过声明来完成</target>
        </trans-unit>
        <trans-unit id="9e081e131ffbc4e13afc7b95b1192b51f216cb4d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">再举一个例子，我们可以考虑一个类型 &lt;code&gt;Set a&lt;/code&gt; 表示一组数据，下令根据 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;Ord&lt;/code&gt; 实例。虽然这将通常是类型安全的考虑 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，有可能是一个 &lt;code&gt;newtype&lt;/code&gt; 且其基本类型有&lt;em&gt;不同的&lt;/em&gt;在各自的编码排序 &lt;code&gt;Ord&lt;/code&gt; 实例。这将导致运行时行为异常。因此， &lt;code&gt;Set&lt;/code&gt; 数据类型的作者希望其参数处于标称角色。这将通过声明来完成</target>
        </trans-unit>
        <trans-unit id="971f3c8e7fa04aa11b176990e12b0d8a905825b5" translate="yes" xml:space="preserve">
          <source>As before, only one selector function is generated here, that for &lt;code&gt;tag&lt;/code&gt;. Nevertheless, you can still use all the field names in pattern matching and record construction.</source>
          <target state="translated">和以前一样，这里仅生成一个选择器函数，即 &lt;code&gt;tag&lt;/code&gt; 的选择器函数。但是，您仍然可以在模式匹配和记录构造中使用所有字段名称。</target>
        </trans-unit>
        <trans-unit id="aa864a2dee7d7cdb239046ddc338c3e2554307a5" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;base&lt;/code&gt; package. &lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt;&lt;code&gt;-flink-rts&lt;/code&gt;&lt;/a&gt; additionally links against the shared library version of the &lt;code&gt;rts&lt;/code&gt; package (linking against the &lt;code&gt;rts&lt;/code&gt; package is not enabled by default when building shared libraries). You may also omit &lt;code&gt;-flink-rts&lt;/code&gt; and link the RTS library into your final executable.</source>
          <target state="translated">和以前一样，&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志指定该库链接到 &lt;code&gt;base&lt;/code&gt; 软件包的共享库版本。&lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt; &lt;code&gt;-flink-rts&lt;/code&gt; &lt;/a&gt;还会针对 &lt;code&gt;rts&lt;/code&gt; 软件包的共享库版本进行链接（构建共享库时，默认情况下不会针对 &lt;code&gt;rts&lt;/code&gt; 软件包进行链接）。您也可以省略 &lt;code&gt;-flink-rts&lt;/code&gt; 并将RTS库链接到最终的可执行文件中。</target>
        </trans-unit>
        <trans-unit id="1b294469f3600688f3c16a9375ab450bd92e329f" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;rts&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; package. The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">和以前一样，&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志指定该库链接到 &lt;code&gt;rts&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 软件包的共享库版本。所述&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;标志是必需的所有的代码，将在一个共享库中结束。该&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;标志指定作共享库，而不是一个项目。为了使这一点更清楚，我们可以将其分解为单独的编译和链接步骤：</target>
        </trans-unit>
        <trans-unit id="7075fa9b7f0c6ece6ef586ef8232718a3c4e1adf" translate="yes" xml:space="preserve">
          <source>As channels, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as receive and send, and</source>
          <target state="translated">作为通道，将 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 用作接收和发送，并且</target>
        </trans-unit>
        <trans-unit id="5f8a308216057de51dc8e2d87492c599832235ef" translate="yes" xml:space="preserve">
          <source>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-x ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">如上所述，GHC处理文件的方式取决于其后缀。可以使用&lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-x ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;选项覆盖此行为：</target>
        </trans-unit>
        <trans-unit id="ac41a6f7a2ba794206a1881f72e83bfc76ecc4c5" translate="yes" xml:space="preserve">
          <source>As discussed earlier, use &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to disambiguate GHC flags when needed. For example, &lt;code&gt;-f&lt;/code&gt; is recognized by runghc, therefore to pass &lt;code&gt;-fliberate-case&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">如前所述，在需要时使用 &lt;code&gt;--&lt;/code&gt; 或 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 消除GHC标志的歧义。例如， &lt;code&gt;-f&lt;/code&gt; 被runghc识别，因此要使用 &lt;code&gt;-fliberate-case&lt;/code&gt; 传递给GHC，请使用以下任一命令：</target>
        </trans-unit>
        <trans-unit id="67cc7c655699a8e4a2e0b555a8afa1e30261d029" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">至于该库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8991e65b25a1268c5578c175657da1832d9cb512" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">至于该库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78cc6104aca9fb1ec54052832ddebd0c39befee4" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">至于该库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47a4bb98e7bde318e0428ee9df25a1247392901b" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">至于该库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe90224af19846dad1a17ef9f898f327403d732c" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;ByteStrings&lt;/code&gt; that are slices of the original.</source>
          <target state="translated">至于此库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;ByteStrings&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66418d326af7c7178dbcf345c383fa758cb34200" translate="yes" xml:space="preserve">
          <source>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</source>
          <target state="translated">至于类型签名,隐式量化也会发生在非过载类型上。所以,如果你这样写。</target>
        </trans-unit>
        <trans-unit id="131c4ed80f84ad7adaad005b0b251d5561f2e9bd" translate="yes" xml:space="preserve">
          <source>As iconv is missing in some minimal environments (e.g. #10298), this checks to ensure that iconv is working properly before returning the encoding, returning &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">由于iconv在某些最小环境（例如＃10298）中丢失，因此将检查以确保iconv在返回编码之前正常工作，否则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a094fb6c3fac4ea42a5b01e068a43a07a1612b8" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#define&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">好像在源代码中放置了适当的 &lt;code&gt;#define&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="0b3a2a9b0861349d1000eb5c63f5fe83939ea7af" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#include&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">好像在源代码中放置了适当的 &lt;code&gt;#include&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="beaf430a25d7c8a7463fc714eeb5bef652c1ca18" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">与图&lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2一样&lt;/a&gt;，实际上并不需要FFI。 &lt;code&gt;GHC.Exts&lt;/code&gt; 包含用于从 &lt;code&gt;ArrayArray#&lt;/code&gt; 读取的原语。</target>
        </trans-unit>
        <trans-unit id="098c067155c3928cc8e309c0b70434dda18ac150" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;[2]&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">如&lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;[2]所示&lt;/a&gt;，实际上并不需要FFI。 &lt;code&gt;GHC.Exts&lt;/code&gt; 包含用于从 &lt;code&gt;ArrayArray#&lt;/code&gt; 读取的原语。</target>
        </trans-unit>
        <trans-unit id="3704be0b1f85ea495e4739ed1a37ef32e604634f" translate="yes" xml:space="preserve">
          <source>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of &amp;ldquo;acyclic&amp;rdquo; involves only the superclass relationships. For example, this is okay:</source>
          <target state="translated">与Haskell 98中一样，类层次结构必须是非循环的。但是，&amp;ldquo;非循环&amp;rdquo;的定义仅涉及超类关系。例如，这可以：</target>
        </trans-unit>
        <trans-unit id="a18ecf9c948be4e27d139d19b812430b86052cfe" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">与使用类似Haskell-98的记录语法（&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;）声明的存在性一样，记录选择器功能仅针对具有类型正确的选择器的字段生成。这是该部分的示例，采用GADT样式的语法：</target>
        </trans-unit>
        <trans-unit id="92ba8fd84c6bd0e839142f8b7eca6e02c9f392cc" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">与使用类似Haskell-98的记录语法（&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;）声明的存在性一样，记录选择器功能仅针对具有类型正确的选择器的字段生成。这是该部分的示例，采用GADT样式的语法：</target>
        </trans-unit>
        <trans-unit id="e3cd19795acf719bdbdadfeb240558bb97933bfa" translate="yes" xml:space="preserve">
          <source>As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</source>
          <target state="translated">由于种类和类型相同，种类可以（带有&lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt;）包含类型约束。但是，仅支持平等约束。</target>
        </trans-unit>
        <trans-unit id="b688c040bfb0b19971fb0ce773edf49cba5c5c6c" translate="yes" xml:space="preserve">
          <source>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</source>
          <target state="translated">只要一个类型变量受到这些类中的一个类的约束,就会发生默认,如上所述。</target>
        </trans-unit>
        <trans-unit id="44161a74606a6af43d39c349f3c26f8c14875c50" translate="yes" xml:space="preserve">
          <source>As long as you are happy to only be able to link to the DLL using &lt;code&gt;GetProcAddress&lt;/code&gt; and friends, you can supply the &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt;&lt;code&gt;-fno-shared-implib&lt;/code&gt;&lt;/a&gt; flag to disable the creation of the import library entirely.</source>
          <target state="translated">只要您很高兴只能使用 &lt;code&gt;GetProcAddress&lt;/code&gt; 和好友链接到DLL ，就可以提供&lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt; &lt;code&gt;-fno-shared-implib&lt;/code&gt; &lt;/a&gt;标志以完全禁用导入库的创建。</target>
        </trans-unit>
        <trans-unit id="2e315249f68fda8aaff176e296d66a05a6132ca0" translate="yes" xml:space="preserve">
          <source>As mapFile, but returns ByteString</source>
          <target state="translated">作为mapFile,但返回ByteString</target>
        </trans-unit>
        <trans-unit id="a545221512e878619258ca5f17df48cfac240523" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="6e1afd64bce824d5669c2abf1ae7f5ca39a54331" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="6a668f275f9aa656c990c93f68c69e117d56a6a9" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="f65b46df8fe6c264c596a4ee57c977d2fcd44935" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">如在&lt;a href=&quot;#gadt-style&quot;&gt;使用显式构造函数签名声明数据类型中&lt;/a&gt;所述，支持记录语法。例如：</target>
        </trans-unit>
        <trans-unit id="9f2d8d704ce406fdcf65da6dff1ef0084db00f7c" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">如在&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;使用显式构造函数签名声明数据类型中&lt;/a&gt;所述，支持记录语法。例如：</target>
        </trans-unit>
        <trans-unit id="180500d2c123f41ae24d4c741a0e7e11617119d4" translate="yes" xml:space="preserve">
          <source>As observed in the &lt;a href=&quot;#leftright&quot;&gt;above description&lt;/a&gt; of left and right folds, there are three general ways in which a structure can be reduced to a summary value:</source>
          <target state="translated">从上面对左右折的&lt;a href=&quot;#leftright&quot;&gt;描述&lt;/a&gt;中可以看出，可以通过三种通用方法将结构简化为汇总值：</target>
        </trans-unit>
        <trans-unit id="2b20aa3bf540201cc843068062611e2c68e78f44" translate="yes" xml:space="preserve">
          <source>As of 1.3.5.0, the environment variable is ignored if set to a relative path, per revised XDG Base Directory Specification. See &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;#100&lt;/a&gt;.</source>
          <target state="translated">从1.3.5.0版本开始，根据修订的XDG基本目录规范，如果将环境变量设置为相对路径，则将忽略该变量。参见&lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;＃100&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66155d480946b24160dbc04cb1009ec185e9eb15" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d54fac1ed5477bc40ff0f48a11003303f605712" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68bb1e4d347f7e14f0730566cfe86c41cf0cf621" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="431c3d0f7612a40f6ff5eb1278e282741242a19d" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; 已由 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt; 取代。</target>
        </trans-unit>
        <trans-unit id="165ec2af84cd6d6f877d1e69014b6333343144ea" translate="yes" xml:space="preserve">
          <source>As of GHC 8.0.1 you may also &amp;ldquo;bundle&amp;rdquo; pattern synonyms with an exported type constructor, making that pattern appear as a data constructor of that type. To bundle a pattern synonym, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">从GHC 8.0.1开始，您还可以将模式同义词与导出的类型构造函数&amp;ldquo;捆绑&amp;rdquo;在一起，使该模式作为该类型的数据构造函数出现。为了捆绑模式同义词，我们在导出类型构造函数的模块的导出列表中列出了模式同义词。例如，要将 &lt;code&gt;Zero&lt;/code&gt; 与 &lt;code&gt;MyNum&lt;/code&gt; 捆绑在一起，我们可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="ff725c4e2000e4c32e7a70322b85a55a85f4f248" translate="yes" xml:space="preserve">
          <source>As of GHC version 6.8, we have adopted the following policy for numbering GHC versions:</source>
          <target state="translated">从GHC 6.8版本开始,我们对GHC版本的编号采取了以下政策。</target>
        </trans-unit>
        <trans-unit id="6667e67a30d7295682c9410cb1e7f0f855d9f77a" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="189b02d51b70039f2bb98397c33331f99f38f72e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ffe502c088313295fc8544881ef2e7de642be25" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4755017eb545075e257326e642258214d89957c4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be1d09e17e8e02c7031393483495ad5d61f69b4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f37649ade650085aa0f65cecdda074623b0b69e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="995d3e4e58500aa9b1bd3701177a6dbe6d9b1cb8" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0137e920b69fe62239fad821757f41940234bff2" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63452b7c7f465acb4dded12e10643c0a80c59e1c" translate="yes" xml:space="preserve">
          <source>As of bytestring 0.9.0.3, this function is stricter than its list cousin.</source>
          <target state="translated">从bytestring 0.9.0.3开始,这个函数比它的表兄弟list更加严格。</target>
        </trans-unit>
        <trans-unit id="039bbe9675865514fb60ebed364f1df32b98df77" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; data structures, which have one variety of element on which an action can be performed, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; data structures have two such varieties of elements.</source>
          <target state="translated">相对于 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 的数据结构，其具有一个品种在其上可以执行的动作元件， &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 数据结构具有两个这样的品种元件。</target>
        </trans-unit>
        <trans-unit id="1ae607bddf78967e412e95f44ed5f98b62257887" translate="yes" xml:space="preserve">
          <source>As part of the same extension, you can put kind annotations in types as well. Thus:</source>
          <target state="translated">作为同一扩展的一部分,你也可以在类型中加入种类注释。因此:</target>
        </trans-unit>
        <trans-unit id="7699c90ab29019673b3fd8db1b1767ae9771115b" translate="yes" xml:space="preserve">
          <source>As soon as GHC plus its &amp;ldquo;fellow citizens&amp;rdquo; (other processes on your machine) start using more than the &lt;em&gt;real memory&lt;/em&gt; on your machine, and the machine starts &amp;ldquo;thrashing,&amp;rdquo; &lt;em&gt;the party is over&lt;/em&gt;. Compile times will be worse than terrible! Use something like the csh builtin &lt;strong&gt;time&lt;/strong&gt; command to get a report on how many page faults you&amp;rsquo;re getting.</source>
          <target state="translated">一旦GHC及其&amp;ldquo;同胞&amp;rdquo;（计算机上的其他进程）开始使用的&lt;em&gt;内存&lt;/em&gt;超过了&lt;em&gt;计算机&lt;/em&gt;上的&lt;em&gt;实际内存&lt;/em&gt;，并且计算机开始&amp;ldquo;崩溃&amp;rdquo;，&lt;em&gt;则聚会结束了&lt;/em&gt;。编译时间将比可怕的还要糟糕！使用csh Builtin &lt;strong&gt;time&lt;/strong&gt;命令之类的内容获取有关您遇到的页面错误的报告。</target>
        </trans-unit>
        <trans-unit id="5c65dae701ef99ffffbad1ccc118a5d026621cac" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;purePlugin&lt;/code&gt; is defined as a function which always returns &lt;code&gt;NoForceRecompile&lt;/code&gt;.</source>
          <target state="translated">这样， &lt;code&gt;purePlugin&lt;/code&gt; 被定义为始终返回 &lt;code&gt;NoForceRecompile&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="83c27882ec4f84c2b1c7547fee6d29bef6299680" translate="yes" xml:space="preserve">
          <source>As synchronized mutable variables,</source>
          <target state="translated">作为同步可变的变量。</target>
        </trans-unit>
        <trans-unit id="8c68344402c4c848cd9948b1b997a6cdee8b6472" translate="yes" xml:space="preserve">
          <source>As text to standard output, for debugging purposes.</source>
          <target state="translated">作为标准输出的文本,用于调试。</target>
        </trans-unit>
        <trans-unit id="181b02f4903ccd97fffcaf58addb10482aefc450" translate="yes" xml:space="preserve">
          <source>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; above would be valid field type signatures.</source>
          <target state="translated">作为数据类型声明中的构造函数的参数或字段的类型。例如，上面的 &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; 任何一个都是有效的字段类型签名。</target>
        </trans-unit>
        <trans-unit id="2c75efee694fce1348012a0f71a5ff8152fe1dea" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">由于双 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;noneOf cs&lt;/code&gt; 成功，如果当前字符&lt;em&gt;不&lt;/em&gt;中的字符提供的一系列 &lt;code&gt;cs&lt;/code&gt; 。返回已解析的字符。</target>
        </trans-unit>
        <trans-unit id="ccb0b2bddb73f4bc8b6273e372d5253cba90fe8b" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">由于双 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;noneOf cs&lt;/code&gt; 成功，如果当前字符&lt;em&gt;不&lt;/em&gt;中的字符提供的一系列 &lt;code&gt;cs&lt;/code&gt; 。返回已解析的字符。</target>
        </trans-unit>
        <trans-unit id="595d79d9d63a7ad5c2be3b061e3dc58b00a5d260" translate="yes" xml:space="preserve">
          <source>As the type of an implicit parameter</source>
          <target state="translated">作为一个隐性参数的类型</target>
        </trans-unit>
        <trans-unit id="d153cbf6806b7b35bd0413a66f8a99b8d11cec38" translate="yes" xml:space="preserve">
          <source>As this suggests, each occurrence is replaced exactly once. So if &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;replacement&lt;/code&gt;, that occurrence will &lt;em&gt;not&lt;/em&gt; itself be replaced recursively:</source>
          <target state="translated">如此暗示，每个事件被完全替换一次。因此，如果 &lt;code&gt;needle&lt;/code&gt; 在 &lt;code&gt;replacement&lt;/code&gt; 中发生，那么该事件本身将&lt;em&gt;不会&lt;/em&gt;被递归替换：</target>
        </trans-unit>
        <trans-unit id="e53867775e4428028623be9fceee714ed0171be0" translate="yes" xml:space="preserve">
          <source>As usual, for every constructor that has a field &lt;code&gt;f&lt;/code&gt;, the type of field &lt;code&gt;f&lt;/code&gt; must be the same (modulo alpha conversion). The &lt;code&gt;Child&lt;/code&gt; constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the &amp;ldquo;type&amp;rdquo; that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A &amp;ldquo;type&amp;rdquo; of this form can appear only in a constructor signature.)</source>
          <target state="translated">与往常一样，对于具有字段每一个构造 &lt;code&gt;f&lt;/code&gt; ，字段的类型 &lt;code&gt;f&lt;/code&gt; 必须是相同的（模&amp;alpha;-转化）。上面的 &lt;code&gt;Child&lt;/code&gt; 构造函数表明，签名可以具有上下文，存在量化的变量和严格性注释，就像在非记录情况下一样。（注意：由于记录的语法和严格性的注解，双冒号后面的&amp;ldquo;类型&amp;rdquo;实际上不是一种类型。这种形式的&amp;ldquo;类型&amp;rdquo;只能出现在构造函数签名中。）</target>
        </trans-unit>
        <trans-unit id="424c7f952d5ac1aa74645c5f27a67eda13f56e6f" translate="yes" xml:space="preserve">
          <source>As usual, the meta-variables &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc., can be arbitrary patterns. In general, the statement &lt;code&gt;rec ss&lt;/code&gt; is desugared to the statement</source>
          <target state="translated">像往常一样，元变量 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 等可以是任意模式。一般而言，语句 &lt;code&gt;rec ss&lt;/code&gt; 取代了该语句</target>
        </trans-unit>
        <trans-unit id="3cf1bb90d2a6c5267034d92cb3db4ce82d1bfdff" translate="yes" xml:space="preserve">
          <source>As we demonstrated earlier (&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt;), the debugger has some intelligence built-in to update the type of &lt;code&gt;f&lt;/code&gt; whenever the types of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;_result&lt;/code&gt; are discovered. So what we do in this scenario is force &lt;code&gt;x&lt;/code&gt; a bit, in order to recover both its type and the argument part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">正如我们之前所演示的（&lt;a href=&quot;#breakpoints&quot;&gt;断点和检查变量&lt;/a&gt;），调试器具有一些内置的智能功能，可以在发现 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;_result&lt;/code&gt; 类型时更新 &lt;code&gt;f&lt;/code&gt; 的类型。因此，在这种情况下，我们要做的是稍微施加力 &lt;code&gt;x&lt;/code&gt; ，以便同时恢复其类型和 &lt;code&gt;f&lt;/code&gt; 的自变量部分。</target>
        </trans-unit>
        <trans-unit id="480449ae21e88b5153c176f83519328d5843ab58" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the &lt;code&gt;ArrowPlus&lt;/code&gt; class includes a combinator</source>
          <target state="translated">正如我们所看到的，箭头表示法提供了以表达式，顺序，值递归和条件为基础的构造模型。但是，您可以在普通的Haskell中定义的合适组合器也可以用于从现有命令中构建新命令。基本思想是命令定义从环境到值的箭头。这些环境将值分配给命令的可用局部变量。因此，从箭头产生箭头的组合器也可以用于从命令构建命令。例如， &lt;code&gt;ArrowPlus&lt;/code&gt; 类包含一个组合器</target>
        </trans-unit>
        <trans-unit id="22cabbc3d4e2b43e627bd00b9475f0bf29950d8f" translate="yes" xml:space="preserve">
          <source>As well as in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">除了类型签名，您还可以在实例声明中使用显式的 &lt;code&gt;forall&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="196191205f2b62c541cf8a5ff3836b4bc01787da" translate="yes" xml:space="preserve">
          <source>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</source>
          <target state="translated">以及避免不必要的模式匹配,它还有助于避免不必要的分配。这适用于当一个参数在递归调用自身时是严格的,但在初始条目上不是。由于严格递归函数的分支被创建,类似于上面的例子。</target>
        </trans-unit>
        <trans-unit id="8c16e4471532afea529c20b4ff2e8a8a16601be0" translate="yes" xml:space="preserve">
          <source>As well in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">除了类型签名，您还可以在实例声明中使用显式的 &lt;code&gt;forall&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ead26c4f8d8b65c7691881f1d8045e494c57debb" translate="yes" xml:space="preserve">
          <source>As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</source>
          <target state="translated">与所有已知的Haskell系统一样,GHC实现了对标准Haskell语言的一些扩展。它们都可以通过命令行标志或语言语法来启用或禁用。默认情况下,GHC能理解它所支持的最新的Haskell版本,加上一些扩展。</target>
        </trans-unit>
        <trans-unit id="fcd43e9a7f0adbd4e1cdcb63a469dbf86f84b840" translate="yes" xml:space="preserve">
          <source>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there&amp;rsquo;s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</source>
          <target state="translated">与普通变量绑定一样，后面的定义会覆盖前面的定义，因此您可以重新输入声明以解决该问题或扩展它。但是有一个陷阱：当新的类型声明遮盖了旧的类型声明时，可能还有其他引用旧类型的声明。要记住的是，旧类型仍然存在，而这些其他声明仍然引用旧类型。但是，尽管新旧类型具有相同的名称，但是GHCi会将它们区别对待。例如：</target>
        </trans-unit>
        <trans-unit id="637fa52fc6437e00230d9db2fe6b3adca8d89276" translate="yes" xml:space="preserve">
          <source>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;:</source>
          <target state="translated">与其他类型签名一样，您可以为多个数据构造函数提供一个签名。在此示例中，我们为 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 提供一个签名：</target>
        </trans-unit>
        <trans-unit id="9a5d0276624512bf5b98fc03c361aa6bea31b80c" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; function, if any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 函数一样，如果列表中的任何两个关联具有相同的索引，则该索引处的值取决于实现。（在GHC中，使用为该索引指定的最后一个值。其他实现也将对未装箱的数组执行此操作，但是Haskell 98要求对于 &lt;code&gt;Array&lt;/code&gt; ，此类索引处的值应为底部。）</target>
        </trans-unit>
        <trans-unit id="290e57760e517898d7b9efcc098bc5d22f645f5f" translate="yes" xml:space="preserve">
          <source>As you can guess &lt;code&gt;justOnes&lt;/code&gt; will evaluate to &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt;.</source>
          <target state="translated">正如您可以猜到 &lt;code&gt;justOnes&lt;/code&gt; 将评估为 &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44e503436bbd1b51c2f4671a6a4bc6e7cfdbb40d" translate="yes" xml:space="preserve">
          <source>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</source>
          <target state="translated">正如你所看到的,以这种方式使用运算符并不是很有用,Haskell 98甚至不允许你写它们的infix。</target>
        </trans-unit>
        <trans-unit id="2b751c77c03006544a696243e4f9983a43fa624e" translate="yes" xml:space="preserve">
          <source>As-patterns must not be surrounded by whitespace on either side:</source>
          <target state="translated">As-patterns的两边不能用空格包围。</target>
        </trans-unit>
        <trans-unit id="67dc44d97f00c988807bcf67aa9d1c8f84fff7c6" translate="yes" xml:space="preserve">
          <source>Ascii Drawings</source>
          <target state="translated">Ascii 图纸</target>
        </trans-unit>
        <trans-unit id="cca21e0df87aca3b913734b67e2e333b718bae99" translate="yes" xml:space="preserve">
          <source>Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</source>
          <target state="translated">阿什莉&amp;middot;亚克利&amp;lt;ashley@semantic.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7f327535400c99b415e9d1ddaa6d9904d1bfafa2" translate="yes" xml:space="preserve">
          <source>Ask that GHC specialize a polymorphic value to a particular type.</source>
          <target state="translated">要求GHC将一个多态值特殊化为一个特定的类型。</target>
        </trans-unit>
        <trans-unit id="bc24cd3c8b6ddb112a336c5966d0506d3b2fd9ca" translate="yes" xml:space="preserve">
          <source>Assembly language (.s)</source>
          <target state="translated">汇编语言(.s)</target>
        </trans-unit>
        <trans-unit id="4ffedc04e994a9aefd97d00e379f2d4f383ff9bc" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">可以捕获断言失败，有关详细信息，请参见&lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;库的文档。</target>
        </trans-unit>
        <trans-unit id="d8e00d7a54a273c595978f5b3e92d75c8e0981a9" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">可以捕获断言失败，有关详细信息，请参见&lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;库的文档。</target>
        </trans-unit>
        <trans-unit id="cde31a8393d46785fc228979a73996dac43391ba" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">可以捕获断言失败，有关详细信息，请参见&lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;库的文档。</target>
        </trans-unit>
        <trans-unit id="74319d6a5a4eb02ecd1401e7a9faed7d9660ea69" translate="yes" xml:space="preserve">
          <source>AssertionFailed</source>
          <target state="translated">AssertionFailed</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e8ddc914ca09e8e31648b53bc077284126a4cbdc" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">断言通常可以使用编译器标志打开或关闭（对于GHC，除非使用 &lt;code&gt;-O&lt;/code&gt; 打开优化或给出 &lt;code&gt;-fignore-asserts&lt;/code&gt; 选项，否则断言通常处于打开状态）。当断言关闭时， &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 的第一个参数将被忽略，而第二个参数将作为结果返回。</target>
        </trans-unit>
        <trans-unit id="492da7da6121915584e059d74109845fdbc2bb99" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">断言通常可以使用编译器标志打开或关闭（对于GHC，除非使用 &lt;code&gt;-O&lt;/code&gt; 打开优化或给出 &lt;code&gt;-fignore-asserts&lt;/code&gt; 选项，否则断言通常处于打开状态）。当断言关闭时， &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 的第一个参数将被忽略，而第二个参数将作为结果返回。</target>
        </trans-unit>
        <trans-unit id="2a67c621ce56962ea20451247e4968660972fdfe" translate="yes" xml:space="preserve">
          <source>Assoc</source>
          <target state="translated">Assoc</target>
        </trans-unit>
        <trans-unit id="68b22545bb595a6b43f06bac583241d8e11a31a0" translate="yes" xml:space="preserve">
          <source>AssocLeft</source>
          <target state="translated">AssocLeft</target>
        </trans-unit>
        <trans-unit id="aa2f28d5f211bc5ecef78542598f880f8e318baa" translate="yes" xml:space="preserve">
          <source>AssocNone</source>
          <target state="translated">AssocNone</target>
        </trans-unit>
        <trans-unit id="56894dfcf0b1ff176191c0989a9045db04e81fe2" translate="yes" xml:space="preserve">
          <source>AssocRight</source>
          <target state="translated">AssocRight</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">相关类型</target>
        </trans-unit>
        <trans-unit id="28d556f025319f64419ff88734b119ab1b87004b" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">关联的类型和数据实例声明不继承在封闭实例上指定的任何上下文。对于类型实例声明，尚不清楚上下文的含义。对于数据实例声明，用户不太可能希望为每个数据构造函数重复上下文。上下文可能有用的唯一地方是关联数据实例的 &lt;code&gt;deriving&lt;/code&gt; 子句。但是，即使在这里，外部实例上下文的角色也是模糊的。因此，为清楚起见，我们只是遵循上述规则：封闭的实例上下文被忽略。如果需要在派生实例上使用非平凡上下文，请使用&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt;子句（在顶层）。</target>
        </trans-unit>
        <trans-unit id="9d29f80f6f8aff1ac6afd29591fc1ab7479bcba6" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">关联的类型和数据实例声明不继承在封闭实例上指定的任何上下文。对于类型实例声明，尚不清楚上下文的含义。对于数据实例声明，用户不太可能希望为每个数据构造函数重复上下文。上下文可能有用的唯一地方是在关联数据实例的 &lt;code&gt;deriving&lt;/code&gt; 子句中。但是，即使在这里，外部实例上下文的角色也是模糊的。因此，为清楚起见，我们只遵循上述规则：封闭的实例上下文将被忽略。如果需要在派生实例上使用非平凡的上下文，请使用&lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt;子句（在顶层）。</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="1c3f48563bf3394a3a3f951813cae0818e684494" translate="yes" xml:space="preserve">
          <source>Associativity is not used to reduce the occurrence of parentheses, although precedence may be.</source>
          <target state="translated">联想性并不是用来减少小括号的出现,尽管优先性可能是。</target>
        </trans-unit>
        <trans-unit id="6b99ff8f8291b4b50e3921986b0bce0e781dbc7e" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; to write a very simple error-reporting function that does absolutely nothing in the case of success, and outputs &quot;ERROR&quot; if any error occurred.</source>
          <target state="translated">假设 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值表示某种错误，我们可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 编写一个非常简单的错误报告功能，在成功的情况下绝对不执行任何操作，如果发生任何错误，则输出&amp;ldquo; ERROR&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d055592ad02200007ba459bbee0ab4e26e918369" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; to write a very simple reporting function that only outputs &quot;SUCCESS&quot; when a computation has succeeded.</source>
          <target state="translated">假设 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值表示某种错误，我们可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 编写一个非常简单的报告函数，该函数仅在计算成功后才输出&amp;ldquo; SUCCESS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="483f89adba9ea9c40c941cf4a83fdac02ee4e4a5" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; has already been defined on the partially built structure:</source>
          <target state="translated">假设已经在部分构建的结构上定义了 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c834581788562362bcf330136a30982991522f6" translate="yes" xml:space="preserve">
          <source>Assumption: Integer is strictly positive</source>
          <target state="translated">假设。整数是严格的正数</target>
        </trans-unit>
        <trans-unit id="77fd17f027574bb2f7df35f4ef90ead2e9b60836" translate="yes" xml:space="preserve">
          <source>AsyncException</source>
          <target state="translated">AsyncException</target>
        </trans-unit>
        <trans-unit id="603f73055272502639dd306a8bca156dc618be89" translate="yes" xml:space="preserve">
          <source>AsyncIOAvailable</source>
          <target state="translated">AsyncIOAvailable</target>
        </trans-unit>
        <trans-unit id="e1aac0f84af1ee48fafd058955607776e453cc9b" translate="yes" xml:space="preserve">
          <source>Asynchronous Exceptions</source>
          <target state="translated">异步异常</target>
        </trans-unit>
        <trans-unit id="1fde34ce4b1dca7f44eebcbaf7ae6171e5ddd42a" translate="yes" xml:space="preserve">
          <source>Asynchronous exception control</source>
          <target state="translated">异步异常控制</target>
        </trans-unit>
        <trans-unit id="90e8f43c2f265d7e22350697496f72118afa53f2" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; are two examples of system-generated asynchronous exceptions.</source>
          <target state="translated">异步异常之所以被称为是因为它们是由外部影响引起的，并且可以在执行过程中的任何时候引发。 &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; 是系统生成的异步异常的两个示例。</target>
        </trans-unit>
        <trans-unit id="e9087c26270e45969905025ed0c6876268b8e459" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则处于被屏蔽状态时仍可能接收异步异常。请参见&lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="303a11aed286b513643b565c89072a6a7aa3770b" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则在处于被屏蔽状态时仍可以接收异步异常。请参见&lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cedca602451f983242010d922a6b8f21df9fe142" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则在处于被屏蔽状态时仍可以接收异步异常。请参见&lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c6f92d83ff3d5f34604121aadc15840ac708368" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则处于被屏蔽状态时仍可能接收异步异常。请参见&lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="631cd36315ff03e677e0243fa4a94f4335edad65" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions.</source>
          <target state="translated">异步异常。</target>
        </trans-unit>
        <trans-unit id="de23bf55d43f3cb1369402e7877d3faa61f2949f" translate="yes" xml:space="preserve">
          <source>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and &lt;em&gt;appends&lt;/em&gt; it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</source>
          <target state="translated">在函数调用时，GHC接收存储在被调用函数中的堆栈（对于顶层函数，该堆栈为空），然后&lt;em&gt;将&lt;/em&gt;其&lt;em&gt;追加&lt;/em&gt;到当前堆栈，而忽略与当前堆栈的前缀相同的任何前缀。</target>
        </trans-unit>
        <trans-unit id="bb19257a1286f9e500a61c5dfeacaecfe019ec79" translate="yes" xml:space="preserve">
          <source>At any time you can use the command &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt; to get a list of the modules currently loaded into GHCi:</source>
          <target state="translated">您可以随时使用命令&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;获取当前已加载到GHCi中的模块的列表：</target>
        </trans-unit>
        <trans-unit id="3461cf3addc608aea10037826585d0df504e072e" translate="yes" xml:space="preserve">
          <source>At definition site, the arity determines what inputs can be matched on:</source>
          <target state="translated">在定义站点,arity决定了哪些输入可以被匹配上。</target>
        </trans-unit>
        <trans-unit id="cc7e513d6fe875bf90b4a728f124a7f9ff012de2" translate="yes" xml:space="preserve">
          <source>At first blush, &lt;code&gt;UnEx&lt;/code&gt; seems poorly-kinded. The return kind &lt;code&gt;k&lt;/code&gt; is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of &lt;code&gt;k&lt;/code&gt;&lt;em&gt;for any&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, this is not the case. The type family &lt;code&gt;UnEx&lt;/code&gt; is a kind-indexed type family. The return kind &lt;code&gt;k&lt;/code&gt; is an implicit parameter to &lt;code&gt;UnEx&lt;/code&gt;. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</source>
          <target state="translated">乍一看， &lt;code&gt;UnEx&lt;/code&gt; 看起来很烂。参数中未提到返回类型 &lt;code&gt;k&lt;/code&gt; ，因此&lt;em&gt;对于任何&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; ，实例似乎都必须返回 &lt;code&gt;k&lt;/code&gt; 的成员。然而，这种情况并非如此。类型族 &lt;code&gt;UnEx&lt;/code&gt; 是类型索引的类型族。返回种类 &lt;code&gt;k&lt;/code&gt; 是 &lt;code&gt;UnEx&lt;/code&gt; 的隐式参数。详细的定义如下（其中隐式参数用大括号表示）：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="082a6d8510562c71bea9da704521358ac4884d2e" translate="yes" xml:space="preserve">
          <source>At least one of the classes &lt;code&gt;Ci&lt;/code&gt; is numeric.</source>
          <target state="translated">类 &lt;code&gt;Ci&lt;/code&gt; 中的至少一者是数字的。</target>
        </trans-unit>
        <trans-unit id="da4d3ab8aa4bf1c457aa64eadbb0f7599f12c862" translate="yes" xml:space="preserve">
          <source>At least one overlapped instance, &lt;code&gt;Iy&lt;/code&gt;, is both:</source>
          <target state="translated">至少有一个重叠的实例 &lt;code&gt;Iy&lt;/code&gt; 都是：</target>
        </trans-unit>
        <trans-unit id="95b0afae80408c0a928a6ff24b58dae9588bff21" translate="yes" xml:space="preserve">
          <source>At present, &lt;code&gt;-O2&lt;/code&gt; is nearly indistinguishable from &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">目前， &lt;code&gt;-O2&lt;/code&gt; 与 &lt;code&gt;-O&lt;/code&gt; 几乎没有区别。</target>
        </trans-unit>
        <trans-unit id="2d06e4b175297e1faf1e01c3741923b7d7eb11e9" translate="yes" xml:space="preserve">
          <source>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results&amp;mdash; in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of &lt;code&gt;(+)&lt;/code&gt;, for example.</source>
          <target state="translated">目前，GHC在算术方面的推理非常有限：它将仅评估算术类型函数并比较结果，就像对其他任何类型函数所做的一样。特别地，它不知道关于算术的更一般的事实，例如 &lt;code&gt;(+)&lt;/code&gt; 的可交换性和可结合性。</target>
        </trans-unit>
        <trans-unit id="14a75af6823b475d201cdaf02b67cfc7b30f5d3d" translate="yes" xml:space="preserve">
          <source>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type &lt;code&gt;TypeError&lt;/code&gt;. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</source>
          <target state="translated">在运行时，每当需要评估包含类型错误的术语时，该错误就会转换为 &lt;code&gt;TypeError&lt;/code&gt; 类型的运行时异常。请注意，在运行时会尽可能多地推迟类型错误，但是永远不会执行无效的强制，即使它们最终会导致正确的类型值。例如，给出以下代码：</target>
        </trans-unit>
        <trans-unit id="3b1e7a17deca9b74f37ec0a39800ad357611600d" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt you can also enter any top-level Haskell declaration, including &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;deriving&lt;/code&gt;, and &lt;code&gt;foreign&lt;/code&gt; declarations. For example:</source>
          <target state="translated">在GHCi提示符下，您还可以输入任何顶级Haskell声明，包括 &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;newtype&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;instance&lt;/code&gt; ， &lt;code&gt;deriving&lt;/code&gt; 和 &lt;code&gt;foreign&lt;/code&gt; 声明。例如：</target>
        </trans-unit>
        <trans-unit id="cd0949a6c29925c12d1d048d17633d245e1a3ebf" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt, or with GHC if the &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; flag is given, the types are instead resolved with the following method:</source>
          <target state="translated">在GHCi提示符下，或者如果给出&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;标志，则使用GHC ，而是使用以下方法解析类型：</target>
        </trans-unit>
        <trans-unit id="faae2aa7c10c0885466c17a8edd2f6d0318681f4" translate="yes" xml:space="preserve">
          <source>At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</source>
          <target state="translated">在采样周期结束时，将发出 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; 事件。这对于正确地划定采样周期并记录分析所花费的总时间很有用。</target>
        </trans-unit>
        <trans-unit id="4d062db617e8b184eee773ae86e765aa598c88a3" translate="yes" xml:space="preserve">
          <source>At the moment GHCi supports most of GHC&amp;rsquo;s language extensions.</source>
          <target state="translated">目前，GHCi支持GHC的大多数语言扩展。</target>
        </trans-unit>
        <trans-unit id="af7cac97440198fcc962770e0f96df4e013c2492" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command doesn&amp;rsquo;t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; will not do what you expect.</source>
          <target state="translated">目前，&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;命令在其参数中不支持任何形式的引号：引号不会被删除，也不能用于将单词组合在一起。例如， &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; 将无法满足您的期望。</target>
        </trans-unit>
        <trans-unit id="82ba5640e0de386d6cc85d3de209bb9cdb633f12" translate="yes" xml:space="preserve">
          <source>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in &lt;code&gt;build-depends&lt;/code&gt; (which uses the conventional &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</source>
          <target state="translated">目前，在Cabal中指定对插件的依赖的唯一方法是将其放入 &lt;code&gt;build-depends&lt;/code&gt; （使用常规 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 标志）；但是，将来会有单独的字段专门指定插件依赖项。</target>
        </trans-unit>
        <trans-unit id="36f6fc6a8b5e23e239eeef3e4a0f085a44f79d37" translate="yes" xml:space="preserve">
          <source>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</source>
          <target state="translated">在使用站点,arity决定了该定义是否可以在更高等级的场景中使用。</target>
        </trans-unit>
        <trans-unit id="7f078fc66826e48322f51a990469bfd247658746" translate="yes" xml:space="preserve">
          <source>Atomic blocks.</source>
          <target state="translated">原子块。</target>
        </trans-unit>
        <trans-unit id="92c10450c672866027afd2c75b1a19f1a5daa4db" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is forced.</source>
          <target state="translated">以原子方式将函数应用于 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容，并返回旧值和新值。该函数的结果是强制的。</target>
        </trans-unit>
        <trans-unit id="2e8c029e8fddf8615e7bdb4f7438b3feba64ae42" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is not forced. As this can lead to a memory leak, it is usually better to use &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式将函数应用于 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容，并返回旧值和新值。该函数的结果不是强制的。由于这可能导致内存泄漏，因此通常最好使用 &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="420f4999cbf62263237bdbe7d15cefd4576bc583" translate="yes" xml:space="preserve">
          <source>Atomically modifies the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式修改 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="5976845b8f84b952ac2fc7192f0a75f69d2927f0" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cee328d42a656c88f81a24f4db1782769f19c73" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="184b9dc038e8a43ed0e8ffb796e5fef400df0150" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be6bc09ee654abc40df66bc414fa4a9c12171cb5" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23386c18719208e0c4d15b8720f6d737027a0291" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d13722b70b72345abf719add29b1a51d34aad57" translate="yes" xml:space="preserve">
          <source>Atomically replace the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, returning the old contents.</source>
          <target state="translated">以原子方式替换 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容，并返回旧内容。</target>
        </trans-unit>
        <trans-unit id="2ab5a0a6f732e3010e4b8d4b1f44a6fc68552e9b" translate="yes" xml:space="preserve">
          <source>Attach a timeout event to arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">将超时事件附加到任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算中。</target>
        </trans-unit>
        <trans-unit id="cb303f555c293bc6ebb398fedf551b67ed2ee6e1" translate="yes" xml:space="preserve">
          <source>Attach an annotation to a document.</source>
          <target state="translated">为文档附加注释。</target>
        </trans-unit>
        <trans-unit id="83a56249e5cff48f561d2d725143f1fc2eb3228c" translate="yes" xml:space="preserve">
          <source>Attachment</source>
          <target state="translated">Attachment</target>
        </trans-unit>
        <trans-unit id="6771ade6e8965a499bc298107ffb52e9a18dd7e3" translate="yes" xml:space="preserve">
          <source>Attachments</source>
          <target state="translated">Attachments</target>
        </trans-unit>
        <trans-unit id="358b4cc5015b0aa8d923e59ec8734cadaa58c21f" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the capacity (in bytes) given by the first argument. The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous compact block of the CNF or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new CNF with a single compact block.</source>
          <target state="translated">尝试分配具有第一个参数给出的容量（以字节为单位）的紧凑块。该 &lt;code&gt;Addr#&lt;/code&gt; 是一个指针，CNF或以前的致密块状 &lt;code&gt;nullAddr#&lt;/code&gt; 创建一个新的CNF有一个紧凑的块。</target>
        </trans-unit>
        <trans-unit id="14c3e18c8fd88ff49a30c3e7b04045a40e92e438" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the given size (in bytes, given by the first argument). The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous block of the compact or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new compact.</source>
          <target state="translated">尝试分配给定大小的紧凑块（以字节为单位，由第一个参数给出）。该 &lt;code&gt;Addr#&lt;/code&gt; 是一个指向紧凑型或前一块 &lt;code&gt;nullAddr#&lt;/code&gt; 创建一个新的紧凑型。</target>
        </trans-unit>
        <trans-unit id="7aa6f2a111a7ae3d1c85ad97bb0176dbe687d1c3" translate="yes" xml:space="preserve">
          <source>Attempt to convert an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;a&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;b&lt;/code&gt; using the size of the types as measured by &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">尝试将转换 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 型 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 型 &lt;code&gt;b&lt;/code&gt; 使用如由测量的类型的大小 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 的方法。</target>
        </trans-unit>
        <trans-unit id="eb6ccc5388b3a3515cdd4a9fde980934200b5b13" translate="yes" xml:space="preserve">
          <source>Attempt to ignore and recover if an illegal sequence is encountered</source>
          <target state="translated">如果遇到非法序列,试图忽略并恢复。</target>
        </trans-unit>
        <trans-unit id="1dd801e8dde9f614ee3cf534bfcd9bf71825677c" translate="yes" xml:space="preserve">
          <source>Attempt to lock the semaphore without blocking. Immediately return False if it is not available.</source>
          <target state="translated">试图在不阻塞的情况下锁定信号体。如果不可用,立即返回False。</target>
        </trans-unit>
        <trans-unit id="5ce185b0aec3184ea8d85cd399f6b27591eecf61" translate="yes" xml:space="preserve">
          <source>Attempt to perform the given action, silencing any IO exception thrown by it.</source>
          <target state="translated">试图执行给定的操作,沉默任何由它抛出的IO异常。</target>
        </trans-unit>
        <trans-unit id="1c903a1acb600fe485f2c4a45d92c0ad8eff63d5" translate="yes" xml:space="preserve">
          <source>Attempting to use of linear types in Template Haskell will probably not work.</source>
          <target state="translated">试图在模板Haskell中使用线性类型可能不会成功。</target>
        </trans-unit>
        <trans-unit id="95eba1f265744c575faabec4b145e9a698745932" translate="yes" xml:space="preserve">
          <source>Attempts to reload the current target set (see &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</source>
          <target state="translated">如果集合中的任何模块或任何从属模块已更改，则尝试重新加载当前目标集（请参阅&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;）。请注意，这可能需要加载新模块或删除目标不再间接需要的模块。</target>
        </trans-unit>
        <trans-unit id="db06067c8f8d76e8b68fa4b9186a9b50479a85d3" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the specified process. This function should not be used under normal circumstances - no guarantees are given regarding how cleanly the process is terminated. To check whether the process has indeed terminated, use &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试终止指定的进程。在正常情况下不应使用此功能-无法保证终止过程的干净程度。要检查进程是否确实终止，请使用 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="c4b6f77c88d20ca04f9a50aec205f45262f5d7ab" translate="yes" xml:space="preserve">
          <source>Attributes in XHTML Strict</source>
          <target state="translated">严格的XHTML中的属性</target>
        </trans-unit>
        <trans-unit id="16128ba0c9d08bb0dde15482b5b394897473b886" translate="yes" xml:space="preserve">
          <source>Attributes of I/O errors</source>
          <target state="translated">I/O错误的属性</target>
        </trans-unit>
        <trans-unit id="1360a6d5f84dba15e5314081238a2fd3066ee932" translate="yes" xml:space="preserve">
          <source>Attributes with name and value.</source>
          <target state="translated">有名称和值的属性。</target>
        </trans-unit>
        <trans-unit id="993065bb1a56fd21869c669ca617b04976cb0030" translate="yes" xml:space="preserve">
          <source>Author: Ben Gamari</source>
          <target state="translated">作者:Ben Gamari Ben Gamari</target>
        </trans-unit>
        <trans-unit id="75c4b805a306f8a99221f82ad1e776dcaee1276b" translate="yes" xml:space="preserve">
          <source>Authors importing this module are expected to track development closely.</source>
          <target state="translated">希望导入本模块的作者密切跟踪开发情况。</target>
        </trans-unit>
        <trans-unit id="ac440c0ee95ad46797ff526e4fa32c25032310cf" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all CAFs</source>
          <target state="translated">自动将 &lt;code&gt;SCC&lt;/code&gt; 添加到所有CAF</target>
        </trans-unit>
        <trans-unit id="3e6d90a8087bfbc9d56637d926baaee06bb11b50" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all bindings not marked INLINE</source>
          <target state="translated">自动将 &lt;code&gt;SCC&lt;/code&gt; 添加到所有未标记为INLINE的绑定中</target>
        </trans-unit>
        <trans-unit id="926781921f42c31bb0687106a4a150bb577b974e" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all call sites</source>
          <target state="translated">自动将 &lt;code&gt;SCC&lt;/code&gt; 添加到所有呼叫站点</target>
        </trans-unit>
        <trans-unit id="aba3425843f29781a7a8d03a07af127ba3b7b9b2" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all exported bindings not marked INLINE</source>
          <target state="translated">自动将 &lt;code&gt;SCC&lt;/code&gt; 添加到所有未标记为INLINE的导出绑定中</target>
        </trans-unit>
        <trans-unit id="f39d1b641099009478c941384a7ddb92d9adc118" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all top-level bindings not marked INLINE</source>
          <target state="translated">自动将 &lt;code&gt;SCC&lt;/code&gt; 添加到所有未标记为INLINE的顶级绑定中</target>
        </trans-unit>
        <trans-unit id="fc392ab09cabed566e31abcea7714e1a9fbd59f8" translate="yes" xml:space="preserve">
          <source>AutoDeriveTypeable</source>
          <target state="translated">AutoDeriveTypeable</target>
        </trans-unit>
        <trans-unit id="0f3997661b5230a1d4a29603d354a226f203caa0" translate="yes" xml:space="preserve">
          <source>Automatically enable compacting collection when the live data exceeds ⟨n⟩% of the maximum heap size (see the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; option). Note that the maximum heap size is unlimited by default, so this option has no effect unless the maximum heap size is set with &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当活动数据超过最大堆大小的n％时，自动启用压缩收集（请参见&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;选项）。请注意，默认情况下最大堆大小是无限的，因此，除非使用&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;设置最大堆大小，否则此选项无效。</target>
        </trans-unit>
        <trans-unit id="6deb87b596d87ecee88f79fe651652c552010dcc" translate="yes" xml:space="preserve">
          <source>Available on &lt;code&gt;base &amp;gt;=4.9&lt;/code&gt;</source>
          <target state="translated">可基于 &lt;code&gt;base &amp;gt;=4.9&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e4e7aa329cbbf38ad0669fe65c87a2d764ac59f" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">避免&lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ace826e18102f6899794ad3ef89b5a4cafb9c1c" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">避免&lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d046fd0eedb33417414a7f1c2d12f68e0c748ad0" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">避免&lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6bcda3182218ed04e058e2a3e7f3b82979718dc" translate="yes" xml:space="preserve">
          <source>Avoid using Bytes constructor directly as it is likely to change in the future. Use helpers such as &lt;code&gt;mkBytes&lt;/code&gt; in Language.Haskell.TH.Lib instead.</source>
          <target state="translated">避免直接使用Bytes构造函数，因为将来可能会更改。请 &lt;code&gt;mkBytes&lt;/code&gt; Language.Haskell.TH.Lib中的mkBytes之类的助手。</target>
        </trans-unit>
        <trans-unit id="be332d307b7edd783371ed9722af4d2891b5ddd8" translate="yes" xml:space="preserve">
          <source>Avoiding multi-pass folds</source>
          <target state="translated">避免多次折腾</target>
        </trans-unit>
        <trans-unit id="ca874deaab16366191c7957785eea44d50d3a744" translate="yes" xml:space="preserve">
          <source>B0</source>
          <target state="translated">B0</target>
        </trans-unit>
        <trans-unit id="8fa6afc648cb35f98b314ec87af904a1320a565f" translate="yes" xml:space="preserve">
          <source>B110</source>
          <target state="translated">B110</target>
        </trans-unit>
        <trans-unit id="69983106476a1baa3e173eb0da9525d4e05a1e94" translate="yes" xml:space="preserve">
          <source>B115200</source>
          <target state="translated">B115200</target>
        </trans-unit>
        <trans-unit id="63db1d5e1025a5dca03dde90aaee4ab1689048ef" translate="yes" xml:space="preserve">
          <source>B1200</source>
          <target state="translated">B1200</target>
        </trans-unit>
        <trans-unit id="e74b06339c34831ce0b9ab483e8c8a61a8068208" translate="yes" xml:space="preserve">
          <source>B134</source>
          <target state="translated">B134</target>
        </trans-unit>
        <trans-unit id="a9905f37be71ad27b06428c2ae3de56996c96c7e" translate="yes" xml:space="preserve">
          <source>B150</source>
          <target state="translated">B150</target>
        </trans-unit>
        <trans-unit id="966d5ab4ced9ae0785e30c1280734e03950b8b43" translate="yes" xml:space="preserve">
          <source>B1800</source>
          <target state="translated">B1800</target>
        </trans-unit>
        <trans-unit id="e535913533dad54a5814041ea8ecb91d9eeccbc1" translate="yes" xml:space="preserve">
          <source>B19200</source>
          <target state="translated">B19200</target>
        </trans-unit>
        <trans-unit id="559bc674c0bef2843ad28f3b0807a3bc8c3a905e" translate="yes" xml:space="preserve">
          <source>B200</source>
          <target state="translated">B200</target>
        </trans-unit>
        <trans-unit id="8b9d4b133283a998a17790c5482a1a7e5ea5ef89" translate="yes" xml:space="preserve">
          <source>B2400</source>
          <target state="translated">B2400</target>
        </trans-unit>
        <trans-unit id="1100370c026795a2ba481e6ed685267255662a5a" translate="yes" xml:space="preserve">
          <source>B300</source>
          <target state="translated">B300</target>
        </trans-unit>
        <trans-unit id="967e9e4821f80944c4a011159dea85581127b02d" translate="yes" xml:space="preserve">
          <source>B38400</source>
          <target state="translated">B38400</target>
        </trans-unit>
        <trans-unit id="3e5bbebbfb2d76d5eb4a77c12b899a53cb0e824b" translate="yes" xml:space="preserve">
          <source>B4800</source>
          <target state="translated">B4800</target>
        </trans-unit>
        <trans-unit id="70e67f1d5a37cf067a56baf4ce16e1420d5e3b02" translate="yes" xml:space="preserve">
          <source>B50</source>
          <target state="translated">B50</target>
        </trans-unit>
        <trans-unit id="763970e59e7e204186ab4318ebc79d0aad573df8" translate="yes" xml:space="preserve">
          <source>B57600</source>
          <target state="translated">B57600</target>
        </trans-unit>
        <trans-unit id="e41fa1e36cc5ce5485a1da88669ebf6c181b64fc" translate="yes" xml:space="preserve">
          <source>B600</source>
          <target state="translated">B600</target>
        </trans-unit>
        <trans-unit id="0a96b59160d52c4d3a94a14b630cd642e970d726" translate="yes" xml:space="preserve">
          <source>B75</source>
          <target state="translated">B75</target>
        </trans-unit>
        <trans-unit id="38ed67ee58867b1ed339e07a0a0e350aefba9899" translate="yes" xml:space="preserve">
          <source>B9600</source>
          <target state="translated">B9600</target>
        </trans-unit>
        <trans-unit id="d9004f19dea2dc973e0d147f71242cc2bebca3f3" translate="yes" xml:space="preserve">
          <source>BCO#</source>
          <target state="translated">BCO#</target>
        </trans-unit>
        <trans-unit id="d387e5e412686186588f12198f87a79c11ecf2f3" translate="yes" xml:space="preserve">
          <source>BLACK STAR</source>
          <target state="translated">黑星</target>
        </trans-unit>
        <trans-unit id="ed7592b91885c70d24cf8681c067a4604fe9f9a7" translate="yes" xml:space="preserve">
          <source>BN#</source>
          <target state="translated">BN#</target>
        </trans-unit>
        <trans-unit id="292c7af4fff95bcd09dba6dcdd4b5f6d636b95c8" translate="yes" xml:space="preserve">
          <source>BOOL</source>
          <target state="translated">BOOL</target>
        </trans-unit>
        <trans-unit id="42c5e705983ae56cd93e4c5f6314e815eb160593" translate="yes" xml:space="preserve">
          <source>BSD-style</source>
          <target state="translated">BSD-style</target>
        </trans-unit>
        <trans-unit id="9332433de0ed1632f2bcc6d0a44e38c2f119263d" translate="yes" xml:space="preserve">
          <source>BSD-style (see LICENSE)</source>
          <target state="translated">BSD-style(见LICENSE)</target>
        </trans-unit>
        <trans-unit id="44f04e5b329f5940c142f534423ac2c4e47a1a2d" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file in the distribution)</source>
          <target state="translated">BSD风格(参见发行版中的LICENSE文件)。</target>
        </trans-unit>
        <trans-unit id="c6ca990beea2501ec303342859beced421c42eb6" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file)</source>
          <target state="translated">BSD风格(见LICENSE文件)。</target>
        </trans-unit>
        <trans-unit id="965d82d9479d90e4c8debb630580bf0a1b1ba92f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE in this distribution)</source>
          <target state="translated">BSD风格(参见本发行版中的LICENSE文件)。</target>
        </trans-unit>
        <trans-unit id="768626facad260a6f891ec7130589a5f3309d501" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE)</source>
          <target state="translated">BSD风格(见文件LICENSE)。</target>
        </trans-unit>
        <trans-unit id="81e1671a0b4eeb6f499727101f56c68023874e7f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/base/LICENSE)</source>
          <target state="translated">BSD 风格(见文件库/base/LICENSE)。</target>
        </trans-unit>
        <trans-unit id="ef57f6a3a070b95b64e77f5a36de3561ef544d65" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/parsec/LICENSE)</source>
          <target state="translated">BSD 风格(见文件库/parsec/LICENSE)。</target>
        </trans-unit>
        <trans-unit id="19a47f35c441c8dd2576f588079955402fb90b82" translate="yes" xml:space="preserve">
          <source>BSD3</source>
          <target state="translated">BSD3</target>
        </trans-unit>
        <trans-unit id="7f9c1e64342b8d68000ad605b095d79dad9a02d3" translate="yes" xml:space="preserve">
          <source>BSD3-style (see LICENSE)</source>
          <target state="translated">BSD3-风格(见许可证</target>
        </trans-unit>
        <trans-unit id="1d7caa593761d5e9b3a933c7c28bf276e5fe0725" translate="yes" xml:space="preserve">
          <source>BYTE</source>
          <target state="translated">BYTE</target>
        </trans-unit>
        <trans-unit id="c6d4a87dd731399addc42bfa4639f9363a8c4260" translate="yes" xml:space="preserve">
          <source>BY_HANDLE_FILE_INFORMATION</source>
          <target state="translated">BY_HANDLE_FILE_INFORMATION</target>
        </trans-unit>
        <trans-unit id="80ed9fd98b57c91f78562ce126c39ae7b67ed567" translate="yes" xml:space="preserve">
          <source>Back-quotes work as for expressions, both for type constructors and type variables; e.g. &lt;code&gt;Int `Either` Bool&lt;/code&gt;, or &lt;code&gt;Int `a` Bool&lt;/code&gt;. Similarly, parentheses work the same; e.g. &lt;code&gt;(:*:) Int Bool&lt;/code&gt;.</source>
          <target state="translated">反引号和表达式一样，都适用于类型构造函数和类型变量。例如 &lt;code&gt;Int `Either` Bool&lt;/code&gt; 或Int`a` &lt;code&gt;Int `a` Bool&lt;/code&gt; 。同样，括号的作用相同。例如 &lt;code&gt;(:*:) Int Bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe2ff7fc27afe7d547b5eb980ad60a5d316a61a8" translate="yes" xml:space="preserve">
          <source>Background: some systems have a Non-Uniform Memory Architecture, whereby main memory is split into banks which are &amp;ldquo;local&amp;rdquo; to specific CPU cores. Accessing local memory is faster than accessing remote memory. The OS provides APIs for allocating local memory and binding threads to particular CPU cores, so that we can ensure certain memory accesses are using local memory.</source>
          <target state="translated">背景：某些系统具有非统一内存体系结构，因此主内存被拆分为特定CPU核&amp;ldquo;本地&amp;rdquo;的存储体。访问本地内存比访问远程内存更快。该操作系统提供用于分配本地内存并将线程绑定到特定CPU内核的API，以便我们可以确保某些内存访问正在使用本地内存。</target>
        </trans-unit>
        <trans-unit id="72bac718669114015a5f4f323dbfd19315cc9c1e" translate="yes" xml:space="preserve">
          <source>BackgroundWriteInterrupt</source>
          <target state="translated">BackgroundWriteInterrupt</target>
        </trans-unit>
        <trans-unit id="95e848a0c727105f2393d59e2c3843e625c17c16" translate="yes" xml:space="preserve">
          <source>Backwards</source>
          <target state="translated">Backwards</target>
        </trans-unit>
        <trans-unit id="13be7afef8413dabb18fb208bcddc8487eccc989" translate="yes" xml:space="preserve">
          <source>Bang</source>
          <target state="translated">Bang</target>
        </trans-unit>
        <trans-unit id="8c8ebd2c416a792dfc576bb10ca4e468125c1a6e" translate="yes" xml:space="preserve">
          <source>Bang patterns (&lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;) makes pattern matching and let bindings stricter.</source>
          <target state="translated">Bang模式（&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt;）使模式匹配并使绑定更加严格。</target>
        </trans-unit>
        <trans-unit id="5ec90a9a17a2969ccda25430595be20a569e3fe9" translate="yes" xml:space="preserve">
          <source>Bang patterns and strict matching do not affect the type system in any way.</source>
          <target state="translated">爆炸模式和严格匹配丝毫不影响类型系统。</target>
        </trans-unit>
        <trans-unit id="4331913421f3f413f4d723cb7bf92c5118afdbaf" translate="yes" xml:space="preserve">
          <source>Bang patterns work in &lt;code&gt;case&lt;/code&gt; expressions too, of course:</source>
          <target state="translated">当然，爆炸模式也适用于 &lt;code&gt;case&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="50466cee465187abc9af9cab7155eae9f7c01b4f" translate="yes" xml:space="preserve">
          <source>BangPatterns</source>
          <target state="translated">BangPatterns</target>
        </trans-unit>
        <trans-unit id="23753b97b7d02a9e0370366e9fbeda13137a82c9" translate="yes" xml:space="preserve">
          <source>BangQ</source>
          <target state="translated">BangQ</target>
        </trans-unit>
        <trans-unit id="48d652eba9b41d0c825ca713155f565dc1ca77d2" translate="yes" xml:space="preserve">
          <source>BangType</source>
          <target state="translated">BangType</target>
        </trans-unit>
        <trans-unit id="b5159683817a7c6e14cfc2ce8186bac739ef41b1" translate="yes" xml:space="preserve">
          <source>BangTypeQ</source>
          <target state="translated">BangTypeQ</target>
        </trans-unit>
        <trans-unit id="b97a50336dc10f904675fe44fbb4e1e0f9f62610" translate="yes" xml:space="preserve">
          <source>Bart Massey &amp;lt;bart@cs.pdx.edu&amp;gt;</source>
          <target state="translated">巴特&amp;middot;梅西&amp;lt;bart@cs.pdx.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="15c502386eb41ec778f48f0426dd044e61902a8f" translate="yes" xml:space="preserve">
          <source>Based on the original Text.Html library by Andy Gill. See &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; for an introduction to that library.</source>
          <target state="translated">基于Andy Gill的原始Text.Html库。有关该库的介绍，请参见&lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2140f37579f36362da3719562444661d727afe4" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">基本 &lt;code&gt;Integer&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="ee73c6548371a6788caa59207b82400814c02764" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Monad&lt;/code&gt; functions</source>
          <target state="translated">基本的 &lt;code&gt;Monad&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="c88db86b8d674e03dbcad77f83787a7e61a8e034" translate="yes" xml:space="preserve">
          <source>Basic Input and output</source>
          <target state="translated">基本输入和输出</target>
        </trans-unit>
        <trans-unit id="f9b3e5bd963e2b38618aa474b3e7102fc295adcc" translate="yes" xml:space="preserve">
          <source>Basic UTF-8 validation and character manipulation.</source>
          <target state="translated">基本的UTF-8验证和字符操作。</target>
        </trans-unit>
        <trans-unit id="9568da19057c26bab59b9243581c623c02943b7f" translate="yes" xml:space="preserve">
          <source>Basic arrow definitions, based on</source>
          <target state="translated">箭头的基本定义,依据是</target>
        </trans-unit>
        <trans-unit id="6a1b59604dd8bf31bed9746b89fda90c3467c9aa" translate="yes" xml:space="preserve">
          <source>Basic concurrency operations</source>
          <target state="translated">基本并发操作</target>
        </trans-unit>
        <trans-unit id="0c54046043ce73859746be9b39ba7b190dacdaf6" translate="yes" xml:space="preserve">
          <source>Basic concurrency stuff.</source>
          <target state="translated">基本并发的东西。</target>
        </trans-unit>
        <trans-unit id="a7e69e7791ed667a403de47b04497c349887deca" translate="yes" xml:space="preserve">
          <source>Basic data types</source>
          <target state="translated">基本数据类型</target>
        </trans-unit>
        <trans-unit id="c9d432205b7dc1b2af1472a1dcd6e06b2740bef0" translate="yes" xml:space="preserve">
          <source>Basic data types and classes.</source>
          <target state="translated">基本数据类型和类。</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="b9548c7037e25b8bf7a7572126d2cc1b16e01f80" translate="yes" xml:space="preserve">
          <source>Basic interface</source>
          <target state="translated">基本接口</target>
        </trans-unit>
        <trans-unit id="ea133ee8187b37bb71d85236dac3108829ef4b40" translate="yes" xml:space="preserve">
          <source>Basic kinds</source>
          <target state="translated">基本种类</target>
        </trans-unit>
        <trans-unit id="50a832ade293f6e2e4b29e68fbed8adbb4f5292b" translate="yes" xml:space="preserve">
          <source>Basic non-strict arrays.</source>
          <target state="translated">基本的非严格数组。</target>
        </trans-unit>
        <trans-unit id="5f012dfa959f01c06a8f22651163550a83550e42" translate="yes" xml:space="preserve">
          <source>Basic numeric class.</source>
          <target state="translated">基本的数字类。</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="25c075b5afd0fa65abaa64881721f9e82dad1e33" translate="yes" xml:space="preserve">
          <source>Basic operations on type-level Booleans.</source>
          <target state="translated">对类型级布尔的基本操作。</target>
        </trans-unit>
        <trans-unit id="ce2e8249a9c31f9132666369cb296c36dc8cbe0d" translate="yes" xml:space="preserve">
          <source>Basic type classes</source>
          <target state="translated">基本类型类</target>
        </trans-unit>
        <trans-unit id="5f5e9b287612ac50252f03aed2ec4f912c26ab6b" translate="yes" xml:space="preserve">
          <source>Basic types for the implementation of IO Handles.</source>
          <target state="translated">实现IO手柄的基本类型。</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">基本用途。</target>
        </trans-unit>
        <trans-unit id="57869d5cb688abb53fb6a3ccefe136c430873b62" translate="yes" xml:space="preserve">
          <source>BasicFormat</source>
          <target state="translated">BasicFormat</target>
        </trans-unit>
        <trans-unit id="edd76f36427e0be6ee4ea72fcc2b48f9dc5f829a" translate="yes" xml:space="preserve">
          <source>BaudRate</source>
          <target state="translated">BaudRate</target>
        </trans-unit>
        <trans-unit id="13b75e02d46b87821b8e6bb2e907caf22536eaeb" translate="yes" xml:space="preserve">
          <source>Be aware of that &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; do require filenames containing spaces to be escaped using quotes:</source>
          <target state="translated">请注意， &lt;code&gt;ghc&lt;/code&gt; 和 &lt;code&gt;ghci&lt;/code&gt; 确实要求使用引号将包含空格的文件名转义：</target>
        </trans-unit>
        <trans-unit id="2a750147c0b7e7b2524f6f876a3edd09786994a4" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">注意'fromList'。toList = id'仅适用于未冻结的 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 会删除冻结信息。</target>
        </trans-unit>
        <trans-unit id="833fbd733b968c1c689e377b206c44a8ba2c1393" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">注意'fromList'。toList = id'仅适用于未冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 会删除冻结信息。</target>
        </trans-unit>
        <trans-unit id="8b4f2dc8bf0c5571de02a483e44a0efdc7eb624d" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">注意'fromList'。toList = id'仅适用于未冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 会删除冻结信息。</target>
        </trans-unit>
        <trans-unit id="4dc420edbf82aa0a2fac0909c5f04bacaae0ad94" translate="yes" xml:space="preserve">
          <source>Be careful not to recompile any packages that GHC itself depends on, as this may render the &lt;code&gt;ghc&lt;/code&gt; package itself broken, and &lt;code&gt;ghc&lt;/code&gt; cannot be simply recompiled. The only way to recover from this would be to re-install GHC.</source>
          <target state="translated">注意不要重新编译GHC本身依赖的任何软件包，因为这可能会使 &lt;code&gt;ghc&lt;/code&gt; 软件包本身损坏，并且不能简单地重新编译 &lt;code&gt;ghc&lt;/code&gt; 。从中恢复的唯一方法是重新安装GHC。</target>
        </trans-unit>
        <trans-unit id="6e58b8e7a7708dab3c9a2bfb9884abe1e3e42613" translate="yes" xml:space="preserve">
          <source>Be careful when using all the processors in your machine: if some of your processors are in use by other programs, this can actually harm performance rather than improve it. Asking GHC to create more capabilities than you have physical threads is almost always a bad idea.</source>
          <target state="translated">在使用机器中的所有处理器时要小心:如果你的一些处理器被其他程序使用,这实际上会损害而不是提高性能。要求GHC创建比你的物理线程更多的功能几乎总是一个坏主意。</target>
        </trans-unit>
        <trans-unit id="030ba515acd2d25ee94d7a99ab66ba47851bdf13" translate="yes" xml:space="preserve">
          <source>Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; to check that the called foreign function is prepared to deal with the consequences of the call being interrupted. On Unix it is considered good practice to always check for &lt;code&gt;EINTR&lt;/code&gt; after system calls, so you can expect it not to crash (but in that case &lt;code&gt;interruptible&lt;/code&gt; will not work as intended unless the code then returns all the way up to Haskell as described above). But on Windows it is not typically common practice to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;interruptible&lt;/code&gt; 检查被调用的外部函数是否已准备好处理调用被中断的后果时，请特别小心。在Unix上，最好在系统调用后始终检查 &lt;code&gt;EINTR&lt;/code&gt; ，这是一种好习惯，因此可以预期它不会崩溃（但在这种情况下，除非代码如上所述如上所述一直返回到Haskell，否则 &lt;code&gt;interruptible&lt;/code&gt; 不会按预期工作） 。但是在Windows上，通常不常见的做法是处理 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e6215070ac7ba503783ef4dcd9847d43461c01e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">警告， &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 并不严格应用该功能。这意味着，如果程序多次调用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; ，但很少使用该值，则重击将堆积在内存中，从而导致空间泄漏。当使用IORef作为计数器时，这是一个常见的错误。例如，以下可能会产生堆栈溢出：</target>
        </trans-unit>
        <trans-unit id="1e632134338b9cc24cdcec9c2ad59ac6cbe767e2" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">警告， &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 并不严格应用该功能。这意味着，如果程序多次调用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; ，但很少使用该值，则重击将堆积在内存中，从而导致空间泄漏。使用IORef作为计数器时，这是一个常见的错误。例如，以下可能会产生堆栈溢出：</target>
        </trans-unit>
        <trans-unit id="55340cb5b344cb0896b46c3e02107cead57c765e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">警告， &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 并不严格应用该功能。这意味着，如果程序多次调用 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; ，但很少使用该值，则重击将堆积在内存中，从而导致空间泄漏。当使用 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 作为计数器时，这是一个常见的错误。例如，以下内容将泄漏内存，并可能产生堆栈溢出：</target>
        </trans-unit>
        <trans-unit id="9146268e3a870b89574a63d603a9a4c2b804fc8e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">警告， &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 并不严格应用该功能。这意味着，如果程序多次调用 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; ，但很少使用该值，则重击将堆积在内存中，从而导致空间泄漏。使用 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 作为计数器时，这是一个常见的错误。例如，以下内容将泄漏内存，并可能产生堆栈溢出：</target>
        </trans-unit>
        <trans-unit id="1ac5eb692c23fe608a9eb6b4fa5f11c0d62b8835" translate="yes" xml:space="preserve">
          <source>Be warned, these functions can be used to construct ill-kinded type representations.</source>
          <target state="translated">请注意,这些函数可以被用来构建恶意的类型表示。</target>
        </trans-unit>
        <trans-unit id="7554aac55bd08ae4a1829bdc1657e239450fe1f9" translate="yes" xml:space="preserve">
          <source>Be warned: this is an experimental facility, with fewer checks than usual. Use &lt;code&gt;-dcore-lint&lt;/code&gt; to typecheck the desugared program. If Core Lint is happy you should be all right.</source>
          <target state="translated">请注意：这是实验设施，检查次数比平时少。使用 &lt;code&gt;-dcore-lint&lt;/code&gt; 来检查已终止的程序。如果Core Lint很高兴，那么您应该没事。</target>
        </trans-unit>
        <trans-unit id="fdd46744a0edc96d38a6d8119838b4d615e82dd7" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">请记住，关联的族实例的&lt;em&gt;右侧&lt;/em&gt;也可能包含&lt;em&gt;种类&lt;/em&gt;参数（通过使用&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;扩展名）。例如，此类和实例是完全可以接受的：</target>
        </trans-unit>
        <trans-unit id="0e4123c9a7cc2c0e3ec676685e293b58dd27e565" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">请记住，关联的族实例的&lt;em&gt;右侧&lt;/em&gt;也可能包含&lt;em&gt;种类&lt;/em&gt;参数（通过使用&lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;扩展名）。例如，此类和实例是完全可以接受的：</target>
        </trans-unit>
        <trans-unit id="7efc4e2f9d66a82f758a773da6630b93a7985e7a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">因为 &lt;code&gt;-&lt;/code&gt; 在Haskell语法中专门处理-，所以 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 不是节，而是前缀否定的应用。但是， &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 等同于不允许的部分。</target>
        </trans-unit>
        <trans-unit id="5c608a2b36ee0d8fe295adfc9f68da466a5a7382" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">因为 &lt;code&gt;-&lt;/code&gt; 在Haskell语法中专门处理-，所以 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 不是节，而是前缀否定的应用。但是， &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 等同于不允许的部分。</target>
        </trans-unit>
        <trans-unit id="8b2c5ca5dad541aa7265cf458075ac55886113df" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; is the only field of &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; depending on &lt;code&gt;m&lt;/code&gt;, the expression &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; leads to a type error from being too general. This function works around that issue, and may become unnecessary if another field depending on &lt;code&gt;m&lt;/code&gt; is added.</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; 是取决于 &lt;code&gt;m&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; 的唯一字段，所以表达式 &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; 会导致类型错误，因为它过于笼统。此函数解决该问题，并且如果添加了另一个取决于 &lt;code&gt;m&lt;/code&gt; 的字段，则可能变得不必要。</target>
        </trans-unit>
        <trans-unit id="8b457de1c6b2d821b49b86e8b76d929d48f11800" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">因为 &lt;code&gt;~&lt;/code&gt; 是更常见的等式关系，所以除非设置了&lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; ,&lt;/a&gt;否则GHC会像 &lt;code&gt;~&lt;/code&gt; 一样打印 &lt;code&gt;~~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5e7e24ec7e3c0fdbaa3e27a95a2858ab8e68585" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">因为 &lt;code&gt;~&lt;/code&gt; 是更常见的等式关系，所以除非设置了&lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; ,&lt;/a&gt;否则GHC 像 &lt;code&gt;~&lt;/code&gt; 一样打印 &lt;code&gt;~~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7118064a4d44aa8f245264afef0d428f57c57f6" translate="yes" xml:space="preserve">
          <source>Because Haskell objects and libraries tend to be large, it can take many real seconds to slurp the bits to/from a remote filesystem.</source>
          <target state="translated">因为 Haskell 对象和库往往很大,所以它可能需要很多实际的秒数来吞吐远程文件系统的位。</target>
        </trans-unit>
        <trans-unit id="72e3d53125a21f513cc7ad6223feeb5607db810b" translate="yes" xml:space="preserve">
          <source>Because bounded primitives are the more general case, in this documentation we only refer to fixed size primitives where it matters that the resulting sequence of bytes is of a fixed length. Otherwise, we just refer to bounded size primitives.</source>
          <target state="translated">因为有界基元是更普遍的情况,所以在本文档中,我们只引用固定大小的基元,因为所产生的字节序列的长度是固定的。否则,我们只引用有界大小的基元。</target>
        </trans-unit>
        <trans-unit id="b5fdc31bfd5809c4f1c4e511c746ab15cfe4b9d1" translate="yes" xml:space="preserve">
          <source>Because local fixity declarations are technically Haskell 98, no extension is necessary to enable them.</source>
          <target state="translated">因为本地固定性声明在技术上是Haskell 98的,所以不需要扩展来启用它们。</target>
        </trans-unit>
        <trans-unit id="de8ee7dd4338a2055669c56f86b3139945bd3682" translate="yes" xml:space="preserve">
          <source>Because of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; is unclear name, we use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; for alias of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 的名称不清楚，因此我们将 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; 用作 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="5fcb8636cfa970f434fa5b94db2cb53e2de61b75" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;#12971&lt;/a&gt; for more.</source>
          <target state="translated">由于工具链的限制，我们无法在Windows上支持完整的Unicode路径。在Windows上，我们最多支持Latin-1。有关更多信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;＃12971&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fbf59b2f9a8d04abba49afed510bca079acda23" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;Issue #12971&lt;/a&gt; for more.</source>
          <target state="translated">由于工具链的限制，我们无法在Windows上支持完整的Unicode路径。在Windows上，我们最多支持Latin-1。有关更多信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;问题＃12971&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1351fede99f7574d382011519c832e48e2febe1" translate="yes" xml:space="preserve">
          <source>Because of the aggressive optimization that GHC performs to the programs it compiles it is quite difficult to pin-point exactly which point in the source program a given machine instruction should be attributed to. In fact, internally GHC associates each instruction with a &lt;strong&gt;set&lt;/strong&gt; of source locations. When emitting the standard debug information used by &lt;code&gt;gdb&lt;/code&gt; and other language-agnostic debugging tools, GHC is forced to heuristically choose one location from among this set.</source>
          <target state="translated">由于GHC对它进行编译的程序进行了积极的优化，因此很难准确地指出给定机器指令应归属于源程序中的哪一点。实际上，GHC在内部将每个指令与一&lt;strong&gt;组&lt;/strong&gt;源位置相关联。当发出 &lt;code&gt;gdb&lt;/code&gt; 和其他与语言无关的调试工具使用的标准调试信息时，GHC被迫从该组中试探性地选择一个位置。</target>
        </trans-unit>
        <trans-unit id="526af66ce39268b28da886109bb8d1f1638720be" translate="yes" xml:space="preserve">
          <source>Because of the lack of an outermost &lt;code&gt;forall&lt;/code&gt; in the type of &lt;code&gt;MkT&lt;/code&gt;, the &lt;code&gt;b&lt;/code&gt; would be implicitly quantified. In effect, it would be as if one had written &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt;, which contains nested &lt;code&gt;forall&lt;/code&gt;s. See &lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;Formal syntax for GADTs&lt;/a&gt;.</source>
          <target state="translated">由于缺少 &lt;code&gt;MkT&lt;/code&gt; 类型的最外面的 &lt;code&gt;forall&lt;/code&gt; ，因此 &lt;code&gt;b&lt;/code&gt; 将被隐式量化。实际上，就好像一个人写了 &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt; （forall a。a-&amp;gt; b-&amp;gt; T），其中包含嵌套的 &lt;code&gt;forall&lt;/code&gt; s。请参阅&lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;GADT的形式语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d22c87e1c1a19e64881fa0a5c29ea8d152160afd" translate="yes" xml:space="preserve">
          <source>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; should come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;-l ⟨bar⟩&lt;/code&gt; on the command line.</source>
          <target state="translated">由于大多数UNIX链接器的状态令人沮丧，因此这些选项的顺序确实很重要。如果库⟨foo⟩需要库⟨bar⟩，则通常 &lt;code&gt;-l ⟨bar⟩&lt;/code&gt; 在命令行上应位于 &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aefb27d5d1f818fec24e956de3be5cc43a462d50" translate="yes" xml:space="preserve">
          <source>Because of this, unlike &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, explicit binding of type/kind variables in default declarations is not permitted by &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">因此，与&lt;a href=&quot;#assoc-inst&quot;&gt;Associated实例&lt;/a&gt;不同，&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;不允许在默认声明中显式绑定类型/种类变量。</target>
        </trans-unit>
        <trans-unit id="f47acccf5b190df69b3205bc25cdf837d4bc4d64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;IArray&lt;/code&gt; interface provides operations overloaded on the type of the array, it should be possible to just change the array type being used by a program from say &lt;code&gt;Array&lt;/code&gt; to &lt;code&gt;UArray&lt;/code&gt; to get the benefits of unboxed arrays (don't forget to import &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; instead of &lt;a href=&quot;data-array&quot;&gt;Data.Array&lt;/a&gt;).</source>
          <target state="translated">因为 &lt;code&gt;IArray&lt;/code&gt; 接口提供的操作会重载数组类型，所以应该可以将程序使用的数组类型从 &lt;code&gt;Array&lt;/code&gt; 更改为 &lt;code&gt;UArray&lt;/code&gt; 以获得拆箱数组的好处（不要忘记导入&lt;a href=&quot;data-array-unboxed&quot;&gt;Data。 Array.Unboxed&lt;/a&gt;而不是&lt;a href=&quot;data-array&quot;&gt;Data.Array&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="73825efb186a67ab4235b4b330529ec46440f89c" translate="yes" xml:space="preserve">
          <source>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be levity-polymorphic.</source>
          <target state="translated">因为代码生成器必须存储和移动参数以及变量,所以上面的逻辑同样适用于函数参数,而函数参数可能不是浮力多态的。</target>
        </trans-unit>
        <trans-unit id="0b922e23af5d396ea51043a6f5495cb7265ef575" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">由于指数必须为这些错误进行检查， &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 是严格的界限参数，并在关联表的索引，但非严格的值。因此，可能会发生以下类似情况：</target>
        </trans-unit>
        <trans-unit id="744b8a2e53d06a3c0594d327e50d361273a6ea66" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list. Whether &lt;code&gt;array&lt;/code&gt; is strict or non-strict in the elements depends on the array type: &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; is a non-strict array type, but all of the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; arrays are strict. Thus in a non-strict array, recurrences such as the following are possible:</source>
          <target state="translated">由于指数必须为这些错误进行检查， &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 是在边界争论，并在关联表的索引严格。是否 &lt;code&gt;array&lt;/code&gt; 是在元件严格或非严格取决于阵列类型： &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 是一种非严格阵列型，但所有的的 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 阵列是严格。因此，在非严格数组中，可能会发生以下类似的重复：</target>
        </trans-unit>
        <trans-unit id="1ead8ebe60edd2b98db40ca3daeca484e250542a" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">由于指数必须为这些错误进行检查， &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 是严格的界限参数，并在关联表的索引，但非严格的值。因此，可能会发生以下类似情况：</target>
        </trans-unit>
        <trans-unit id="3877a6244217b5631d19062ad9620975d2dde55e" translate="yes" xml:space="preserve">
          <source>Because the preprocessor targets Haskell (rather than Core), &lt;code&gt;let&lt;/code&gt;-bound variables are monomorphic.</source>
          <target state="translated">因为预处理器针对Haskell（而不是Core），所以 &lt;code&gt;let&lt;/code&gt; 绑定变量是单态的。</target>
        </trans-unit>
        <trans-unit id="808844f69c7e9605bc105a4ad20ea2d366849e5a" translate="yes" xml:space="preserve">
          <source>Because there is no unboxed unit tuple, the following expression</source>
          <target state="translated">因为没有开箱的单元元组,所以有以下表达式</target>
        </trans-unit>
        <trans-unit id="76fec9d9feb8d4cfd75fa0cf83ef0298228be150" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">由于刻薄的概要分析需要对GHC内部有一定的了解，因此我们已将文档移至GHC开发人员Wiki。看一下它对&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;概要分析选项的概述&lt;/a&gt;，其中包括指向棘手的概要分析页面的链接。</target>
        </trans-unit>
        <trans-unit id="50cb7c0b41fc81c206b893c65bdf7993f9032da2" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">由于刻薄的概要分析需要对GHC内部有一定的了解，因此我们已将文档移至GHC开发人员Wiki。看一下它对&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;概要分析选项的概述&lt;/a&gt;，其中包括指向棘手的概要分析页面的链接。</target>
        </trans-unit>
        <trans-unit id="0697b298a873826983783cd5e687ae37a97dd6a7" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includes a link to the ticky-ticky profiling page.</source>
          <target state="translated">由于刻薄的概要分析需要对GHC内部有一定的了解，因此我们已将文档移至GHC开发人员Wiki。看一下它的&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;概要分析选项概述&lt;/a&gt;，其中包括指向棘手的概要分析页面的链接。</target>
        </trans-unit>
        <trans-unit id="2d85fe57284106ee9c63c6a96e2335fd4a4543d3" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in a polymorphic datatype. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">因为未装箱的类型是在不使用指针的情况下表示的，所以我们不能将它们存储在多态数据类型中。例如， &lt;code&gt;Just&lt;/code&gt; 的节点 &lt;code&gt;Just 42#&lt;/code&gt; 将必须是从不同的 &lt;code&gt;Just&lt;/code&gt; 的节点 &lt;code&gt;Just 42&lt;/code&gt; ; 前者直接存储一个整数，而后者存储一个指针。GHC当前不支持多种 &lt;code&gt;Just&lt;/code&gt; 节点（也不支持任何其他数据类型）。因此，&lt;em&gt;一种&lt;/em&gt;未装箱型的是从一种装箱类型的不同。</target>
        </trans-unit>
        <trans-unit id="f3d41195121db8c561952d390998012e5adf5323" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in use a polymorphic datatype at an unboxed type. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">因为未装箱的类型是在不使用指针的情况下表示的，所以我们不能以未装箱的类型使用多态数据类型来存储它们。例如， &lt;code&gt;Just&lt;/code&gt; 的节点 &lt;code&gt;Just 42#&lt;/code&gt; 将必须是从不同的 &lt;code&gt;Just&lt;/code&gt; 的节点 &lt;code&gt;Just 42&lt;/code&gt; ; 前者直接存储整数，而后者存储指针。GHC当前不支持多种 &lt;code&gt;Just&lt;/code&gt; 节点（也不支持任何其他数据类型）。因此，&lt;em&gt;一种&lt;/em&gt;未装箱型的是从一种装箱类型的不同。</target>
        </trans-unit>
        <trans-unit id="fe6fce85b24f15b5d65932c379eeca8ae6b18466" translate="yes" xml:space="preserve">
          <source>Becomes this:</source>
          <target state="translated">变成了这样。</target>
        </trans-unit>
        <trans-unit id="0ef17ad67edcf83107e1af3022c4061c85509f1d" translate="yes" xml:space="preserve">
          <source>Before data is written, it is first encoded as UTF-8.</source>
          <target state="translated">在写入数据之前,首先将其编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="595c4c743cb61dcc0704188c65ab1109a331f426" translate="yes" xml:space="preserve">
          <source>Before going into the Safe Haskell details, let&amp;rsquo;s point out some of the reasons this security mechanism would fail without Safe Haskell:</source>
          <target state="translated">在进入Safe Haskell详细信息之前，让我们指出一些没有Safe Haskell的安全机制将失败的原因：</target>
        </trans-unit>
        <trans-unit id="74554fdf503e2d7e6e96019d0ebd03e229b9e50a" translate="yes" xml:space="preserve">
          <source>Before resorting to explicit unboxed types, try using strict constructor fields and &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; first (see above). That way, your code stays portable.</source>
          <target state="translated">在使用显式的未装箱类型之前，请先尝试使用严格的构造函数字段和&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;（请参见上文）。这样，您的代码将保持可移植性。</target>
        </trans-unit>
        <trans-unit id="c505eb2064aacbd9cf542da06128d3e808f292b7" translate="yes" xml:space="preserve">
          <source>Before using the Continuation monad, be sure that you have a firm understanding of continuation-passing style and that continuations represent the best solution to your particular design problem. Many algorithms which require continuations in other languages do not require them in Haskell, due to Haskell's lazy semantics. Abuse of the Continuation monad can produce code that is impossible to understand and maintain.</source>
          <target state="translated">在使用Continuation monad之前,请确保你对Continuation-passing风格有一个坚定的理解,并且Continuation代表了你特定设计问题的最佳解决方案。由于 Haskell 的懒惰语义,许多在其他语言中需要延续的算法在 Haskell 中并不需要。滥用Continuation单体会产生无法理解和维护的代码。</target>
        </trans-unit>
        <trans-unit id="2da8e18ee240f54f494c1090de6f01f19305fb9e" translate="yes" xml:space="preserve">
          <source>Before you get too carried away working at the lowest level (e.g., sloshing &lt;code&gt;MutableByteArray#&lt;/code&gt;s around your program), you may wish to check if there are libraries that provide a &amp;ldquo;Haskellised veneer&amp;rdquo; over the features you want. The separate &lt;a href=&quot;../libraries/index&quot;&gt;libraries documentation&lt;/a&gt; describes all the libraries that come with GHC.</source>
          <target state="translated">在您开始从事最低级别的工作（例如，在程序周围晃动 &lt;code&gt;MutableByteArray#&lt;/code&gt; ）之前，您可能希望检查是否有库在所需的功能上提供了&amp;ldquo; Haskellised veneer&amp;rdquo;。单独的&lt;a href=&quot;../libraries/index&quot;&gt;库文档&lt;/a&gt;描述了GHC随附的所有库。</target>
        </trans-unit>
        <trans-unit id="6e79eaaaac969988bacd211dc7719f705249b6b2" translate="yes" xml:space="preserve">
          <source>Begin or end a multi-line GHCi command block.</source>
          <target state="translated">开始或结束一个多行GHCi命令块。</target>
        </trans-unit>
        <trans-unit id="aaa2d30b9548c8c6360214c67d65f8f2b43a2ef2" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to lock</source>
          <target state="translated">要锁定的文件的起始偏移量</target>
        </trans-unit>
        <trans-unit id="a88e403def4a0ef34fb4cbdd6fb4234e3d4de40f" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to unlock</source>
          <target state="translated">要解锁的文件的起始偏移量</target>
        </trans-unit>
        <trans-unit id="a603260088041becc44147197033a240091e8107" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 6.12, text I/O is performed using the system or handle's current locale and line ending conventions.</source>
          <target state="translated">从GHC 6.12开始,文本I/O使用系统或句柄的当前locale和行结束惯例来执行。</target>
        </trans-unit>
        <trans-unit id="f3aa22597a1e0633e605134fce9271b6f0ab9592" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 7.2, it is possible to use binary serialization without writing any instance boilerplate code.</source>
          <target state="translated">从GHC 7.2开始,可以在不编写任何实例模板代码的情况下使用二进制序列化。</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="3b615d319efe934d18d838650aea75dd222232f9" translate="yes" xml:space="preserve">
          <source>Behaviors</source>
          <target state="translated">Behaviors</target>
        </trans-unit>
        <trans-unit id="198a78dbe4628d2be1564fc1b18cd50856f7b448" translate="yes" xml:space="preserve">
          <source>Behind all these special cases there is a simple guiding principle. Consider</source>
          <target state="translated">在所有这些特殊情况的背后,有一个简单的指导原则。考虑到</target>
        </trans-unit>
        <trans-unit id="9927980f0adf7f518791c8284a901dec62d24eaf" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">作为&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分，此警告默认情况下为关闭，但作为&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail提案（MFP）的&lt;/a&gt;一部分，它将在以后的GHC版本中打开。</target>
        </trans-unit>
        <trans-unit id="7b666df63b130afff3eedd81208b2e0a7a134951" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">作为&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分，此警告默认情况下为关闭，但在以后的GHC版本中将打开。</target>
        </trans-unit>
        <trans-unit id="2dc8c83454270735d86a9e3ef3fee23e1a680d7a" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">作为&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分，默认情况下此警告处于禁用状态，但作为&lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail提案（MFP）的&lt;/a&gt;一部分，它将在以后的GHC版本中启用。</target>
        </trans-unit>
        <trans-unit id="f03e9e7f99ad75ac4d7551b349bf9316b17b8429" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">作为&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分，默认情况下此警告处于禁用状态，但作为&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail提案（MFP）的&lt;/a&gt;一部分，它将在以后的GHC版本中启用。</target>
        </trans-unit>
        <trans-unit id="e424286d0dd9624ae70bbdecffd2b0043a24233e" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">作为&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分，此警告默认情况下为关闭，但在以后的GHC版本中将打开。</target>
        </trans-unit>
        <trans-unit id="9c04a6e766fbff8072acd4912e7880d5f0b4d39b" translate="yes" xml:space="preserve">
          <source>Being strict by being lazy</source>
          <target state="translated">严以修身</target>
        </trans-unit>
        <trans-unit id="969fbe69d4fd12dcb8cd78548a9408fd636a4a1d" translate="yes" xml:space="preserve">
          <source>Bell alerts</source>
          <target state="translated">钟声警报</target>
        </trans-unit>
        <trans-unit id="36c94be5c6badc8ef160f60b3f9d24d9b2c8db30" translate="yes" xml:space="preserve">
          <source>Below are two examples showing a definition of a reusable less-polymorphic &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and a one-off in-line specialisation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">以下是两个示例，它们显示了可重用的较少多态 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 的定义以及一个一次性的 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 内联专门化：</target>
        </trans-unit>
        <trans-unit id="9405867e098bc21ea37caa6071fbd884463207a3" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下是&lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;的示例输出</target>
        </trans-unit>
        <trans-unit id="631e6a2e29c9e7487b85c9d3fda8e1229ccc3cd2" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下是&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;的示例输出</target>
        </trans-unit>
        <trans-unit id="b2041b4df1603971cd99daa2131b9173fce20a5d" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下是使用&lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;的同一示例的输出</target>
        </trans-unit>
        <trans-unit id="7895436348a83297630a392863829501eafbcaec" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下是使用&lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;的同一示例的输出</target>
        </trans-unit>
        <trans-unit id="9dafb52c45cfdbf863160a686861b97310393d60" translate="yes" xml:space="preserve">
          <source>Below we construct a &lt;code&gt;Foldable&lt;/code&gt; instance for a data type representing a (finite) binary tree with depth-first traversal.</source>
          <target state="translated">下面我们为数据类型构造一个 &lt;code&gt;Foldable&lt;/code&gt; 实例，该数据类型表示具有（深度）优先遍历的（有限）二叉树。</target>
        </trans-unit>
        <trans-unit id="a29d5a1f385485805511ac832659c0faf4251bd6" translate="yes" xml:space="preserve">
          <source>Below we implement an analogous data structure using a representation based on &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This is an example of &lt;em&gt;Church encoding&lt;/em&gt; (named after Alonzo Church, inventor of the lambda calculus).</source>
          <target state="translated">下面我们使用基于 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的表示来实现类似的数据结构。这是&lt;em&gt;教会编码&lt;/em&gt;的示例（以lambda演算的发明者Alonzo Church的名字命名）。</target>
        </trans-unit>
        <trans-unit id="98ad2d7635fc111746d76bbebe8290141e95c77d" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries中&lt;/a&gt;找到将&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;与其他字典实现进行比较的基准。</target>
        </trans-unit>
        <trans-unit id="accf09ba43e68b9c38f3e58c7eda4b805b21f104" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries中&lt;/a&gt;找到将&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;与其他字典实现进行比较的基准。</target>
        </trans-unit>
        <trans-unit id="8166d1f6f68785d8abaf21c7a0c48450cb6c1c1e" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries中&lt;/a&gt;找到将&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;与其他字典实现进行比较的基准。</target>
        </trans-unit>
        <trans-unit id="8c3dee153b5361c9c8871a11980becccab3e42dc" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries中&lt;/a&gt;找到将&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;与其他字典实现进行比较的基准。</target>
        </trans-unit>
        <trans-unit id="1ffe14aeb84cb87ee3186a9571b06e8928ba55d3" translate="yes" xml:space="preserve">
          <source>Beside</source>
          <target state="translated">Beside</target>
        </trans-unit>
        <trans-unit id="fe92499c572ca34751830e44318f456f3cef3984" translate="yes" xml:space="preserve">
          <source>Beside, separated by space</source>
          <target state="translated">旁边,用空间隔开</target>
        </trans-unit>
        <trans-unit id="788b6f6586539d7fc47b8fcc55c19730cea68d99" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另外，用空格隔开，除非参数之一为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e330d7aca54bde1e02fdeabed64fcc133a6401a" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另外，用空格隔开，除非参数之一为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e618be55395d8238a159850eddcfbe3ac7a7c273" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另外，用空格隔开，除非参数之一为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="624607c86787dd5201e891b5c7bb38bfd2a78db7" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">旁。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d88ff324bd9ae359aacf25e29a3916a4ff7c3758" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">旁。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d384f6b4d5525841d1e0cf79b191835355e54bd2" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">旁。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85ed1a12122824af84b077aa03948e1d13a22d0d" translate="yes" xml:space="preserve">
          <source>Besides an extra-constraints wildcard (see &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;Extra-Constraints Wildcard&lt;/a&gt;), only named wildcards can occur in the constraints, e.g. the &lt;code&gt;_x&lt;/code&gt; in &lt;code&gt;Show _x&lt;/code&gt;.</source>
          <target state="translated">除了额外的约束通配符（见&lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;特约束通配符&lt;/a&gt;），可发生于限制仅命名的通配符，例如 &lt;code&gt;_x&lt;/code&gt; 中 &lt;code&gt;Show _x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26a472de725e2ab48d4de069fd18a472bb691f2e" translate="yes" xml:space="preserve">
          <source>Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</source>
          <target state="translated">除了通过生成所有方法定义来推导实例的存量方法外,GHC还支持两种额外的推导策略,可以推导任意的类。</target>
        </trans-unit>
        <trans-unit id="bf2ddad2d8faffde93e2583147aba1ed84271cf8" translate="yes" xml:space="preserve">
          <source>Beware that for many monads (those for which the &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict) this instance will &lt;em&gt;not&lt;/em&gt; satisfy the right-tightening law required by the &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">请注意，对于许多单子（对 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 操作严格的单子），此实例将&lt;em&gt;无法&lt;/em&gt;满足 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; 类要求的右拧法则。</target>
        </trans-unit>
        <trans-unit id="5d549c234ccdd45fa67e66fd17e9aa5b7f98bef5" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">请注意，在某些情况下，可能需要启用&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;扩展才能使用此功能。这是一个病理案例，说明了为什么会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="e7c1558fc208f9daac585e394451c0ebdd033dbc" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">请注意，在某些情况下，可能需要启用&lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;扩展才能使用此功能。这是一个病理案例，说明了为什么会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="653c3c82d14b666acef082f6f19dc453202cc92e" translate="yes" xml:space="preserve">
          <source>Beware that this function allocates a new file descriptor. A consequence of this is that calling &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; on the standard Windows handles will not give you &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For example, if you run this code:</source>
          <target state="translated">请注意，此函数分配了新的文件描述符。这样的结果是，在标准Windows句柄上调用 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; 不会为您提供 &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 。例如，如果您运行以下代码：</target>
        </trans-unit>
        <trans-unit id="7827a30613f0ebab2ac4ede20720ab2ad59250c6" translate="yes" xml:space="preserve">
          <source>Beware: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; truncates multi-byte characters to octets. e.g. &quot;枯朶に烏のとまりけり秋の暮&quot; becomes �6k�nh~�Q��n�</source>
          <target state="translated">当心： &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; 将多字节字符截断为八位字节。例如，&amp;ldquo;枯朵に乌のとまりけり秋の暮&amp;rdquo;变为，6k nh〜 Q n。</target>
        </trans-unit>
        <trans-unit id="2d677a45c1242d143f2da8c0235a4156fc9aed39" translate="yes" xml:space="preserve">
          <source>Bidirectional</source>
          <target state="translated">Bidirectional</target>
        </trans-unit>
        <trans-unit id="03af5d044e78c5ca2a87b11a0cd3ee30426faaa4" translate="yes" xml:space="preserve">
          <source>Bifoldable</source>
          <target state="translated">Bifoldable</target>
        </trans-unit>
        <trans-unit id="6148a7120e3e6bee1841037a0e66edba57f2b59d" translate="yes" xml:space="preserve">
          <source>Bifunctor</source>
          <target state="translated">Bifunctor</target>
        </trans-unit>
        <trans-unit id="a1ec611991374940381b1e25467f733adcf02bbc" translate="yes" xml:space="preserve">
          <source>Big-endian</source>
          <target state="translated">Big-endian</target>
        </trans-unit>
        <trans-unit id="f84c8cdd20adeb4d710d8f5e51b3ed37c2ffc31f" translate="yes" xml:space="preserve">
          <source>Big-endian decoding</source>
          <target state="translated">大写字母解码</target>
        </trans-unit>
        <trans-unit id="a75e84204fb542f8fffbe1d93f24c4127709d703" translate="yes" xml:space="preserve">
          <source>Big-endian primitives</source>
          <target state="translated">大二烯基元</target>
        </trans-unit>
        <trans-unit id="d80f000c501b0702089f0a6d5d685b3b13d95ab4" translate="yes" xml:space="preserve">
          <source>Big-endian writes</source>
          <target state="translated">Big-endian写道</target>
        </trans-unit>
        <trans-unit id="b092fd4b540ba704e7eab5010e33d073c85baa3e" translate="yes" xml:space="preserve">
          <source>BigEndian</source>
          <target state="translated">BigEndian</target>
        </trans-unit>
        <trans-unit id="4a103563aecb5d07999bf55551e2840da08dea6b" translate="yes" xml:space="preserve">
          <source>BigNat</source>
          <target state="translated">BigNat</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="ca596333bdb84d8c57915427010182cfc758ccf1" translate="yes" xml:space="preserve">
          <source>Binary encodings</source>
          <target state="translated">二进制编码</target>
        </trans-unit>
        <trans-unit id="b7a0b74a0efeea7a4ae51a1506822c7ba3cdfd5b" translate="yes" xml:space="preserve">
          <source>Binary input and output</source>
          <target state="translated">二进制输入和输出</target>
        </trans-unit>
        <trans-unit id="977f362d04f5411618935479aa90d3c2cbbc8fc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation</source>
          <target state="translated">二进制序列化</target>
        </trans-unit>
        <trans-unit id="e899d0e0bf36df2f1e4a7c2fa0c0833fc062acdf" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">Haskell值与惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 之间的二进制序列化。二进制库提供了将Haskell值编码为直接在内存中的字节流的方法。然后可以将所得的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入磁盘，通过网络发送或进一步处理（例如，使用gzip压缩）。</target>
        </trans-unit>
        <trans-unit id="21a20ed9e4ba0673faa9314d967e4c8a18a9ddc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">Haskell值往返于惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的二进制序列化。二进制库提供了将Haskell值编码为直接在内存中的字节流的方法。然后，可以将生成的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入磁盘，通过网络发送或进一步处理（例如，使用gzip压缩）。</target>
        </trans-unit>
        <trans-unit id="4f05e0ce4c49719ca18e235c0a5338e6c9f82d92" translate="yes" xml:space="preserve">
          <source>Binary-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s do no newline translation at all.</source>
          <target state="translated">二进制模式 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 根本不进行换行翻译。</target>
        </trans-unit>
        <trans-unit id="4e65c3b7cae6dd45ee04f43d6dc7e91ad9857ed8" translate="yes" xml:space="preserve">
          <source>BinaryLiterals</source>
          <target state="translated">BinaryLiterals</target>
        </trans-unit>
        <trans-unit id="ef29ec8d1db838c8e1a48ba8918f31da08b74947" translate="yes" xml:space="preserve">
          <source>BinaryType</source>
          <target state="translated">BinaryType</target>
        </trans-unit>
        <trans-unit id="6bc6b5d113e80feddce377fd7a1ee8583e9b656f" translate="yes" xml:space="preserve">
          <source>Bind worker threads on a capability to the appropriate node.</source>
          <target state="translated">将能力上的工作线程绑定到相应的节点。</target>
        </trans-unit>
        <trans-unit id="250887693e686f9b9bf4bfdc01f65dbe05d0a943" translate="yes" xml:space="preserve">
          <source>Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.</source>
          <target state="translated">将一个函数绑定到一个单值上,会创建一个新的延续,这个延续将函数作为单值计算的延续。</target>
        </trans-unit>
        <trans-unit id="df37671abb2b5d29837d448a150784288f14c591" translate="yes" xml:space="preserve">
          <source>Binding strategy:</source>
          <target state="translated">装订战略。</target>
        </trans-unit>
        <trans-unit id="f86ed004f3a732d1f540de4195d20a7e54011bbe" translate="yes" xml:space="preserve">
          <source>Bindings are translated with the &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; functions to the usual do-notation:</source>
          <target state="translated">绑定被翻译用 &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 功能，通常的DO-符号：</target>
        </trans-unit>
        <trans-unit id="c5508d22bc8524cbfc21537e7df0e0da3d89023d" translate="yes" xml:space="preserve">
          <source>Bindings:</source>
          <target state="translated">Bindings:</target>
        </trans-unit>
        <trans-unit id="d77c376e13dda253679750f2f2a4005705a750a7" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;response&lt;/code&gt; to the result of the following &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; block, binds &lt;code&gt;exit&lt;/code&gt; to the continuation.</source>
          <target state="translated">绑定 &lt;code&gt;response&lt;/code&gt; 以下 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; 块的结果的响应，将 &lt;code&gt;exit&lt;/code&gt; 绑定到继续。</target>
        </trans-unit>
        <trans-unit id="2fe1387ba65691c262469ad0ad878d77f589b9fd" translate="yes" xml:space="preserve">
          <source>Biographical profiling samples start with the &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; event. These events also include a timestamp which indicates when the sample was taken. This is because all these samples will appear at the end of the eventlog due to how the biographical profiling mode works. You can use the timestamp to reorder the samples relative to the other events.</source>
          <target state="translated">传记分析样本从 &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; 事件开始。这些事件还包括指示何时采集样本的时间戳。这是因为由于传记配置文件模式的工作原理，所有这些样本都将出现在事件日志的末尾。您可以使用时间戳相对于其他事件重新排列样本。</target>
        </trans-unit>
        <trans-unit id="1bca52e9cf05fd2b526ca79883fe209959fdb0eb" translate="yes" xml:space="preserve">
          <source>Bit reversal</source>
          <target state="translated">比特反转</target>
        </trans-unit>
        <trans-unit id="bd55858742523f8eb1bcf4b2ff338846c79cd3cf" translate="yes" xml:space="preserve">
          <source>Bit-operations</source>
          <target state="translated">Bit-operations</target>
        </trans-unit>
        <trans-unit id="3bb87577cfbf6b194391f9fd2449d3a6daeb5a6e" translate="yes" xml:space="preserve">
          <source>BitMap</source>
          <target state="translated">BitMap</target>
        </trans-unit>
        <trans-unit id="792ac9c6e86cf4159b4253d880e8d576591cad45" translate="yes" xml:space="preserve">
          <source>BitQueue</source>
          <target state="translated">BitQueue</target>
        </trans-unit>
        <trans-unit id="16859195f5f61ebc3eeb05fc2fd6fe7e5753102f" translate="yes" xml:space="preserve">
          <source>BitQueueB</source>
          <target state="translated">BitQueueB</target>
        </trans-unit>
        <trans-unit id="b3f2f3df0a3eb7ef036e378ae33aea93f8400b62" translate="yes" xml:space="preserve">
          <source>Bitraversable</source>
          <target state="translated">Bitraversable</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="f4eecb0837ac1302da3d67883bc955eb28db73ff" translate="yes" xml:space="preserve">
          <source>Bits are numbered from 0 with bit 0 being the least significant bit.</source>
          <target state="translated">位从0开始编号,0位是最小的有效位。</target>
        </trans-unit>
        <trans-unit id="51a3d80c1096a062a320e452d30389dbba6e7b2e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;</source>
          <target state="translated">位上的 &quot;和&quot;</target>
        </trans-unit>
        <trans-unit id="c00a3cca6e0ab63567c09149e3d79bf22145be8a" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;.</source>
          <target state="translated">位的 &quot;和&quot;。</target>
        </trans-unit>
        <trans-unit id="0762de2cf0c6e6b77d828208804bb630467f8b11" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;not&quot;, also known as the binary complement.</source>
          <target state="translated">位上的 &quot;不&quot;,又称二进制补。</target>
        </trans-unit>
        <trans-unit id="2ddacb26a9c51fdf4ca8a56ff66cbb76c9340f8f" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;</source>
          <target state="translated">位上的 &quot;或&quot;</target>
        </trans-unit>
        <trans-unit id="c4b3b9bbde6c754b04ce738f6f2d6bfaa36d025e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;.</source>
          <target state="translated">位的 &quot;或&quot;。</target>
        </trans-unit>
        <trans-unit id="06ae84f662f3c26c21557288d7b8b92876ca8dee" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;</source>
          <target state="translated">位上 &quot;xor&quot;</target>
        </trans-unit>
        <trans-unit id="e3c7281d1f961f980af39f221c595b00177f9020" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;.</source>
          <target state="translated">位的 &quot;xor&quot;。</target>
        </trans-unit>
        <trans-unit id="1aa01b99c6c9acf5a48b2725a9ba94e0bfd7f80c" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;code&gt;NOT&lt;/code&gt; operation</source>
          <target state="translated">按位 &lt;code&gt;NOT&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="683d2fe77a00a83b71f7046b5e0207bef8f8b05e" translate="yes" xml:space="preserve">
          <source>Bitwise AND operation</source>
          <target state="translated">位与位操作</target>
        </trans-unit>
        <trans-unit id="812234cb7852ab2e4152ebfeecff0e34bbc8f331" translate="yes" xml:space="preserve">
          <source>Bitwise OR operation</source>
          <target state="translated">位式OR操作</target>
        </trans-unit>
        <trans-unit id="566da620243c869eb9093b1d9109361f7deab173" translate="yes" xml:space="preserve">
          <source>Bitwise XOR operation</source>
          <target state="translated">位XOR操作</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="8f231bba8956b90d7be7998e87d3ff0f36931637" translate="yes" xml:space="preserve">
          <source>Blackholing is the act of marking a thunk (lazy computation) as being under evaluation. It is useful for three reasons: firstly it lets us detect certain kinds of infinite loop (the &lt;code&gt;NonTermination&lt;/code&gt; exception), secondly it avoids certain kinds of space leak, and thirdly it avoids repeating a computation in a parallel program, because we can tell when a computation is already in progress.</source>
          <target state="translated">Blackholing是将一个thunk（惰性计算）标记为正在评估的行为。它之所以有用，有以下三个原因：首先，它使我们能够检测到某些类型的无限循环（ &lt;code&gt;NonTermination&lt;/code&gt; 异常）；其次，它避免了某些类型的空间泄漏；其次，它避免了在并行程序中重复计算，因为我们可以知道何时计算已经在进行中。</target>
        </trans-unit>
        <trans-unit id="574a76735e33bbd57fb0a916028cacc6070b3973" translate="yes" xml:space="preserve">
          <source>Block size</source>
          <target state="translated">块大小</target>
        </trans-unit>
        <trans-unit id="8b9a1d81d5887c9c67a6b20d2df16d43fe81caa7" translate="yes" xml:space="preserve">
          <source>Block the current thread until data can be written to the given file descriptor (GHC only).</source>
          <target state="translated">封锁当前线程,直到数据可以写入给定的文件描述符(仅GHC)。</target>
        </trans-unit>
        <trans-unit id="7065922fead5956b30a4880d4db36fbe6025cd84" translate="yes" xml:space="preserve">
          <source>Block the current thread until data is available to read on the given file descriptor (GHC only).</source>
          <target state="translated">封锁当前线程,直到在给定的文件描述符上有数据可读(仅GHC)。</target>
        </trans-unit>
        <trans-unit id="2032cada98db5faaa0692223c8180668544f801d" translate="yes" xml:space="preserve">
          <source>Block until input is available on specified file descriptor.</source>
          <target state="translated">阻止输入,直到指定的文件描述符上有可用的输入。</target>
        </trans-unit>
        <trans-unit id="37d7b821bc5d453b65c16db21a1b548c820c28a2" translate="yes" xml:space="preserve">
          <source>Block until output is possible on specified file descriptor.</source>
          <target state="translated">在指定的文件描述符上阻止输出,直到可以输出为止。</target>
        </trans-unit>
        <trans-unit id="9ba5e142177e718c386fc68a7e5656d6003bdbf3" translate="yes" xml:space="preserve">
          <source>BlockArguments</source>
          <target state="translated">BlockArguments</target>
        </trans-unit>
        <trans-unit id="21ee9c95fd5afb5bc56f8da9452091ffececfb39" translate="yes" xml:space="preserve">
          <source>BlockReason</source>
          <target state="translated">BlockReason</target>
        </trans-unit>
        <trans-unit id="bc1ab004ab80487da68b0fe585fadda53b1d746e" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnMVar</source>
          <target state="translated">BlockedIndefinitelyOnMVar</target>
        </trans-unit>
        <trans-unit id="69236e61bca3edecfc65ca8a204134ba0de3fd74" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnSTM</source>
          <target state="translated">BlockedIndefinitelyOnSTM</target>
        </trans-unit>
        <trans-unit id="45dfab9fc5bfc0e525595e3313ce2a25dd4d7faa" translate="yes" xml:space="preserve">
          <source>BlockedOnBlackHole</source>
          <target state="translated">BlockedOnBlackHole</target>
        </trans-unit>
        <trans-unit id="93c9452da95239560e86200369ac0d634e21fb28" translate="yes" xml:space="preserve">
          <source>BlockedOnException</source>
          <target state="translated">BlockedOnException</target>
        </trans-unit>
        <trans-unit id="b61c27531d4d77cf1630fbca19ceced64a349e39" translate="yes" xml:space="preserve">
          <source>BlockedOnForeignCall</source>
          <target state="translated">BlockedOnForeignCall</target>
        </trans-unit>
        <trans-unit id="f3b3ba940976333504078cae62e2eabe3bbf8432" translate="yes" xml:space="preserve">
          <source>BlockedOnIOCompletion</source>
          <target state="translated">BlockedOnIOCompletion</target>
        </trans-unit>
        <trans-unit id="53d58631b450ca365b0ba176488a8441b143b2c2" translate="yes" xml:space="preserve">
          <source>BlockedOnMVar</source>
          <target state="translated">BlockedOnMVar</target>
        </trans-unit>
        <trans-unit id="895bd85890de6d5092a051ca56773fa4f0cd0c75" translate="yes" xml:space="preserve">
          <source>BlockedOnOther</source>
          <target state="translated">BlockedOnOther</target>
        </trans-unit>
        <trans-unit id="3804172b29d85f99db9a290a3dd685ef7d5c8d84" translate="yes" xml:space="preserve">
          <source>BlockedOnSTM</source>
          <target state="translated">BlockedOnSTM</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="0120b648baeefab9ba6ebfa6450b325f6a60cba8" translate="yes" xml:space="preserve">
          <source>BodyQ</source>
          <target state="translated">BodyQ</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="3f8b6ea3af3c50fa9d094ce543d63a1358584bcf" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;</source>
          <target state="translated">布尔运算 &quot;和&quot;</target>
        </trans-unit>
        <trans-unit id="04332ab31b7691eb315a3b0e8934a864c9ebacfa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;, lazy in the second argument</source>
          <target state="translated">布尔运算 &quot;和&quot;,在第二个参数中懒惰。</target>
        </trans-unit>
        <trans-unit id="69265825ad6d4c4d64bf7e08030ff39e70a968fa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;not&quot;</source>
          <target state="translated">Boolean &quot;not&quot;</target>
        </trans-unit>
        <trans-unit id="b22b4e8199107440fbfe7d97c6a6e57037c7151d" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;</source>
          <target state="translated">布尔运算 &quot;或&quot;</target>
        </trans-unit>
        <trans-unit id="0266fdeda44ec514d099d2f8107813680104acda" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;, lazy in the second argument</source>
          <target state="translated">布尔型 &quot;或&quot;,在第二个参数中懒惰。</target>
        </trans-unit>
        <trans-unit id="eb9c2517131e28267052868fb04f87dd8cb84e01" translate="yes" xml:space="preserve">
          <source>Boolean monoid under conjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">并列（ &lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt; ）下的布尔单义形。</target>
        </trans-unit>
        <trans-unit id="c181263cf12be8452e7085b87f90b355a0cc7ef9" translate="yes" xml:space="preserve">
          <source>Boolean monoid under disjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">析取运算符（ &lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt; ）下的布尔布尔半群。</target>
        </trans-unit>
        <trans-unit id="8ee67baf0a124b81be7277cfa2a8ff919c8c8724" translate="yes" xml:space="preserve">
          <source>Boolean predicate folds. These functions examine elements strictly until a condition is met, but then return a result ignoring the rest (lazy in the tail). These may loop forever given an unbounded input where no elements satisy the termination condition.</source>
          <target state="translated">布尔谓词折叠。这些函数严格地检查元素,直到满足一个条件,然后返回一个结果,忽略其他元素(尾部的懒惰)。这些函数可能会永远循环,给定一个无边界的输入,其中没有元素满足终止条件。</target>
        </trans-unit>
        <trans-unit id="2732eeea43125f2e843ab5f5666a8d163b3d9289" translate="yes" xml:space="preserve">
          <source>Boolean type-level equality</source>
          <target state="translated">布尔类型级平等</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="98b4ea6bcdbb948d8cbe34481cd1c0a07bd194e0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">无论 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 存在于提供的接口匹配 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类型的类，但建议实施 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 的使用情况 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; ，因为前者比后者更有效。例如：</target>
        </trans-unit>
        <trans-unit id="3f34f496978794b63af2a314d45c261e70ec11ca" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">无论 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 存在于提供的接口匹配 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类型的类，但建议实施 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 则使用实例 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; ，因为前者比后者更有效。例如：</target>
        </trans-unit>
        <trans-unit id="5b731e5f2cccb2521565e021975320c572150ee8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;, and pick an arbitrary one if multiple choices are available.</source>
          <target state="translated">两个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; ，并选择任意一个如果有多个选项可供选择。</target>
        </trans-unit>
        <trans-unit id="4d60c7bb83c292da504a6719a69ebefefdf4659e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">这两个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b44c00c13cb83fe026cbd5b8d4d766f125c9858" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F0&lt;/code&gt; have kind &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but their arity differs.</source>
          <target state="translated">无论 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F0&lt;/code&gt; 有种 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; ，但它们的对等关系有所不同。</target>
        </trans-unit>
        <trans-unit id="c5124f48e35e2fbfeb662d20bdb90a9e2a8cb8e0" translate="yes" xml:space="preserve">
          <source>Both module &lt;code&gt;Class&lt;/code&gt; and module &lt;code&gt;Dangerous&lt;/code&gt; will compile under &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; without issue. However, in module &lt;code&gt;TCB_Runner&lt;/code&gt;, we must check if the call to &lt;code&gt;op&lt;/code&gt; in function &lt;code&gt;f&lt;/code&gt; is safe.</source>
          <target state="translated">模块 &lt;code&gt;Class&lt;/code&gt; 和 &lt;code&gt;Dangerous&lt;/code&gt; 模块都将在&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;下编译而不会出现问题。但是，在模块 &lt;code&gt;TCB_Runner&lt;/code&gt; 中，我们必须检查在函数 &lt;code&gt;f&lt;/code&gt; 中对 &lt;code&gt;op&lt;/code&gt; 的调用是否安全。</target>
        </trans-unit>
        <trans-unit id="49ffa16e1c07272dd28d622d9dbdc1c18ed54d66" translate="yes" xml:space="preserve">
          <source>Both of these hold:</source>
          <target state="translated">这两点都成立。</target>
        </trans-unit>
        <trans-unit id="2bafd70b5ada2ef0c84297ccc53777ff415bca1e" translate="yes" xml:space="preserve">
          <source>Both the type &lt;code&gt;Ex&lt;/code&gt; and the data constructor &lt;code&gt;MkEx&lt;/code&gt; get promoted, with the polymorphic kind &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt;. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</source>
          <target state="translated">&lt;code&gt;Ex&lt;/code&gt; 类型和数据构造函数 &lt;code&gt;MkEx&lt;/code&gt; 都被提升，具有多态类型 &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt; 。出乎意料的是，您可以编写一个类型族来提取类型级存在的成员：</target>
        </trans-unit>
        <trans-unit id="361b42712506425fdcf2b1ea50a51aa8dea82ef8" translate="yes" xml:space="preserve">
          <source>Both upper- and lower-case &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'F'&lt;/code&gt; are converted as well, to &lt;code&gt;10..15&lt;/code&gt;.</source>
          <target state="translated">大写和小写字母 &lt;code&gt;'A'&lt;/code&gt; 到 &lt;code&gt;'F'&lt;/code&gt; 也都转换为 &lt;code&gt;10..15&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecb0b65529079a3af9e45a8098a612b9728453e3" translate="yes" xml:space="preserve">
          <source>BothQueues</source>
          <target state="translated">BothQueues</target>
        </trans-unit>
        <trans-unit id="403591682693529ea8d764be443089ceac85ad97" translate="yes" xml:space="preserve">
          <source>Bound Threads</source>
          <target state="translated">捆绑线</target>
        </trans-unit>
        <trans-unit id="60da7217d44bdc40c1eb907204fa54294872b81f" translate="yes" xml:space="preserve">
          <source>Bound threads can be created using the &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; function below. All foreign exported functions are run in a bound thread (bound to the OS thread that called the function). Also, the &lt;code&gt;main&lt;/code&gt; action of every Haskell program is run in a bound thread.</source>
          <target state="translated">可以使用下面的 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 函数创建绑定线程。所有外部导出的函数都在绑定线程（绑定到称为该函数的OS线程）中运行。同样，每个Haskell程序的 &lt;code&gt;main&lt;/code&gt; 动作都在绑定线程中运行。</target>
        </trans-unit>
        <trans-unit id="1bb360f4682f39da897d5087bec41a43fcf97967" translate="yes" xml:space="preserve">
          <source>Bounded</source>
          <target state="translated">Bounded</target>
        </trans-unit>
        <trans-unit id="5cf53f246d50f6260632d008d2b6db3a49861eea" translate="yes" xml:space="preserve">
          <source>Bounded-size builder primitives</source>
          <target state="translated">有界尺寸的构建器基元</target>
        </trans-unit>
        <trans-unit id="67c8c593c7bd9a6879a0fe1147f8534d16210197" translate="yes" xml:space="preserve">
          <source>Bounded-size primitives</source>
          <target state="translated">有界尺寸基元</target>
        </trans-unit>
        <trans-unit id="1d198c2728b2ed26f54e7cf85c8fe977ccb9dc30" translate="yes" xml:space="preserve">
          <source>BoundedPrim</source>
          <target state="translated">BoundedPrim</target>
        </trans-unit>
        <trans-unit id="b95a97052e20a036c292b97a8ef02a42631be78d" translate="yes" xml:space="preserve">
          <source>Bounds</source>
          <target state="translated">Bounds</target>
        </trans-unit>
        <trans-unit id="c32b8e824fbf6eb465582d1de11fcd8513bd5c9c" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">并 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 界限由给出</target>
        </trans-unit>
        <trans-unit id="dd273039c19f3757a5b2fd1fd257892b02f8e2dc" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">并 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 界限由给出</target>
        </trans-unit>
        <trans-unit id="c07a1483ae52efde58c537e9e0e90f76af8d10c2" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">并 &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 界限由给出</target>
        </trans-unit>
        <trans-unit id="f69cf141b98e3135d46e5dad39602462872e7538" translate="yes" xml:space="preserve">
          <source>BoxLabel</source>
          <target state="translated">BoxLabel</target>
        </trans-unit>
        <trans-unit id="2ede889b135cd77a1e71ca9eac7d985ad2849d48" translate="yes" xml:space="preserve">
          <source>Boxed arrays</source>
          <target state="translated">盒式阵列</target>
        </trans-unit>
        <trans-unit id="b252e3099c6de97ebf23d4d3dad230e7eb5f4d7a" translate="yes" xml:space="preserve">
          <source>Break a string on a substring, returning a pair of the part of the string prior to the match, and the rest of the string.</source>
          <target state="translated">在子串上断开字符串,返回匹配前的字符串部分和字符串其余部分的一对。</target>
        </trans-unit>
        <trans-unit id="48c9c26fa469922bae1a8d989dbc3283a3056b99" translate="yes" xml:space="preserve">
          <source>Break on any exception thrown</source>
          <target state="translated">抛出的任何异常都要中断</target>
        </trans-unit>
        <trans-unit id="a3c2a397d9584ae0b3fce8742f96600f8f4f3b73" translate="yes" xml:space="preserve">
          <source>Break on uncaught exceptions and errors</source>
          <target state="translated">突破未捕获的异常和错误</target>
        </trans-unit>
        <trans-unit id="5255e26cd5c57de2f55fb7938271f8fe86a6ef18" translate="yes" xml:space="preserve">
          <source>Breaking into lines and words</source>
          <target state="translated">破解成线条和文字</target>
        </trans-unit>
        <trans-unit id="e436763b8c5113cc5e50ec031996d87ced4c8b9f" translate="yes" xml:space="preserve">
          <source>Breaking into many substrings</source>
          <target state="translated">分成多个子串</target>
        </trans-unit>
        <trans-unit id="9572241e9e3834b00e85795597b97e3ac3c0330f" translate="yes" xml:space="preserve">
          <source>Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.</source>
          <target state="translated">在异常上的突破对于找出你的程序在无限循环中做了什么特别有用。只要按下Control-C键,检查历史记录,就能知道发生了什么。</target>
        </trans-unit>
        <trans-unit id="9ef5f02e366bdd5b1bc2750710d3b437ec6c866e" translate="yes" xml:space="preserve">
          <source>Breaking strings</source>
          <target state="translated">打破束缚</target>
        </trans-unit>
        <trans-unit id="9462db075d64fc4a3db967b37fffd444976427cc" translate="yes" xml:space="preserve">
          <source>Breakpoints can also be set by line (and optionally column) number:</source>
          <target state="translated">断点也可以通过行号(也可以选择列号)来设置。</target>
        </trans-unit>
        <trans-unit id="60a59cc6fc01f63be8e198f2fd5dd150495e86da" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set in various ways. Perhaps the easiest way to set a breakpoint is to name a top-level function:</source>
          <target state="translated">断点可以用不同的方式来设置。也许最简单的设置断点的方法是命名一个顶层函数。</target>
        </trans-unit>
        <trans-unit id="f3e8df33a1deb2bc938e5368fcc9fe73e94b3bdd" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set on arbitrarily deeply nested functions, but the whole chain of nested function names must be specified.</source>
          <target state="translated">断点可以设置在任意深度嵌套的函数上,但必须指定整个嵌套函数的名称链。</target>
        </trans-unit>
        <trans-unit id="5d7429ed06486112488321794f766798e806ffe7" translate="yes" xml:space="preserve">
          <source>Breaks down the graph by heap closure type.</source>
          <target state="translated">按堆闭合类型对图形进行分解。</target>
        </trans-unit>
        <trans-unit id="b6426715004373ae21dcdb366f81839cc52b183c" translate="yes" xml:space="preserve">
          <source>Bringing type variables into scope is particularly important for existential data constructors. For example:</source>
          <target state="translated">将类型变量带入作用域,对于存在式数据构造器来说尤为重要。例如:</target>
        </trans-unit>
        <trans-unit id="a676d7117cb70fed108c464413db56b7582a1b58" translate="yes" xml:space="preserve">
          <source>Broadcast a scalar to all elements of a vector.</source>
          <target state="translated">向一个向量的所有元素广播一个标量。</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="63915c89cc9540e39b93d3bbb0389bf834c12179" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">缓冲区分配功能。如果未给出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 内容，则应分配一个新的第一个缓冲区。如果给出了 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; ，则必须返回最小大小为 &lt;code&gt;minSize&lt;/code&gt; 的缓冲区。如果该策略可以保证此参照透明且 &lt;code&gt;oldBuffer&lt;/code&gt; 足够大，则该策略可以重用 &lt;code&gt;oldBuffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ffb5bb34208049e05e2848a2a464b9554b0c581" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">缓冲区分配功能。如果未给出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 内容，则应分配一个新的第一个缓冲区。如果给出了 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; ，则必须返回最小大小为 &lt;code&gt;minSize&lt;/code&gt; 的缓冲区。如果该策略可以保证此参照透明且 &lt;code&gt;oldBuffer&lt;/code&gt; 足够大，则该策略可以重用 &lt;code&gt;oldBuffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2421eb366ac457d20e3b2bf63b1d22adfd90f3a8" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuf&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuf&lt;/code&gt; is large enough.</source>
          <target state="translated">缓冲区分配功能。如果未给出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 内容，则应分配一个新的第一个缓冲区。如果给出了 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; ，则必须返回最小大小为 &lt;code&gt;minSize&lt;/code&gt; 的缓冲区。如果该策略可以确保此参照透明且 &lt;code&gt;oldBuf&lt;/code&gt; 足够大，则该策略可以重用 &lt;code&gt;oldBuf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1511aac3b884d36da1f7bb8a91d1b07265d2d60" translate="yes" xml:space="preserve">
          <source>Buffer allocation strategy to use</source>
          <target state="translated">使用的缓冲区分配策略</target>
        </trans-unit>
        <trans-unit id="efe38e877d87cf3a601574f61e8c6112056e7eb0" translate="yes" xml:space="preserve">
          <source>Buffer management</source>
          <target state="translated">缓冲区管理</target>
        </trans-unit>
        <trans-unit id="9824aaadc3118ca3339cc9676a3f0f7e0217d736" translate="yes" xml:space="preserve">
          <source>Buffer range to fill.</source>
          <target state="translated">要填充的缓冲区范围。</target>
        </trans-unit>
        <trans-unit id="07882a47335e43d38370ae44c05618c4c0286951" translate="yes" xml:space="preserve">
          <source>BufferCodec</source>
          <target state="translated">BufferCodec</target>
        </trans-unit>
        <trans-unit id="a9ae0ebad1f560c0b01d474fcf8a1259da2e45b3" translate="yes" xml:space="preserve">
          <source>BufferList</source>
          <target state="translated">BufferList</target>
        </trans-unit>
        <trans-unit id="85c84c25d56fc13d452000134b60f28ba5e1e022" translate="yes" xml:space="preserve">
          <source>BufferListNil</source>
          <target state="translated">BufferListNil</target>
        </trans-unit>
        <trans-unit id="f7f013f67bedbafe6a6a6713f8fba0341a8b5915" translate="yes" xml:space="preserve">
          <source>BufferMode</source>
          <target state="translated">BufferMode</target>
        </trans-unit>
        <trans-unit id="107a37d237e86ecf0a07109468ec7abb99d1adfa" translate="yes" xml:space="preserve">
          <source>BufferRange</source>
          <target state="translated">BufferRange</target>
        </trans-unit>
        <trans-unit id="322e5d09d79c6009f5674e7117a1114889fbffad" translate="yes" xml:space="preserve">
          <source>BufferState</source>
          <target state="translated">BufferState</target>
        </trans-unit>
        <trans-unit id="4e850fb4754d7daddef54b1081f53c061e2277d2" translate="yes" xml:space="preserve">
          <source>BufferWriter</source>
          <target state="translated">BufferWriter</target>
        </trans-unit>
        <trans-unit id="f000f6a3275f9800597ad7f1ac98d43bdd868368" translate="yes" xml:space="preserve">
          <source>BufferedIO</source>
          <target state="translated">BufferedIO</target>
        </trans-unit>
        <trans-unit id="9639fd1e6014e384d9b0d21001270a4532eabd44" translate="yes" xml:space="preserve">
          <source>Buffering operations</source>
          <target state="translated">缓冲操作</target>
        </trans-unit>
        <trans-unit id="1705358c6a0b24af297b254b2108454741ff4557" translate="yes" xml:space="preserve">
          <source>Buffers of any element</source>
          <target state="translated">任何元素的缓冲器</target>
        </trans-unit>
        <trans-unit id="aec7810cb2c876e23b0033e46aae5289ebf0c07c" translate="yes" xml:space="preserve">
          <source>Buffers used in the IO system</source>
          <target state="translated">IO系统中使用的缓冲器</target>
        </trans-unit>
        <trans-unit id="0c6dee2a7b5942268d8c231ef297e7abf881535b" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;lsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle仅导入使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的 &lt;code&gt;Prelude&lt;/code&gt; 。 &lt;code&gt;Prelude&lt;/code&gt; 驻留在 &lt;code&gt;C&lt;/code&gt; 信任的 &lt;code&gt;base&lt;/code&gt; 包中，并且（我们假设） &lt;code&gt;Prelude&lt;/code&gt; 的所有导入都是受信任的。因此 &lt;code&gt;C&lt;/code&gt; 信任 &lt;code&gt;Prelude&lt;/code&gt; ，因此 &lt;code&gt;C&lt;/code&gt; 也信任Buggle。（虽然 &lt;code&gt;Prelude&lt;/code&gt; 通常是隐式导入的，但仍遵循此处概述的相同规则）。</target>
        </trans-unit>
        <trans-unit id="dab94f662adaf1659e7f05eebbac08d52174fe85" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;rsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle仅导入使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的 &lt;code&gt;Prelude&lt;/code&gt; 。 &lt;code&gt;Prelude&lt;/code&gt; 驻留在 &lt;code&gt;C&lt;/code&gt; 信任的 &lt;code&gt;base&lt;/code&gt; 程序包中，并且（我们假设） &lt;code&gt;Prelude&lt;/code&gt; 的所有导入均受信任。因此， &lt;code&gt;C&lt;/code&gt; 信任 &lt;code&gt;Prelude&lt;/code&gt; ，因此 &lt;code&gt;C&lt;/code&gt; 也信任Buggle。（虽然 &lt;code&gt;Prelude&lt;/code&gt; 通常是隐式导入的，但仍遵循此处概述的相同规则）。</target>
        </trans-unit>
        <trans-unit id="8081798290cefd3d54a8b9c792ffff9da0c521f1" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) forest from a list of seed values in breadth-first order.</source>
          <target state="translated">按广度第一顺序从种子值列表中建立一个(可能是无限的)森林。</target>
        </trans-unit>
        <trans-unit id="4bf90ac98bb2341a2075164c532c21f819b14548" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) tree from a seed value in breadth-first order.</source>
          <target state="translated">从一个种子值按广度一阶建立一棵(可能是无限的)树。</target>
        </trans-unit>
        <trans-unit id="c1d9cde7a54b308063f3fd73d9babe621683dd31" translate="yes" xml:space="preserve">
          <source>Build a function type.</source>
          <target state="translated">建立一个函数类型。</target>
        </trans-unit>
        <trans-unit id="884c3b47e0ba76cd8f3c27d14e011d3bd05577da" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of edges.</source>
          <target state="translated">从边的列表中建立一个图。</target>
        </trans-unit>
        <trans-unit id="a94df834fcc88712c4822652bc46a21adf37eec8" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of nodes uniquely identified by keys, with a list of keys of nodes this node should have edges to.</source>
          <target state="translated">从一个由键唯一标识的节点列表中构建一个图,这个节点应该有边到的节点的键列表。</target>
        </trans-unit>
        <trans-unit id="2fea8f78ed97ff98cabd9dfcff293718197383f4" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt; for details.</source>
          <target state="translated">构建一个多模块的Haskell程序，自动找出依赖性。可能比使用 &lt;code&gt;make&lt;/code&gt; 更容易，更快捷。有关详细信息，请参见&lt;a href=&quot;using#make-mode&quot;&gt;使用ghc &amp;ndash;make&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a5960117b6ce95230aee2dd05eee4a451e3faba" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc --make&lt;/a&gt; for details.</source>
          <target state="translated">建立一个多模块的Haskell程序，自动找出依赖关系。可能比使用 &lt;code&gt;make&lt;/code&gt; 更容易，更快捷。有关详细信息，请参见&lt;a href=&quot;using#make-mode&quot;&gt;使用ghc --make&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecfe54531e239227dfe711c2483b41196f665224" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">用提供的初始数量构建一个新的 &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 。初始数量必须至少为0。</target>
        </trans-unit>
        <trans-unit id="0dbc0898ffb2401cdf281b35699fcbe7978e4839" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">用提供的初始数量构建一个新的 &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; 。初始数量必须至少为0。</target>
        </trans-unit>
        <trans-unit id="70552251bfc019f0a6642059f0e75968472b7607" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">建立一个新的 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="203ae674b4968ad5dbc66e2600cec2ba9f05797f" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">在当前状态线程中建立一个新的 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2ccc32e3940757246852fc694480f4189287bca" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">建立一个新的 &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2300e21cc0d85b3217ced13fe2e4d327643182d7" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">建立一个新的 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82733393c21fc1714245da66647bbf83f8a411fd" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">在当前状态线程中建立一个新的 &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48c92907a18be455e4e537a0232ec22e0c8bf45" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">建立一个新的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97fae16599eb28b19c06553bf02629e165abbc5e" translate="yes" xml:space="preserve">
          <source>Build a term and use a generic function for subterms</source>
          <target state="translated">建立一个术语,并为子术语使用一个通用函数。</target>
        </trans-unit>
        <trans-unit id="cdf22117ef668c1724b6471862c994146899c2a2" translate="yes" xml:space="preserve">
          <source>Build a term skeleton</source>
          <target state="translated">建立术语骨架</target>
        </trans-unit>
        <trans-unit id="6e114d1f641bd96174ecb4be857124ba1201641c" translate="yes" xml:space="preserve">
          <source>Build and return a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">构建并返回新的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 实例</target>
        </trans-unit>
        <trans-unit id="3ec1bed141573c1c17cf02d6a5d0bb6f437db403" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">生成并返回 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 的新实例。</target>
        </trans-unit>
        <trans-unit id="35be25a421fa9ce73459655bf04e9204af3809b5" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">生成并返回新的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 实例</target>
        </trans-unit>
        <trans-unit id="e8370129f628872766fbc00d3f80875610f346b1" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;#10352&lt;/a&gt;.</source>
          <target state="translated">构建用于动态链接的代码。这可以极大地减少代码大小，但可能会减慢非内联函数的跨模块调用。与Linux下的RTS中的链接相关的此标志&lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;可能会带来一些麻烦。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;＃10352&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81f76d0f10c8f6fc4b46e538ab3beeacb47b224a" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;Issue #10352&lt;/a&gt;.</source>
          <target state="translated">构建用于动态链接的代码。这样可以极大地减少代码大小，但可能会减慢非内联函数的跨模块调用。与Linux下RTS中的链接链接相关的此标志&lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;可能会带来一些麻烦。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;第10352期&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5add7a5a63c06d485a23e304e415303fa124ca5" translate="yes" xml:space="preserve">
          <source>Build dynamic object files &lt;em&gt;as well as&lt;/em&gt; static object files during compilation</source>
          <target state="translated">在编译过程中生成动态对象文件&lt;em&gt;和&lt;/em&gt;静态对象文件</target>
        </trans-unit>
        <trans-unit id="4d3910a254eaafd1fc8455fdeef9fbad4ea46494" translate="yes" xml:space="preserve">
          <source>Build dynamically-linked object files and executables</source>
          <target state="translated">构建动态链接的对象文件和可执行文件。</target>
        </trans-unit>
        <trans-unit id="eacb633fef8080b6f0e8a1849d462864fe4d86c5" translate="yes" xml:space="preserve">
          <source>Build signals and steps</source>
          <target state="translated">建立信号和步骤</target>
        </trans-unit>
        <trans-unit id="0b5df5cd9791079aa609e1eaab6f8fc1c1ffdb8d" translate="yes" xml:space="preserve">
          <source>Build step to use for filling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">构建步骤，用于填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="333dc9940206cf3fadb3fab2461dac23ee93f097" translate="yes" xml:space="preserve">
          <source>BuildSignal</source>
          <target state="translated">BuildSignal</target>
        </trans-unit>
        <trans-unit id="801f513654150879c914869a1ad18da56a51311a" translate="yes" xml:space="preserve">
          <source>BuildStep</source>
          <target state="translated">BuildStep</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="364a8a9074eaff8c9a4b742aefb97068ac895a25" translate="yes" xml:space="preserve">
          <source>Builder construction</source>
          <target state="translated">建筑商建设</target>
        </trans-unit>
        <trans-unit id="9bb1e848b4810eae4e0aa47509b87fbea136f359" translate="yes" xml:space="preserve">
          <source>Builder primitives are contravariant so it's like the normal fmap, but backwards (look at the type). (If it helps to remember, the operator symbol is like (&lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt;) but backwards.)</source>
          <target state="translated">构建器原语是互变的，因此它就像普通的fmap一样，但是向后（查看类型）。（如果它有助于记住，则运算符符号类似于（&lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt;），但倒退。）</target>
        </trans-unit>
        <trans-unit id="080b4431eac6064309a77089493ad982c5492b9a" translate="yes" xml:space="preserve">
          <source>Builder primitives come in two forms: fixed-size and bounded-size.</source>
          <target state="translated">Builder 基元有两种形式:固定大小和限定大小。</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="69f74097b2a4cac8d5c3948fa9f727f1ceca5558" translate="yes" xml:space="preserve">
          <source>Building ByteStrings</source>
          <target state="translated">构建ByteStrings</target>
        </trans-unit>
        <trans-unit id="e7a886492e100281858af7babfd3d1560f1a0fa1" translate="yes" xml:space="preserve">
          <source>Building Haskell code into a shared library is a good way to include Haskell code in a larger mixed-language project. While with static linking it is recommended to use GHC to perform the final link step, with shared libraries a Haskell library can be treated just like any other shared library. The linking can be done using the normal system C compiler or linker.</source>
          <target state="translated">将Haskell代码构建到共享库中是将Haskell代码包含在一个更大的混合语言项目中的好方法。虽然对于静态链接,建议使用GHC来执行最后的链接步骤,但对于共享库,Haskell库可以像其他共享库一样对待。链接可以使用普通的系统C编译器或链接器来完成。</target>
        </trans-unit>
        <trans-unit id="c345d8576de571b12d40732f130fe8f621f52549" translate="yes" xml:space="preserve">
          <source>Building a static library is done by using the &lt;strong&gt;ar&lt;/strong&gt; tool, like so:</source>
          <target state="translated">可以通过使用&lt;strong&gt;ar&lt;/strong&gt;工具来构建静态库，如下所示：</target>
        </trans-unit>
        <trans-unit id="8152d2ec7d17304f7305d9df262ac39349bac99f" translate="yes" xml:space="preserve">
          <source>Building and using shared libraries is slightly more complicated than building and using static libraries. When using Cabal much of the detail is hidden, just use &lt;code&gt;--enable-shared&lt;/code&gt; when configuring a package to build it into a shared library, or to link it against other packages built as shared libraries. The additional complexity when building code is to distinguish whether the code will be used in a shared library or will use shared library versions of other packages it depends on. There is additional complexity when installing and distributing shared libraries or programs that use shared libraries, to ensure that all shared libraries that are required at runtime are present in suitable locations.</source>
          <target state="translated">构建和使用共享库比构建和使用静态库稍微复杂一些。使用Cabal时，很多细节都是隐藏的，只需在配置软件包时将 &lt;code&gt;--enable-shared&lt;/code&gt; 配置为将其构建到共享库中，或将其链接到作为共享库构建的其他软件包。构建代码时，额外的复杂性是区分代码是在共享库中使用还是在其依赖的其他软件包的共享库版本中使用。在安装和分发共享库或使用共享库的程序时，存在额外的复杂性，以确保运行时所需的所有共享库都位于适当的位置。</target>
        </trans-unit>
        <trans-unit id="d2d47db5b33b51c402bdb2a8a2fb36f1133fc85e" translate="yes" xml:space="preserve">
          <source>Building computations from sequences of functions that may fail or using exception handling to structure error handling.</source>
          <target state="translated">从可能失败的函数序列中构建计算,或者使用异常处理来构建错误处理。</target>
        </trans-unit>
        <trans-unit id="5c9c803f9e45294cd3c242c8eff2a73203984f1b" translate="yes" xml:space="preserve">
          <source>Building lists</source>
          <target state="translated">建立名单</target>
        </trans-unit>
        <trans-unit id="59b3ac6a1ebc1aa3f0dee53bb672cdabad274ba4" translate="yes" xml:space="preserve">
          <source>Building streams</source>
          <target state="translated">建设流</target>
        </trans-unit>
        <trans-unit id="f2136c9449e4d2207252445899311ca019c571b7" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">构建自己的软件包也非常简单：我们提供&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;基础架构，该基础架构可自动执行配置，构建，安装和分发软件包的过程。您需要做的就是编写一个简单的配置文件，在正确的位置放置几个文件，然后有了一个软件包。有关详细信息，请参见&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal文档&lt;/a&gt;，以及Cabal库（例如&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="468ffacf83b540eb8029fa77183ff7a6bbbe4845" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">构建自己的软件包也非常简单：我们提供&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;基础结构，该基础结构可自动执行配置，构建，安装和分发软件包的过程。您需要做的就是编写一个简单的配置文件，在正确的位置放置几个文件，然后有了一个软件包。有关详细信息，请参见&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal文档&lt;/a&gt;，以及Cabal库（例如&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="08e50fabbac322297c0380dab80b06348335688e" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">构建自己的软件包也非常简单：我们提供&lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;基础架构，该基础架构可自动执行配置，构建，安装和分发软件包的过程。您需要做的就是编写一个简单的配置文件，在正确的位置放置几个文件，然后有了一个软件包。有关详细信息，请参见&lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal文档&lt;/a&gt;，以及Cabal库（例如&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="327fc0c96310e3524acc6da1fe01e6c67634802c" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to an undefined value. In a monadic context in which operations must be deterministic (e.g. the ST monad), the array elements are initialised to a fixed but undefined value, such as zero.</source>
          <target state="translated">建立一个新的数组,每个元素初始化为一个未定义的值。在单项式上下文中,操作必须是确定性的(例如ST单项式),数组元素被初始化为一个固定但未定义的值,例如零。</target>
        </trans-unit>
        <trans-unit id="9185529c0692a9b618d7cbf93f4568e19c94d3ee" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to the supplied value.</source>
          <target state="translated">建立一个新的数组,每个元素都初始化为提供的值。</target>
        </trans-unit>
        <trans-unit id="8214ecb33cfb7974c4f39c8c9d05735a2e2c8271" translate="yes" xml:space="preserve">
          <source>Builds a sequence from a seed value. Takes time linear in the number of generated elements. &lt;em&gt;WARNING:&lt;/em&gt; If the number of generated elements is infinite, this method will not terminate.</source>
          <target state="translated">从种子值构建序列。时间与生成的元素数量成线性关系。&lt;em&gt;警告：&lt;/em&gt;如果生成的元素数是无限的，则此方法不会终止。</target>
        </trans-unit>
        <trans-unit id="7b20d8714b6e61b13e739bc27b8ce588d42b92f5" translate="yes" xml:space="preserve">
          <source>Builds a time value from a parsed input string. If the input does not include all the information needed to construct a complete value, any missing parts should be taken from 1970-01-01 00:00:00 +0000 (which was a Thursday). In the absence of &lt;code&gt;%C&lt;/code&gt; or &lt;code&gt;%Y&lt;/code&gt;, century is 1969 - 2068.</source>
          <target state="translated">根据已解析的输入字符串构建时间值。如果输入不包括构造一个完整值所需的所有信息，则所有缺少的部分都应取自1970-01-01 00:00:00 +0000（这是星期四）。在没有 &lt;code&gt;%C&lt;/code&gt; 或 &lt;code&gt;%Y&lt;/code&gt; 的情况下，世纪是1969年-2068年。</target>
        </trans-unit>
        <trans-unit id="0e8e2b2ccd17965cacc18d35e9f5403a32e7112a" translate="yes" xml:space="preserve">
          <source>Builds and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">生成并返回 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 的新实例。</target>
        </trans-unit>
        <trans-unit id="76ca7a4e55fa9d29e200dbea08886efb9fb74322" translate="yes" xml:space="preserve">
          <source>Built-in names</source>
          <target state="translated">内置名称</target>
        </trans-unit>
        <trans-unit id="e2f8f611e0d7e4911d6a941a4fb69322eea24213" translate="yes" xml:space="preserve">
          <source>Built-in rule ensures that applications of this function to literal Word# are lifted into Natural literals.</source>
          <target state="translated">内建规则确保该函数对字面Word#的应用被提升为自然字面。</target>
        </trans-unit>
        <trans-unit id="396f77e795df5a4def2612076c16d77e30f3c69e" translate="yes" xml:space="preserve">
          <source>Bundled Patterns</source>
          <target state="translated">捆绑模式</target>
        </trans-unit>
        <trans-unit id="26b720e58894a51047c1c6e9ca37a4f1f3595b00" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">对捆绑的模式同义词进行类型检查，以确保它们与捆绑的类型构造函数具有相同的类型。如果 &lt;code&gt;P&lt;/code&gt; 的类型明显与 &lt;code&gt;T&lt;/code&gt; 不兼容，则模式同义词 &lt;code&gt;P&lt;/code&gt; 不能与类型构造函数 &lt;code&gt;T&lt;/code&gt; 捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="9bbc0ee622ef87f959fb1f6a96e0d378e9dec049" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">对捆绑的模式同义词进行类型检查，以确保它们与捆绑的类型构造器具有相同的类型。如果 &lt;code&gt;P&lt;/code&gt; 的类型明显与 &lt;code&gt;T&lt;/code&gt; 不兼容，则模式同义词 &lt;code&gt;P&lt;/code&gt; 不能与类型构造函数 &lt;code&gt;T&lt;/code&gt; 捆绑在一起。</target>
        </trans-unit>
        <trans-unit id="4464772fd83cffa489cd2cb879896c855ed166d2" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have distinct types, and so can&amp;rsquo;t be compared. It&amp;rsquo;s just about possible to imagine examples in which the derived instance would make sense, but it seems altogether simpler simply to prohibit such declarations. Define your own instances!</source>
          <target state="translated">但是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 具有不同的类型，因此无法进行比较。可以想象在派生实例中有意义的示例，但是简单地禁止这样的声明似乎完全简单。定义自己的实例！</target>
        </trans-unit>
        <trans-unit id="b6ef53f84ff5027bc07ac3842944ad3414ad9d1f" translate="yes" xml:space="preserve">
          <source>But Haskell programmers can safely think of the ordinary &lt;em&gt;universally&lt;/em&gt; quantified type given above, thereby avoiding adding a new existential quantification construct.</source>
          <target state="translated">但是Haskell程序员可以放心地想到上面给出的普通&lt;em&gt;通用&lt;/em&gt;量化类型，从而避免添加新的存在量化结构。</target>
        </trans-unit>
        <trans-unit id="1a5eaf2134b45ec93619a779aa721cc224a4fe25" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">但是，因为启用了&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;，所以 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 字符串文字现在将是 &lt;code&gt;Text&lt;/code&gt; 类型，而不是 &lt;code&gt;String&lt;/code&gt; 类型，而 &lt;code&gt;showString&lt;/code&gt; 不接受！这将导致生成的 &lt;code&gt;Show&lt;/code&gt; 实例无法进行类型检查。很难想象会有任何在派生代码中具有&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;行为的情况，因此GHC 在检查派生代码时完全忽略了&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a148ffd04c373d017a1eeb4091389373b44c4def" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">但是因为启用了&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;，所以 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 字符串文字现在将是 &lt;code&gt;Text&lt;/code&gt; 类型，而不是 &lt;code&gt;String&lt;/code&gt; 类型，而 &lt;code&gt;showString&lt;/code&gt; 不接受！这将导致生成的 &lt;code&gt;Show&lt;/code&gt; 实例无法进行类型检查。很难想象会有任何情况在派生代码中具有&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;行为，因此GHC在检查派生代码时完全忽略了&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="513f043a73b80db70c830181c526df028997f561" translate="yes" xml:space="preserve">
          <source>But it is not clear what GHC would fill in for &lt;code&gt;???&lt;/code&gt;, as each data family instance must generate fresh data constructors.</source>
          <target state="translated">但不清楚GHC将填写什么 &lt;code&gt;???&lt;/code&gt; ，因为每个数据族实例都必须生成新的数据构造函数。</target>
        </trans-unit>
        <trans-unit id="35278e742589993fb14c61a18c5b5d7e9aec1d0d" translate="yes" xml:space="preserve">
          <source>But more efficiently than using length on the intermediate list.</source>
          <target state="translated">但比在中间列表上使用长度更有效。</target>
        </trans-unit>
        <trans-unit id="5845751806ebabdf9499df5449f17bf8fdf1e9d2" translate="yes" xml:space="preserve">
          <source>But not on lists with more than one element:</source>
          <target state="translated">但在有一个以上元素的列表上就不行了。</target>
        </trans-unit>
        <trans-unit id="1747f875a6f39afa8ae9cf4d467a26e849fc8649" translate="yes" xml:space="preserve">
          <source>But not this (since the free variable &lt;code&gt;a&lt;/code&gt; is in the wrong place):</source>
          <target state="translated">但这不是（因为自由变量 &lt;code&gt;a&lt;/code&gt; 在错误的位置）：</target>
        </trans-unit>
        <trans-unit id="65daa9e4b1075dc22f97b5e99c95b67c30d85438" translate="yes" xml:space="preserve">
          <source>But note that doing this will cause all currently loaded modules to be unloaded, and you&amp;rsquo;ll be dumped back into the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">但是请注意，这样做将导致当前所有已加载的模块被卸载，并且您将被转回到 &lt;code&gt;Prelude&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5f500af96a3dd31762b3cd040fbfe22ac1abfff8" translate="yes" xml:space="preserve">
          <source>But some more exotic characters are (like HTML's &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;):</source>
          <target state="translated">但是还有一些更奇特的字符（例如HTML的 &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="7a9f84020f58d91882dbfc0db953fb2f507004d2" translate="yes" xml:space="preserve">
          <source>But sometimes you really do need to catch any exception, and actually see what the exception is. One example is at the very top-level of a program, you may wish to catch any exception, print it to a logfile or the screen, and then exit gracefully. For these cases, you can use &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; (or one of the other exception-catching functions) with the &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">但是有时您确实确实需要捕获任何异常，并实际查看异常是什么。一个示例位于程序的最顶层，您可能希望捕获任何异常，将其打印到日志文件或屏幕，然后正常退出。对于这些情况，可以将 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; （或其他异常捕获功能之一）与 &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 类型一起使用。</target>
        </trans-unit>
        <trans-unit id="8e72f01b86fcf7d8b9f975c29c3a1117f8ed8c6a" translate="yes" xml:space="preserve">
          <source>But superclass constraints like these are sometimes useful, and the conservative check is annoying where no actual recursion is involved.</source>
          <target state="translated">但是像这样的超类约束有时是有用的,在不涉及实际递归的情况下,保守的检查是很烦人的。</target>
        </trans-unit>
        <trans-unit id="73f40a957f0eafaef43b7412e6b7eae8ca1629e4" translate="yes" xml:space="preserve">
          <source>But suppose we made a slight adjustment to the order of the instance context, putting &lt;code&gt;E a&lt;/code&gt; before &lt;code&gt;D a&lt;/code&gt;:</source>
          <target state="translated">但是，假设我们对实例上下文的顺序进行了一些调整，将 &lt;code&gt;E a&lt;/code&gt; 放在 &lt;code&gt;D a&lt;/code&gt; 之前：</target>
        </trans-unit>
        <trans-unit id="cfea8bf40fe32a0b6ae6eb32e50457a3bbe00861" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">但是以下所有内容都是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7731812692d70803e0e0e350c8da86a84a0c20be" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">但是以下所有内容都是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a8d348a97b3765db0e297f4b99bd3286d0a14a90" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">但是以下所有内容都是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91df2416d261e941ac64542c14e564e449aadd62" translate="yes" xml:space="preserve">
          <source>But the following doesn't terminate:</source>
          <target state="translated">但下面并没有终止。</target>
        </trans-unit>
        <trans-unit id="7717e46be083515ecb72e392ec90c5060d7fc5a3" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">但是以下操作应该总体上失败，因为我们尝试将 &lt;code&gt;'m'&lt;/code&gt; 解析为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的第一个操作将失败：</target>
        </trans-unit>
        <trans-unit id="1a58bd6d5d0e7ba62e5be7b51f024f151d484faf" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">但是以下操作应该总体上失败，因为我们尝试将 &lt;code&gt;'m'&lt;/code&gt; 解析为 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的第一个操作将失败：</target>
        </trans-unit>
        <trans-unit id="8f2d73619f8d796daeb72fd392f5ed8f12263a1e" translate="yes" xml:space="preserve">
          <source>But there is one exception: free variables mentioned in the outermost kind signature on the right hand side are quantified implicitly. Thus, in the following example the variables &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are all in scope on the right hand side of &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">但是有一个例外：右侧最外层签名中提到的自由变量被隐式量化。因此，在以下示例中，变量 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 都在 &lt;code&gt;S&lt;/code&gt; 的右侧范围内：</target>
        </trans-unit>
        <trans-unit id="4ca875b680fdb97fc74f9300d7be351d9a268b49" translate="yes" xml:space="preserve">
          <source>But these are not:</source>
          <target state="translated">但这些都不是。</target>
        </trans-unit>
        <trans-unit id="808cb3b77f5d26da60e12a8c2e267fb2361422db" translate="yes" xml:space="preserve">
          <source>But this instantiation and re-generalisation happens only at the top level of a type. In particular, none of this happens if the foralls are underneath an arrow. For example:</source>
          <target state="translated">但是这种实例化和再泛化只发生在一个类型的顶层。特别是,如果foralls在一个箭头下面,这些都不会发生。比如说</target>
        </trans-unit>
        <trans-unit id="7e7307e0fa3f238675a94c67154f45c09774348d" translate="yes" xml:space="preserve">
          <source>But this is unsound:</source>
          <target state="translated">但这是不健全的。</target>
        </trans-unit>
        <trans-unit id="032c3ace0e924d44f9ac3686950012f6f9c642b4" translate="yes" xml:space="preserve">
          <source>But when pattern matching on &lt;code&gt;Baz1&lt;/code&gt; the matched values can be compared for equality, and when pattern matching on &lt;code&gt;Baz2&lt;/code&gt; the first matched value can be converted to a string (as well as applying the function to it). So this program is legal:</source>
          <target state="translated">但是，当在 &lt;code&gt;Baz1&lt;/code&gt; 上进行模式匹配时，可以比较匹配的值是否相等，并且在 &lt;code&gt;Baz2&lt;/code&gt; 上进行模式匹配时，可以将第一个匹配值转换为字符串（以及将函数应用于该字符串）。所以这个程序是合法的：</target>
        </trans-unit>
        <trans-unit id="48b6f05d33c295f64d2c3b6836ca407ebef98238" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;Maybe&amp;rdquo; we mean that the usual heuristic inlining rules apply (if the function body is small, or it is applied to interesting-looking arguments etc). Another way to understand the semantics is this:</source>
          <target state="translated">所谓&amp;ldquo;也许&amp;rdquo;，是指通常的启发式内联规则适用（如果函数主体较小，或者适用于看起来有趣的参数等）。理解语义的另一种方式是：</target>
        </trans-unit>
        <trans-unit id="e5e954f010734bc63857acf7253cb96bcc09c253" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;ambiguous&amp;rdquo; we mean that there is a type variable &lt;code&gt;e&lt;/code&gt; that appears on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, but not on the right. The problem with this is that, according to the theoretical foundations of Haskell overloading, we cannot guarantee a well-defined semantics for any term with an ambiguous type.</source>
          <target state="translated">&amp;ldquo;模棱两可&amp;rdquo;是指在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号的左侧而不是右侧出现类型变量 &lt;code&gt;e&lt;/code&gt; 。问题是，根据Haskell重载的理论基础，我们不能保证任何含糊类型的术语都具有明确定义的语义。</target>
        </trans-unit>
        <trans-unit id="a9626f1ba2bf1f860641df5bd3f3382835b801df" translate="yes" xml:space="preserve">
          <source>By contrast, &lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lifted-base&lt;/a&gt;'s version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; always discards all of &lt;code&gt;g&lt;/code&gt;'s non-IO effects, and &lt;code&gt;g&lt;/code&gt; never sees any of &lt;code&gt;f&lt;/code&gt;'s non-IO effects, regardless of the layer ordering and regardless of whether &lt;code&gt;f&lt;/code&gt; throws an error. This is not the result of interacting effects, but a consequence of &lt;code&gt;MonadBaseControl&lt;/code&gt;'s approach.</source>
          <target state="translated">相比之下，&lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lift-base&lt;/a&gt;的版本 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 总是丢弃 &lt;code&gt;g&lt;/code&gt; 的所有非IO效果，并且 &lt;code&gt;g&lt;/code&gt; 永远不会看到 &lt;code&gt;f&lt;/code&gt; 的任何非IO效果，无论层顺序和 &lt;code&gt;f&lt;/code&gt; 是否引发错误。 。这不是交互作用的结果，而是 &lt;code&gt;MonadBaseControl&lt;/code&gt; 方法的结果。</target>
        </trans-unit>
        <trans-unit id="9f8fa066b62ce9de7834b32b1ffd79abe4903ede" translate="yes" xml:space="preserve">
          <source>By convention, overloaded functions have a non-overloaded counterpart whose name is suffixed with `&lt;code&gt;By&lt;/code&gt;'.</source>
          <target state="translated">按照惯例，重载函数具有一个未重载的对应函数，其名称后缀为' &lt;code&gt;By&lt;/code&gt; '。</target>
        </trans-unit>
        <trans-unit id="896bbb1ee06a6fe71b9beeaa9d18f1143bc8c3b4" translate="yes" xml:space="preserve">
          <source>By default (when &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is not specified), GHC exposes only one version of a package, all other versions become hidden. If &lt;code&gt;-package&lt;/code&gt; option is specified multiple times for the same package the last one overrides the previous ones. On the other hand, if &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is used, GHC allows you to expose multiple versions of a package by using the &lt;code&gt;-package&lt;/code&gt; option multiple times with different versions of the same package.</source>
          <target state="translated">缺省情况下（未指定&lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; 时&lt;/a&gt;），GHC仅公开一个版本的软件包，所有其他版本均被隐藏。如果为同一软件包多次指定 &lt;code&gt;-package&lt;/code&gt; 选项，则最后一个将覆盖先前的软件包。另一方面，如果使用&lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt;，则GHC允许您通过对同一软件包的不同版本多次使用 &lt;code&gt;-package&lt;/code&gt; 选项来公开软件包的多个版本。</target>
        </trans-unit>
        <trans-unit id="c08f7a94109584e7aa0e6d79a4e77ce07a68fae9" translate="yes" xml:space="preserve">
          <source>By default Ctl-C will generate a &lt;code&gt;SIGINT&lt;/code&gt; signal, causing a &lt;code&gt;UserInterrupt&lt;/code&gt; exception to be sent to the main Haskell thread of your program, which if not specially handled will terminate the program. Normally, this is exactly what is wanted: an orderly shutdown of the program in response to Ctl-C.</source>
          <target state="translated">默认情况下，Ctl-C将生成 &lt;code&gt;SIGINT&lt;/code&gt; 信号，从而将 &lt;code&gt;UserInterrupt&lt;/code&gt; 异常发送到您程序的主Haskell线程，如果没有特别处理，它将终止程序。通常，这正是需要的：响应Ctl-C有序关闭程序。</target>
        </trans-unit>
        <trans-unit id="85da6991904e0f3fd3e4bbad20cbc4f4be16d997" translate="yes" xml:space="preserve">
          <source>By default GHC builds applications that open a console window when they start. If you want to build a GUI-only application, with no console window, use the flag &lt;code&gt;-optl-mwindows&lt;/code&gt; in the link step.</source>
          <target state="translated">默认情况下，GHC构建的应用程序在启动时会打开控制台窗口。如果要构建没有控制台窗口的 &lt;code&gt;-optl-mwindows&lt;/code&gt; GUI应用程序，请在链接步骤中使用-optl-mwindows标志。</target>
        </trans-unit>
        <trans-unit id="e8d919b56909f1bc95e959f98255a58354f13898" translate="yes" xml:space="preserve">
          <source>By default GHC will be very quiet about what it is doing, only printing error messages. If you want to see in more detail what&amp;rsquo;s going on behind the scenes, add &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; to the command line.</source>
          <target state="translated">默认情况下，GHC将对正在执行的操作保持安静，仅打印错误消息。如果您想更详细地了解幕后情况，请在命令行中添加&lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="188b3edf5485565e6e6ef6439aa7adfb9f3f40c8" translate="yes" xml:space="preserve">
          <source>By default only type class methods and methods marked &lt;code&gt;INLINABLE&lt;/code&gt; or &lt;code&gt;INLINE&lt;/code&gt; are specialised. This flag will specialise any overloaded function regardless of size if its unfolding is available. This flag is not included in any optimisation level as it can massively increase code size. It can be used in conjunction with &lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt;&lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt;&lt;/a&gt; if you want to ensure all calls are specialised.</source>
          <target state="translated">默认情况下，仅专门处理类型类方法和标记为 &lt;code&gt;INLINABLE&lt;/code&gt; 或 &lt;code&gt;INLINE&lt;/code&gt; 的方法。如果可以展开，此标志将专用于任何重载函数，而不管其大小如何。此标志未包含在任何优化级别中，因为它会大大增加代码大小。如果要确保所有调用都专用，可以将它与&lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt; &lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt; &lt;/a&gt;结合使用。</target>
        </trans-unit>
        <trans-unit id="624e8cce7ea7cdb4e472abd23a004063a0206d28" translate="yes" xml:space="preserve">
          <source>By default the valid hole fits are sorted to show the most relevant hole fits at the top of the list of valid hole fits. This can be toggled off with this flag.</source>
          <target state="translated">默认情况下,有效的孔配合是排序的,在有效孔配合列表的顶部显示最相关的孔配合。这个可以用这个标志来关闭。</target>
        </trans-unit>
        <trans-unit id="c1764f7c7473b983f83b4e96209c1fd4c0ad4af0" translate="yes" xml:space="preserve">
          <source>By default this module is set up to parse character data. If you'd like to parse the result of your own tokenizer you should start with the following imports:</source>
          <target state="translated">默认情况下,该模块被设置为解析字符数据。如果你想解析你自己的tokenizer的结果,你应该从下面的导入开始。</target>
        </trans-unit>
        <trans-unit id="0ce3ebf665bc95b496362425218966d039437681" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ghc -M&lt;/code&gt; generates all the dependencies, and then concatenates them onto the end of &lt;code&gt;makefile&lt;/code&gt; (or &lt;code&gt;Makefile&lt;/code&gt; if &lt;code&gt;makefile&lt;/code&gt; doesn&amp;rsquo;t exist) bracketed by the lines &amp;ldquo;&lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt;&amp;rdquo;. If these lines already exist in the &lt;code&gt;makefile&lt;/code&gt;, then the old dependencies are deleted first.</source>
          <target state="translated">默认情况下， &lt;code&gt;ghc -M&lt;/code&gt; 生成所有依赖项，然后将它们连接到 &lt;code&gt;makefile&lt;/code&gt; 的末尾（如果 &lt;code&gt;makefile&lt;/code&gt; 不存在，则将其合并到 &lt;code&gt;Makefile&lt;/code&gt; 的末尾），并用&amp;ldquo; &lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt; &amp;rdquo;。如果 &lt;code&gt;makefile&lt;/code&gt; 中已经存在这些行，则首先删除旧的依赖项。</target>
        </trans-unit>
        <trans-unit id="a1836101dccd7400532d625ffcce0904ab5ebfa5" translate="yes" xml:space="preserve">
          <source>By default, GHC (as the Haskell 2010 standard prescribes) parses identifiers starting with an underscore in a type as type variables. To treat them as named wildcards, the &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; extension should be enabled. The example below demonstrated the effect.</source>
          <target state="translated">默认情况下，GHC（按Haskell 2010标准的规定）将以下划线开头的标识符解析为类型变量。要将它们视为命名通配符，应启用&lt;a href=&quot;#extension-NamedWildCards&quot;&gt; &lt;code&gt;NamedWildCards&lt;/code&gt; &lt;/a&gt;扩展。下面的示例演示了效果。</target>
        </trans-unit>
        <trans-unit id="375ba54e7f496ec128d1b7ef8611af8553668782" translate="yes" xml:space="preserve">
          <source>By default, GHC ignores Haddock comments (&lt;code&gt;-- | ...&lt;/code&gt; and &lt;code&gt;-- ^ ...&lt;/code&gt;) and does not check that they&amp;rsquo;re associated with a valid term, such as a top-level type-signature. With this flag GHC will parse Haddock comments and include them in the interface file it produces.</source>
          <target state="translated">默认情况下，GHC会忽略Haddock注释（ &lt;code&gt;-- | ...&lt;/code&gt; 和 &lt;code&gt;-- ^ ...&lt;/code&gt; ），并且不检查它们是否与有效术语（例如顶级类型签名）相关联。GHC将使用此标志解析Haddock注释，并将其包括在它生成的接口文件中。</target>
        </trans-unit>
        <trans-unit id="5545ec84b6af100d02a17fdcb1293a391503367a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">默认情况下，GHC的主要目的是（基本上）像Haskell 2010编译器那样运行，尽管您可以使用&lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt;标志来告诉它尝试像特定版本的语言一样运行。与标准的已知偏差如下所述。除非另有说明，否则该偏差适用于Haskell 98，Haskell 2010和默认模式。</target>
        </trans-unit>
        <trans-unit id="12df8ed1e15edda69c0c572579814ea973c3f99c" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">默认情况下，GHC的主要目的是（基本上）像Haskell 2010编译器那样运行，尽管您可以使用&lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt;标志来告诉它尝试像特定版本的语言一样运行。与标准的已知偏差如下所述。除非另有说明，否则该偏差适用于Haskell 98，Haskell 2010和默认模式。</target>
        </trans-unit>
        <trans-unit id="9abdae9b40906f9cfda31d516ba3c096c45e1e1a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;code&gt;-XHaskell98&lt;/code&gt; and &lt;code&gt;-XHaskell2010&lt;/code&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">默认情况下，GHC的主要目的是（基本上）像Haskell 2010编译器那样运行，尽管您可以使用 &lt;code&gt;-XHaskell98&lt;/code&gt; 和 &lt;code&gt;-XHaskell2010&lt;/code&gt; 标志让它尝试像特定版本的语言一样运行。与标准的已知偏差如下所述。除非另有说明，否则该偏差适用于Haskell 98，Haskell 2010和默认模式。</target>
        </trans-unit>
        <trans-unit id="ec779fb59a0c807c306278944368725099b24555" translate="yes" xml:space="preserve">
          <source>By default, GHC will automatically link in the &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages. This flag disables that behaviour.</source>
          <target state="translated">默认情况下，GHC将自动链接 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;rts&lt;/code&gt; 软件包。此标志禁用该行为。</target>
        </trans-unit>
        <trans-unit id="df55ad44f83f85e9c4e4f4d6d779d38193eb5c3e" translate="yes" xml:space="preserve">
          <source>By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system. GHCi can also compile Haskell code to object code: to turn on this feature, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; flag either on the command line or with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (the option &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; restores byte-code compilation again). Compiling to object code takes longer, but typically the code will execute 10-20 times faster than byte-code.</source>
          <target state="translated">默认情况下，GHCi将Haskell源代码编译为运行时系统解释的字节码。GHCi也可以将Haskell代码编译为目标代码：要启用此功能，请在命令行上或通过&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;标志（选项&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; 可&lt;/a&gt;再次恢复字节码编译）。编译为目标代码需要更长的时间，但是通常，该代码的执行速度比字节码快10到20倍。</target>
        </trans-unit>
        <trans-unit id="5e88504b814b1fec26bf7b42a2f12aaadb66f2cc" translate="yes" xml:space="preserve">
          <source>By default, GHCi keeps global history in &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; or &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt;, but you can use current directory, e.g.:</source>
          <target state="translated">默认情况下，GHCi将全局历史记录保留在 &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; 或 &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt; 中，但是您可以使用当前目录，例如：</target>
        </trans-unit>
        <trans-unit id="fdbafe643d46838671b1a066fee2f9329338669e" translate="yes" xml:space="preserve">
          <source>By default, all exposed packages in the normal, source import namespace are also available for plugins. This causes those packages to be hidden by default. If you use this flag, then any packages with plugins you require need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">默认情况下，正常的源导入名称空间中的所有公开包也可用于插件。这将导致这些包在默认情况下被隐藏。如果使用此标志，则需要使用&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;选项显式公开所需的所有带有插件的软件包。</target>
        </trans-unit>
        <trans-unit id="82625d74a09e8d4b74d07dfbe3c657128326ccf1" translate="yes" xml:space="preserve">
          <source>By default, all fields in algebraic data types are linear (even if &lt;code&gt;-XLinearTypes&lt;/code&gt; is not turned on). Given</source>
          <target state="translated">默认情况下，代数数据类型中的所有字段都是线性的（即使未打开 &lt;code&gt;-XLinearTypes&lt;/code&gt; ）。给定</target>
        </trans-unit>
        <trans-unit id="46539ad051a890125fb96d050b762a5dd85eaf9d" translate="yes" xml:space="preserve">
          <source>By default, all of the capabilities participate in parallel garbage collection. If we want to use a very large &lt;code&gt;-N&lt;/code&gt; value, however, this can reduce the performance of the GC. For this reason, the &lt;code&gt;-qn&lt;/code&gt; flag can be used to specify a lower number for the threads that should participate in GC. During GC, if there are more than this number of workers active, some of them will sleep for the duration of the GC.</source>
          <target state="translated">默认情况下，所有功能都参与并行垃圾回收。但是，如果我们要使用非常大的 &lt;code&gt;-N&lt;/code&gt; 值，则会降低GC的性能。因此，可以使用 &lt;code&gt;-qn&lt;/code&gt; 标志为应该参与GC的线程指定一个较小的数字。在GC期间，如果活动的工人数量超过此数目，则其中一些工人将在GC期间休眠。</target>
        </trans-unit>
        <trans-unit id="dff65f59491f27c9a1b1f59bb08671c0847e3677" translate="yes" xml:space="preserve">
          <source>By default, each hole fit shows the provenance information of its hole fit, i.e. where it was bound or defined, and what module it was originally defined in if it was imported. This can be toggled off using the reverse of this flag.</source>
          <target state="translated">默认情况下,每个孔配合都会显示其孔配合的出处信息,即它是在哪里绑定或定义的,如果是导入的,它最初是在哪个模块中定义的。这可以使用这个标志的反面来切换关闭。</target>
        </trans-unit>
        <trans-unit id="40b07e5a3f0d5d2adc75edc52198eb4a7127369d" translate="yes" xml:space="preserve">
          <source>By default, if idle GC is enabled in the threaded runtime, a major GC will be performed every time the process goes idle for a sufficiently long duration (see &lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt;&lt;code&gt;-I ⟨seconds⟩&lt;/code&gt;&lt;/a&gt;). For large server processes accepting regular but infrequent requests (e.g., once per second), an expensive, major GC may run after every request. As an alternative to shutting off idle GC entirely (with &lt;code&gt;-I0&lt;/code&gt;), a minimum wait time between idle GCs can be specified with this flag. For example, &lt;code&gt;-Iw60&lt;/code&gt; will ensure that an idle GC runs at most once per minute.</source>
          <target state="translated">默认情况下，如果在线程化运行时中启用了空闲GC，则每次进程空闲足够长的时间（参见&lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt; &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; &lt;/a&gt;）时，都会执行主GC 。对于接受定期但不频繁的请求（例如，每秒一次）的大型服务器进程，可能在每个请求之后运行昂贵的大型GC。作为完全关闭空闲GC（使用 &lt;code&gt;-I0&lt;/code&gt; ）的替代方法，可以使用此标志指定空闲GC之间的最短等待时间。例如， &lt;code&gt;-Iw60&lt;/code&gt; 将确保空闲的GC每分钟最多运行一次。</target>
        </trans-unit>
        <trans-unit id="00e1d7b164983ad889522ed53190607d61c4610f" translate="yes" xml:space="preserve">
          <source>By default, modules compiled with plugins are always recompiled even if the source file is unchanged. This most conservative option is taken due to the ability of plugins to perform arbitrary IO actions. In order to control the recompilation behaviour you can modify the &lt;code&gt;pluginRecompile&lt;/code&gt; field in &lt;code&gt;Plugin&lt;/code&gt;.</source>
          <target state="translated">默认情况下，即使源文件未更改，也始终会重新编译使用插件编译的模块。由于插件具有执行任意IO操作的能力，因此采用了这种最保守的选项。为了控制重新编译行为，您可以修改 &lt;code&gt;Plugin&lt;/code&gt; 中的 &lt;code&gt;pluginRecompile&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="eb82d4dffabcd57e78239ea2df207ce6d76727da" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if a set of patterns are overlapping, e.g.,</source>
          <target state="translated">默认情况下,如果一组模式重叠,编译器会警告你,例如。</target>
        </trans-unit>
        <trans-unit id="069c263ac2190411cc9526082fc8f4fd76502131" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if types make a branch inaccessible. This generally requires GADTs or similar extensions.</source>
          <target state="translated">默认情况下,如果类型使一个分支无法访问,编译器会警告你。这通常需要GADTs或类似的扩展。</target>
        </trans-unit>
        <trans-unit id="42ececaa43e2537fc3e254dd2078e6ca5e31deaf" translate="yes" xml:space="preserve">
          <source>By default, the entry points of all the object files will be exported from the DLL when using &lt;code&gt;-shared&lt;/code&gt;. Should you want to constrain this, you can specify the &lt;em&gt;module definition file&lt;/em&gt; to use on the command line as follows:</source>
          <target state="translated">默认情况下，使用 &lt;code&gt;-shared&lt;/code&gt; 时，将从DLL中导出所有目标文件的入口点。如果要对此进行限制，可以按如下所示在命令行上指定要使用的&lt;em&gt;模块定义文件&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="8cda497389193e1649e303cab4fabec282743541" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overridden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overridden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">默认情况下，当同步时间超过指定时间时，该标志将导致向stderr发出警告。但是，可以 &lt;code&gt;longGCSync()&lt;/code&gt; 此行为：在同步期间超过同步时间时，将 &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 挂钩，并在末尾调用longGCSyncEnd（）挂钩。当使用 &lt;code&gt;hs_init_ghc()&lt;/code&gt; 启动运行 &lt;code&gt;RtsConfig&lt;/code&gt; ，可以在RtsConfig中覆盖这两个钩子。这些钩子的默认实现 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; 分别为 &lt;code&gt;LongGcSync()&lt;/code&gt; 和LongGCSyncEnd（））向stderr打印警告。</target>
        </trans-unit>
        <trans-unit id="9fe9a2f0fe153f620abcfa8682464add226d1fdb" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overriden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overriden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">默认情况下，当同步时间超过指定时间时，该标志将导致向stderr发出警告。此行为可以被覆盖，但是：在 &lt;code&gt;longGCSync()&lt;/code&gt; 在同步期间超过同步时间时钩被调用，并且 &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 在端钩。使用 &lt;code&gt;hs_init_ghc()&lt;/code&gt; 启动运行 &lt;code&gt;RtsConfig&lt;/code&gt; ，可以在RtsConfig中覆盖这两个钩子。这些钩子的默认实现 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; 分别为 &lt;code&gt;LongGcSync()&lt;/code&gt; 和LongGCSyncEnd（））向stderr打印警告。</target>
        </trans-unit>
        <trans-unit id="7ddee701400360fbf24135d74284e1d2f92e56f8" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This flag toggles whether to show &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; instead of &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; in the where clause of the valid hole fit message.</source>
          <target state="translated">默认情况下，孔配合显示使该孔适合孔的类型所需的类型应用程序，例如，对于孔 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; &amp;gt; [Int]），mempty :: Monoid a =&amp;gt; a是一个孔适合 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; 。此标志切换是否在有效的孔拟合消息的where子句中显示 &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; &amp;gt; [Int]）而不是mempty @（Int-&amp;gt; [Int]）。</target>
        </trans-unit>
        <trans-unit id="d54e2c2c7ff09cca548a7181b38ba4eb543ff3ab" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This can be toggled off with the reverse of this flag.</source>
          <target state="translated">默认情况下，孔配合显示使该孔适合孔的类型所需的类型应用程序，例如，对于孔 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; &lt;code&gt;mempty&lt;/code&gt; &amp;gt; [Int]），mempty是带有 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; 。可以通过此标志的相反方向将其关闭。</target>
        </trans-unit>
        <trans-unit id="35d5a2ec055ae5d603afdd7b0fe5afae1fc6be21" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type of the hole fit. This can be turned off by the reverse of this flag.</source>
          <target state="translated">默认情况下,孔配合显示孔配合的类型。這可以通過這個標誌的反面來關閉。</target>
        </trans-unit>
        <trans-unit id="98a6c6abf4876ada1cf384346f6c09b294c533e7" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">默认情况下，类型检查器将报告部分类型签名中每个孔的错误消息，以将推断出的类型通知程序员。当&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;启用扩展，类型检查器将接受该推断出的类型对于每个孔，生成警告，而不是错误。此外，可以使用&lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt;标志使这些警告静音。</target>
        </trans-unit>
        <trans-unit id="5f832c954f21105383f315f5795a3f1e4b92e9c8" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">默认情况下，类型检查器将报告部分类型签名中每个孔的错误消息，以将推断出的类型通知程序员。当&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;启用扩展，类型检查器将接受该推断出的类型对于每个孔，生成警告，而不是错误。此外，可以使用&lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt;标志使这些警告静音。</target>
        </trans-unit>
        <trans-unit id="73c75d191039b62d5631ea3a5a9bfa7631f5b38e" translate="yes" xml:space="preserve">
          <source>By default, this means that everything from the module &lt;code&gt;Prelude&lt;/code&gt; is currently in scope. Should the prompt be set to &lt;code&gt;%s&amp;gt;&lt;/code&gt; in the &lt;code&gt;.ghci&lt;/code&gt; configuration file, we would be seeing &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; displayed. However, it is not the default mechanism due to the large space the prompt can take if more imports are done.</source>
          <target state="translated">默认情况下，这意味着 &lt;code&gt;Prelude&lt;/code&gt; 模块中的所有内容当前都在作用域内。如果在 &lt;code&gt;.ghci&lt;/code&gt; 配置文件中将提示设置为 &lt;code&gt;%s&amp;gt;&lt;/code&gt; ，我们将看到显示 &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; 。但是，这不是默认机制，因为如果完成更多导入，提示可能会占用很大的空间。</target>
        </trans-unit>
        <trans-unit id="bbc06aef5e5a39593988fb4a13a30427cfe33d3b" translate="yes" xml:space="preserve">
          <source>By default, when a module is compiled with plugins, it will be marked as unsafe. With this flag passed, all plugins are treated as trustworthy and the safety inference will no longer be affected.</source>
          <target state="translated">默认情况下,当一个模块在编译时使用了插件,它将被标记为不安全。通过这个标志后,所有的插件都会被视为可信任的,安全推理将不再受到影响。</target>
        </trans-unit>
        <trans-unit id="174e61791c2af8c07db7989b5f30fdc0a9f3888b" translate="yes" xml:space="preserve">
          <source>By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are:</source>
          <target state="translated">默认情况下,你会得到一组标准的警告,这些警告通常可能表明你的程序有错误。这些警告是:</target>
        </trans-unit>
        <trans-unit id="46283cfe9b92cf9ced3d37e5a425538fb2879a38" translate="yes" xml:space="preserve">
          <source>By feeding the ghc compiler driver the option &lt;code&gt;-shared&lt;/code&gt;, it will build a DLL rather than produce an executable. The DLL will consist of all the object files and archives given on the command line.</source>
          <target state="translated">通过为ghc编译器驱动程序提供 &lt;code&gt;-shared&lt;/code&gt; 选项，它将构建DLL而不是生成可执行文件。DLL将包含命令行上给定的所有目标文件和归档。</target>
        </trans-unit>
        <trans-unit id="8504674d3abb04bdd53121c5e1c8cc5547351f38" translate="yes" xml:space="preserve">
          <source>By including dependencies in a class declaration, we provide a mechanism for the programmer to specify each multiple parameter class more precisely. The compiler, on the other hand, is responsible for ensuring that the set of instances that are in scope at any given point in the program is consistent with any declared dependencies. For example, the following pair of instance declarations cannot appear together in the same scope because they violate the dependency for &lt;code&gt;D&lt;/code&gt;, even though either one on its own would be acceptable:</source>
          <target state="translated">通过在类声明中包含依赖项，我们为程序员提供了一种机制，可以更精确地指定每个多参数类。另一方面，编译器负责确保在程序中任何给定点范围内的实例集与任何声明的依赖项一致。例如，以下一对实例声明不能一起出现在同一作用域中，因为它们违反了对 &lt;code&gt;D&lt;/code&gt; 的依赖关系，即使它们中的任何一个都可以接受：</target>
        </trans-unit>
        <trans-unit id="a31672cadecf688e7c40679abceb4f7169dc8697" translate="yes" xml:space="preserve">
          <source>By inspecting the example &lt;code&gt;plugin&lt;/code&gt; defined above, we can see that it is pure. This means that if the two modules have the same fingerprint then the plugin will always return the same result. Declaring a plugin as pure means that the plugin will never cause a module to be recompiled.</source>
          <target state="translated">通过检查上面定义的示例 &lt;code&gt;plugin&lt;/code&gt; ，我们可以看到它是纯净的。这意味着，如果两个模块具有相同的指纹，则插件将始终返回相同的结果。将插件声明为纯插件意味着该插件将永远不会导致模块重新编译。</target>
        </trans-unit>
        <trans-unit id="85fd7daebedfdd6804e24888c9b0949a47ff5308" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in O(1) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">通过使其成为该类的成员，幂等半群和 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; 分别通过选择 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; 或stimes = stimesIdempotentMonoid将其升级为在O（1）中执行。</target>
        </trans-unit>
        <trans-unit id="280d0ae1e53ec0807b301a1828edbb266fb95f7c" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in \(\mathcal{O}(1)\) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">通过使其成为该类的成员，幂等半群和 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; 分别通过选择 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; 或stimes = stimesIdempotentMonoid将其升级为在\（\ mathcal {O}（1）\）中执行。</target>
        </trans-unit>
        <trans-unit id="60b0706ea95c7ca522f1b094a7d6011fac8bf09b" translate="yes" xml:space="preserve">
          <source>By overriding the &lt;code&gt;renamedResultAction&lt;/code&gt; field we can modify each &lt;code&gt;HsGroup&lt;/code&gt; after it has been renamed. A source file is separated into groups depending on the location of template haskell splices so the contents of these groups may not be intuitive. In order to save the entire renamed AST for inspection at the end of typechecking you can set &lt;code&gt;renamedResultAction&lt;/code&gt; to &lt;code&gt;keepRenamedSource&lt;/code&gt; which is provided by the &lt;code&gt;Plugins&lt;/code&gt; module. This is important because some parts of the renamed syntax tree (for example, imports) are not found in the typechecked one.</source>
          <target state="translated">通过覆盖重 &lt;code&gt;renamedResultAction&lt;/code&gt; 字段，我们可以在每个 &lt;code&gt;HsGroup&lt;/code&gt; 重命名后对其进行修改。根据模板haskell接头的位置，源文件分为几组，因此这些组的内容可能不直观。为了节省检查整个重命名AST的类型检查，您可以设置结束 &lt;code&gt;renamedResultAction&lt;/code&gt; 到 &lt;code&gt;keepRenamedSource&lt;/code&gt; 这是由提供 &lt;code&gt;Plugins&lt;/code&gt; 模块。这很重要，因为在类型检查的树中找不到重命名的语法树的某些部分（例如，导入）。</target>
        </trans-unit>
        <trans-unit id="96c953756e6001b89332797e663898838e62a7c0" translate="yes" xml:space="preserve">
          <source>By replacing &lt;code&gt;Str.hs&lt;/code&gt; with a signature &lt;code&gt;Str.hsig&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; (and any other modules in this package) are now parametrized by a string implementation:</source>
          <target state="translated">通过更换 &lt;code&gt;Str.hs&lt;/code&gt; 与签名 &lt;code&gt;Str.hsig&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; （并且在此包中的任何其它模块）现在由一个字符串实现参数化：</target>
        </trans-unit>
        <trans-unit id="4177c241d143fa0a5ca33741ceb19186757ef74e" translate="yes" xml:space="preserve">
          <source>By using qualified names, one can set breakpoints on all functions (top-level and nested) in every loaded and interpreted module:</source>
          <target state="translated">通过使用限定名称,可以在每个加载和解释的模块中对所有函数(顶层和嵌套)设置断点。</target>
        </trans-unit>
        <trans-unit id="bd2c213b8e4781cce6dcf36530ac2526d2c7bb34" translate="yes" xml:space="preserve">
          <source>By using them, you are telling GHC that you are willing to suffer longer compilation times for better-quality code.</source>
          <target state="translated">通过使用它们,你告诉GHC,你愿意为了更好的代码质量而忍受更长的编译时间。</target>
        </trans-unit>
        <trans-unit id="fc6baee463471fde1ecec97642f1d1ca74590180" translate="yes" xml:space="preserve">
          <source>Byte ordering.</source>
          <target state="translated">字节排序。</target>
        </trans-unit>
        <trans-unit id="a2e0dbd8b1ab09bde4319780f72a4d81435a048c" translate="yes" xml:space="preserve">
          <source>Byte swapping</source>
          <target state="translated">字节交换</target>
        </trans-unit>
        <trans-unit id="67ce106b074a2dd010e2ed6cebb15426f65787d3" translate="yes" xml:space="preserve">
          <source>ByteArray#</source>
          <target state="translated">ByteArray#</target>
        </trans-unit>
        <trans-unit id="b2ba0861bb06ea1a63c71749689a7beb9ea6b729" translate="yes" xml:space="preserve">
          <source>ByteCount</source>
          <target state="translated">ByteCount</target>
        </trans-unit>
        <trans-unit id="53bc4f0faf53dfa905efcd2b3b1d6b5236b29f9b" translate="yes" xml:space="preserve">
          <source>ByteOffset</source>
          <target state="translated">ByteOffset</target>
        </trans-unit>
        <trans-unit id="8a45cdc61d443f1d99e6a8e08a1a5cac63e13810" translate="yes" xml:space="preserve">
          <source>ByteOrder</source>
          <target state="translated">ByteOrder</target>
        </trans-unit>
        <trans-unit id="c237250b1379824c1dbf827faf23519fe09b6f29" translate="yes" xml:space="preserve">
          <source>ByteString</source>
          <target state="translated">ByteString</target>
        </trans-unit>
        <trans-unit id="f4fdba4ce7955a359ebc54c3d8b75dced1a5bcb3" translate="yes" xml:space="preserve">
          <source>ByteString I/O uses binary mode, without any character decoding or newline conversion. The fact that it does not respect the Handle newline mode is considered a flaw and may be changed in a future version.</source>
          <target state="translated">ByteString I/O使用二进制模式,没有任何字符解码或换行转换。它不尊重Handle换行模式的事实被认为是一个缺陷,可能会在未来的版本中被修改。</target>
        </trans-unit>
        <trans-unit id="141ecf8c9b6b748576d6f030e689b5ac01081c26" translate="yes" xml:space="preserve">
          <source>ByteStrings</source>
          <target state="translated">ByteStrings</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="f8cd96f16d9102cf1ed4d9be9ee1b34e6dca04ee" translate="yes" xml:space="preserve">
          <source>C compiler (opt.)</source>
          <target state="translated">C语言编译器</target>
        </trans-unit>
        <trans-unit id="f4f28ebdbc8eb0a109bc7de54e138a24cbdfbe50" translate="yes" xml:space="preserve">
          <source>C file</source>
          <target state="translated">C档</target>
        </trans-unit>
        <trans-unit id="8db42ba5780c0869ea2cc63ca7f695f38e31b373" translate="yes" xml:space="preserve">
          <source>C functions are normally declared using prototypes in a C header file. Earlier versions of GHC (6.8.3 and earlier) &lt;code&gt;#include&lt;/code&gt;d the header file in the C source file generated from the Haskell code, and the C compiler could therefore check that the C function being called via the FFI was being called at the right type.</source>
          <target state="translated">通常使用C头文件中的原型声明C函数。GHC的早期版本（6.8.3和更早版本） &lt;code&gt;#include&lt;/code&gt; 头文件在从Haskell代码生成的C源文件中，因此C编译器可以检查通过FFI调用的C函数是否在右侧被调用类型。</target>
        </trans-unit>
        <trans-unit id="f30e8dc9993cbcb352b6de3b6f306c76123830fc" translate="yes" xml:space="preserve">
          <source>C header</source>
          <target state="translated">C头</target>
        </trans-unit>
        <trans-unit id="e0a32b6cde92a02c4d0079b04d003ea26b8c8425" translate="yes" xml:space="preserve">
          <source>C pre-processor (opt.)</source>
          <target state="translated">C语言预处理器(选择)</target>
        </trans-unit>
        <trans-unit id="05da97e8f671dc8e81bb497ab7d0b559bb48f35f" translate="yes" xml:space="preserve">
          <source>C strings</source>
          <target state="translated">C字串</target>
        </trans-unit>
        <trans-unit id="a19e3f51c16c6cf9751d0517111b9e9046598db1" translate="yes" xml:space="preserve">
          <source>C strings with a configurable encoding</source>
          <target state="translated">可配置编码的 C 字符串</target>
        </trans-unit>
        <trans-unit id="2a2bdbc5a70792af2d724997593731718b21fae4" translate="yes" xml:space="preserve">
          <source>C wide strings</source>
          <target state="translated">C宽弦</target>
        </trans-unit>
        <trans-unit id="9389a51d4da82d4389a58627b6e1618412013bd7" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s command-line flags say to trust &lt;code&gt;P&lt;/code&gt; regardless of what is recorded in the package database.</source>
          <target state="translated">C的命令行标志表示信任 &lt;code&gt;P&lt;/code&gt; ,无论软件包数据库中记录了什么。</target>
        </trans-unit>
        <trans-unit id="be8c54d411949b31b40add83f394cd96144642ba" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s package database records that &lt;code&gt;P&lt;/code&gt; is trusted (and no command-line arguments override this)</source>
          <target state="translated">C的程序包数据库记录 &lt;code&gt;P&lt;/code&gt; 是受信任的（并且没有命令行参数会覆盖此参数）</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2db6df68dc5acc80ecf8fc1e995baa397dbbfd10" translate="yes" xml:space="preserve">
          <source>C-- representation</source>
          <target state="translated">C--代表</target>
        </trans-unit>
        <trans-unit id="4c91c2588a480fcaf1c89f77c993a5b28cde7c85" translate="yes" xml:space="preserve">
          <source>C-\- pass sanity checking</source>
          <target state="translated">C------------------通过安全检查</target>
        </trans-unit>
        <trans-unit id="53224a3fe23d089d17e25bc63ef74d76f7140e70" translate="yes" xml:space="preserve">
          <source>C-\- representation</source>
          <target state="translated">C-/-代表</target>
        </trans-unit>
        <trans-unit id="31a8186414085b899b97c056b647bb5d6f3812d1" translate="yes" xml:space="preserve">
          <source>C-specific Marshalling support: Handling of C &quot;errno&quot; error codes.</source>
          <target state="translated">支持C语言特有的Marshalling。处理C语言 &quot;errno &quot;错误代码。</target>
        </trans-unit>
        <trans-unit id="28c27031fe7162d732a1c2e209a40bbfcb5fef90" translate="yes" xml:space="preserve">
          <source>C1</source>
          <target state="translated">C1</target>
        </trans-unit>
        <trans-unit id="6c0a03c4460fb3c0c00906dce789ea44d2c84225" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;0 :: BigNat&lt;/code&gt;</source>
          <target state="translated">CAF代表值 &lt;code&gt;0 :: BigNat&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d21200844f499d2358206dede07cd8324f4fd8d" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;1 :: BigNat&lt;/code&gt;</source>
          <target state="translated">代表值 &lt;code&gt;1 :: BigNat&lt;/code&gt; CAF :: BigNat</target>
        </trans-unit>
        <trans-unit id="3398da44f9b46eb47c2133df1dbc8f8ae4577ac5" translate="yes" xml:space="preserve">
          <source>CApi</source>
          <target state="translated">CApi</target>
        </trans-unit>
        <trans-unit id="121fd037efff290f65a5321e272862e0f357c01b" translate="yes" xml:space="preserve">
          <source>CApiFFI</source>
          <target state="translated">CApiFFI</target>
        </trans-unit>
        <trans-unit id="14db2db50b91a19fe259904927c84450dabfbabc" translate="yes" xml:space="preserve">
          <source>CBlkCnt</source>
          <target state="translated">CBlkCnt</target>
        </trans-unit>
        <trans-unit id="d700620d461bc690688d590b78ff1f6451076bc9" translate="yes" xml:space="preserve">
          <source>CBlkSize</source>
          <target state="translated">CBlkSize</target>
        </trans-unit>
        <trans-unit id="b7c2df6676202033e6f4b96ba59aff64b6a29f29" translate="yes" xml:space="preserve">
          <source>CBool</source>
          <target state="translated">CBool</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="893cefd4dd78167c7a5a4ac0d06beb7f83dd928c" translate="yes" xml:space="preserve">
          <source>CCFlags</source>
          <target state="translated">CCFlags</target>
        </trans-unit>
        <trans-unit id="6042f4ccd2b35f8dec9caec98fc66b65acdc25f3" translate="yes" xml:space="preserve">
          <source>CCall</source>
          <target state="translated">CCall</target>
        </trans-unit>
        <trans-unit id="66f04a168f55eebf1080c6abb4c6b95b7048c658" translate="yes" xml:space="preserve">
          <source>CCc</source>
          <target state="translated">CCc</target>
        </trans-unit>
        <trans-unit id="0eaec9bae149e37a5ce9a0a7cb18d3a0521a4365" translate="yes" xml:space="preserve">
          <source>CChar</source>
          <target state="translated">CChar</target>
        </trans-unit>
        <trans-unit id="b922d01dfb7fbf4c7d572d9c0a302d24875c9465" translate="yes" xml:space="preserve">
          <source>CClock</source>
          <target state="translated">CClock</target>
        </trans-unit>
        <trans-unit id="00ffad0ad9d13dcd921b4ce8556a4127a2a6d9dd" translate="yes" xml:space="preserve">
          <source>CClockId</source>
          <target state="translated">CClockId</target>
        </trans-unit>
        <trans-unit id="058ca29cc6039cd32a619c31a884582dd9b365d7" translate="yes" xml:space="preserve">
          <source>CDev</source>
          <target state="translated">CDev</target>
        </trans-unit>
        <trans-unit id="a33f47bafc89a737517d547138493e904caede4a" translate="yes" xml:space="preserve">
          <source>CDouble</source>
          <target state="translated">CDouble</target>
        </trans-unit>
        <trans-unit id="a13df1b410bce84da0245d90f1b68f47e714bb5d" translate="yes" xml:space="preserve">
          <source>CFile</source>
          <target state="translated">CFile</target>
        </trans-unit>
        <trans-unit id="7207a00980deab52aac4c426e769595a330ba71f" translate="yes" xml:space="preserve">
          <source>CFloat</source>
          <target state="translated">CFloat</target>
        </trans-unit>
        <trans-unit id="f87722cf9f18251ddb2f5f220f7d782de8cb027d" translate="yes" xml:space="preserve">
          <source>CFpos</source>
          <target state="translated">CFpos</target>
        </trans-unit>
        <trans-unit id="3245250fcffb641fa52b5fc6b60ab78d806ce5a2" translate="yes" xml:space="preserve">
          <source>CFsBlkCnt</source>
          <target state="translated">CFsBlkCnt</target>
        </trans-unit>
        <trans-unit id="668bc46de7dfe8a5a87b82b4a14b2a9b3c2c4f39" translate="yes" xml:space="preserve">
          <source>CFsFilCnt</source>
          <target state="translated">CFsFilCnt</target>
        </trans-unit>
        <trans-unit id="9008ca0ab2fa0b88a1f9335f80a8e41eaf69719f" translate="yes" xml:space="preserve">
          <source>CGid</source>
          <target state="translated">CGid</target>
        </trans-unit>
        <trans-unit id="976337a037dec864a10c701cda46660bf59430a9" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS</source>
          <target state="translated">CHANGEATTRS</target>
        </trans-unit>
        <trans-unit id="9573cfe4003d4063018bfabe8baccabc5dec5643" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS is a more expressive alternative to ADDATTRS</source>
          <target state="translated">CHANGEATTRS是ADDATTRS的一个更有表现力的选择。</target>
        </trans-unit>
        <trans-unit id="4ddd94dd247fbf76059144dff88c2354f6004d0e" translate="yes" xml:space="preserve">
          <source>CId</source>
          <target state="translated">CId</target>
        </trans-unit>
        <trans-unit id="e7be63b330aaa816ff99dddf52aa901f13c3fabc" translate="yes" xml:space="preserve">
          <source>CIno</source>
          <target state="translated">CIno</target>
        </trans-unit>
        <trans-unit id="a00ab8ccad7bd52aaf161686d6fb6af78b9d90cb" translate="yes" xml:space="preserve">
          <source>CInt</source>
          <target state="translated">CInt</target>
        </trans-unit>
        <trans-unit id="afbea4a00e3b8d5fbee852694e9f0dbcb7b1e070" translate="yes" xml:space="preserve">
          <source>CIntMax</source>
          <target state="translated">CIntMax</target>
        </trans-unit>
        <trans-unit id="47afa26f3dfaeef25e893b6e001325c1745aac45" translate="yes" xml:space="preserve">
          <source>CIntPtr</source>
          <target state="translated">CIntPtr</target>
        </trans-unit>
        <trans-unit id="ac426a11e5deca23d2c52eb810c979f96bbedb83" translate="yes" xml:space="preserve">
          <source>CJmpBuf</source>
          <target state="translated">CJmpBuf</target>
        </trans-unit>
        <trans-unit id="3ed41ed1d90695511c38d0a153baab3b0aab617d" translate="yes" xml:space="preserve">
          <source>CKey</source>
          <target state="translated">CKey</target>
        </trans-unit>
        <trans-unit id="1966141ca85782abdda851368b2a0b7057d80562" translate="yes" xml:space="preserve">
          <source>CLLong</source>
          <target state="translated">CLLong</target>
        </trans-unit>
        <trans-unit id="a354353db32e9f98dfeeb3d33b8aaf84b8a163c2" translate="yes" xml:space="preserve">
          <source>CLong</source>
          <target state="translated">CLong</target>
        </trans-unit>
        <trans-unit id="689f2f5b3b386fc3317fb8b3163fa80d82e58f86" translate="yes" xml:space="preserve">
          <source>CMode</source>
          <target state="translated">CMode</target>
        </trans-unit>
        <trans-unit id="c0b6232c6ae7abd7cbb0bae2c172830f28afe3d7" translate="yes" xml:space="preserve">
          <source>CNlink</source>
          <target state="translated">CNlink</target>
        </trans-unit>
        <trans-unit id="2da5c4d5231433ed47b22851a4f34135c562f535" translate="yes" xml:space="preserve">
          <source>CONSOLE_SCREEN_BUFFER_INFO</source>
          <target state="translated">CONSOLE_SCREEN_BUFFER_INFO</target>
        </trans-unit>
        <trans-unit id="f3139171b06d99e21e1e6c0b43a55ca7d2c6d843" translate="yes" xml:space="preserve">
          <source>COORD</source>
          <target state="translated">COORD</target>
        </trans-unit>
        <trans-unit id="49131fde8c7035d6dfd1fe50ce9178a13516766e" translate="yes" xml:space="preserve">
          <source>COff</source>
          <target state="translated">COff</target>
        </trans-unit>
        <trans-unit id="bb1b5dc31671aeff27893044e2275fa0f92d166f" translate="yes" xml:space="preserve">
          <source>CPid</source>
          <target state="translated">CPid</target>
        </trans-unit>
        <trans-unit id="885b63c2b62001411024f3d2c731364c5cee99eb" translate="yes" xml:space="preserve">
          <source>CPtrdiff</source>
          <target state="translated">CPtrdiff</target>
        </trans-unit>
        <trans-unit id="1e7cf4b3318228689b092ee37835b9eb42f41fcc" translate="yes" xml:space="preserve">
          <source>CRLF</source>
          <target state="translated">CRLF</target>
        </trans-unit>
        <trans-unit id="546a33567885515078f7a87477637b76336d1419" translate="yes" xml:space="preserve">
          <source>CRLim</source>
          <target state="translated">CRLim</target>
        </trans-unit>
        <trans-unit id="a28d95e9ceb07c9c8e7449a2375eb3ec11044c2f" translate="yes" xml:space="preserve">
          <source>CSChar</source>
          <target state="translated">CSChar</target>
        </trans-unit>
        <trans-unit id="75d3d4d8267acfcf111594d3887d3a5dd6134eae" translate="yes" xml:space="preserve">
          <source>CSUSeconds</source>
          <target state="translated">CSUSeconds</target>
        </trans-unit>
        <trans-unit id="ac8f56e35ed11b15a2832f15b0cb2a46ae988850" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV是表的基于字符的表示形式。为了获得最大的模块化，我们可以首先将 &lt;code&gt;Table&lt;/code&gt; 呈现为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ，然后使用某种Unicode字符编码对该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 进行编码。但是，由于中间的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示被构建并随后被丢弃，这牺牲了性能。我们通过将字符编码固定为UTF-8并使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;Table&lt;/code&gt; 直接转换为UTF-8编码的懒惰 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示的CSV表，从而摆脱了中间的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="e46e637d7bf291d892a2acd0c0be182fc2c433c5" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV是表的基于字符的表示形式。为了获得最大的模块化，我们可以首先将 &lt;code&gt;Table&lt;/code&gt; 呈现为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ，然后使用某种Unicode字符编码对该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 进行编码。但是，由于中间的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示被构建并随后被丢弃，因此这会牺牲性能。我们通过将字符编码固定为UTF-8并使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;Table&lt;/code&gt; 直接转换为UTF-8编码的懒惰 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示的CSV表，从而摆脱了中间的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="c147f801a4e20b0c854dee13ad8a1089c996075a" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV是表的基于字符的表示形式。为了获得最大的模块化，我们可以首先将 &lt;code&gt;Table&lt;/code&gt; 呈现为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ，然后使用某种Unicode字符编码对该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 进行编码。但是，由于中间的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示被构建并随后被丢弃，因此这会牺牲性能。我们通过将字符编码固定为UTF-8并使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;Table&lt;/code&gt; 直接转换为UTF-8编码的懒惰 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示的CSV表，从而摆脱了中间的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示形式。</target>
        </trans-unit>
        <trans-unit id="794f1cc6fcdf266910baaaaa86b4abed6174089f" translate="yes" xml:space="preserve">
          <source>CShort</source>
          <target state="translated">CShort</target>
        </trans-unit>
        <trans-unit id="27cb76e132d99689a39828e8481058f89da270b5" translate="yes" xml:space="preserve">
          <source>CSigAtomic</source>
          <target state="translated">CSigAtomic</target>
        </trans-unit>
        <trans-unit id="066363f762e399c732848700263a21650f470940" translate="yes" xml:space="preserve">
          <source>CSize</source>
          <target state="translated">CSize</target>
        </trans-unit>
        <trans-unit id="3646574cc19c0a235322672991f1d68d3e2b739a" translate="yes" xml:space="preserve">
          <source>CSpeed</source>
          <target state="translated">CSpeed</target>
        </trans-unit>
        <trans-unit id="f87d0c18f3d1185d116c56fd0a55a68efac638e7" translate="yes" xml:space="preserve">
          <source>CSsize</source>
          <target state="translated">CSsize</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="a23c591d96bc64ebb3bf49374a09dbdd388bf154" translate="yes" xml:space="preserve">
          <source>CStringLen</source>
          <target state="translated">CStringLen</target>
        </trans-unit>
        <trans-unit id="9b2eea83d1e0429c7833e421b94919e2cf388ec0" translate="yes" xml:space="preserve">
          <source>CTcflag</source>
          <target state="translated">CTcflag</target>
        </trans-unit>
        <trans-unit id="5f2bbbe0349a800c3f616f598f975d6fd04867c5" translate="yes" xml:space="preserve">
          <source>CTime</source>
          <target state="translated">CTime</target>
        </trans-unit>
        <trans-unit id="18430e50761b0e842a393b19db9ce285e6cc8054" translate="yes" xml:space="preserve">
          <source>CTimer</source>
          <target state="translated">CTimer</target>
        </trans-unit>
        <trans-unit id="dcb42bcafe594e90af67676c9e8c052fd5a939f5" translate="yes" xml:space="preserve">
          <source>CUChar</source>
          <target state="translated">CUChar</target>
        </trans-unit>
        <trans-unit id="d4a2582d6c16b4ba5d2c635b012416934740d9a4" translate="yes" xml:space="preserve">
          <source>CUInt</source>
          <target state="translated">CUInt</target>
        </trans-unit>
        <trans-unit id="bd076efc1995c3ed275a187edc0ef066f25ea188" translate="yes" xml:space="preserve">
          <source>CUIntMax</source>
          <target state="translated">CUIntMax</target>
        </trans-unit>
        <trans-unit id="e074910606a6a0a7045029bb34df02fd731ab117" translate="yes" xml:space="preserve">
          <source>CUIntPtr</source>
          <target state="translated">CUIntPtr</target>
        </trans-unit>
        <trans-unit id="5486c3338e80ad8846379dc8e8efd520cc4bb304" translate="yes" xml:space="preserve">
          <source>CULLong</source>
          <target state="translated">CULLong</target>
        </trans-unit>
        <trans-unit id="5a6a6d18d4f6db0b3cd3cb3ee6e11d2b638b36ea" translate="yes" xml:space="preserve">
          <source>CULong</source>
          <target state="translated">CULong</target>
        </trans-unit>
        <trans-unit id="14f5959d3f206903fe812b4714e3e8212c8b6cb1" translate="yes" xml:space="preserve">
          <source>CUSKs</source>
          <target state="translated">CUSKs</target>
        </trans-unit>
        <trans-unit id="897002c69b6a884ea8eefcb5421db84ebdef160d" translate="yes" xml:space="preserve">
          <source>CUSeconds</source>
          <target state="translated">CUSeconds</target>
        </trans-unit>
        <trans-unit id="5c8ed628cb7e45bc705eead76f1cbbebd239bed4" translate="yes" xml:space="preserve">
          <source>CUShort</source>
          <target state="translated">CUShort</target>
        </trans-unit>
        <trans-unit id="92c2830bba441303faf6bab856a7cb069b95ea73" translate="yes" xml:space="preserve">
          <source>CUid</source>
          <target state="translated">CUid</target>
        </trans-unit>
        <trans-unit id="418cbde1ba91d0f1d2a07615c5e0090662363499" translate="yes" xml:space="preserve">
          <source>CWString</source>
          <target state="translated">CWString</target>
        </trans-unit>
        <trans-unit id="8057975ee7505b53300ea225f8ab98d9c485a979" translate="yes" xml:space="preserve">
          <source>CWStringLen</source>
          <target state="translated">CWStringLen</target>
        </trans-unit>
        <trans-unit id="e1b7eb195fb8e47d10f92245d40ce0a83001bfc2" translate="yes" xml:space="preserve">
          <source>CWchar</source>
          <target state="translated">CWchar</target>
        </trans-unit>
        <trans-unit id="f28b182fd6c1e7864bf4df566f792efa2f287d19" translate="yes" xml:space="preserve">
          <source>Calculate the disjoint union of two sets.</source>
          <target state="translated">计算两个集合的不相联。</target>
        </trans-unit>
        <trans-unit id="4f4058eb0d05059b00bf8670b35dee8225ccc810" translate="yes" xml:space="preserve">
          <source>Calculate the integer base 2 logarithm of an &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. The calculation is more efficient than for the general case, on platforms with 32- or 64-bit words much more efficient.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 的整数以2为底的对数。在具有32位或64位字的平台上，计算效率要比一般情况下更高。</target>
        </trans-unit>
        <trans-unit id="6b1934e0c8bea85b670349912e862bb717885de1" translate="yes" xml:space="preserve">
          <source>Calculate the integer logarithm for an arbitrary base.</source>
          <target state="translated">计算任意基数的整数对数。</target>
        </trans-unit>
        <trans-unit id="fb6671b4faab4d9f68221ca795a7d987f6a0b011" translate="yes" xml:space="preserve">
          <source>Calculate the power set of a set: the set of all its subsets.</source>
          <target state="translated">计算一个集合的幂集:它所有子集的集合。</target>
        </trans-unit>
        <trans-unit id="64d88731a775170b2c2441d20c5626fd611990f4" translate="yes" xml:space="preserve">
          <source>Calculating length of a list continuation-style:</source>
          <target state="translated">计算列表延续式的长度。</target>
        </trans-unit>
        <trans-unit id="d8643951a671cd22c32e5119288ea47182a9cfcf" translate="yes" xml:space="preserve">
          <source>Calendar Duration</source>
          <target state="translated">日历时间</target>
        </trans-unit>
        <trans-unit id="17b81c9701f67a03dd57e8dd0dc487ffc9b431f1" translate="yes" xml:space="preserve">
          <source>CalendarDiffDays</source>
          <target state="translated">CalendarDiffDays</target>
        </trans-unit>
        <trans-unit id="7409b1c71c8750958b11afbc94ff9c16ede064de" translate="yes" xml:space="preserve">
          <source>CalendarDiffTime</source>
          <target state="translated">CalendarDiffTime</target>
        </trans-unit>
        <trans-unit id="eb7dce9cb4dc86ccc09e9d78fd32dae9732b4f0b" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible</source>
          <target state="translated">历法不同,尽量用整月的方式</target>
        </trans-unit>
        <trans-unit id="7768352cae2cf4a9e8a3254eb24cd7bb701e58be" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">日历差异，尽可能多的整个月。与 &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; 的持续时间相同。</target>
        </trans-unit>
        <trans-unit id="c553a4bbbf5e7eabf268248210393cf922adb6b0" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">日历差异，尽可能多的整个月。与 &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; 相同，持续时间为正。</target>
        </trans-unit>
        <trans-unit id="f49baea1e6b905de58ea91679cca46b40b81f9d9" translate="yes" xml:space="preserve">
          <source>Call frame information (CFI) necessary for stack unwinding to produce a call stack trace.</source>
          <target state="translated">调用帧信息(CFI),是堆栈展开产生调用堆栈跟踪所必需的。</target>
        </trans-unit>
        <trans-unit id="3812f07ff31cb5f1c7a312c2a62d7b06b2a82122" translate="yes" xml:space="preserve">
          <source>Call stacks</source>
          <target state="translated">呼叫堆栈</target>
        </trans-unit>
        <trans-unit id="369931f908b5d62b0161c02a5b22a7cc6f5cac8f" translate="yes" xml:space="preserve">
          <source>CallCC</source>
          <target state="translated">CallCC</target>
        </trans-unit>
        <trans-unit id="c880ae2dae683608578f800194affe123789856b" translate="yes" xml:space="preserve">
          <source>CallStack</source>
          <target state="translated">CallStack</target>
        </trans-unit>
        <trans-unit id="0056e80c1c5d28940be39ffae2973568ce16898b" translate="yes" xml:space="preserve">
          <source>Callback invoked on I/O events.</source>
          <target state="translated">在I/O事件中调用回调。</target>
        </trans-unit>
        <trans-unit id="daaca2c7f2ff8d9519d665fa41b06b2d69fccb29" translate="yes" xml:space="preserve">
          <source>Callback invoked on timeout events.</source>
          <target state="translated">超时事件时调用回调。</target>
        </trans-unit>
        <trans-unit id="bab9ef2996e7c7cd612ef756aaf74e75bf66e857" translate="yes" xml:space="preserve">
          <source>Callconv</source>
          <target state="translated">Callconv</target>
        </trans-unit>
        <trans-unit id="f2709480559f8e1ebfe51f5f922070ee5a0b317e" translate="yes" xml:space="preserve">
          <source>Called when event logging is about to stop. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">在事件记录即将停止时调用。这可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0e54dd6b0d6f06132a5ac9efba16065ebcb80fc" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_free_fun_ptr&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;hs_free_fun_ptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f93440ac09595da765dfd7fce3c043e1340ddc7c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_thread_done()&lt;/code&gt; is entirely optional. You can call it as often or as little as you like. It is safe to call it from a thread that has never called any Haskell functions, or one that never will. If you forget to call it, the worst that can happen is that some memory remains allocated until &lt;code&gt;hs_exit()&lt;/code&gt; is called. If you call it too often, the worst that can happen is that the next call to a Haskell function incurs some extra overhead.</source>
          <target state="translated">调用 &lt;code&gt;hs_thread_done()&lt;/code&gt; 完全是可选的。您可以根据需要随意或不多地调用它。从从未调用过任何Haskell函数或从未调用过任何Haskell函数的线程中调用它是安全的。如果您忘记调用它，则可能发生的最坏情况是在调用 &lt;code&gt;hs_exit()&lt;/code&gt; 之前，仍会分配一些内存。如果您经常调用它，则可能发生的最坏情况是下一次调用Haskell函数会产生一些额外的开销。</target>
        </trans-unit>
        <trans-unit id="e8f8b83a7a11f59a3ed11ede1f3d1bacf0e929ec" translate="yes" xml:space="preserve">
          <source>Calling a foreign export has a lot of overhead: it creates a complete new Haskell thread, for example.</source>
          <target state="translated">调用国外的导出有很多开销:例如,它会创建一个完整的新的Haskell线程。</target>
        </trans-unit>
        <trans-unit id="ff08cba20a67e3d5df6255f93d1d83290d3ee9d5" translate="yes" xml:space="preserve">
          <source>Calling any FFI function that deals with the stable pointer table except for arbitrarily many calls to &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; and the final call to &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;.</source>
          <target state="translated">调用任何处理稳定指针表的FFI函数，除了任意多次对 &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; 的调用以及对hs_unlock_stable_ptr_table的最终调用 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9df609505c881df29223a688771547c8554de6d3" translate="yes" xml:space="preserve">
          <source>Calling any Haskell function, whether or not that function manipulates stable pointers.</source>
          <target state="translated">调用任何Haskell函数,无论该函数是否操纵稳定指针。</target>
        </trans-unit>
        <trans-unit id="ed557244b4a9e349a3c322cb0a77503f0c82e38a" translate="yes" xml:space="preserve">
          <source>Calling it as a function and using the result exactly once in the same fashion.</source>
          <target state="translated">以函数的形式调用它,并以同样的方式准确地使用一次结果。</target>
        </trans-unit>
        <trans-unit id="9e7c37f4b93e87283ca9f6dfdb888042f1b6baeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">致电 &lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b8a9e246fa76764839ff44eb2f103e773afd472" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate an unknown format letter for a given type.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 表示给定类型的未知格式字母。</target>
        </trans-unit>
        <trans-unit id="bbeabbfe431946986773f5b91e4e429276bde50e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that the format string ended early.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 表示格式字符串提前结束。</target>
        </trans-unit>
        <trans-unit id="d4d742c7c0092a147431c7f726520a71e74c9a5c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a missing argument in the argument list.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 表示参数列表中缺少参数。</target>
        </trans-unit>
        <trans-unit id="8f43ec8fc4303b258e938941fa0c2345e526a41e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a type error or similar in the given argument.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 表示给定参数中存在类型错误或类似错误。</target>
        </trans-unit>
        <trans-unit id="070d4130edcaf66aaea470ab76abbaddcd88f8ef" translate="yes" xml:space="preserve">
          <source>Calls to wrapper stubs like &lt;code&gt;mkCompare&lt;/code&gt; allocate storage, which should be released with &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">调用 &lt;code&gt;mkCompare&lt;/code&gt; 之类的包装存根会分配存储，当不再需要时，应使用 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; 释放该存储。</target>
        </trans-unit>
        <trans-unit id="f880e789e2f3915fa404c71994dee3260cf66e4f" translate="yes" xml:space="preserve">
          <source>Can be combined by allowing the first function to fail:</source>
          <target state="translated">可以通过允许第一个功能失效来组合。</target>
        </trans-unit>
        <trans-unit id="08a5398c4ef4368084de9b377c7ea4fe19382c35" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 也是 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 的实例，则可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="4d3a970cf23a4db5acc2dcd82f2ea1d2d3114348" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 也是 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 的实例，则可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="77df886f88f5ac11d91e40af1a385d5cf0c476b4" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 也是 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 的实例，则可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="dfff1eba5fd5e0ee04fd5ffa74f4d0a27cee0119" translate="yes" xml:space="preserve">
          <source>Cancel and clean up the user interaction session. Does not block on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取消并清理用户交互会话。不阻止对 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 的现有调用。</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="79fd1355be5e5c3a2d4b8536cbbd16e2b9043764" translate="yes" xml:space="preserve">
          <source>Capability</source>
          <target state="translated">Capability</target>
        </trans-unit>
        <trans-unit id="54d8a47a1e0d806a4cdef71377794d92327dfe08" translate="yes" xml:space="preserve">
          <source>Capability set</source>
          <target state="translated">能力集</target>
        </trans-unit>
        <trans-unit id="47decb03a85edffa821a50bbfb0d437fdc807e88" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type. &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; evaluates to &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and evaluates to &lt;code&gt;y&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 类型的案例分析。 &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; 在 &lt;code&gt;p&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 时计算为 &lt;code&gt;x&lt;/code&gt; ，在 &lt;code&gt;p&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 时计算为 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd61e6da694c7005c3bf09a8d6c6175a2aa43e8f" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型的案例分析。如果值为 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; ，则将第一个函数应用于 &lt;code&gt;a&lt;/code&gt; ；如果为 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; ，则将第二个功能应用于 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98c9b70590f3abe192e52616a49d1ce1c95797d5" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型的案例分析。如果值为 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; ，则将第一个函数应用于 &lt;code&gt;a&lt;/code&gt; ；如果为 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; ，则将第二个功能应用于 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="475bc2fca6cb658692cd146b77f3134683e44d4e" translate="yes" xml:space="preserve">
          <source>Case conversion</source>
          <target state="translated">案件转换</target>
        </trans-unit>
        <trans-unit id="c384f0bd4de15126a4e648ecdb43ed85f0f9788d" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt;</source>
          <target state="translated">投放到 &lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b0c1cec3779c67b5a4198434044b6479333cc3b" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt;</source>
          <target state="translated">投放到 &lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="418d5136974671468558a366b7adf4e1745babd1" translate="yes" xml:space="preserve">
          <source>Casting &lt;code&gt;Any&lt;/code&gt; back to the real type</source>
          <target state="translated">将 &lt;code&gt;Any&lt;/code&gt; 类型转换为实型</target>
        </trans-unit>
        <trans-unit id="14eaff82dc32a3dd06fbb2120fb55390d7aff2b7" translate="yes" xml:space="preserve">
          <source>Casting an unboxed type to another unboxed type of the same size. (Casting between floating-point and integral types does not work. See the &lt;code&gt;GHC.Float&lt;/code&gt; module for functions to do work.)</source>
          <target state="translated">将未装箱的类型转换为相同大小的另一个未装箱的类型。（在浮点和整数类型之间进行转换不起作用。有关 &lt;code&gt;GHC.Float&lt;/code&gt; 的功能，请参见GHC.Float模块。）</target>
        </trans-unit>
        <trans-unit id="a77a280b66f17718ca45f364c2549ea59ee231d5" translate="yes" xml:space="preserve">
          <source>Casting any lifted type to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">将任何提升类型转换为 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8239393d85a3d2b20d80ac50aa2077b6cb2bbff9" translate="yes" xml:space="preserve">
          <source>Casting between two types that have the same runtime representation. One case is when the two types differ only in &quot;phantom&quot; type parameters, for example &lt;code&gt;Ptr Int&lt;/code&gt; to &lt;code&gt;Ptr Float&lt;/code&gt;, or &lt;code&gt;[Int]&lt;/code&gt; to &lt;code&gt;[Float]&lt;/code&gt; when the list is known to be empty. Also, a &lt;code&gt;newtype&lt;/code&gt; of a type &lt;code&gt;T&lt;/code&gt; has the same representation at runtime as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">具有相同运行时表示形式的两种类型之间的转换。一种情况是两种类型的区别仅在于&amp;ldquo;幻像&amp;rdquo;类型参数，例如，当已知列表为空时，例如 &lt;code&gt;Ptr Int&lt;/code&gt; 到 &lt;code&gt;Ptr Float&lt;/code&gt; 或 &lt;code&gt;[Int]&lt;/code&gt; 到 &lt;code&gt;[Float]&lt;/code&gt; 。另外， &lt;code&gt;newtype&lt;/code&gt; 的类型 &lt;code&gt;T&lt;/code&gt; 具有在运行时为相同的表示 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="817c5fda8cf761e409f0573537fe831f98dcc235" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 为其他类型的FunPtr。</target>
        </trans-unit>
        <trans-unit id="3b87674433c2d83df21e90e5d30bb6ad8b8917b3" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 强制转换为 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a333b32a76b5f0846b0b562e4e374f98aa285d13" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95e8d467482a948856e848cedf6d867c0805e0eb" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 为其他类型的FunPtr。</target>
        </trans-unit>
        <trans-unit id="b06ed4465a78c5cb3d6a85f1cc01b4e8f6b31063" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 强制转换为 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19d6f9a00c0c2cabff3ad4bdfb625dab782fe4d7" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2924698e10e606808fa245512e94c5f68ae0c26" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">将一种元素类型的 &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; 转换为另一种元素类型的IOUArray。结果数组的所有元素都是不确定的（除非您知道自己在做什么...）。</target>
        </trans-unit>
        <trans-unit id="a08750b8b38605ce21952c72bb767d5301c2b939" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">将一种元素类型的 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 转换为另一种元素类型的STUArray。结果数组的所有元素都是不确定的（除非您知道自己在做什么...）。</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="55968d8a1379a4b67fddecc8e9883f837526266e" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">捕获所有 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （当量。 &lt;code&gt;IOException&lt;/code&gt; 异常）的异常。仍然有些过于笼统，但是比使用 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; 更好。有关基于&lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;谓词捕获特定 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 的简便方法，请参见 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b0491a3ba40c7aae2ac43311b82cc5e386de0f0" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">捕获所有 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （当量。 &lt;code&gt;IOException&lt;/code&gt; 异常）的异常。仍然有些过于笼统，但是比使用 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; 更好。有关基于&lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;谓词捕获特定 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 的简便方法，请参见 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be3e0797dab02a979f34001bfab69a509009b77c" translate="yes" xml:space="preserve">
          <source>Catch an exception in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中捕获异常。</target>
        </trans-unit>
        <trans-unit id="dd822d9ac25676eae90dbd5e34d62a0eba9fb936" translate="yes" xml:space="preserve">
          <source>Catch and handle an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">捕获并处理 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 类型的异常。</target>
        </trans-unit>
        <trans-unit id="a0396fc2c6cc0de592c078776391d5b4c38fa9d0" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中的任何 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="bb4abdda83b18367b6738ca6670fbc64a522dd00" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 中的任何 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="e8a05dab529be35078b57b35e09c9396125ad8d1" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中的任何 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="85fb57b50b7c396aea28d0563de6686ac25936f8" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">捕获计算中发生的任何 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 并抛出修改后的版本。</target>
        </trans-unit>
        <trans-unit id="3e8b90383da6530dd9f0567fb4058dd0c3408fd5" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">捕获计算中发生的任何 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 并抛出修改后的版本。</target>
        </trans-unit>
        <trans-unit id="e00ca112629f0bbeddd0eaf128d45287b724c7a1" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">仅在异常通过某些谓词时才捕获它们。谓词通常用于测试&lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error中的&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cc1d9a1fb694c15418a8f0478bbfd7cc9e0ccce4" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">仅在异常通过某些谓词时才捕获它们。谓词通常用于测试&lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error中的&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="27e1a543d61fbc5ef22c14a662c04bfa3f8494dd" translate="yes" xml:space="preserve">
          <source>CatchT</source>
          <target state="translated">CatchT</target>
        </trans-unit>
        <trans-unit id="4faa50ac1aedb089ef7ad23c0ec14c4788d3fa93" translate="yes" xml:space="preserve">
          <source>Catchable failure</source>
          <target state="translated">可捕获的故障</target>
        </trans-unit>
        <trans-unit id="3ad467bb02d631ca180aaff8b3eb2bb11449bd34" translate="yes" xml:space="preserve">
          <source>Catches all exceptions, and somewhat defeats the purpose of the extensible exception system. Use sparingly.</source>
          <target state="translated">捕获所有异常,这在一定程度上违背了可扩展异常系统的目的。尽量少用。</target>
        </trans-unit>
        <trans-unit id="ab50d7d0a8e10c25d0254d43e62f4208eacd6ea8" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">捕获不同种类的异常。请参见&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f142aa11175cc4bb725dba420c092ca4007c7b66" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">捕获不同种类的异常。请参见&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db9f1e35bd8bc054c14a57bda1390e0ea6c3de74" translate="yes" xml:space="preserve">
          <source>Catches exceptions from the base monad.</source>
          <target state="translated">从基础单体中捕捉异常。</target>
        </trans-unit>
        <trans-unit id="cbf0eb43a0f74729b670cb70ee447e8dafe2ae8e" translate="yes" xml:space="preserve">
          <source>Catching Exceptions</source>
          <target state="translated">捕捉例外情况</target>
        </trans-unit>
        <trans-unit id="7c24a071f68091fc4b6c70d3a203d55c0991236d" translate="yes" xml:space="preserve">
          <source>Catching all exceptions</source>
          <target state="translated">捕捉所有异常情况</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="24116b77a8f36e799ebb282f0b37aa98b99674d4" translate="yes" xml:space="preserve">
          <source>Cause GHC to spew a long usage message to standard output and then exit.</source>
          <target state="translated">使GHC向标准输出喷出一条长长的使用信息,然后退出。</target>
        </trans-unit>
        <trans-unit id="cd4f2174d5c74263e2692df318af63043a136f0a" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to ignore missing dependencies, directories and libraries when registering a package, and just go ahead and add it anyway. This might be useful if your package installation system needs to add the package to GHC before building and installing the files.</source>
          <target state="translated">使 &lt;code&gt;ghc-pkg&lt;/code&gt; 在注册程序包时忽略缺少的依赖项，目录和库，并继续进行添加。如果您的软件包安装系统需要在构建和安装文件之前将软件包添加到GHC，这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="51d690ac870a757a43255d7f87f9ba95fdebc250" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed package IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">使 &lt;code&gt;ghc-pkg&lt;/code&gt; 将参数解释为已安装的程序包ID（例如，诸如 &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; 之类的标识符）。如果仅提供软件包名称和版本不明确，这将很有用（在GHC的旧版本中，这被保证是唯一的，但是这种不变性不再成立）。</target>
        </trans-unit>
        <trans-unit id="6668ddc9a0b8030af8f071d3c72c96b34a4f1919" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed unit IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">使 &lt;code&gt;ghc-pkg&lt;/code&gt; 将参数解释为已安装的单元ID（例如，诸如 &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; 之类的标识符）。如果仅提供软件包名称和版本不明确，这将很有用（在旧版本的GHC中，这被保证是唯一的，但是这种不变性不再成立）。</target>
        </trans-unit>
        <trans-unit id="6c8b9bf99ddcbd146b3c845f7be476ec85530046" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as unit IDs (e.g., an identifier like &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt;). Package keys are used to prefix symbol names GHC produces (e.g., &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt;), so if you need to figure out what package a symbol belongs to, use &lt;code&gt;ghc-pkg&lt;/code&gt; with this flag.</source>
          <target state="translated">使 &lt;code&gt;ghc-pkg&lt;/code&gt; 将参数解释为单位ID（例如，类似 &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt; 的标识符）。包密钥用于为GHC产生的符号名称添加前缀（例如 &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt; ），因此，如果需要确定符号属于哪个包，请使用带有该标志的 &lt;code&gt;ghc-pkg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00ace62f72694d4200557c472f90977b55426b58" translate="yes" xml:space="preserve">
          <source>Causes GHC to continue the compilation if a module has an error. Any reverse dependencies are pruned immediately and the whole compilation is still flagged as an error. This option has no effect if parallel compilation (&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;) is in use.</source>
          <target state="translated">如果模块有错误，使GHC继续编译。任何反向依赖项都将立即被修剪，整个编译过程仍将被标记为错误。如果使用并行编译（&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;），则此选项无效。</target>
        </trans-unit>
        <trans-unit id="8e4e5c6ceb6d8c45565db992a2558a62eccda222" translate="yes" xml:space="preserve">
          <source>Causes GHC to display error messages with colors. To do this, the terminal must have support for ANSI color codes, or else garbled text will appear. The default value is &lt;code&gt;auto&lt;/code&gt;, which means GHC will make an attempt to detect whether terminal supports colors and choose accordingly.</source>
          <target state="translated">使GHC显示带有颜色的错误消息。为此，终端必须支持ANSI颜色代码，否则会出现乱码。默认值为 &lt;code&gt;auto&lt;/code&gt; ，这意味着GHC将尝试检测终端是否支持颜色并进行相应选择。</target>
        </trans-unit>
        <trans-unit id="20d2d68914c6346c2e95cbf24b6ec67960b9eecf" translate="yes" xml:space="preserve">
          <source>Causes GHC to emit the full source span of the syntactic entity relating to an error message. Normally, GHC emits the source location of the start of the syntactic entity only.</source>
          <target state="translated">使GHC发出与错误消息有关的句法实体的全部源跨度,通常情况下,GHC只发出句法实体起始的源位置。通常情况下,GHC只发出句法实体开始的源位置。</target>
        </trans-unit>
        <trans-unit id="d576e350cd2aa7e7096854355ee66b60b92ba0b0" translate="yes" xml:space="preserve">
          <source>Causes GHC to group diagnostic messages by severity and output them after other messages when building a multi-module Haskell program. This flag can make diagnostic messages more visible when used in conjunction with &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;. Otherwise, it can be hard to find the relevant errors or likely to ignore the warnings when they are mixed with many other messages.</source>
          <target state="translated">在构建多模块Haskell程序时，使GHC按严重性对诊断消息进行分组，并在其他消息之后输出它们。与&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;结合使用时，此标志可使诊断消息更加可见。否则，当它们与许多其他消息混合在一起时，可能很难找到相关的错误或可能会忽略警告。</target>
        </trans-unit>
        <trans-unit id="d70d25285a51eb0c30b7f813f53d107d40395ccf" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;exts/assert#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">使GHC忽略源代码中对 &lt;code&gt;Exception.assert&lt;/code&gt; 函数的使用（换句话说，将 &lt;code&gt;Exception.assert p e&lt;/code&gt; 重写为 &lt;code&gt;e&lt;/code&gt; （请参见&lt;a href=&quot;exts/assert#assertions&quot;&gt;Assertions&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="acca7ff63d9b6e41e528844003c34ddbdde2ee3a" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;glasgow_exts#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">使GHC忽略源代码中对 &lt;code&gt;Exception.assert&lt;/code&gt; 函数的使用（换句话说，将 &lt;code&gt;Exception.assert p e&lt;/code&gt; 重写为 &lt;code&gt;e&lt;/code&gt; （请参见&lt;a href=&quot;glasgow_exts#assertions&quot;&gt;Assertions&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a5c37beba2bad256ebd9f62113525cc50cf13289" translate="yes" xml:space="preserve">
          <source>Causes GHC to output errors in reverse line-number order, so that the errors and warnings that originate later in the file are displayed first.</source>
          <target state="translated">使GHC以相反的行号顺序输出错误,使文件中后面出现的错误和警告先显示。</target>
        </trans-unit>
        <trans-unit id="c74c8c8a50a946a1eb069af532c3b41c65914fde" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt; breaks on only those exceptions which would otherwise be uncaught.</source>
          <target state="translated">如果发生异常，使GHCi停止评估并返回交互式提示。&lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt;仅中断那些否则将无法捕获的异常。</target>
        </trans-unit>
        <trans-unit id="09fceabf67429fb54f490834d66c90cb5b2d87e7" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; breaks on all exceptions.</source>
          <target state="translated">如果发生异常，使GHCi停止评估并返回交互式提示。&lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt;会在所有异常上中断。</target>
        </trans-unit>
        <trans-unit id="e7e4317b2c3f6f72a82cfdcbcf16addd4832d7ce" translate="yes" xml:space="preserve">
          <source>Causes a specific warning to be treated as normal warning, not fatal error.</source>
          <target state="translated">导致特定警告被视为正常警告,而不是致命错误。</target>
        </trans-unit>
        <trans-unit id="9013a7a5dd4b02050c445d6c8d02f8c9a5659e8f" translate="yes" xml:space="preserve">
          <source>Causes a the finalizer associated with a weak pointer to be run immediately.</source>
          <target state="translated">使与弱指针相关的定标器立即运行。</target>
        </trans-unit>
        <trans-unit id="d660793220cce4be870d303d08ede77e598c4e8a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign declarations that use unsupported calling conventions. In particular, if the &lt;code&gt;stdcall&lt;/code&gt; calling convention is used on an architecture other than i386 then it will be treated as &lt;code&gt;ccall&lt;/code&gt;.</source>
          <target state="translated">使使用不支持的调用约定的外部声明发出警告。特别是，如果在非i386的体系结构上使用 &lt;code&gt;stdcall&lt;/code&gt; 调用约定，则它将被视为 &lt;code&gt;ccall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9231b916d8fb538801ceb6978b5f7d56d89c46a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign imports of the following form:</source>
          <target state="translated">对以下形式的外国进口发出警告:</target>
        </trans-unit>
        <trans-unit id="e98a3a30d7733ed9dedcbabc936490c757372801" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if a literal will overflow, e.g. &lt;code&gt;300 :: Word8&lt;/code&gt;.</source>
          <target state="translated">如果文字溢出，则发出警告，例如 &lt;code&gt;300 :: Word8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd1c01a0d1fd759549d7f5a255d840e89eea8c9" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if an enumeration is empty, e.g. &lt;code&gt;[5 .. 3]&lt;/code&gt;.</source>
          <target state="translated">如果枚举为空（例如 &lt;code&gt;[5 .. 3]&lt;/code&gt; ，则发出警告。</target>
        </trans-unit>
        <trans-unit id="2b03d60a421fef989bdabe6f59af3aafb863a3a2" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted in the following cases:</source>
          <target state="translated">在下列情况下会发出警告:</target>
        </trans-unit>
        <trans-unit id="54a2ce2dcdf3de95961e4a84c06a6eb991218b3a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a datatype &lt;code&gt;T&lt;/code&gt; is exported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but is it just a type synonym.</source>
          <target state="translated">使用所有构造函数导出数据类型 &lt;code&gt;T&lt;/code&gt; 时都会发出警告，即 &lt;code&gt;T(..)&lt;/code&gt; ，但它只是类型的同义词。</target>
        </trans-unit>
        <trans-unit id="5850209be2276082816894ad46c9d27f472d8244" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a deprecated command-line flag is used.</source>
          <target state="translated">当使用废弃的命令行标志时,会发出警告。</target>
        </trans-unit>
        <trans-unit id="1559b656d4f4ada2377537a03c55fbff0cb2ceb8" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">当使用带有 &lt;code&gt;WARNING&lt;/code&gt; 或已 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 的模块，功能或类型时，导致发出警告。有关&lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;实用&lt;/a&gt;程序的更多详细信息，请参见警告和不建议使用的实用程序。</target>
        </trans-unit>
        <trans-unit id="e8a0d32c9e37c86534bf9a681300a1caae49d88d" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用带有 &lt;code&gt;WARNING&lt;/code&gt; 或已 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 的模块，功能或类型时，导致发出警告。有关&lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;实用&lt;/a&gt;程序的更多详细信息，请参见警告和不建议使用的实用程序。&lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="b17effd9a3e5c7c9e87b6669a7b23b62923d60da" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">当使用带有 &lt;code&gt;WARNING&lt;/code&gt; 或已 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 的模块，功能或类型时，导致发出警告。有关&lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;实用&lt;/a&gt;程序的更多详细信息，请参见警告和不建议使用的实用程序。</target>
        </trans-unit>
        <trans-unit id="ae2b17da3f31748cf6562bc1e9f9fc0eea07082f" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用带有 &lt;code&gt;WARNING&lt;/code&gt; 或不建议 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 的模块，功能或类型时，导致发出警告。有关&lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;实用&lt;/a&gt;程序的更多详细信息，请参见警告和不建议使用的实用程序。&lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="98e20c4585a176d469e30cd83022bf0c8a9dc06c" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a pragma that GHC doesn&amp;rsquo;t recognise is used. As well as pragmas that GHC itself uses, GHC also recognises pragmas known to be used by other tools, e.g. &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; and &lt;code&gt;DERIVE&lt;/code&gt;.</source>
          <target state="translated">当使用GHC无法识别的编译指示时，发出警告。除了GHC本身使用的编译指示外，GHC还识别已知由其他工具（例如 &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; 和 &lt;code&gt;DERIVE&lt;/code&gt; )使用的编译指示。</target>
        </trans-unit>
        <trans-unit id="a825494d23788ab82b5c459198f152d6a42195e6" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">将类型错误推迟到运行时，导致报告警告。请参见将&lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d06a9df074ba808cc5468d12706017603b0286" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">将类型错误推迟到运行时，导致报告警告。请参见将&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a66456e97d3e5c82a2e7e50ed6cce45f40a3e24" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">当同时启用&lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;并且未使用任何显式派生策略时，将引发警告。例如，这将导致警告：</target>
        </trans-unit>
        <trans-unit id="cd293507c41778581d65d30e7291dca340df36ce" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">当同时启用&lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;并且未使用任何显式派生策略时，将引发警告。例如，这将导致警告：</target>
        </trans-unit>
        <trans-unit id="7b795c3c145457a6b91186e97358df9a2b6dccc0" translate="yes" xml:space="preserve">
          <source>Causes all files following this option on the command line to be processed as if they had the suffix ⟨suffix⟩. For example, to compile a Haskell module in the file &lt;code&gt;M.my-hs&lt;/code&gt;, use &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt;.</source>
          <target state="translated">使命令行上此选项之后的所有文件都被视为带有后缀&amp;ldquo; suffix&amp;rdquo;。例如，要在文件 &lt;code&gt;M.my-hs&lt;/code&gt; 中编译Haskell模块，请使用 &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8292d38b8a6403c2a334f06412c37889687b00ef" translate="yes" xml:space="preserve">
          <source>Causes the compiler to behave as if package ⟨pkg⟩, and any packages that depend on ⟨pkg⟩, are not installed at all.</source>
          <target state="translated">导致编译器的行为就像包⟨pkg⟩,以及任何依赖⟨pkg⟩的包,根本没有安装一样。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
