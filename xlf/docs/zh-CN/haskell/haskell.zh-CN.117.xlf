<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fea1585aed3010cb59ede80216e1092bd438ce4" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">带引号的&amp;ldquo;字符串&amp;rdquo;在两个字符序列 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 首次出现时结束。绝对不会执行转义。如果要在字符串中嵌入该字符序列，则必须发明自己的转义符（例如，使用字符串 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; ），并使引用程序函数将 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 解释为 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 。一种实现此方法的方法是在报价程序中添加预处理通道，以执行转义转换。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;问题＃5348中&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;论文&lt;/a&gt; &amp;ldquo;不应该被概括&amp;rdquo;和&amp;ldquo;采用局部假设的模块化类型推论&amp;rdquo;以及相关&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;博客文章中&lt;/a&gt;给出了这种更为保守的策略的原理。</target>
        </trans-unit>
        <trans-unit id="46c2ed2757c23fae8b2fbe6c5c9ab4a0e016d4ba" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">归因于此成本中心的时间&amp;ldquo;滴答声&amp;rdquo;的原始数量；由此，我们得到上面提到的 &lt;code&gt;%time&lt;/code&gt; 数字。</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">读者单体变换器,它为给定的单体添加一个只读环境。</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 在回溯输出中未显示此符号名称的原因是其对调试信息的解释是不忠实的，它假定C中保留了不变式，但Haskell程序中并未保留。不幸的是，必须手动解决此问题，直到此行为被固定在上游。</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">后一种限制的原因是没有办法检查实例匹配。考虑到</target>
        </trans-unit>
        <trans-unit id="76babb94bd7796eeda34a4c806d3669a17f9540b" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">对 &lt;code&gt;mergeQs&lt;/code&gt; 的调用之所以懒惰是因为它将在队列中的最后一个元素的底部，从而阻止我们评估完全排序的序列。</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">存在两种检查信任方式的原因是&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;支持的额外要求导致Safe Haskell的设计具有侵入性。启用该标志时使用Safe Haskell的软件包可能会编译，也可能不会编译，具体取决于用户计算机上受信任软件包的状态。这既脆弱，又会导致每个人的编译失败，即使他们没有尝试使用Safe Haskell提供的任何保证也是如此。默认情况下禁用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;并将其转换为标志，可使Safe Haskell成为选择加入扩展而不是始终启用功能。</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">可重新绑定的运算符必须具有上表中给出的&amp;ldquo;期望类型&amp;rdquo;。这些类型令人惊讶地通用。例如，您可以将绑定运算符与类型</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装惰性ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">推荐的分块大小。目前设置为4k,减去内存管理开销。</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">记录字段 &lt;code&gt;f&lt;/code&gt; 以某种方式在范围内（合格或不合格）。</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的递归使用迫使第二个参数具有 &lt;code&gt;Type&lt;/code&gt; 类型。但是，就像类型推断一样，您可以通过为 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;提供完整的用户提供的种类签名&lt;/em&gt;（或CUSK）来实现多态递归。当所有参数类型和结果类型都已知时，无需进行推断就可以提出CUSK。例如：</target>
        </trans-unit>
        <trans-unit id="dedba55228cde4bbd5f3a4194d8b8dabbf8ef98a" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">这些引用必须在调用者进程中创建。</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 表示相关的&lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;查找优先操作&lt;/a&gt;，如下所示</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">渲染模式。</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">表示 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 稍有不同。让我们再次以 &lt;code&gt;Tree&lt;/code&gt; 为例：</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typ的表示方式是举行抽象的,允许实现者使用花哨的表示方式(例如,用哈希凝聚来管理共享)。如果没有视图模式,使用这个签名有点不方便。</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">外部文件或流中换行的表示。</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由GHC产生的表示形式，用于表示 &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 的种类。</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">表示重用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; （从而 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ），以及 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。（这种可重用性是我们为kind- &lt;code&gt;*&lt;/code&gt; -types 携带伪类型参数的原因，但是已经包含足够多的不同名称，而无需重复其中的每个。）</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">该模块使用的表示方法适合于高性能的使用和大量数据的流式传输。它提供了一种操作大量文本的方法,而不要求将全部内容储存在内存中。</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">类型的表示 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; ，函数 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; 其中使用由衍生实例 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 来构造 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">默认情况下，重新计划计时器以20毫秒的粒度运行，但是可以使用 &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS选项更改此计时器。重新安排&amp;ldquo;滴答&amp;rdquo;之后，正在运行的线程将尽快被抢占。</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">的分辨率 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;getCurrentTime&lt;/code&gt; ， &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">本节其余部分将进一步详细介绍GADT风格的数据类型声明。</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分概述了支持GADT的GHC扩展。扩展程序通过&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;启用。该&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;扩展还设置&lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">对功能依赖项的限制（&lt;a href=&quot;#functional-dependencies&quot;&gt;功能依赖项&lt;/a&gt;）特别麻烦。引人注意的是在上下文中引入类型变量，这些变量不会出现在头部，这是常规规则所排除的。例如：</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01982d31d372848e4d6802c210759a3354a8278" translate="yes" xml:space="preserve">
          <source>The result is always &lt;code&gt;&amp;gt;= 1&lt;/code&gt; since even zero is encoded with 1 limb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">结果是，孔或变量的行为将类似于 &lt;code&gt;undefined&lt;/code&gt; ，但具有额外的好处，即它在编译时显示警告，并且在运行时求值时也会显示相同的消息。此行为遵循&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;选项的行为，该选项表示&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。请参见将&lt;a href=&quot;#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">结果类型注释是可选的，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; （如参数类型）。可以使用种类注释中的参数声明多种类类型族：</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">运行CPS计算的结果，并将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 作为最后的延续。</target>
        </trans-unit>
        <trans-unit id="6cddc91b7454e61583af3768c2c69961c994bfc1" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">以身份作为最后的延续,运行CPS计算的结果。</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能比输入字符串长，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，亚美尼亚语的小连字&amp;ldquo; ﬓ&amp;rdquo;（现在为U + FB13）被折叠为序列&amp;ldquo;մ&amp;rdquo;（男人，U + 0574），后跟&amp;ldquo;ն&amp;rdquo;（现在为U + 0576），而希腊文将&amp;ldquo; &amp;micro;&amp;rdquo;（微符号，U + 00B5）而不是其自身折叠为&amp;ldquo;&amp;mu;&amp;rdquo;（小写字母mu，U + 03BC）。</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文小舌音符 &quot;U+FB02 &quot;被转换为拉丁文大写字母F(U+0046)和拉丁文小字母l(U+006C)的序列。</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,&quot;İ&quot; (拉丁文大写字母I,上面有点,U+0130)映射到序列 &quot;i&quot;(拉丁文小写字母i,U+0069),后面是&quot;̇&quot; (以上结合点,U+0307)。</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如，德语&amp;ldquo;&amp;szlig;&amp;rdquo;（埃塞特，U + 00DF）映射到两个字母的序列&amp;ldquo; SS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,德文eszett (U+00DF)映射到两个字母序列SS。</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文大写字母I和上面的点(U+0130)映射到序列拉丁文小写字母i(U+0069),然后是上面的组合点(U+0307)。</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">结果类型是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">结果类型不是 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">结果类型也必须是明确的。通常这一点可以推断出来,但是当一个组中的所有模式同义词在构造函数中都是多态的时候,用户必须提供一个类型签名。</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">每个数据构造函数的结果类型必须从定义的类型构造函数开始。如果所有构造函数的结果类型均为 &lt;code&gt;T a1 ... an&lt;/code&gt; ，其中 &lt;code&gt;a1 ... an&lt;/code&gt; 是不同的类型变量，则数据类型为&lt;em&gt;普通&lt;/em&gt;；否则为&lt;em&gt;通用&lt;/em&gt;数据类型（&lt;a href=&quot;#gadt&quot;&gt;通用代数数据类型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">结果将是一组（可能是）递归绑定，仅绑定左侧的简单变量。（可以像在Haskell报告中那样向前迈进一步，并使用 &lt;code&gt;fix&lt;/code&gt; 来使递归绑定成为非递归绑定，但是我们在Core中不这样做，并且它只会混淆问题，因此我们在这里不这样做。）</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">直到 &lt;code&gt;compactFixupPointers#&lt;/code&gt; ，GC才知道结果块，并且必须格外小心，以免地址逃脱或内存泄漏。</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">返回值为 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; （应为 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; ，但是Haskell的类型系统使此操作变得很困难）。</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">仅当编译器发现 &lt;code&gt;Control.Exception.assert&lt;/code&gt; 应用程序时，才由重写器执行重写，因此，您仍然可以根据需要定义和使用自己的 &lt;code&gt;assert&lt;/code&gt; 版本。如果不是，请导入 &lt;code&gt;Control.Exception&lt;/code&gt; 以在代码中使用 &lt;code&gt;assert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">记录更新的规则是这样的。</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">规则是这样的:</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">导出列表规则（Haskell报告&lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;第5.2节&lt;/a&gt;）需要针对类型族进行调整：</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">词法范围的类型变量的规则（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法范围的类型变量&lt;/a&gt;）适用于模式同义词签名。如这些规则所指定的，只有模式显式同义词的定义中来自显式的，在语法上可见的 &lt;code&gt;forall&lt;/code&gt; （通用）范围内的类型变量；被内在的一切所束缚的存在不存在。例如</target>
        </trans-unit>
        <trans-unit id="b99c4ffb314648f355d9f28d0c2cc30bab28737d" translate="yes" xml:space="preserve">
          <source>The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">解决 &quot;类型化 &quot;约束的规则如下。</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">运行时管理一组虚拟处理器，我们称其为&lt;em&gt;功能&lt;/em&gt;，其数量由 &lt;code&gt;-N&lt;/code&gt; 选项确定。每个功能可以一次运行一个Haskell线程，因此功能的数量等于可以物理并行运行的Haskell线程的数量。功能由一个或多个OS线程激活；运行时会为每种功能管理一个OS线程池，因此，如果Haskell线程进行外部调用（请参阅&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;多线程和FFI&lt;/a&gt;），则另一个OS线程可以接管该功能。</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">运行时将使用任何可用的工作程序OS线程运行Haskell线程。如果您需要控制使用哪个特定的OS线程来运行给定的Haskell线程，也许是因为您需要调用使用OS-thread-local状态的外部库，那么就需要绑定线程（请参见&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">与 &lt;code&gt;-v2&lt;/code&gt; 相同，除了另外还会打印每个编译阶段的完整命令行（如果适用）。</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">与 &lt;code&gt;-v3&lt;/code&gt; 相同，除了在每个编译阶段之后还会打印中间程序表示形式（不包括预处理和C /汇编文件）。</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 相同，但用于非IO计算。当它们用于导出具有非IO类型的Haskell函数时，用于包装 &lt;code&gt;foreign export&lt;/code&gt; 和 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">与 &lt;code&gt;register&lt;/code&gt; 相同，除了如果已安装相同名称的软件包，将其替换为新的软件包。</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">和普通的Haskell对一样,但却是</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于&amp;ldquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;rdquo;错误，其行为相同，默认情况下会终止编译。您可以使用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志来推迟此类错误。该标志将超出范围的变量产生的错误推迟到运行时，并将它们转换为编译时警告。反过来，这些警告可以完全由&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;抑制。</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">即使我们从源代码编译模块，也需要相同的标志，因为GHC仍认为它处于批处理模式：</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">相同的函子，但具有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和可 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例，这些实例以相反的顺序处理元素。</target>
        </trans-unit>
        <trans-unit id="da41682db6dc3bc462b3f80ca76ddaa5753e53c9" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">相同的函子，但具有以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="0aaeaba67e253d52c7d36c2433b481fa76e2e2f2" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">同样的信息在此汇总。</target>
        </trans-unit>
        <trans-unit id="c9836bb2774b4fe28e93611c450bce02c5621a1e" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">相同的相位编号控件可用于 &lt;code&gt;RULE&lt;/code&gt; （&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">相同的精细依赖关系分析还允许相互递归函数的类型签名具有不同的上下文，这在Haskell 98中是非法的（第4.5.2节，最后一句话）。GHC仅坚持要求&lt;em&gt;精制&lt;/em&gt;组的类型签名具有相同的类型签名；实际上，这意味着仅由相同模式绑定绑定的变量必须具有相同的上下文。例如，这很好：</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">相同的限制适用于 &lt;code&gt;deriving&lt;/code&gt; 子句生成的实例。因此，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">这里的场景与&lt;a href=&quot;#using-own-main&quot;&gt;使用您自己的main（）中&lt;/a&gt;的场景非常相似，除了目标不是链接完整的程序，而是从Haskell代码中创建一个库，该库可以按照与部署C库相同的方式进行部署码。</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">默认情况下，搜索路径包含一个目录：&amp;ldquo;&amp;rdquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;（即当前目录）。以下选项可用于添加或更改搜索路径的内容：</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">查找源文件的搜索路径是通过GHCi命令行上的&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项指定的，如下所示：</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">第二个参数通常是应用程序的名称。因为它将被整合到路径中,所以它必须由有效的路径字符组成。注意:如果第二个参数是绝对路径,它将只返回第二个参数。</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">第二个子句比较有趣。它说,如果右手边在重叠区域内重合,则允许两个重叠的类型族实例。一些例子在这里有帮助。</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个构造函数由两个字段组成。每个字段都是 &lt;code&gt;Tree a&lt;/code&gt; 类型的递归字段，表示为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; 。使用二进制类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 组合各个字段的表示形式。</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行的第二个最常见的步骤是使用有界图元填充缓冲区，其工作方式如下。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 检查是否有留下来执行有限的原始足够的空间。如果存在，那么 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 将执行有界原语并使用更新的缓冲区调用下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 器会向其驱动程序发出信号，告知它需要新的缓冲区。该缓冲区必须至少与图元的边界一样大。我们可以使用有界原语通过融合连续 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的无缓冲区检查来减少无缓冲区检查的次数s。通过确保首先检查是否还有足够的空间，然后再决定如何编码给定值，我们还可以使用有界原语来简化表示缓冲区已满的信号的控制流程。</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">其中第二种情况,即一个类型与类型参数不等,但确实包含类型参数,这可能是令人惊讶的棘手问题。例如,下面的例子可以编译。</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">第二个选项是添加标志&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程&lt;/a&gt;中运行解释器），该标志在单独的进程中运行解释器，在该进程中，它可以直接加载和运行配置文件的代码。无需两次编译代码，只需添加&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;即可。（此选项在GHC 8.0.x中是实验性的，但在将来的版本中可能会成为默认选项）。</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">文件的第二部分是按成本中心划分的程序中最昂贵的功能。在这种情况下，程序中只有一个重要功能，即 &lt;code&gt;fib&lt;/code&gt; ，它负责程序的时间和分配成本的100％。</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">本手册中有关种类多态性的部分介绍了如何对类型和类声明中&lt;a href=&quot;#inferring-variable-order&quot;&gt;的变量&lt;/a&gt;进行排序（推断类型/类声明中的变量顺序）。</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">适用于环境的选择器功能。</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">选择器的严格性注释(如有)。</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">选择器的解包性注释(如果有的话</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">这种情况下的语义是,所需实体的集合只由其导出项来定义;如果导出项列表中没有提到某个实体,它就不是必需的。这个特性背后的动机是允许库作者提供一个总括签名,其中包含了别人可能想要使用的每个函数的类型,而客户则将导出的函数缩减到他们实际需要的函数。例如,假设你继承了一个字符串的签名,你可以写一个这种形式的本地签名,只列出你需要的实体。</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; 的语义非常简单。只要GHC找到一个 &lt;code&gt;rec&lt;/code&gt; 组，它将计算其绑定变量集，并将对 &lt;code&gt;MonadFix&lt;/code&gt; 类的基础 &lt;code&gt;mfix&lt;/code&gt; 值递归运算符mfix进行适当的调用。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell模式匹配的语义在Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2节中&lt;/a&gt;进行了描述。在此描述中添加一个额外的项目10，说：</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">模式 &lt;code&gt;(&lt;/code&gt; ⟨exp⟨- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 的语义如下：</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">服务器端模板 Haskell 状态。这是由StartTH消息创建的。每个GHC类型检查的模块都会创建一个新的状态。</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">静态指针表中用于定位静态指针的键集不能保证在不同的程序二进制中保持稳定。或者换句话说,只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">已知的编码集取决于系统,但至少包括:</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">提示符下当前&lt;em&gt;作用域内&lt;/em&gt;的模块集。如上所述，此集合由 &lt;code&gt;import&lt;/code&gt; 和&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;修改，并且也会在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;之后自动修改。范围内的模块集可以用&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前正在&lt;em&gt;加载&lt;/em&gt;的模块集。该集合由&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 修改&lt;/a&gt;，并可以与&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;一起显示。</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">签名给出的是函数绑定或裸变量绑定的类型,而不是模式绑定。例如:</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 解码器的最简单的接口。如果解码器遇到错误，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或输入用完，它将调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e8c225c01f9faa3800585856cd9e7639c83f852" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="15de436f5ad58966f3fd02d798c87b26a0a4d2de" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，并且如果超出大小限制，则序列的行为不确定。这是不太可能在大多数应用中发生，但可能需要一些护理使用时 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ，特别是重复且特别是与组合 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9c06af16b62ace31432f475d864e0e1ea766afc" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。两个原始键中较大者的值用作 &lt;code&gt;c&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将保留原始键最大的值。</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 生成的字节序列的大小。</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">集合的大小不能超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">一个边界对所定义的子范围的大小。</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已调整大小的整数数据类型 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">您可以使用的大锤是 &lt;code&gt;INLINE&lt;/code&gt; 编译指示，因此使用：</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">解决办法是自己定义实例专用函数,用pragma防止过早内联,并给它一个rule。</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">该程序的源文件并不需要全部都在同一目录中。在&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项可以用来将目录添加到搜索路径（见&lt;a href=&quot;separate_compilation#search-path&quot;&gt;的搜索路径&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">来源地</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准数据声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准类型声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">专门的软件包名称 &lt;code&gt;this&lt;/code&gt; 可以用来指代当前包在建。</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">该规范以格式字符结束。</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">指定的文件包含在C程序，已编译的Haskell文件和C标头中。 &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; 是自动包含的。</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; ， &lt;code&gt;NominalDiffTime&lt;/code&gt; ， &lt;code&gt;CalendarDiffDays&lt;/code&gt; 和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 的说明符在语义上与其他类型分开。负时差的说明 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 通常为负（认为rem而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="509d7b73e79bd7157914844fa1c9246fd5e8d212" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">接头 &lt;code&gt;$(blah1)&lt;/code&gt; 无法引用函数 &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; 是后面的声明组的一部分，因此是不可见的，类似地， &lt;code&gt;$(blah1)&lt;/code&gt; 也看不到 &lt;code&gt;h&lt;/code&gt; 的定义（因为它与 &lt;code&gt;$(blah1)&lt;/code&gt; 是同一声明组的一部分）（blah1）。但是，拼接 &lt;code&gt;$(blah1)&lt;/code&gt; 可以看到 &lt;code&gt;f&lt;/code&gt; 的定义（因为它在紧接的声明组中）。</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">拼接 &lt;code&gt;$(blah2)&lt;/code&gt; 会看到作为拼接相同的定义 &lt;code&gt;$(th2 ...)&lt;/code&gt; （但&lt;em&gt;没有&lt;/em&gt;任何绑定它创建）。</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; 将看到 &lt;code&gt;f&lt;/code&gt; 的定义-接头是顶级的，因此可见在先前声明组中的所有定义（即，模块中的所有定义，包括但不包括：接头本身）。</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;不能&lt;/em&gt;引用 &lt;code&gt;D&lt;/code&gt; -它在同一声明组中。</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">拼接 &lt;code&gt;$(th2 ...)&lt;/code&gt; 会看到的定义 &lt;code&gt;f&lt;/code&gt; ，通过创建的所有绑定 &lt;code&gt;$(th1 ...)&lt;/code&gt; ，定义 &lt;code&gt;h&lt;/code&gt; 和创建的所有绑定 &lt;code&gt;[qq|blah|]&lt;/code&gt; 他们都在前面声明组）。</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">拼接运行</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">默认情况下，堆栈配置文件中不计算堆栈。请参阅RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">堆栈跟踪通常可能以诸如 &lt;code&gt;GHC.List.CAF&lt;/code&gt; 之类的无信息的内容开始；这是GHC的优化程序的一种人工产物，它可以将异常提升到顶级，在顶级系统中，性能分析系统会将异常分配给成本中心&amp;ldquo; CAF&amp;rdquo;。但是， &lt;code&gt;+RTS -xc&lt;/code&gt; 不仅打印当前堆栈，它看起来更深，并在评估CAF时报告堆栈，并且它可能会报告其他堆栈，直到找到非CAF堆栈为止。在上面的示例中，下一个堆栈（在 &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 符之后）包含许多有关程序在评估 &lt;code&gt;head []&lt;/code&gt; 时正在执行的操作的信息。</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">堆栈溢出的消息。</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">独立语法针对新类型的泛化与普通 &lt;code&gt;deriving&lt;/code&gt; 子句的泛化完全相同（&lt;a href=&quot;#newtype-deriving&quot;&gt;针对新类型的广义派生实例&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">独立的派生声明不必与数据类型声明位于同一模块中。（但是要注意孤立实例的危险（&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="704c3d94002789a8f5e8c50c778edbf18c8986c7" translate="yes" xml:space="preserve">
          <source>The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">标准的C99 &lt;code&gt;fenv.h&lt;/code&gt; 标头提供了用于检查和修改浮点单元的状态的操作。特别是，可以更改浮点运算所使用的舍入模式，并且可以测试异常标志。</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">标准的CPUTime库。</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">标准的IO库。</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS X上的标准假设是，动态库将在构建时用&amp;ldquo;安装名称&amp;rdquo;标记，这是库文件的完整最终安装路径。随后链接到该库的任何库或可执行文件（即使尚未安装）也将选择该路径作为其运行时搜索位置。直接使用ghc进行编译时，默认情况下会将安装名称设置为生成位置。您可以使用 &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; 选项（将 &lt;code&gt;-install_name&lt;/code&gt; 传递给Apple链接程序）覆盖此选项。 Cabal为您做到这一点。它将自动将动态库的安装名称设置为最终安装位置的绝对路径。</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">因此，扩展了标准默认规则：当所有未解决的约束都涉及标准类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 时，将应用默认值；至少一个是数字类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">标准函数 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; 锁定稳定指针表，释放给定的稳定指针，然后再次解锁稳定指针表。一次释放许多稳定的指针时，通常一次锁定和解锁表会更有效。</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">编码和解码文本的标准功能很严格，也就是说，它们对无效输入会抛出异常。这通常对现实世界的输入没有帮助，因此存在替代功能，这些功能接受用于处理无效输入的自定义处理程序。这些 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; 处理程序是常规的Haskell函数。您可以使用此模块中预先提供的功能之一，也可以编写自己的自定义处理程序。</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">与 &lt;code&gt;callCC&lt;/code&gt; 一起使用的标准习惯用法是提供lambda表达式来命名延续。然后，即使在嵌套计算中有很多层，在其范围内的任何地方调用命名的连续都将退出计算。</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">标准库不直接支持此设备类型，但是用户实现应期望以任意顺序在目录中提供文件名列表，并以 &lt;code&gt;'\0'&lt;/code&gt; 字符分隔，但不包括 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 名称。另请参见 &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; 。目录（除零位以外）不支持搜寻操作。</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">系统加载程序的标准库搜索路径，在某些系统上，可以通过设置 &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量来覆盖该路径。</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">执行栈的状态</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">语句 &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; 表示&amp;ldquo; 在 &lt;code&gt;IO&lt;/code&gt; monad中执行 &lt;code&gt;return 42&lt;/code&gt; ，并将结果绑定到 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。然后，我们可以在以后的语句中使用 &lt;code&gt;x&lt;/code&gt; ，例如像上面一样打印它。</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">该语句不是绑定，或者它是仅绑定一个变量的单子绑定（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">存储值并不代表大的虚拟数据结构,可以懒得计算。</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">从抛出异常到处理异常的过程中,通过绕过约束函数,将能抛出异常的计算组合起来的策略。</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型要求整个字符串一次放入内存。惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型能够使用较小的内存占用量流传输比内存大的字符串。在许多情况下，分块流传输的开销使惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型比其严格对应类型慢，但并非总是如此。有时，一个功能在一个模块中的时间复杂度可能会因另一个模块的内部结构不同而有所不同。</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">严格性分析器指出何时可以&amp;ldquo;严格地&amp;rdquo;对待函数中的参数和变量（即始终在函数中对它们进行评估）。这使GHC可以进行某些优化，例如取消装箱，否则将不适用，因为当应用于延迟参数时，它们会更改程序的语义。</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的严格程度。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">在编译过程中，GHC推断字段的严格性。尽管 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 有九种不同的组合，但是GHC决定的严格性最终将是惰性，严格或未打包的一种。GHC决定的内容受用户在源代码中编写的内容以及GHC标志的影响。例如，请考虑以下数据类型：</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">编译器对选择器推断的严格程度。</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">该模块中的字符串功能是对应于用户输入的字符序列,如方向键和功能键。</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">软件包名称后括号中的字符串是已安装的软件包ID：通常以软件包名称和版本开头，并以从已编译的软件包派生的哈希字符串结尾。软件包之间的依赖关系以已安装的软件包ID表示，而不仅仅是软件包和版本。例如，看一下 &lt;code&gt;haskell98&lt;/code&gt; 软件包的依赖关系：</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">有向图的强连接分量,反向拓扑排序。</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">有向图的强连接组件，按逆向拓扑排序。该函数与 &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; 相同，只是保留了有关每个节点的所有信息。当您希望申请该接口用于 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 来（一些）的结果 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; ，所以你不想失去相关性信息。</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">图的强连接分量,按反向拓扑顺序。</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">在 &lt;code&gt;n+k&lt;/code&gt; 模式中，减法运算和大于等于检验使用范围内的 &lt;code&gt;(-)&lt;/code&gt; 和 &lt;code&gt;(&amp;gt;=)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">由于输入不足而无法解码的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 后缀。</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">概括 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; 的动作集合的总和。</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">超类实例应满足以下要求。</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">下面列出了GHC定义的符号。要检查哪些符号是由你本地安装的GHC定义的,下面的技巧很有用。</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">以下小节将详细说明模式同义词的语法和语义。也有在其它更多细节&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;纸&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">最小完整定义的语法是:</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">提示 &lt;code&gt;*module&lt;/code&gt; 中的语法表明，是&amp;ldquo; 模块&amp;rdquo;的完整顶级范围才有助于在提示中键入的表达式的范围。如果没有 &lt;code&gt;*&lt;/code&gt; ，则仅显示模块的导出。</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">语法是</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">除了（a）关键字 &lt;code&gt;deriving&lt;/code&gt; 和（b）缺少 &lt;code&gt;where&lt;/code&gt; 部分之外，该语法与普通实例声明的语法相同。</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">语法与 &lt;code&gt;case&lt;/code&gt; 表达式相同，除了替代方法的主体是命令而不是表达式。转换类似于 &lt;code&gt;if&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">表达式的成本中心注释的语法是</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCi提示符下接受的语句的语法与Haskell &lt;code&gt;do&lt;/code&gt; 表达式中的语句的语法完全相同。但是，这里没有monad重载：在提示符下键入的语句必须在 &lt;code&gt;IO&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">值的语法取决于字段。各种字段类型有:</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">下表总结了每一种模式同义词的使用范围。</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">模板文件(见下文)。</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">子计算终止时（正常或通过异常）释放临时存储，因此在该函数返回后，&lt;em&gt;不得&lt;/em&gt;使用指向临时存储的指针。</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">&amp;ldquo;未注册&amp;rdquo;一词的真正含义是&amp;ldquo;通过香草C编译&amp;rdquo;，从而禁用了GHC通常用来使程序运行更快的某些特定于平台的技巧。当编译未注册的内容时，GHC会简单地生成一个通过gcc编译的C文件。</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">术语级别的语法相似。前导和前杠（ &lt;code&gt;|&lt;/code&gt; ）指示它是哪个替代项。这是上面显示的两种类型的术语：</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">该文件的第三部分也是最后一部分提供了按成本中心堆栈划分的配置文件细分。这大致是程序的调用树配置文件。在上面的示例中，很明显，对 &lt;code&gt;fib&lt;/code&gt; 的昂贵调用来自 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">第三例声明不服从覆盖条件;事实上(有点奇怪)定义。</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">对于每种新类型 &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; ，都存在第三种实例，它有两个变体，即</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">第三种通配符是&lt;em&gt;Extra-constraints通配符&lt;/em&gt;。额外约束通配符的存在指示在类型检查期间可以推断任意数量的额外约束，并将其添加到类型签名中。在下面的示例中，额外约束通配符用于推断三个额外约束。</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">该线程在 &lt;code&gt;MVar&lt;/code&gt; 上被阻止，但是没有其他对 &lt;code&gt;MVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">该线程正在等待重试STM事务，但是没有其他涉及任何 &lt;code&gt;TVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">使用 &lt;code&gt;pthread_kill()&lt;/code&gt; 向发出外部调用的线程发送 &lt;code&gt;SIGPIPE&lt;/code&gt; 信号。这通常足以导致阻塞的系统调用返回 &lt;code&gt;EINTR&lt;/code&gt; （默认情况下，GHC为 &lt;code&gt;SIGPIPE&lt;/code&gt; 安装一个空信号处理程序，以覆盖默认行为，即立即终止进程）。</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">线程运行系统具有以下优点。</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">程序给定部分所花费的时间和分配以两种方式显示：&amp;ldquo;个人&amp;rdquo;，即由该成本中心堆栈所覆盖的代码所产生的成本；以及&amp;ldquo;继承&amp;rdquo;，其包括所有成本所引起的成本该节点的子代。</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">气象局本身所耗费的时间</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">在同步化过程中,GC之前所经过的时间。</target>
        </trans-unit>
        <trans-unit id="4b330c6f47b52569d23f62fae825fc0e09a81ec0" translate="yes" xml:space="preserve">
          <source>The time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">时间地点。</target>
        </trans-unit>
        <trans-unit id="1637c3729549ceeb82c37601b6dec6b827e71006" translate="yes" xml:space="preserve">
          <source>The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">时间值，如果无法使用给定格式解析输入，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="806aa42ce85483bc45bf5f50020217f50c8cf737" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">时间值。</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">程序在整个运行过程中分配的总字节数。</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">进行垃圾收集的总次数。</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">程序执行的总时间（以秒为单位）。</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">译文经过精心设计,使bang模式对递归和多态绑定以及直接的非递归绑定都有意义。</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">这种形式的翻译使用 &lt;code&gt;loop&lt;/code&gt; 组合器，因此有关的箭头必须属于 &lt;code&gt;ArrowLoop&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">三元单体变换器,它将一个单体映射到一个等价单体上。</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">孤儿的麻烦在于，GHC必须主动读取所有孤儿模块的接口文件，以防万一它们的实例或规则起作用，而无论模块接口是否可以使用。有关详细信息，请参见&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">两者的处理方式相同，只是后者可能会将类型变量带入范围（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexical作用域类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">这两个构造函数具有您期望的类型：</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">两个函数 &lt;code&gt;comp1&lt;/code&gt; 和 &lt;code&gt;comp2&lt;/code&gt; 具有相同的语义，但是 &lt;code&gt;comp1&lt;/code&gt; 在应用于&lt;em&gt;两个&lt;/em&gt;参数时将被内联，而 &lt;code&gt;comp2&lt;/code&gt; 需要&lt;em&gt;三个&lt;/em&gt;。如果您说这可能会有很大的不同</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">两组选项的初始化如下。首先，&lt;a href=&quot;#ghci-dot-files&quot;&gt;如.ghci和.haskeline文件中&lt;/a&gt;所述初始化两组选项。然后，对交互选项进行如下修改：</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;命令分别检查两组选项，不带参数。例如，在干净的GHCi会话中，我们可能会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 类型在角色表示中具有其参数，这通常是最常见的情况。 &lt;code&gt;Simple Age&lt;/code&gt; 与 &lt;code&gt;Simple Int&lt;/code&gt; 具有相同的表示形式。类型 &lt;code&gt;Complex&lt;/code&gt; ，而另一方面，有其在标称的作用参数，因为 &lt;code&gt;Complex Age&lt;/code&gt; 和 &lt;code&gt;Complex Int&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样的。最后，尽管 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Bool&lt;/code&gt; 无关，但 &lt;code&gt;Phant Age&lt;/code&gt; 和 &lt;code&gt;Phant Bool&lt;/code&gt; 具有相同的表示形式。</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">类型 &lt;code&gt;StreamPermParser s st a&lt;/code&gt; 表示一个置换分析器，当由 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 函数转换时，它将分析具有用户状态 &lt;code&gt;st&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 流，并在成功时返回a类型 &lt;code&gt;a&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="6120b118bdba0e4c010f34fbf9eb9b4980f33ce0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">类型 &lt;code&gt;t&lt;/code&gt; 是任意类型。</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">类型检查器有时会在错误消息中显示类型环境的片段，但是最多显示此标志设置的最大数量。使用 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 将其关闭可提供无限数量。从语法上讲，顶级绑定通常也被排除（因为它们可能很多），但是 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 也包括它们。</target>
        </trans-unit>
        <trans-unit id="b4f3436c445b81b9b8c7c9be8963efa0b16fdd8a" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; 是可以安全地将任何提升类型强制转换为反向的类型。更具体地说，对于提升类型 &lt;code&gt;t&lt;/code&gt; 和值 &lt;code&gt;x :: t&lt;/code&gt; ， &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; 等效于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">类型构造函数 &lt;code&gt;Proxy#&lt;/code&gt; 用于见证某些类型变量。当您要传递代理值以进行诸如对类型应用程序建模之类的操作时，可以使用它。一个 &lt;code&gt;Proxy#&lt;/code&gt; 不仅拆箱，它也有一个多态样了，有没有运行时表示，是完全免费的。</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 都是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">类型函数 &lt;code&gt;Item&lt;/code&gt; 返回结构 &lt;code&gt;l&lt;/code&gt; 的项目类型。</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">在一个类型 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示可以是任何类型，它是比原来的功能的类型少的多态性。具体来说，如果原始函数为 &lt;code&gt;f&lt;/code&gt; ,则说明语用</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">当然,该类型也可以包含一个类上下文。</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的类型令人头疼，但是在操作上它是列表折叠的简单概括。</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; 的类型在Haskell 98中是非法的，因为它包含约束 &lt;code&gt;Eq a&lt;/code&gt; ，该约束仅约束类类型变量（在这种情况下为 &lt;code&gt;a&lt;/code&gt; ）。这种情况 &lt;code&gt;a&lt;/code&gt; ）。更准确地说，如果以下情况被拒绝，则拒绝类方法签名中的约束：</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">任何一种 &lt;code&gt;case&lt;/code&gt; 提到的任何自由变量的类型都必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">不可变的非严格（装箱）数组的类型，其索引在 &lt;code&gt;i&lt;/code&gt; 中，元素在 &lt;code&gt;e&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">非空流的类型</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 方法的类型为 &lt;code&gt;[a]&lt;/code&gt; ，这也是默认方法的类型。您可以取消此限制，并使用扩展名&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;为默认方法提供其他类型。例如，如果你在一个类写一个通用实现枚举的 &lt;code&gt;GEnum&lt;/code&gt; 与方法 &lt;code&gt;genum&lt;/code&gt; 来讲 &lt;code&gt;GHC.Generics&lt;/code&gt; ，你可以指定一个默认的方法，它使用通用的实现：</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">正如 &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; 所示，参数的类型通常可以比所需的类型更一般。（ &lt;code&gt;reverse&lt;/code&gt; 不需要 &lt;code&gt;Ord&lt;/code&gt; 约束。）</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">整个 &lt;code&gt;case&lt;/code&gt; 表达式的类型必须是固定的。</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">被更新的表达式的类型不会被推断出来,也不会进行约束解,所以以下内容会被视为模棱两可而被拒绝。</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">对象的类型必须是 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 的实例，以确保只能将单态类型的对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 。要将多态对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; ，请为其提供单态类型签名。例如：</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">该类型保存词法分析器是工作记录的 &lt;code&gt;s&lt;/code&gt; 与国家流 &lt;code&gt;u&lt;/code&gt; 在单子 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">审稿人的类型必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">类型参数 &lt;code&gt;c_m&lt;/code&gt; 在 &lt;code&gt;T1&lt;/code&gt; 到 &lt;code&gt;Tk&lt;/code&gt; 的每个类型变量中出现一次。想象一个没有这种情况的课堂。例如：</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数应该是 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">当然,类型参数必须都是类型变量,其中一些(但不一定全部)可以是类参数。每个类参数在每个关联类型中最多只能使用一次,但有些可以省略,它们的顺序也可以不在类头中。因此,下面这个人为的例子是可以接受的。</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 被列表的无限嵌套替换，则这对中的类型模式相等。对于类型健全性，必须拒绝此类实例。</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名使类型变量 &lt;code&gt;a&lt;/code&gt; 进入范围，这是因为显式的 &lt;code&gt;forall&lt;/code&gt; （&lt;a href=&quot;#decl-type-sigs&quot;&gt;声明类型签名&lt;/a&gt;）。由结合的类型变量 &lt;code&gt;forall&lt;/code&gt; 的范围在所附的值声明的整个定义。在此示例中，类型变量 &lt;code&gt;a&lt;/code&gt; 覆盖 &lt;code&gt;f&lt;/code&gt; 的整个定义，包括 &lt;code&gt;ys&lt;/code&gt; 的类型签名。在Haskell 98中，不可能为 &lt;code&gt;ys&lt;/code&gt; 声明一个类型。作用域类型变量的主要好处是可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">类型类的默认方法的类型签名必须与相应的主方法的类型签名采用相同的形式。否则，类型检查器将拒绝该类的定义。&amp;ldquo;采用相同的形式&amp;rdquo;是指默认类型签名应仅在其上下文中与主要类型签名不同。因此，如果您有一个方法 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">实例声明中的类型签名必须比类声明中的类型签名更多态(或相同),用实例类型实例化。例如,这样就可以了。</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">类型签名可能有量化的类型变量,但没有出现在结果类型中。</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; 的类型签名会通知用户其正确性取决于未经证实的猜想。如果使用该功能，则用户必须通过以下方式确认依赖关系：</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">每个构造函数的类型签名都是独立的，并且像往常一样隐式地进行通用量化。特别是，&amp;ldquo; &lt;code&gt;data T a where&lt;/code&gt; &amp;rdquo;标头中的类型变量没有作用域，并且不同的构造函数可能具有不同的通用量化类型变量：</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">用于尺寸和sizeBounds的类型。</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">类型变量 &lt;code&gt;a&lt;/code&gt; 没有其他限制</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">此处使用的类型变量 &lt;code&gt;e&lt;/code&gt; 表示元素类型，而 &lt;code&gt;ce&lt;/code&gt; 是容器本身的类型。在此框架内，我们可能想为列表或特征函数（两者都可用于表示任何相等类型的集合），位集（可用于表示字符的集合）或哈希定义此类的实例。表（可用于表示其元素具有哈希功能的任何集合）。省略标准实施细节，这将导致以下声明：</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">类型变量由单一的，语法上可见，最外面的量化 &lt;code&gt;forall&lt;/code&gt; 的类型签名的。例如，GHC将拒绝以下所有示例：</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">类型变量（如果给定的话）可能是显式的，所以我们也可以这样写 &lt;code&gt;Foo&lt;/code&gt; 的头文件：</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">类型变量 &lt;code&gt;vk+1...vn&lt;/code&gt; 不在类型 &lt;code&gt;t&lt;/code&gt; ， &lt;code&gt;s1..sk&lt;/code&gt; 或 &lt;code&gt;t1..tj&lt;/code&gt; 中出现。</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;instance&lt;/code&gt; 声明的头部中的类型变量作用于 &lt;code&gt;where&lt;/code&gt; 部分中定义的方法。您甚至不需要显式的 &lt;code&gt;forall&lt;/code&gt; （尽管在 &lt;code&gt;instance&lt;/code&gt; 声明中允许显式的 &lt;code&gt;forall&lt;/code&gt; ；请参阅&lt;a href=&quot;#explicit-foralls&quot;&gt;显式通用量化（forall）&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="1f03bbab3fd03c0f04b9e0c0fedb642fb00b2844" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">通常，类型族方程右侧的类型变量必须由左侧明确绑定。对于&lt;em&gt;种类&lt;/em&gt;变量，此限制放宽了，但是，因为允许右侧提到隐式绑定的种类变量。例如，这些是合法的：</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">类型变量： &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型级别等效于 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">类型安全浇注操作</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，类 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 以及在Word32和Float以及Word64和Double之间进行转换。</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; 再次是类型级别的代理，仅用于创建 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的多个变体。</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ，以及类 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">单纯的类型是不会执行这些法律的,所以你要自己去查。</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">细孔配合中其他孔的类型显示在输出中，例如 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; 是孔 &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; 的细化。如果关闭此标志，则输出将仅显示 &lt;code&gt;foldl1 _&lt;/code&gt; ，可以将其直接替换为孔，而无需 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">未装箱元组的典型用法是简单地返回多个值，并将这些多个结果与 &lt;code&gt;case&lt;/code&gt; 表达式绑定在一起，因此：</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">地图列表的结合,并进行组合操作。</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d32217b38bffdaa9ca587e9d6a40f750e6e5bfb9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b99c2dfae5341557cba637c4f3ef989142689dd9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">地图列表的结合。</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="06da55697aaeea01f68121fc5dda49aec58e2fa9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5359b26f8252c95c2fa3287a62d5ed9a07ab46e7" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">一组列表的结合。</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">可折叠结构中集合的并集：（ &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">该组的唯一数字ID(gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">将单元类型 &lt;code&gt;()&lt;/code&gt; 和列表类型 &lt;code&gt;[]&lt;/code&gt; 添加到标准类型列表的开头，这些类型在进行类型默认设置时会尝试使用。</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的解包性。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">这样的结果是，如果您的Haskell线程在外部调用中被阻塞，则 &lt;code&gt;hs_exit()&lt;/code&gt; 可能会挂起（或可能忙于等待），直到调用返回。因此，最好在调用 &lt;code&gt;hs_exit()&lt;/code&gt; 时确保系统中没有此类线程。这包括执行I / O的任何线程，因为可以使用阻止外部调用来实现I / O（或可以不取决于I / O的类型和平台）。</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译 &lt;code&gt;Danger&lt;/code&gt; 限制了可用于&lt;a href=&quot;#safe-language&quot;&gt;安全子集&lt;/a&gt;的Haskell功能。这包括禁止使用 &lt;code&gt;unsafePerformIO&lt;/code&gt; ，模板Haskell，纯FFI函数，规则和限制重叠实例的操作。该&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志也限制了模块可以通过进口 &lt;code&gt;Danger&lt;/code&gt; ，只有那些被认为是可信的。受信任的模块是使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的模块，其中GHC提供了机械确保代码安全的保证。或那些使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的模块，其中模块作者声称该模块是安全的。</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示居住类型的类型取决于&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;扩展名，该扩展名在将来的版本中将默认关闭，然后可能会删除。&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30中&lt;/a&gt;对此原因和弃用时间表进行了说明。</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">在 &lt;code&gt;?y&lt;/code&gt; 的绑定中使用 &lt;code&gt;?x&lt;/code&gt; 不会&amp;ldquo;看到&amp;rdquo; &lt;code&gt;?x&lt;/code&gt; 的绑定，因此 &lt;code&gt;f&lt;/code&gt; 的类型为</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">稍微修改一下这个例子,就能更好地证明成本中心堆栈的作用。</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">用户可以选择声明所需的&lt;a href=&quot;#deriving-stragies&quot;&gt;派生策略&lt;/a&gt;，特别是如果编译器&lt;a href=&quot;#default-deriving-strategy&quot;&gt;默认&lt;/a&gt;选择了错误的派生策略。</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">用户数据库</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">通常的输出流是 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 。对于Windows GUI应用程序（没有stderr），输出将定向到Windows调试控制台。这些函数的某些实现可能会修饰输出的字符串，以指示您正在跟踪。</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">数组中给定索引的值。</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">主要版本 &lt;code&gt;x.y.z&lt;/code&gt; 的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值（请参阅&lt;a href=&quot;phases#c-pre-processor&quot;&gt;影响C预处理程序的选项&lt;/a&gt;）是整数⟨xyy⟩（如果⟨y⟩是一位数字，则添加前导零，例如在版本6.8.2中）我们将拥有 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">快照版本的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值为整数⟨xyy⟩。但是，您永远不应编写任何测试该值的条件代码：由于接口每天都在变化，并且我们在 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值中没有更细的粒度，因此您仅应使用可测试该条件的谓词进行条件编译是否 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 等于，晚于或早于给定的主要版本。</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">的值 &lt;code&gt;seq a b&lt;/code&gt; 是底部，如果 &lt;code&gt;a&lt;/code&gt; 是底部，否则等于 &lt;code&gt;b&lt;/code&gt; 。换句话说，它将第一个参数 &lt;code&gt;a&lt;/code&gt; 评估为弱头范式（WHNF）。通常引入 &lt;code&gt;seq&lt;/code&gt; 来避免不必要的懒惰，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">在编译/链接时，GHC标志 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">变量的类型不是多态的，不是 &lt;code&gt;()&lt;/code&gt; ，并且是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">左手边定义中的变量被右手边的模式所约束。对于双向模式同义词,右侧的所有变量也必须出现在左侧;另外,不允许使用通配符模式和视图模式。对于单向和明确的双向模式同义词,对右侧模式没有限制。</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">运行时的变体（&amp;ldquo;方式&amp;rdquo;）。最常见的值是 &lt;code&gt;rts_v&lt;/code&gt; （香草）， &lt;code&gt;rts_thr&lt;/code&gt; （螺纹运行时，即，链接使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项）和 &lt;code&gt;rts_p&lt;/code&gt; （仿形运行时，即，链接使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项）。其他变体包括 &lt;code&gt;debug&lt;/code&gt; （使用&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;链接）和 &lt;code&gt;dyn&lt;/code&gt; （RTS是动态链接的，即共享库，而不是静态链接到可执行文件本身）。这些可以组合，例如，您可能具有 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">不同的通信进程需要在用于引用静态指针表中的值的键上达成一致,否则查找将失败。只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">您可以通过使用 &lt;code&gt;--version&lt;/code&gt; 标志调用 &lt;code&gt;ghc&lt;/code&gt; 来找到GHC副本的版本号（请参见&lt;a href=&quot;using#options-help&quot;&gt;Verbosity选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 与该程序被编译或正在解释。</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">编译此程序时使用的GHC版本。</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">强连接组件列表的顶点。</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">强连接分量的顶点。</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">类参数在相关族实例右侧的可见性&lt;em&gt;仅&lt;/em&gt;取决于族的参数。例如，考虑简单的类声明</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt;，默认情况下处于关闭状态，但包含在&lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 中&lt;/a&gt;，如果您隐藏了导入的模块不导出的内容，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="5369ef220638dc82aaace3093ac85be8f6ea055a" translate="yes" xml:space="preserve">
          <source>The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">对于以下划线开头的名字,警告会被抑制。例如</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">如果字段名以下划线开头,则该警告将被抑制。</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示重复的 &lt;code&gt;Eq a&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：： &lt;code&gt;f&lt;/code&gt; 的定义未使用它。）</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：它被 &lt;code&gt;Ord a&lt;/code&gt; 包含为约束。</target>
        </trans-unit>
        <trans-unit id="6b81d66b467d23d7422d611d2f4898b0e6c539b7" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">获得可预测行为的方法是在 &lt;code&gt;f&lt;/code&gt; 上使用&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示或INLINE [⟨phase⟩]编译指示，以确保在规则有机会触发之前不会内联。警告标志&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全性检查&lt;/a&gt;）对这种情况发出警告。</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">识别这种情况的方法是将&lt;em&gt;角色&lt;/em&gt;分配给数据类型，类和类型同义词的类型变量。</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">该库中的弱指针支持另一种方法，称为&lt;em&gt;finalization&lt;/em&gt;。当弱指针所指的密钥死亡时，存储管理器安排运行程序员指定的终结器。例如，在备忘录表的情况下，终结器可以从备忘录表中删除键/值对。</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">解决方法是分裂的.o文件，使你的包成两个或两个以上的.o的，沿该怎么行 &lt;code&gt;base&lt;/code&gt; 包做的。</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">工作车间</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">包装器和通用默认值</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">拉链： &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">&amp;ldquo; quoter&amp;rdquo;不能为&amp;ldquo; &lt;code&gt;e&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;t&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;d&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;p&lt;/code&gt; &amp;rdquo;，因为它们与Template Haskell引用重叠。</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩必须是导入的报价器名称,可以是有条件的,也可以是无条件的,不能是任意表达式。</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">然后 &lt;code&gt;Foo_stub.h&lt;/code&gt; 将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">然后， &lt;code&gt;Parser&lt;/code&gt; 是 &lt;code&gt;MonadPlus&lt;/code&gt; 的一个实例：单子排序实现解析器的串联，而 &lt;code&gt;mplus&lt;/code&gt; 提供选择。要使用解析器，我们需要一个基元来在输入字符串上运行构造的解析器：</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">然后， &lt;code&gt;bar&lt;/code&gt; 的默认方法必须采用以下形式：</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">然后，尽管可以使用 &lt;code&gt;stdout2&lt;/code&gt; 写入标准输出，但 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">然后,涂抹式脱胶将使其变成。</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">然后是用户编写的变量，以类型变量的类型隐式地带入范围。</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">然后使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;再次对其进行编译，并另外使用 &lt;code&gt;-osuf p_o&lt;/code&gt; 来对目标文件进行不同的命名（您可以在此处选择不是正常对象后缀的任何后缀）。执行拼接表达式时，GHC将自动加载第一步中构建的目标文件。如果在使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;进行构建时省略了 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 标志，并且使用了模板Haskell，则GHC将发出错误消息。</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">然后，在一些进口模块 &lt;code&gt;M&lt;/code&gt; ，约束 &lt;code&gt;(E a Int)&lt;/code&gt; 设置应为&amp;ldquo;提高&amp;rdquo; &lt;code&gt;a = T&lt;/code&gt; ，&lt;em&gt;尽管没有明确提及&lt;/em&gt;的 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">这样就可以派生 &lt;code&gt;HigherEq Option&lt;/code&gt; 实例。请注意，唯一的区别是现在 &lt;code&gt;(==#)&lt;/code&gt; 的非默认类型签名引入了一个 &lt;code&gt;Eq a&lt;/code&gt; 约束。来自非默认类型签名的约束永远不会出现在派生实例上下文本身中，但是它们可以用于履行默认类型签名所要求的义务。在上面的示例中，默认类型签名需要一个 &lt;code&gt;Eq a&lt;/code&gt; 实例，并且非默认签名能够满足该请求，因此派生的实例很简单：</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">那么它就会以错误的方式失败,大意是:。</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">然后派生的 &lt;code&gt;Foo&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">那么派生实例声明的形式是</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">然后，解析器将跟踪它执行了多少个 &lt;code&gt;tick&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">然后程序的其余部分将使用构建的标志列表来决定它的行为。</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">然后，使用 &lt;code&gt;args.txt&lt;/code&gt; 调用 &lt;code&gt;foo&lt;/code&gt; 的结果是：</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">然后我们可以这样运行程序。</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 原语之上实现自己的 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">有&lt;em&gt;许多&lt;/em&gt;影响GHC产生代码质量的选项。大多数人只有一个总体目标，例如&amp;ldquo;快速编译&amp;rdquo;或&amp;ldquo;使我的程序像润滑的闪电般运行&amp;rdquo;。下列优化（或缺乏优化）&amp;ldquo;包装&amp;rdquo;就足够了。</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有一些警告可能会在将来被删除：此选项当前未在Windows上实现（它是无操作），并且外部解释器不支持GHCi调试器，因此断点和单步执行不&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;不起作用。</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">有几个标志用于控制输入孔的上下文信息显示量。</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">还有其他一些与分析相关的编译选项。&lt;em&gt;除了&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt;之外，还要&lt;/em&gt;使用它们。这些不必一定要在程序中的所有模块上一致使用。</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">还有 &lt;code&gt;case&lt;/code&gt; 命令，例如</target>
        </trans-unit>
        <trans-unit id="1279203c2e0d157a8d9dad524a1fc81607cfc8e4" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt;&lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">当前有两种方法可以对有效的孔配合进行排序。可以使用 &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 切换排序</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">编译为目标代码有一些缺点：例如，您不能在目标代码模块中设置断点。在GHCi中仅可见目标代码模块的导出，而不是解释模块中的所有顶级绑定。</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">有五种新的理解限定词形式， &lt;code&gt;then&lt;/code&gt; 由（existing）关键字引入：</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">有四种方法可以设置RTS选项。</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">有许多数据类型-通用函数并不区分作为参数的位置和作为递归调用的位置,也有许多数据类型-通用函数根本不关心数据类型和构造函数的名称。还有很多数据类型-泛型函数根本不关心数据类型和构造函数的名称。为了使通用函数在这种情况下要考虑的情况数量降到最低,结果发现上面介绍的很多类型构造函数实际上是同义词,把它们定义为一个较小的构造函数集的变体。</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">有许多不同种类的配置文件可以生成,由不同的 RTS 选项选择。我们将在本章的其余部分描述各种不同类型的配置文件。有些配置文件需要在程序运行后使用额外的工具进行进一步的处理。</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">没有此类的预定义实例。默认情况下，它不在范围内，但是可以通过导入&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels使其&lt;/a&gt;进入范围。不像 &lt;code&gt;IsString&lt;/code&gt; ，没有特殊的默认规则 &lt;code&gt;IsLabel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70d1d2c96409db371b4aa9bd1644711aa1fc1d7d" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">没有可运行的线程，因此程序处于死锁状态。该 &lt;code&gt;Deadlock&lt;/code&gt; 例外仅在主线程提高。</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;没有语法变化。它在源代码级别显示的唯一方式是您可以拥有一个不需要 &lt;code&gt;Monad&lt;/code&gt; 约束的 &lt;code&gt;do&lt;/code&gt; 表达式。例如，在GHCi中：</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">没有要传递的 &lt;code&gt;V1 p&lt;/code&gt; 类型的值（未定义的除外），因此实际上是不可能的。有人会问为什么在这种情况下为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 定义一个实例为什么很有用？好的，可以将空类型用作非空类型的参数，并且您可能仍希望对结果类型进行编码。作为一个有些人为的示例，请考虑 &lt;code&gt;[Empty]&lt;/code&gt; ，它不是空类型，而仅包含空列表。该 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 实例，确保我们能够呼吁这些类型的通用功能。</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">在某些情况下，您确实确实需要捕获任何异常。但是，在大多数情况下，这只是为了使您可以进行一些清理。您实际上对异常本身不感兴趣。例如，如果您打开一个文件然后要再次关闭它，则处理文件是正常执行还是引发异常。但是，在这些情况下，您可以使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 之类的函数，它们实际上不会向您传递异常，而只是在适当的位置调用清除函数。</target>
        </trans-unit>
        <trans-unit id="68320e8b907613c7782553698755865907bc858f" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">您可以使用几种不同的访问点来定义用于访问表示形式的插件。所有这些字段都接收使用 &lt;code&gt;-fplugin-opt&lt;/code&gt; 标志传递给编译器的 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串列表。</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">有几种不同类型的堆配置文件可以生成。所有不同的剖面图类型都会产生一个实时堆与时间的对比图,但它们在如何将实时堆分解成带状方面有所不同。下面的RTS选项可以选择使用哪种分解方式。</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获和检查异常有几种功能。所有这些都只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 内部使用。</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">有几个选项可让您精确控制垃圾回收。希望您在正常操作中不需要任何这些，但是为了达到最佳性能，可以进行一些调整。</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 还提供其他一些与Haskell和GHC相关的邮件列表。有关完整列表，&lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;请访问http://www.haskell.org/mailman/listinfo/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">对于存在量化的构造体的使用方式有几个限制。</target>
        </trans-unit>
        <trans-unit id="93f0614d42022b318b6c7e89cd2bff7336dde820" translate="yes" xml:space="preserve">
          <source>There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt;, &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">关于哪些数据类型可以派生 &lt;code&gt;Foldable&lt;/code&gt; 实例还有一些其他区别：</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">在某些其他情况下，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将无法编译：</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">对基元类型的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">对未装箱的元组的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">还有三个选项与堆剖析有关。</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">新增了三个关键字： &lt;code&gt;group&lt;/code&gt; ， &lt;code&gt;by&lt;/code&gt; 和 &lt;code&gt;using&lt;/code&gt; 。（ &lt;code&gt;sortWith&lt;/code&gt; 和 &lt;code&gt;groupWith&lt;/code&gt; 函数不是关键字；它们是 &lt;code&gt;GHC.Exts&lt;/code&gt; 导出的普通函数。）</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">有三种方法可以获得对当前调用栈的访问。</target>
        </trans-unit>
        <trans-unit id="18668df28a2960d99f735bbd24797ff6843bd893" translate="yes" xml:space="preserve">
          <source>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7482a52c288e2a6aa7c273bf0bcf1dbfeabe7e" translate="yes" xml:space="preserve">
          <source>There are two classes of event types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">特殊语法有两类。</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLL的使用有两种不同的方式。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">这一规则有两个例外。</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 还有两个其他重要属性：</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">这个解码器的执行方式有两种,分别是懒惰输入法和增量输入法。这里我们将使用懒惰输入法。</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">序列和列表之间有两大区别。</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">这个柜台有两件事可以做。</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">浏览命令有两种变体。</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">有两种方法可以使用这些实用工具。</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">有两种方法可以在多个处理器上运行程序：从程序中调用&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;或使用RTS&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="54084616a21d75658db0216e6ad990b71f0f3457" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">可以有任意多的文件头实用名,而且可以在它们的前面或后面加上注释。</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">关联类型同义词最多只能有一个默认声明。</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">可以对 &lt;code&gt;hs_init()&lt;/code&gt; 进行多次调用，但每个调用都应与对hs_exit（）的一个（只有一个）调用 &lt;code&gt;hs_exit()&lt;/code&gt; 。最外面的 &lt;code&gt;hs_exit()&lt;/code&gt; 实际上会取消初始化系统。请注意，当前GHC的运行时在发生这种情况后无法可靠地重新初始化。参见&lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;外部功能接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">只能有一个&amp;ldquo;细分&amp;rdquo;选项（例如，上例中的&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;），但是可以应用的进一步限制的数量没有限制。所有的选项可以合并，但有一个例外：GHC目前不支持混合&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">有一个默认值 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 应该用于初始化 &lt;code&gt;RtsConfig&lt;/code&gt; 类型的变量。毫无疑问，将来会有更多字段添加到 &lt;code&gt;RtsConfig&lt;/code&gt; ，因此，为了使您的代码向前兼容，最好使用 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 进行初始化，然后修改所需的字段，如上面的代码示例中所示。</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;上有关于编译安全性和一些潜在解决方案的更详细的讨论。</target>
        </trans-unit>
        <trans-unit id="7ef9b54093e73b5247e6192453bb1d4451bfc02a" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="566104a98981fe95741524bb050f2354c55f9f53" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">死锁检测和终结器（由 &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 或&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak中&lt;/a&gt;的函数创建）之间存在微妙的交互：如果某个线程在等待终结器运行时被阻塞，则该线程将被视为死锁并发送异常。因此最好不要这样做，但是如果没有其他选择，则可以通过使 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 指向该线程来防止该线程被视为死锁。不要忘了释放 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 与后来的 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">这里有额外的符号(借用GNU图标v)来指定如何处理非法字符。</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">有大量的Haskell民间艺术 &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;智能构造&lt;/a&gt;函数，从本质上讲，这些函数将验证包装在构造函数周围，并避免公开其表示形式。缺点是基础构造函数不能用作匹配器。模式同义词可以用作真正的智能构造函数，用于验证和匹配。</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">剖析本身有一个开销,由剖析器从驻留数据中减去。当然,在没有profiling支持的情况下,这个开销会消失。空间开销目前是每个堆对象多出2个字,大概会造成30%的开销。</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">当前不支持获取&amp;ldquo;堆栈跟踪&amp;rdquo;，但是跟踪和历史记录功能提供了有用的第二优功能，通常足以确定错误的上下文。例如，即使在编译后的代码中抛出异常，也可能自动中断该异常（请参阅&lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;调试异常&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">类型只有一个值 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; ，因此对它进行编码不需要任何知识，我们可以使用零位：</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有 &lt;code&gt;ZonedTime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例。如果要比较本地时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 。如果要比较绝对时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ed2f198aae585d94d8de2a49be348554775e93" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">没有 &lt;code&gt;deRefStableName&lt;/code&gt; 操作。您不能从一个稳定的名称返回到原始的Haskell对象。原因是对象的稳定名称的存在不能保证对象本身的存在。它仍然可以被垃圾收集。</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">与&lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;不同，没有 &lt;code&gt;freeStableName&lt;/code&gt; 操作。当不再需要稳定名称时，运行时系统将对其进行回收。</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; 或 &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 注释，因此标记为 &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">读取缓冲区没有相应的操作，因为在读取之前，客户端将始终调用 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">对新类型没有影响,只是对现有类型进行重命名。例如:</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">无法保证评估的顺序。该实现可以按任何顺序或并行评估结构的组件。要在评估征收的实际顺序，使用 &lt;code&gt;pseq&lt;/code&gt; 从&lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt;在 &lt;code&gt;parallel&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">无法保证延迟到期后将立即重新安排线程的运行时间，但是该线程将永远不会继续运行 &lt;em&gt;时间&lt;/em&gt;比指定的&lt;em&gt;早&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">无需列出所有源文件作为 &lt;code&gt;ghc -M&lt;/code&gt; 命令的参数。 &lt;code&gt;ghc&lt;/code&gt; 跟踪依赖项，就像 &lt;code&gt;ghc --make&lt;/code&gt; （GHC 6.4中的新功能）一样。</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有严格（ &lt;code&gt;!&lt;/code&gt; ）或惰性（ &lt;code&gt;~&lt;/code&gt; ）注释，因此将其标记为 &lt;code&gt;'NoSourceStrictness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">无法对 &lt;code&gt;Danger&lt;/code&gt; 可以导入的模块施加限制。这使 &lt;code&gt;Danger&lt;/code&gt; 的作者拥有很大的攻击面，基本上是系统上当前安装的任何软件包。如果这些软件包中的任何一个都有漏洞，则 &lt;code&gt;Danger&lt;/code&gt; 模块可以利用它。</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">除了初始数据外,没有办法提供更多的输入。要想以增量方式提供更多数据,请参见增量输入界面。</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">现在进出口清单中可能存在一些歧义；例如，如果您编写 &lt;code&gt;import M( (+) )&lt;/code&gt; ，是指&lt;em&gt;函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 还是&lt;em&gt;类型构造函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; ？默认值为前者，但是使用&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（由&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;隐含）GHC允许您通过在其前面加上关键字来指定后者 &lt;code&gt;type&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">有一个 &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 情况：reifyInstances''可键入的ty当前总是产生一个空列表（无论给出什么 &lt;code&gt;tys&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">此一般规则有一个例外：当使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;加载程序时，或在调用 &lt;code&gt;ghci&lt;/code&gt; 时指定程序时，可以提供文件名而不是模块名。该文件名（如果存在）将被加载，并且可能包含您喜欢的任何模块。如果您在同一目录中有多个 &lt;code&gt;Main&lt;/code&gt; 模块，而又不能全部调用它们 &lt;code&gt;Main.hs&lt;/code&gt; ,则这特别方便。</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">有一个特别棘手的案例,应该解释一下。</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">句法上的歧义有一个问题。请考虑:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="25f515351416a88c7165a7d23467301f2a1ae98e" translate="yes" xml:space="preserve">
          <source>There is room for extra information in the event type specification, which can be ignored by older tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCi加载前奏和标准库时，可能会停顿一会儿，然后显示提示。如横幅所示，您可以输入&lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;查看可用命令列表，以及每个命令的半行描述。我们将逐步解释所有这些命令，并且在&lt;a href=&quot;#ghci-commands&quot;&gt;GHCi命令中&lt;/a&gt;提供了所有命令的完整文档。</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">同一个键可能有多个弱指针。在这种情况下,每一个弱指针的定标器都会以某种任意的顺序运行,或者当键死亡时,可能会同时运行。如果程序员指定的定标器假定它拥有对一个对象的唯一引用(例如,它希望关闭的文件),那么程序员必须确保只有一个这样的定标器。</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">规则中可能有零个或多个&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;，并用分号分隔（可能由布局规则生成）。</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">令牌 &lt;code&gt;[quoter|&lt;/code&gt; 不能有空格。。</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如,我们可以定义这样的签名:</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如:</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">必须对类型族的方程进行一些限制,以免我们定义一个模糊的重写系统。所以,开放类型族的方程被限制为兼容。如果两个类型模式是兼容的</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">曾经有 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的另一种变体（即 &lt;code&gt;Par0&lt;/code&gt; ），但此后不推荐使用。</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;并发&lt;/em&gt;和&lt;em&gt;并行&lt;/em&gt;性之间有很好的区别：并行性就是使程序运行&lt;em&gt;得更快&lt;/em&gt;通过同时使用多个处理器来使。另一方面，并​​发是一种抽象手段：这是一种构造必须响应多个异步事件的程序的便捷方法。</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">有一个创建 &lt;code&gt;StablePtr&lt;/code&gt; 的特殊功能： &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; ，因为RTS需要一个到原始 &lt;code&gt;MVar#&lt;/code&gt; 对象的 &lt;code&gt;StablePtr&lt;/code&gt; ，而我们不能直接创建它。不要&lt;em&gt;不&lt;/em&gt;只是使用 &lt;code&gt;newStablePtr&lt;/code&gt; 的 &lt;code&gt;MVar&lt;/code&gt; &lt;em&gt;&lt;/em&gt;：你的程序会崩溃。</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">这里有一个例外：您可以使用Cygwin的外壳，如果 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量并&lt;em&gt;没有&lt;/em&gt;包含 &lt;code&gt;tty&lt;/code&gt; 。在这种模式下，Cygwin Shell的行为类似于Windows控制台Shell，并且控制台事件传播到子进程。注意，&lt;em&gt;在&lt;/em&gt;启动Cygwin shell &lt;em&gt;之前，&lt;/em&gt;必须先设置 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量。之后再更改它对外壳没有影响。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">使用外部库时，还需要牢记其他一点：如果该库包含 &lt;code&gt;main()&lt;/code&gt; 函数，则这将与GHC自己的 &lt;code&gt;main()&lt;/code&gt; 函数（例如 &lt;code&gt;libf2c&lt;/code&gt; 和 &lt;code&gt;libl&lt;/code&gt; 有自己 &lt;code&gt;main()&lt;/code&gt; 小号）。</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">有一个隐含的 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 系列函数之一的调用中，每个异常处理程序周围都有。这是因为这是您大多数时候想要的-它消除了启动异常处理程序时的常见竞争条件，因为如果一个人立即到达，则堆栈上可能没有异常处理程序来处理另一个异常。但是，如果异步异常在进入处理程序时被屏蔽，我们有时间在被中断之前安装新的异常处理程序。如果不是默认设置，则必须编写类似</target>
        </trans-unit>
        <trans-unit id="6b1f8f78c4b21b4ebde0207b0aeba4e07d56d547" translate="yes" xml:space="preserve">
          <source>Therefore, if we run GHC against the following code using the plugin from above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">这些 &lt;code&gt;Names&lt;/code&gt; 可用于构造Template Haskell表达式，模式，声明等。它们也可以作为 &lt;code&gt;reify&lt;/code&gt; 函数的参数提供。</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">这些RTS选项可用于（a）避免GHC错误，（b）看到&amp;ldquo;实际情况&amp;rdquo;，或（c）因为您喜欢它。不建议日常使用！</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">这些和许多其他示例在Honghong Xi和Tim Sheard的论文中给出。&lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;Wiki上&lt;/a&gt;有更长的介绍，以及Ralf Hinze的&amp;ldquo; &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;幻影类型&lt;/a&gt;的乐趣&amp;rdquo;。也有许多示例。请注意，论文使用的符号可能与GHC中实施的符号不同。</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">这些可用作 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">这些可从&lt;em&gt;Trustworthy&lt;/em&gt;模块中获得&lt;a href=&quot;data-coerce&quot;&gt; Data.Coerce&lt;/a&gt;中获得</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">这些是 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;newtype&lt;/code&gt; 声明的示例，其数据构造函数具有多态参数类型：</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">这些是程序编译后要运行的平台。</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">这些是GHC本身编译的平台。同样,这通常与构建和目标平台相同。</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">这些是程序构建的平台。(也就是GHC本身的目标平台。)通常这和目标平台是一样的。(如果是交叉编译的话,有可能是不同的。)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">这些属性的所有属性都是关闭的。</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">这些对于调查错误或性能问题很有用。他们应该&lt;em&gt;不是&lt;/em&gt;在生产代码中使用。</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">这些功能直接对应于 &lt;code&gt;cub&lt;/code&gt; ， &lt;code&gt;cud&lt;/code&gt; ， &lt;code&gt;cub1&lt;/code&gt; ， &lt;code&gt;cud1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">这些字符是:任何空格、单引号、双引号和反斜杠字符。反斜杠字符总是转义(即,不加考虑地通过)后面的字符。字符也可以通过引号在块中进行转义(即在块的周围用匹配的单引号或双引号对其进行转义)。</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;不是&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;商标&amp;rdquo;，什么不是&amp;ldquo;商标&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;数字&amp;rdquo;，什么不是数字。</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;标点符号&amp;rdquo;和什么不是&amp;ldquo;标点符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;分隔符&amp;rdquo;，什么不是&amp;ldquo;分隔符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是和不是&amp;ldquo;符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">需要这些类来表达对便携式Haskell中的转换器参数的约束。因此，对于一个新的转换器 &lt;code&gt;T&lt;/code&gt; ，可能会编写如下实例</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">考虑到这些因素,我们对孤儿模块的定义如下:</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">这些通过参数化确保。</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">这些事件&lt;em&gt;始终&lt;/em&gt;是GHC系统中的错误，请报告。</target>
        </trans-unit>
        <trans-unit id="588a8548c6363993d22d2b7e86c47e328069a514" translate="yes" xml:space="preserve">
          <source>These events are typically produced during program startup and describe the environment which the program is being run in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9e62a89c4ce54bd1d84649823a3e3080b1425a" translate="yes" xml:space="preserve">
          <source>These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;non-moving collection&lt;/code&gt;&lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">只要模块包含&amp;ldquo;孤立&amp;rdquo;实例声明或重写规则，这些标志就会发出警告。如果实例声明出现在模块中，而该实例或类都没有在同一模块中声明，则实例声明是孤立的。如果规则是另一个模块中声明的函数的规则，则它是孤立的。包含任何孤立对象的模块称为孤立模块。</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">这些标志从其他后端转储各种信息位。</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">这些标志从GHC的前端转储各种信息。这包括解析器和接口文件读取器。</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">这些标志从GHC的类型检查器和重命名器中转储各种信息。</target>
        </trans-unit>
        <trans-unit id="2dc9a8e0f094a600546405a33b0a5ef835899c04" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">这些标志转储GHC的C-\-管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">这些标志转储了GHC核心到核心管道的各个阶段。这从解糖器开始，包括简化程序，工作者包装程序转换，规则引擎，专家，严格性/出现率分析器以及常见的子表达式消除过程。</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">这些标志转储GHC STG管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="50fcdcd1fe44bc0c3ab929a2c58bbb80cb13f620" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">这些标志转储本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;管道的各个阶段，该管道以C-\-开头并生成本机汇编程序。</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">这些标志打开和关闭各个优化。默认情况下，标记为on的标志由 &lt;code&gt;-O&lt;/code&gt; 启用，因此您不需要显式设置任何标志。可以通过说 &lt;code&gt;-fno-wombat&lt;/code&gt; &lt;code&gt;-fwombat&lt;/code&gt; 否定标志-fwombat。</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">提供这些用于标准类型的格式化程序是为了方便编写新的特定于类型的格式化程序：一种常见的模式是抛出 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; 来对新类型进行大多数格式处理。</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">这四个属性保证了在安全语言中,你可以相信类型,可以相信模块导出列表会得到尊重,可以相信成功编译的代码与正常情况下的代码具有相同的意义。</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">这些功能也由&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出。</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">这些函数与其对应的 &lt;code&gt;CAString&lt;/code&gt; 不同，它们将使用由当前语言环境确定的编码，而不是始终采用ASCII。</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">这些函数是重载的,因为它们需要返回不同的结果,这取决于它们被实例化的类型。</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">当移位量大于机器Int#的位数大小时,这些函数未被定义。</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">这些函数在内部用于引发各种错误,并被导出供新的特定类型格式化器使用。</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">这些函数可用于组合新代数类型的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例。例如，给定定义</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">这些函数没有绑定一个多态变量,所以被接受。它们的多态性允许用户使用这些函数来方便地剔除那些返回非盒式类型的函数。</target>
        </trans-unit>
        <trans-unit id="044a64ee1e082d15f5fc359f3ff870486d8b309f" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">通过允许任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作作为终结器，这些函数在可移植的&lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt;模块中通用了它们的名称。这些终结器必须在单独的线程中运行，请参见。&lt;em&gt;析构&lt;/em&gt;&lt;em&gt;函数&lt;/em&gt;，&lt;em&gt;终结器和同步&lt;/em&gt;，作者：Hans Boehm，&lt;em&gt;POPL&lt;/em&gt;，2003年。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">这些函数从序列的左端或右端进行顺序搜索,返回匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">这些功能早于 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; ，后者更加灵活。</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">这些实例是兼容的，因为它们的隐式种类参数有所不同。第一个使用 &lt;code&gt;Type&lt;/code&gt; ，第二个使用 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">这些宏从GHC 7.10.1开始可用。</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">提供这些宏是为了比 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 提供更细的粒度。通常，这不是必需的，因为期望大多数API在补丁程序版本之间保持稳定，但是偶尔需要内部API更改才能修复错误。此外，在补丁程序级别上进行条件编译对于解决较旧版本中的错误也很有用。</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">在预处理Haskell源和C源（包括从Haskell模块生成的C源（即 &lt;code&gt;.hs&lt;/code&gt; ， &lt;code&gt;.lhs&lt;/code&gt; ， &lt;code&gt;.c&lt;/code&gt; )时，会设置这些宏。和 &lt;code&gt;.hc&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">这些模块在导入时要有限定条件,以避免与Prelude函数的名称冲突,例如:。</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">这些操作分别返回 &lt;code&gt;0#&lt;/code&gt; 和 &lt;code&gt;1#&lt;/code&gt; ,而不是 &lt;code&gt;False&lt;/code&gt; 和 &lt;code&gt;True&lt;/code&gt; 。看到&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;&lt;/a&gt;更多详细信息， PrimBool Wiki页面。</target>
        </trans-unit>
        <trans-unit id="b7ccd9c5b4911eda91ad51529b53aa771bb31514" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">这些选项在&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;中进行了详细描述。如果一个标志由 &lt;code&gt;-O&lt;/code&gt; 隐含，那么它也由 &lt;code&gt;-O2&lt;/code&gt; 隐含（除非标志说明另有明确说明）。如果仅 &lt;code&gt;-O0&lt;/code&gt; 隐含标志，则 &lt;code&gt;-O&lt;/code&gt; 和-O不隐含该标志。 &lt;code&gt;-O2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">这些选项在以下内容中有更详细的描述 &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;优化（代码改进）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">这些选项控制哪些警告被认为是致命的,并导致编译中止。</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">这些选项产生运行时系统统计信息，例如执行程序和在垃圾回收器中花费的时间，分配的内存量，堆的最大大小等。这三个变体提供不同的详细程度： &lt;code&gt;-T&lt;/code&gt; 收集数据但不产生输出 &lt;code&gt;-t&lt;/code&gt; 产生与GHC的 &lt;code&gt;-Rghc-timing&lt;/code&gt; 选项相同格式的单行输出， &lt;code&gt;-s&lt;/code&gt; 在结束时产生更详细的摘要程序和线程化的运行时将导致详细的摘要包括运行期间累积的各种内部计数；请注意，这些是未指定的，并且可能在发行版之间进行更改。 &lt;code&gt;-S&lt;/code&gt; 还会生成有关每个垃圾收集的信息。通过 &lt;code&gt;--internal-counters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;ByteString&lt;/code&gt; 打包到另一个构造函数中后，这些开销都可以减少1个字（4或8个字节）。</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">这些论文和有关箭头的更多信息可以在&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些模式仅在GHC 8.0或更高版本中可用，而8.2版更适用于它们。当近期这些版本GHC的文字，图案可以代替使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">这些可能重叠，但是无论标志设置如何，GHC都不会抱怨实例声明本身。如果我们以后尝试解决约束 &lt;code&gt;(C Int Char)&lt;/code&gt; ,则只有第一个实例匹配，并且一切都很好。与 &lt;code&gt;(C Bool Bool)&lt;/code&gt; 相似。但是，如果我们尝试解决 &lt;code&gt;(C Int Bool)&lt;/code&gt; ，则两个实例都匹配，并且会报告错误。</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">这些实用名词控制着函数定义的内联。</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">这些限制很容易验证，并确保终止类型推断。但是，在存在所谓的&amp;ldquo;循环等式&amp;rdquo;（例如 &lt;code&gt;a ~ [F a]&lt;/code&gt; 的情况下，它们不足以保证类型推断的完整性，在这种情况下，类型变量的递归出现在族应用程序的下方，并且数据构造器应用程序-有关详细信息，请参见上述文章。</target>
        </trans-unit>
        <trans-unit id="9f701b27c6f77c55b38a0a5e6d91357571f66567" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">这些限制确保实例解析终止：每个简化步骤至少使一个构造函数使问题变小。您可以在论文中&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;通过约束处理规则了解功能依赖性&lt;/a&gt;找到许多背景材料，以了解这些限制的原因。。</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">这些规则将记录通配符限制在用户可以编写扩展版本的情况下。例如</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">这些类型对于实现处理可变数量的参数 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 是必需的。从模块中看不到它们的实现。如果您尝试将不是该适当类的实例的类型的参数传递给 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; ，则编译器会将其报告为缺少的 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例。 （所有 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例都是 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">为了访问Haskell中的C库接口，需要使用这些类型来精确表示C函数原型。 Haskell系统不需要完全像C那样表示这些类型，但是对于表示C类型 &lt;code&gt;t&lt;/code&gt; 的Haskell类型 &lt;code&gt;CT&lt;/code&gt; 提供了以下保证：</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 第 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，和是的情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 。这是否意味着 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; 的（分别 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; 的的）情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的行为（分别为 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ）一样糟糕。</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 基本外交类型的S，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 的种S &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;和&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">上述函数的这些变体用于不懂Unicode的C库。这些函数的使用应谨慎,因为可能会造成信息丢失。</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">以上函数的这些变体用于与C语言库有关的C库，这些C库使用C &lt;code&gt;wchar_t&lt;/code&gt; 类型以依赖于系统的方式对Unicode进行编码。支持的唯一编码是</target>
        </trans-unit>
        <trans-unit id="d4df89c18ae8de17d49ca0683c16ba6bdd50a129" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">他们告诉 &lt;code&gt;make&lt;/code&gt; ，如果有任何的 &lt;code&gt;Foo.o&lt;/code&gt; ， &lt;code&gt;Foo.hc&lt;/code&gt; 或 &lt;code&gt;Foo.s&lt;/code&gt; 有较早的修改日期比 &lt;code&gt;Baz.hi&lt;/code&gt; ，再出过期的文件必须予以更新。为了把它最新的， &lt;code&gt;make&lt;/code&gt; 寻找一个规则来做到这一点; 前面的后缀规则之一可以很好地完成这项工作。这些依赖可以由 &lt;code&gt;ghc&lt;/code&gt; 自动生成；请参阅&lt;a href=&quot;#makefile-dependencies&quot;&gt;依赖项生成&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">它们在Simon Peyton Jones，Andrew Gordon和Sigbjorn Finne 的论文&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&amp;ldquo; Concurrent Haskell&amp;rdquo;中&lt;/a&gt;进行了介绍，尽管此后其实现的某些细节已发生了变化（特别是用于错误的完整 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的外观，但现在仅是块状）。 ）</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">需要注意的事项:</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">这个&amp;ldquo;功能&amp;rdquo;与 &lt;code&gt;unsafePerformIO&lt;/code&gt; 有表面上的相似之处，但实际上它是混乱的恶毒代理。它揭开了现实的接缝（以及 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad），使常规规则不再适用。它使您认为它是合理的，但是当您不看它时，它会刺伤您的背部，并为所有可变缓冲区起别名。许多经验丰富的Haskell程序员的尸体散落在其脚下。</target>
        </trans-unit>
        <trans-unit id="4c6dd831f46ec853aa8fce97c6a2a27a512463cc" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">此&amp;ldquo;功能&amp;rdquo;可能违反直觉： &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; 将把中间C代码放入文件 &lt;code&gt;foo.o&lt;/code&gt; 中。，尽管名称！</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">这个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 在对字符串进行模式匹配时，使用相等谓词。</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="c332f21db0753a9ce2e0bf5358f7f0659bb25726" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">可以将此 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 扩展为默认提供的格式类型以外的其他格式。这是通过实例化 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 并为该类型提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 来完成的。可以提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 来处理特定于类型的修饰符，但是默认实例通常是最佳选择。</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">这种缩写使顶层申报片更安静、更不吓人。</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">这个抽象的数据类型表示解析错误消息。有四种消息。</target>
        </trans-unit>
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">这将调整所有列号,从42开始。这个参数的存在只影响诊断的质量,并不改变代码本身的语法。</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">这允许通过指定另一种相等的运行时表示形式来 &lt;code&gt;deriving&lt;/code&gt; 类型的类实例（例如，在两者之间存在一个 &lt;code&gt;Coercible&lt;/code&gt; 实例：请参阅&lt;a href=&quot;#coercible&quot;&gt;Coercible约束&lt;/a&gt;），该已经是这个类的一个实例。</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">这允许具有指定字段的记录类型具有多态的定义。例如，以下内容适用于任何具有字段 &lt;code&gt;name :: String&lt;/code&gt; 记录类型：</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">这允许你写更短的签名。</target>
        </trans-unit>
        <trans-unit id="e8a1d903f792395fe48e068f8423dc24b82157d5" translate="yes" xml:space="preserve">
          <source>This also applies to GADT-style data instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">这假定库 &lt;code&gt;libfoo.so&lt;/code&gt; 位于当前目录中，并且一旦部署了程序，便可以在与可执行文件 &lt;code&gt;main&lt;/code&gt; 所在的目录中找到该库。同样，可以使用相对于可执行文件的子目录，例如 &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61fe3a7a67ef0295ed3b813ce3259d063c2d2b72" translate="yes" xml:space="preserve">
          <source>This avoid generating Typeable-related bindings for modules and types. This is useful when debugging because it gives smaller modules and dumps, but the compiler will panic if you try to use Typeable instances of things that you built with this flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f906decfdad529805a16ffec27620b40f24764" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9638426e03b58cbb0b8529e91d4b2a020cb1636d" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">表现为 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; ，除了始终保证小数点（即使不需要）外。</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">这种行为不同于GHC内置的Ctrl-C处理方式,它可能在用户第二次按下Ctrl-C后立即终止程序。</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">这种行为对大多数应用来说应该是足够的。</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">这种行为取决于一个键的可到达性是什么意思。在非正式的情况下,如果某个东西可以通过根集的普通指针到达,但不能通过弱指针到达,那么它就是可到达的。我们将可到达性更精确地定义如下。</target>
        </trans-unit>
        <trans-unit id="6b2b05c125a4021b12f162035f98b456ef9c82e9" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt;&lt;code&gt;NondecreasingIndentation&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">此行为由 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 扩展控制。</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">当设置了 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; = True选项时，此行为由 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; ）实现。特别是， &lt;code&gt;SIGINT&lt;/code&gt; 信号将被忽略，直到 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 返回（或 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 返回非Nothing结果）为止，因此对每个创建的进程使用 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 变得尤为重要。</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">在控制评估顺序时，此行为有时很有用。值得注意的是，在 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 的库定义中使用了 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">这些都可以用一个小脚本来封装。</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">这可以用以下方法编译和运行。</target>
        </trans-unit>
        <trans-unit id="f7e5132d5805fa0f4b66063054f14a1690215ca6" translate="yes" xml:space="preserve">
          <source>This can be exponential in the arity of the pattern and in the number of guards in some cases. The &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt;&lt;/a&gt; limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46a06f859ec4216c3665e278e7c6dd66a8347dc" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly quantifying over &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">这对于调试特别有用：如果您的程序抱怨出现 &lt;code&gt;head []&lt;/code&gt; 错误，并且您不知道是哪段代码引起它， &lt;code&gt;-prof -fprof-auto&lt;/code&gt; 使用-prof -fprof-auto（请参阅&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;）进行编译并运行使用 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; 将在发生错误时准确地告诉您调用堆栈。</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">例如,这可以用来重新定位标准手柄。</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">当你知道被审查的表达式没有非底值时,这就很有用。例如</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">当数值数据类型的正负范围不匹配时，这可能会有所不同。例如，在8位算术中，-128是可表示的，但+128不是。因此 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 将引发意外的整数字面溢出消息。</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的背景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的前景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">如果你有一个包含Template Haskell代码的多模块程序,并且你需要编译它进行剖析,这就会造成困难,因为GHC不能加载剖析过的对象代码并在执行拼接时使用它。</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">此更改仅适用于主模块。无论 &lt;code&gt;-main-is&lt;/code&gt; 标志如何，其他模块仍将从默认的导出列表中导出 &lt;code&gt;main&lt;/code&gt; 。这允许将 &lt;code&gt;-main-is&lt;/code&gt; 与通过默认导出列表导出 &lt;code&gt;main&lt;/code&gt; 的现有模块一起使用，即使 &lt;code&gt;-main-is&lt;/code&gt; 指向不同的入口点（如本示例中所述）（与 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 编译）也是如此。</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">此类包含一些类型，您可以从&lt;em&gt;术语中&lt;/em&gt;包含的信息中学习两种类型的相等性。通常，只有单例类型可以居住在此类中。</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">这个类给出了与类型级自然相关的整数。每一个具体的文字都有这个类的实例:0,1,2,等等。</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">这个类给出了与类型级符号相关联的字符串。每一个具体的文字符号都有该类的实例。&quot;hello&quot;,等等。</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">这个类是作为缺乏FlexibleInstances的Haskell98兼容的变通方法而需要的。</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">此类在GHC和Hugs支持的递归 &lt;code&gt;do&lt;/code&gt; 表示法的翻译中使用。</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">该类仅具有一个实例，被用作一种变通方法，以解决 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 作为具体类型不允许作为typeclass实例的事实。导出 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">这个代码片段应该引起一个致命的错误,但它没有。</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3494ba5905a6ab7393145cd907a3ba47ca64dbf3" translate="yes" xml:space="preserve">
          <source>This code is in the style of both transformers and mtl, and is compatible with them, though doesn't mimic the module structure or offer the complete range of features in those packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该组合器实现选择。解析器 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 首先应用 &lt;code&gt;p&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;p&lt;/code&gt; 的值。如果 &lt;code&gt;p&lt;/code&gt; 失败&lt;em&gt;而不消耗任何输入&lt;/em&gt;，则尝试解析器 &lt;code&gt;q&lt;/code&gt; 。此组合子被定义等于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 所述的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类和（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">即使通过管道而不是通过适当的终端进行交互，此命令也允许从GHCi请求命令完成，并且该命令旨在将GHCi的完成与文本编辑器和IDE集成在一起。</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">这条命令对于高亮显示和导航编辑器和IDE中标识符的所有用途非常有用。</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个goto-definition设施。</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个show-type-under-point设施。</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">由于以下 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 异常之一，此计算可能会失败：</target>
        </trans-unit>
        <trans-unit id="3a53acc002bbe269420ba165928d4d81ea8f10ab" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">这个计算可能会失败,因为:</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">这涉及到外部呼叫与 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 的交互。通常，当外部调用涉及 &lt;code&gt;throwTo&lt;/code&gt; 的目标时，在调用返回之前不会引发异常，与此同时，调用者也将被阻止。这可能会导致无响应，这在用户中断（例如Control-C）的情况下尤其不希望出现。当收到Control-C信号时（在Unix上为 &lt;code&gt;SIGINT&lt;/code&gt; ），默认行为是在主线程中引发 &lt;code&gt;UserInterrupt&lt;/code&gt; 异常；如果此时主线程在外部调用中被阻塞，则程序将不会响应用户中断。</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">这个条件不被类型检查。您必须确保所提供的值是自己有效的总订单。</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">这将转换一个字符串,但保留了不可换行的空格,并在输入列表中的每个字符串之间添加换行符。</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">这将转换一个字符串,但保留了不可断行的空格。</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">这对应于 &lt;code&gt;base&lt;/code&gt; 的&lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt;模块提供的 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="b849491aac2caa06d22e6da0aa56daf804da18ae" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">目前,这使</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">这种数据类型表示一个等价关系。</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">此数据类型指定可处理类型为 &lt;code&gt;a&lt;/code&gt; 的值的运算符。运算符可以是二进制中缀，也可以是一元前缀或后缀。二元运算符也具有关联性。</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">此数据类型指定运算符的关联性:左、右或无。</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">此数据类型见证了 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 向点 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 的提升。</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">数据类型 &lt;code&gt;G&lt;/code&gt; 的类型和类型均类似于GADT。假设您有 &lt;code&gt;g :: G a&lt;/code&gt; ，其中 &lt;code&gt;a :: k&lt;/code&gt; 。然后，模式匹配，以发现 &lt;code&gt;g&lt;/code&gt; 其实 &lt;code&gt;GMaybe&lt;/code&gt; 告诉你们的是 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 和 &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; 的定义要求&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;有效，但是 &lt;code&gt;G&lt;/code&gt; 上的模式匹配不需要扩展到&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;之外。这项工作实际上是常规GADT的直接扩展，并且是种类和类型相同的事实的结果。</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">此数据类型作为用于缓冲器逐缓冲器执行的共同界面 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 。该接口的典型用户是 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 或iteratee风格的库，例如 &lt;code&gt;enumerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">这个解码器的缺点是,它需要在返回之前读取所有的输入。另一方面,它不会返回任何东西,直到它知道它可以在没有任何解码器错误的情况下进行解码。</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">该定义允许基于操作系统的条件编译，其中&amp;ldquo; os&amp;rdquo;是当前操作系统的名称（例如 &lt;code&gt;linux&lt;/code&gt; ，Windows的 &lt;code&gt;mingw32&lt;/code&gt; ， &lt;code&gt;solaris&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">此定义允许基于主机体系结构进行条件编译，其中&amp;ldquo; arch&amp;rdquo;是当前体系结构的名称（例如 &lt;code&gt;i386&lt;/code&gt; ， &lt;code&gt;x86_64&lt;/code&gt; ， &lt;code&gt;powerpc&lt;/code&gt; ， &lt;code&gt;sparc&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">这个定义使 &lt;code&gt;f1&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 中严格，而如果没有爆炸声，它将是懒惰的。爆炸模式当然可以嵌套：</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">这表示在其中派生上下文的派生 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 实例，其方式与普通 &lt;code&gt;deriving&lt;/code&gt; 子句相同。禁止在独立 &lt;code&gt;deriving&lt;/code&gt; 声明中使用通配符。</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">这种设计使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的实现可以完全访问 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad。因此，必须 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 小心，不要覆盖给定BufferRange之外的任何内容。此外，还必须格外小心，以确保 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 是参照透明的。请参阅 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 的注释并 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 函数以获取更多信息。请注意，使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 时&lt;em&gt;根本没有安全带&lt;/em&gt;：您正在编写代码，可能会在Haskell服务器上启用下一个缓冲区溢出攻击！</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">由于&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 的&lt;/a&gt;工作方式，这种区别很重要。派生的 &lt;code&gt;Functor Right&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="35e478384f40b7a1e661dbe9f918af72fd276223" translate="yes" xml:space="preserve">
          <source>This distinction is only meaningful for monads which have multiple exit points, such as &lt;code&gt;Except&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt;. For monads that only have a single exit point, there is no difference between &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; has a more constrained type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">这不会嵌入任何运行时路径。它依赖于共享库在标准位置或 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量给定的目录中可用。</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">这不再起作用了。假设模块 &lt;code&gt;C&lt;/code&gt; 进口模块 &lt;code&gt;B&lt;/code&gt; ，和 &lt;code&gt;B&lt;/code&gt; 进口模块 &lt;code&gt;A&lt;/code&gt; 。因此，对模块 &lt;code&gt;A&lt;/code&gt; 的更改可能需要重新编译模块 &lt;code&gt;C&lt;/code&gt; ，因此，在 &lt;code&gt;A.hi&lt;/code&gt; 更改时，我们应检查是否应重新编译 &lt;code&gt;C&lt;/code&gt; 。但是， &lt;code&gt;C&lt;/code&gt; 的依存关系只会列出 &lt;code&gt;B.hi&lt;/code&gt; ，而不 &lt;code&gt;A.hi&lt;/code&gt; ，并且可以想到，对 &lt;code&gt;A&lt;/code&gt; 的某些更改（更改出现在 &lt;code&gt;B&lt;/code&gt; 导出的函数的内联中的函数的定义）可能不会更改 &lt;code&gt;B.hi&lt;/code&gt; 一个记号。所以现在</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">由于变量 &lt;code&gt;x&lt;/code&gt; 具有表示多态类型，因此消除了 &lt;code&gt;bad&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">这样就可以在代码生成器的汇编阶段实现快捷化。简单来说,捷径的意思是,如果一个指令块A只由一个无条件跳转组成,我们就用跳转到A的后继者来代替所有对A的跳转。</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">这种编码在任何一个方向上都不会失败。但是,编码会丢弃信息,所以编码之后的解码不是身份。</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">该编码使用字节序列 &quot;xc0x80 &quot;表示NUL,字符串以NUL结尾。</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用双折前的每一步之前将其强制转换为弱头正常形态，避免了否则会发生的团块聚集。这通常是您要严格将有限结构简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">这个错误信息。</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">这样可以确定模块是受信任的，但是保证由模块的作者提供。然后，该模块的客户端通过指定他们信任包含该模块的程序包来指定他们信任该模块的作者。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;并不将模块限制在安全语言范围内。但是，它确实限制了重叠实例的分辨率，只允许&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全重叠实例&lt;/a&gt;。它还允许使用安全导入关键字。</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">这个例子让我们了解了转义延续的工作原理,展示了它们的典型使用模式。</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">这个例子是一个缩减版的,在</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">如果直接使用 &lt;code&gt;Type&lt;/code&gt; 构造函数，则此示例等效于复杂得多的构造。</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">此示例仅需要 &lt;code&gt;Functor&lt;/code&gt; ，因为它被转换为 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 。一个更复杂的示例需要 &lt;code&gt;Applicative&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">本例使用 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 的Microsoft Word的功能，但提供 &lt;code&gt;HsStart&lt;/code&gt; 是第一个函数之前调用， &lt;code&gt;HsEnd&lt;/code&gt; 在最后，那么它会正常工作。</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此示例改编自原始的Concurrent Haskell论文。有关用于构建高级同步原语的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的更多示例，请参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">此异常不适用于语句，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">另一个调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 的线程会引发此异常，如果系统由于某种原因需要终止该线程，则会引发该异常。</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">当用户通过通常的机制(例如控制台中的Control-C)请求终止程序时,程序的主线程会默认引发这个异常。</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">此扩展允许程序员使用列表符号构造结构，例如： &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;IntMap&lt;/code&gt; ， &lt;code&gt;Vector&lt;/code&gt; ， &lt;code&gt;Text&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; 。下面的代码清单给出了一些示例：</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">此扩展名使我们可以编写形式为 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 约束。Eq b =&amp;gt; Eq（fb），这是解决因 &lt;code&gt;(==)&lt;/code&gt; 方法的第二次使用而引起的 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 约束所必需的。</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">此扩展还可以显式量化&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;，&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;，&lt;a href=&quot;#closed-type-families&quot;&gt;封闭类型系列&lt;/a&gt;，&lt;a href=&quot;#assoc-inst&quot;&gt;关联实例&lt;/a&gt;和&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则中&lt;/a&gt;的类型和种类变量。</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">该扩展可以在以下地方进行种类签名:</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">此扩展概括了&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;。要使用GND 派生 &lt;code&gt;Num Unicode&lt;/code&gt; （ &lt;code&gt;deriving newtype Num&lt;/code&gt; ），它必须重用 &lt;code&gt;Num Int&lt;/code&gt; 实例。使用 &lt;code&gt;DerivingVia&lt;/code&gt; ，我们可以显式指定表示类型 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">自GHC 8.6.1起，在&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail提案（MFP）&lt;/a&gt;下默认启用此扩展。</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">这个扩展是暂时的,并将在未来的版本中被废弃。</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">这个功能在GHC 8.0.x中是试验性的,但在未来的版本中可能会成为默认的。</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">这个功能在GHC中已经没有了,但是重写规则可以让你做同样的事情。</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">此功能不适用于GHC随附的核心库之外。有关更多详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC开发人员Wiki&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ee160906b857c67fe57bb11a964fcfc779b0e3a" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">这个功能是在GHC 7.4.1中加入的。</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">此标志还允许在括号内打印&lt;em&gt;推断的&lt;/em&gt;类型变量。请参阅&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;推断类型变量与指定类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">该标志将以冒号分隔的 &lt;code&gt;dirs&lt;/code&gt; 列表附加到搜索路径。</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">这个标志可以被启用,以覆盖模块的任何声明的安全属性(Safe,Unsafe,Trustworthy),这样编译就会像没有指定这些标志一样进行。这在使用插件编译时特别有用,因为这通常会导致编译后的模块被标记为不安全。</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">这个标志可以被切换,通过不显示建议的出处或类型应用来降低有效孔配合建议的啰嗦程度。</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">这个标志可以被切换到完全关闭有效孔配合的显示。</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">该标志暗示&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志，这使&lt;a href=&quot;#typed-holes&quot;&gt;键入孔&lt;/a&gt;和变量具有此行为。如果您愿意，可以通过显式指定&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;来启用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;而不启用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;-fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;标志后，在命令行上将-defer-out-of-scope-variables放在命令行上。</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">该标志是黑客的领土。该标志的主要目的是使调试和调试新代码布局算法变得容易。无法保证在下一个发行版中提供更好结果的值现在不会变差。</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">这个标志对于调试为什么定义没有内联很有用。</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">该标志对于调试为什么不希望触发的规则很有用。</target>
        </trans-unit>
        <trans-unit id="913346e87539751c35ed9c7fbbe9dacd336e394e" translate="yes" xml:space="preserve">
          <source>This flag offers a workaround, albeit a slightly convoluted one. To be able to load an object file outside of the low 2Gb, the object code needs to be compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt;. When the &lt;code&gt;+RTS -xp&lt;/code&gt; flag is passed, the linker will assume that all object files were compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and load them anywhere in the address space. It&amp;rsquo;s up to you to arrange that the object files you load (including all packages) were compiled in the right way. If this is not the case for an object, the linker will probably fail with an error message when the problem is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">该标志将 &lt;code&gt;-Wundef&lt;/code&gt; 传递给C预处理器（如果正在使用它），这会导致预处理器警告在未定义标识符上使用 &lt;code&gt;#if&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">该标志选择多种模式之一，以在运行时查找共享库。有关每种模式的说明，请参见&lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;在运行时查找共享库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="707ef7038c152a9d95c30f93e519ab392f0434e0" translate="yes" xml:space="preserve">
          <source>This flag sets the size (in bytes) threshold above which the second approach is used. You can disable the second approach entirely by setting the threshold to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">这个标志指定在第0列的退格将光标包到前一行的最后一列。</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">这个标志指定光标从一行的最后一列自动缠绕到下一行的第一列。</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">当可能导致环绕的字符是控制字符时，此标志指定终端不执行 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; 样式的环绕。这也称为&amp;ldquo;换行故障&amp;rdquo;或&amp;ldquo;魔术包&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">该标志告诉GHC链接共享的Haskell库。该标志仅影响选择依赖库，而不影响当前目标的形式（请参见-shared）。有关如何创建&lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;共享库的信息&lt;/a&gt;，请参见使用共享库。</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">该标志以前只是 &lt;code&gt;-k&lt;/code&gt; ，但在GHC 7.2.1中被重命名为 &lt;code&gt;-ki&lt;/code&gt; 。为了向后兼容，仍接受旧名称，但将来的版本中可能会删除该旧名称。</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">如果您声明一个模块而没有声明一个显式的导出列表,这个标志会发出警告。例如</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">如果您使用不显式列出带入范围的实体的不合格 &lt;code&gt;import&lt;/code&gt; 声明，则该标志会发出警告。例如</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">每当您编写一个模式来绑定一个类型不为实的变量时，该标志都会发出警告，但该模式既不是爆炸模式也不是裸变量。有关未&lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;提升类型&lt;/a&gt;的信息，请参见未装箱类型。</target>
        </trans-unit>
        <trans-unit id="cae0b42613ae5635daabfb73c1fd1a6fde87c094" translate="yes" xml:space="preserve">
          <source>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">该表格旨在解决那些被标记为 &lt;code&gt;INLINABLE&lt;/code&gt; （可能启用专门化）的导入函数无法专门化的情况，因为它调用了本身未专门化的其他函数。</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">这种形式类似于前一种形式，但是允许您创建一个函数，该函数将作为第一个参数传递给f。因此，f必须具有所有类型 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 。从类型可以看到，此函数使f从正在转换的列表元素中&amp;ldquo;投影&amp;rdquo;一些信息。</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">此函数接受可选的前导符号字符，后接至少一个十进制数字。语法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 函数接受的语法，但末尾带有 &lt;code&gt;'.'&lt;/code&gt; 或&lt;em&gt;不&lt;/em&gt;加数字的 &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;不会&lt;/em&gt;被使用。</target>
        </trans-unit>
        <trans-unit id="5f4a157f15275b0104f4661492b13677fdbb6264" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 中。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的 &lt;code&gt;ForeignPtr&lt;/code&gt; 中。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的异物。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">使用线程的RTS时，此函数始终 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回当前线程的事件管理器，否则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">这个函数的行为就像它的定义一样。</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">此函数的行为与 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; 完全相同，只是它会预先填充输入区域。驻留在输入区域中的文本以带有两个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的2元组给出。元组左侧的字符串（通过调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; 获得）将显示在游标的左侧，而右侧的字符串（通过调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; 获得）将显示在游标的右侧。</target>
        </trans-unit>
        <trans-unit id="1e7f64006d44420f7d5449007f9ad343dd8f086e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">这个函数只有在没有数据可用,并且尚未达到EOF时才会阻塞。一旦达到EOF,这个函数将返回一个空字符串,而不是抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">该函数比 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 更具可预测性，尤其是在文件名本身可能包含的情况下 &lt;code&gt;.&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">该函数比 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 更具可预测性，尤其是在文件名本身可能包含的情况下 &lt;code&gt;.&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">这个函数可以用来解析命令行参数,并将拆分后的参数作为列表中的元素返回。</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">此函数执行零复制，并且仅将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 展开以显示为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 。这有两种方式是&lt;em&gt;不安全的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">此函数执行零复制，并且仅将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 展开以显示为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 。这是&lt;em&gt;不安全的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="a47c3f2d7d39a2c3b063895b58a717924193e65c" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7536fe5974322621a8dd1f75ea634bfbda36cef" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="826e259566faf8425ada2d502fd2ea8be00aa816" translate="yes" xml:space="preserve">
          <source>This function exists because in order to thread their effects through the execution of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, monad transformers need values to be threaded from &lt;code&gt;use&lt;/code&gt; to &lt;code&gt;release&lt;/code&gt; and from &lt;code&gt;release&lt;/code&gt; to the output value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">此函数提取外部指针的指针组件。这是一个潜在的危险操作，好像 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 的参数是给定外来指针的最后一次使用，则将运行其终结器，这可能会使刚获得的普通指针无效。因此，必须在必须保证指针位于其上的任何地方（即发生另一次使用情况） &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 必须使用touchForeignPtr。</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">此函数提取外部指针的指针组件。这是一个潜在的危险操作，好像 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 的参数是给定外来指针的最后一次使用，则将运行其终结器，这可能会使刚获得的普通指针无效。因此，必须在必须保证指针位于其上的任何地方（即发生另一次使用情况） &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 必须使用touchForeignPtr。</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">此功能给出的答案与将结果与 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 结果进行比较的结果相同，但是如果字符数大于数字，则可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">该函数给出的答案与将其与 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; 的结果进行比较的结果相同，但是如果字符数大于数字或流的长度不能与所提供的数字一样长，则该函数可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">此功能给出的答案与将结果与 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 结果进行比较的结果相同，但是如果字符数大于数字，则可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">此功能已在&lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt;模块中使用了一段时间，并且自1.2.1.0版以来是&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;模块的一部分。</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已移至 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已移至 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">此功能有两种方式&lt;em&gt;不安全&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">此函数是&lt;em&gt;不安全的&lt;/em&gt;，因为可能还有其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 引用相同的基础页面。如果使用此方法，则需要某种证明，即从基础字节数组生成的所有 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 都不再有效。</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数&lt;em&gt;不安全&lt;/em&gt;，可以通过修改第一个参数指向的基础缓冲区来破坏引用透明性。对原始缓冲区的任何更改都将反映在结果 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果稍后修改了 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="1834d9d84b56bb752c51f02a1d644b2b93d96323" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果后来修改了原始 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果后来修改了原始的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="f349071f25d8991d866f99530006dd7090d11a0c" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b49b304d9d1b37bde4bfa9bfeb7383e8f4a58d" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果修改原始 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 指向的缓冲区，则此修改将反映在生成的 &lt;code&gt;ByteString&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="ce62a4da0ca7ff6594e5735e96a49ced57bae709" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">此功能几乎与 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 相同。唯一的区别是：</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">如果您两次调用它的终结器，则该函数也是不安全的，这将导致&lt;em&gt;双重释放&lt;/em&gt;错误，或者如果将其传递给未分配 &lt;code&gt;malloc&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则该函数也不安全。</target>
        </trans-unit>
        <trans-unit id="725d98580cd2d533b5eb08b0b83d5983bcb4d0b9" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用文件 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用文件 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">此函数等效于 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 连接到终端并启用了回显，则它将使用终端样式的交互。否则（例如，如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 是管道），它将使用文件样式的交互。</target>
        </trans-unit>
        <trans-unit id="925f47def99f594f17042330b2cb3a4074f9cfdc" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">这个函数与普通的unsafeInterleaveST相同,但是是内联的,因此速度更快。</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">尽管此函数的代码量很大，但仍可以内联，以与分配策略融合。例如，默认的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行函数 &lt;code&gt;toLazyByteString&lt;/code&gt; 定义如下。</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">尽管此函数的代码量很大，但仍可以内联，以与分配策略融合。例如，默认的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行函数 &lt;code&gt;toLazyByteString&lt;/code&gt; 定义如下。</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">这个函数主要用于执行无大小写(也称为不区分大小写)的字符串比较。</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">这个函数主要用于执行无大小写(或不区分大小写)的字符串比较。</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">该功能旨在从任何应用程序级清除处理程序中调用。它终止进程，并关闭所有 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">此功能比 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 更有效。toLazyByteString，因为在许多情况下无需进行缓冲区分配。此外，short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的几次执行结果都被合并在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的缓冲区中，因此避免了不必要的缓冲区刷新。</target>
        </trans-unit>
        <trans-unit id="af91de3226aaac03a1110fced423ab247dd1f835" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">此函数通常用于使用 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类中的操作将数据编组到 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 指向的对象或从该对象编入数据。</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">此函数通常用于使用 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类中的操作将数据编组到 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 指向的对象或从该对象编入数据。</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">仅当 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; 和 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 时才定义此函数（注意：文档声称仅支持 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; ，但是实际实现最多支持base 256）。</target>
        </trans-unit>
        <trans-unit id="1f0db6399242ab25312fe9ac2fbde674ee7aa2e5" translate="yes" xml:space="preserve">
          <source>This function is runtime-representation polymorphic, but the &lt;code&gt;RuntimeRep&lt;/code&gt; type argument is marked as &lt;code&gt;Inferred&lt;/code&gt;, meaning that it is not available for visible type application. This means the typechecker will accept &lt;code&gt;coerce @Int @Age 42&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配内存块。</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配内存块。</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证内存块由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证内存块由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; ，不同之处在于，它使用内部优化的，不带终结器的ForeignPtr表示形式。尝试添加终结器将引发异常。</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">此函数与 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 相似，除了使用内部优化的，不带终结器的ForeignPtr表示形式。尝试添加终结器将引发异常。</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; ，不同之处在于，所需内存的大小和对齐方式以字节数形式明确给出。</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">该功能在 &lt;code&gt;needle&lt;/code&gt; 很严格，在 &lt;code&gt;haystack&lt;/code&gt; 很懒（尽可能）。</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">这个函数的第一个参数是严格的,第二个参数是懒惰的。</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">这个函数在计算结果上是严格的,在写入字节上是懒惰的。例如,给定</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">此功能适用于纯代码。在IO上下文中，请改用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">此函数是不安全的，因为如果返回的 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 的类型与预期的不匹配，则程序行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">GHC使用此函数来构造 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">GHC使用此函数来构造 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">这个功能很有用,例如,当一个孩子终止时,可以通知家长。</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">此功能对于在多线程程序中安全使用 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 很有用。如果只有一个 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; ，则使用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 进行访问和修改将防止出现竞争情况。</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">当我们要设置cTRL_C_EVENT处理程序时，此函数不合适。如果要设置cTRL_C_EVENT处理程序，请改用 &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">这个函数将一个异常映射成另一个异常,正如论文 &quot;A semantics for imprecise exceptions &quot;中提出的那样。</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例，只要 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 被限定。（将 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; 与仅由 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例一起使用将导致无限递归。）</target>
        </trans-unit>
        <trans-unit id="5b30959a5096a71e3cec93cd57d2e51e397b263e" translate="yes" xml:space="preserve">
          <source>This function may be used to debug Haskeline's input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">此功能必须是参照透明的；即，使用相等大小的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 多次调用它必须导致写入相同的字节序列和计算相同的值。如果需要可变状态，则必须在每次调用此函数时重新分配它。更进一步，此函数必须在完成后调用延续。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 的单峰排序不起作用。最后，此函数必须写入它声称已写入的所有字节。否则，不能保证所生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 相对于参考透明，并且敏感数据可能会泄漏。</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">此功能必须是参照透明的；即，使用相等大小的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 多次调用它必须导致写入相同的字节序列。如果需要可变状态，则必须在每次调用此函数时重新分配它。更进一步，此函数必须在完成后调用延续。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的串联将不起作用。最后，此函数必须写入它声称已写入的所有字节。否则，不能保证 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的生成器是参照透明的，并且敏感数据可能会泄漏。</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">该函数一次读取块，增加了每次读取的块大小。然后将最终的字符串重新分配为适当的大小。对于大于可用内存一半的文件，这可能会导致内存耗尽。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">该函数一次读取块，增加了每次读取的块大小。然后将最终的字符串重新分配为适当的大小。对于大于可用内存一半的文件，这可能会导致内存耗尽。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">该函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果它的参数有以下一个 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; S，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 以其他方式：</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">该函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果它的参数有以下一个 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; S，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 以其他方式：</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不应在关闭或取消的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 上调用此函数。</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">该函数获取一个表示图的邻接表，该图具有由类型 &lt;code&gt;node&lt;/code&gt; 的值标记的类型为 &lt;code&gt;key&lt;/code&gt; 的顶点，并生成该列表的基于 &lt;code&gt;Graph&lt;/code&gt; 的表示形式。的 &lt;code&gt;Graph&lt;/code&gt; 结果表示&lt;em&gt;形状&lt;/em&gt;的曲线图的，和功能描述）如何检索给定顶点的标签和相邻顶点，以及b）如何以检索给定的密钥的顶点。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">此函数使用一个额外的 &lt;code&gt;String&lt;/code&gt; 参数来创建错误消息。</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果进程 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不同于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; ,则此函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。相反，如果要获取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; ,请使用 &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1318cc2b39b86c3da816e772a9967719bb468613" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">这个函数将在约束求解过程中的两点被调用:在给定约束简化之后,和在想要的约束取消之后。这两个阶段可以区分开来,因为在第一种情况下,派生约束和想要的约束都是空的。在每种情况下,插件都应该</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">此函数包装 &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; ，其中考虑了一些实现方面的特殊性：</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 一样，此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这概括了基于列表的 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">这 &lt;code&gt;hpc_index.html&lt;/code&gt; 每个Haskell模块生成一个文件，并生成4个索引文件：hpc_index.html， &lt;code&gt;hpc_index_alt.html&lt;/code&gt; ， &lt;code&gt;hpc_index_exp.html&lt;/code&gt; ， &lt;code&gt;hpc_index_fun.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5344bdf0cc9457503d3d92a9eb3e0f2cb07653d" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;unpinned&lt;/a&gt;&lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">这极大地限制了库作者，因为它暗示将任何堆对象引用传递给 &lt;code&gt;safe&lt;/code&gt; 外部函数调用是不安全的。例如，通常希望将未固定的 &lt;code&gt;ByteArray#&lt;/code&gt; 直接传递给本机代码，以避免产生不必要的副本。但是，只有保证在调用过程中不让垃圾收集器移动该数组时，才能安全地完成此操作。</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 以及与带有 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 一起调用具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 以及与带有 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 一起调用具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">这有两个效果。第一种是编译代码，使其可以与Haskell软件包的共享库版本（例如base）链接。第二个是在链接时，链接到软件包库的共享版本而不是静态版本。显然，这需要使用共享库构建软件包。在支持的平台上，GHC附带了所有核心软件包的共享库，但是，如果您安装了额外的软件包（例如Cabal），则它们也必须使用共享库（对于Cabal为 &lt;code&gt;--enable-shared&lt;/code&gt; )构建。</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">这个想法很古老；参见Seciton 7的&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable类型类&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">此实现使用 &lt;code&gt;memset(3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">这个实现是故意幼稚的。实例有望为其规模提供优化的实现。</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">这意味着刷新输出缓冲区，即使它仅包含一个字节也是如此。因此，应仅对大（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 。否则，生成的块将过于分散，以至于无法在之后进行有效处理。</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">这意味着刷新输出缓冲区，即使它仅包含一个字节也是如此。因此，应仅对大（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 。否则，生成的块将过于分散，以至于无法在之后进行有效处理。</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">对于大多数程序而言，这会稍微提高效率，但会显着提高，而对于少数几个程序却是不利的。要抑制这种虚假的&amp;ldquo;优化&amp;rdquo;，请使用 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">这包括主线程，因此使用&lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;是查看程序正在使用多少堆栈空间的好方法。</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">这表明可能还有更多数据要写入。它为您提供了下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作。您应该使用适当的缓冲区调用该操作。 int指示下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作所需的&lt;em&gt;最小&lt;/em&gt;缓冲区大小。也就是说，如果调用下一个动作，则&lt;em&gt;必须&lt;/em&gt;为其提供至少此大小的缓冲区长度。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">不管调用的参数或 &lt;code&gt;f&lt;/code&gt; 的定义大小如何，都会发生此内联；这是无条件的。主要警告是 &lt;code&gt;f&lt;/code&gt; 的定义对于编译器必须是可见的。因此，建议在函数定义时用 &lt;code&gt;INLINABLE&lt;/code&gt; 杂注标记功能，以便GHC保证记录其展开的大小。</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">这会将插件作为核心到核心通道插入。与 &lt;code&gt;-fplugin=(module)&lt;/code&gt; ，plugin模块不能与调用&lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;的模块位于同一软件包中。这样，实现可以期望插件在需要的时候构建。</target>
        </trans-unit>
        <trans-unit id="5ff50fa3f4d1717b720187c6141e26cd711cc26f" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">该实例与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例具有类似的考虑：它以低效率为代价保留了抽象。</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">此实例是为了方便和与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 保持一致。假设WHNF在功能上与NF等效。</target>
        </trans-unit>
        <trans-unit id="0eaa2be703bfed5db1962bf2e87d773ccbf9e44d" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">仅当构造函数 &lt;code&gt;MkNT&lt;/code&gt; 在范围内时，此实例才可用。</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">这个实例以低效率为代价保留了数据抽象。为了数据抽象,我们省略了反射服务。</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">通过复制 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 的更新行为来创建此实例。 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 。如果您认为自己犯了一个错误，请随时提出改进意见。</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">通过复制 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 的更新行为来创建此实例。 &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等效于 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype的派生实例。</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等效于 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype的派生实例。</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等同于 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 新类型的派生实例。</target>
        </trans-unit>
        <trans-unit id="d7a50a4b488dfd0ceef47a8a415f99ee744d5ed8" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-ord#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe29b722781fc1de8c3cf834abcc1f449fc0a931" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">这指示链接器将所有符号（不仅是已使用的符号）添加到动态符号表中。目前仅适用于Linux和Windows / MinGW32。这等效于在Linux 上使用 &lt;code&gt;-optl -rdynamic&lt;/code&gt; ，在Windows 上使用-optl &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这指示链接器生成与位置无关的可执行文件。该标志仅在生成可执行文件时才有效，并且所有链接的目标代码必须已使用&lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; 生成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">NiklasR&amp;ouml;jemo为解析器引入了此接口，因为它接受的共享比monadic接口更多。这里的名称主要基于Doaitse Swierstra的解析工作。</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; ，其参数已翻转。</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">这是一个&amp;ldquo;安全的&amp;rdquo;变体 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;mpz_powm_sec()&lt;/code&gt; ，其被设计为弹性的，以侧信道攻击，并因此适用于密码应用的功能。</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">这是相对于6.2及以前的行为变化。</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 的组合；即。它从 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 获取值，将其放回去，然后还返回它。</target>
        </trans-unit>
        <trans-unit id="d6388ad09499896ee48a8e46a65f919073bd630f" translate="yes" xml:space="preserve">
          <source>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">当您尝试直接链接到目标文件时，这是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; 的一个很好的选择。</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">这是使程序与全局暴露的程序包之间的差异隔离的好方法，并且明确说明程序包的依赖关系是一件好事。正是由于这个原因，Cabal始终将 &lt;code&gt;-hide-all-packages&lt;/code&gt; 标志传递给GHC。</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">这是有关使用格拉斯哥Haskell编译器（GHC）的指南：格拉斯哥&lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt;语言的交互式批处理编译系统。</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">这是一个时间长度,由UTC测量。它的精确度为10^-12秒。</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">这是一个时间长度,由时钟测量。换算函数会将其视为秒。它的精度为10^-12秒。</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">这是一个解析器组合器库，最初由Koen Claessen编写。它并行地解析所有替代项，因此它永远不会保持输入字符串的开头，这是其他解析器常见的空间泄漏源。的 &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 的选择组合子是真正交换; 哪个分支&amp;ldquo;更短&amp;rdquo;没有区别。</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">这是一个很大的信息!然而,大多数信息实际上只是元信息,它使数据类型和构造函数的名称和更多的类型水平可用。然而,它的大部分实际上只是元信息,使得数据类型和构造函数的名称以及更多的信息在类型级别上可用。</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">这是一个Haskell风格语言的最小化标记定义。它定义了注释、有效标识符和大小写敏感性的风格。它没有定义任何保留字或操作符。</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">这是一个Java风格语言的最小标记定义。它定义了注释的风格、有效的标识符和大小写敏感性。它没有定义任何保留字或运算符。</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">这是一个高效的堆栈跟踪模块。这个堆栈跟踪实现被认为是低开销的。基本用法是这样的。</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。如果该进程仍在运行， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。如果该进程已退出，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是该进程的退出代码。</target>
        </trans-unit>
        <trans-unit id="1f500d4f7fd67c8ad0b3e4a53af642dd0d2ae2b1" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">这是一个相当脆弱的安排，因为程序员通常期望 &lt;code&gt;(*) a b&lt;/code&gt; 等于 &lt;code&gt;a * b&lt;/code&gt; 。使用&lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; &lt;/a&gt;可以警告对 &lt;code&gt;(*)&lt;/code&gt; 的特殊处理。</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">这是一个稍微涉及的试探法，但是捕获了更改现有代码行为的导入模块 &lt;code&gt;N&lt;/code&gt; 的情况。例如，如果不违反第二个条件，那么模块作者 &lt;code&gt;M&lt;/code&gt; 必须依赖于 &lt;code&gt;N&lt;/code&gt; 中定义的类型类或类型。</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;mtimes&lt;/code&gt; 成员，这是一个合适的定义。</target>
        </trans-unit>
        <trans-unit id="bec2a1e9f6c0528918f3d75270102aae0235701e" translate="yes" xml:space="preserve">
          <source>This is a tad complicated for our &lt;code&gt;ApplicativeDo&lt;/code&gt; extension which will give it a &lt;code&gt;Monad&lt;/code&gt; constraint. For an &lt;code&gt;Applicative&lt;/code&gt; constraint we write it of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个有效的定义 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个有效的定义 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 为幂等 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是幂等 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 的有效定义。</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 的变体，其中终结器是任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。调用终结器时，它将在新线程中运行。</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">这是 &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; 的变体，其中终结器是任意 &lt;code&gt;IO&lt;/code&gt; 操作。调用终结器时，它将在新线程中运行。</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">这是查看位于异物内部的指针的方法。该函数采用一个应用于该指针的函数。然后执行生成的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。即使不直接在内部使用，异物也至少在整个动作过程中都保持活动状态。请注意，从操作返回指针并在操作完成后使用它是不安全的。指针的所有使用都应放在 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 括号内。这种不安全的原因与下面的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 相同：终结器的运行可能比预期的要早，因为编译器只能跟踪 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 对象的使用，而不能跟踪由此生成的 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">这是查看位于异物内部的指针的方法。该函数采用一个应用于该指针的函数。然后执行生成的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。即使不直接在内部使用，异物也至少在整个动作过程中都保持活动状态。请注意，从操作返回指针并在操作完成后使用它是不安全的。指针的所有使用都应放在 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 括号内。这种不安全的原因与下面的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 相同：终结器的运行可能比预期的要早，因为编译器只能跟踪 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 对象的使用，而不能跟踪由此生成的 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">这是一个针对GHC 6.8.2中优化不良的变通方法。它没有注意到恒定宽度的移动,并为每次移动添加了测试和分支。这对性能造成了10%的影响。</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">这几乎与 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 相同，但是返回一个由选项参数，非选项列表，无法识别的选项列表和错误消息列表组成的四元组。</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">这与 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 几乎相同，不同之处在于 &lt;code&gt;ghc-pkg dump&lt;/code&gt; 是供解析结果的工具使用的，因此，例如 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 会发出错误。如果找不到与模式匹配的任何软件包， &lt;code&gt;ghc-pkg dump&lt;/code&gt; 将不会发出任何东西。</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">这也就是所谓的树上的猫腻。</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">这也是参与并行垃圾收集的线程数。强烈建议能力数量的设置不要大于物理处理器内核的数量,而且通常情况下,留出一个或多个内核以避免与机器中的其他进程发生争执可能是有益的。</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">这始终是一个整体类型。宽度和签约度是平台特定的。</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">这是使用&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt;编译器生成可执行代码的备用后端。它产生的代码通常具有与本机代码生成器一样好的性能，但是在某些情况下可以产生更快的代码。对于使用矢量之类的软件包的数字数组重代码尤其如此。惩罚是编译时间的显着增加。选择带有&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;标志的LLVM后端。</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">这是一个实验性的功能,请让我们知道它是否会造成问题和/或可以从进一步的调整中受益。</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 的中缀别名。</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">这是参数 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 的infix版本。</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">这是因为 &lt;code&gt;qsort&lt;/code&gt; 是一个多态函数，并且因为GHCi在运行时不携带类型信息，所以它无法确定涉及类型变量的自由变量的运行时类型。因此，当您要求在提示处显示 &lt;code&gt;left&lt;/code&gt; 时，GHCi无法确定要使用哪个 &lt;code&gt;Show&lt;/code&gt; 实例，因此它会在上面发出类型错误。</target>
        </trans-unit>
        <trans-unit id="9020fa1ceb2a91d141dfe05d47580894b2e14468" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">这是 &lt;code&gt;Natural&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 常用的类型。由于此类型由包装 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 的单个构造函数组成，因此可以解压缩。</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">这对保持正确性至关重要。在其他模块中定义的实体可能会依靠懒惰来保证正确性(无论是功能还是性能)。</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">目前只由以下操作返回。</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">然而,这是一个危险的领域。例如,这里有一个程序,可以让typechecker循环。</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">这肯定是由GHC中的错误引起的。请报告它（请参阅&lt;a href=&quot;intro#bug-reporting&quot;&gt;报告GHC中的错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">这等效于 &lt;code&gt;if p then y else x&lt;/code&gt; ; 也就是说，可以将其视为参数重新排序的if-then-else构造。</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从本质 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; ，这是findFilesWith的更高性能版本，它始终返回第一个结果（如果有）。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="62b9a042aea0816af6e299c00f387f0402dcd3d1" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Eq&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">这与在声明 &lt;code&gt;data Foo a&lt;/code&gt; 之后编写 &lt;code&gt;deriving Foo&lt;/code&gt; 基本上相同。使用此功能需要使用&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;部分类型签名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">预计这将提高平均性能,但实际性能差异会有所不同。</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">这完全是为写GHC改写规则的人暴露的。</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">这适用于可能需要在运行时在这些Haskell库中定义的符号的专业应用程序，即使未链接到可执行文件的任何其他代码引用了它们。如果您正在使用 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; ，则可能还需要 &lt;code&gt;-rdynamic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">这是使用 &lt;code&gt;insertLookupWithKey&lt;/code&gt; 定义 &lt;code&gt;insertLookup&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">这是非法的，因为在右侧使用&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; 会&lt;/a&gt;阻止它成为格式正确的表达。但是，使用明确的双向模式同义词来构造严格的模式同义词是很有可能的：</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">这在内部实现为计数前导-零的机器指令。</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">这只是一个方便函数,它的定义很简单,就是。</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">这主要是在Cmm传球时进行的。然而,这可能会漏掉一些角落的情况。因此,在-O2时,我们在asm阶段再次运行该通道,以捕捉这些情况。</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">这通常在一组替代方法的末尾使用，在这些替代方法中，我们希望根据高层构造返回错误消息，而不是返回所有可能的字符。例如，如果 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 示例中的 &lt;code&gt;expr&lt;/code&gt; 解析器失败，则错误消息为：'...：expressioning expression'。如果没有 &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 组合器，则消息将类似于'...：期待&amp;ldquo; let&amp;rdquo;或字母&amp;ldquo;&amp;rdquo;，这不太友好。</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">这通常在一组替代方法的末尾使用，在这些替代方法中，我们希望根据高层构造返回错误消息，而不是返回所有可能的字符。例如，如果 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 示例中的 &lt;code&gt;expr&lt;/code&gt; 解析器失败，则错误消息为：'...：expressioning expression'。如果没有 &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 组合器，则消息将类似于'...：期待&amp;ldquo; let&amp;rdquo;或字母&amp;ldquo;&amp;rdquo;，这不太友好。</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">这在某些情况下并不理想,比如当输出很长,或者包含非ascii字符的字符串时。</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特殊字符不进行处理。对于用户字符串，请使用stringToHtml或lineToHtml代替，因为它们可以理解特殊字符，例如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9eee7f5de1930e679b3ff1bf2b45247aa3e4891d" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">与较大的 &lt;code&gt;-A&lt;/code&gt; 值结合使用时，这特别有用，例如 &lt;code&gt;-A64m -n4m&lt;/code&gt; 对于较大的内核数（8+）是有用的组合。</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">这对于GHC 的 &lt;code&gt;ViewPatterns&lt;/code&gt; 扩展特别有用，如下所示：</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">这与类 &lt;code&gt;IsString&lt;/code&gt; 非常相似（请参见&lt;a href=&quot;#overloaded-strings&quot;&gt;重载的字符串文字&lt;/a&gt;），但是具有一个附加的type参数，该参数使标签的文本可用作类型级字符串（请参见&lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;）。请注意， &lt;code&gt;fromLabel&lt;/code&gt; 在GHC 8.0中有一个额外的 &lt;code&gt;Proxy# x&lt;/code&gt; 参数，但是在GHC 8.2中已将其删除，因为可以改用类型应用程序（请参阅&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型应用程序&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">这被拒绝是因为RHS上的类型没有&amp;ldquo;最外层&amp;rdquo;（向 &lt;code&gt;PackMap&lt;/code&gt; 添加额外的参数显然很糟糕），因此不会发生隐式量化，并且声明被拒绝（&amp;ldquo; &lt;code&gt;f&lt;/code&gt; 超出范围&amp;rdquo; &amp;rdquo;）。解决方案：使用显式的 &lt;code&gt;forall&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">这是通过Haskell的98拒绝，但在琼斯的方案为定义 &lt;code&gt;g&lt;/code&gt; 首先typechecked，分别从对于 &lt;code&gt;f&lt;/code&gt; ，因为参考以 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;g&lt;/code&gt; 的右手侧由依赖性分析忽略。然后将 &lt;code&gt;g&lt;/code&gt; 的类型归纳为</target>
        </trans-unit>
        <trans-unit id="af9e5e6b5a1471403ba13a39e6cf598e61cc7f1f" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type is generalised, to get</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">如果编译器支持Template Haskell，则将其设置为 &lt;code&gt;1&lt;/code&gt; ；否则，将其设置为 &lt;code&gt;0&lt;/code&gt; 。后者是在引导过程中或在没有解释器的体系结构上的阶段1编译器的情况。</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">这甚至适用于抽象类型，因为 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的定律暗示了一种关联性。</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">这甚至适用于抽象类型，因为 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的定律暗示了一种关联性。</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">这甚至适用于抽象类型，因为假定类人动物满足类人动物定律。或者，可以定义 &lt;code&gt;foldr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">这适用于透明导出的数据类型。</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 的&amp;ldquo;后门&amp;rdquo; ，允许随时执行 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。为了安全起见， &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算应无副作用且与环境无关。</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 的&amp;ldquo;后门&amp;rdquo; ，允许随时执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。为了安全起见， &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算应无副作用且与环境无关。</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">这是 &lt;code&gt;LINE&lt;/code&gt; 编译指示的类似物，同样适用于自动生成的Haskell代码。它允许您指定原始代码的列号；例如</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">这是 &lt;code&gt;getContents&lt;/code&gt; 的已定义行为：将stdin Handle置于一种称为半封闭的状态，其中禁止对其进行任何进一步的I / O操作。由于在两次计算之间会保留I / O状态，因此半封闭状态将一直保持到下一个&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;命令为止。</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">这是初始的语言环境编码：如果后来被 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; 更改，则此值将不会反映该更改。</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">这是展开（即内联）的不可思议的临界值：在此大小以下，函数定义将在调用位置展开，更大的部分将不会展开。为函数计算的大小取决于两件事：表达式的实际大小减去根据表达式要内联的上下文而适用的任何折扣。</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">这是使程序运行更快的最基本方法。编译时间会更慢，尤其是使用 &lt;code&gt;-O2&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">这是最通用的构建弱指针的接口。</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">这是最通用的分组类型语句。在这种形式下，要求f具有类型 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 。与上面的 &lt;code&gt;then f by e&lt;/code&gt; 情况一样，第一个参数是由编译器提供给f的函数，该函数使它可以对要转换的列表的每个元素计算e。但是，与非分组情况不同，f将列表另外划分为多个子列表：这意味着在该语句之后的每个点，在理解中出现在其之前的联编程序都引用可能值的&lt;em&gt;列表&lt;/em&gt;，而不是单个值。为了帮助理解这一点，让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">这是产生外部进程的最通用方法。该过程可以是要由Shell执行的命令行，也可以是带有参数列表的原始命令。新进程的stdin，stdout和stderr流可以分别附加到新管道，现有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 或仅从父级继承（默认值）。</target>
        </trans-unit>
        <trans-unit id="11f3ed6859503f000bff2d612fad07f02ba594bf" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">这是最小的令牌定义。建议将此定义用作其他定义的基础。 &lt;code&gt;emptyDef&lt;/code&gt; 没有保留的名称或运算符，区分大小写，并且不接受注释，标识符或运算符。</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">这是用于接受令牌的最原始的组合器。例如， &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; 解析器可以实现为：</target>
        </trans-unit>
        <trans-unit id="c028e89a3d3ce63ac917bdfc38f641c5b46ea80a" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt;&lt;code&gt;-fvia-C&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">这是GHC中最古老的代码生成器，通常不包含在GHC 7.0中已弃用的代码生成器。使用 &lt;code&gt;-fvia-C&lt;/code&gt; 标志选择它。</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">这是异常捕获函数中最简单的一个。它接受一个参数,运行它,如果出现异常,&quot;处理程序 &quot;就会被执行,异常值作为参数传递。否则,结果将按正常方式返回。例如</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">这是UTC最简单的表示方法。它由日号和从午夜开始的时间偏移组成。请注意,如果一天有一个闰秒,它将有86401秒。</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">这是传统的批处理编译器模式，GHC可以一次编译一个源文件，也可以将对象链接在一起成为可执行文件。请参阅&lt;a href=&quot;#options-order&quot;&gt;批处理编译器模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">这是在其参数上重构的字段格式器的类型。</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">用户调用 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 时抛出此错误。第一个 &lt;code&gt;String&lt;/code&gt; 是给 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 的参数，第二个 &lt;code&gt;String&lt;/code&gt; 是位置。</target>
        </trans-unit>
        <trans-unit id="aebf3f40f6a1942ecdd588383580c2939b2e0f04" translate="yes" xml:space="preserve">
          <source>This is unsafe because GHC cannot check for you that the expression really does have the type you claim it has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">这用于AST引号中的漏洞或未解决的标识符。注意,它可以有一个变量名或构造函数名。</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">这用于导入遵循内部GHC调用约定的Cmm代码编写的函数。参数和结果必须是未装箱的类型，但参数可以是 &lt;code&gt;Any&lt;/code&gt; 类型（通过 &lt;code&gt;unsafeCoerce#&lt;/code&gt; ），并且结果类型可以是未装箱的元组或 &lt;code&gt;Any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">这对于通过单项式变换器进行参数化的函数非常有用。</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">与&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;结合使用以测试生成的文件是否取决于 &lt;code&gt;Unique&lt;/code&gt; 的顺序时，这很有用。</target>
        </trans-unit>
        <trans-unit id="eb2802e19e3cc64605ff63d36592512d32cabe42" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;rsquo;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223669d1cce36e8738573bac6e197f3c8162072c" translate="yes" xml:space="preserve">
          <source>This is very similar to &lt;code&gt;&lt;a href=&quot;../mtl-2.2.2/control-monad-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;MonadError&lt;/code&gt;, but based on features of &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;. In particular, it handles the complex case of asynchronous exceptions by including &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; in the typeclass. Note that the extensible exceptions feature relies on the RankNTypes language extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">这就是为什么RIO模块使用&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;进行编译以允许 &lt;code&gt;Danger&lt;/code&gt; 模块导入它的原因。该&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;标志不一样的地方在模块上的任何限制，&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;没有（想到限制重叠的情况下，以&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全重叠的情况下&lt;/a&gt;）。相反，该模块的作者声称，尽管代码可能在内部使用了不安全的功能，但它仅公开了可以安全使用的API。</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">人们普遍认为这是一种错误的功能，并且将从该语言中删除。在GHC中，它由已弃用的扩展 &lt;code&gt;DatatypeContexts&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">这不是特别有启发性。发生的是， &lt;code&gt;left&lt;/code&gt; 绑定到未评估的计算（挂起或重击），并且&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;不会强制执行任何评估。这个想法是&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;可以用来检查断点处的值，而没有任何不幸的副作用。它不会强制执行任何评估，这可能导致程序给出与正常情况不同的答案，因此不会引发任何异常，无限循环或触发其他断点（请参见&lt;a href=&quot;#nested-breakpoints&quot;&gt;嵌套断点&lt;/a&gt;）。 。&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;不会强制重击，而是将每个重 &lt;code&gt;_t1&lt;/code&gt; 绑定到以下划线开头的新变量，在本例中为_t1。</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">这还不是全部：GHC还在预编译的库中寻找模块，即软件包。有关详细信息，请参见有关包（&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;）的部分。</target>
        </trans-unit>
        <trans-unit id="e058359ab2e82e0cac7dd3d00a96ceff57c41dfb" translate="yes" xml:space="preserve">
          <source>This kind is similar to the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;, but with a key difference: the type variables quantified by the &lt;code&gt;forall&lt;/code&gt; are followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;), not a dot (&lt;code&gt;.&lt;/code&gt;). This is a visible, dependent quantifier. It is visible in that it the user must pass in a type for &lt;code&gt;k&lt;/code&gt; explicitly, and it is dependent in the sense that &lt;code&gt;k&lt;/code&gt; appears later in the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;. As a counterpart, the &lt;code&gt;k&lt;/code&gt; binder in &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; can be thought of as an &lt;em&gt;invisible&lt;/em&gt;, dependent quantifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">缺乏类型推理只是GHC中的一个工程问题，但是使其工作将对推理基础结构做出重大改变，并且尚不清楚回报是否值得。如果要在上述实例中限制 &lt;code&gt;b&lt;/code&gt; 的种类，只需在实例头中使用种类签名即可。</target>
        </trans-unit>
        <trans-unit id="35e744da89ea652776d7de1d49ded5a0e6370630" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">此旧版模块提供对&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;的列表特定操作的访问。在将来的GHC版本中，该模块可能会再次消失，并且作为过渡工具提供，用于访问由于实施了&lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;可折叠/前奏式提议（FTP）&lt;/a&gt;而必须概括的一些列表专用操作。</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这可让您使用的差异列表 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">这个词素解析器解析一个浮点值。返回数字的值。数字是根据 Haskell 报告中定义的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法标识符。返回标识符字符串。对于保留字的标识符，此解析器将失败。合法标识符（开始）字符和保留字在传递给 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;identifier&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法标识符。返回标识符字符串。对于保留字的标识符，此解析器将失败。合法标识符（开始）字符和保留字在传递给 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;identifier&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法运算符。返回运算符的名称。该解析器将在所有保留运算符上失败。合法运算符（开始）字符和保留运算符在传递给 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;operator&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法运算符。返回运算符的名称。该解析器将在所有保留运算符上失败。合法运算符（开始）字符和保留运算符在传递给 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;operator&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">这个词素解析器解析一个字面字符串。返回字面字符串的值。这个解析器能正确处理转义序列和间隙。字符串是根据Haskell报告中定义的语法规则进行解析的(与大多数编程语言相当接近)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
