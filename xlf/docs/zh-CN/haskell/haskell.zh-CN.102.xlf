<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="7defbd1e72da7e4dd78ff7b670071a5b458cf24a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">文件 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 一种变体，不具有基本大小写，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="e9ee1d48660b932b3bb180c1aaef20eee11c73c0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的变体，其参数相反。</target>
        </trans-unit>
        <trans-unit id="d32ebdebb4f9a3837e2e7d4648c8bd7eceb6c9f2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种变体，不会产生堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="f23407f9c31b9d9550363e44222113e312af065d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228eb2d34fa954a72d817265f3ac30a2c4d0f77c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7861d5890086af48309a590da6181c625683ee1f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5f00d655edd846275d9f60a79ac5425b4f77f7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e8eb5a5f4093ff8d82e55e0f565658eec94954" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0680130bb0f4b8f4cbc7c8b028930fd44a3af9ce" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="0ec4492419779cfaef51be94d2b8f28e80c4545f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="491efa58eb1f11c0cb3815ae8f348ca0c034ce84" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="47d036c06686a27eae150f0188962179aa6b3b53" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="da53c6399c31d81bfdb2f650d84ca62634038b07" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="73f171fdb5237d901b1c481374b6861edf14fa56" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种变体，不会产生堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="47f3f2679bc0ad75bdf30646c6761ef6c4b68243" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的一种变体，没有基本情况，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="477f918f68cdb05044cf99fdb58a555808faeff3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">文件 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 一种变体，不具有基本大小写，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="6911589d252df6b0d320b35e4685df9e30028055" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 一种变体，其中不需要第一次计算的返回值。</target>
        </trans-unit>
        <trans-unit id="add459265a4128073f2963ebb449fbb05ec6cb08" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">各种各样的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 都忽略了对 &lt;code&gt;n&lt;/code&gt; 的检查，因此程序员有义务提供证明 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="022677c1577a85e404387475e8f412822a05da7e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 省略了对空情况的检查，因此程序员有义务提供证明ByteString为非空。</target>
        </trans-unit>
        <trans-unit id="8b4ffb4fe31d0195b8acddfad454298b4604216b" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 省略对空情况的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="1d777dc5f4859f53e852d78b2a883751d3a5e477" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一种。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 省略了对空箱的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="d0e791ecae2adcb55aa4c85c7e30c588765957cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; 用于非空字节串。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 省略了对空情况的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="cd0eca831b19e2193bae89b92f0b4e215f8baf4c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 其省略了对支票 &lt;code&gt;n&lt;/code&gt; 所以对程序员有义务提供一个证明 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d61fdfe5cc2564d603aac91be2fa83ba8aa2a7c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fb91e894a0b25610b75a5af5b9808209630d25" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdce50acace32ba6eb0fe5af8f10f59503ea5260" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416bf67712d94a4092fa1366ed0a1243511ca321" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73173fcba7dc4f1755bea5939f3721c98a85b2cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ba6eac709468119bb502dc4a786ac25beaa443" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011da0f3d1d6c75639ffb6db3b663d10df8596d2" translate="yes" xml:space="preserve">
          <source>A version can be tagged with an arbitrary list of strings. The interpretation of the list of tags is entirely dependent on the entity that this version applies to.</source>
          <target state="translated">一个版本可以用一个任意的字符串列表来标记。标签列表的解释完全取决于这个版本所适用的实体。</target>
        </trans-unit>
        <trans-unit id="ecaf2ca21f3f2373e5185cd515851b6e67ee803a" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ffeb4910a01e5cd6d72fcebc814ef710471656" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">无法重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b08df2ea8c4c791467734758ae49b0aa839c743" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">不重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5e78e2ce5a1352cca108846156255775dd7108" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff76e55acfcccd02a15d736db81fe96146722925" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">不 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 版本。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 功能企图把价值 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; ，返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果它是成功的，或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="28577cb8a660e56c217a279acfd2976c3b7454ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc8f0973fefa88de9a13d12ee694150980b61d" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed2b50c296f40c959a6e33c87f8de3078552d7bb" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">的一个版本 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 不 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 挤满了内容 &lt;code&gt;a&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 之后， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 保留为空。</target>
        </trans-unit>
        <trans-unit id="5433d7bb6120760452598bf6c542c3024a31c810" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f3fd19a32279f9ca43fcf5051a4b725b4afb0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2433a0ad5e90f34ad9f4bf45621e0ceb170fdea6" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">不重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc561502aa5288942ce875d139d9631abcf512c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</source>
          <target state="translated">一个带有参数互换的 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 版本；在处理程序的代码较短的情况下很有用。例如：</target>
        </trans-unit>
        <trans-unit id="1c3e44a662ef33517cd5d56bc8e42cf32ad0c3d0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; with the arguments swapped around (see &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 的版本，其中的参数互换了（请参阅 &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e66efe0c3f15c8fafbf44d9ce27299363bc807ef" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; that forces the (pair) result of the function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 的版本，用于强制函数的（对）结果。</target>
        </trans-unit>
        <trans-unit id="bef2aa5115f3db1a79e2efec0dfffeeae204b525" translate="yes" xml:space="preserve">
          <source>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</source>
          <target state="translated">竖条表示不连贯,即两边中必须有一边。逗号表示连接,即两边都需要。连词比不连词的约束力更强。</target>
        </trans-unit>
        <trans-unit id="edf34a57d05a3c5d4ea50057dd0ce34f6a6b36fa" translate="yes" xml:space="preserve">
          <source>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">一个非常实验性的标志,让字典值的表达式在优化器看来很廉价。</target>
        </trans-unit>
        <trans-unit id="7c65e4b2cb887d618e9c4063061a15033cdc0051" translate="yes" xml:space="preserve">
          <source>A violation of the &amp;ldquo;forall-or-nothing&amp;rdquo; rule looks like this:</source>
          <target state="translated">违反&amp;ldquo;全部或全部&amp;rdquo;规则的情况如下：</target>
        </trans-unit>
        <trans-unit id="a5feb9baead6354d4dfbb9ad7fa5678327d72c84" translate="yes" xml:space="preserve">
          <source>A visible type application is preceded with an &lt;code&gt;@&lt;/code&gt; sign. (To disambiguate the syntax, the &lt;code&gt;@&lt;/code&gt; must be preceded with a non-identifier letter, usually a space. For example, &lt;code&gt;read@Int 5&lt;/code&gt; would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</source>
          <target state="translated">可见类型的应用程序前面带有 &lt;code&gt;@&lt;/code&gt; 符号。（要消除语法歧义， &lt;code&gt;@&lt;/code&gt; 之前必须加一个非标识符字母，通常是一个空格。例如， &lt;code&gt;read@Int 5&lt;/code&gt; 不会解析。）只要知道函数的完整多态类型，就可以使用它。如果函数是标识符（常见情况），则仅在为标识符提供类型签名后，才认为其类型是已知的。如果标识符没有类型签名，则不能使用可见的类型应用程序。</target>
        </trans-unit>
        <trans-unit id="f7aecd3b32383a90db727ba6bc951dd96bb7555b" translate="yes" xml:space="preserve">
          <source>A way of creating ByteStrings outside the IO monad. The &lt;code&gt;Int&lt;/code&gt; argument gives the final size of the ByteString.</source>
          <target state="translated">一种在IO monad外部创建ByteString的方法。在 &lt;code&gt;Int&lt;/code&gt; 参数给出的字节串的最终大小。</target>
        </trans-unit>
        <trans-unit id="ae700162fd083eb51a2e5484581b63431c6cf961" translate="yes" xml:space="preserve">
          <source>A weak pointer expresses a relationship between two objects, the &lt;em&gt;key&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt;: if the key is considered to be alive by the garbage collector, then the value is also alive. A reference from the value to the key does &lt;em&gt;not&lt;/em&gt; keep the key alive.</source>
          <target state="translated">弱指针表示&lt;em&gt;键&lt;/em&gt;和&lt;em&gt;值&lt;/em&gt;两个对象之间的关系：如果垃圾回收器认为键是活动的，则该值也是活动的。从值到键的引用&lt;em&gt;不会&lt;/em&gt;使键保持活动状态。</target>
        </trans-unit>
        <trans-unit id="4c0a7ed1da2479162371079b8163cabf26c83c98" translate="yes" xml:space="preserve">
          <source>A weak pointer may also have a finalizer of type &lt;code&gt;IO ()&lt;/code&gt;; if it does, then the finalizer will be run at most once, at a time after the key has become unreachable by the program (&quot;dead&quot;). The storage manager attempts to run the finalizer(s) for an object soon after the object dies, but promptness is not guaranteed.</source>
          <target state="translated">弱指针也可能具有 &lt;code&gt;IO ()&lt;/code&gt; 类型的终结器；如果确实如此，则终结器将最多运行一次，一次是在程序无法访问密钥之后（&amp;ldquo;死&amp;rdquo;）。对象死亡后，存储管理器会尝试为该对象运行终结器，但是不能保证快速性。</target>
        </trans-unit>
        <trans-unit id="a955a161a9eee216cd6b80d8d47df1c807c9be34" translate="yes" xml:space="preserve">
          <source>A weak pointer object with a key and a value. The value has type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">具有键和值的弱指针对象。该值的类型为 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b5c16f462f6b8ca64b6aee48fd180f321af7cba" translate="yes" xml:space="preserve">
          <source>A whole String fragment</source>
          <target state="translated">一个完整的字符串片段</target>
        </trans-unit>
        <trans-unit id="1306d902863c6c0a77b6f4d1230a385868937f62" translate="yes" xml:space="preserve">
          <source>A wide character string with explicit length information in &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt;s instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt; 中具有明确长度信息的宽字符串，而不是终止NUL（允许在字符串中间使用NUL字符）。</target>
        </trans-unit>
        <trans-unit id="987253a26575543a06fc7e055fbc0251b63eb205" translate="yes" xml:space="preserve">
          <source>A word begins either at the start of the line or after an unescaped whitespace character.</source>
          <target state="translated">一个字的开头是在行的开始,或者是在一个未加空格的字符之后。</target>
        </trans-unit>
        <trans-unit id="98bca88a2b006e940b1f7f785915d961c11c9f72" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">由输出类型 &lt;code&gt;w&lt;/code&gt; 参数化的writer monad 进行累加。</target>
        </trans-unit>
        <trans-unit id="07ef82639a79658d53d1fcd5bfce5876d5b9adb5" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by:</source>
          <target state="translated">一个以下列方式为参数的作家单子:</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="882edca3292f207f02c04f0e4d828075132b5c5b" translate="yes" xml:space="preserve">
          <source>ADDATTRS</source>
          <target state="translated">ADDATTRS</target>
        </trans-unit>
        <trans-unit id="d37db076be2c745cf98c9bb60cf88dbf2626e6b7" translate="yes" xml:space="preserve">
          <source>AM/PM symbols</source>
          <target state="translated">AM/PM符号</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="e95867ec94d8c275a2d1d9afac6a1d2ffb7fd390" translate="yes" xml:space="preserve">
          <source>ASCII (Char7)</source>
          <target state="translated">ASCII码 (Char7)</target>
        </trans-unit>
        <trans-unit id="2f934a30b8b57fba10b2b745dc320b339724b1b7" translate="yes" xml:space="preserve">
          <source>ASCII &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; are all numbers:</source>
          <target state="translated">ASCII &lt;code&gt;'0'&lt;/code&gt; 到 &lt;code&gt;'9'&lt;/code&gt; 都是数字：</target>
        </trans-unit>
        <trans-unit id="cae061a530cef71c477f974034de1fd1d9b43ecb" translate="yes" xml:space="preserve">
          <source>ATOM</source>
          <target state="translated">ATOM</target>
        </trans-unit>
        <trans-unit id="09116156619580f2fa8233d5bca8cf8644f9c359" translate="yes" xml:space="preserve">
          <source>Abandon evaluation of a statement after a breakpoint</source>
          <target state="translated">断点后放弃对语句的评估。</target>
        </trans-unit>
        <trans-unit id="c38c6ea6c11538ed82fd288d53c904871944106f" translate="yes" xml:space="preserve">
          <source>Abandons the current evaluation (only available when stopped at a breakpoint).</source>
          <target state="translated">放弃当前的评估(仅在断点处停止时可用)。</target>
        </trans-unit>
        <trans-unit id="f07c8230701366b843cd68845fafa5d65a1de2d9" translate="yes" xml:space="preserve">
          <source>About validity:</source>
          <target state="translated">关于有效性。</target>
        </trans-unit>
        <trans-unit id="05edf0d68cd3c84475eb832e7d283639e6bdeca9" translate="yes" xml:space="preserve">
          <source>Above, except that if the last line of the first argument stops at least one position before the first line of the second begins, these two lines are overlapped. For example:</source>
          <target state="translated">以上,但如果第一个参数的最后一行在第二个参数的第一行开始前至少一个位置停止,这两行就会重叠。例如:如果第一个参数的最后一行在第二个参数的第一行开始前至少停了一个位置,那么这两行就会重叠。</target>
        </trans-unit>
        <trans-unit id="ef82336eb495d4e5324f732f879ad3b7c7dd9b61" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a7dc34cb7ea60a4e1ddaf0a591cdafbc0e403cf" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2d972269377ed5359cdd2dcc108f0e3936d78b1" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88874691ade84811a148df43dee3e898c7993db4" translate="yes" xml:space="preserve">
          <source>Above, without dovetailing.</source>
          <target state="translated">以上,没有榫卯。</target>
        </trans-unit>
        <trans-unit id="ffc84c11cb600f5730c837f24132ad44932f0e4a" translate="yes" xml:space="preserve">
          <source>Above; if there is no overlap it &quot;dovetails&quot; the two</source>
          <target state="translated">以上;如果没有重叠,则将两者 &quot;对接&quot;</target>
        </trans-unit>
        <trans-unit id="2c7fe8b95b08b1e64796580d91044372f5603e8d" translate="yes" xml:space="preserve">
          <source>Absolute cursor movements</source>
          <target state="translated">绝对光标移动</target>
        </trans-unit>
        <trans-unit id="44530d6a736fdaae47537dfbad7f8dda6f90c1ca" translate="yes" xml:space="preserve">
          <source>Absolute intervals</source>
          <target state="translated">绝对区间</target>
        </trans-unit>
        <trans-unit id="05675a8df55f00a801d7267f15ceae258c856842" translate="yes" xml:space="preserve">
          <source>Absolute value.</source>
          <target state="translated">绝对值。</target>
        </trans-unit>
        <trans-unit id="be11481292069bbf4e5d32f6f22e3e0ba35a6c06" translate="yes" xml:space="preserve">
          <source>AbsoluteSeek</source>
          <target state="translated">AbsoluteSeek</target>
        </trans-unit>
        <trans-unit id="d18ae99534459c5602deda227d35dbfc2f1e9957" translate="yes" xml:space="preserve">
          <source>AbsoluteTime</source>
          <target state="translated">AbsoluteTime</target>
        </trans-unit>
        <trans-unit id="434cecc208a8b4bb275114bca8d90f1c47541833" translate="yes" xml:space="preserve">
          <source>AbsoluteTime is TAI, time as measured by a clock.</source>
          <target state="translated">AbsoluteTime是TAI,是由时钟测量的时间。</target>
        </trans-unit>
        <trans-unit id="667a8cf10407b19099b8b8a8c853533598abd554" translate="yes" xml:space="preserve">
          <source>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., &lt;code&gt;type T = ...&lt;/code&gt; to be accepted.) For example, the following are all valid implementations of the T above:</source>
          <target state="translated">抽象数据类型不仅可以用数据声明来实现，还可以用新类型和类型同义词来实现（但要限制类型同义词必须完全用eta来表示，例如，要接受的 &lt;code&gt;type T = ...&lt;/code&gt; ）。以下是上述T的所有有效实现：</target>
        </trans-unit>
        <trans-unit id="beb8fcf15e248371df65aec656beac0bfea7c0b8" translate="yes" xml:space="preserve">
          <source>Abstract representation of vertices.</source>
          <target state="translated">顶点的抽象表示。</target>
        </trans-unit>
        <trans-unit id="f326ddf7104d3df6fa13479c593c244c4623b73c" translate="yes" xml:space="preserve">
          <source>Abstract syntax definitions for Template Haskell.</source>
          <target state="translated">模板Haskell的抽象语法定义。</target>
        </trans-unit>
        <trans-unit id="71b7aef56068b7e751389cca7071da4abd7a1c80" translate="yes" xml:space="preserve">
          <source>Accept leading and trailing whitespace?</source>
          <target state="translated">接受前导空格和后导空格?</target>
        </trans-unit>
        <trans-unit id="95d34f3b555d7e27b1e17d75f2e37485b204658e" translate="yes" xml:space="preserve">
          <source>Accept leading whitespace?</source>
          <target state="translated">接受前导空格?</target>
        </trans-unit>
        <trans-unit id="bc52205c7ec889cf4cba765533bcd4e5d13957bc" translate="yes" xml:space="preserve">
          <source>Acceptable data</source>
          <target state="translated">可接受的数据</target>
        </trans-unit>
        <trans-unit id="3a8a3f0706793232d22f7100e8ea68a2faa1f5f0" translate="yes" xml:space="preserve">
          <source>Access to GHC's call-stack simulation</source>
          <target state="translated">访问GHC的调用堆栈模拟。</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="f9fce24b3c49b79586973841924c190bcf8769f7" translate="yes" xml:space="preserve">
          <source>Accessing arrays</source>
          <target state="translated">访问数组</target>
        </trans-unit>
        <trans-unit id="aff0bc5a5aaa0b373eac340c6aadb774a3a23049" translate="yes" xml:space="preserve">
          <source>Accessing the pointer to the array contents</source>
          <target state="translated">访问指向数组内容的指针。</target>
        </trans-unit>
        <trans-unit id="3efd139cf44f823a7b553a058c94da8090307f52" translate="yes" xml:space="preserve">
          <source>Accessors to GHC RTS flags. Descriptions of flags can be seen in &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC User's Guide&lt;/a&gt;, or by running RTS help message using &lt;code&gt;+RTS --help&lt;/code&gt;.</source>
          <target state="translated">GHC RTS标志的访问者。标志的描述可以在《&lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC用户指南》中找到&lt;/a&gt;，也可以通过使用 &lt;code&gt;+RTS --help&lt;/code&gt; 运行RTS帮助消息来看到。</target>
        </trans-unit>
        <trans-unit id="7edca54ae2bf350d49cd477266ad9dd7d55aedcd" translate="yes" xml:space="preserve">
          <source>According to [1]:</source>
          <target state="translated">根据[1]。</target>
        </trans-unit>
        <trans-unit id="2d6dfb6165d33d7dc1b66480f6a0d421d69dd337" translate="yes" xml:space="preserve">
          <source>According to the GMP documentation, the underlying function &lt;code&gt;mpz_nextprime()&lt;/code&gt; &quot;uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small.&quot;</source>
          <target state="translated">根据GMP文档，底层函数 &lt;code&gt;mpz_nextprime()&lt;/code&gt; &amp;ldquo;使用概率算法来识别素数。出于实际目的，这是足够的，复合传递的机会非常小。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a91ad95de89488856c8210673c103c15b4491b35" translate="yes" xml:space="preserve">
          <source>According to the rules above &lt;code&gt;X&lt;/code&gt; has a CUSK. Yet, the kind of &lt;code&gt;k&lt;/code&gt; is undetermined. It is thus quantified over, giving &lt;code&gt;X&lt;/code&gt; the kind &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">根据上面的规则， &lt;code&gt;X&lt;/code&gt; 有一个CUSK。但是， &lt;code&gt;k&lt;/code&gt; 的种类尚未确定。因此，它被量化，给 &lt;code&gt;X&lt;/code&gt; 表示所有 &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d5e0f0e68219f2793950ff4f739b0707416bc38" translate="yes" xml:space="preserve">
          <source>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level &lt;code&gt;forall&lt;/code&gt;, the kind variable was bound there, too. That is, in &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; was bound by the same &lt;code&gt;forall&lt;/code&gt; as the &lt;code&gt;a&lt;/code&gt;. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank &lt;code&gt;forall&lt;/code&gt;, include it explicitly.</source>
          <target state="translated">因此，在较高等级的环境中进行种类量化的规则已略有变化。在GHC 7中，如果第一次在非顶级 &lt;code&gt;forall&lt;/code&gt; 中绑定的变量的种类中提到了种类变量，则该种类变量也在那里绑定。即，在 &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt; 中， &lt;code&gt;k&lt;/code&gt; 用相同结合 &lt;code&gt;forall&lt;/code&gt; 作为 &lt;code&gt;a&lt;/code&gt; 。但是，在GHC 8中，类型中提到的所有种类变量都绑定在最外层。如果要在较高级别的 &lt;code&gt;forall&lt;/code&gt; 中绑定一个，请明确包括它。</target>
        </trans-unit>
        <trans-unit id="1bb0023c7c1fa4cd60dd0df32c9589498220f1d0" translate="yes" xml:space="preserve">
          <source>Accordingly, the type environment seen by &lt;code&gt;reify&lt;/code&gt; includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</source>
          <target state="translated">因此， &lt;code&gt;reify&lt;/code&gt; 看到的类型环境包括直到最前面的声明组末尾的所有顶级声明，但不包含更多顶级声明。</target>
        </trans-unit>
        <trans-unit id="82bedfe88009972d90237d52b7f414b23e6d5eb6" translate="yes" xml:space="preserve">
          <source>Accum</source>
          <target state="translated">Accum</target>
        </trans-unit>
        <trans-unit id="50b4f3d88aa3c9059e12c063f7c950d2f9b4b778" translate="yes" xml:space="preserve">
          <source>Accum operations</source>
          <target state="translated">累计业务</target>
        </trans-unit>
        <trans-unit id="cd4bf7ea6fd4060189e1e1baaa24ebb42d7660ad" translate="yes" xml:space="preserve">
          <source>AccumT</source>
          <target state="translated">AccumT</target>
        </trans-unit>
        <trans-unit id="50412c7500ef5d04ef8c2e37d60a2b1db38c9207" translate="yes" xml:space="preserve">
          <source>Accumulating maps</source>
          <target state="translated">累积地图</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="6347206826a895475f5f91774a889e897ffc7d63" translate="yes" xml:space="preserve">
          <source>Action &lt;code&gt;askString&lt;/code&gt; requests user to enter a string, and passes it to the continuation. &lt;code&gt;askString&lt;/code&gt; takes as a parameter a continuation taking a string parameter, and returning &lt;code&gt;IO ()&lt;/code&gt;. Compare its signature to &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; definition.</source>
          <target state="translated">动作 &lt;code&gt;askString&lt;/code&gt; 请求用户输入一个字符串，并将其传递给延续。 &lt;code&gt;askString&lt;/code&gt; 接受带有字符串参数并返回 &lt;code&gt;IO ()&lt;/code&gt; 的延续作为参数。将其签名与 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; 定义进行比较。</target>
        </trans-unit>
        <trans-unit id="a2f1b38e49644d95f7b46650e509c991d77060f8" translate="yes" xml:space="preserve">
          <source>Action to be executed</source>
          <target state="translated">有待执行的行动</target>
        </trans-unit>
        <trans-unit id="f5278c8649d913f335c11a62f866017db4429c6b" translate="yes" xml:space="preserve">
          <source>Actions on directories</source>
          <target state="translated">关于目录的行动</target>
        </trans-unit>
        <trans-unit id="696ed90b8efd0baea13c573b2e7c286d011d6b3c" translate="yes" xml:space="preserve">
          <source>Actions on files</source>
          <target state="translated">对档案采取的行动</target>
        </trans-unit>
        <trans-unit id="7083b72c48cfaf651eebc9aa10754311beefc8de" translate="yes" xml:space="preserve">
          <source>Activate cross-compilation mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;).</source>
          <target state="translated">激活交叉编译模式（请参阅&lt;a href=&quot;#hsc2hs-cross&quot;&gt;交叉编译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="583d9a705b86bbdfe3e1d9047b3ea1485ccadeeb" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; ,除非 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 引用符号链接。在这种情况下，将返回符号链接本身的 &lt;code&gt;FileStatus&lt;/code&gt; 信息，而不是它所指向的文件的信息。</target>
        </trans-unit>
        <trans-unit id="7d65523818024ea88107f6287927f036ddf6afd4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb8dd245b9cb57f179bf3b4b88042343c063795" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接（因此更改了链接本身的权限）。</target>
        </trans-unit>
        <trans-unit id="00b98c6571c6f97fdd25d5e837fe03213c325e22" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; ,除非 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 引用符号链接。在这种情况下，将返回符号链接本身的 &lt;code&gt;FileStatus&lt;/code&gt; 信息，而不是它所指向的文件的信息。</target>
        </trans-unit>
        <trans-unit id="cbcea92f66c4289d12fcd3463f6bb4e3fab3bda6" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接（因此更改了链接本身的权限）。</target>
        </trans-unit>
        <trans-unit id="6a6c3ff29419f1c7034849f1db0a070b794f9ad2" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">充当 &lt;code&gt;setFileSize&lt;/code&gt; ,但使用文件描述符而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49be567080d7b410e84b47729961520e4de920c4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b7078adb2d96736d050720e01d8ae82392b27c" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">充当 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; ,但使用文件描述符而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f40c80358e12a1e2aaf02b1148d6c20fcfd4ba45" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce17679436ea260fadec4591a677de22164d0f8" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;hsc2hs&lt;/code&gt; does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code.</source>
          <target state="translated">实际上， &lt;code&gt;hsc2hs&lt;/code&gt; 不会直接输出Haskell文件。它创建一个包含头文件的C程序，并自动进行编译和运行。该程序输出Haskell代码。</target>
        </trans-unit>
        <trans-unit id="4f047ea892e21f4553c30a3d6ef7ff19933e3fa6" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; handling abilities to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4c8a6633849d6709d07c9f3e63104f63a51077" translate="yes" xml:space="preserve">
          <source>Add a finalizer that will run in the Q monad after the current module has been type checked. This only makes sense when run within a top-level splice.</source>
          <target state="translated">增加一个定型器,它将在当前模块被类型检查后在Q单体中运行。这只有在顶层拼接中运行时才有意义。</target>
        </trans-unit>
        <trans-unit id="de0de177dcddf4173fd744c404b8ba61f96637ed" translate="yes" xml:space="preserve">
          <source>Add a finalizer to an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (GHC only). See &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; and &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; for more about finalizers.</source>
          <target state="translated">将终结器添加到 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; （仅适用于GHC）。有关&lt;a href=&quot;foreign-foreignptr&quot;&gt;终结&lt;/a&gt;器的更多信息，请参见Foreign.ForeignPtr和&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87eb63d6dca38f792891dceb6d3068ba951d4549" translate="yes" xml:space="preserve">
          <source>Add a line to the history unless it matches the previously recorded line.</source>
          <target state="translated">在历史记录中添加一行,除非它与之前记录的行相匹配。</target>
        </trans-unit>
        <trans-unit id="aaca03fa0d32c5a3d402a6fb5fcc0ded2bb915ec" translate="yes" xml:space="preserve">
          <source>Add a line to the history, and remove all previous entries which are the same as it.</source>
          <target state="translated">在历史记录中添加一行,并删除所有与之相同的先前条目。</target>
        </trans-unit>
        <trans-unit id="1d7fd5dfa46b0f645d5db42f20504f6c3caf7358" translate="yes" xml:space="preserve">
          <source>Add a trailing file path separator if one is not already present.</source>
          <target state="translated">如果没有尾部的文件路径分隔符,则添加一个尾部的文件路径分隔符。</target>
        </trans-unit>
        <trans-unit id="c5f1a8ca3a641a6b0ef6dbe461171ca7f604eb5a" translate="yes" xml:space="preserve">
          <source>Add additional top-level declarations. The added declarations will be type checked along with the current declaration group.</source>
          <target state="translated">添加额外的顶层声明。增加的声明将与当前声明组一起进行类型检查。</target>
        </trans-unit>
        <trans-unit id="cecd1aea8fe88c39fcc8f71681a3e087791c984b" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使已有扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34878ebb3f1e96601aafa913d00d7bd263cdc36c" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使存在扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89357b09335d29d387cf17547863b974b8decc59" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使已有扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e0f266814b31f57d2a4d4f2e065ebded03e6c4" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使存在扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88bd486d89c4fede722e2d2391a03c0fd1f29c23" translate="yes" xml:space="preserve">
          <source>Add entries to the Static Pointer Table</source>
          <target state="translated">向静态指针表添加条目。</target>
        </trans-unit>
        <trans-unit id="573b000c455e2582361374a0f2d5ce932b4443a5" translate="yes" xml:space="preserve">
          <source>Add months (clipped to last day), then add days</source>
          <target state="translated">添加月份(剪到最后一天),然后添加天数。</target>
        </trans-unit>
        <trans-unit id="11f2dacfd6ba9147a205050f051361aedae62583" translate="yes" xml:space="preserve">
          <source>Add months (rolling over to next month), then add days</source>
          <target state="translated">添加月份(滚动到下个月),然后添加天数。</target>
        </trans-unit>
        <trans-unit id="b015364a9bf90321fb61c3a98f1cdc612fdf7a8d" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.</source>
          <target state="translated">加月份,过了月份最后一天的天数剪到最后一天。例如,2005-01-30+1个月=2005-02-28。</target>
        </trans-unit>
        <trans-unit id="1ce9d4dd3c00c35abdeda445f12f814c42604388" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month rolling over to the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.</source>
          <target state="translated">加月份,超过当月最后一天的天数滚入下个月。例如,2005-01-30+1个月=2005-03-02。</target>
        </trans-unit>
        <trans-unit id="45aa2700c673ebfa0acebc5efea925be3a17cb6f" translate="yes" xml:space="preserve">
          <source>Add one to the given number using the state monad:</source>
          <target state="translated">使用状态单体在给定的数字上加一。</target>
        </trans-unit>
        <trans-unit id="ad0277793f67d2e393175d08b52db34131c5ef10" translate="yes" xml:space="preserve">
          <source>Add signed integers reporting overflow. First member of result is the sum truncated to an &lt;code&gt;Int#&lt;/code&gt;; second member is zero if the true sum fits in an &lt;code&gt;Int#&lt;/code&gt;, nonzero if overflow occurred (the sum is either too large or too small to fit in an &lt;code&gt;Int#&lt;/code&gt;).</source>
          <target state="translated">添加有符号整数报告溢出。结果的第一个成员是被截断为 &lt;code&gt;Int#&lt;/code&gt; 的总和；如果真正的总和适合 &lt;code&gt;Int#&lt;/code&gt; ，则第二个成员为零；如果发生溢出，则第二个成员为非零（总和太大或太小而无法适合 &lt;code&gt;Int#&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0fcd5e56314036018a9f0cac00e78ef55a1787b" translate="yes" xml:space="preserve">
          <source>Add some helper code that starts up and shuts down the Haskell RTS:</source>
          <target state="translated">增加一些启动和关闭Haskell RTS的助手代码。</target>
        </trans-unit>
        <trans-unit id="985586c7f3031f00d6269e644d3adc10e6ea07bc" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS option when running the program to see timing stats, which will help to tell you whether your program got faster by using more CPUs or not. If the user time is greater than the elapsed time, then the program used more than one CPU. You should also run the program without &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; for comparison.</source>
          <target state="translated">运行程序时添加 &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS选项以查看计时统计信息，这将有助于告诉您程序是否通过使用更多的CPU来加快速度。如果用户时间大于经过时间，则该程序使用了多个CPU。您还应该运行不带&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;的程序进行比较。</target>
        </trans-unit>
        <trans-unit id="343b1a229f6a10110d459f27e6591278cc0810b3" translate="yes" xml:space="preserve">
          <source>Add the global package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt;&lt;code&gt;-no-global-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the global package database should be loaded.</source>
          <target state="translated">将全局软件包数据库添加到当前堆栈的顶部。在&lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt; &lt;code&gt;-no-global-package-db&lt;/code&gt; &lt;/a&gt;之后，可以使用此选项来指定堆栈中应装入全局软件包数据库的位置。</target>
        </trans-unit>
        <trans-unit id="24dc1f25cbb780084188d4ff897a81d5104622f0" translate="yes" xml:space="preserve">
          <source>Add the global package db to the stack.</source>
          <target state="translated">将全局包db添加到栈中。</target>
        </trans-unit>
        <trans-unit id="fe975763255492732af82ca06ecb5eda5e5fa904" translate="yes" xml:space="preserve">
          <source>Add the package database ⟨file⟩ on top of the current stack.</source>
          <target state="translated">在当前堆栈的基础上添加包数据库⟨file⟩。</target>
        </trans-unit>
        <trans-unit id="6134bf2d1b2295efc8fa6b7e828ec4d22ba2e38e" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt;&lt;code&gt;-no-user-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the user&amp;rsquo;s package database should be loaded.</source>
          <target state="translated">将用户的软件包数据库添加到当前堆栈的顶部。可以在&lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt; &lt;code&gt;-no-user-package-db&lt;/code&gt; &lt;/a&gt;之后使用此选项，以指定堆栈中应装载用户的软件包数据库的位置。</target>
        </trans-unit>
        <trans-unit id="30d336c4a71c8e660819935f8d9b591c05d3839d" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package db to the stack.</source>
          <target state="translated">将用户的程序包db添加到堆栈中。</target>
        </trans-unit>
        <trans-unit id="f0c714c0819e829fa65b99edbce416f762fa1cd5" translate="yes" xml:space="preserve">
          <source>Add the user's package db to the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e83704b0c13e474a873f78d2503ff9d5058a2e" translate="yes" xml:space="preserve">
          <source>Add two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">添加两个 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="42140a41e27de0c19e086f86091f816243e8209e" translate="yes" xml:space="preserve">
          <source>Add two non-negative numbers. Errors out on overflow.</source>
          <target state="translated">加两个非负数。溢出时出错。</target>
        </trans-unit>
        <trans-unit id="e2856c1714aa39e0ac4378840b55f10a1492a342" translate="yes" xml:space="preserve">
          <source>Add two vectors element-wise.</source>
          <target state="translated">将两个向量元素相加。</target>
        </trans-unit>
        <trans-unit id="d21ffb0b2e887326fe4eaccd172c45b78c0f6321" translate="yes" xml:space="preserve">
          <source>Add unsigned integers reporting overflow. The first element of the pair is the result. The second element is the carry flag, which is nonzero on overflow. See also &lt;code&gt;plusWord2#&lt;/code&gt;.</source>
          <target state="translated">添加无符号整数报告溢出。该对中的第一个元素是结果。第二个元素是进位标志，溢出时非零。另请参见 &lt;code&gt;plusWord2#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4224f11c255c4982dd554902608b0a229771245f" translate="yes" xml:space="preserve">
          <source>Add unsigned integers, with the high part (carry) in the first component of the returned pair and the low part in the second component of the pair. See also &lt;code&gt;addWordC#&lt;/code&gt;.</source>
          <target state="translated">添加无符号整数，在返回的对的第一部分的高位（进位），在对的第二部分的低位。另请参见 &lt;code&gt;addWordC#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7bc6acbb336def5a2fed21adc84cf2eba8c8695" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th clipped to Feb 28th if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.</source>
          <target state="translated">加年份,匹配月份和日期,必要时将2月29日剪到2月28日。例如:2004-02-29+2年=2006-02-28。</target>
        </trans-unit>
        <trans-unit id="00a5a0f630ddf36709167f1d67babdf5ba438d3b" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th rolled over to Mar 1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.</source>
          <target state="translated">加年份,匹配月份和日期,必要时2月29日滚到3月1日。例如:2004-02-29+2年=2006-03-01。</target>
        </trans-unit>
        <trans-unit id="b78eacb0dc09583fbc5860e25537c0fbd17b2217" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the directory search list for &lt;code&gt;#include&lt;/code&gt; files</source>
          <target state="translated">将⟨dir⟩添加到 &lt;code&gt;#include&lt;/code&gt; 文件的目录搜索列表中</target>
        </trans-unit>
        <trans-unit id="3af3cf99d9bd473db5a8f166f611704c815a0e2a" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the list of directories searched for libraries</source>
          <target state="translated">将⟨dir⟩添加到搜索库的目录列表中。</target>
        </trans-unit>
        <trans-unit id="22a6f927fd045f27916f2841389ceb5619f2f520" translate="yes" xml:space="preserve">
          <source>Add ⟨file⟩ to the package db stack.</source>
          <target state="translated">将⟨file⟩添加到包中的db栈中。</target>
        </trans-unit>
        <trans-unit id="fd862d70f0a0e1b3f98b9cfd9a82f7a12719414c" translate="yes" xml:space="preserve">
          <source>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces the module to be loaded as byte-code.</source>
          <target state="translated">将&amp;ldquo;模块&amp;rdquo;添加到当前目标集中，然后执行重新加载。通常，将加载模块的预编译代码（如果可用），否则，模块将被编译为字节码。使用 &lt;code&gt;*&lt;/code&gt; 前缀将强制模块以字节码加载。</target>
        </trans-unit>
        <trans-unit id="d5c0d264184b29e5240b822c85a976bae183083b" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior.</source>
          <target state="translated">添加 &lt;code&gt;~&lt;/code&gt; 前面 &lt;code&gt;x&lt;/code&gt; 给出了经常偷懒行为。</target>
        </trans-unit>
        <trans-unit id="320069f40befc715427528e74af5fccc8e33c273" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;~&lt;/code&gt; 前面 &lt;code&gt;x&lt;/code&gt; 给出了经常偷懒行为。一般规则是，除非在 &lt;code&gt;~&lt;/code&gt; 禁用，否则我们在最外面的模式上添加一个隐式爆炸。</target>
        </trans-unit>
        <trans-unit id="d83058e490d2d8e416a97aa6b2da12e694c423cc" translate="yes" xml:space="preserve">
          <source>Adding a new kind of pure computation to an applicative functor.</source>
          <target state="translated">将一种新的纯计算添加到一个应用型漏子中。</target>
        </trans-unit>
        <trans-unit id="3e22ec51f6417f07ed5484e9c1f31e458834a41e" translate="yes" xml:space="preserve">
          <source>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</source>
          <target state="translated">添加类型签名会极大地改变结果! 这是一个比较反常的现象,值得注意。</target>
        </trans-unit>
        <trans-unit id="99385bb5ea9d50b509bba76a80c6d5cf02fdad9b" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">添加可选的&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;会在加载时将类型错误转换为警告。即使某些定义中存在类型错误，这也允许使用模块的正确部分。实际上，&amp;ldquo;-fdefer-type-errors&amp;rdquo;标志是在加载之前设置的，如果之前尚未设置，则在加载之后取消设置。有关进一步的动机和详细信息，请参见将&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;类型错误延迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f220c3a56210a9843d04890d61a40e6f8811dd" translate="yes" xml:space="preserve">
          <source>Addition of type-level naturals.</source>
          <target state="translated">增加类型级别的自然人。</target>
        </trans-unit>
        <trans-unit id="1d55c4561961d726b476a4d113ce4ac1271e1f3d" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">其他 &lt;code&gt;Integer&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="452f31724597f25fbb7b21a77fe4b6fccc9c9f11" translate="yes" xml:space="preserve">
          <source>Additional arguments to the pre-processor can be passed in using the &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt;&lt;code&gt;-optF ⟨option⟩&lt;/code&gt;&lt;/a&gt; option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt; &lt;code&gt;-optF ⟨option⟩&lt;/code&gt; &lt;/a&gt;选项将其他参数传递给预处理器。在三个标准输入和输出参数之后，这些参数将被馈送到命令行上的&amp;ldquo; cmd&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ba84f116cccb8aaddf33910d85c19273f9b5c33d" translate="yes" xml:space="preserve">
          <source>Additional conversion operations to &lt;code&gt;Integer&lt;/code&gt;</source>
          <target state="translated">附加到 &lt;code&gt;Integer&lt;/code&gt; 转换操作</target>
        </trans-unit>
        <trans-unit id="05dd2fde350699cecd8602584538e2a5301a7997" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得用于解构序列的其他功能。</target>
        </trans-unit>
        <trans-unit id="5cf2915563496656545c5e0888c8da42599eb5f8" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33810ea2f256277dbeeee354b4b9748e64cd54e7" translate="yes" xml:space="preserve">
          <source>Additional generic representation type constructors</source>
          <target state="translated">额外的通用表示类型构造器</target>
        </trans-unit>
        <trans-unit id="fefa8177b546e09c697ef3ccda7dfb9a8468dadd" translate="yes" xml:space="preserve">
          <source>Additional submodules</source>
          <target state="translated">其他子模块</target>
        </trans-unit>
        <trans-unit id="d5fc75cb6b2328204ad6e4f5c7b8aa1503974318" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;ghc-pkg list&lt;/code&gt; reminds you that there are broken packages and suggests &lt;code&gt;ghc-pkg check&lt;/code&gt;, which displays more information about the nature of the failure:</source>
          <target state="translated">此外， &lt;code&gt;ghc-pkg list&lt;/code&gt; 会提醒您有损坏的软件包，并建议 &lt;code&gt;ghc-pkg check&lt;/code&gt; ，它显示有关故障性质的更多信息：</target>
        </trans-unit>
        <trans-unit id="4dc57812bc7acb080b8b1b3c9a8dc29f687921a8" translate="yes" xml:space="preserve">
          <source>Additionally, any files specified with &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; flags will be read after the standard files, allowing the use of custom .ghci files.</source>
          <target state="translated">此外，将在标准文件之后读取用&lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt;标志指定的所有文件，从而允许使用自定义.ghci文件。</target>
        </trans-unit>
        <trans-unit id="8273902569bf382d8f68303982acb32861c6cbb8" translate="yes" xml:space="preserve">
          <source>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</source>
          <target state="translated">此外,在函数定义中,通过匹配前面的策源地参数所绑定的变量可以在后面的参数中使用视图模式表达式。</target>
        </trans-unit>
        <trans-unit id="f89673843f1be6757860a64501f5bc027e357960" translate="yes" xml:space="preserve">
          <source>Additionally, the following flags are accepted by &lt;code&gt;ghc-pkg&lt;/code&gt;:</source>
          <target state="translated">此外， &lt;code&gt;ghc-pkg&lt;/code&gt; 接受以下标志：</target>
        </trans-unit>
        <trans-unit id="6098dd57b05f9b5adb478e7eb1c70e1499221dae" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea07a4f598cd1862ca91a8d811d4455a836c0db0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;Issue #10826&lt;/a&gt; for details.</source>
          <target state="translated">此外，禁止使用&lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;注释&lt;/a&gt;，因为这样可以绕过Safe Haskell限制。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;问题＃10826&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba7d071e5cf6b03c15819e3ffdf6a64a0ef17bfa" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduce memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">此外,这种实现将位图放在树叶中。它们的大小是机器字的自然大小(32位或64位),并大大减少了密集集的内存占用和执行时间,例如,许多值很可能相互靠近的集。渐近论不受这种优化的影响。</target>
        </trans-unit>
        <trans-unit id="9433cfd346f8c54358a2f7edce3cb77efb148924" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduces the memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">此外,这种实现将位图放在树叶中。它们的大小是机器字的自然大小(32位或64位),并大大减少了密集集的内存占用和执行时间,例如,许多值很可能相互靠近的集。渐近论不受这种优化的影响。</target>
        </trans-unit>
        <trans-unit id="1bf2d76785594ad916dd8c2e5e99f51e13db7893" translate="yes" xml:space="preserve">
          <source>Additionally, unless &lt;code&gt;-hide-all-packages&lt;/code&gt; is specified &lt;code&gt;ghc&lt;/code&gt; will also look for the package environment in the following locations:</source>
          <target state="translated">另外，除非指定了 &lt;code&gt;-hide-all-packages&lt;/code&gt; ，否则 &lt;code&gt;ghc&lt;/code&gt; 还将在以下位置查找软件包环境：</target>
        </trans-unit>
        <trans-unit id="2aa983ad06fdb2dac09d7b6232814da70747e9ee" translate="yes" xml:space="preserve">
          <source>Additive</source>
          <target state="translated">Additive</target>
        </trans-unit>
        <trans-unit id="0d42cec26dbc762aafe43e05a50f969d0b7505d7" translate="yes" xml:space="preserve">
          <source>Addr</source>
          <target state="translated">Addr</target>
        </trans-unit>
        <trans-unit id="e78f3509a8a9919b87bca8268eb67a1992a398dd" translate="yes" xml:space="preserve">
          <source>Addr#</source>
          <target state="translated">Addr#</target>
        </trans-unit>
        <trans-unit id="9693f97edb3f213e60bf04638a2964d95c0a8e70" translate="yes" xml:space="preserve">
          <source>AddrRep</source>
          <target state="translated">AddrRep</target>
        </trans-unit>
        <trans-unit id="e1bcdaba63c737122befb027c96355aebd956e8a" translate="yes" xml:space="preserve">
          <source>Address range information necessary for efficient lookup in debug information.</source>
          <target state="translated">调试信息中有效查找所需的地址范围信息。</target>
        </trans-unit>
        <trans-unit id="2bea019ec2ca9ce8cba25638cef6e4ebf912a40d" translate="yes" xml:space="preserve">
          <source>Adds a core plugin to the compilation pipeline.</source>
          <target state="translated">为编译管道添加一个核心插件。</target>
        </trans-unit>
        <trans-unit id="f141d838836915fbdfd335ae66e883d10b2bee58" translate="yes" xml:space="preserve">
          <source>Adds a location description and maybe a file path and file handle to an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;. If any of the file handle or file path is not given the corresponding value in the &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; remains unaltered.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 添加位置描述，可能还添加文件路径和文件句柄。如果未提供任何文件句柄或文件路径，则 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中的相应值将保持不变。</target>
        </trans-unit>
        <trans-unit id="14518bca79b10a8d6a6afac2dc2d74ba60c9789a" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">向所有&lt;em&gt;呼叫站点&lt;/em&gt;添加自动 &lt;code&gt;SCC&lt;/code&gt; 注释。当使用概要分析来生成堆栈跟踪时，这特别有用。有关更多详细信息，请参见函数&lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;或&lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS标志（&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;黑客，调试器和过度关注的灵魂的RTS选项&lt;/a&gt;）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4dd58b10c5df43531b5419e150eab3428f317659" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fd2a08806dfb482db344074817b7f6e5c01441" translate="yes" xml:space="preserve">
          <source>Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt; or &lt;code&gt;hide&lt;/code&gt; command, unless it is overridden by a later &lt;code&gt;--package-db&lt;/code&gt;, &lt;code&gt;--user&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; option.</source>
          <target state="translated">将&amp;ldquo; file&amp;rdquo;添加到软件包数据库堆栈中。此外，⟨file⟩也将是由一个修改了数据库 &lt;code&gt;register&lt;/code&gt; ， &lt;code&gt;unregister&lt;/code&gt; ， &lt;code&gt;expose&lt;/code&gt; 或 &lt;code&gt;hide&lt;/code&gt; 命令，除非它受到一个后覆盖 &lt;code&gt;--package-db&lt;/code&gt; ， &lt;code&gt;--user&lt;/code&gt; 或 &lt;code&gt;--global&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6b704187610182fd9bd374b8590aaa1ef187a2e9" translate="yes" xml:space="preserve">
          <source>Adjacency list representation of a graph, mapping each vertex to its list of successors.</source>
          <target state="translated">图的邻接列表表示,将每个顶点映射到它的后继列表。</target>
        </trans-unit>
        <trans-unit id="b54a06cdf203c292a9600afc8f4877852335267a" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array</source>
          <target state="translated">调整阵列的大小</target>
        </trans-unit>
        <trans-unit id="90ae8e7c61f1d870875dbba75294d0ee30d78240" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array in the given pool.</source>
          <target state="translated">调整给定池中数组的大小。</target>
        </trans-unit>
        <trans-unit id="0f13658ace97bdbb476bffd14472478597823d14" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array including an extra position for the end marker.</source>
          <target state="translated">调整数组的大小,包括结束标记的额外位置。</target>
        </trans-unit>
        <trans-unit id="8f64f3b151b220c78b035080db416951b86c9133" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array with an end marker in the given pool.</source>
          <target state="translated">在给定的池子中调整一个带有结束标记的数组的大小。</target>
        </trans-unit>
        <trans-unit id="22c056b1203c0d0dbe4975dcb12541b083750969" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size of the required type.</source>
          <target state="translated">将池中元素的存储区域调整为所需类型的给定大小。</target>
        </trans-unit>
        <trans-unit id="7b78d30e021c76a4d2cd9b8d7c83d0401635e998" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size.</source>
          <target state="translated">将池中元素的存储区域调整为给定大小。</target>
        </trans-unit>
        <trans-unit id="483b6c748f94c6096a813d4e1202da0abec1197a" translate="yes" xml:space="preserve">
          <source>Administration: errors, locations and IO</source>
          <target state="translated">管理:错误、位置和IO</target>
        </trans-unit>
        <trans-unit id="e796c7c730ff7dabd900a81e118126dd63495d56" translate="yes" xml:space="preserve">
          <source>Advance a pointer into an array by the given number of elements</source>
          <target state="translated">将指针按给定的元素数推进到数组中。</target>
        </trans-unit>
        <trans-unit id="260fc09cb1bd463d426655ad971e67b80c27f04d" translate="yes" xml:space="preserve">
          <source>Advances the given address by the given offset in bytes.</source>
          <target state="translated">将给定的地址以字节为单位向前推进。</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="1f3b7ab3442ed00e15ed0541b2686cab5245f648" translate="yes" xml:space="preserve">
          <source>Advice parameter for &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; 操作的Advice参数。</target>
        </trans-unit>
        <trans-unit id="641791da837ed200728e9e50c3a7a04bddd511ba" translate="yes" xml:space="preserve">
          <source>AdviceDontNeed</source>
          <target state="translated">AdviceDontNeed</target>
        </trans-unit>
        <trans-unit id="ea4292d4f711440375ee49d21953e80b5e52f970" translate="yes" xml:space="preserve">
          <source>AdviceNoReuse</source>
          <target state="translated">AdviceNoReuse</target>
        </trans-unit>
        <trans-unit id="74d7e2511ff18bffd6e754606fb5eef4017e56ae" translate="yes" xml:space="preserve">
          <source>AdviceNormal</source>
          <target state="translated">AdviceNormal</target>
        </trans-unit>
        <trans-unit id="81df8c0f743f838767314197c10a01806cad2ee1" translate="yes" xml:space="preserve">
          <source>AdviceRandom</source>
          <target state="translated">AdviceRandom</target>
        </trans-unit>
        <trans-unit id="ccfd39209774bc0bd28a1949494a57c9a708ab38" translate="yes" xml:space="preserve">
          <source>AdviceSequential</source>
          <target state="translated">AdviceSequential</target>
        </trans-unit>
        <trans-unit id="42c90330aa2e9c8f79a56b93334f2cee6565ec83" translate="yes" xml:space="preserve">
          <source>AdviceWillNeed</source>
          <target state="translated">AdviceWillNeed</target>
        </trans-unit>
        <trans-unit id="ed7d231de2d15caa7608638f366b36b040083e12" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;ldquo;</source>
          <target state="translated">在&amp;ldquo;对于每个类别约束 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; &amp;rdquo;之后，添加&amp;ldquo;或每个量化的约束 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="962b02c7a62413f64f2ece2fa9269c59c618e145" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0f8ce28395257ee72603489cfcfd39f2ac90c3" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, the current context is set to:</source>
          <target state="translated">一个后&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令，当前上下文被设置为：</target>
        </trans-unit>
        <trans-unit id="07383eb16f1578a01af993380c0758317c77da4a" translate="yes" xml:space="preserve">
          <source>After analysing this declaration, GHC will discover that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; can be kind-polymorphic, with &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;c :: k2&lt;/code&gt;. We thus infer the following kind:</source>
          <target state="translated">在分析了此声明之后，GHC将发现 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 可以是种类多态的，具有 &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; 和 &lt;code&gt;c :: k2&lt;/code&gt; 。因此，我们推断出以下几种：</target>
        </trans-unit>
        <trans-unit id="43eb39a82773f2a643009be434c6a85d6547dd46" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 与原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 共享底层字节缓冲区。因此，用C或使用poke 修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 会导致 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的内容更改，从而破坏引用透明性。通过共享创建的其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; （例如通过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 生成的那些）也将反映这些更改。修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 将破坏引用透明性。为了避免这种情况，请使用 &lt;code&gt;useAsCString&lt;/code&gt; ，它会复制原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f34b11d2d5cf5b9fa61ceda45199281dda85ee6f" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 与原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 共享基础字节缓冲区。从而修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; ，用C或使用poke CStringLen会导致 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的内容发生更改，从而破坏了引用透明性。通过共享创建的其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; （例如通过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 生成的那些）也将反映这些更改。修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 将破坏引用透明性。为避免这种情况，请使用 &lt;code&gt;useAsCStringLen&lt;/code&gt; ，它会复制原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82a058ea48e1049a3153e84c6e2e32200ba90877" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb3d574900104a74408c8731d7eda427531f654" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6923804e768f3da3c4e34a50b537baa1cecaa53f" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;f&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">扩展同义词后， &lt;code&gt;f&lt;/code&gt; 具有法定（GHC中）类型：</target>
        </trans-unit>
        <trans-unit id="e94a959addb55b4d2ce5f3c538f5e0b4451a9198" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;foo&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">扩展同义词后， &lt;code&gt;foo&lt;/code&gt; 具有法定（GHC中）类型：</target>
        </trans-unit>
        <trans-unit id="06d0d43c4a9a4534a91da534db4a4831101176f7" translate="yes" xml:space="preserve">
          <source>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn&amp;rsquo;t detected simply by kind checking:</source>
          <target state="translated">扩展类型同义词后，GHC对类型进行有效性检查，查找以下不能通过类型检查简单检测到的格式错误：</target>
        </trans-unit>
        <trans-unit id="0449647915398655b7a878613d9a9af3cfaf3fda" translate="yes" xml:space="preserve">
          <source>After running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action there are three possibilities for what comes next:</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作后，接下来可能发生三种情况：</target>
        </trans-unit>
        <trans-unit id="f4bbb708c55cef458c6b0bed0fa5801c96a405ff" translate="yes" xml:space="preserve">
          <source>After starting &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8861d66315ce749c004b7e24b472e22e1345c7" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve finished invoking our Haskell functions, we can call &lt;code&gt;hs_exit()&lt;/code&gt;, which terminates the RTS.</source>
          <target state="translated">调用完Haskell函数后，可以调用 &lt;code&gt;hs_exit()&lt;/code&gt; 来终止RTS。</target>
        </trans-unit>
        <trans-unit id="2fa08ab3cb629ae0630f4dccf9a63999f34ccc01" translate="yes" xml:space="preserve">
          <source>Again, if &lt;code&gt;C&lt;/code&gt; contains no class methods, the instance context will be redundant, so GHC will instead generate &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt;.</source>
          <target state="translated">同样，如果 &lt;code&gt;C&lt;/code&gt; 不包含类方法，则实例上下文将是多余的，因此GHC会生成 &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80611142c1da75771c803bc1306de5dd47e954cb" translate="yes" xml:space="preserve">
          <source>Alexander Berntsen 2014</source>
          <target state="translated">Alexander Berntsen 2014年</target>
        </trans-unit>
        <trans-unit id="0f9d329fecfee776bcba1d14e6bca4840fae8ece" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;#12717&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70df90ba28c32aa3934681405622b497740ae050" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Issue #12717&lt;/a&gt;</source>
          <target state="translated">签名中指定的代数数据类型不能使用模式同义词来实现。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;问题＃12717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a995fe628ebfb0ac7cc0c0b98a66a1d60308575a" translate="yes" xml:space="preserve">
          <source>Algebraic properties:</source>
          <target state="translated">代数性质。</target>
        </trans-unit>
        <trans-unit id="00fe36cee0a001e71e45449595c2a673824d1b79" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="308d7f644aaa00a5665368fb713217dcb84b51ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="9cdf35744dcefb67854cfd9303dbe37b27518062" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="107c8c77b99ddea22e0d4483b070454ccd2a71ae" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="23f78602884a7b538f91b984806e37d22c871f3b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="0c1b2d82c320084f6a2ecaa9b2bb2ee948dec368" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="60cc1b8e67da53fd1ea040fa3bfb7016cc924b7f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="dc75b7adfd72cadf1d0c28de54a66b5886fa0528" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt;. Returns True if its parameter is 1# and False if it is 0#.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt; 的别名。如果参数为1＃，则返回True；如果参数为0＃，则返回False。</target>
        </trans-unit>
        <trans-unit id="b5417a2480ca72a7d0a8e8c2b271f31533da5d02" translate="yes" xml:space="preserve">
          <source>Align functions at given boundary.</source>
          <target state="translated">在给定的边界对准函数。</target>
        </trans-unit>
        <trans-unit id="309cb56d1cbd5360ce8e4fa89688161c57474b68" translate="yes" xml:space="preserve">
          <source>Align functions to multiples of the given value. Only valid values are powers of two.</source>
          <target state="translated">将函数对齐到给定值的倍数。只有有效值是二的幂。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="be7cbc9171e2709ef932f92879b2fa92b735095e" translate="yes" xml:space="preserve">
          <source>All are based directly on their similarly-named &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; counterparts.</source>
          <target state="translated">所有这些都直接基于其类似名称的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 副本。</target>
        </trans-unit>
        <trans-unit id="a6cd8f76353135f8eca4c08f035ed3722d4ad99a" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where &lt;code&gt;n&lt;/code&gt; is the number of bits in the type.</source>
          <target state="translated">所有算术均以2 ^ n为模，其中 &lt;code&gt;n&lt;/code&gt; 是类型中的位数。</target>
        </trans-unit>
        <trans-unit id="5c996c3cc62dedfc6f0f7accd3202c5cbe66b76c" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; raise an error on negative arguments.</source>
          <target state="translated">所有算术均以2 ^ n为模，其中n是类型中的位数。这方面的一个非显而易见的后果是 &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; 应该&lt;em&gt;不是&lt;/em&gt;消极的论点引发错误。</target>
        </trans-unit>
        <trans-unit id="0cb70b7dc62c8932f9a5fdafd462f49e1a9ac846" translate="yes" xml:space="preserve">
          <source>All data that is read will be decoded as UTF-8.</source>
          <target state="translated">所有被读取的数据将被解码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="63944b6a06201ae38dfb9a4d0c8e79dcd222ae47" translate="yes" xml:space="preserve">
          <source>All formats</source>
          <target state="translated">所有格式</target>
        </trans-unit>
        <trans-unit id="3da05872e313e33621f92f71c99a716c25b4c06e" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell与外语之间的所有编组最终归结为将Haskell数据结构转换为外语对应数据结构的二进制表示形式，反之亦然。为了在Haskell中编码此编组，必须操纵存储在非结构化存储块中的原始数据类型。 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类有助于在实例化它的所有类型上进行此操作，这些类型是Haskell的标准基本类型，固定大小的 &lt;code&gt;Int&lt;/code&gt; 类型（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ），固定大小的 &lt;code&gt;Word&lt;/code&gt; 类型（ &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ）， &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; ，各类从&lt;a href=&quot;foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cffe145534643d9c1142d3476b91e58e7cb0edd7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell与外语之间的所有编组最终归结为将Haskell数据结构转换为外语对应数据结构的二进制表示形式，反之亦然。为了在Haskell中编码此编组，必须操纵存储在非结构化存储块中的原始数据类型。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类有助于在实例化它的所有类型上进行此操作，这些类型是Haskell的标准基本类型，固定大小的 &lt;code&gt;Int&lt;/code&gt; 类型（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; ），固定大小的 &lt;code&gt;Word&lt;/code&gt; 类型（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; ）， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; ，各类从&lt;a href=&quot;../base-4.13.0.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ce405ee1194b3ce0523423637671f91407135a7" translate="yes" xml:space="preserve">
          <source>All marshalling between Haskell and a foreign language ultimately boils down to translating Haskell data structures into the binary representation of a corresponding data structure of the foreign language and vice versa. To code this marshalling in Haskell, it is necessary to manipulate primitive data types stored in unstructured memory blocks. The class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; facilitates this manipulation on all types for which it is instantiated, which are the standard basic types of Haskell, the fixed size &lt;code&gt;Int&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;), the fixed size &lt;code&gt;Word&lt;/code&gt; types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt;, all types from &lt;a href=&quot;../base-4.14.1.0/foreign-c-types&quot;&gt;Foreign.C.Types&lt;/a&gt;, as well as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd19ff0d458c57b97295494e47d40838d1850a87" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 的所有直接&lt;em&gt;安全进口&lt;/em&gt;均受C信任</target>
        </trans-unit>
        <trans-unit id="1ef5ded9d2dd453646aebbde6bc1e77e258d91ac" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct imports are trusted by C</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 的所有直接进口均受C信任</target>
        </trans-unit>
        <trans-unit id="ef4a7530bfdff42a708223449593af312fe8738b" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s direct safe imports are trusted by C</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 的所有直接安全进口均受C信任</target>
        </trans-unit>
        <trans-unit id="a5408f6679dcddf6cf10903e40871b1051e396da" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct &lt;em&gt;safe imports&lt;/em&gt; are trusted by C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797d2c20c300f4f341eb1a8bbafe469bcca673e" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct imports are trusted by C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1624840fe46a64a971c34a839de2cd6166d7cc15" translate="yes" xml:space="preserve">
          <source>All of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s direct safe imports are trusted by C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26ff1c50009409908cc1dc4184f2fa494a5bb4b" translate="yes" xml:space="preserve">
          <source>All of M&amp;rsquo;s direct imports are trusted by C</source>
          <target state="translated">M的所有直接进口均受C信任</target>
        </trans-unit>
        <trans-unit id="6bbff3b9a2342fa6a7328cc64d9d064b0c59177f" translate="yes" xml:space="preserve">
          <source>All of the following are permissible:</source>
          <target state="translated">以下所有情况都是允许的:</target>
        </trans-unit>
        <trans-unit id="07a302413e8b75e6da91c912ef456b8df520f40e" translate="yes" xml:space="preserve">
          <source>All of the functions fail on an empty queue.</source>
          <target state="translated">所有的函数在空队列上都失败了。</target>
        </trans-unit>
        <trans-unit id="459b9c097e1f48899719948d13092addea8d683b" translate="yes" xml:space="preserve">
          <source>All of the heaps are defined to be non-empty, which speeds up the merge functions.</source>
          <target state="translated">所有的堆都被定义为非空,这加快了合并函数的速度。</target>
        </trans-unit>
        <trans-unit id="a6d572146a4416cc21d822c5b9122cc28fefd404" translate="yes" xml:space="preserve">
          <source>All of the monad transformers except &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; are functors on the category of monads: in addition to defining a mapping of monads, they also define a mapping from transformations between base monads to transformations between transformed monads, called &lt;code&gt;map&lt;/code&gt;&lt;em&gt;XXX&lt;/em&gt;&lt;code&gt;T&lt;/code&gt;. Thus given a monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;, the combinator &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; constructs a monad transformation</source>
          <target state="translated">以外的所有单子变压器 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 是单子上的类别函子：在除了定义单子的映射，它们还限定从基座单子之间的变换来变换单子之间的变换的映射，称为 &lt;code&gt;map&lt;/code&gt; &lt;em&gt;XXX &lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 。因此，给定一个monad变换 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; &amp;gt; N a，组合器mapStateT构造一个monad变换</target>
        </trans-unit>
        <trans-unit id="9ff4cf753e2cbc29b4117cb6c949a3dcfef8b652" translate="yes" xml:space="preserve">
          <source>All of the single-parameter functions for decoding bytestrings encoded in one of the Unicode Transformation Formats (UTF) operate in a &lt;em&gt;strict&lt;/em&gt; mode: each will throw an exception if given invalid input.</source>
          <target state="translated">用于解码以Unicode转换格式（UTF）之一编码的字节串的所有单参数函数均以&lt;em&gt;严格&lt;/em&gt;模式运行：如果输入无效，则每个函数都会引发异常。</target>
        </trans-unit>
        <trans-unit id="c1146584e3cb478bf3265f7c6f72fec49b0f80d2" translate="yes" xml:space="preserve">
          <source>All of the type variables mentioned are bound by the class declaration, and none is locally quantified. Examples:</source>
          <target state="translated">所提到的所有类型变量都是由类声明约束的,没有一个是局部量化的。举例说明。</target>
        </trans-unit>
        <trans-unit id="d683e41b047bddec21ed6f58cd355ac5da8d7ca4" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">全部放在一行中，忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 并将显式换行（ &lt;code&gt;$$&lt;/code&gt; ）转换为空格。</target>
        </trans-unit>
        <trans-unit id="d04619ab3f8398e576bbe00b547d8d28a39b93a6" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">全部放在一行中，忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 并将显式换行（ &lt;code&gt;$$&lt;/code&gt; ）转换为空格。</target>
        </trans-unit>
        <trans-unit id="8734d083f84649d66cdee2cb45a731a5deb1ea31" translate="yes" xml:space="preserve">
          <source>All on one line, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored and explicit new lines (&lt;code&gt;$$&lt;/code&gt;) are turned into spaces.</source>
          <target state="translated">全部放在一行中，忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 并将显式换行（ &lt;code&gt;$$&lt;/code&gt; ）转换为空格。</target>
        </trans-unit>
        <trans-unit id="9bd92a106884eb39d74915dc625e8a2eeded96d9" translate="yes" xml:space="preserve">
          <source>All other type errors are reported immediately, and cannot be deferred; for example, an ill-kinded type signature, an instance declaration that is non-terminating or ill-formed, a type-family instance that does not obey the declared injectivity constraints, etc etc.</source>
          <target state="translated">所有其他类型错误都会被立即报告,不能推迟;例如,一个错误的类型签名,一个非终结或错误的实例声明,一个不服从声明的注入性约束的类型家族实例,等等等等。</target>
        </trans-unit>
        <trans-unit id="100083b95ff688c1be21a4288351839a84f80d50" translate="yes" xml:space="preserve">
          <source>All previously loaded modules, except package modules, are forgotten. The new set of modules is known as the target set. Note that &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be used without any arguments to unload all the currently loaded modules and bindings.</source>
          <target state="translated">除软件包模块外，所有先前加载的模块都将被遗忘。新的模块集称为目标集。注意&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;可以不带任何参数地使用，以卸载当前所有已加载的模块和绑定。</target>
        </trans-unit>
        <trans-unit id="6827c99a0f2492e5c37fe7d9438e06c6b6af14e1" translate="yes" xml:space="preserve">
          <source>All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly. (That is, if A imports B, which imports C, then C&amp;rsquo;s rules are in force when compiling A.) The situation is very similar to that for instance declarations.</source>
          <target state="translated">所有规则都是从模块隐式导出的，因此在直接或间接导入定义规则的模块的任何模块中都有效。（也就是说，如果A导入了B，而C则导入了C，则在编译A时C的规则将生效。）这种情况与实例声明的情况非常相似。</target>
        </trans-unit>
        <trans-unit id="7dbe1320fffcde509144ec4167268e2f24928720" translate="yes" xml:space="preserve">
          <source>All special processing is triggered by the &lt;code&gt;#&lt;/code&gt; operator. To output a literal &lt;code&gt;#&lt;/code&gt;, write it twice: &lt;code&gt;##&lt;/code&gt;. Inside string literals and comments &lt;code&gt;#&lt;/code&gt; characters are not processed.</source>
          <target state="translated">所有特殊处理均由 &lt;code&gt;#&lt;/code&gt; 运算符触发。要输出文字 &lt;code&gt;#&lt;/code&gt; ，请编写两次： &lt;code&gt;##&lt;/code&gt; 。内部字符串文字和注释不处理 &lt;code&gt;#&lt;/code&gt; 个字符。</target>
        </trans-unit>
        <trans-unit id="e754d606e9f071f8917ddf678a8be51138905754" translate="yes" xml:space="preserve">
          <source>All storage allocated by functions that allocate based on a &lt;em&gt;size in bytes&lt;/em&gt; must be sufficiently aligned for any of the basic foreign types that fits into the newly allocated storage. All storage allocated by functions that allocate based on a specific type must be sufficiently aligned for that type. Array allocation routines need to obey the same alignment constraints for each array element.</source>
          <target state="translated">由基于&lt;em&gt;字节大小&lt;/em&gt;分配的函数分配的所有存储，必须针对适合新分配的存储的任何基本外部类型进行充分对齐。由基于特定类型分配的功能分配的所有存储必须针对该类型充分对齐。数组分配例程需要遵守每个数组元素的相同对齐约束。</target>
        </trans-unit>
        <trans-unit id="0f41064ade872ca46f2cce357b6f0f602bb6c9f2" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt;, including a header.</source>
          <target state="translated">所有的 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; ，包括标题。</target>
        </trans-unit>
        <trans-unit id="8191f2288d30ed04618d8a7f6947ee07d2f827e8" translate="yes" xml:space="preserve">
          <source>All the classes &lt;code&gt;Ci&lt;/code&gt; are standard.</source>
          <target state="translated">所有的 &lt;code&gt;Ci&lt;/code&gt; 类都是标准的。</target>
        </trans-unit>
        <trans-unit id="27b13a294aaa6ffa8890f192e7f1dee01b865654" translate="yes" xml:space="preserve">
          <source>All the instance does is apply and remove the &lt;code&gt;newtype&lt;/code&gt; constructor. It is particularly galling that, since the constructor doesn&amp;rsquo;t appear at run-time, this instance declaration defines a dictionary which is &lt;em&gt;wholly equivalent&lt;/em&gt; to the &lt;code&gt;Int&lt;/code&gt; dictionary, only slower!</source>
          <target state="translated">实例所做的只是应用并删除 &lt;code&gt;newtype&lt;/code&gt; 构造函数。特别令人鼓舞的是，由于构造函数不会在运行时出现，因此该实例声明定义了一个与 &lt;code&gt;Int&lt;/code&gt; 字典&lt;em&gt;完全等效&lt;/em&gt;的字典，只是速度较慢！</target>
        </trans-unit>
        <trans-unit id="3560dcf83b04004c14094e6b1d3cd4500f468374" translate="yes" xml:space="preserve">
          <source>All these features are described in the papers mentioned earlier.</source>
          <target state="translated">所有这些特点在前面提到的论文中都有描述。</target>
        </trans-unit>
        <trans-unit id="9f289fff56ff75be648fe75fd05b62eefadc5aae" translate="yes" xml:space="preserve">
          <source>All these features are enabled by default if the &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; extension is enabled. The types and more detailed examples on how to use comprehensions are explained in the previous chapters &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt; and &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;. In general you just have to replace the type &lt;code&gt;[a]&lt;/code&gt; with the type &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; for monad comprehensions.</source>
          <target state="translated">如果启用了&lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt;扩展，则默认情况下将启用所有这些功能。有关如何使用理解的类型和更详细的示例，在前面的几章&amp;ldquo; &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;通用（类似于SQL）的列表理解&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;并行列表理解&amp;rdquo;中&lt;/a&gt;都有介绍。通常，对于monad理解，只需将类型 &lt;code&gt;[a]&lt;/code&gt; 替换为 &lt;code&gt;Monad m =&amp;gt; m a&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f320750508ae8a4bdfcecfb3e8588bc22cc54930" translate="yes" xml:space="preserve">
          <source>All these functions evaluate the message completely before printing it; so if the message is not fully defined, none of it will be printed.</source>
          <target state="translated">所有这些函数在打印之前都会对消息进行完整的评估,所以如果消息没有完全定义,则不会打印。</target>
        </trans-unit>
        <trans-unit id="fcd3e8296e242f3b3d9e914ad0a98eb399c9d926" translate="yes" xml:space="preserve">
          <source>All these primitive data types and operations are exported by the library &lt;code&gt;GHC.Prim&lt;/code&gt;, for which there is detailed online documentation &amp;lt;GHC.Prim.&amp;gt;. (This documentation is generated from the file &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt;.)</source>
          <target state="translated">所有这些原始数据类型和操作都由 &lt;code&gt;GHC.Prim&lt;/code&gt; 库导出，该库具有详细的在线文档&amp;lt;GHC.Prim。&amp;gt;。（此文档是从文件 &lt;code&gt;compiler/prelude/primops.txt.pp&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="11d822b519b4d27d4c90f7025aa2f37e057b1573" translate="yes" xml:space="preserve">
          <source>All this applies to constructors declared using the syntax of &lt;a href=&quot;#existential-with-context&quot;&gt;Existentials and type classes&lt;/a&gt;. For example, the &lt;code&gt;NumInst&lt;/code&gt; data type above could equivalently be declared like this:</source>
          <target state="translated">所有这些都适用于使用&lt;a href=&quot;#existential-with-context&quot;&gt;Existentials和类型类&lt;/a&gt;的语法声明的构造函数。例如，上面的 &lt;code&gt;NumInst&lt;/code&gt; 数据类型可以这样声明：</target>
        </trans-unit>
        <trans-unit id="70df367f1e5c153af04770d26e6bb6e5662b24b1" translate="yes" xml:space="preserve">
          <source>All this behaviour contrasts with Haskell 98&amp;rsquo;s peculiar treatment of contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report). In Haskell 98 the definition</source>
          <target state="translated">所有这些行为与Haskell 98在数据类型声明中对上下文的特殊处理形成了对比（Haskell 98报告的4.2.1节）。在Haskell 98中的定义</target>
        </trans-unit>
        <trans-unit id="3d7f2d606f261a5fba2db68b6939910c2cd2ece4" translate="yes" xml:space="preserve">
          <source>All this looks quite promising; we have a class and a range of interesting implementations. Unfortunately, there are some serious problems with the class declaration. First, the empty function has an ambiguous type:</source>
          <target state="translated">所有这些看起来都很有希望;我们有一个类和一系列有趣的实现。不幸的是,这个类的声明存在一些严重的问题。首先,空函数的类型含糊不清。</target>
        </trans-unit>
        <trans-unit id="c67f8504ed498a898f1ab818b85763d53fddcf77" translate="yes" xml:space="preserve">
          <source>All three of these examples would compile without issue. On the other hand:</source>
          <target state="translated">这三个例子在编译时都没有问题。另一方面。</target>
        </trans-unit>
        <trans-unit id="9677956077fa96efb5b69b5a1ae7ad4b38e3313b" translate="yes" xml:space="preserve">
          <source>All types are classified as one of these classes: 32bit word, 64bit word, 32bit float, 64bit float, pointer.</source>
          <target state="translated">所有的类型都被划分为其中的一类。32位字,64位字,32位浮点,64位浮点,指针。</target>
        </trans-unit>
        <trans-unit id="057ac441b399eb9586ae68f5c1eb9f47b4178362" translate="yes" xml:space="preserve">
          <source>All unbound identifiers are treated as typed holes, &lt;em&gt;whether or not they start with an underscore&lt;/em&gt;. The only difference is in the error message:</source>
          <target state="translated">所有未绑定的标识符都被视为类型化的空洞，&lt;em&gt;无论它们是否以下划线开头&lt;/em&gt;。唯一的区别在于错误消息：</target>
        </trans-unit>
        <trans-unit id="fd53184b2d10dc248ec6c9e2385390b9b65b470a" translate="yes" xml:space="preserve">
          <source>AllPhases</source>
          <target state="translated">AllPhases</target>
        </trans-unit>
        <trans-unit id="86266bd7ede6bd6ba8469405abe76d387f23e4e4" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory and marshal a value into it (the combination of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt;). The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">分配一个内存块并将一个值编组到其中（ &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; 的组合）。分配的区域大小由 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 方法确定，以适用于适当的类型。</target>
        </trans-unit>
        <trans-unit id="bd8c715cc3db061ff535eb5c0524be9fac0fa2b8" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory of the given number of bytes. The block of memory is sufficiently aligned for any of the basic foreign types that fits into a memory block of the allocated size.</source>
          <target state="translated">分配一个给定字节数的内存块。该内存块对于任何适合分配大小的内存块的基本外来类型都是充分对齐的。</target>
        </trans-unit>
        <trans-unit id="48f50994b06d1d5671f516b19482a827582f3624" translate="yes" xml:space="preserve">
          <source>Allocate a block of memory that is sufficient to hold values of type &lt;code&gt;a&lt;/code&gt;. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">分配足以容纳类型 &lt;code&gt;a&lt;/code&gt; 的值的内存块。分配的区域大小由 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 方法确定，以适用于适当的类型。</target>
        </trans-unit>
        <trans-unit id="945eac0de6e1530ab37e60133056c31933f7e0c0" translate="yes" xml:space="preserve">
          <source>Allocate a fresh memory pool.</source>
          <target state="translated">分配一个新的内存池。</target>
        </trans-unit>
        <trans-unit id="bf161f8d2ef1099082c0d5528c3c029bcc71adc8" translate="yes" xml:space="preserve">
          <source>Allocate a new buffer of the given size.</source>
          <target state="translated">分配一个给定大小的新缓冲区。</target>
        </trans-unit>
        <trans-unit id="797966dc728422a87321bee745962bf7b9b2105b" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it, terminating the end with the given marker.</source>
          <target state="translated">为给定池中的值列表分配连续的存储空间,并将这些值汇入其中,以给定的标记结束。</target>
        </trans-unit>
        <trans-unit id="f5067d72f839d0ca801793aa2138ada31d2918c8" translate="yes" xml:space="preserve">
          <source>Allocate consecutive storage for a list of values in the given pool and marshal these values into it.</source>
          <target state="translated">为给定池中的值列表分配连续的存储空间,并将这些值调入其中。</target>
        </trans-unit>
        <trans-unit id="4f94873e14ae1ca0d376362647204a8cbf513639" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">分配一些内存并向其返回一个 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 。丢弃 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 时，内存将自动释放。</target>
        </trans-unit>
        <trans-unit id="adc10905359d2ad848031b0da8c89829871951ed" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">分配一些内存并向其返回一个 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 。丢弃 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 时，内存将自动释放。</target>
        </trans-unit>
        <trans-unit id="d7a74b5000fcb22d46c63fd1403958268121cb0e" translate="yes" xml:space="preserve">
          <source>Allocate some memory and return a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; to it. The memory will be released automatically when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is discarded.</source>
          <target state="translated">分配一些内存并向其返回一个 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 。丢弃 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 时，内存将自动释放。</target>
        </trans-unit>
        <trans-unit id="18d53cff546da86cca443415642d6098c6313605" translate="yes" xml:space="preserve">
          <source>Allocate space for storable type in the given pool. The size of the area allocated is determined by the &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; method from the instance of &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; for the appropriate type.</source>
          <target state="translated">在给定的池中为可存储类型分配空间。分配的区域大小由 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:sizeOf&quot;&gt;sizeOf&lt;/a&gt;&lt;/code&gt; 方法确定，以适用于适当的类型。</target>
        </trans-unit>
        <trans-unit id="d0faf0f0921366d35115d853c768adb58bbc217c" translate="yes" xml:space="preserve">
          <source>Allocate storage and marshal a storable value wrapped into a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">分配存储并封送存储在 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中的可存储值</target>
        </trans-unit>
        <trans-unit id="85a29b1e9713abbc38e1d1724333822128176095" translate="yes" xml:space="preserve">
          <source>Allocate storage for a value in the given pool and marshal the value into this storage.</source>
          <target state="translated">在给定的池中为一个值分配存储,并将该值调入该存储。</target>
        </trans-unit>
        <trans-unit id="a751dea2f39999181b1d506f2ded5ae31093a057" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">为给定数量的可存储类型的元素分配存储（如 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ，但多个元素）。</target>
        </trans-unit>
        <trans-unit id="b8bd206b599ec8ecb129ced0e29abca1ece50440" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool, but leave room for an extra element to signal the end of the array.</source>
          <target state="translated">为池中给定数量的可存储类型元素分配存储空间,但要为额外的元素留出空间,以表示阵列的结束。</target>
        </trans-unit>
        <trans-unit id="3c6502a8f26acdc89616720173572f6835f4395f" translate="yes" xml:space="preserve">
          <source>Allocate storage for the given number of elements of a storable type in the pool.</source>
          <target state="translated">为池中给定数量的可存储类型元素分配存储空间。</target>
        </trans-unit>
        <trans-unit id="dfb0511a4ae80d311521dfea2fd5a589ea804b6a" translate="yes" xml:space="preserve">
          <source>Allocate the given number of bytes of storage in the pool.</source>
          <target state="translated">在池中分配给定的存储字节数。</target>
        </trans-unit>
        <trans-unit id="74c31d0f81c37ba9952fac9ee09d5580d40e7044" translate="yes" xml:space="preserve">
          <source>Allocate the nursery from node-local memory.</source>
          <target state="translated">从节点本地内存中分配苗圃。</target>
        </trans-unit>
        <trans-unit id="489efe43727a84928b21db7c885a4647eec79612" translate="yes" xml:space="preserve">
          <source>Allocating managed memory</source>
          <target state="translated">分配托管内存</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="a371c9709f159b54fa290c4ef85af0337a88411e" translate="yes" xml:space="preserve">
          <source>Allocation accounting is accurate only to about 4Kbytes.</source>
          <target state="translated">分配核算只精确到4Kbytes左右。</target>
        </trans-unit>
        <trans-unit id="672bb521be73595aa99b0bcb407ba5c8a04ff65e" translate="yes" xml:space="preserve">
          <source>Allocation counter and limit</source>
          <target state="translated">分配计数器和限制</target>
        </trans-unit>
        <trans-unit id="6be4e23bfb8b2d85b4d8e47ee554151801bbfd62" translate="yes" xml:space="preserve">
          <source>Allocation counter and limits</source>
          <target state="translated">分配计数器和限制</target>
        </trans-unit>
        <trans-unit id="f863a7852bc37e781471622e1a75707f51a4b50b" translate="yes" xml:space="preserve">
          <source>Allocation counter and quota</source>
          <target state="translated">分配计数器和配额</target>
        </trans-unit>
        <trans-unit id="6714f70908a1447bb325aa721caef6aa021fb67a" translate="yes" xml:space="preserve">
          <source>AllocationLimitExceeded</source>
          <target state="translated">AllocationLimitExceeded</target>
        </trans-unit>
        <trans-unit id="78fee5f8d19c1012e15c9cb754371db736ef10f0" translate="yes" xml:space="preserve">
          <source>AllocationStrategy</source>
          <target state="translated">AllocationStrategy</target>
        </trans-unit>
        <trans-unit id="1e0ddb13f2d7482f1d9d4401e43c0f7c159e3d27" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;#&lt;/code&gt; as a postfix modifier on identifiers.</source>
          <target state="translated">允许 &lt;code&gt;#&lt;/code&gt; 作为标识符的后缀修饰符。</target>
        </trans-unit>
        <trans-unit id="487b72f96ce687ab0a0c0c91a3747ce245eb86bd" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; blocks and other constructs as function arguments.</source>
          <target state="translated">允许将 &lt;code&gt;do&lt;/code&gt; 块和其他构造用作函数参数。</target>
        </trans-unit>
        <trans-unit id="f3d4d6a5ae1b8e8556bffe5a2051a8a7eeb9bcd1" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;do&lt;/code&gt; expressions, lambda expressions, etc. to be directly used as a function argument.</source>
          <target state="translated">允许 &lt;code&gt;do&lt;/code&gt; 表达式，lambda表达式等直接用作函数参数。</target>
        </trans-unit>
        <trans-unit id="57b2197ae6b5696247d5182d09e77a732fad1d01" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;forall&lt;/code&gt; quantifiers in constraints.</source>
          <target state="translated">允许 &lt;code&gt;forall&lt;/code&gt; 在约束量词。</target>
        </trans-unit>
        <trans-unit id="48fb284220c7e71266222e272e89501b5da2de4e" translate="yes" xml:space="preserve">
          <source>Allow all superclass constraints, including those that may result in non-termination of the typechecker.</source>
          <target state="translated">允许所有超类约束,包括那些可能导致类型检查器非终止的约束。</target>
        </trans-unit>
        <trans-unit id="80eb231dd3933ab2efd3d5dfa5c44bae12bc9d69" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="translated">允许延迟 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算。当传递类型为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 的动作时，仅当需要 &lt;code&gt;a&lt;/code&gt; 的值时才执行该动作。</target>
        </trans-unit>
        <trans-unit id="7a2ecf66e99906eb20d2eca046ddaa3ae040e446" translate="yes" xml:space="preserve">
          <source>Allow an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be deferred lazily. When passed an action of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;, the action will only be performed when the value of &lt;code&gt;a&lt;/code&gt; is demanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1750d76ce07b95cdb172cc776a34f360d5d4cd29" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">即使在 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内部也允许引发异步异常，从而使操作可中断（请参见 &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 中&amp;ldquo; Interruptible operation&amp;rdquo;的讨论）。</target>
        </trans-unit>
        <trans-unit id="780a200a64ac9433b47b1da40e2581b24c295f40" translate="yes" xml:space="preserve">
          <source>Allow asynchronous exceptions to be raised even inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, making the operation interruptible (see the discussion of &quot;Interruptible operations&quot; in &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">即使在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内部也允许引发异步异常，从而使操作可中断（请参见 &lt;code&gt;&lt;a href=&quot;control#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 中&amp;ldquo; Interruptible operation&amp;rdquo;的讨论）。</target>
        </trans-unit>
        <trans-unit id="8baf535a4dbc587a727d88078ccbc03106a8d4ba" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Foldable&lt;/code&gt; typeclass.</source>
          <target state="translated">允许自动派生 &lt;code&gt;Foldable&lt;/code&gt; 类型类的实例。</target>
        </trans-unit>
        <trans-unit id="4f96512299d9639cbf383164f1db522bd120f323" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Functor&lt;/code&gt; typeclass.</source>
          <target state="translated">允许自动派生 &lt;code&gt;Functor&lt;/code&gt; 类型类的实例。</target>
        </trans-unit>
        <trans-unit id="cb4259796e51e2d950e57edd562f9cf8982dd300" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Generic&lt;/code&gt; typeclass.</source>
          <target state="translated">允许自动派生 &lt;code&gt;Generic&lt;/code&gt; 类型类的实例。</target>
        </trans-unit>
        <trans-unit id="a7632af3ddef7069071f3bf8a7c397be4ca59fcd" translate="yes" xml:space="preserve">
          <source>Allow automatic deriving of instances for the &lt;code&gt;Traversable&lt;/code&gt; typeclass.</source>
          <target state="translated">允许自动派生 &lt;code&gt;Traversable&lt;/code&gt; 类型类的实例。</target>
        </trans-unit>
        <trans-unit id="add95d26da022101d791b89213499080da94e3a9" translate="yes" xml:space="preserve">
          <source>Allow constant folding in case expressions that scrutinise some primops: For example,</source>
          <target state="translated">允许在案件表达中不断折叠,仔细检查一些primops。例如:</target>
        </trans-unit>
        <trans-unit id="934cc159b35ac28d99ae334c8a54aa36d7a7c39a" translate="yes" xml:space="preserve">
          <source>Allow constraints to quantify over types.</source>
          <target state="translated">允许约束条件对类型进行量化。</target>
        </trans-unit>
        <trans-unit id="2ce51b30b9da5f59ff139ceec6637a831ee564b6" translate="yes" xml:space="preserve">
          <source>Allow contexts on &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">允许有关 &lt;code&gt;data&lt;/code&gt; 类型的上下文。</target>
        </trans-unit>
        <trans-unit id="eab095a3e387bb8b63300500e130636d41df289c" translate="yes" xml:space="preserve">
          <source>Allow defaulting to take place for more than just numeric classes.</source>
          <target state="translated">允许不仅仅对数字类进行默认。</target>
        </trans-unit>
        <trans-unit id="926119bf4ff3119fe5a37dc0cb8f3089e82d4ec6" translate="yes" xml:space="preserve">
          <source>Allow definition of empty &lt;code&gt;data&lt;/code&gt; types.</source>
          <target state="translated">允许定义空 &lt;code&gt;data&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="36885bc6f326d61d2bc2d18c723dc0b2ce083841" translate="yes" xml:space="preserve">
          <source>Allow definition of functions expecting implicit parameters.</source>
          <target state="translated">允许定义期望隐式参数的函数。</target>
        </trans-unit>
        <trans-unit id="b8fdd0e51a265a2c590d00cb6abc3adad2684d61" translate="yes" xml:space="preserve">
          <source>Allow definition of record types with identically-named fields.</source>
          <target state="translated">允许定义具有相同名称字段的记录类型。</target>
        </trans-unit>
        <trans-unit id="726294c3f294ef13dd773189e75ae54c6d6e3bbd" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances for type synonyms.</source>
          <target state="translated">允许为类型同义词定义类型类实例。</target>
        </trans-unit>
        <trans-unit id="7f2a1ee40ed67cae653a504bd6f3545fe705b983" translate="yes" xml:space="preserve">
          <source>Allow definition of type class instances with arbitrary nested types in the instance head.</source>
          <target state="translated">允许在实例头定义任意嵌套类型的类型类实例。</target>
        </trans-unit>
        <trans-unit id="86966622a20e13b1ac31de8f45367c263a8977cf" translate="yes" xml:space="preserve">
          <source>Allow deriving instances of standard type classes for empty data types.</source>
          <target state="translated">允许导出空数据类型的标准类型类实例。</target>
        </trans-unit>
        <trans-unit id="60943beab02466a2c26e0ab7a51efa95c6e2a7fe" translate="yes" xml:space="preserve">
          <source>Allow empty case alternatives.</source>
          <target state="translated">允许空箱替代。</target>
        </trans-unit>
        <trans-unit id="025c491c399c735d766d5a9892dd9e6ee33b7e08" translate="yes" xml:space="preserve">
          <source>Allow empty case expressions.</source>
          <target state="translated">允许空箱表达式。</target>
        </trans-unit>
        <trans-unit id="6c84f72d8d262e69d1f9faa234eff6fdf37f2369" translate="yes" xml:space="preserve">
          <source>Allow existentially quantified type variables in types.</source>
          <target state="translated">允许在类型中存在量化的类型变量。</target>
        </trans-unit>
        <trans-unit id="1ab319c3adc39803249aca0e24d447b1fb428579" translate="yes" xml:space="preserve">
          <source>Allow explicit kind signatures on type variables.</source>
          <target state="translated">允许对类型变量进行明确的种类签名。</target>
        </trans-unit>
        <trans-unit id="17fa756b705f1fa52e127048ab38d27914f60aba" translate="yes" xml:space="preserve">
          <source>Allow functional dependency annotations on type families. This allows one to define injective type families.</source>
          <target state="translated">允许对类型族进行功能依赖性注释。这允许我们定义注入式类型族。</target>
        </trans-unit>
        <trans-unit id="6eb8b184e2bcabb5b3fa790e938afe5ac1becfb4" translate="yes" xml:space="preserve">
          <source>Allow impredicative polymorphic types.</source>
          <target state="translated">允许不预言的多态类型。</target>
        </trans-unit>
        <trans-unit id="2433b80c1b9d57252941872fdc1b781f2a3699e6" translate="yes" xml:space="preserve">
          <source>Allow kind polymorphic types.</source>
          <target state="translated">允许种多态类型。</target>
        </trans-unit>
        <trans-unit id="cdff7073df11b6e1c05a0eceb6acaa80701d67af" translate="yes" xml:space="preserve">
          <source>Allow multiple &lt;code&gt;deriving&lt;/code&gt;, each optionally qualified with a &lt;em&gt;strategy&lt;/em&gt;.</source>
          <target state="translated">允许多个 &lt;code&gt;deriving&lt;/code&gt; ，每个派生可以选择一个&lt;em&gt;策略&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="76ba8a634a12bd3f74b9359ac050a7de5e913037" translate="yes" xml:space="preserve">
          <source>Allow naming of wildcards (e.g. &lt;code&gt;_x&lt;/code&gt;) in type signatures.</source>
          <target state="translated">允许在类型签名中命名通配符（例如 &lt;code&gt;_x&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="70463e61ddc2770c5bfd923aebb592b3ba442123" translate="yes" xml:space="preserve">
          <source>Allow nested contexts to be at the same indentation level as its enclosing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24b90b3b696d68b4a53058736b07d9593258864" translate="yes" xml:space="preserve">
          <source>Allow other process to set Window to Foreground by using &lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">允许其他进程通过使用 &lt;code&gt;&lt;a href=&quot;graphics-win32-window-foregroundwindow#v:setForegroundWindow&quot;&gt;setForegroundWindow&lt;/a&gt;&lt;/code&gt; 函数将Window设置为Foreground 。</target>
        </trans-unit>
        <trans-unit id="3466dbeb7cfb661d1b3d5d9ae06ef44c39d689be" translate="yes" xml:space="preserve">
          <source>Allow parallel list comprehension syntax.</source>
          <target state="translated">允许平行列表理解语法。</target>
        </trans-unit>
        <trans-unit id="3ed92111f1838c96b6c033cdfe95611654ed8c96" translate="yes" xml:space="preserve">
          <source>Allow promotion of data types to kind level.</source>
          <target state="translated">允许将数据类型提升到种类级别。</target>
        </trans-unit>
        <trans-unit id="260dca80fe27608e688cf5033c080a2cfba5b239" translate="yes" xml:space="preserve">
          <source>Allow role annotation syntax.</source>
          <target state="translated">允许角色注释语法。</target>
        </trans-unit>
        <trans-unit id="87a0f4cf411c10836ab0efbb3303960a1c45e4a3" translate="yes" xml:space="preserve">
          <source>Allow the compiler to apply rewrite rules to the source program.</source>
          <target state="translated">允许编译器对源程序应用重写规则。</target>
        </trans-unit>
        <trans-unit id="6b09bb1ac28b5b0c583dc8ebf98fba2849116608" translate="yes" xml:space="preserve">
          <source>Allow the compiler to automatically choose between identically-named record selectors based on type (if the choice is unambiguous).</source>
          <target state="translated">允许编译器根据类型自动在相同名称的记录选择器之间进行选择(如果选择是明确的)。</target>
        </trans-unit>
        <trans-unit id="83c47b742b143b98b73e92a9a5de1c9e32c641ec" translate="yes" xml:space="preserve">
          <source>Allow the definition of pattern synonyms.</source>
          <target state="translated">允许定义模式同义词。</target>
        </trans-unit>
        <trans-unit id="fe2a8646e41c100c7ad5651319a6e065e997f85a" translate="yes" xml:space="preserve">
          <source>Allow the definition of typeclasses with more than one parameter.</source>
          <target state="translated">允许定义多于一个参数的类型类。</target>
        </trans-unit>
        <trans-unit id="d185ff37afe97c8a5c9c099b699c25563f19c7b7" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">允许在计算内部（延迟）使用 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算的结果。</target>
        </trans-unit>
        <trans-unit id="ce75fe6b08dfb2e2c5aeb7a05bc37771108792fd" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">允许在计算内部（延迟）使用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算的结果。注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71db9c7ef93f554ac579b40d6689938982ec9dda" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation. Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">允许在计算内部（延迟）使用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算的结果。注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e53378677db7eb448650e4848cf3af89d1c7b5" translate="yes" xml:space="preserve">
          <source>Allow the result of an &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation to be used (lazily) inside the computation.</source>
          <target state="translated">允许在计算内部（延迟）使用 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算的结果。</target>
        </trans-unit>
        <trans-unit id="a25778334adcda643e0a1777a4a1308851238bc9" translate="yes" xml:space="preserve">
          <source>Allow the use and definition of types with operator names.</source>
          <target state="translated">允许使用和定义带有操作者名称的类型。</target>
        </trans-unit>
        <trans-unit id="ffa6e2a8241cb1d89e5bfc36b1a5b18d2b5d635a" translate="yes" xml:space="preserve">
          <source>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">允许在数据类型定义中使用GADT语法（但不允许使用GADT本身；有关此信息，请参见&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="59b4b3836b0ad08f877b34af9e4fa8b8a8d4a012" translate="yes" xml:space="preserve">
          <source>Allow the use of binary notation in integer literals.</source>
          <target state="translated">允许在整数字中使用二进制符号。</target>
        </trans-unit>
        <trans-unit id="efcd29c7bce33303e5d32e6ccbc57335b0acff65" translate="yes" xml:space="preserve">
          <source>Allow the use of complex constraints in class declaration contexts.</source>
          <target state="translated">允许在类声明上下文中使用复杂的约束。</target>
        </trans-unit>
        <trans-unit id="702e6903368de34c7b00d4d1faab5cc980b6ff20" translate="yes" xml:space="preserve">
          <source>Allow the use of floating-point literal syntax for integral types.</source>
          <target state="translated">允许对积分类型使用浮点文字语法。</target>
        </trans-unit>
        <trans-unit id="2f2df53ac2aa65699d533256ce56f3e679075bdf" translate="yes" xml:space="preserve">
          <source>Allow the use of lambda-case syntax.</source>
          <target state="translated">允许使用lambda-case语法。</target>
        </trans-unit>
        <trans-unit id="76a7a3b4a067b229370029d02bfb2c0e97e8bc7f" translate="yes" xml:space="preserve">
          <source>Allow the use of multi-way-&lt;code&gt;if&lt;/code&gt; syntax.</source>
          <target state="translated">允许使用多向 &lt;code&gt;if&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="4acbbed0487deb8857b5f7e688836829f142c6f1" translate="yes" xml:space="preserve">
          <source>Allow the use of package-qualified &lt;code&gt;import&lt;/code&gt; syntax.</source>
          <target state="translated">允许使用包限定的 &lt;code&gt;import&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="eea333a314c924e9102b9616473c6ae74d1b2886" translate="yes" xml:space="preserve">
          <source>Allow the use of post-fix operators</source>
          <target state="translated">允许使用后补运算符</target>
        </trans-unit>
        <trans-unit id="adb08d203af69b5b4cd4dd423b7318efffc8b20f" translate="yes" xml:space="preserve">
          <source>Allow the use of recursive &lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">允许使用递归 &lt;code&gt;do&lt;/code&gt; 表示法。</target>
        </trans-unit>
        <trans-unit id="b0029babcf620375a925cb0f309e07f9eef805a4" translate="yes" xml:space="preserve">
          <source>Allow the use of stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations.</source>
          <target state="translated">允许使用独立的 &lt;code&gt;deriving&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="6ffc26d958cddfc3a794521475014c76922cd906" translate="yes" xml:space="preserve">
          <source>Allow the use of standalone kind signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86686087092ab757a3c44071e8cdb958a2e740ab" translate="yes" xml:space="preserve">
          <source>Allow the use of tuple section syntax</source>
          <target state="translated">允许使用元组部分语法。</target>
        </trans-unit>
        <trans-unit id="f62761563b5f41d61ca0ecbb5ad968019d4409d7" translate="yes" xml:space="preserve">
          <source>Allow the use of type application syntax.</source>
          <target state="translated">允许使用类型应用语法。</target>
        </trans-unit>
        <trans-unit id="5675777ef0f98250d6e550ff440d842beeff404c" translate="yes" xml:space="preserve">
          <source>Allow the use of underscores in numeric literals.</source>
          <target state="translated">允许在数字文字中使用下划线。</target>
        </trans-unit>
        <trans-unit id="eee4b36605984e0b63f2119e25dc26be8151e070" translate="yes" xml:space="preserve">
          <source>Allow the use of wildcards in record construction and pattern matching.</source>
          <target state="translated">允许在记录构建和模式匹配中使用通配符。</target>
        </trans-unit>
        <trans-unit id="1a6687c47ecd5f08e5cbe5a2d433f777d1b2ba65" translate="yes" xml:space="preserve">
          <source>Allow the user to write ambiguous types, and the type inference engine to infer them.</source>
          <target state="translated">允许用户编写模糊类型,由类型推理引擎来推断。</target>
        </trans-unit>
        <trans-unit id="86a368ced00c7e3c3b92de7fbdde36c04126fbd7" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting.</source>
          <target state="translated">允许在进行后期lambda提升时,将已知呼叫转为未知呼叫。</target>
        </trans-unit>
        <trans-unit id="3cbe6d10b7f1a1883fd95b6bb21627c693dfd0bb" translate="yes" xml:space="preserve">
          <source>Allow turning known into unknown calls while performing late lambda lifting. This is deemed non-beneficial, so it&amp;rsquo;s off by default.</source>
          <target state="translated">在执行后期lambda提升时，允许将已知呼叫转换为未知呼叫。这被认为是无益的，因此默认情况下处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="274c2026d3d9723dc92cd98f7d9326abfd5773f8" translate="yes" xml:space="preserve">
          <source>Allow type signatures for members in instance definitions.</source>
          <target state="translated">允许在实例定义中对成员进行类型签名。</target>
        </trans-unit>
        <trans-unit id="da5bb70ccf69edfc067bb0ecac09b8b7fa946e39" translate="yes" xml:space="preserve">
          <source>Allow type signatures which appear that they would result in an unusable binding.</source>
          <target state="translated">允许出现会导致无法使用绑定的类型签名。</target>
        </trans-unit>
        <trans-unit id="7f9ebd8bc90d2c97f8f8af6055daef8a66d58b11" translate="yes" xml:space="preserve">
          <source>Allow types of arbitrary rank.</source>
          <target state="translated">允许任意等级的类型。</target>
        </trans-unit>
        <trans-unit id="72c06cac8ca4e2cc8c6349ed8e7e17158f9a5bef" translate="yes" xml:space="preserve">
          <source>Allow types of kind &lt;code&gt;Constraint&lt;/code&gt; to be used in contexts.</source>
          <target state="translated">允许在上下文中使用 &lt;code&gt;Constraint&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="a7e55900edd38daa3e986afd90affccc2a45f441" translate="yes" xml:space="preserve">
          <source>Allow use and definition of indexed type and data families.</source>
          <target state="translated">允许使用和定义索引类型和数据族。</target>
        </trans-unit>
        <trans-unit id="6e40b71ea659cf26b3075e17e0c63e65704ae662" translate="yes" xml:space="preserve">
          <source>Allow use of &lt;code&gt;Applicative&lt;/code&gt;&lt;code&gt;do&lt;/code&gt; notation.</source>
          <target state="translated">允许使用的 &lt;code&gt;Applicative&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; 记号。</target>
        </trans-unit>
        <trans-unit id="9bed755b4d0a566202ee360d2e8141648215487c" translate="yes" xml:space="preserve">
          <source>Allow use of Generalised Algebraic Data Types (GADTs).</source>
          <target state="translated">允许使用通用代数数据类型(GADTs)。</target>
        </trans-unit>
        <trans-unit id="b42306fa5c185a7862be6bb52526be30dbac6894" translate="yes" xml:space="preserve">
          <source>Allow use of any typeclass in &lt;code&gt;deriving&lt;/code&gt; clauses.</source>
          <target state="translated">允许在 &lt;code&gt;deriving&lt;/code&gt; 子句中使用任何类型类。</target>
        </trans-unit>
        <trans-unit id="5a457c798a55fb26f0dd47dc4032be39a59a6341" translate="yes" xml:space="preserve">
          <source>Allow use of bang pattern syntax.</source>
          <target state="translated">允许使用bang模式语法。</target>
        </trans-unit>
        <trans-unit id="c23bf1d512a631794fb404638276aacd4f32df67" translate="yes" xml:space="preserve">
          <source>Allow use of functional dependencies in class declarations.</source>
          <target state="translated">允许在类声明中使用功能依赖。</target>
        </trans-unit>
        <trans-unit id="2d060a642a2f52d17e449b4e275108c16d94164a" translate="yes" xml:space="preserve">
          <source>Allow use of generalised list (SQL-like) comprehension syntax. This introduces the &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt; keywords.</source>
          <target state="translated">允许使用广义列表（类似于SQL）的理解语法。这将介绍 &lt;code&gt;group&lt;/code&gt; ， &lt;code&gt;by&lt;/code&gt; 和 &lt;code&gt;using&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="6416480874a524bb16d12732baf7a1a42b48283b" translate="yes" xml:space="preserve">
          <source>Allow use of record puns.</source>
          <target state="translated">允许使用记录双关语。</target>
        </trans-unit>
        <trans-unit id="62089014435f225ba326e9329061e5e4a53f0bb5" translate="yes" xml:space="preserve">
          <source>Allow use of static pointer syntax.</source>
          <target state="translated">允许使用静态指针语法。</target>
        </trans-unit>
        <trans-unit id="8f3abc6ee81a5c4909fa0b404e4d5cc274c88e29" translate="yes" xml:space="preserve">
          <source>Allow use of the &lt;code&gt;forall&lt;/code&gt; keyword in places where universal quantification is implicit.</source>
          <target state="translated">允许在隐含通用量化的地方使用 &lt;code&gt;forall&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="f830fe1b81f5dd2916e893293dc917cf10ac1a5f" translate="yes" xml:space="preserve">
          <source>Allow use of the Haskell foreign function interface.</source>
          <target state="translated">允许使用 Haskell 外来函数接口。</target>
        </trans-unit>
        <trans-unit id="d2ec09e108221e720d271bb74180facf527b037f" translate="yes" xml:space="preserve">
          <source>Allow use of view pattern syntax.</source>
          <target state="translated">允许使用视图模式语法。</target>
        </trans-unit>
        <trans-unit id="d8d0040f1860796d1680868b0c0c97a27e733ecd" translate="yes" xml:space="preserve">
          <source>Allow worker-wrapper to convert a function closure into a thunk if the function does not use any of its arguments. Off by default.</source>
          <target state="translated">如果函数没有使用任何参数,允许worker-wrapper将函数闭包转换为thunk。默认为关闭。</target>
        </trans-unit>
        <trans-unit id="0bf61d77eeec666128b4e93e100c46e62621a2b9" translate="yes" xml:space="preserve">
          <source>Allow writing floating point literals using hexadecimal notation.</source>
          <target state="translated">允许使用十六进制记数法书写浮点数。</target>
        </trans-unit>
        <trans-unit id="44b76e5dbcac70fa19335f3f6dd1767846c2ae45" translate="yes" xml:space="preserve">
          <source>AllowAmbiguousTypes</source>
          <target state="translated">AllowAmbiguousTypes</target>
        </trans-unit>
        <trans-unit id="f568f29db39d6daee9c168b5db2b40a0f82b6e78" translate="yes" xml:space="preserve">
          <source>Allows the definition of default method signatures in class definitions.</source>
          <target state="translated">允许在类定义中定义默认的方法签名。</target>
        </trans-unit>
        <trans-unit id="39a8bda3c1c817a2744fbe48c428dd732e29b994" translate="yes" xml:space="preserve">
          <source>Allows the definition of further constraints on individual class methods.</source>
          <target state="translated">允许对各个类方法进行进一步的约束定义。</target>
        </trans-unit>
        <trans-unit id="795662519537fb732dd1a2476e8a6962c0c19569" translate="yes" xml:space="preserve">
          <source>Allows the use definition of type classes with no parameters. This extension has been replaced by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">允许使用不带参数的类型类的使用定义。此扩展已由&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="2018e3c7850e7133b41fccedea329900b1f4d76e" translate="yes" xml:space="preserve">
          <source>Alone</source>
          <target state="translated">Alone</target>
        </trans-unit>
        <trans-unit id="ac58ae5ab26ea9f98150373e68429bafad7728e6" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f k x y&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">与遍历 &lt;code&gt;WhenMissing f k x y&lt;/code&gt; ，见证了WhenMissing fkxy与 &lt;code&gt;k -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 之间的同构。</target>
        </trans-unit>
        <trans-unit id="7eaf4e6487782093547b308bb962d31222393a9b" translate="yes" xml:space="preserve">
          <source>Along with traverseMaybeMissing, witnesses the isomorphism between &lt;code&gt;WhenMissing f x y&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt;.</source>
          <target state="translated">与遍历 &lt;code&gt;WhenMissing f x y&lt;/code&gt; 一起，见证了WhenMissing fxy和 &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe y)&lt;/code&gt; 之间的同构。</target>
        </trans-unit>
        <trans-unit id="fceb538d6e1da23d3f3babb9155dbc45ee7239e4" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; and &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">与zipWithMaybeAMatched一起，见证了 &lt;code&gt;WhenMatched f k x y z&lt;/code&gt; 与 &lt;code&gt;k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 之间的同构。</target>
        </trans-unit>
        <trans-unit id="88e74dd86e7cd0c0ee3739f6c7a769d3ff6c7c44" translate="yes" xml:space="preserve">
          <source>Along with zipWithMaybeAMatched, witnesses the isomorphism between &lt;code&gt;WhenMatched f x y z&lt;/code&gt; and &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">与zipWithMaybeAMatched一起，见证了 &lt;code&gt;WhenMatched f x y z&lt;/code&gt; 和 &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 之间的同构。</target>
        </trans-unit>
        <trans-unit id="19ad299afbc240cf0075ef975ed7558787fe489f" translate="yes" xml:space="preserve">
          <source>AlreadyExists</source>
          <target state="translated">AlreadyExists</target>
        </trans-unit>
        <trans-unit id="630df194c5b10abfa95d9d050a3cb36c24a133d2" translate="yes" xml:space="preserve">
          <source>Also</source>
          <target state="translated">Also</target>
        </trans-unit>
        <trans-unit id="50722218b035a878cd9ffc30a73ebfebc7a35f8b" translate="yes" xml:space="preserve">
          <source>Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.</source>
          <target state="translated">当一个模块被重新导出,但该模块没有导出任何东西时,也会发出警告。</target>
        </trans-unit>
        <trans-unit id="746c9d1259ee19f74bffdc1d68a458f59b53388d" translate="yes" xml:space="preserve">
          <source>Also for newtypes, &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Enum&lt;/code&gt; are derived using the &lt;code&gt;newtype&lt;/code&gt; strategy if &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and the derivation succeeds.</source>
          <target state="translated">也为newtypes， &lt;code&gt;Functor&lt;/code&gt; ， &lt;code&gt;Foldable&lt;/code&gt; 和 &lt;code&gt;Enum&lt;/code&gt; 使用衍生 &lt;code&gt;newtype&lt;/code&gt; 策略，如果 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 启用并推导成功。</target>
        </trans-unit>
        <trans-unit id="9b5456c8967e8ed475ed23a6be13064c4931fe49" translate="yes" xml:space="preserve">
          <source>Also in the same way as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicilty bound in a type instance declaration.</source>
          <target state="translated">同样，与&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;相同，启用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;时，可以在类型实例声明中显式绑定类型和种类变量。</target>
        </trans-unit>
        <trans-unit id="6cdbfaf0e12c5c669a436bbe3f3e6d1b8921e00e" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">另请注意， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="92256f9554b50ce0b2fea7c43d4cb8cc3cb75d44" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">还要注意， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="691fd7629064f3b051f676bcbfa6149c61d9b342" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">另请注意， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="406dc1c18625f274ff0dc94719e4b6be8d808a02" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">还要注意， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="810701a878272ce093eceec04b908e8284d8a9c5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">另请注意， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="8d40d8b2532580731c8434c5f67b1078551988ae" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">另请注意， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="dd8ee350e8fa89eeaea33735d33ccaffdcefe56b" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">还要注意， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="e30beaf60ec387590381b5355c5af1eb18030345" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy substitutivity:</source>
          <target state="translated">还要注意， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足取代性：</target>
        </trans-unit>
        <trans-unit id="aab6ba61f08a0ca3c95484013fb136c6e751322c" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">还要注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="f4786dd3fd2bcdff58d3b26007350033e063a192" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">另请注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="3e16b7f498e9a6b4b83f2652ce5ef38935a94752" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">还要注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="3e9f33b522d825dd8a332d37d794d47c3815cced" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">另请注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="40cdf5e6225f275daf21fe333e66b5c010a69778" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">还要注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="b45d0d39ada80fe3208a871ffe74aeb25503276e" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">还要注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="1f433875b8e4b77573f0f23895a49894977730bb" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">另请注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="c6e30397e70af87af894b6d2572b73af0484f5e2" translate="yes" xml:space="preserve">
          <source>Also note that due to the presence of -0, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance doesn't have an additive identity</source>
          <target state="translated">另请注意，由于存在-0，因此 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例没有加法标识</target>
        </trans-unit>
        <trans-unit id="b4cc23b0b0763553e0311dddd73a34a9e4dee8d5" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">还要注意，如果您想高效地进行左折，则可能要使用 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 。这样做的原因是，后者在将&amp;ldquo;内部&amp;rdquo;结果（例如上例中的 &lt;code&gt;z `f` x1&lt;/code&gt; ）应用到运算符（例如，对 &lt;code&gt;(`f` x2)&lt;/code&gt; ）之前不会强制执行。这导致一个长链 &lt;code&gt;O(n)&lt;/code&gt; 个元素的链状链，然后必须从外到内对其进行评估。</target>
        </trans-unit>
        <trans-unit id="ac14b968b5bbba0075fe9bfd17b35d0cc2b952eb" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed5ac80b0447d75eb36a8e1088f826de1949152" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">还要注意，如果您想高效地进行左折，则可能要使用 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 。这样做的原因是，后者在将&amp;ldquo;内部&amp;rdquo;结果（例如上例中的 &lt;code&gt;z `f` x1&lt;/code&gt; ）应用到运算符（例如，对 &lt;code&gt;(`f` x2)&lt;/code&gt; ）之前不会强制执行。这导致一个长链 &lt;code&gt;O(n)&lt;/code&gt; 个元素的链状链，然后必须从外到内对其进行评估。</target>
        </trans-unit>
        <trans-unit id="f372abd57a7f3cac154979340cbe51baeec9bbfb" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0312e92e764c438aa064f2113437c35a6539b369" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain &lt;code&gt;O(n)&lt;/code&gt; elements long, which then must be evaluated from the outside-in.</source>
          <target state="translated">还要注意，如果您想高效地进行左折，则可能要使用 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 。这样做的原因是，后者在将&amp;ldquo;内部&amp;rdquo;结果（例如上例中的 &lt;code&gt;z `f` x1&lt;/code&gt; ）应用到运算符（例如，对 &lt;code&gt;(`f` x2)&lt;/code&gt; ）之前不会强制执行。这导致一个长链 &lt;code&gt;O(n)&lt;/code&gt; 个元素的链状链，然后必须从外到内对其进行评估。</target>
        </trans-unit>
        <trans-unit id="adb136095ed6cc375f6a3f0659e9e4fe69576dda" translate="yes" xml:space="preserve">
          <source>Also note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that latter does not force the &quot;inner&quot; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acbfc03f5d47fca9d6b436cb055a438d6d24adc" translate="yes" xml:space="preserve">
          <source>Also note that the argument to &lt;code&gt;DEPRECATED&lt;/code&gt; and &lt;code&gt;WARNING&lt;/code&gt; can also be a list of strings, in which case the strings will be presented on separate lines in the resulting warning message,</source>
          <target state="translated">另请注意， &lt;code&gt;DEPRECATED&lt;/code&gt; 和 &lt;code&gt;WARNING&lt;/code&gt; 的参数也可以是字符串列表，在这种情况下，字符串将在警告消息中的不同行上显示，</target>
        </trans-unit>
        <trans-unit id="aa8f340d5595cab499d451cc0ad91fefbf788a96" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的运算符交互：</target>
        </trans-unit>
        <trans-unit id="cde3b82cd7b9ecd782961c29d79052d748e75c8a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的操作员交互：</target>
        </trans-unit>
        <trans-unit id="41ccfa2353a09113f0c811d9cb51cb48399720bc" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的运算符交互：</target>
        </trans-unit>
        <trans-unit id="235d629ac464213b855f299b5269fbab1821ac2a" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的操作员交互：</target>
        </trans-unit>
        <trans-unit id="a09b8126190a3493d9f5d149861112b275c4a820" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的运算符交互：</target>
        </trans-unit>
        <trans-unit id="df2b6faed2041cbc5f8775d83e79ec068a616bf0" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的操作员交互：</target>
        </trans-unit>
        <trans-unit id="f982812ed18e181efb5f1842c282247a56bf7ec3" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的运算符交互：</target>
        </trans-unit>
        <trans-unit id="27a6d2f2099e869b6c35b0b33e690f3dbb98988d" translate="yes" xml:space="preserve">
          <source>Also note that, due to the same, &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;'s operator interactions are not respected by &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s instance:</source>
          <target state="translated">还要注意，由于同样的原因， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的实例不尊重 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的操作员交互：</target>
        </trans-unit>
        <trans-unit id="220abdef84f1e02ea77807f44da3633ce41b62f6" translate="yes" xml:space="preserve">
          <source>Also note the use of &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; in the GHCi session above instead of &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;. This is because &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; gives you the type that would be inferred for a variable assigned to the expression provided (that is, the type of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt;). As we saw above with &lt;code&gt;myLength2&lt;/code&gt;, this type will have no variables available to visible type application. On the other hand, &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; gives you the actual type of the expression provided. To illustrate this:</source>
          <target state="translated">还要注意，在上面的GHCi会话中使用&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;代替&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;。这是因为&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;给你将被推断为分配给所提供的表达式中的变量的类型（即，类型 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;let x = &amp;lt;expr&amp;gt;&lt;/code&gt; 正如我们在 &lt;code&gt;myLength2&lt;/code&gt; 上看到的那样，此类型将没有可用于可见类型应用程序的变量。另一方面，&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;为您提供所提供表达式的实际类型。为了说明这一点：</target>
        </trans-unit>
        <trans-unit id="2513c4a2bdd30848586867d45397f58c5275a1ec" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;extra-libraries&lt;/code&gt; are placed on the linker command line after the &lt;code&gt;hs-libraries&lt;/code&gt; for the same package. If your package has dependencies in the other direction (i.e. &lt;code&gt;extra-libraries&lt;/code&gt; depends on &lt;code&gt;hs-libraries&lt;/code&gt;), and the libraries are static, you might need to make two separate packages.</source>
          <target state="translated">同样，对于相同软件包，将 &lt;code&gt;extra-libraries&lt;/code&gt; 放在链接程序命令行的 &lt;code&gt;hs-libraries&lt;/code&gt; 之后。如果您的软件包在另一个方向上具有依赖项（即， &lt;code&gt;extra-libraries&lt;/code&gt; 取决于 &lt;code&gt;hs-libraries&lt;/code&gt; ），并且这些库是静态的，则可能需要制作两个单独的软件包。</target>
        </trans-unit>
        <trans-unit id="40984f68323bbc3a5e0662d8396443ffd212990b" translate="yes" xml:space="preserve">
          <source>Also, you may need to use the &lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt;&lt;code&gt;-rdynamic&lt;/code&gt;&lt;/a&gt; flag to ensure that that symbols are not dropped from your PIE objects.</source>
          <target state="translated">另外，您可能需要使用&lt;a href=&quot;#ghc-flag--rdynamic&quot;&gt; &lt;code&gt;-rdynamic&lt;/code&gt; &lt;/a&gt;标志以确保不会从PIE对象中删除符号。</target>
        </trans-unit>
        <trans-unit id="e30eff925100b7c3e119ed678e39009e962455b0" translate="yes" xml:space="preserve">
          <source>Alt</source>
          <target state="translated">Alt</target>
        </trans-unit>
        <trans-unit id="e429c5fc3a2401f13f505fe2471ed35cea126252" translate="yes" xml:space="preserve">
          <source>Alternate completion to perform if the cursor is not at a quoted word</source>
          <target state="translated">如果光标不在被引用的单词上,则执行其他的完成方式。</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="f427a4339b88ab5730e552c0af40d96b9c132d30" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRule</source>
          <target state="translated">AlternativeLayoutRule</target>
        </trans-unit>
        <trans-unit id="a87adb1730114f941ad55c79898057fd80fd74d1" translate="yes" xml:space="preserve">
          <source>AlternativeLayoutRuleTransitional</source>
          <target state="translated">AlternativeLayoutRuleTransitional</target>
        </trans-unit>
        <trans-unit id="76d5f5130ef008f32d0f9b4ea42dc455c34353b6" translate="yes" xml:space="preserve">
          <source>Alternatively &lt;code&gt;Coll&lt;/code&gt; might be rewritten</source>
          <target state="translated">另外， &lt;code&gt;Coll&lt;/code&gt; 可能会被重写</target>
        </trans-unit>
        <trans-unit id="a65a8212521ccdabba5ba2d4d0578992c935fe0f" translate="yes" xml:space="preserve">
          <source>Alternatively you can use &lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt;&lt;code&gt;-funbox-small-strict-fields&lt;/code&gt;&lt;/a&gt; to only unbox strict fields which are &amp;ldquo;small&amp;rdquo;.</source>
          <target state="translated">或者，您可以使用&lt;a href=&quot;#ghc-flag--funbox-small-strict-fields&quot;&gt; &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; &lt;/a&gt;仅取消对&amp;ldquo; small&amp;rdquo; 的严格字段进行装箱。</target>
        </trans-unit>
        <trans-unit id="0139c0df4a42fccf86ef595e9d7e4a89d60e0341" translate="yes" xml:space="preserve">
          <source>Alternatively, core plugins can be specified with Template Haskell.</source>
          <target state="translated">另外,也可以用Template Haskell指定核心插件。</target>
        </trans-unit>
        <trans-unit id="1bde40f6b099fd2459055a9d8eec8e840639306e" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="translated">另外，如果您想自己构建GHC，请继续阅读&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Building&quot;&gt;GHC构建指南，&lt;/a&gt;以了解如何获取源并将其构建在系统上。请注意，GHC本身是用Haskell编写的，因此您仍然需要安装GHC才能进行构建。</target>
        </trans-unit>
        <trans-unit id="487925a0dfe33b56fabdc308b58c83700f73524a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to build GHC yourself, head on over to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/building&quot;&gt;GHC Building Guide&lt;/a&gt; to find out how to get the sources, and build it on your system. Note that GHC itself is written in Haskell, so you will still need to install GHC in order to build it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb5e0c35bffdb5bac67b4158b85ee94fc664745" translate="yes" xml:space="preserve">
          <source>Alternatively, use your &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; environment variable. Set it to the name of the directory where temporary files should be put. GCC and other programs will honour the &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; variable as well.</source>
          <target state="translated">或者，使用您的 &lt;code id=&quot;index-14&quot;&gt;TMPDIR&lt;/code&gt; 环境变量。将其设置为放置临时文件的目录的名称。GCC和其他程序也将使用 &lt;code id=&quot;index-15&quot;&gt;TMPDIR&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="7b0162a0bbd1d38dbdfc269cc088cc5f731a6ba2" translate="yes" xml:space="preserve">
          <source>Alternatively, you can give a type signature to the enclosing context, which GHC can &amp;ldquo;push down&amp;rdquo; to find the type for the variable:</source>
          <target state="translated">或者，您可以为封闭的上下文提供类型签名，GHC可以&amp;ldquo;按下&amp;rdquo;以查找变量的类型：</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="369a93d4fce888d55a59c31d08c7fb3c46433a3b" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="29cf9aad2a6fbceeb5608717dde74a1b736195b5" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14f8d1451ab6b8eb4e7c4771d4a0ca47ed0fa3c" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="9d4b54010820702fe99161a26c1a3fd6da57d30a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabfacf44a025fa1709c2ce0bc2ca417b25be0c8" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="2f75950244ae1b83eb1fa765162dcee833eb2b00" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f69795c586d406dd4511ba9d5155c1a42f2617" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="8f38ab9e9f8dc1070a59ba1354c8cbcf7666ec61" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9ddf09d766d5f9ca39130ead484571fe0feced" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="832b928147d026a938c7c9c4f9b77b788e8f12a1" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8713c63104594f55f79cca79583e8fe10117c5e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; has a type that is an instance of the type of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;, the two functions are subtly different:</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 的类型是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 类型的实例，但是这两个函数有细微的不同：</target>
        </trans-unit>
        <trans-unit id="e2ed5be7a335e3dba8612b72e2da7b9e639f8124" translate="yes" xml:space="preserve">
          <source>Although GHC allows the user to pass all unlifted boxed types to foreign functions, some of them are not amenable to useful work. Although &lt;code&gt;Array#&lt;/code&gt; is unlifted, the elements in its payload are lifted, and a foreign C function cannot safely force thunks. Consequently, a foreign C function may not dereference any of the addresses that comprise the payload of the &lt;code&gt;Array#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6b65048b50606bfc86ae17bba6c11487ce8b27" translate="yes" xml:space="preserve">
          <source>Although all open type families are considered to have a complete user-supplied kind signature, we can relax this condition for closed type families, where we have equations on which to perform kind inference. GHC will infer kinds for the arguments and result types of a closed type family.</source>
          <target state="translated">虽然所有的开放类型族都被认为有一个完整的用户提供的种类签名,但我们可以对封闭类型族放宽这个条件,因为我们有方程来执行种类推理。GHC将对封闭类型族的参数和结果类型进行种类推断。</target>
        </trans-unit>
        <trans-unit id="a8ba660b18337f8755c5f957412710cfb811a48b" translate="yes" xml:space="preserve">
          <source>Although it is equivalent to running GHC twice, using &lt;code&gt;-dynamic-too&lt;/code&gt; is more efficient, because the earlier phases of the compiler up to code generation are performed just once.</source>
          <target state="translated">尽管等效于运行GHC两次，但使用 &lt;code&gt;-dynamic-too&lt;/code&gt; 效率更高，因为直到代码生成的编译器早期阶段仅执行一次。</target>
        </trans-unit>
        <trans-unit id="17fe55cf03ef562c44820f718c2ff2b873fd70ad" translate="yes" xml:space="preserve">
          <source>Although it is unusual, there (currently) can be &lt;em&gt;multiple&lt;/em&gt; instances for an associated family in a single instance declaration. For example, this is legitimate:</source>
          <target state="translated">虽然这是不寻常的，有（目前）可以&lt;em&gt;多&lt;/em&gt;为相关的家人在一个实例声明实例。例如，这是合法的：</target>
        </trans-unit>
        <trans-unit id="c0e0fc4143b94596d60f1c94c3fec1d4b047aa5e" translate="yes" xml:space="preserve">
          <source>Although names generated by &lt;code&gt;newName&lt;/code&gt; cannot &lt;em&gt;be captured&lt;/em&gt;, they can &lt;em&gt;capture&lt;/em&gt; other names. For example, this:</source>
          <target state="translated">尽管无法&lt;em&gt;捕获&lt;/em&gt;由 &lt;code&gt;newName&lt;/code&gt; 生成的名称，但它们可以&lt;em&gt;捕获&lt;/em&gt;其他名称。例如，这：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="051c31d13e18e01e98444eb19f8ca75e805e3ed3" translate="yes" xml:space="preserve">
          <source>Although not recommended, the deprecated &lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt;&lt;code&gt;-fglasgow-exts&lt;/code&gt;&lt;/a&gt; flag enables a large swath of the extensions supported by GHC at once.</source>
          <target state="translated">尽管不建议使用，但已弃用的&lt;a href=&quot;#ghc-flag--fglasgow-exts&quot;&gt; &lt;code&gt;-fglasgow-exts&lt;/code&gt; &lt;/a&gt;标志可立即启用GHC支持的大量扩展。</target>
        </trans-unit>
        <trans-unit id="fca41e21a6d4cf355148dfe827eb5a105a329d84" translate="yes" xml:space="preserve">
          <source>Although only GHC implements arrow notation directly, there is also a preprocessor (available from the &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;arrows web page&lt;/a&gt;) that translates arrow notation into Haskell 98 for use with other Haskell systems. You would still want to check arrow programs with GHC; tracing type errors in the preprocessor output is not easy. Modules intended for both GHC and the preprocessor must observe some additional restrictions:</source>
          <target state="translated">尽管只有GHC直接实现箭头符号，但是也有一个预处理器（可从&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;箭头网页上获得&lt;/a&gt;），将箭头符号转换为Haskell 98以与其他Haskell系统一起使用。您仍然需要使用GHC检查箭头程序；在预处理器输出中跟踪类型错误并不容易。用于GHC和预处理器的模块必须遵守一些其他限制：</target>
        </trans-unit>
        <trans-unit id="030de1c351ae0b62dc7102e4cd4c0fd4463e840e" translate="yes" xml:space="preserve">
          <source>Although quantified constraints are a little like local instance declarations, they differ in one big way: the local instances are written by the compiler, not the user, and hence cannot introduce incoherence. Consider</source>
          <target state="translated">虽然量化约束有点像本地实例声明,但它们有一个很大的不同:本地实例是由编译器而不是用户编写的,因此不能引入不一致。考虑到</target>
        </trans-unit>
        <trans-unit id="917df874b8dc3f0710c076dbfbabbd379b501cb5" translate="yes" xml:space="preserve">
          <source>Although the distinction between &lt;em&gt;file&lt;/em&gt; symbolic links and &lt;em&gt;directory&lt;/em&gt; symbolic links does not exist on POSIX systems, on Windows this is an intrinsic property of every symbolic link and cannot be changed without recreating the link. A file symbolic link that actually points to a directory will fail to dereference and vice versa. Moreover, creating symbolic links on Windows may require privileges unavailable to users outside the Administrators group. Portable programs that use symbolic links should take both into consideration.</source>
          <target state="translated">尽管在POSIX系统上不存在&lt;em&gt;文件&lt;/em&gt;符号链接和&lt;em&gt;目录&lt;/em&gt;符号链接之间的区别，但在Windows上，这是每个符号链接的固有属性，并且不能在不重新创建链接的情况下进行更改。实际上指向目录的文件符号链接将无法取消引用，反之亦然。此外，在Windows上创建符号链接可能需要Administrators组之外的用户无法使用的特权。使用符号链接的可移植程序应同时考虑两者。</target>
        </trans-unit>
        <trans-unit id="99e9a14b3e8cd2cda9b0d1073e9a3e3d417a68e2" translate="yes" xml:space="preserve">
          <source>Although typechecking &lt;code&gt;T MyInt&lt;/code&gt; will terminate, GHC&amp;rsquo;s termination checker isn&amp;rsquo;t sophisticated enough to determine this, so you&amp;rsquo;ll need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; in order to use this derived instance. If you do go down this route, make sure you can convince yourself that all of the type family instances you&amp;rsquo;re deriving will eventually terminate if used!</source>
          <target state="translated">尽管类型检查 &lt;code&gt;T MyInt&lt;/code&gt; 将终止，但是GHC的终止检查器还不足以确定它，因此您需要启用&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;才能使用此派生实例。如果您确实走这条路，请确保您可以说服自己，派生的所有类型系列实例最终都将在使用后终止！</target>
        </trans-unit>
        <trans-unit id="6fee9b71141e5521bd00d271e9f736a2cbff6c7d" translate="yes" xml:space="preserve">
          <source>Although we have given only a few examples here, it should be clear that the addition of dependency information can help to make multiple parameter classes more useful in practice, avoiding ambiguity problems, and allowing more general sets of instance declarations.</source>
          <target state="translated">虽然我们在这里只举了几个例子,但应该清楚的是,增加依赖信息有助于使多参数类在实践中更加有用,避免歧义问题,并允许更通用的实例声明集。</target>
        </trans-unit>
        <trans-unit id="d34157ee16cf986f86cc94da23a34f265af1348f" translate="yes" xml:space="preserve">
          <source>Although, a data family is &lt;em&gt;introduced&lt;/em&gt; with the keyword &amp;ldquo;&lt;code&gt;data&lt;/code&gt;&amp;rdquo;, a data family &lt;em&gt;instance&lt;/em&gt; can use either &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;. For example:</source>
          <target state="translated">尽管使用关键字&amp;ldquo; &lt;code&gt;data&lt;/code&gt; &amp;rdquo; &lt;em&gt;引入&lt;/em&gt;了数据族，但是数据族&lt;em&gt;实例&lt;/em&gt;可以使用 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 。例如：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc69fe6d4cdd92804a7734b80adc8316333f1f44" translate="yes" xml:space="preserve">
          <source>Always fails.</source>
          <target state="translated">总是失败。</target>
        </trans-unit>
        <trans-unit id="d694f7e3dcf06959f0a7fcce2057e4016e3a9632" translate="yes" xml:space="preserve">
          <source>Always write interface files</source>
          <target state="translated">总是写接口文件</target>
        </trans-unit>
        <trans-unit id="acb5edef3f602d225f892db47fe7ee1f895d055d" translate="yes" xml:space="preserve">
          <source>Always write interface files. GHC will normally write interface files automatically, but this flag is useful with &lt;a href=&quot;#ghc-flag--fno-code&quot;&gt;&lt;code&gt;-fno-code&lt;/code&gt;&lt;/a&gt;, which normally suppresses generation of interface files. This is useful if you want to type check over multiple runs of GHC without compiling dependencies.</source>
          <target state="translated">始终编​​写接口文件。GHC通常会自动写入接口文件，但是此标志对于&lt;a href=&quot;#ghc-flag--fno-code&quot;&gt; &lt;code&gt;-fno-code&lt;/code&gt; &lt;/a&gt;很有用，它通常会抑制接口文件的生成。如果要在不编译依赖项的情况下对GHC的多个运行进行类型检查，这将很有用。</target>
        </trans-unit>
        <trans-unit id="770876e2d8a6f234b57db2323d7a120bd5cefd2f" translate="yes" xml:space="preserve">
          <source>Ambiguity can be subtle. Consider this example which uses functional dependencies:</source>
          <target state="translated">歧义可能是微妙的。考虑这个使用功能依赖的例子。</target>
        </trans-unit>
        <trans-unit id="3ee65b18fc60dcabb8937e100f2503fb55e37a11" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;a href=&quot;#pragma-CONLIKE&quot;&gt;&lt;code&gt;CONLIKE&lt;/code&gt;&lt;/a&gt; modifier, which affects matching in &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03a800321c3532f62fd50dbd5f813f55dc2c76d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma may have a &lt;code&gt;CONLIKE&lt;/code&gt; modifier, which affects matching in &lt;code&gt;RULE&lt;/code&gt;s (only). See &lt;a href=&quot;#conlike&quot;&gt;How rules interact with CONLIKE pragmas&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示可具有 &lt;code&gt;CONLIKE&lt;/code&gt; 改性剂，这会影响在匹配 &lt;code&gt;RULE&lt;/code&gt; 秒（只）。请参阅&lt;a href=&quot;#conlike&quot;&gt;规则如何与CONLIKE实用程序交互&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de96fd13e454f7d0ced988da0b0fe6591f42a8af" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; is mutable location that is either empty or contains a value of type &lt;code&gt;t&lt;/code&gt;. It has two fundamental operations: &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; which fills an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is empty and blocks otherwise, and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; which empties an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if it is full and blocks otherwise. They can be used in multiple different ways:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; t&lt;/code&gt; 是可变的位置是空或者包含的类型的值 &lt;code&gt;t&lt;/code&gt; 。它有两个基本操作： &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 会在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 为空时填充MVar，否则会阻塞；而 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 会在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 已满时清空MVar，否则会阻塞。它们可以以多种不同方式使用：</target>
        </trans-unit>
        <trans-unit id="bfc651b7b6015a5d38e8dc9b2d2cd9a41bf19609" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; （发音为&amp;ldquo;EM-VAR&amp;rdquo;）是一个同步的变量，用于并发线程之间的通信。可以将其视为一个盒子，可以是空的或满的。</target>
        </trans-unit>
        <trans-unit id="52e415725c78688d42711652a7e4079f14251bb6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 是可变的，盒装，非严格在阵列 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="e750e5e924cba57bf36a0ebd4161427cec7557d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c3205df3a50720edd8ad6a1e53cf3a8ebdb0c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 是可变的，盒装，非严格在阵列 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="4f847ae13cb0b0976d90acd768ce3eab18b000b5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-io-safe#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47281938d8ea8fab14ec059d784740642bb1fcd7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 通常将是更有效的（在时间和空间方面）比等效盒装版本（ &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; ）具有相同的元素类型。但是， &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 的元素非常严格-因此，如果您需要 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 提供的非严格性，请不要使用 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ab056c484cefd1634f35523d774bd2bf27bc81" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent boxed version (&lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt;) with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 通常将是更有效的（在时间和空间方面）比等效盒装版本（ &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; ）具有相同的元素类型。但是， &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 的元素非常严格-因此，如果您需要 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STArray&quot;&gt;STArray&lt;/a&gt;&lt;/code&gt; 提供的非严格性，请不要使用 &lt;code&gt;&lt;a href=&quot;data-array-st-safe#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72c0a99e8a213a03ed1ff5d7bad4f8d34a4fe41" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; instance is always required (but it can just ignore the meta-information, as is the case for &lt;code&gt;encode&lt;/code&gt; above).</source>
          <target state="translated">始终需要一个 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 实例（但是它可以忽略元信息，就像上面的 &lt;code&gt;encode&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c6430d754f6ee1e74237537560c890d61207b930" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; is a mutable, boxed, non-strict array in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 是可变的，盒装，非严格在阵列 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="9fec238ef2447aa47087bb9d112fb0dd69cdcd4c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (pronounced &quot;em-var&quot;) is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; （发音为&amp;ldquo;EM-VAR&amp;rdquo;）是一个同步的变量，用于并发线程之间的通信。可以将其视为一个盒子，可以是空的或满的。</target>
        </trans-unit>
        <trans-unit id="e64ebf00aaf703cb98269bd37718878465c05c15" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;INLINE&lt;/code&gt; function is not worker/wrappered by strictness analysis. It&amp;rsquo;s going to be inlined wholesale instead.</source>
          <target state="translated">严格性分析不能对 &lt;code&gt;INLINE&lt;/code&gt; 函数进行辅助/包装。它将改为内联批发。</target>
        </trans-unit>
        <trans-unit id="683b56235dbe6d9de132b9c32113d5f5fe04aa0c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InstalledPackageInfo&lt;/code&gt; has a human readable/writable syntax. The functions &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; and &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; read and write this syntax respectively. Here&amp;rsquo;s an example of the &lt;code&gt;InstalledPackageInfo&lt;/code&gt; for the &lt;code&gt;unix&lt;/code&gt; package:</source>
          <target state="translated">一个 &lt;code&gt;InstalledPackageInfo&lt;/code&gt; 具有人可读/可写的语法。函数 &lt;code&gt;parseInstalledPackageInfo&lt;/code&gt; 和 &lt;code&gt;showInstalledPackageInfo&lt;/code&gt; 分别读取和写入此语法。下面是一个例子 &lt;code&gt;InstalledPackageInfo&lt;/code&gt; 为 &lt;code&gt;unix&lt;/code&gt; 包：</target>
        </trans-unit>
        <trans-unit id="3a2c03ccefc5072e12ca70273302c1ee7ab6f1d5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;OperatorTable s u m a&lt;/code&gt; is a list of &lt;code&gt;Operator s u m a&lt;/code&gt; lists. The list is ordered in descending precedence. All operators in one list have the same precedence (but may have a different associativity).</source>
          <target state="translated">一个 &lt;code&gt;OperatorTable s u m a&lt;/code&gt; 是列表 &lt;code&gt;Operator s u m a&lt;/code&gt; 名单。该列表以降序排列。一个列表中的所有运算符都具有相同的优先级（但可能具有不同的关联性）。</target>
        </trans-unit>
        <trans-unit id="0f9933684475c3885933d3cb45f7d700d24f1bf2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; pragma on a function &lt;code&gt;f&lt;/code&gt; has the following behaviour:</source>
          <target state="translated">函数 &lt;code&gt;f&lt;/code&gt; 上的 &lt;code&gt;{-# INLINABLE f #-}&lt;/code&gt; 注具有以下行为：</target>
        </trans-unit>
        <trans-unit id="b9ded8006363b78c478c9d256d512759af3de706" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;orphan module&lt;/em&gt; orphan module contains at least one &lt;em&gt;orphan instance&lt;/em&gt; or at least one &lt;em&gt;orphan rule&lt;/em&gt;.</source>
          <target state="translated">一个&lt;em&gt;孤立模块一个&lt;/em&gt;孤立模块包含至少一个&lt;em&gt;孤立实例&lt;/em&gt;或至少一个&lt;em&gt;孤立规则&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e3de3cb88319a179768b2746e40461a71f436143" translate="yes" xml:space="preserve">
          <source>An FFI binding to the hot key part of the Win32 API.</source>
          <target state="translated">与Win32 API热键部分的FFI绑定。</target>
        </trans-unit>
        <trans-unit id="cbfb652fdf79531cc3d86d6d11da84e45c07abbf" translate="yes" xml:space="preserve">
          <source>An FFI binding to the system part of the Win32 API.</source>
          <target state="translated">与Win32 API系统部分的FFI绑定。</target>
        </trans-unit>
        <trans-unit id="451395d3497bffe11685a4808d989a520d0e956e" translate="yes" xml:space="preserve">
          <source>An HValueRef with a finalizer</source>
          <target state="translated">一个带有定标器的HValueRef</target>
        </trans-unit>
        <trans-unit id="d2d296bd0d9d97c26c27e28a4f8f9fc312ec86a0" translate="yes" xml:space="preserve">
          <source>An I/O event.</source>
          <target state="translated">一个I/O事件。</target>
        </trans-unit>
        <trans-unit id="9d61e77c59f8de3e6e0f09bd0569bdcfd960fe05" translate="yes" xml:space="preserve">
          <source>An IO monad wrapped in &lt;code&gt;StateT&lt;/code&gt; inside of &lt;code&gt;ErrorT&lt;/code&gt;:</source>
          <target state="translated">包裹在 &lt;code&gt;StateT&lt;/code&gt; 内部的 &lt;code&gt;ErrorT&lt;/code&gt; 的IO monad ：</target>
        </trans-unit>
        <trans-unit id="7426b52720da94bc2bc36c2af36224d9d16ed966" translate="yes" xml:space="preserve">
          <source>An ML-style language usually generalises the type of any &lt;code&gt;let&lt;/code&gt;-bound or &lt;code&gt;where&lt;/code&gt;-bound variable, so that it is as polymorphic as possible. With the extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; GHC implements a slightly more conservative policy, using the following rules:</source>
          <target state="translated">ML风格的语言通常会概括任何 &lt;code&gt;let&lt;/code&gt; - bound或 &lt;code&gt;where&lt;/code&gt; - bound变量的类型，以便使其尽可能多态。通过扩展，&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; GHC使用以下规则实施了更为保守的策略：</target>
        </trans-unit>
        <trans-unit id="9cefabc3584d4516f625a578f6ab414f96911025" translate="yes" xml:space="preserve">
          <source>An RTS debugging flag; only available if the program was linked with the &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt; option. Various values of ⟨x⟩ are provided to enable debug messages and additional runtime sanity checks in different subsystems in the RTS, for example &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; enables debug messages from the scheduler. Use &lt;code&gt;+RTS -?&lt;/code&gt; to find out which debug flags are supported.</source>
          <target state="translated">RTS调试标志；仅当程序与&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;选项链接时才可用。提供各种&amp;ldquo; xx&amp;rdquo;值来启用调试消息和RTS中不同子系统中的其他运行时完整性检查，例如 &lt;code&gt;+RTS -Ds -RTS&lt;/code&gt; 启用来自调度程序的调试消息。使用 &lt;code&gt;+RTS -?&lt;/code&gt; 找出支持哪些调试标志。</target>
        </trans-unit>
        <trans-unit id="4e45674dc1c637028f0f01799a8815e6ecb98130" translate="yes" xml:space="preserve">
          <source>An XHTML combinator library.</source>
          <target state="translated">一个XHTML组合库。</target>
        </trans-unit>
        <trans-unit id="09858e905a1c37c93edf149194a2d9bb2ce3582b" translate="yes" xml:space="preserve">
          <source>An abstract interface to a unique symbol generator.</source>
          <target state="translated">一个独特符号生成器的抽象接口。</target>
        </trans-unit>
        <trans-unit id="c3d4f7cf1abe842d95a74003b96fc062bd25f990" translate="yes" xml:space="preserve">
          <source>An abstract name for an object, that supports equality and hashing.</source>
          <target state="translated">对象的抽象名称,支持平等和散列。</target>
        </trans-unit>
        <trans-unit id="c7780c030353da535248bab25cc8ad315039483b" translate="yes" xml:space="preserve">
          <source>An abstract type representing names in the syntax tree.</source>
          <target state="translated">一个抽象类型,代表语法树中的名称。</target>
        </trans-unit>
        <trans-unit id="3739511153de0d9b79bcbb692e2cd72c742f7bd7" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包含每个 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 变体的值的抽象类型。</target>
        </trans-unit>
        <trans-unit id="580e2ee0cc2d32003a3cd07143debcb038d87924" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包含每个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 变体的值的抽象类型。</target>
        </trans-unit>
        <trans-unit id="4efb40389fa8d66e189c71d212784428f0bae6b2" translate="yes" xml:space="preserve">
          <source>An abstract type that contains a value for each variant of &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包含每个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 变体的值的抽象类型。</target>
        </trans-unit>
        <trans-unit id="35eff700132dbe6d90bfc15821db76d5acbdf25d" translate="yes" xml:space="preserve">
          <source>An abstract unique object. Objects of type &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; may be compared for equality and ordering and hashed into &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">抽象的唯一对象。可以比较 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 类型的对象的相等性和顺序，并将其哈希到 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="21c7f832db5783c3e7a8088c500d2962ed9384be" translate="yes" xml:space="preserve">
          <source>An accumulating function</source>
          <target state="translated">累积函数</target>
        </trans-unit>
        <trans-unit id="b61c87037791a3b504bed8e01931aafc2fc5942c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">由输出类型 &lt;code&gt;w&lt;/code&gt; 参数化的累加单子要累加。</target>
        </trans-unit>
        <trans-unit id="f7cc330fe5c9abb7f58e424cead33a14c496fa0c" translate="yes" xml:space="preserve">
          <source>An accumulation monad parameterized by:</source>
          <target state="translated">一个积累单体的参数为:</target>
        </trans-unit>
        <trans-unit id="282bf0a0b47e57c828188f0a009349e911a1315e" translate="yes" xml:space="preserve">
          <source>An action which sends output to the terminal. That output may mix plain text with control characters and escape sequences, along with delays (called &quot;padding&quot;) required by some older terminals.</source>
          <target state="translated">向终端发送输出的操作。该输出可能会混合纯文本与控制字符和转义序列,以及一些旧终端所需的延迟(称为 &quot;填充&quot;)。</target>
        </trans-unit>
        <trans-unit id="40621b0cc1f828021b505715d70a5c3153c57b8e" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="35feeff338058bf37c6e24f0244366473367a8b7" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;--nonmoving-gc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbb51b39bb5ee9826d87215f4821611643eee9b" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt;&lt;code&gt;-ddump-ticked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ticked&quot;&gt; &lt;code&gt;-ddump-ticked&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="8b292908bf0d2936fbcd16984eafba397dbc968a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="a37301a9d0fe7303c2440af029087f787465968c" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="39f245d534c3b422c9edc0bbe9598133641be7f8" translate="yes" xml:space="preserve">
          <source>An alias for modifyState for backwards compatibility.</source>
          <target state="translated">modifyState的别名,用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="99e294020522b0531d3dadc4d8bef2d2fd79bf01" translate="yes" xml:space="preserve">
          <source>An alias for putState for backwards compatibility.</source>
          <target state="translated">putState的别名,用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="709a0f933c96849749d91e33427992ea15ebf916" translate="yes" xml:space="preserve">
          <source>An allocation strategy that does not trim any of the filled buffers before converting it to a chunk</source>
          <target state="translated">一种分配策略,在将其转换为一个块之前,不修剪任何填充的缓冲区。</target>
        </trans-unit>
        <trans-unit id="7cb706568d5dabeb772af56d1f92199b0a7ee949" translate="yes" xml:space="preserve">
          <source>An allocation strategy that guarantees that at least half of the allocated memory is used for live data</source>
          <target state="translated">保证至少一半的分配内存用于实时数据的分配策略。</target>
        </trans-unit>
        <trans-unit id="c8a358c8e089a8a6ad543274e213736fdd805423" translate="yes" xml:space="preserve">
          <source>An alternative sort. Sorts by checking which hole fits subsume other hole fits, such that if hole fit a could be used as hole fits for hole fit b, then b appears before a in the output. It is more precise than the default sort, but also a lot slower, since a subsumption check has to be run for each pair of valid hole fits.</source>
          <target state="translated">另一种排序方式。通过检查哪些孔配合从属于其他孔配合来排序,如果孔配合a可以被用作孔配合b的孔配合,那么在输出中b出现在a之前。它比默认排序更精确,但也慢了很多,因为每一对有效的孔配合都要运行一个归并检查。</target>
        </trans-unit>
        <trans-unit id="85c8ea4d2925dfd094cde7445f68c6da3c037dbf" translate="yes" xml:space="preserve">
          <source>An ambiguous selector may be disambiguated by the type being &amp;ldquo;pushed down&amp;rdquo; to the occurrence of the selector (see &lt;a href=&quot;#higher-rank-type-inference&quot;&gt;Type inference&lt;/a&gt; for more details on what &amp;ldquo;pushed down&amp;rdquo; means). For example, the following are permitted:</source>
          <target state="translated">模棱两可的选择器可能会因&amp;ldquo;按下&amp;rdquo;到选择器的出现而消除歧义（有关&amp;ldquo;按下&amp;rdquo;的含义的更多详细信息，请参见&lt;a href=&quot;#higher-rank-type-inference&quot;&gt;类型推断&lt;/a&gt;）。例如，允许以下内容：</target>
        </trans-unit>
        <trans-unit id="cb9d0b854775c17b2c5aff97ccac59e5200fac6e" translate="yes" xml:space="preserve">
          <source>An amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the length of the sequence and &lt;em&gt;i&lt;/em&gt; being the integral index used by some operations. These bounds hold even in a persistent (shared) setting.</source>
          <target state="translated">给出了每个操作的摊销运行时间，其中&lt;em&gt;n&lt;/em&gt;表示序列的长度，&lt;em&gt;i&lt;/em&gt;是某些操作使用的整数索引。这些界限甚至在持久（共享）设置中也成立。</target>
        </trans-unit>
        <trans-unit id="6ce9dd94558d3a6cb7c491d6ce3c6738daadefaa" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">附加在 &lt;code&gt;Doc&lt;/code&gt; 中特定点的注释（边元数据）。允许在附加在结构中特定点的 &lt;code&gt;Doc&lt;/code&gt; 中携带非精美打印的数据。将 &lt;code&gt;Doc&lt;/code&gt; 呈现为输出类型（例如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）后，我们还可以检索注释在呈现的文档中的开始和结束位置（请参见 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11d313098b3ec3f985281ba5d03b5e871c638cd4" translate="yes" xml:space="preserve">
          <source>An annotation (side-metadata) attached at a particular point in a &lt;code&gt;Doc&lt;/code&gt;. Allows carrying non-pretty-printed data around in a &lt;code&gt;Doc&lt;/code&gt; that is attached at particular points in the structure. Once the &lt;code&gt;Doc&lt;/code&gt; is render to an output type (such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;), we can also retrieve where in the rendered document our annotations start and end (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:renderSpans&quot;&gt;renderSpans&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a5bd4a90cc650cc053e5d8d2d60daef1c2e891" translate="yes" xml:space="preserve">
          <source>An applicative functor that collects a monoid (e.g. lists) of errors. A sequence of computations fails if any of its components do, but unlike monads made with &lt;code&gt;ExceptT&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;, these computations continue after an error, collecting all the errors.</source>
          <target state="translated">收集错误的单态（例如列表）的应用函子。如果任何组件做不像做单子计算的序列会失败，但 &lt;code&gt;ExceptT&lt;/code&gt; 从&lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;，这些计算继续错误后，收集所有的错误。</target>
        </trans-unit>
        <trans-unit id="bc070c7328fa5d3571a45acb079f74b2dde0b0b6" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 的适用版本。</target>
        </trans-unit>
        <trans-unit id="3cf3d115218ff8bff3d10483bba1404c9ab4c403" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 的适用版本。</target>
        </trans-unit>
        <trans-unit id="97a468ebf5cf1c674abd871e054ea2dee404c992" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 的适用版本。</target>
        </trans-unit>
        <trans-unit id="714a850af4acc6ad522e25162362c1e340e36f2e" translate="yes" xml:space="preserve">
          <source>An applicative version of &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 的适用版本。</target>
        </trans-unit>
        <trans-unit id="3e4069001a63b95ceb7dda105321002b8f3e3ba6" translate="yes" xml:space="preserve">
          <source>An arbitrary machine address assumed to point outside the garbage-collected heap.</source>
          <target state="translated">假设一个任意的机器地址指向垃圾回收堆之外。</target>
        </trans-unit>
        <trans-unit id="8bf5023dfbbe40314a1c91c2950b274f9f5333cc" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="translated">数组类型具有 &lt;code&gt;(a i e)&lt;/code&gt; 形式，其中 &lt;code&gt;a&lt;/code&gt; 是数组类型构造函数（kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ）， &lt;code&gt;i&lt;/code&gt; 是索引类型（类 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 的成员）， &lt;code&gt;e&lt;/code&gt; 是元素类型。</target>
        </trans-unit>
        <trans-unit id="f333085677822b91b2d6266691a5fadac493bad0" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="translated">数组类型具有 &lt;code&gt;(a i e)&lt;/code&gt; 形式，其中 &lt;code&gt;a&lt;/code&gt; 是数组类型构造函数（kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; ）， &lt;code&gt;i&lt;/code&gt; 是索引类型（类 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 的成员）， &lt;code&gt;e&lt;/code&gt; 是元素类型。所述 &lt;code&gt;IArray&lt;/code&gt; 类是参数在两个 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; ，使实例专用于某些元素类型可以被定义。</target>
        </trans-unit>
        <trans-unit id="fd0764a85da5b607f0944932a419f16b24701a2a" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b79318296e9a1df365be13462713df9a22390f7" translate="yes" xml:space="preserve">
          <source>An array type has the form &lt;code&gt;(a i e)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the array type constructor (kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;), &lt;code&gt;i&lt;/code&gt; is the index type (a member of the class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt;), and &lt;code&gt;e&lt;/code&gt; is the element type. The &lt;code&gt;IArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, so that instances specialised to certain element types can be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15133cd1e98c4cec2d0b6095c794ad5b60cd611" translate="yes" xml:space="preserve">
          <source>An assembly-language source file, usually produced by the compiler.</source>
          <target state="translated">一个汇编语言的源文件,通常由编译器产生。</target>
        </trans-unit>
        <trans-unit id="e94a0acd4447829f7e16f2e0681abc5b94e72a47" translate="yes" xml:space="preserve">
          <source>An associated type or data family declaration has a CUSK precisely if its enclosing class has a CUSK.</source>
          <target state="translated">一个关联的类型或数据族声明,如果它的外层类有一个CUSK,那么它就有一个CUSK。</target>
        </trans-unit>
        <trans-unit id="9a839446e60f1231647068f143a30b2ecfe17004" translate="yes" xml:space="preserve">
          <source>An association is a pair of the form &lt;code&gt;(i,x)&lt;/code&gt;, which defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;. The array is undefined if any index in the list is out of bounds. If any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">的关联是一对的形式的 &lt;code&gt;(i,x)&lt;/code&gt; ，其在索引定义了阵列的值 &lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;x&lt;/code&gt; 。如果列表中的任何索引超出范围，则该数组未定义。如果列表中的任何两个关联具有相同的索引，则该索引处的值取决于实现。（在GHC中，使用为该索引指定的最后一个值。其他实现也将对未装箱的数组执行此操作，但是Haskell 98要求对于 &lt;code&gt;Array&lt;/code&gt; ，此类索引处的值应为底部。）</target>
        </trans-unit>
        <trans-unit id="3afb607a33ed15aef025831322f63f1a04d9a09d" translate="yes" xml:space="preserve">
          <source>An associative binary operation</source>
          <target state="translated">一个关联的二进制操作</target>
        </trans-unit>
        <trans-unit id="1147ac2d130bd449477786144a5c8a1b76f89092" translate="yes" xml:space="preserve">
          <source>An associative operation</source>
          <target state="translated">一个关联操作</target>
        </trans-unit>
        <trans-unit id="8ce47487694776c0a4231b6d5c5f44ab8e16a07a" translate="yes" xml:space="preserve">
          <source>An associative operation with identity &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标识 &lt;code&gt;&lt;a href=&quot;control-arrow#v:zeroArrow&quot;&gt;zeroArrow&lt;/a&gt;&lt;/code&gt; 的关联操作。</target>
        </trans-unit>
        <trans-unit id="8f702f0949aff10d3524aea50e9531b4e09362c3" translate="yes" xml:space="preserve">
          <source>An associative operation.</source>
          <target state="translated">一个关联的操作。</target>
        </trans-unit>
        <trans-unit id="d3660f5f8cdd17a078c28b99ce21ad421e42c7b8" translate="yes" xml:space="preserve">
          <source>An associative operation. The default definition is</source>
          <target state="translated">一个关联操作。默认定义是</target>
        </trans-unit>
        <trans-unit id="e8163d537de96930d1551a2bbdc32c863286eb63" translate="yes" xml:space="preserve">
          <source>An attempt was made to evaluate an element of an array that had not been initialized.</source>
          <target state="translated">有人试图评估一个未被初始化的数组元素。</target>
        </trans-unit>
        <trans-unit id="578f42dbdd127ca4fccb4e419110bd0c78e68ac1" translate="yes" xml:space="preserve">
          <source>An attempt was made to index an array outside its declared bounds.</source>
          <target state="translated">有人试图在其声明的范围之外为一个数组编制索引。</target>
        </trans-unit>
        <trans-unit id="424d796a4ce39c6e1c11527f6f9821335c409254" translate="yes" xml:space="preserve">
          <source>An easy extension is to allow arbitrary contexts before the constructor. For example:</source>
          <target state="translated">一个简单的扩展是在构造函数之前允许任意的上下文。例如</target>
        </trans-unit>
        <trans-unit id="aa4b3e7e1ba4fecc1be2a9b715baa31cf5742128" translate="yes" xml:space="preserve">
          <source>An edge from the first vertex to the second.</source>
          <target state="translated">从第一顶点到第二顶点的一条边。</target>
        </trans-unit>
        <trans-unit id="4dfc37a5d88a5cef62918450d61f82ec135f66a3" translate="yes" xml:space="preserve">
          <source>An efficient deserialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 的高效反序列化器。</target>
        </trans-unit>
        <trans-unit id="9abf3b4b588f08354857f088c37e909380ccb8c8" translate="yes" xml:space="preserve">
          <source>An efficient get method for lazy ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input.</source>
          <target state="translated">惰性ByteString的有效get方法。如果输入中少于 &lt;code&gt;n&lt;/code&gt; 个字节，则失败。</target>
        </trans-unit>
        <trans-unit id="779d338d8d1396567da301a0915991a8253fcb3d" translate="yes" xml:space="preserve">
          <source>An efficient get method for strict ByteStrings. Fails if fewer than &lt;code&gt;n&lt;/code&gt; bytes are left in the input. If &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; then the empty string is returned.</source>
          <target state="translated">严格的ByteStrings的有效get方法。如果输入中少于 &lt;code&gt;n&lt;/code&gt; 个字节，则失败。如果 &lt;code&gt;n &amp;lt;= 0&lt;/code&gt; 则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="64a0398b712134b5c921639d4662413422147955" translate="yes" xml:space="preserve">
          <source>An efficient implementation of integer sets.</source>
          <target state="translated">整数集的有效实现。</target>
        </trans-unit>
        <trans-unit id="ed7ff4240488108e796dda83b8f8a885a21e7f97" translate="yes" xml:space="preserve">
          <source>An efficient implementation of maps from integer keys to values (dictionaries).</source>
          <target state="translated">高效实现从整数键到值(字典)的映射。</target>
        </trans-unit>
        <trans-unit id="300c10f93efb7d8e708d1538e08d8d7e538b4d21" translate="yes" xml:space="preserve">
          <source>An efficient implementation of ordered maps from keys to values (dictionaries).</source>
          <target state="translated">高效实现从键到值的有序映射(字典)。</target>
        </trans-unit>
        <trans-unit id="9c17d2bea255ffe0974a30b48457084e4d307e5f" translate="yes" xml:space="preserve">
          <source>An efficient primitive to write a strict ByteString into the output buffer. It flushes the current buffer, and writes the argument into a new chunk.</source>
          <target state="translated">一个高效的基元,用于将一个严格的ByteString写入输出缓冲区。它刷新当前的缓冲区,并将参数写入一个新的块中。</target>
        </trans-unit>
        <trans-unit id="409ad01192a6191df9780f4e796153ec80522cce" translate="yes" xml:space="preserve">
          <source>An efficient serialiser of &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 的高效串行器。</target>
        </trans-unit>
        <trans-unit id="e6015ce2daa6533d6818de8c86f4d41b485e9542" translate="yes" xml:space="preserve">
          <source>An empty document</source>
          <target state="translated">一个空文件</target>
        </trans-unit>
        <trans-unit id="ce3be77c03c4e3699f0fd72a41b3ed4e3a5f892e" translate="yes" xml:space="preserve">
          <source>An empty graph.</source>
          <target state="translated">一个空图。</target>
        </trans-unit>
        <trans-unit id="60a7cfffba592bf3fc0701b5fe4cb99cba424d1c" translate="yes" xml:space="preserve">
          <source>An empty immutable array.</source>
          <target state="translated">一个空的不可更改的数组。</target>
        </trans-unit>
        <trans-unit id="110c4ac770ed6cac3b6a8ac6f3769b9a42dfce56" translate="yes" xml:space="preserve">
          <source>An empty piece of HTML.</source>
          <target state="translated">一段空的HTML。</target>
        </trans-unit>
        <trans-unit id="863735067735f8b0df4ec524f2091a6814c632b6" translate="yes" xml:space="preserve">
          <source>An encoding in which Unicode code points are translated to bytes by taking the code point modulo 256. When decoding, bytes are translated directly into the equivalent code point.</source>
          <target state="translated">一种编码方式,Unicode码点通过取码点的模数256翻译成字节。解码时,字节直接翻译成等效码点。</target>
        </trans-unit>
        <trans-unit id="379731e74a8a7303ee4ec5e7849e8a388a898a4e" translate="yes" xml:space="preserve">
          <source>An equivalent form for that example, avoiding explicit &lt;code&gt;forall&lt;/code&gt; uses &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;:</source>
          <target state="translated">该示例的等效形式，避免显式 &lt;code&gt;forall&lt;/code&gt; 使用&lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern类型签名&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2317b7500211efb11dba6702f8ff358cab78a9f0" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">表示由于其参数之一已存在而导致 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="9c5c1ab24132ff1db5fc41f514c9dd3d02f6830b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">表示由于其参数之一不存在而导致 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="a44dec7bdac91aad0789fdf13b8614448d0c3e1b" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">表示由于无法执行 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作而导致的错误。返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 结果的任何计算都可能因 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 失败。在某些情况下，实现将无法区分可能的错误原因。在这种情况下，它应该使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="4f839fc9cbc9a7a46f4c3ef068799b74f941ae12" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">一个错误，指示 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败，因为用户没有足够的操作系统特权来执行该操作。</target>
        </trans-unit>
        <trans-unit id="353bc4608932aa64def2cb47401212891190e861" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afac72a08e880e338eb3054c3cc4cb3b2c8d874a" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa08b0c059f66a3dd7b2f5959546d1e6588e7a9f" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdd36f108f41c6140824253d332a12f73fc5123" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66b1c80ba834855aae9f9d43d3592e67e98a671" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments already exists.</source>
          <target state="translated">表示由于其参数之一已存在而导致 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="84e040a37ce664544af44aa14d72c1c5b1f5fdf7" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments does not exist.</source>
          <target state="translated">表示由于其参数之一不存在而导致 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="3aaf153bc2f4b4a705a6640c9e8a13f49833a532" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because one of its arguments is a single-use resource, which is already being used (for example, opening the same file twice for writing might give this error).</source>
          <target state="translated">一个错误，指示 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败，因为其参数之一是已被使用的一次性资源（例如，两次打开相同的文件进行写入可能会出现此错误）。</target>
        </trans-unit>
        <trans-unit id="fbdf1497d8ba0761ae0294d7cba12faf35e238d8" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the device is full.</source>
          <target state="translated">表示由于设备已满而导致 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="587d82956d47a090dc9d6a33c66777d643e7e317" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the end of file has been reached.</source>
          <target state="translated">表示由于已到达文件末尾而导致 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败的错误。</target>
        </trans-unit>
        <trans-unit id="0cfca5871ab77adff3cb578bb0516ceb582413e3" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the operation was not possible. Any computation which returns an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; result may fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;. In some cases, an implementation will not be able to distinguish between the possible error causes. In this case it should fail with &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">表示由于无法执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作而导致的错误。返回 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 结果的任何计算都可能因 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 失败。在某些情况下，实现将无法区分可能的错误原因。在这种情况下，它应该使用 &lt;code&gt;&lt;a href=&quot;system-io-error#v:isIllegalOperation&quot;&gt;isIllegalOperation&lt;/a&gt;&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="5f1a557e45ff222ff19723cc3b00907ab8191320" translate="yes" xml:space="preserve">
          <source>An error indicating that an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">一个错误，指示 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作失败，因为用户没有足够的操作系统特权来执行该操作。</target>
        </trans-unit>
        <trans-unit id="502a1695e398902350a22b419e2e0b7872570bf2" translate="yes" xml:space="preserve">
          <source>An error indicating that the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8588ea4ffd2451e25b457e42e986ce533b40b9" translate="yes" xml:space="preserve">
          <source>An example from &lt;em&gt;The Craft of Functional Programming&lt;/em&gt;, Simon Thompson (&lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt;), Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a tree of integers in which the original elements are replaced by natural numbers, starting from 0. The same element has to be replaced by the same number at every occurrence, and when we meet an as-yet-unvisited element we have to find a 'new' number to match it with:&quot;</source>
          <target state="translated">从一个实例&lt;em&gt;函数式编程的工艺&lt;/em&gt;，西蒙&amp;middot;汤普森（&lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/sjt/&quot;&gt;http://www.cs.kent.ac.uk/people/staff/sjt/&lt;/a&gt;），Addison-Wesley出版社1999年：&amp;ldquo;给定一个任意的树，将其转换成树整数，其中原始元素从0开始用自然数替换。每次出现相同的元素时，都必须用相同的数字替换，并且当我们遇到一个尚未被访问的元素时，我们必须找到一个'new '与之匹配的数字：&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="26553b69de76ef603493e22f9b56e8e8f0e7cc55" translate="yes" xml:space="preserve">
          <source>An example in which using &lt;code&gt;RULES&lt;/code&gt; for specialisation will Win Big:</source>
          <target state="translated">一个使用 &lt;code&gt;RULES&lt;/code&gt; 进行专业化将赢得成功的例子：</target>
        </trans-unit>
        <trans-unit id="d94ee3fed69a3a2d6cbb28624b1e2c3a6d9674bc" translate="yes" xml:space="preserve">
          <source>An example is shown in the opening example, where &lt;code&gt;sortWith&lt;/code&gt; is supplied with a function that lets it find out the &lt;code&gt;sum salary&lt;/code&gt; for any item in the list comprehension it transforms.</source>
          <target state="translated">在开头的示例中显示了一个示例，其中 &lt;code&gt;sortWith&lt;/code&gt; 提供了一个函数，该函数可以让它找出要转换的列表理解中任何项目的 &lt;code&gt;sum salary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92f996a82b303141412a037410a747eab994f16e" translate="yes" xml:space="preserve">
          <source>An example of a pre-processor is to convert your source files to the input encoding that GHC expects, i.e. create a script &lt;code&gt;convert.sh&lt;/code&gt; containing the lines:</source>
          <target state="translated">预处理程序的一个示例是将您的源文件转换为GHC期望的输入编码，即创建一个包含以下行的脚本 &lt;code&gt;convert.sh&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="46db75079dc947994d3c8f73c95f7d8d5b14f912" translate="yes" xml:space="preserve">
          <source>An example of a suitable Euclidean function, for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;'s instance, is &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 而言，合适的欧几里得函数的一个示例是 &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c01fc02e927a60926df24dbe6dfbd1b4746279b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 的一个示例可能是根据字符串的长度对 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 字符串进行排序：</target>
        </trans-unit>
        <trans-unit id="bd7ad3a60a7ec7010ecf8274734b34b569a3aa76" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的示例可能是根据字符串的长度对Seq字符串进行排序：</target>
        </trans-unit>
        <trans-unit id="fd78ec4b25edfc34c070db47b86faa55268ea5fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 的一个示例可能是根据字符串的长度对 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 字符串进行排序：</target>
        </trans-unit>
        <trans-unit id="2aef6af3f5288d7dec723009106ae656cb18d0ec" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; might be to sort a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; of strings according to their length:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的示例可能是根据字符串的长度对Seq字符串进行排序：</target>
        </trans-unit>
        <trans-unit id="37825ef9057435b5d70e42055abe88a2f5caa9ef" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from C++ is:</source>
          <target state="translated">从C ++ 使用 &lt;code&gt;Adder.dll&lt;/code&gt; 的示例是：</target>
        </trans-unit>
        <trans-unit id="284aba923f06dcb4f47c7f3c609dae9afb54f97b" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;Adder.dll&lt;/code&gt; from VBA is:</source>
          <target state="translated">从VBA 使用 &lt;code&gt;Adder.dll&lt;/code&gt; 的示例是：</target>
        </trans-unit>
        <trans-unit id="0a2f6a683146590a81cb59662a6f31a14e0007fe" translate="yes" xml:space="preserve">
          <source>An example of using &lt;code&gt;lookup&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;lookup&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="62a7372438651bafa2669d1145fa021654f7a3ee" translate="yes" xml:space="preserve">
          <source>An example use of this library for a simple read-eval-print loop (REPL) is the following:</source>
          <target state="translated">下面是一个简单的读-评价-打印循环(REPL)的例子。</target>
        </trans-unit>
        <trans-unit id="57f1733124f33be242778620a4eb6cdc6409382d" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad中使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="381e8e3e19da9b996ca14e0adbfa4195c12da0b2" translate="yes" xml:space="preserve">
          <source>An exception thrown to a thread by &lt;code&gt;&lt;a href=&quot;system-timeout#v:timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; to interrupt a timed-out computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a213b0b1515044c4c78bd78637c0113c5cd8be80" translate="yes" xml:space="preserve">
          <source>An exception to be thrown.</source>
          <target state="translated">要抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="fdf570a64c3420a5e9dc66825959db440f96c3c1" translate="yes" xml:space="preserve">
          <source>An exception type for representing Unicode encoding errors.</source>
          <target state="translated">用于表示Unicode编码错误的异常类型。</target>
        </trans-unit>
        <trans-unit id="efb9885da89ae0153ca6bd437d81d85bcf6d2a5e" translate="yes" xml:space="preserve">
          <source>An exception-safe wrapper for modifying the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; will replace the original contents of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; if an exception is raised during the operation. This function is only atomic if there are no other producers for this &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于修改 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 内容的异常安全包装器。像 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 将取代原来的内容 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; ，如果有异常操作过程中提出的。仅当该 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 没有其他生产者时，此函数才是原子的。</target>
        </trans-unit>
        <trans-unit id="f7bad0722f6e1639c9b8bf58917fbc9a749282ca" translate="yes" xml:space="preserve">
          <source>An experimental flag to expose all unfoldings, even for very large or recursive functions. This allows for all functions to be inlined while usually GHC would avoid inlining larger functions.</source>
          <target state="translated">一个实验性的标志,用于暴露所有的展开,即使是非常大的或递归的函数。这使得所有函数都可以内联,而通常GHC会避免内联较大的函数。</target>
        </trans-unit>
        <trans-unit id="fcc169bba3c04120ce581359b5205c6e6861fa64" translate="yes" xml:space="preserve">
          <source>An expression</source>
          <target state="translated">一种表达方式</target>
        </trans-unit>
        <trans-unit id="5b3e9db1ce65c03995d328bea346bec14a73a082" translate="yes" xml:space="preserve">
          <source>An expression that didn't typecheck during compile time was called. This is only possible with -fdefer-type-errors. The &lt;code&gt;String&lt;/code&gt; gives details about the failed type check.</source>
          <target state="translated">调用了在编译时未进行类型检查的表达式。仅在出现-fdefer-type-errors时才有可能。该 &lt;code&gt;String&lt;/code&gt; 提供有关失败的类型检查的详细信息。</target>
        </trans-unit>
        <trans-unit id="23d6c8ea4520ef478bc2079b23a73769921d85ca" translate="yes" xml:space="preserve">
          <source>An expression type signature (&lt;a href=&quot;#exp-type-sigs&quot;&gt;Expression type signatures&lt;/a&gt;)</source>
          <target state="translated">表达式类型签名（&lt;a href=&quot;#exp-type-sigs&quot;&gt;Expression type signatures&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="befd82a9275f38fcab59cee9b3a9893ec9498cda" translate="yes" xml:space="preserve">
          <source>An expression type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the annotated expression. For example:</source>
          <target state="translated">具有&lt;em&gt;显式&lt;/em&gt;量化（使用 &lt;code&gt;forall&lt;/code&gt; ）的表达式类型签名将带注释的表达式中显式量化的类型变量纳入范围。例如：</target>
        </trans-unit>
        <trans-unit id="b82cc29cb694eff0d6c543cfd3b0fa40875fc57b" translate="yes" xml:space="preserve">
          <source>An extended Haskell interface file, produced by the Haskell compiler.</source>
          <target state="translated">一个扩展的Haskell接口文件,由Haskell编译器产生。</target>
        </trans-unit>
        <trans-unit id="06078bbc223f3f2c54001e817424da6925e7e456" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the C compiler.</source>
          <target state="translated">一个额外的标志,传递给C编译器。</target>
        </trans-unit>
        <trans-unit id="4ada7ba8223269b5dc2b7e6f71e6be14db026a01" translate="yes" xml:space="preserve">
          <source>An extra flag to pass to the linker.</source>
          <target state="translated">一个额外的标志传递给链接器。</target>
        </trans-unit>
        <trans-unit id="ff063cb1c991404edd003923980f0718291bfcf8" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard can also lead to zero extra constraints to be inferred, e.g.</source>
          <target state="translated">额外约束的通配符也可以导致零额外约束的推断,例如。</target>
        </trans-unit>
        <trans-unit id="8737dcbc364a0104937da45530e573d364b0ae37" translate="yes" xml:space="preserve">
          <source>An extra-constraints wildcard shouldn&amp;rsquo;t prevent the programmer from already listing the constraints he knows or wants to annotate, e.g.</source>
          <target state="translated">额外约束通配符不应阻止程序员已经列出他知道或要注释的约束，例如</target>
        </trans-unit>
        <trans-unit id="d29ed66c17bed0542d86b370f6bc6043d2a378e4" translate="yes" xml:space="preserve">
          <source>An extremely light-weight, fast, and limited representation of a string of up to (2*WORDSIZE - 2) bits. In fact, there are two representations, misleadingly named bit queue builder and bit queue. The builder supports only &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt;, creating an empty builder, and &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt;, enqueueing a bit. The bit queue builder is then turned into a bit queue using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt;, after which bits can be removed one by one using &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt;. If the size limit is exceeded, further operations will silently produce nonsense.</source>
          <target state="translated">最多（2 * WORDSIZE-2）位的字符串的极轻量，快速且有限的表示形式。实际上，存在两种表示形式，误导性地命名为位队列生成器和位队列。该构建器仅支持 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:emptyQB&quot;&gt;emptyQB&lt;/a&gt;&lt;/code&gt; （创建一个空的构建器）和 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:snocQB&quot;&gt;snocQB&lt;/a&gt;&lt;/code&gt; （排队）。然后将位队列助洗剂变成使用比特队列 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:buildQ&quot;&gt;buildQ&lt;/a&gt;&lt;/code&gt; ，之后的比特可以通过使用一个去除一个 &lt;code&gt;&lt;a href=&quot;utils-containers-internal-bitqueue#v:unconsQ&quot;&gt;unconsQ&lt;/a&gt;&lt;/code&gt; 。如果超过大小限制，则进一步的操作将无提示地产生废话。</target>
        </trans-unit>
        <trans-unit id="4a1b2653a1c9d958510f1ed844f74e8ecb8d1c49" translate="yes" xml:space="preserve">
          <source>An idiom that is common in some languages is to find the numeric offset of a character or substring, then use that number to split or trim the searched string. With a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value, this approach would require two O(n) operations: one to perform the search, and one to operate from wherever the search ended.</source>
          <target state="translated">在某些语言中常见的习惯用法是查找字符或子字符串的数字偏移量，然后使用该数字来分割或修整搜索到的字符串。对于 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值，此方法将需要两项O（n）操作：一项用于执行搜索，而另一项则在搜索结束的任何地方进行操作。</target>
        </trans-unit>
        <trans-unit id="67c017344c03d68395eeb6821615e8a8bfe1033a" translate="yes" xml:space="preserve">
          <source>An idle-time garbage collection has been started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d426bd25abbccce84e0bdf47cb062c833bbb269" translate="yes" xml:space="preserve">
          <source>An illustrative example for these strictness properties is the implementation of Base64 decoding (&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt;).</source>
          <target state="translated">这些严格性属性的说明性示例是Base64解码的实现（&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;http://en.wikipedia.org/wiki/Base64&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d20888eadb4852094fcef2f3603d26df3e4539de" translate="yes" xml:space="preserve">
          <source>An implementation is entitled to assume the following laws about these operations:</source>
          <target state="translated">一个实施者有权对这些操作采取以下规律:</target>
        </trans-unit>
        <trans-unit id="5dd9779568fb3b84f00870e9c9dc5e99b34e41c6" translate="yes" xml:space="preserve">
          <source>An implementation is free to flush the buffer more frequently, but not less frequently, than specified above. The output buffer is emptied as soon as it has been written out.</source>
          <target state="translated">实现可以自由地冲洗缓冲区,但频率不能低于上述规定。输出缓冲区一旦写完就会被清空。</target>
        </trans-unit>
        <trans-unit id="764ec8855ef58c6a8f42aecb228f30ad41274dec" translate="yes" xml:space="preserve">
          <source>An implementation of the old &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop in terms of the new &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop, for backwards compatibility. The type of this function is a bit bogus. It's best to think of it as having type</source>
          <target state="translated">用新的 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:atomicModifyMutVar2-35-&quot;&gt;atomicModifyMutVar2#&lt;/a&gt;&lt;/code&gt; primop来实现旧的 &lt;code&gt;atomicModifyMutVar#&lt;/code&gt; primop 的实现，以实现向后兼容。此函数的类型有点虚假。最好将其视为具有类型</target>
        </trans-unit>
        <trans-unit id="055bfb77bc4911c1d902e9c7e877458502ecd8a2" translate="yes" xml:space="preserve">
          <source>An implicit parameter is &lt;em&gt;bound&lt;/em&gt; using the standard &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; binding forms. For example, we define the &lt;code&gt;min&lt;/code&gt; function by binding &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">隐式参数&lt;em&gt;结合&lt;/em&gt;使用标准 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 结合形式。例如，我们通过绑定 &lt;code&gt;cmp&lt;/code&gt; 定义 &lt;code&gt;min&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="83f900390293c670e8a8d65bb9afeb5cc8fcf2b6" translate="yes" xml:space="preserve">
          <source>An implicit parameter occurs in an expression using the special form &lt;code&gt;?x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any valid identifier (e.g. &lt;code&gt;ord ?x&lt;/code&gt; is a valid expression). Use of this construct also introduces a new dynamic-binding constraint in the type of the expression. For example, the following definition shows how we can define an implicitly parameterised sort function in terms of an explicitly parameterised &lt;code&gt;sortBy&lt;/code&gt; function:</source>
          <target state="translated">隐式参数出现在使用特殊形式 &lt;code&gt;?x&lt;/code&gt; 的表达式中，其中 &lt;code&gt;x&lt;/code&gt; 是任何有效的标识符（例如 &lt;code&gt;ord ?x&lt;/code&gt; 是有效的表达式）。使用此构造还会在表达式的类型中引入新的动态绑定约束。例如，以下定义显示了如何根据显式参数化的 &lt;code&gt;sortBy&lt;/code&gt; 函数定义隐式参数化的排序函数：</target>
        </trans-unit>
        <trans-unit id="2e728fe00beb5b98842848d858c512e28ed428db" translate="yes" xml:space="preserve">
          <source>An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive.</source>
          <target state="translated">隐式参数绑定组必须是对隐式变量的简单绑定的集合(没有函数式绑定,也没有类型签名);这些绑定既不是多态的,也不是递归的。</target>
        </trans-unit>
        <trans-unit id="055d0a98d0fca1648c6546c9fc6ca5cb2c9b9157" translate="yes" xml:space="preserve">
          <source>An implicit-parameter type constraint differs from other type class constraints in the following way: All uses of a particular implicit parameter must have the same type. This means that the type of &lt;code&gt;(?x, ?x)&lt;/code&gt; is &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt;, and not &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt;, as would be the case for type class constraints.</source>
          <target state="translated">隐式参数类型约束与其他类型类约束在以下方面有所不同：特定隐式参数的所有使用都必须具有相同的类型。这意味着 &lt;code&gt;(?x, ?x)&lt;/code&gt; 是 &lt;code&gt;(?x::a) =&amp;gt; (a,a)&lt;/code&gt; ，而不是 &lt;code&gt;(?x::a, ?x::b) =&amp;gt; (a, b)&lt;/code&gt; ，就像类型类约束一样。</target>
        </trans-unit>
        <trans-unit id="41e571a04d49adc778f99f9915a653a4d8383f97" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的中缀同义词。</target>
        </trans-unit>
        <trans-unit id="676b0466c764d24182ade55c20826949e1613615" translate="yes" xml:space="preserve">
          <source>An infix synonym for &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的中缀同义词。</target>
        </trans-unit>
        <trans-unit id="45e7ca78829cc48699173c5bd84e19553844a4fb" translate="yes" xml:space="preserve">
          <source>An initial environment.</source>
          <target state="translated">一个初始环境。</target>
        </trans-unit>
        <trans-unit id="032f25891e62fb8921b2ffd173fccd585c489d81" translate="yes" xml:space="preserve">
          <source>An installed package is either &lt;em&gt;exposed&lt;/em&gt; or &lt;em&gt;hidden&lt;/em&gt; by default. Packages hidden by default are listed in parentheses (e.g. &lt;code&gt;(lang-1.0)&lt;/code&gt;), or possibly in blue if your terminal supports colour, in the output of &lt;code&gt;ghc-pkg list&lt;/code&gt;. Command-line flags, described below, allow you to expose a hidden package or hide an exposed one. Only modules from exposed packages may be imported by your Haskell code; if you try to import a module from a hidden package, GHC will emit an error message. It should be noted that a hidden package might still get linked with your program as a dependency of an exposed package, it is only restricted from direct imports.</source>
          <target state="translated">默认情况下，已安装的软件包是&lt;em&gt;公开的&lt;/em&gt;或&lt;em&gt;隐藏&lt;/em&gt;的。默认情况下隐藏的软件包在 &lt;code&gt;ghc-pkg list&lt;/code&gt; 的输出中以括号（例如 &lt;code&gt;(lang-1.0)&lt;/code&gt; ）列出，或者如果终端支持颜色，则可能以蓝色列出。如下所述，命令行标志允许您公开隐藏的程序包或隐藏公开的程序包。您的Haskell代码只能导入裸露包中的模块；如果您尝试从隐藏的软件包中导入模块，GHC将发出错误消息。应该注意的是，隐藏包仍可能作为暴露包的依赖项与您的程序链接，它仅受直接导入的限制。</target>
        </trans-unit>
        <trans-unit id="6e9e64155c356c6955cab41597813ffebcaa65a5" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">一个实例可以定义用户可以在本和 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 或统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; ，这取决于它是有问题的类型更方便。</target>
        </trans-unit>
        <trans-unit id="d84b0a9b1da15cdbb5efba9440685e88ebcccf36" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">一个实例可以定义用户可以在本和 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; 或统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; ，这取决于它是有问题的类型更方便。</target>
        </trans-unit>
        <trans-unit id="771255935064afcdb9c5d67ea14ceedd0c402b64" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">实例可以定义this和 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 或统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ，这取决于所讨论的类型更方便。</target>
        </trans-unit>
        <trans-unit id="c91e8ae7413d71da86962a384a3de3aff328dd8d" translate="yes" xml:space="preserve">
          <source>An instance can define either this and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; or the unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">实例可以定义this和 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; 或统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ，这取决于所讨论的类型更方便。</target>
        </trans-unit>
        <trans-unit id="9505be87e1ced40bfc25bab37f391a9491bdd4ef" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">实例可以定义此统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateL&quot;&gt;rotateL&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotateR&quot;&gt;rotateR&lt;/a&gt;&lt;/code&gt; ，这取决于所讨论的类型更方便。</target>
        </trans-unit>
        <trans-unit id="1f6f1ff04bfa289ae107fe2cb73d2dc665d5edae" translate="yes" xml:space="preserve">
          <source>An instance can define either this unified &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt;, depending on which is more convenient for the type in question.</source>
          <target state="translated">实例可以定义此统一的 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#v:shiftR&quot;&gt;shiftR&lt;/a&gt;&lt;/code&gt; ，这取决于所讨论的类型更方便。</target>
        </trans-unit>
        <trans-unit id="b91c1218cc10bd9b2d241b41fc654dedb75905ac" translate="yes" xml:space="preserve">
          <source>An instance declaration has the form</source>
          <target state="translated">一个实例声明的形式是</target>
        </trans-unit>
        <trans-unit id="0422a1c1ceadfc36e077b4145e342be0d4fe9752" translate="yes" xml:space="preserve">
          <source>An instance declaration in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan instance&lt;/em&gt; if orphan instance</source>
          <target state="translated">在模块的实例声明 &lt;code&gt;M&lt;/code&gt; 是一个&lt;em&gt;孤儿例如&lt;/em&gt;，如果孤儿实例</target>
        </trans-unit>
        <trans-unit id="f659879efb627bdd5cecbbab282a1e9e47a6cd51" translate="yes" xml:space="preserve">
          <source>An instance declaration is &lt;em&gt;more specific&lt;/em&gt; than another iff the head of former is a substitution instance of the latter. For example (D) is &amp;ldquo;more specific&amp;rdquo; than (C) because you can get from (C) to (D) by substituting &lt;code&gt;a := Int&lt;/code&gt;.</source>
          <target state="translated">如果前者的头是后者的替代实例，则实例声明比另一个声明&lt;em&gt;更具体&lt;/em&gt;。例如（D）比（C）更&amp;ldquo;具体&amp;rdquo;，因为您可以通过替换 &lt;code&gt;a := Int&lt;/code&gt; 从（C）到（D）。</target>
        </trans-unit>
        <trans-unit id="a925b49f0219e891d285365b66dce29fa02d0e7e" translate="yes" xml:space="preserve">
          <source>An instance for an associated family can only appear as part of an instance declarations of the class in which the family was declared, just as with the equations of the methods of a class.</source>
          <target state="translated">关联族的实例只能作为声明该族的类的实例声明的一部分出现,就像类的方法公式一样。</target>
        </trans-unit>
        <trans-unit id="6797a394b5a38cb77951470781b2ae0ce53d676c" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;incoherent&lt;/em&gt; if: it has an &lt;code&gt;INCOHERENT&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个实例是&lt;em&gt;不连贯的&lt;/em&gt;，如果：它有一个 &lt;code&gt;INCOHERENT&lt;/code&gt; 编译; 或实例没有编译指示，并且出现在使用&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;编译的模块中。</target>
        </trans-unit>
        <trans-unit id="0b66884ab42d5d8b014e6fc23b4324da15721d24" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlappable&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPABLE&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">一个实例是&lt;em&gt;重叠的&lt;/em&gt;，如果：它有一个 &lt;code&gt;OVERLAPPABLE&lt;/code&gt; 或 &lt;code&gt;OVERLAPS&lt;/code&gt; 编译; 或者，如果实例没有编译指示，并且出现在使用&lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt;编译的模块中；或者 或实例不一致。</target>
        </trans-unit>
        <trans-unit id="c64945d958795bcda270b74e76ecf8e08588cfbe" translate="yes" xml:space="preserve">
          <source>An instance is &lt;em&gt;overlapping&lt;/em&gt; if: it has an &lt;code&gt;OVERLAPPING&lt;/code&gt; or &lt;code&gt;OVERLAPS&lt;/code&gt; pragma; or if the instance has no pragma and it appears in a module compiled with &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt;; or if the instance is incoherent.</source>
          <target state="translated">一个实例是&lt;em&gt;重叠的&lt;/em&gt;，如果：它有一个 &lt;code&gt;OVERLAPPING&lt;/code&gt; 或 &lt;code&gt;OVERLAPS&lt;/code&gt; 编译; 或者，如果实例没有编译指示，并且出现在使用&lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt;编译的模块中；或者 或实例不一致。</target>
        </trans-unit>
        <trans-unit id="da552798a9dccf85004f0b6505ae33c512663e04" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; is provided, which implements exact equality modulo reordering of the tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field.</source>
          <target state="translated">提供了一个 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例，该实例对 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 字段中的标签实施精确的等式模重新排序。</target>
        </trans-unit>
        <trans-unit id="41664f4a7f5f1d180ac492e6274bf660ab0d02d1" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is also provided, which gives lexicographic ordering on the &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; fields (i.e. 2.1 &amp;gt; 2.0, 1.2.3 &amp;gt; 1.2.2, etc.). This is expected to be sufficient for many uses, but note that you may need to use a more specific ordering for your versioning scheme. For example, some versioning schemes may include pre-releases which have tags &lt;code&gt;&quot;pre1&quot;&lt;/code&gt;, &lt;code&gt;&quot;pre2&quot;&lt;/code&gt;, and so on, and these would need to be taken into account when determining ordering. In some cases, date ordering may be more appropriate, so the application would have to look for &lt;code&gt;date&lt;/code&gt; tags in the &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; field and compare those. The bottom line is, don't always assume that &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; and other &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; operations are the right thing for every &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">还提供了一个 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例，该实例在 &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; 字段上按字典顺序排序（即2.1&amp;gt; 2.0、1.2.3 &amp;gt; 1.2.2等）。预期这足以满足许多用途，但是请注意，对于版本控制方案，可能需要使用更具体的顺序。例如，一些版本方案可能包括之前版本具有标签 &lt;code&gt;&quot;pre1&quot;&lt;/code&gt; ， &lt;code&gt;&quot;pre2&quot;&lt;/code&gt; ，等等，这些都需要确定订货时要考虑的。在某些情况下，日期排序可能更合适，因此应用程序必须在 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; 字段中查找 &lt;code&gt;date&lt;/code&gt; 标签并进行比较。底线是，不要总是假设 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 和其他 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 操作对于每个 &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 都是正确的。</target>
        </trans-unit>
        <trans-unit id="fdfa656ab79a71bc26c499aa546810046ca396ff" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; is generally made up of monad transformers layered on top of the IO monad.</source>
          <target state="translated">通常， &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:MonadException&quot;&gt;MonadException&lt;/a&gt;&lt;/code&gt; 的一个实例由位于IO monad之上的monad转换器组成。</target>
        </trans-unit>
        <trans-unit id="8ef31ea41a9ba018762805e0743531d210cd6284" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Stream&lt;/code&gt; has stream type &lt;code&gt;s&lt;/code&gt;, underlying monad &lt;code&gt;m&lt;/code&gt; and token type &lt;code&gt;t&lt;/code&gt; determined by the stream</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 的实例具有流类型 &lt;code&gt;s&lt;/code&gt; ，基础monad &lt;code&gt;m&lt;/code&gt; 和由流确定的令牌类型 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182b96f131379637cff152270abf17ec6ecf1c40" translate="yes" xml:space="preserve">
          <source>An integer denoting the number &lt;code&gt;l&lt;/code&gt; of printed completions,</source>
          <target state="translated">一个整数，表示打印完成的数量 &lt;code&gt;l&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="5705ba72313d6782ee3dec31edcfe71a4e6bfe65" translate="yes" xml:space="preserve">
          <source>An integer literal &lt;code&gt;368&lt;/code&gt; means &amp;ldquo;&lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">整数文字 &lt;code&gt;368&lt;/code&gt; 的意思是&amp;ldquo; &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; &amp;rdquo;，而不是&amp;ldquo; &lt;code&gt;Prelude.fromInteger (368::Integer)&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7fcfdbe8f2cac93c2ec79190607c573c3d60d86c" translate="yes" xml:space="preserve">
          <source>An intermediate result in a scan.</source>
          <target state="translated">扫描中的一个中间结果。</target>
        </trans-unit>
        <trans-unit id="4fdb6e08d830a1c3979bfdc3fd7343eb5abdfb8f" translate="yes" xml:space="preserve">
          <source>An invocation of GHC takes the following form:</source>
          <target state="translated">调用GHC的形式如下:</target>
        </trans-unit>
        <trans-unit id="edb1f7c1dc03b67ee6b809077f9e5604578eb554" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language bitcode file, usually produced by the compiler.</source>
          <target state="translated">一个llvm-中间语言位码文件,通常由编译器产生。</target>
        </trans-unit>
        <trans-unit id="11d0526a9a9e3e29d8774eda5075a8938912393d" translate="yes" xml:space="preserve">
          <source>An llvm-intermediate-language source file, usually produced by the compiler.</source>
          <target state="translated">一个llvm-中间语言的源文件,通常由编译器产生。</target>
        </trans-unit>
        <trans-unit id="2e0a23e4bb2863d568c7f363da30cd3b735cae06" translate="yes" xml:space="preserve">
          <source>An object &lt;code&gt;B&lt;/code&gt; retains object &lt;code&gt;A&lt;/code&gt; if (i) &lt;code&gt;B&lt;/code&gt; is a retainer object and (ii) object &lt;code&gt;A&lt;/code&gt; can be reached by recursively following pointers starting from object &lt;code&gt;B&lt;/code&gt;, but not meeting any other retainer objects on the way. Each live object is retained by one or more retainer objects, collectively called its retainer set, or its retainer set, or its retainers.</source>
          <target state="translated">对象 &lt;code&gt;B&lt;/code&gt; 保留对象 &lt;code&gt;A&lt;/code&gt; 如果（i） &lt;code&gt;B&lt;/code&gt; 是保持器对象和（ii）对象 &lt;code&gt;A&lt;/code&gt; 可以通过从对象开始递归以下指针来达到 &lt;code&gt;B&lt;/code&gt; ，但在途中不符合任何其他保持器对象。每个活动对象都由一个或多个保留对象保留，这些对象统称为其保留集或保留集或保留集。</target>
        </trans-unit>
        <trans-unit id="42910c59b4eb5fc3b9c19c32b311eab9e4bf6a36" translate="yes" xml:space="preserve">
          <source>An object file, produced by an assembler.</source>
          <target state="translated">一个对象文件,由汇编器产生。</target>
        </trans-unit>
        <trans-unit id="18c88b3ac1bd46ecfef3ff8276bc55927b9a64fe" translate="yes" xml:space="preserve">
          <source>An object which is never used is said to be in the void state for its whole lifetime.</source>
          <target state="translated">一个从未被使用过的对象被称为在其整个生命周期内都处于无效状态。</target>
        </trans-unit>
        <trans-unit id="5199083ec8a4ed3cb5139c93d4aeb1ab1a44d8f3" translate="yes" xml:space="preserve">
          <source>An offset, counted in bytes.</source>
          <target state="translated">一个偏移量,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="4e93ce4db75561be705e22c1086fdc986365d26d" translate="yes" xml:space="preserve">
          <source>An operator version of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 的运算符版本。</target>
        </trans-unit>
        <trans-unit id="269ede13d98d287f0dd18a20f718823a44965f42" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;E&lt;/code&gt; character indicates an alternate formatting. Currently this only affects &lt;code&gt;%Z&lt;/code&gt; and &lt;code&gt;%z&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;E&lt;/code&gt; 字符表示备用格式。当前，这仅影响 &lt;code&gt;%Z&lt;/code&gt; 和 &lt;code&gt;%z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="147554bd72cb36203ba4e437f86b5856939ecef7" translate="yes" xml:space="preserve">
          <source>An optional escape character</source>
          <target state="translated">一个可选的转义字符</target>
        </trans-unit>
        <trans-unit id="470bd4645aa2a37d61b6006cf88e182f77dda35b" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;.</source>
          <target state="translated">可变数组的重载接口。有关可用于此接口的数组类型，请参见&lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;，&lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;和&lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed76ddf939d258125a9d07e26bf81d6563190100" translate="yes" xml:space="preserve">
          <source>An overloaded interface to mutable arrays. For array types which can be used with this interface, see &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;, &lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;, and &lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;. . Safe API only of &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;.</source>
          <target state="translated">可变数组的接口重载。有关可用于此接口的数组类型，请参见&lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;，&lt;a href=&quot;data-array-st&quot;&gt;Data.Array.ST&lt;/a&gt;和&lt;a href=&quot;data-array-storable&quot;&gt;Data.Array.Storable&lt;/a&gt;。。仅&lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray的&lt;/a&gt;安全API 。</target>
        </trans-unit>
        <trans-unit id="b46b21c3d0ad448b7dbfafad15287d739812f46d" translate="yes" xml:space="preserve">
          <source>An overloaded label &amp;ldquo;&lt;code&gt;#foo&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo;, rather than &amp;ldquo;&lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt;&amp;rdquo; (see &lt;a href=&quot;#overloaded-labels&quot;&gt;Overloaded labels&lt;/a&gt;).</source>
          <target state="translated">重载的标签&amp;ldquo; &lt;code&gt;#foo&lt;/code&gt; &amp;rdquo;的意思是&amp;ldquo; &lt;code&gt;fromLabel @&quot;foo&quot;&lt;/code&gt; &amp;rdquo;，而不是&amp;ldquo; &lt;code&gt;GHC.OverloadedLabels.fromLabel @&quot;foo&quot;&lt;/code&gt; &amp;rdquo;（请参见&lt;a href=&quot;#overloaded-labels&quot;&gt;重载的标签&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9468ea5c26fba1b901ed7aacb46a3a82ed93f64b" translate="yes" xml:space="preserve">
          <source>An un-associated open type or data family declaration &lt;em&gt;always&lt;/em&gt; has a CUSK; un-annotated type variables default to kind &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">未关联的开放类型或数据族声明&lt;em&gt;始终&lt;/em&gt;具有CUSK；未注释的类型变量默认为kind &lt;code&gt;Type&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="130b0c42eca7246bf15b8c958b406f7273873440" translate="yes" xml:space="preserve">
          <source>An unbounded size unsigned integer type is available with &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 提供了无限制大小的无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="860459917b5a02de589e908d125eff6b77571ea2" translate="yes" xml:space="preserve">
          <source>An unboxed sum of the given reps</source>
          <target state="translated">给定代表的开箱总和</target>
        </trans-unit>
        <trans-unit id="7a6c34e18a2ffbd1385e4ed434dc780b5897e179" translate="yes" xml:space="preserve">
          <source>An unboxed tuple of the given reps</source>
          <target state="translated">一个给定代表的开箱元组。</target>
        </trans-unit>
        <trans-unit id="58d8e58dbcaf88f766575185e1685146830b08ca" translate="yes" xml:space="preserve">
          <source>An unevaluated spark has been garbage collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc5e3262cb4421f0eecc8b241d84ce50b4e2631" translate="yes" xml:space="preserve">
          <source>An uninitialised record field was used. The &lt;code&gt;String&lt;/code&gt; gives information about the source location where the record was constructed.</source>
          <target state="translated">使用了未初始化的记录字段。该 &lt;code&gt;String&lt;/code&gt; 提供有关该纪录被修建的源位置信息。</target>
        </trans-unit>
        <trans-unit id="35d4a9def65ccb498f533dbeaee2b2071da0bbc7" translate="yes" xml:space="preserve">
          <source>An unqualified name; dynamically bound</source>
          <target state="translated">非限定名称;动态绑定。</target>
        </trans-unit>
        <trans-unit id="dd607d2def70825ae686680e0742f5955f4c5559" translate="yes" xml:space="preserve">
          <source>An unsigned integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;uintptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">可以无损地与 &lt;code&gt;Ptr&lt;/code&gt; 进行无损转换的无符号整数类型。该类型也与C99类型 &lt;code&gt;uintptr_t&lt;/code&gt; 兼容，并且可以安全地与该类型进出编组。</target>
        </trans-unit>
        <trans-unit id="14042e31bb5752011e77595736a7c337f4b6cf90" translate="yes" xml:space="preserve">
          <source>And a response file &lt;code&gt;args.txt&lt;/code&gt;:</source>
          <target state="translated">和一个响应文件 &lt;code&gt;args.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cbd0ba0de747b34708a0f30527430f5a5c552189" translate="yes" xml:space="preserve">
          <source>And five warning flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523755b21b99024bbe43a1c9df96976e561c8e78" translate="yes" xml:space="preserve">
          <source>And inside &lt;code&gt;scheduleCallback&lt;/code&gt;, we create a callback that will in due course store the result data in the &lt;code&gt;Ptr Result&lt;/code&gt;, and then call &lt;code&gt;hs_try_putmvar()&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;scheduleCallback&lt;/code&gt; 内部，我们创建一个回调，该回调将在适当的时候将结果数据存储在 &lt;code&gt;Ptr Result&lt;/code&gt; 中，然后调用 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c289bb0b2889358d5359dfed88823350fe8916e4" translate="yes" xml:space="preserve">
          <source>And multi-line spans are possible too:</source>
          <target state="translated">而且多线跨度也是可以的。</target>
        </trans-unit>
        <trans-unit id="5e61586d1382fe8ad684bf10b7ab8931fb17aed0" translate="yes" xml:space="preserve">
          <source>And one general flag:</source>
          <target state="translated">还有一面将军旗。</target>
        </trans-unit>
        <trans-unit id="dea1f9e397867b9cb1063d86c4c517eae2eedcd1" translate="yes" xml:space="preserve">
          <source>And read back with:</source>
          <target state="translated">并回读与。</target>
        </trans-unit>
        <trans-unit id="fc6d8473bdc84d9a5a02e5f55e8ffba9c7a1eadb" translate="yes" xml:space="preserve">
          <source>And the program will loop at runtime. Similarly, an &lt;code&gt;Applicative&lt;/code&gt; instance like this</source>
          <target state="translated">程序将在运行时循环。同样，像这样的 &lt;code&gt;Applicative&lt;/code&gt; 实例</target>
        </trans-unit>
        <trans-unit id="91b7607b548e3de2b58aab9b4afde889d7ecf3e4" translate="yes" xml:space="preserve">
          <source>And three warning flags:</source>
          <target state="translated">还有三面警示旗。</target>
        </trans-unit>
        <trans-unit id="0194dd87cfa77e0f7f90bc726fd0703ab0c251ba" translate="yes" xml:space="preserve">
          <source>And we could have built an equivalent path with the following expressions:</source>
          <target state="translated">而我们可以用下面的表达方式建立一个等价的路径。</target>
        </trans-unit>
        <trans-unit id="f04f47a0bf05c20c03ec6759fd8321b4e440f4b6" translate="yes" xml:space="preserve">
          <source>And with &lt;a href=&quot;#unboxed-sums&quot;&gt;UnboxedSums&lt;/a&gt; enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1853f8dddb99a8c160df02448f14aeb5c7e0b7" translate="yes" xml:space="preserve">
          <source>And write a value to disk</source>
          <target state="translated">并向磁盘写入一个值</target>
        </trans-unit>
        <trans-unit id="0b691ef27c0c127676c790709cff2ef33778d7eb" translate="yes" xml:space="preserve">
          <source>And you attempt to derive it using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">然后您尝试使用&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;派生它：</target>
        </trans-unit>
        <trans-unit id="495577bd97a225b48a7e5b45336021b982d75dbc" translate="yes" xml:space="preserve">
          <source>And you tried to derive an instance for it:</source>
          <target state="translated">而你试图为它推导出一个实例。</target>
        </trans-unit>
        <trans-unit id="b8ad3365893a0b275281ec83a50665e9f2d6834f" translate="yes" xml:space="preserve">
          <source>And, among other things, lazy pattern-matching is your enemy.</source>
          <target state="translated">而其中,懒惰的模式匹配是你的敌人。</target>
        </trans-unit>
        <trans-unit id="8c4a82e242cf12aed8b85b58f58b0968fee82178" translate="yes" xml:space="preserve">
          <source>Andy Gill and Simon Marlow have written a parser-generator for Haskell, called &lt;code&gt;happy&lt;/code&gt;. &lt;code&gt;Happy&lt;/code&gt; is to Haskell what &lt;code&gt;Yacc&lt;/code&gt; is to C.</source>
          <target state="translated">安迪&amp;middot;吉尔（Andy Gill）和西蒙&amp;middot;马洛（Simon Marlow）为Haskell写了一个解析器生成器，称为 &lt;code&gt;happy&lt;/code&gt; 。对Haskell 感到 &lt;code&gt;Happy&lt;/code&gt; ，对C而言 &lt;code&gt;Yacc&lt;/code&gt; 感到高兴。</target>
        </trans-unit>
        <trans-unit id="74661a73b0dde5f32e46ef5440b8f7c212e3dd3f" translate="yes" xml:space="preserve">
          <source>AnnLookup</source>
          <target state="translated">AnnLookup</target>
        </trans-unit>
        <trans-unit id="c1da64c83c4be735ccac640316d60131dd4381db" translate="yes" xml:space="preserve">
          <source>AnnTarget</source>
          <target state="translated">AnnTarget</target>
        </trans-unit>
        <trans-unit id="f1b790e1da14310f6ece84c62bb58322fef3c9fc" translate="yes" xml:space="preserve">
          <source>AnnotDetails</source>
          <target state="translated">AnnotDetails</target>
        </trans-unit>
        <trans-unit id="bf34615f46f75f35e2f9ccc197db2f929dd6a301" translate="yes" xml:space="preserve">
          <source>AnnotStart</source>
          <target state="translated">AnnotStart</target>
        </trans-unit>
        <trans-unit id="1e19b78b16e2a7b6a1e4f80c0a4d231548b5500d" translate="yes" xml:space="preserve">
          <source>Annotate the Template Haskell expression with a type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665edccbf78492c3059856c8597043ed30b15ce4" translate="yes" xml:space="preserve">
          <source>Annotating documents</source>
          <target state="translated">文件的注释</target>
        </trans-unit>
        <trans-unit id="0d453d564eadde058c35ace639f7bec19eccb3ee" translate="yes" xml:space="preserve">
          <source>Annotation lookup</source>
          <target state="translated">注释查询</target>
        </trans-unit>
        <trans-unit id="11129140d62298b72f4c953d972b05a50da295ea" translate="yes" xml:space="preserve">
          <source>Annotation rendering</source>
          <target state="translated">注释渲染</target>
        </trans-unit>
        <trans-unit id="112cca03c76acb3cca2a892f6e3fa24c275d9756" translate="yes" xml:space="preserve">
          <source>Annotation target for reifyAnnotations</source>
          <target state="translated">reifyAnnotations的注释目标。</target>
        </trans-unit>
        <trans-unit id="fddbd22c104843c74d2c00f8cf2af89a7f68516f" translate="yes" xml:space="preserve">
          <source>Annotations are small pragmas that allow you to attach data to identifiers in source code, which are persisted when compiled. These pieces of data can then inspected and utilized when using GHC as a library or writing a compiler plugin.</source>
          <target state="translated">注释是一种小型的实用工具,它允许你将数据附加到源代码中的标识符上,这些标识符在编译时将被持久化。这些数据可以在使用GHC作为一个库或编写编译器插件时进行检查和利用。</target>
        </trans-unit>
        <trans-unit id="e5b762d7dbaed9bb5ebd61e64b87ad52b2d8a6ca" translate="yes" xml:space="preserve">
          <source>Anonymous and named wildcards &lt;em&gt;can&lt;/em&gt; occur on the left hand side of a type or data instance declaration; see &lt;a href=&quot;#type-wildcards-lhs&quot;&gt;Wildcards on the LHS of data and type family instances&lt;/a&gt;.</source>
          <target state="translated">匿名通配符和命名通配符&lt;em&gt;可以&lt;/em&gt;出现在类型或数据实例声明的左侧。请参阅&lt;a href=&quot;#type-wildcards-lhs&quot;&gt;数据和类型族实例的LHS上的通配符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cf2947ec117ab6af4c3e63853ae6bc974a4aab5" translate="yes" xml:space="preserve">
          <source>Anonymous wildcards are also allowed in visible type applications/ visible kind applications (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt; where the first argument is a wildcard.</source>
          <target state="translated">在可见类型应用程序/可见类型应用程序（&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型应用程序&lt;/a&gt;）中也允许使用匿名通配符。如果只想为 &lt;code&gt;wurble&lt;/code&gt; 指定第二个类型参数，则可以说 &lt;code&gt;wurble @_ @Int&lt;/code&gt; ，其中第一个参数是通配符。</target>
        </trans-unit>
        <trans-unit id="b4f913427243fca5da364b9f4af093e1c132cd45" translate="yes" xml:space="preserve">
          <source>Another common question that comes up when debugging is &amp;ldquo;where did this exception come from?&amp;rdquo;. Exceptions such as those raised by &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;head []&lt;/code&gt; have no context information attached to them. Finding which particular call to &lt;code&gt;head&lt;/code&gt; in your program resulted in the error can be a painstaking process, usually involving &lt;code&gt;Debug.Trace.trace&lt;/code&gt;, or compiling with profiling and using &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; or &lt;code&gt;+RTS -xc&lt;/code&gt; (see &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">调试时出现的另一个常见问题是&amp;ldquo;此异常来自何处？&amp;rdquo;。诸如因 &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;head []&lt;/code&gt; 引发的异常没有附加上下文信息。在程序中查找哪个特定的 &lt;code&gt;head&lt;/code&gt; 调用会导致错误可能是一个艰苦的过程，通常涉及 &lt;code&gt;Debug.Trace.trace&lt;/code&gt; ，或者通过概要分析并使用 &lt;code&gt;Debug.Trace.traceStack&lt;/code&gt; 或 &lt;code&gt;+RTS -xc&lt;/code&gt; 进行编译（请参阅&lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8a901bb130edd93de354a92729369e7eb8a77ff7" translate="yes" xml:space="preserve">
          <source>Another common use is to ensure any exceptions hidden within lazy fields of a data structure do not leak outside the scope of the exception handler, or to force evaluation of a data structure in one thread, before passing to another thread (preventing work moving to the wrong threads).</source>
          <target state="translated">另一种常见的用法是确保隐藏在数据结构的懒惰字段中的任何异常不会泄漏到异常处理程序的范围之外,或者在将数据结构传递给另一个线程之前,在一个线程中强制评估数据结构(防止工作转移到错误的线程中)。</target>
        </trans-unit>
        <trans-unit id="312336ad458ea40ebadf4c791b596f396bc92d0d" translate="yes" xml:space="preserve">
          <source>Another difference between higher-rank kinds and types can be found in their treatment of inferred and user-specified type variables. Consider the following program:</source>
          <target state="translated">高阶种类和类型之间的另一个区别可以在它们对推断的和用户指定的类型变量的处理中找到。考虑以下程序。</target>
        </trans-unit>
        <trans-unit id="619e7f27cda3e42e4615c75dcb4975c0f4f68283" translate="yes" xml:space="preserve">
          <source>Another difficulty with the memo table is that the value of a key/value pair might itself contain a pointer to the key. So the memo table keeps the value alive, which keeps the key alive, even though there may be no other references to the key so both should die. The weak pointers in this library provide a slight generalisation of the basic weak-pointer idea, in which each weak pointer actually contains both a key and a value.</source>
          <target state="translated">备忘录表的另一个困难是,键/值对的值本身可能包含一个指向键的指针。所以备忘录表使值保持活力,而值又使键保持活力,即使可能没有其他对键的引用,所以两者都应该死亡。这个库中的弱指针提供了一个基本弱指针思想的轻微概括,其中每个弱指针实际上包含了一个键和一个值。</target>
        </trans-unit>
        <trans-unit id="3139c4c3d9fe163dd31667b3304a7a4a55378c8e" translate="yes" xml:space="preserve">
          <source>Another extremely efficient way to make your program snappy is to use library code that has been Seriously Tuned By Someone Else. You &lt;em&gt;might&lt;/em&gt; be able to write a better quicksort than the one in &lt;code&gt;Data.List&lt;/code&gt;, but it will take you much longer than typing &lt;code&gt;import Data.List&lt;/code&gt;.</source>
          <target state="translated">使您的程序更加生动的另一种极为有效的方法是使用其他人已经认真调整过的库代码。您&lt;em&gt;可能&lt;/em&gt;可以编写比 &lt;code&gt;Data.List&lt;/code&gt; 中更好的quicksort，但是比输入 &lt;code&gt;import Data.List&lt;/code&gt; 要花费更多的时间。</target>
        </trans-unit>
        <trans-unit id="0192d00c4c561122179982081c286d8efe43c16b" translate="yes" xml:space="preserve">
          <source>Another form of command is a form of &lt;code&gt;do&lt;/code&gt;-notation. For example, you can write</source>
          <target state="translated">命令的另一种形式是形式 &lt;code&gt;do&lt;/code&gt; -notation。例如，你可以写</target>
        </trans-unit>
        <trans-unit id="ca7ae7aaeace3e8afcdea81b5fff39694bdaa3a2" translate="yes" xml:space="preserve">
          <source>Another important difference between the two types of binding is that the monadic bind (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) is &lt;em&gt;strict&lt;/em&gt; (it evaluates &lt;code&gt;e&lt;/code&gt;), whereas with the &lt;code&gt;let&lt;/code&gt; form, the expression isn&amp;rsquo;t evaluated immediately:</source>
          <target state="translated">两种类型的绑定之间的另一个重要区别是，monadic绑定（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）是&lt;em&gt;严格的&lt;/em&gt;（其评估为 &lt;code&gt;e&lt;/code&gt; ），而对于 &lt;code&gt;let&lt;/code&gt; 形式，该表达式不会立即进行评估：</target>
        </trans-unit>
        <trans-unit id="fa6d0d044f8316bb0266e4594b9afdb9ea5faf82" translate="yes" xml:space="preserve">
          <source>Another point to bear in mind: By far the best way to improve a program&amp;rsquo;s performance &lt;em&gt;dramatically&lt;/em&gt; is to use better algorithms. Once profiling has thrown the spotlight on the guilty time-consumer(s), it may be better to re-think your program than to try all the tweaks listed below.</source>
          <target state="translated">需要牢记的另一点：迄今为止，&lt;em&gt;显着&lt;/em&gt;提高程序性能的最佳方法是使用更好的算法。一旦剖析成为有罪的时间消耗者，重新思考程序可能比尝试下面列出的所有调整要好。</target>
        </trans-unit>
        <trans-unit id="d787e6c2588a53fddf149a1d181b21e1640ac274" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="translated">另一个有用的应用程序是将 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 结合起来，以便相对于其他 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作强制进行深度评估：</target>
        </trans-unit>
        <trans-unit id="748a1e04935a7f3501001c42790b9f7f7d64ce9f" translate="yes" xml:space="preserve">
          <source>Another useful application is to combine &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; in order to force deep evaluation relative to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16541def5ea587ac69bfcc99daad84a959043da" translate="yes" xml:space="preserve">
          <source>Another valid monoid instance of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; It is defined by multiplication and `1` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的另一个有效的monoid实例是 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; 它通过乘法和&amp;ldquo; 1&amp;rdquo;定义为中性元素：</target>
        </trans-unit>
        <trans-unit id="988994d9ba9baaa058f970931250d478f9f37dc1" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">在呼叫站点消除歧义的另一种方法是使用&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;扩展来指定类型。例如：</target>
        </trans-unit>
        <trans-unit id="c9ca1d00f2ba6c9bdc216ddca02e1e03260d4bda" translate="yes" xml:space="preserve">
          <source>Another way to manipulate the scope is to use the &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command, whose syntax is this:</source>
          <target state="translated">操纵范围的另一种方法是使用&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令，其语法为：</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="55329b02c1416b447df48dea23b5ad00b5ee2f0a" translate="yes" xml:space="preserve">
          <source>Any -On where n &amp;gt; 2 is the same as -O2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed001ecb885bcbc05312253a4102a733b569260" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 的所有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 都立即置于关闭状态。</target>
        </trans-unit>
        <trans-unit id="bcbdf5a60ce9ec92529281711b09ee9755999301" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91b45192e9b0774cf7aefe77d4d40c0d29cd8a2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;COMPLETE&lt;/code&gt; sets of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">任何 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;COMPLETE&lt;/code&gt; 集</target>
        </trans-unit>
        <trans-unit id="5dfb3cd648c868b374f6e2677fac36fbe2978a3c" translate="yes" xml:space="preserve">
          <source>Any GHC command-line option that is designated as dynamic (see the table in &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;), may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. To unset an option, you can set the reverse option:</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置&lt;/a&gt;任何指定为动态的GHC命令行选项（请参见&lt;a href=&quot;flags#flag-reference&quot;&gt;标志参考中&lt;/a&gt;的表）。要取消设置选项，可以设置反向选项：</target>
        </trans-unit>
        <trans-unit id="6f5306564b28b058683860c0dbb58f6e1ae386c4" translate="yes" xml:space="preserve">
          <source>Any I/O errors encountered while a handle is semi-closed are simply discarded.</source>
          <target state="translated">当一个句柄处于半关闭状态时,遇到的任何I/O错误都会被简单地丢弃。</target>
        </trans-unit>
        <trans-unit id="0c84ffa38e0d42fe1e3c4aafd67e2a273e5029ca" translate="yes" xml:space="preserve">
          <source>Any arbitrary string, no interpretation or parsing is done.</source>
          <target state="translated">任何任意的字符串,不做任何解释或解析。</target>
        </trans-unit>
        <trans-unit id="0452f2ab13ab3b0881a1a304cec756faecd5a100" translate="yes" xml:space="preserve">
          <source>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</source>
          <target state="translated">任何可以用标准 Haskell 98 语法声明的数据类型也可以用 GADT 风格的语法声明。这种选择在很大程度上是风格上的,但是GADT风格的声明在一个重要的方面有所不同:它们以不同的方式对待数据构造函数的类约束。具体来说,如果给构造函数一个类型类上下文,那么这个上下文是通过模式匹配来提供的。例如</target>
        </trans-unit>
        <trans-unit id="7d3011ab0c7b5aa4a9a177dbc0ce024f6e055225" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">GHCi命令行界面会捕获并打印在语句的评估或执行期间引发的任何异常（有关异常的更多信息，请参见库文档中的&lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="d671ba93c9259d42fd317ba91ce67c391a4d8b7f" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb34342e0a6715040492745b6bae6bc125156350" translate="yes" xml:space="preserve">
          <source>Any expression that has both &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances may be attached to a top-level value binding using an &lt;code&gt;ANN&lt;/code&gt; pragma. In particular, this means you can use &lt;code&gt;ANN&lt;/code&gt; to annotate data constructors (e.g. &lt;code&gt;Just&lt;/code&gt;) as well as normal values (e.g. &lt;code&gt;take&lt;/code&gt;). By way of example, to annotate the function &lt;code&gt;foo&lt;/code&gt; with the annotation &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; you would do this:</source>
          <target state="translated">具有 &lt;code&gt;Typeable&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 实例的任何表达式都可以使用 &lt;code&gt;ANN&lt;/code&gt; 杂注附加到顶级值绑定。特别是，这意味着您可以使用 &lt;code&gt;ANN&lt;/code&gt; 注释数据构造函数（例如 &lt;code&gt;Just&lt;/code&gt; ）以及普通值（例如 &lt;code&gt;take&lt;/code&gt; ）。举例来说，用注解 &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; 来注释函数 &lt;code&gt;foo&lt;/code&gt; ，您可以这样做：</target>
        </trans-unit>
        <trans-unit id="01212113a76fa0770e6b80bde8974e88d8560b27" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b940cc0f6bd9befa4dc2cd571bce369cc78d6f" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">可以使用&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension中&lt;/a&gt;定义的 &lt;code&gt;Extension&lt;/code&gt; 类型中的任何扩展。如果不支持任何请求的扩展名，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="45294fce8a408e067f71fcddc66e44fa9a3aa925" translate="yes" xml:space="preserve">
          <source>Any field width is followed optionally by a precision:</source>
          <target state="translated">任何字段的宽度后面都有一个精度。</target>
        </trans-unit>
        <trans-unit id="ca99cdb1b6224c8f2acca56e49dc80e277ef33e9" translate="yes" xml:space="preserve">
          <source>Any flags are followed optionally by a field width:</source>
          <target state="translated">任何标志后面都有一个可选的字段宽度。</target>
        </trans-unit>
        <trans-unit id="fe6292886945b8678502b2eed862908e6596bec8" translate="yes" xml:space="preserve">
          <source>Any flags not recognized by runghc are automatically passed to GHC. If a flag is recognized by both runghc and GHC but you want to pass it to GHC then you can place it after a &lt;code&gt;--&lt;/code&gt; separator. Flags after the separator are treated as GHC only flags. Alternatively you can use the runghc option &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass any flag or argument directly to GHC.</source>
          <target state="translated">runghc无法识别的所有标志都会自动传递到GHC。如果标志被runghc和GHC识别，但您希望将其传递给GHC，则可以将其放在 &lt;code&gt;--&lt;/code&gt; 分隔符之后。分隔符之后的标志被视为仅GHC标志。或者，您可以使用runghc选项 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 将任何标志或参数直接传递给GHC。</target>
        </trans-unit>
        <trans-unit id="d3a24acb0ed73105a63c6aa8b83c5ce57f71ebe7" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; can be made into an instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; by defining &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过定义 &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt; ，可以将 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 的任何实例制作为 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="c46287c62f0868214d45f152801a23db51bd59d4" translate="yes" xml:space="preserve">
          <source>Any instance should be subject to the following laws:</source>
          <target state="translated">任何实例都应遵守以下法律。</target>
        </trans-unit>
        <trans-unit id="b4adffce07a1e96f7b4aa9f3335793d174570cf6" translate="yes" xml:space="preserve">
          <source>Any modifiers found.</source>
          <target state="translated">任何修改器发现。</target>
        </trans-unit>
        <trans-unit id="5cecd2c65d9c46eca630a92c4797e911edc247d7" translate="yes" xml:space="preserve">
          <source>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a &lt;code&gt;Main&lt;/code&gt; module, the program will also be linked into an executable.</source>
          <target state="translated">可以指定任意数量的源文件名或模块名；GHC将通过遵循这些初始模块的导入来找出程序中的所有模块。然后它将尝试编译每个过时的模块，最后，如果有 &lt;code&gt;Main&lt;/code&gt; 模块，则该程序还将链接到一个可执行文件中。</target>
        </trans-unit>
        <trans-unit id="8a7ee0a6d4ed7c475e886db91c9ca4af5ab7c3c0" translate="yes" xml:space="preserve">
          <source>Any of the command-line options described in the rest of this chapter can be used with &lt;code&gt;--make&lt;/code&gt;, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you&amp;rsquo;ll need to use an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt;).</source>
          <target state="translated">本章其余部分描述的任何命令行选项都可以与 &lt;code&gt;--make&lt;/code&gt; 一起使用，但是请注意，您在命令行上给出的任何选项都将应用于所有编译的源文件，因此如果您希望应用任何选项仅限于单个源文件，您将需要使用 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译指示（请参见&lt;a href=&quot;#source-file-options&quot;&gt;源文件中的命令行选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4fcac47fb48917b29ef16b080f9169cd49dcd808" translate="yes" xml:space="preserve">
          <source>Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt;. A semi-closed handle becomes closed:</source>
          <target state="translated">由于句柄已关闭而失败的任何操作，如果句柄是半封闭的，则也会失败。唯一的例外是 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 。半封闭手柄将变为封闭状态：</target>
        </trans-unit>
        <trans-unit id="74cf8930fe96c667f6ee4ecd6012b01ea066396e" translate="yes" xml:space="preserve">
          <source>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn&amp;rsquo;t actually import the same orphans.</source>
          <target state="translated">即使从最终实现模块实际上未导入相同的孤儿的情况下，也无条件地考虑了从签名的导入而引入范围的任何孤儿实例。</target>
        </trans-unit>
        <trans-unit id="2fbfab23f62ec3e48e80e1e5422619cb69668f7f" translate="yes" xml:space="preserve">
          <source>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">谓词不匹配的其他任何异常都会重新引发，并可能被封闭的 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 等捕获。</target>
        </trans-unit>
        <trans-unit id="a712b26d1cb0416ca0ddd0555d9306a2c267be27" translate="yes" xml:space="preserve">
          <source>Any precision is followed optionally for Integral types by a width modifier; the only use of this modifier being to set the implicit size of the operand for conversion of a negative operand to unsigned:</source>
          <target state="translated">对于Integral类型,任何精度后面都有一个宽度修饰符;这个修饰符的唯一用途是设置负操作数转换为无符号操作数时操作数的隐含大小。</target>
        </trans-unit>
        <trans-unit id="d8c91f9f9f6e75c41b02098e931d3439ddcf440f" translate="yes" xml:space="preserve">
          <source>Any real interval contains a unique simplest rational; in particular, note that &lt;code&gt;0/1&lt;/code&gt; is the simplest rational of all.</source>
          <target state="translated">任何实际区间都包含唯一的最简单的有理数；特别注意的是 &lt;code&gt;0/1&lt;/code&gt; 是最简单的所有合理的。</target>
        </trans-unit>
        <trans-unit id="bd6fa11933cdfcdc743d92e3ae1b1b26d19d69a2" translate="yes" xml:space="preserve">
          <source>Any single-constructor data is eligible for unpacking; for example</source>
          <target state="translated">任何单一构造体数据都有资格进行解包,例如</target>
        </trans-unit>
        <trans-unit id="a18603a852f4e4b843d8b21962152ae0dc60595e" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 在文件描述符上阻塞的任何线程都将通过引发IO异常来解除阻塞。</target>
        </trans-unit>
        <trans-unit id="769148ddf54673e79970f08b70786bcc3aab11e0" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 在文件描述符上阻塞的任何线程都将通过引发IO异常来解除阻塞。</target>
        </trans-unit>
        <trans-unit id="87c36f7b926ac2fbec6f667eb5439c00c637c3ef" translate="yes" xml:space="preserve">
          <source>Any type that you wish to throw or catch as an exception must be an instance of the &lt;code&gt;Exception&lt;/code&gt; class. The simplest case is a new exception type directly below the root:</source>
          <target state="translated">您希望引发或捕获的任何类型的异常都必须是 &lt;code&gt;Exception&lt;/code&gt; 类的实例。最简单的情况是在根目录正下方的新异常类型：</target>
        </trans-unit>
        <trans-unit id="b1bd8e562d1fefda868c7d1ff0cda571db4a02aa" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩中的任何变量都是绑定的事件，但是在模式中&amp;ldquo;左&amp;rdquo;绑定的变量在范围内。例如，此功能允许在另一个参数的视图中使用函数的一个参数。例如，可以使用视图模式来编写来自&lt;a href=&quot;#pattern-guards&quot;&gt;Pattern &lt;/a&gt; &lt;code&gt;clunky&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="b0f483f182aa56813d1000ce4df4790bcbe905f1" translate="yes" xml:space="preserve">
          <source>Any whitespace which appears outside of either of the quoting and escaping mechanisms, is interpreted as having been added by this special concatenation process to designate where the boundaries are between the original, un-concatenated list of strings. These added whitespace characters are removed from the output.</source>
          <target state="translated">任何出现在引号和转义机制之外的空白字符,都会被解释为是由这个特殊的连接过程添加的,用于指定原始的、未连接的字符串列表之间的边界。这些添加的空白字符会从输出中删除。</target>
        </trans-unit>
        <trans-unit id="86fba8724925018bcafcede041fc92c898e3eb9b" translate="yes" xml:space="preserve">
          <source>AnyclassStrategy</source>
          <target state="translated">AnyclassStrategy</target>
        </trans-unit>
        <trans-unit id="2d219c6ebc1efaae092effbbdcf3fa6d485c6699" translate="yes" xml:space="preserve">
          <source>Anything else throws an exception:</source>
          <target state="translated">其他任何东西都会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="036d8f7bd31769453184842860e1d5ca8c639fff" translate="yes" xml:space="preserve">
          <source>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints.</source>
          <target state="translated">凡是已经有效的约束,而没有标志的:饱和应用于类型类、隐式参数和平等约束。</target>
        </trans-unit>
        <trans-unit id="ad26f77e74f38dbef3399b317d10c13e53d32aa2" translate="yes" xml:space="preserve">
          <source>Anything whose form is not yet known, but the user has declared to have kind &lt;code&gt;Constraint&lt;/code&gt; (for which they need to import it from &lt;code&gt;Data.Kind&lt;/code&gt;). So for example &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; is allowed, as well as examples involving type families:</source>
          <target state="translated">尚不知道其形式，但用户已声明具有种类 &lt;code&gt;Constraint&lt;/code&gt; 的任何内容（需要从 &lt;code&gt;Data.Kind&lt;/code&gt; 导入）。例如， &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; ，以及涉及类型族的示例：</target>
        </trans-unit>
        <trans-unit id="b920fb3adf34d73af2cb7b5c93d8efbc94cd36f7" translate="yes" xml:space="preserve">
          <source>Ap</source>
          <target state="translated">Ap</target>
        </trans-unit>
        <trans-unit id="53d21ca24e640bdf8e7b761f501faaae7e4e72fb" translate="yes" xml:space="preserve">
          <source>Apart from removing intermediate data-structures, encodings can be optimized further by fine-tuning their execution parameters using the functions in &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; and their &quot;inner loops&quot; using the functions in &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;.</source>
          <target state="translated">除了删除中间数据结构，编码可以进一步通过微调优化使用的功能的它们的执行参数&lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;使用功能和他们的&amp;ldquo;内环&amp;rdquo; &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14dc219def5159ae2ab7cfd4d71881c1c3903e70" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;code&gt;:{ ... :}&lt;/code&gt; syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by &lt;code&gt;:set +m&lt;/code&gt;, &lt;code&gt;:set +m&lt;/code&gt; in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</source>
          <target state="translated">除了上述用于多行输入的 &lt;code&gt;:{ ... :}&lt;/code&gt; 语法外，GHCi还具有多行模式，该模式由 &lt;code&gt;:set +m&lt;/code&gt; ， &lt;code&gt;:set +m&lt;/code&gt; 启用，在该模式下，GHCi在当前语句未完成时自动检测并允许要添加的其他行。多行输入以空行终止。例如：</target>
        </trans-unit>
        <trans-unit id="fc4a695f02a8a53a129dcb9ace91e91ee1e7feb9" translate="yes" xml:space="preserve">
          <source>App</source>
          <target state="translated">App</target>
        </trans-unit>
        <trans-unit id="c607b075485b6dc8c400c818769a9c892ea0ffc4" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="f664580544f7f0aa77f101d16e0efbbe807fa6e5" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="e26661dc8c698ec289349a6aeecab4d0a5e5ec82" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="345b0c25bf20f673449b84d7d686b5c70bebf7c2" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 附加到文件。</target>
        </trans-unit>
        <trans-unit id="4ebc23e4c1b65a48a70d373d483fafb1ccae8ba3" translate="yes" xml:space="preserve">
          <source>Append two lists, i.e.,</source>
          <target state="translated">附加两个名单,即:</target>
        </trans-unit>
        <trans-unit id="3e0bf0178a1d360f27255c9a7f025fc03359dcd5" translate="yes" xml:space="preserve">
          <source>AppendHandle</source>
          <target state="translated">AppendHandle</target>
        </trans-unit>
        <trans-unit id="374c012a038cea614a313e941a993048c6cf1210" translate="yes" xml:space="preserve">
          <source>AppendMode</source>
          <target state="translated">AppendMode</target>
        </trans-unit>
        <trans-unit id="3916a3175dfaa3fd999b22f53277fe454f6b7b38" translate="yes" xml:space="preserve">
          <source>AppendOnWrite</source>
          <target state="translated">AppendOnWrite</target>
        </trans-unit>
        <trans-unit id="dbe098d861d9a244dfef0444bcf8ab0f87546a7d" translate="yes" xml:space="preserve">
          <source>AppendSymbol</source>
          <target state="translated">AppendSymbol</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="d311231658a1b3353cd77d4859248f1e061c4cc1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="43dbefc4fd00eee5d8e84d6de5dadb9d229d56a1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="f58752dc50f3a1aa349659b655c647ebed7f8f30" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">应用操作员。该运算符是多余的，因为普通应用程序 &lt;code&gt;(f x)&lt;/code&gt; 含义与 &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 相同。但是， &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 具有较低的右关联绑定优先级，因此有时可以省略括号。例如：</target>
        </trans-unit>
        <trans-unit id="4bf898ba305639dbde7f1d71fe68cf723d6796d1" translate="yes" xml:space="preserve">
          <source>Application-specific customizations to the user interface.</source>
          <target state="translated">对用户界面进行特定应用的定制。</target>
        </trans-unit>
        <trans-unit id="0b8a1b21fc212c72c3e7976ca547d1f598c5e314" translate="yes" xml:space="preserve">
          <source>Applicative</source>
          <target state="translated">Applicative</target>
        </trans-unit>
        <trans-unit id="c42b346f9e6450034a0b493919801528c343e948" translate="yes" xml:space="preserve">
          <source>Applicative actions</source>
          <target state="translated">适用行动</target>
        </trans-unit>
        <trans-unit id="98c9a7602c91954ae00f88c84bb4db90472de9d3" translate="yes" xml:space="preserve">
          <source>Applicative do-notation desugaring preserves the original semantics, provided that the &lt;code&gt;Applicative&lt;/code&gt; instance satisfies &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; and &lt;code&gt;pure = return&lt;/code&gt; (these are true of all the common monadic types). Thus, you can normally turn on &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; without fear of breaking your program. There is one pitfall to watch out for; see &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;Things to watch out for&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Applicative&lt;/code&gt; 实例满足 &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; 和 &lt;code&gt;pure = return&lt;/code&gt; （在所有常见单子类型中都是这样），则应用符号表示法将保留原始语义。因此，您通常可以打开&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; ,&lt;/a&gt;而不必担心会破坏程序。有一个陷阱需要提防。看&lt;a href=&quot;#applicative-do-pitfall&quot;&gt;提防的事情&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3040a310341680e034eec3985152bc5a9e486ec2" translate="yes" xml:space="preserve">
          <source>Applicative functor formed by adding pure computations to a given applicative functor.</source>
          <target state="translated">在给定的应用型漏斗中加入纯计算而形成的应用型漏斗。</target>
        </trans-unit>
        <trans-unit id="65f268e6aa6cb1e22480a2a575f39395d4e90f10" translate="yes" xml:space="preserve">
          <source>Applicative functors</source>
          <target state="translated">应用型漏斗</target>
        </trans-unit>
        <trans-unit id="e1507c25dc6a64376527010df0e4de108198887a" translate="yes" xml:space="preserve">
          <source>Applicative general combining function</source>
          <target state="translated">适用的一般组合功能</target>
        </trans-unit>
        <trans-unit id="ba83691e2c1dcc5de53cc3e4b25ca28fcf3f9a3b" translate="yes" xml:space="preserve">
          <source>Applicative merge tactic types</source>
          <target state="translated">适用的合并战术类型</target>
        </trans-unit>
        <trans-unit id="3bb211f1db0886c20dbcbe3aec098bfa4c51a870" translate="yes" xml:space="preserve">
          <source>ApplicativeDo</source>
          <target state="translated">ApplicativeDo</target>
        </trans-unit>
        <trans-unit id="a3e4a569ead07c8bc4d8de675cfd615c69dad24a" translate="yes" xml:space="preserve">
          <source>Applied</source>
          <target state="translated">Applied</target>
        </trans-unit>
        <trans-unit id="919e6fc623e0dc282b30825056bd5dda3c4e6c46" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="637b1e1d5c8efd54c8949c6a43abe4555350a327" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="9e82bc67b89a4b9e5b1ef1666971641ffcc4ec35" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="bbb6d3ed7b10d0b6c91c1b6b6102c1501910cf5b" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="b1b160142b2aab409abf2571e6a42ee896b8231e" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表， &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定列表中的所有元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="1bb3df1dee5942308d7549a4ff4e6623460c1a98" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表时， &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 决定列表中的任何元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的； &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="649319403532f404d1828c385726fa18cf17318d" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定列表中的所有元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="96fd46ee7a807ee87c60e5d0b9ca946dc3e911cb" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">应用于谓词和列表时， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 决定列表中的任何元素是否满足谓词。为了使结果为 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，列表必须是有限的； &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，然而，从结果 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 谓词值施加到元件在有限或无限列表的有限索引。</target>
        </trans-unit>
        <trans-unit id="be0613a1194858373863a5914ef44b595dda15fa" translate="yes" xml:space="preserve">
          <source>Applies a type to a function type. Returns: &lt;code&gt;Just u&lt;/code&gt; if the first argument represents a function of type &lt;code&gt;t -&amp;gt; u&lt;/code&gt; and the second argument represents a function of type &lt;code&gt;t&lt;/code&gt;. Otherwise, returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">将类型应用于函数类型。返回： &lt;code&gt;Just u&lt;/code&gt; 如果第一个参数表示的类型的函数 &lt;code&gt;t -&amp;gt; u&lt;/code&gt; ，第二个参数代表的类型的函数 &lt;code&gt;t&lt;/code&gt; 。否则，返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee4a02d62b3b562a9c374f2e31932813920bd3d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;(+1)&lt;/code&gt; to a list, a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">将 &lt;code&gt;(+1)&lt;/code&gt; 应用于一个列表，一个 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7560eee7a783d22baf2bd6d4444f64f9c9a496fc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; to the second element of a pair:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; 适用于一对的第二个元素：</target>
        </trans-unit>
        <trans-unit id="11040b63f3921092eab408bc2b85dc0c41f9e594" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 应用于 &lt;code&gt;Maybe Int&lt;/code&gt; 。如果我们有 &lt;code&gt;Just n&lt;/code&gt; ，我们想显示底层的 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 。但是，如果我们有 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回空字符串，而不是（例如）&amp;ldquo; Nothing&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="615a1ddaf7551b2a4174858609db8c4f030df5a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 应用于 &lt;code&gt;Maybe Int&lt;/code&gt; 。如果我们有 &lt;code&gt;Just n&lt;/code&gt; ，我们想显示底层的 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 。但是，如果我们有 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回空字符串，而不是（例如）&amp;ldquo; Nothing&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="edd6c71ec52ff9bccf29d84188bba0b21ce69446" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上花 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6b9c8416c76cb38545167e06e3308ec9286dc30" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，请在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ad84cd5aa8118e1f8b36881b3b884a1d00f4857" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 应用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9745cca7883787ea648c32cd3f515d25f4cb991e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">适用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; ，如果布尔是真实的。</target>
        </trans-unit>
        <trans-unit id="96e48ba2760c93e4e34b159d49c1dbbc56799681" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9854504f7be6e574e7bfe679f44b4ee0c6be89cc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上花 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f46147f015f62456e6f042fc1fdd0a4e456ff05" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，请在 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 上加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d053cfa4369b1863e68c118fa964a1a17e42f125" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 应用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21bdb9c521d1c7d41257920a997db5a1c432b4d7" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">适用 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; ，如果布尔是真实的。</target>
        </trans-unit>
        <trans-unit id="83bd5f5c6340c2876e03bdf5c78f42f0045fcd17" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">如果布尔值为true，则对 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 加上 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00536f11c69e40c7baa6a53f5c52fe55c8806e5" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;f&lt;/code&gt;-actions in the reverse order.</source>
          <target state="translated">应用 &lt;code&gt;f&lt;/code&gt; 以相反的顺序-actions。</target>
        </trans-unit>
        <trans-unit id="a7fd738556716f25c4a33b181a4727d226b4c919" translate="yes" xml:space="preserve">
          <source>Apply a function to a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; token. When manually applying a function to &lt;code&gt;realWorld#&lt;/code&gt;, it is necessary to use &lt;code&gt;NOINLINE&lt;/code&gt; to prevent semantically undesirable floating. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; is inlined, but only very late in compilation after all floating is complete.</source>
          <target state="translated">将功能应用于 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 令牌。将函数手动应用于 &lt;code&gt;realWorld#&lt;/code&gt; 时，必须使用 &lt;code&gt;NOINLINE&lt;/code&gt; 来防止语义上不希望的浮动。内联 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; ，但是在完成所有浮动之后才在编译的后期进行。</target>
        </trans-unit>
        <trans-unit id="15923e60f19aafe01135e2792144867deb99400e" translate="yes" xml:space="preserve">
          <source>Apply a function to the first element of an optional pair.</source>
          <target state="translated">将一个函数应用于一个可选对的第一个元素。</target>
        </trans-unit>
        <trans-unit id="a5aee8e5a78690a96a71ac571dd01657b03993bb" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the continuation passed to a CPS computation.</source>
          <target state="translated">应用一个函数来转换传递给CPS计算的延续。</target>
        </trans-unit>
        <trans-unit id="35e3f909c25395866110729633dad59aecf7af3c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation.</source>
          <target state="translated">应用一个函数来变换一个继续传递计算的结果。</target>
        </trans-unit>
        <trans-unit id="4ff89ef704740fc048b9ba990998fdecd8670f9c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来转换连续传递计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="d4993fc434940195f4b64a80d66593316a376d43" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来转换连续传递计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="b51211dea86c79bd6e381cda63ad155fa030e446" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation.</source>
          <target state="translated">应用函数来变换选择计算的结果。</target>
        </trans-unit>
        <trans-unit id="119d0767fcb8340ed73d84a60d5eb57b7349f3e5" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">应用函数来变换选择计算的结果。它的类型比其他monad转换器的 &lt;code&gt;map&lt;/code&gt; 操作更受限制，因为 &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 不在monads类别中定义函子。</target>
        </trans-unit>
        <trans-unit id="90c1bc3308702f2e877e752823a6f576e30aa537" translate="yes" xml:space="preserve">
          <source>Apply a transformation to the other computation.</source>
          <target state="translated">对另一个计算进行变换。</target>
        </trans-unit>
        <trans-unit id="6b6f2a899229fc5c6cb94a1a620e95652b86a4f6" translate="yes" xml:space="preserve">
          <source>Apply one equality to another, respectively</source>
          <target state="translated">分别将一个平等应用于另一个平等</target>
        </trans-unit>
        <trans-unit id="3915aaeccbb6370f41a8ba795caff78447316b72" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;mask&lt;/code&gt; to an exception handler</source>
          <target state="translated">将 &lt;code&gt;mask&lt;/code&gt; 应用于异常处理程序</target>
        </trans-unit>
        <trans-unit id="7940fbb624b272a2fc9b14574cab25dadfa00758" translate="yes" xml:space="preserve">
          <source>Applying functions of dynamic type</source>
          <target state="translated">应用动态类型的函数</target>
        </trans-unit>
        <trans-unit id="8d3c6b448377adca963a9a043ce17ad5b59ebdc9" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c0f892889dcc2a8ebf1f6c5901067143d19b65" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4918ddd1f06d48d8245e6c5a8235cc03f138f53" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a6b0961bc685e7241bda505e193149b1b6e1e7" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">任意精度有理数，表示为两个 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的比率。可以使用 &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 运算符来构造有理数。</target>
        </trans-unit>
        <trans-unit id="2f570f682fb6c172cde8b33c6dce79b95de7ed61" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">任意精度有理数，表示为两个 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的比率。可以使用 &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 运算符来构造有理数。</target>
        </trans-unit>
        <trans-unit id="29a35ec82756568480404c0269911333a81119f5" translate="yes" xml:space="preserve">
          <source>Arbitrary-sized tuples</source>
          <target state="translated">任意大小的元组</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="9932a4cb0405a0729daea0726dad5bca21f86edb" translate="yes" xml:space="preserve">
          <source>ArgDescr</source>
          <target state="translated">ArgDescr</target>
        </trans-unit>
        <trans-unit id="ffc2c4751c406dfe729e68e12fca79cd5235bbd5" translate="yes" xml:space="preserve">
          <source>ArgMax</source>
          <target state="translated">ArgMax</target>
        </trans-unit>
        <trans-unit id="ff6dd3f82d1ef3b64409b1d48173a3489bd3a0de" translate="yes" xml:space="preserve">
          <source>ArgMin</source>
          <target state="translated">ArgMin</target>
        </trans-unit>
        <trans-unit id="33b3818348e9a7abc5ad4f8c9119835de808618f" translate="yes" xml:space="preserve">
          <source>ArgMin, ArgMax</source>
          <target state="translated">ArgMin,ArgMax</target>
        </trans-unit>
        <trans-unit id="24257e1e26a78c97f1a7d50aeb70e00749ebb9e9" translate="yes" xml:space="preserve">
          <source>ArgOrder</source>
          <target state="translated">ArgOrder</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e753ec7f8245ae5fdc7a8b075baae341353e5ea" translate="yes" xml:space="preserve">
          <source>ArgumentLimit</source>
          <target state="translated">ArgumentLimit</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="41c35f0b16b9faa92a29f4ed3edbe5f0ea7a74af" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the executable</source>
          <target state="translated">要传递给可执行文件的参数</target>
        </trans-unit>
        <trans-unit id="e1cbb100861b9948d58a53b976c856c97d398433" translate="yes" xml:space="preserve">
          <source>Arguments which look like &lt;code&gt;@foo&lt;/code&gt; will be replaced with the contents of file &lt;code&gt;foo&lt;/code&gt;. A gcc-like syntax for response files arguments is expected. This must re-constitute the argument list by doing an inverse of the escaping mechanism done by the calling-program side.</source>
          <target state="translated">看起来像 &lt;code&gt;@foo&lt;/code&gt; 的参数将替换为 &lt;code&gt;foo&lt;/code&gt; 文件的内容。响应文件参数应采用类似gcc的语法。这必须通过执行与调用程序端相反的转义机制来重新构造参数列表。</target>
        </trans-unit>
        <trans-unit id="c4a70a3f41d906934cb39fa13410a07666b58dc9" translate="yes" xml:space="preserve">
          <source>ArithException</source>
          <target state="translated">ArithException</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="bb08cbe0a6134017a6f7cf472ab8010209d07a2f" translate="yes" xml:space="preserve">
          <source>Arithmetic exceptions.</source>
          <target state="translated">算术异常。</target>
        </trans-unit>
        <trans-unit id="a9d7caa767383fc4926cd95d59576ba33ee0a3dc" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202699f8498d7982cc53b20732251548a363465a" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflowoverflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">算术上的 &lt;code&gt;Int&lt;/code&gt; 是选中的overflowoverflow &lt;code&gt;Int&lt;/code&gt; ，等等所有的操作 &lt;code&gt;Int&lt;/code&gt; 发生模2 &lt;sup&gt;⟨n⟩&lt;/sup&gt;其中⟨n⟩是在中位大小 &lt;code&gt;Int&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算术运算</target>
        </trans-unit>
        <trans-unit id="3fecae258b41570e5190fa75b10edfa2c67f433e" translate="yes" xml:space="preserve">
          <source>Arithmetic shift-right operation</source>
          <target state="translated">算术右移操作</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a070934e81973445b297f3e432a70f43cd9eb647" translate="yes" xml:space="preserve">
          <source>Array classes</source>
          <target state="translated">阵列类</target>
        </trans-unit>
        <trans-unit id="1f72bc74b6f28918205f9e6e811785a34a99cae8" translate="yes" xml:space="preserve">
          <source>Array construction</source>
          <target state="translated">阵列结构</target>
        </trans-unit>
        <trans-unit id="b9be2aa72950b9c68024a84de0f4b74e90523e2c" translate="yes" xml:space="preserve">
          <source>Array in which to place the values</source>
          <target state="translated">放置数值的阵列</target>
        </trans-unit>
        <trans-unit id="35664ac437e521792c86de2c050b2b9616ad2f9b" translate="yes" xml:space="preserve">
          <source>Array to resize</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f55ab0f2f0b52c9ee209db3b03b78882aa29c9" translate="yes" xml:space="preserve">
          <source>Array to write from</source>
          <target state="translated">阵列写入</target>
        </trans-unit>
        <trans-unit id="2dfdceb734024f39f314a3c0b8391586228fb921" translate="yes" xml:space="preserve">
          <source>Array#</source>
          <target state="translated">Array#</target>
        </trans-unit>
        <trans-unit id="898837d96f33bff85a3be5478164cfc6afd0eadc" translate="yes" xml:space="preserve">
          <source>ArrayArray#</source>
          <target state="translated">ArrayArray#</target>
        </trans-unit>
        <trans-unit id="592acb75a6da231d0a2a2173d588c93486db96f4" translate="yes" xml:space="preserve">
          <source>ArrayException</source>
          <target state="translated">ArrayException</target>
        </trans-unit>
        <trans-unit id="93c35e8fd0d3491f05295cbaa9fc1ec445fdc9e3" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;Storable&lt;/code&gt; things.</source>
          <target state="translated">可 &lt;code&gt;Storable&lt;/code&gt; 事物的数组。</target>
        </trans-unit>
        <trans-unit id="6f11fdf73ec1f7aec4ea144e79eb109ff942b709" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements</source>
          <target state="translated">带有未装箱元素的数组</target>
        </trans-unit>
        <trans-unit id="9d7392dc546e184e07e6daaacd277a5d43a5c7da" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">具有未装箱元素的数组。的实例 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 提供用于 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 与某些元素类型（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ，等;见 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 类的完整列表）。</target>
        </trans-unit>
        <trans-unit id="641e7befb70fe85093114258ec0852dc24a766bf" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4758c3cc8dac2d76026d0733816741f9b21d43" translate="yes" xml:space="preserve">
          <source>Arrow</source>
          <target state="translated">Arrow</target>
        </trans-unit>
        <trans-unit id="4a7111dcaf1b4237c13ed045e218a14996e9fbe6" translate="yes" xml:space="preserve">
          <source>Arrow application</source>
          <target state="translated">箭头应用</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">方向键</target>
        </trans-unit>
        <trans-unit id="a6216e2bed8396214323ababdee0bc0041b0726d" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">箭头符号（请参阅&lt;a href=&quot;#arrow-notation&quot;&gt;箭头符号&lt;/a&gt;）使用范围内的任何 &lt;code&gt;arr&lt;/code&gt; ， &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;app&lt;/code&gt; ， &lt;code&gt;(|||)&lt;/code&gt; 和 &lt;code&gt;loop&lt;/code&gt; 函数。但是与其他构造不同，这些函数的类型必须与Prelude类型非常紧密地匹配。细节在不断变化。如果要使用此功能，请询问！</target>
        </trans-unit>
        <trans-unit id="8f1f0db1f62fbb0e92d1c7e980a5aefb808bd919" translate="yes" xml:space="preserve">
          <source>ArrowApply</source>
          <target state="translated">ArrowApply</target>
        </trans-unit>
        <trans-unit id="3c11beff8b02b8f9cbaa16ca3ab20327c65da1ba" translate="yes" xml:space="preserve">
          <source>ArrowChoice</source>
          <target state="translated">ArrowChoice</target>
        </trans-unit>
        <trans-unit id="47595fe84f8dd1e9405b5200e89860454330a77e" translate="yes" xml:space="preserve">
          <source>ArrowLoop</source>
          <target state="translated">ArrowLoop</target>
        </trans-unit>
        <trans-unit id="e45164f39602039a081dfdb414a58cdcb90fce01" translate="yes" xml:space="preserve">
          <source>ArrowMonad</source>
          <target state="translated">ArrowMonad</target>
        </trans-unit>
        <trans-unit id="31cc2db65fb67d75aaa03855c6522bc61f0c5f08" translate="yes" xml:space="preserve">
          <source>ArrowPlus</source>
          <target state="translated">ArrowPlus</target>
        </trans-unit>
        <trans-unit id="a6cef6a13748337ec64d72cbbfdef1e1d56c28ba" translate="yes" xml:space="preserve">
          <source>ArrowT</source>
          <target state="translated">ArrowT</target>
        </trans-unit>
        <trans-unit id="c5b3adde056c0b01047cb4ee63a6ade2f14b6bf6" translate="yes" xml:space="preserve">
          <source>ArrowZero</source>
          <target state="translated">ArrowZero</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="c27973de6a30851ee83300e482ede863a41f7f94" translate="yes" xml:space="preserve">
          <source>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</source>
          <target state="translated">箭头是John Hughes介绍的单项式的概括。更多细节,请看</target>
        </trans-unit>
        <trans-unit id="50de5e9983b77e93c151fa7abf423177ee062d7f" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 一样，但严格的归约结果在每个步骤中都起作用。</target>
        </trans-unit>
        <trans-unit id="192565b6bc1ac3ccf6bc1023c2ebb1325b5351f9" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; ，但严格的缩减结果在每个步骤中都起作用。</target>
        </trans-unit>
        <trans-unit id="5af372b8d1d974d76bfe10c942fe9d73af03dd9b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;, but with the structure as the primary argument. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; ，但以结构为主要参数。有关不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa8707f2ab83f8daca8094457adcacefc1dfcf09" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; are just binary operators, one might ask what happens if the datatype has more than two constructors, or a constructor with more than two fields. The answer is simple: the operators are used several times, to combine all the constructors and fields as needed. However, users /should not rely on a specific nesting strategy/ for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; being used. The compiler is free to choose any nesting it prefers. (In practice, the current implementation tries to produce a more-or-less balanced nesting, so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 只是二进制运算符，所以您可能会问，如果数据类型具有两个以上的构造函数，或者一个构造函数具有两个以上的字段，会发生什么情况。答案很简单：运算符被多次使用，以根据需要组合所有构造函数和字段。但是，用户不应该依赖于 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 的特定嵌套策略/ 。编译器可以自由选择其喜欢的任何嵌套。 （在实践中，当前实现尝试产生或多或少的平衡嵌套，以便可以从对数而不是线性时间遍历从根到特定组件的数据类型结构。）</target>
        </trans-unit>
        <trans-unit id="d1abb43b60664f44000bb7f5a55f0ee83b119b80" translate="yes" xml:space="preserve">
          <source>As GHC&amp;rsquo;s compilation products don&amp;rsquo;t map perfectly onto DWARF constructs, GHC takes advantage of the extensibility of the DWARF standard to provide additional information.</source>
          <target state="translated">由于GHC的编译产品无法完美地映射到DWARF结构上，因此GHC利用DWARF标准的可扩展性来提供其他信息。</target>
        </trans-unit>
        <trans-unit id="e35067b51e094e56d5ae4f8f876dfb483b8f92fd" translate="yes" xml:space="preserve">
          <source>As a binary semaphore &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt;, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as wait and signal.</source>
          <target state="translated">作为二进制信号量 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt; ，将 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 用作等待和信号。</target>
        </trans-unit>
        <trans-unit id="86cdad137d8956982af57685ad5fdd7f0b7b6c9c" translate="yes" xml:space="preserve">
          <source>As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt;. However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bbfcb820033011b427f73f5d8e7b567bf9a401" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="f93309e1645a680e5a41f639c6d8007d29bdfd58" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="80b0e3a1e8c000dc891586ccc71861ad6328cf11" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">由于这些定律， &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例将满足</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">作为一个构造函数</target>
        </trans-unit>
        <trans-unit id="5d801d83cd9e0b19d834377699e0695ddc3ca42e" translate="yes" xml:space="preserve">
          <source>As a constructor with record syntax</source>
          <target state="translated">作为记录语法的构造函数</target>
        </trans-unit>
        <trans-unit id="9189865da8d3692a10ab79cac723aaeb6eea7be7" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">为方便起见，GHC允许您在名称明确时省略引号。但是，我们的经验表明，引号有助于使代码更具可读性，并且不易出错。因此，GHC支持&lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt;，如果您使用不带引号的升级数据构造函数，则会警告您。</target>
        </trans-unit>
        <trans-unit id="ce1486ef373f517210a834efa7f6eeb842e7f926" translate="yes" xml:space="preserve">
          <source>As a general rule, if a data type has a derived &lt;code&gt;Functor&lt;/code&gt; instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., &lt;code&gt;newtype Id a = Id a&lt;/code&gt;), or (2) occur as the last argument of a type constructor (as in &lt;code&gt;Right&lt;/code&gt; above).</source>
          <target state="translated">通常，如果数据类型具有派生的 &lt;code&gt;Functor&lt;/code&gt; 实例，并且其最后一个类型参数出现在数据声明的右侧，则它要么必须（1）裸露（例如， &lt;code&gt;newtype Id a = Id a&lt;/code&gt; ）或（2）作为类型构造函数的最后一个参数出现（如上 &lt;code&gt;Right&lt;/code&gt; 所示）。</target>
        </trans-unit>
        <trans-unit id="e5b650f5b24353725153d71d0ace5287fade8a17" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">作为调试Parsec解析器的更全面的替代方法，还有不包含&lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec的&lt;/a&gt;软件包。</target>
        </trans-unit>
        <trans-unit id="826ab8729c5c6b675ee7477d0a06b532fb5de96a" translate="yes" xml:space="preserve">
          <source>As a more substantial example of the rules in action, consider</source>
          <target state="translated">作为规则运作的一个更实质性的例子,请考虑到</target>
        </trans-unit>
        <trans-unit id="8478fed6cf150b0bde8267af58280dff83b3ef83" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</source>
          <target state="translated">作为一个快速的例子,这里是一个前端插件,它可以打印传递给它的参数,然后退出。</target>
        </trans-unit>
        <trans-unit id="991de1e28384a51531170b3384f7afcc4d87ef71" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says &amp;lsquo;Hello&amp;rsquo;:</source>
          <target state="translated">举个简单的例子，这是一个简单的插件，它什么都不做，只返回未经修改的原始编译管道，并说&amp;ldquo; Hello&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="85bb4cc8874a7fe78368b1f43fbe3cade8bd0615" translate="yes" xml:space="preserve">
          <source>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), &lt;em&gt;except&lt;/em&gt;&lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;, which really behave differently for the newtype and its representation.</source>
          <target state="translated">扩展的结果是，&lt;em&gt;除了&lt;/em&gt; &lt;code&gt;Show&lt;/code&gt; 和 &lt;code&gt;Read&lt;/code&gt; &lt;em&gt;之外&lt;/em&gt;，对newtype声明中的所有派生实例均进行了统一处理（并且仅通过重用表示类型的字典来实现），&lt;em&gt;但&lt;/em&gt;Show和Read的行为实际上对newtype及其表示形式有所不同。</target>
        </trans-unit>
        <trans-unit id="b46bedb78774bd2cc4f8ff31c4366eaf33f5bd61" translate="yes" xml:space="preserve">
          <source>As a result, it requires approximately twice as much memory as its result to construct its result. For files more than a half of available RAM in size, this may result in memory exhaustion.</source>
          <target state="translated">因此,它所需要的内存大约是其结果的两倍,以构造其结果。对于大小超过可用内存一半的文件,可能导致内存耗尽。</target>
        </trans-unit>
        <trans-unit id="6e9d8d378558658c4bde3d6e6c2d01732f382a26" translate="yes" xml:space="preserve">
          <source>As a simple example of an encoding implementation, we show how to efficiently convert the following representation of mixed-data tables to an UTF-8 encoded Comma-Separated-Values (CSV) table.</source>
          <target state="translated">作为一个简单的编码实现的例子,我们展示了如何有效地将以下混合数据表的表示方式转换为UTF-8编码的逗号分隔值(CSV)表。</target>
        </trans-unit>
        <trans-unit id="ca12c18463b6879d5a860720c0092cdccee7f627" translate="yes" xml:space="preserve">
          <source>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</source>
          <target state="translated">由于一个额外的约束通配符足以推断出任何数量的约束,所以在类型签名中只允许有一个,而且它应该在约束列表中排在最后。</target>
        </trans-unit>
        <trans-unit id="ba8ae9d2e67cab36cf8dbfe80e256d78b5863ef7" translate="yes" xml:space="preserve">
          <source>As a workaround, we allow to bind &lt;code&gt;(*)&lt;/code&gt; in prefix form:</source>
          <target state="translated">解决方法是，我们允许以前缀形式绑定 &lt;code&gt;(*)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b52875799ff2828c6eeb24db51f51ce6b5d35654" translate="yes" xml:space="preserve">
          <source>As always, for RTS options that take ⟨size⟩s: If the last character of ⟨size⟩ is a K or k, multiply by 1000; if an M or m, by 1,000,000; if a G or G, by 1,000,000,000. (And any wraparound in the counters is &lt;em&gt;your&lt;/em&gt; fault!)</source>
          <target state="translated">与往常一样，对于采用TSsize⟩s的RTS选项：如果⟨size⟩的最后一个字符是K或k，则乘以1000。如果是M或m，则减1,000,000；如果是G或G，则为1,000,000,000。（而且计数器中的任何环绕都是&lt;em&gt;您的&lt;/em&gt;错！）</target>
        </trans-unit>
        <trans-unit id="99567f4b6e834794323885b782256cd2c328ea5e" translate="yes" xml:space="preserve">
          <source>As always, type synonyms must be fully applied. You cannot, for example, write:</source>
          <target state="translated">一如既往,类型同义词必须完全应用。例如,你不能写。</target>
        </trans-unit>
        <trans-unit id="13c3594421b98bd2bf10cd954eb77cee53d78c7c" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a64b93c54367f32283d34b8466c83c540d04226" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作为一个 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不是一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 绕过错误的处理 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，不能被截获 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;prelude&quot;&gt;前奏&lt;/a&gt;。但是，这是 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; ，可以使用&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;函数进行捕获。这意味着添加到 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 中的清除计算（来自&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;）也可以在 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 上正确执行。</target>
        </trans-unit>
        <trans-unit id="7a4cafca22cd8d1a307b13e29242f4d26666e5a9" translate="yes" xml:space="preserve">
          <source>As an example of signaling an error in the error monad &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, consider a safe division function &lt;code&gt;safeDiv x y&lt;/code&gt; that returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the denominator &lt;code&gt;y&lt;/code&gt; is zero and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div`
 y)&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">由于信号在错误的错误的一个例子单子 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; ，考虑安全部门的功能 &lt;code&gt;safeDiv x y&lt;/code&gt; 回返 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 当分母 &lt;code&gt;y&lt;/code&gt; 为零， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div` y)&lt;/code&gt; 除外。例如：</target>
        </trans-unit>
        <trans-unit id="c06e5fe5eaba60d194f35398d388c5324d3e8468" translate="yes" xml:space="preserve">
          <source>As an example which does &lt;em&gt;not&lt;/em&gt; work, consider</source>
          <target state="translated">作为做一个例子&lt;em&gt;不&lt;/em&gt;工作，考虑</target>
        </trans-unit>
        <trans-unit id="6347b158715a28dac26c8c73ed1a2953999b56f9" translate="yes" xml:space="preserve">
          <source>As an example, consider a simple pretty-printer class &lt;code&gt;SPretty&lt;/code&gt;, which outputs pretty strings:</source>
          <target state="translated">例如，考虑一个简单的漂亮打印机类 &lt;code&gt;SPretty&lt;/code&gt; ，它输出漂亮的字符串：</target>
        </trans-unit>
        <trans-unit id="522dfa47c182924ecba88bb21606211e4b6f02fd" translate="yes" xml:space="preserve">
          <source>As an example, consider the following pipeline:</source>
          <target state="translated">举个例子,考虑以下管道。</target>
        </trans-unit>
        <trans-unit id="42d246ca4c667eae440bdea085741dec65a2d440" translate="yes" xml:space="preserve">
          <source>As an example, consider the type of predicate functions &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt;. One such predicate might be &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt;, which classifies integers as to whether they are negative. However, given this predicate, we can re-use it in other situations, providing we have a way to map values &lt;em&gt;to&lt;/em&gt; integers. For instance, we can use the &lt;code&gt;negative&lt;/code&gt; predicate on a person's bank balance to work out if they are currently overdrawn:</source>
          <target state="translated">例如，考虑谓词函数 &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; 的类型。一个这样的谓词可能是 &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt; ，它对整数是否为负数进行了分类。但是，有了这个谓词，只要我们有一种将值映射&lt;em&gt;到&lt;/em&gt;整数的方法，我们就可以在其他情况下重用它。例如，我们可以使用某人的银行余额上的 &lt;code&gt;negative&lt;/code&gt; 谓词来计算当前是否透支了：</target>
        </trans-unit>
        <trans-unit id="9c76375fc08b8bec18373864d63325042996901b" translate="yes" xml:space="preserve">
          <source>As an example, in order to load the plugin exported by &lt;code&gt;Foo.Plugin&lt;/code&gt; in the package &lt;code&gt;foo-ghc-plugin&lt;/code&gt;, and give it the parameter &amp;ldquo;baz&amp;rdquo;, we would invoke GHC like this:</source>
          <target state="translated">例如，为了将 &lt;code&gt;Foo.Plugin&lt;/code&gt; 导出的插件加载到 &lt;code&gt;foo-ghc-plugin&lt;/code&gt; 包中，并为其指定参数&amp;ldquo; baz&amp;rdquo;，我们将像这样调用GHC：</target>
        </trans-unit>
        <trans-unit id="362dc967d86ad4ea9a7d9c73fea6acc2cbd89dbf" translate="yes" xml:space="preserve">
          <source>As an example, let us look at a function &lt;code&gt;encode&lt;/code&gt; that produces a naive, but lossless bit encoding of values of various datatypes. So we are aiming to define a function</source>
          <target state="translated">举个例子，让我们看一个函数 &lt;code&gt;encode&lt;/code&gt; ，它产生各种数据类型的值的幼稚但无损的位编码。因此，我们旨在定义一个功能</target>
        </trans-unit>
        <trans-unit id="33852151126c630432f1fdab8e0ba978ca5481a5" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted &lt;code&gt;IO&lt;/code&gt; monad that we have defined. The restricted &lt;code&gt;IO&lt;/code&gt; monad will only allow a safe subset of &lt;code&gt;IO&lt;/code&gt; actions to be executed. We define the plugin interface so that it requires the plugin module, &lt;code&gt;Danger&lt;/code&gt;, to export a single computation, &lt;code&gt;Danger.runMe&lt;/code&gt;, of type &lt;code&gt;RIO ()&lt;/code&gt;, where &lt;code&gt;RIO&lt;/code&gt; is a monad defined as follows:</source>
          <target state="translated">例如，让我们为插件系统定义一个接口，在该接口上插件作者不受信任，并且可能是恶意的第三方。为此，我们将插件接口限制为纯函数或已定义的受限 &lt;code&gt;IO&lt;/code&gt; monad。受限的 &lt;code&gt;IO&lt;/code&gt; monad将仅允许执行 &lt;code&gt;IO&lt;/code&gt; 操作的安全子集。我们定义插件接口，以便它需要插件模块 &lt;code&gt;Danger&lt;/code&gt; 导出类型为 &lt;code&gt;RIO ()&lt;/code&gt; 的单个计算 &lt;code&gt;Danger.runMe&lt;/code&gt; ，其中 &lt;code&gt;RIO&lt;/code&gt; 是monad，定义如下：</target>
        </trans-unit>
        <trans-unit id="70582809de8cd9e89c6a9bd154c02621c8e3fe1c" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have following special printing module:</source>
          <target state="translated">举个例子,假设我们有以下特殊的打印模块。</target>
        </trans-unit>
        <trans-unit id="6adf45b29a6631ff6d424f3a35e51b0c62f84184" translate="yes" xml:space="preserve">
          <source>As an example, suppose you read a large string, of which you need only a small portion. If you do not use &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt;, the entire original array will be kept alive in memory by the smaller string. Making a copy &quot;breaks the link&quot; to the original array, allowing it to be garbage collected if there are no other live references to it.</source>
          <target state="translated">例如，假设您读取了一个大字符串，而只需要一小部分。如果不使用 &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt; ，则整个原始数组将通过较小的字符串保留在内存中。复制后，将&amp;ldquo;断开链接&amp;rdquo;到原始数组，如果没有其他实时引用，则可以对其进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="d63ea3a1b75b9abed859b37118efd2bdfeda9979" translate="yes" xml:space="preserve">
          <source>As an example, this data declaration:</source>
          <target state="translated">举个例子,这个数据声明:</target>
        </trans-unit>
        <trans-unit id="490082850527086dedfac3775659ee1738c0ae5d" translate="yes" xml:space="preserve">
          <source>As another example, this is the layout for the unboxed version of &lt;code&gt;Maybe a&lt;/code&gt; type, &lt;code&gt;(# (# #) | a #)&lt;/code&gt;:</source>
          <target state="translated">再举一个例子，这是未装箱的 &lt;code&gt;Maybe a&lt;/code&gt; 类型 &lt;code&gt;(# (# #) | a #)&lt;/code&gt; 的布局：</target>
        </trans-unit>
        <trans-unit id="18151bc795d27e140f421a3a96b2c553b0826f0d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">再举一个例子，我们可以考虑一个类型 &lt;code&gt;Set a&lt;/code&gt; 表示一组数据，下令根据 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;Ord&lt;/code&gt; 实例。虽然这将通常是类型安全的考虑 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，有可能是一个 &lt;code&gt;newtype&lt;/code&gt; 且其基本类型有&lt;em&gt;不同的&lt;/em&gt;在各自的编码排序 &lt;code&gt;Ord&lt;/code&gt; 实例。这将导致运行时行为异常。因此， &lt;code&gt;Set&lt;/code&gt; 数据类型的作者希望其参数处于标称角色。这将通过声明来完成</target>
        </trans-unit>
        <trans-unit id="9e081e131ffbc4e13afc7b95b1192b51f216cb4d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971f3c8e7fa04aa11b176990e12b0d8a905825b5" translate="yes" xml:space="preserve">
          <source>As before, only one selector function is generated here, that for &lt;code&gt;tag&lt;/code&gt;. Nevertheless, you can still use all the field names in pattern matching and record construction.</source>
          <target state="translated">和以前一样，这里仅生成一个选择器函数，即 &lt;code&gt;tag&lt;/code&gt; 的选择器函数。但是，您仍然可以在模式匹配和记录构造中使用所有字段名称。</target>
        </trans-unit>
        <trans-unit id="1b294469f3600688f3c16a9375ab450bd92e329f" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;rts&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; package. The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">和以前一样，&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志指定该库链接到 &lt;code&gt;rts&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 软件包的共享库版本。所述&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;标志是必需的所有的代码，将在一个共享库中结束。该&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;标志指定作共享库，而不是一个项目。为了使这一点更清楚，我们可以将其分解为单独的编译和链接步骤：</target>
        </trans-unit>
        <trans-unit id="7075fa9b7f0c6ece6ef586ef8232718a3c4e1adf" translate="yes" xml:space="preserve">
          <source>As channels, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as receive and send, and</source>
          <target state="translated">作为通道，将 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 用作接收和发送，并且</target>
        </trans-unit>
        <trans-unit id="5f8a308216057de51dc8e2d87492c599832235ef" translate="yes" xml:space="preserve">
          <source>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-x ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">如上所述，GHC处理文件的方式取决于其后缀。可以使用&lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-x ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;选项覆盖此行为：</target>
        </trans-unit>
        <trans-unit id="ac41a6f7a2ba794206a1881f72e83bfc76ecc4c5" translate="yes" xml:space="preserve">
          <source>As discussed earlier, use &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to disambiguate GHC flags when needed. For example, &lt;code&gt;-f&lt;/code&gt; is recognized by runghc, therefore to pass &lt;code&gt;-fliberate-case&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">如前所述，在需要时使用 &lt;code&gt;--&lt;/code&gt; 或 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 消除GHC标志的歧义。例如， &lt;code&gt;-f&lt;/code&gt; 被runghc识别，因此要使用 &lt;code&gt;-fliberate-case&lt;/code&gt; 传递给GHC，请使用以下任一命令：</target>
        </trans-unit>
        <trans-unit id="fe90224af19846dad1a17ef9f898f327403d732c" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;ByteStrings&lt;/code&gt; that are slices of the original.</source>
          <target state="translated">至于此库中的所有拆分功能，此功能均不复制子字符串，而只是构造作为原始片段的新 &lt;code&gt;ByteStrings&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66418d326af7c7178dbcf345c383fa758cb34200" translate="yes" xml:space="preserve">
          <source>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</source>
          <target state="translated">至于类型签名,隐式量化也会发生在非过载类型上。所以,如果你这样写。</target>
        </trans-unit>
        <trans-unit id="131c4ed80f84ad7adaad005b0b251d5561f2e9bd" translate="yes" xml:space="preserve">
          <source>As iconv is missing in some minimal environments (e.g. #10298), this checks to ensure that iconv is working properly before returning the encoding, returning &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">由于iconv在某些最小环境（例如＃10298）中丢失，因此将检查以确保iconv在返回编码之前正常工作，否则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a094fb6c3fac4ea42a5b01e068a43a07a1612b8" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#define&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">好像在源代码中放置了适当的 &lt;code&gt;#define&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="0b3a2a9b0861349d1000eb5c63f5fe83939ea7af" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#include&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">好像在源代码中放置了适当的 &lt;code&gt;#include&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="beaf430a25d7c8a7463fc714eeb5bef652c1ca18" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3704be0b1f85ea495e4739ed1a37ef32e604634f" translate="yes" xml:space="preserve">
          <source>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of &amp;ldquo;acyclic&amp;rdquo; involves only the superclass relationships. For example, this is okay:</source>
          <target state="translated">与Haskell 98中一样，类层次结构必须是非循环的。但是，&amp;ldquo;非循环&amp;rdquo;的定义仅涉及超类关系。例如，这可以：</target>
        </trans-unit>
        <trans-unit id="a18ecf9c948be4e27d139d19b812430b86052cfe" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">与使用类似Haskell-98的记录语法（&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;）声明的存在性一样，记录选择器功能仅针对具有类型正确的选择器的字段生成。这是该部分的示例，采用GADT样式的语法：</target>
        </trans-unit>
        <trans-unit id="e3cd19795acf719bdbdadfeb240558bb97933bfa" translate="yes" xml:space="preserve">
          <source>As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b688c040bfb0b19971fb0ce773edf49cba5c5c6c" translate="yes" xml:space="preserve">
          <source>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</source>
          <target state="translated">只要一个类型变量受到这些类中的一个类的约束,就会发生默认,如上所述。</target>
        </trans-unit>
        <trans-unit id="44161a74606a6af43d39c349f3c26f8c14875c50" translate="yes" xml:space="preserve">
          <source>As long as you are happy to only be able to link to the DLL using &lt;code&gt;GetProcAddress&lt;/code&gt; and friends, you can supply the &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt;&lt;code&gt;-fno-shared-implib&lt;/code&gt;&lt;/a&gt; flag to disable the creation of the import library entirely.</source>
          <target state="translated">只要您很高兴只能使用 &lt;code&gt;GetProcAddress&lt;/code&gt; 和好友链接到DLL ，就可以提供&lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt; &lt;code&gt;-fno-shared-implib&lt;/code&gt; &lt;/a&gt;标志以完全禁用导入库的创建。</target>
        </trans-unit>
        <trans-unit id="2e315249f68fda8aaff176e296d66a05a6132ca0" translate="yes" xml:space="preserve">
          <source>As mapFile, but returns ByteString</source>
          <target state="translated">作为mapFile,但返回ByteString</target>
        </trans-unit>
        <trans-unit id="a545221512e878619258ca5f17df48cfac240523" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="6e1afd64bce824d5669c2abf1ae7f5ca39a54331" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="6a668f275f9aa656c990c93f68c69e117d56a6a9" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">如上所述，GHC中派生的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例将实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （及其表亲 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）的默认实现将仅在内部使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 。如果您是手工编写一个 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例，建议这样写：</target>
        </trans-unit>
        <trans-unit id="f65b46df8fe6c264c596a4ee57c977d2fcd44935" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">如在&lt;a href=&quot;#gadt-style&quot;&gt;使用显式构造函数签名声明数据类型中&lt;/a&gt;所述，支持记录语法。例如：</target>
        </trans-unit>
        <trans-unit id="2b20aa3bf540201cc843068062611e2c68e78f44" translate="yes" xml:space="preserve">
          <source>As of 1.3.5.0, the environment variable is ignored if set to a relative path, per revised XDG Base Directory Specification. See &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;#100&lt;/a&gt;.</source>
          <target state="translated">从1.3.5.0版本开始，根据修订的XDG基本目录规范，如果将环境变量设置为相对路径，则将忽略该变量。参见&lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;＃100&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66155d480946b24160dbc04cb1009ec185e9eb15" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d54fac1ed5477bc40ff0f48a11003303f605712" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68bb1e4d347f7e14f0730566cfe86c41cf0cf621" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; 已替换为 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="431c3d0f7612a40f6ff5eb1278e282741242a19d" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 开始， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; 已由 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt; 取代。</target>
        </trans-unit>
        <trans-unit id="ff725c4e2000e4c32e7a70322b85a55a85f4f248" translate="yes" xml:space="preserve">
          <source>As of GHC version 6.8, we have adopted the following policy for numbering GHC versions:</source>
          <target state="translated">从GHC 6.8版本开始,我们对GHC版本的编号采取了以下政策。</target>
        </trans-unit>
        <trans-unit id="6667e67a30d7295682c9410cb1e7f0f855d9f77a" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="189b02d51b70039f2bb98397c33331f99f38f72e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ffe502c088313295fc8544881ef2e7de642be25" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4755017eb545075e257326e642258214d89957c4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be1d09e17e8e02c7031393483495ad5d61f69b4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f37649ade650085aa0f65cecdda074623b0b69e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="995d3e4e58500aa9b1bd3701177a6dbe6d9b1cb8" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; ，专门用于 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0137e920b69fe62239fad821757f41940234bff2" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63452b7c7f465acb4dded12e10643c0a80c59e1c" translate="yes" xml:space="preserve">
          <source>As of bytestring 0.9.0.3, this function is stricter than its list cousin.</source>
          <target state="translated">从bytestring 0.9.0.3开始,这个函数比它的表兄弟list更加严格。</target>
        </trans-unit>
        <trans-unit id="039bbe9675865514fb60ebed364f1df32b98df77" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; data structures, which have one variety of element on which an action can be performed, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; data structures have two such varieties of elements.</source>
          <target state="translated">相对于 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 的数据结构，其具有一个品种在其上可以执行的动作元件， &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 数据结构具有两个这样的品种元件。</target>
        </trans-unit>
        <trans-unit id="1ae607bddf78967e412e95f44ed5f98b62257887" translate="yes" xml:space="preserve">
          <source>As part of the same extension, you can put kind annotations in types as well. Thus:</source>
          <target state="translated">作为同一扩展的一部分,你也可以在类型中加入种类注释。因此:</target>
        </trans-unit>
        <trans-unit id="7699c90ab29019673b3fd8db1b1767ae9771115b" translate="yes" xml:space="preserve">
          <source>As soon as GHC plus its &amp;ldquo;fellow citizens&amp;rdquo; (other processes on your machine) start using more than the &lt;em&gt;real memory&lt;/em&gt; on your machine, and the machine starts &amp;ldquo;thrashing,&amp;rdquo; &lt;em&gt;the party is over&lt;/em&gt;. Compile times will be worse than terrible! Use something like the csh builtin &lt;strong&gt;time&lt;/strong&gt; command to get a report on how many page faults you&amp;rsquo;re getting.</source>
          <target state="translated">一旦GHC及其&amp;ldquo;同胞&amp;rdquo;（计算机上的其他进程）开始使用的&lt;em&gt;内存&lt;/em&gt;超过了&lt;em&gt;计算机&lt;/em&gt;上的&lt;em&gt;实际内存&lt;/em&gt;，并且计算机开始&amp;ldquo;崩溃&amp;rdquo;，&lt;em&gt;则聚会结束了&lt;/em&gt;。编译时间将比可怕的还要糟糕！使用csh Builtin &lt;strong&gt;time&lt;/strong&gt;命令之类的内容获取有关您遇到的页面错误的报告。</target>
        </trans-unit>
        <trans-unit id="5c65dae701ef99ffffbad1ccc118a5d026621cac" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;purePlugin&lt;/code&gt; is defined as a function which always returns &lt;code&gt;NoForceRecompile&lt;/code&gt;.</source>
          <target state="translated">这样， &lt;code&gt;purePlugin&lt;/code&gt; 被定义为始终返回 &lt;code&gt;NoForceRecompile&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="83c27882ec4f84c2b1c7547fee6d29bef6299680" translate="yes" xml:space="preserve">
          <source>As synchronized mutable variables,</source>
          <target state="translated">作为同步可变的变量。</target>
        </trans-unit>
        <trans-unit id="8c68344402c4c848cd9948b1b997a6cdee8b6472" translate="yes" xml:space="preserve">
          <source>As text to standard output, for debugging purposes.</source>
          <target state="translated">作为标准输出的文本,用于调试。</target>
        </trans-unit>
        <trans-unit id="181b02f4903ccd97fffcaf58addb10482aefc450" translate="yes" xml:space="preserve">
          <source>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; above would be valid field type signatures.</source>
          <target state="translated">作为数据类型声明中的构造函数的参数或字段的类型。例如，上面的 &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; 任何一个都是有效的字段类型签名。</target>
        </trans-unit>
        <trans-unit id="2c75efee694fce1348012a0f71a5ff8152fe1dea" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">由于双 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;noneOf cs&lt;/code&gt; 成功，如果当前字符&lt;em&gt;不&lt;/em&gt;中的字符提供的一系列 &lt;code&gt;cs&lt;/code&gt; 。返回已解析的字符。</target>
        </trans-unit>
        <trans-unit id="ccb0b2bddb73f4bc8b6273e372d5253cba90fe8b" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">由于双 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;noneOf cs&lt;/code&gt; 成功，如果当前字符&lt;em&gt;不&lt;/em&gt;中的字符提供的一系列 &lt;code&gt;cs&lt;/code&gt; 。返回已解析的字符。</target>
        </trans-unit>
        <trans-unit id="595d79d9d63a7ad5c2be3b061e3dc58b00a5d260" translate="yes" xml:space="preserve">
          <source>As the type of an implicit parameter</source>
          <target state="translated">作为一个隐性参数的类型</target>
        </trans-unit>
        <trans-unit id="d153cbf6806b7b35bd0413a66f8a99b8d11cec38" translate="yes" xml:space="preserve">
          <source>As this suggests, each occurrence is replaced exactly once. So if &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;replacement&lt;/code&gt;, that occurrence will &lt;em&gt;not&lt;/em&gt; itself be replaced recursively:</source>
          <target state="translated">如此暗示，每个事件被完全替换一次。因此，如果 &lt;code&gt;needle&lt;/code&gt; 在 &lt;code&gt;replacement&lt;/code&gt; 中发生，那么该事件本身将&lt;em&gt;不会&lt;/em&gt;被递归替换：</target>
        </trans-unit>
        <trans-unit id="e53867775e4428028623be9fceee714ed0171be0" translate="yes" xml:space="preserve">
          <source>As usual, for every constructor that has a field &lt;code&gt;f&lt;/code&gt;, the type of field &lt;code&gt;f&lt;/code&gt; must be the same (modulo alpha conversion). The &lt;code&gt;Child&lt;/code&gt; constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the &amp;ldquo;type&amp;rdquo; that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A &amp;ldquo;type&amp;rdquo; of this form can appear only in a constructor signature.)</source>
          <target state="translated">与往常一样，对于具有字段每一个构造 &lt;code&gt;f&lt;/code&gt; ，字段的类型 &lt;code&gt;f&lt;/code&gt; 必须是相同的（模&amp;alpha;-转化）。上面的 &lt;code&gt;Child&lt;/code&gt; 构造函数表明，签名可以具有上下文，存在量化的变量和严格性注释，就像在非记录情况下一样。（注意：由于记录的语法和严格性的注解，双冒号后面的&amp;ldquo;类型&amp;rdquo;实际上不是一种类型。这种形式的&amp;ldquo;类型&amp;rdquo;只能出现在构造函数签名中。）</target>
        </trans-unit>
        <trans-unit id="424c7f952d5ac1aa74645c5f27a67eda13f56e6f" translate="yes" xml:space="preserve">
          <source>As usual, the meta-variables &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc., can be arbitrary patterns. In general, the statement &lt;code&gt;rec ss&lt;/code&gt; is desugared to the statement</source>
          <target state="translated">像往常一样，元变量 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 等可以是任意模式。一般而言，语句 &lt;code&gt;rec ss&lt;/code&gt; 取代了该语句</target>
        </trans-unit>
        <trans-unit id="3cf1bb90d2a6c5267034d92cb3db4ce82d1bfdff" translate="yes" xml:space="preserve">
          <source>As we demonstrated earlier (&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt;), the debugger has some intelligence built-in to update the type of &lt;code&gt;f&lt;/code&gt; whenever the types of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;_result&lt;/code&gt; are discovered. So what we do in this scenario is force &lt;code&gt;x&lt;/code&gt; a bit, in order to recover both its type and the argument part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">正如我们之前所演示的（&lt;a href=&quot;#breakpoints&quot;&gt;断点和检查变量&lt;/a&gt;），调试器具有一些内置的智能功能，可以在发现 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;_result&lt;/code&gt; 类型时更新 &lt;code&gt;f&lt;/code&gt; 的类型。因此，在这种情况下，我们要做的是稍微施加力 &lt;code&gt;x&lt;/code&gt; ，以便同时恢复其类型和 &lt;code&gt;f&lt;/code&gt; 的自变量部分。</target>
        </trans-unit>
        <trans-unit id="480449ae21e88b5153c176f83519328d5843ab58" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the &lt;code&gt;ArrowPlus&lt;/code&gt; class includes a combinator</source>
          <target state="translated">正如我们所看到的，箭头表示法提供了以表达式，顺序，值递归和条件为基础的构造模型。但是，您可以在普通的Haskell中定义的合适组合器也可以用于从现有命令中构建新命令。基本思想是命令定义从环境到值的箭头。这些环境将值分配给命令的可用局部变量。因此，从箭头产生箭头的组合器也可以用于从命令构建命令。例如， &lt;code&gt;ArrowPlus&lt;/code&gt; 类包含一个组合器</target>
        </trans-unit>
        <trans-unit id="196191205f2b62c541cf8a5ff3836b4bc01787da" translate="yes" xml:space="preserve">
          <source>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</source>
          <target state="translated">以及避免不必要的模式匹配,它还有助于避免不必要的分配。这适用于当一个参数在递归调用自身时是严格的,但在初始条目上不是。由于严格递归函数的分支被创建,类似于上面的例子。</target>
        </trans-unit>
        <trans-unit id="8c16e4471532afea529c20b4ff2e8a8a16601be0" translate="yes" xml:space="preserve">
          <source>As well in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">除了类型签名，您还可以在实例声明中使用显式的 &lt;code&gt;forall&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ead26c4f8d8b65c7691881f1d8045e494c57debb" translate="yes" xml:space="preserve">
          <source>As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</source>
          <target state="translated">与所有已知的Haskell系统一样,GHC实现了对标准Haskell语言的一些扩展。它们都可以通过命令行标志或语言语法来启用或禁用。默认情况下,GHC能理解它所支持的最新的Haskell版本,加上一些扩展。</target>
        </trans-unit>
        <trans-unit id="fcd43e9a7f0adbd4e1cdcb63a469dbf86f84b840" translate="yes" xml:space="preserve">
          <source>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there&amp;rsquo;s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</source>
          <target state="translated">与普通变量绑定一样，后面的定义会覆盖前面的定义，因此您可以重新输入声明以解决该问题或扩展它。但是有一个陷阱：当新的类型声明遮盖了旧的类型声明时，可能还有其他引用旧类型的声明。要记住的是，旧类型仍然存在，而这些其他声明仍然引用旧类型。但是，尽管新旧类型具有相同的名称，但是GHCi会将它们区别对待。例如：</target>
        </trans-unit>
        <trans-unit id="637fa52fc6437e00230d9db2fe6b3adca8d89276" translate="yes" xml:space="preserve">
          <source>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;:</source>
          <target state="translated">与其他类型签名一样，您可以为多个数据构造函数提供一个签名。在此示例中，我们为 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 提供一个签名：</target>
        </trans-unit>
        <trans-unit id="9a5d0276624512bf5b98fc03c361aa6bea31b80c" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; function, if any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 函数一样，如果列表中的任何两个关联具有相同的索引，则该索引处的值取决于实现。（在GHC中，使用为该索引指定的最后一个值。其他实现也将对未装箱的数组执行此操作，但是Haskell 98要求对于 &lt;code&gt;Array&lt;/code&gt; ，此类索引处的值应为底部。）</target>
        </trans-unit>
        <trans-unit id="290e57760e517898d7b9efcc098bc5d22f645f5f" translate="yes" xml:space="preserve">
          <source>As you can guess &lt;code&gt;justOnes&lt;/code&gt; will evaluate to &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt;.</source>
          <target state="translated">正如您可以猜到 &lt;code&gt;justOnes&lt;/code&gt; 将评估为 &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44e503436bbd1b51c2f4671a6a4bc6e7cfdbb40d" translate="yes" xml:space="preserve">
          <source>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</source>
          <target state="translated">正如你所看到的,以这种方式使用运算符并不是很有用,Haskell 98甚至不允许你写它们的infix。</target>
        </trans-unit>
        <trans-unit id="67dc44d97f00c988807bcf67aa9d1c8f84fff7c6" translate="yes" xml:space="preserve">
          <source>Ascii Drawings</source>
          <target state="translated">Ascii 图纸</target>
        </trans-unit>
        <trans-unit id="cca21e0df87aca3b913734b67e2e333b718bae99" translate="yes" xml:space="preserve">
          <source>Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</source>
          <target state="translated">阿什莉&amp;middot;亚克利&amp;lt;ashley@semantic.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7f327535400c99b415e9d1ddaa6d9904d1bfafa2" translate="yes" xml:space="preserve">
          <source>Ask that GHC specialize a polymorphic value to a particular type.</source>
          <target state="translated">要求GHC将一个多态值特殊化为一个特定的类型。</target>
        </trans-unit>
        <trans-unit id="bc24cd3c8b6ddb112a336c5966d0506d3b2fd9ca" translate="yes" xml:space="preserve">
          <source>Assembly language (.s)</source>
          <target state="translated">汇编语言(.s)</target>
        </trans-unit>
        <trans-unit id="d8e00d7a54a273c595978f5b3e92d75c8e0981a9" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">可以捕获断言失败，有关详细信息，请参见&lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;库的文档。</target>
        </trans-unit>
        <trans-unit id="cde31a8393d46785fc228979a73996dac43391ba" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74319d6a5a4eb02ecd1401e7a9faed7d9660ea69" translate="yes" xml:space="preserve">
          <source>AssertionFailed</source>
          <target state="translated">AssertionFailed</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e8ddc914ca09e8e31648b53bc077284126a4cbdc" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">断言通常可以使用编译器标志打开或关闭（对于GHC，除非使用 &lt;code&gt;-O&lt;/code&gt; 打开优化或给出 &lt;code&gt;-fignore-asserts&lt;/code&gt; 选项，否则断言通常处于打开状态）。当断言关闭时， &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 的第一个参数将被忽略，而第二个参数将作为结果返回。</target>
        </trans-unit>
        <trans-unit id="492da7da6121915584e059d74109845fdbc2bb99" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">断言通常可以使用编译器标志打开或关闭（对于GHC，除非使用 &lt;code&gt;-O&lt;/code&gt; 打开优化或给出 &lt;code&gt;-fignore-asserts&lt;/code&gt; 选项，否则断言通常处于打开状态）。当断言关闭时， &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 的第一个参数将被忽略，而第二个参数将作为结果返回。</target>
        </trans-unit>
        <trans-unit id="2a67c621ce56962ea20451247e4968660972fdfe" translate="yes" xml:space="preserve">
          <source>Assoc</source>
          <target state="translated">Assoc</target>
        </trans-unit>
        <trans-unit id="68b22545bb595a6b43f06bac583241d8e11a31a0" translate="yes" xml:space="preserve">
          <source>AssocLeft</source>
          <target state="translated">AssocLeft</target>
        </trans-unit>
        <trans-unit id="aa2f28d5f211bc5ecef78542598f880f8e318baa" translate="yes" xml:space="preserve">
          <source>AssocNone</source>
          <target state="translated">AssocNone</target>
        </trans-unit>
        <trans-unit id="56894dfcf0b1ff176191c0989a9045db04e81fe2" translate="yes" xml:space="preserve">
          <source>AssocRight</source>
          <target state="translated">AssocRight</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">相关类型</target>
        </trans-unit>
        <trans-unit id="28d556f025319f64419ff88734b119ab1b87004b" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">关联的类型和数据实例声明不继承在封闭实例上指定的任何上下文。对于类型实例声明，尚不清楚上下文的含义。对于数据实例声明，用户不太可能希望为每个数据构造函数重复上下文。上下文可能有用的唯一地方是关联数据实例的 &lt;code&gt;deriving&lt;/code&gt; 子句。但是，即使在这里，外部实例上下文的角色也是模糊的。因此，为清楚起见，我们只是遵循上述规则：封闭的实例上下文被忽略。如果需要在派生实例上使用非平凡上下文，请使用&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt;子句（在顶层）。</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="1c3f48563bf3394a3a3f951813cae0818e684494" translate="yes" xml:space="preserve">
          <source>Associativity is not used to reduce the occurrence of parentheses, although precedence may be.</source>
          <target state="translated">联想性并不是用来减少小括号的出现,尽管优先性可能是。</target>
        </trans-unit>
        <trans-unit id="6b99ff8f8291b4b50e3921986b0bce0e781dbc7e" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; to write a very simple error-reporting function that does absolutely nothing in the case of success, and outputs &quot;ERROR&quot; if any error occurred.</source>
          <target state="translated">假设 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值表示某种错误，我们可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 编写一个非常简单的错误报告功能，在成功的情况下绝对不执行任何操作，如果发生任何错误，则输出&amp;ldquo; ERROR&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d055592ad02200007ba459bbee0ab4e26e918369" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; to write a very simple reporting function that only outputs &quot;SUCCESS&quot; when a computation has succeeded.</source>
          <target state="translated">假设 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值表示某种错误，我们可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 编写一个非常简单的报告函数，该函数仅在计算成功后才输出&amp;ldquo; SUCCESS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1c834581788562362bcf330136a30982991522f6" translate="yes" xml:space="preserve">
          <source>Assumption: Integer is strictly positive</source>
          <target state="translated">假设。整数是严格的正数</target>
        </trans-unit>
        <trans-unit id="77fd17f027574bb2f7df35f4ef90ead2e9b60836" translate="yes" xml:space="preserve">
          <source>AsyncException</source>
          <target state="translated">AsyncException</target>
        </trans-unit>
        <trans-unit id="603f73055272502639dd306a8bca156dc618be89" translate="yes" xml:space="preserve">
          <source>AsyncIOAvailable</source>
          <target state="translated">AsyncIOAvailable</target>
        </trans-unit>
        <trans-unit id="e1aac0f84af1ee48fafd058955607776e453cc9b" translate="yes" xml:space="preserve">
          <source>Asynchronous Exceptions</source>
          <target state="translated">异步异常</target>
        </trans-unit>
        <trans-unit id="1fde34ce4b1dca7f44eebcbaf7ae6171e5ddd42a" translate="yes" xml:space="preserve">
          <source>Asynchronous exception control</source>
          <target state="translated">异步异常控制</target>
        </trans-unit>
        <trans-unit id="90e8f43c2f265d7e22350697496f72118afa53f2" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; are two examples of system-generated asynchronous exceptions.</source>
          <target state="translated">异步异常之所以被称为是因为它们是由外部影响引起的，并且可以在执行过程中的任何时候引发。 &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; 是系统生成的异步异常的两个示例。</target>
        </trans-unit>
        <trans-unit id="e9087c26270e45969905025ed0c6876268b8e459" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则处于被屏蔽状态时仍可能接收异步异常。请参见&lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="303a11aed286b513643b565c89072a6a7aa3770b" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6f92d83ff3d5f34604121aadc15840ac708368" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">如果被屏蔽的线程以某些方式&lt;em&gt;阻塞&lt;/em&gt;，则处于被屏蔽状态时仍可能接收异步异常。请参见&lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="631cd36315ff03e677e0243fa4a94f4335edad65" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions.</source>
          <target state="translated">异步异常。</target>
        </trans-unit>
        <trans-unit id="de23bf55d43f3cb1369402e7877d3faa61f2949f" translate="yes" xml:space="preserve">
          <source>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and &lt;em&gt;appends&lt;/em&gt; it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</source>
          <target state="translated">在函数调用时，GHC接收存储在被调用函数中的堆栈（对于顶层函数，该堆栈为空），然后&lt;em&gt;将&lt;/em&gt;其&lt;em&gt;追加&lt;/em&gt;到当前堆栈，而忽略与当前堆栈的前缀相同的任何前缀。</target>
        </trans-unit>
        <trans-unit id="bb19257a1286f9e500a61c5dfeacaecfe019ec79" translate="yes" xml:space="preserve">
          <source>At any time you can use the command &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt; to get a list of the modules currently loaded into GHCi:</source>
          <target state="translated">您可以随时使用命令&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;获取当前已加载到GHCi中的模块的列表：</target>
        </trans-unit>
        <trans-unit id="3461cf3addc608aea10037826585d0df504e072e" translate="yes" xml:space="preserve">
          <source>At definition site, the arity determines what inputs can be matched on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7e513d6fe875bf90b4a728f124a7f9ff012de2" translate="yes" xml:space="preserve">
          <source>At first blush, &lt;code&gt;UnEx&lt;/code&gt; seems poorly-kinded. The return kind &lt;code&gt;k&lt;/code&gt; is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of &lt;code&gt;k&lt;/code&gt;&lt;em&gt;for any&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, this is not the case. The type family &lt;code&gt;UnEx&lt;/code&gt; is a kind-indexed type family. The return kind &lt;code&gt;k&lt;/code&gt; is an implicit parameter to &lt;code&gt;UnEx&lt;/code&gt;. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</source>
          <target state="translated">乍一看， &lt;code&gt;UnEx&lt;/code&gt; 看起来很烂。参数中未提到返回类型 &lt;code&gt;k&lt;/code&gt; ，因此&lt;em&gt;对于任何&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; ，实例似乎都必须返回 &lt;code&gt;k&lt;/code&gt; 的成员。然而，这种情况并非如此。类型族 &lt;code&gt;UnEx&lt;/code&gt; 是类型索引的类型族。返回种类 &lt;code&gt;k&lt;/code&gt; 是 &lt;code&gt;UnEx&lt;/code&gt; 的隐式参数。详细的定义如下（其中隐式参数用大括号表示）：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="082a6d8510562c71bea9da704521358ac4884d2e" translate="yes" xml:space="preserve">
          <source>At least one of the classes &lt;code&gt;Ci&lt;/code&gt; is numeric.</source>
          <target state="translated">类 &lt;code&gt;Ci&lt;/code&gt; 中的至少一者是数字的。</target>
        </trans-unit>
        <trans-unit id="da4d3ab8aa4bf1c457aa64eadbb0f7599f12c862" translate="yes" xml:space="preserve">
          <source>At least one overlapped instance, &lt;code&gt;Iy&lt;/code&gt;, is both:</source>
          <target state="translated">至少有一个重叠的实例 &lt;code&gt;Iy&lt;/code&gt; 都是：</target>
        </trans-unit>
        <trans-unit id="95b0afae80408c0a928a6ff24b58dae9588bff21" translate="yes" xml:space="preserve">
          <source>At present, &lt;code&gt;-O2&lt;/code&gt; is nearly indistinguishable from &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">目前， &lt;code&gt;-O2&lt;/code&gt; 与 &lt;code&gt;-O&lt;/code&gt; 几乎没有区别。</target>
        </trans-unit>
        <trans-unit id="2d06e4b175297e1faf1e01c3741923b7d7eb11e9" translate="yes" xml:space="preserve">
          <source>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results&amp;mdash; in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of &lt;code&gt;(+)&lt;/code&gt;, for example.</source>
          <target state="translated">目前，GHC在算术方面的推理非常有限：它将仅评估算术类型函数并比较结果，就像对其他任何类型函数所做的一样。特别地，它不知道关于算术的更一般的事实，例如 &lt;code&gt;(+)&lt;/code&gt; 的可交换性和可结合性。</target>
        </trans-unit>
        <trans-unit id="14a75af6823b475d201cdaf02b67cfc7b30f5d3d" translate="yes" xml:space="preserve">
          <source>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type &lt;code&gt;TypeError&lt;/code&gt;. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</source>
          <target state="translated">在运行时，每当需要评估包含类型错误的术语时，该错误就会转换为 &lt;code&gt;TypeError&lt;/code&gt; 类型的运行时异常。请注意，在运行时会尽可能多地推迟类型错误，但是永远不会执行无效的强制，即使它们最终会导致正确的类型值。例如，给出以下代码：</target>
        </trans-unit>
        <trans-unit id="3b1e7a17deca9b74f37ec0a39800ad357611600d" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt you can also enter any top-level Haskell declaration, including &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;deriving&lt;/code&gt;, and &lt;code&gt;foreign&lt;/code&gt; declarations. For example:</source>
          <target state="translated">在GHCi提示符下，您还可以输入任何顶级Haskell声明，包括 &lt;code&gt;data&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;newtype&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;instance&lt;/code&gt; ， &lt;code&gt;deriving&lt;/code&gt; 和 &lt;code&gt;foreign&lt;/code&gt; 声明。例如：</target>
        </trans-unit>
        <trans-unit id="cd0949a6c29925c12d1d048d17633d245e1a3ebf" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt, or with GHC if the &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; flag is given, the types are instead resolved with the following method:</source>
          <target state="translated">在GHCi提示符下，或者如果给出&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;标志，则使用GHC ，而是使用以下方法解析类型：</target>
        </trans-unit>
        <trans-unit id="faae2aa7c10c0885466c17a8edd2f6d0318681f4" translate="yes" xml:space="preserve">
          <source>At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7cac97440198fcc962770e0f96df4e013c2492" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command doesn&amp;rsquo;t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; will not do what you expect.</source>
          <target state="translated">目前，&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;命令在其参数中不支持任何形式的引号：引号不会被删除，也不能用于将单词组合在一起。例如， &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; 将无法满足您的期望。</target>
        </trans-unit>
        <trans-unit id="82ba5640e0de386d6cc85d3de209bb9cdb633f12" translate="yes" xml:space="preserve">
          <source>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in &lt;code&gt;build-depends&lt;/code&gt; (which uses the conventional &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</source>
          <target state="translated">目前，在Cabal中指定对插件的依赖的唯一方法是将其放入 &lt;code&gt;build-depends&lt;/code&gt; （使用常规 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 标志）；但是，将来会有单独的字段专门指定插件依赖项。</target>
        </trans-unit>
        <trans-unit id="36f6fc6a8b5e23e239eeef3e4a0f085a44f79d37" translate="yes" xml:space="preserve">
          <source>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f078fc66826e48322f51a990469bfd247658746" translate="yes" xml:space="preserve">
          <source>Atomic blocks.</source>
          <target state="translated">原子块。</target>
        </trans-unit>
        <trans-unit id="92c10450c672866027afd2c75b1a19f1a5daa4db" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is forced.</source>
          <target state="translated">以原子方式将函数应用于 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容，并返回旧值和新值。该函数的结果是强制的。</target>
        </trans-unit>
        <trans-unit id="2e8c029e8fddf8615e7bdb4f7438b3feba64ae42" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is not forced. As this can lead to a memory leak, it is usually better to use &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式将函数应用于 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容，并返回旧值和新值。该函数的结果不是强制的。由于这可能导致内存泄漏，因此通常最好使用 &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="420f4999cbf62263237bdbe7d15cefd4576bc583" translate="yes" xml:space="preserve">
          <source>Atomically modifies the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式修改 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="5976845b8f84b952ac2fc7192f0a75f69d2927f0" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以原子方式读取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的内容。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 当前为空，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 将等待直到其满为止。保证 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 可以接收下一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
