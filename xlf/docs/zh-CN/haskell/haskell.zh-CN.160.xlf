<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="206d53635660e89b729dbae0a5ee8ca4ad6f1d4b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91158d8244af0c5ddcf54bbc424a1f3ce8465455" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7a00cf455b4aaa94ffcbf1b27f30d2d4b983381" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56f1034f2c452479c64abd99acb9eaf6e1bb6a77" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f8ff6cc69b22bf1456425678371604ae8bf9764" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引等于查询元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。此实现使用memchr（3）。</target>
        </trans-unit>
        <trans-unit id="a398352b17c6d52739d44d57e844810d9fdaa8f4" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引等于查询元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。此实现使用memchr（3）。</target>
        </trans-unit>
        <trans-unit id="32abf17dade59f23367a0750cae77e0186748742" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. This implementation uses memchr(3).</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引等于查询元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。此实现使用memchr（3）。</target>
        </trans-unit>
        <trans-unit id="0af10507b5ea81f6fcabbaeba877b14d1834c332" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中元素的最后一个索引，该索引等于查询元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。以下内容成立：</target>
        </trans-unit>
        <trans-unit id="14c7bf68b17f49e8b32db0d15573be43d627b498" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中元素的最后一个索引，该索引等于查询元素；如果不存在此元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。以下内容成立：</target>
        </trans-unit>
        <trans-unit id="d745dce74ede3fcde2ce420bea76a037fa60241b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; function returns the last index of the element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. The following holds:</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndexEnd&quot;&gt;elemIndexEnd&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中元素的最后一个索引，该索引等于查询元素；如果不存在此元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。以下内容成立：</target>
        </trans-unit>
        <trans-unit id="fbcfdfda801794a07662249df86f86aa5cd0b663" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order. This implementation uses memchr(3).</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 函数通过按升序返回等于查询元素的所有元素的索引来扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 。此实现使用memchr（3）。</target>
        </trans-unit>
        <trans-unit id="621e458fd04dd53651e92111855033d450b93228" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37315a1539ac148f8b197ee303a4f06afb4f713e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad0581db2808ca151e8408dc8b610954112589e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31976f5cbdfc98ce2993d12f12e761df2fe1de07" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">为O（n）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; S和散布列表中的每个元件之间的第一个参数之后串接列表。</target>
        </trans-unit>
        <trans-unit id="aebda77cb9bcb702165b5d974f705234751405b9" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8377f8842146cb9bdcb129fae39524350bd295ef" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1c798cecb03052828abe1d679f44029d4fe2ee" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5266ce310e43a8dcba567f8d3dcfa9331f32a63e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="ededa77d9c7a6776d6ecc0d36aade061de841310" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="d04693d9d2b80630115ab559169ce1d30fc753ce" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="1df8e27dd6e4c9975b3d6d1b678e792607bef5ca" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a ByteString and returns the pair of ByteStrings with elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数使用一个谓词ByteString，并返回一对ByteStrings，它们分别具有不满足该谓词的元素；即</target>
        </trans-unit>
        <trans-unit id="b44a44b7bb991d29a4a3fcd4bbb247c4297ebd80" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1df3964205eddb193d5cfd1b8c5f213312e6d32f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d20c98a3de15ac1eedd335dc68b7f67fc6ca052a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18e1c4f9b5362a4eb0efebdb1d98d53cd92d25d4" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0478fa49c399cf7deb0653820dcb2078ffa8c79" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9b2f860f165e7e1ad2ffc0926c7affe7c5154ee" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db96fc5014a3b5e25cf1a26e16811daadd87dee0" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="ef57000706634199824077e8a68f4bb5c18e225c" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="852ee6561b62c601b500f8006e40f4eca2f9eb51" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="9f2e8576d1e158cac9c7cbea7febf733692b2170" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引与查询元素相等（按memchr）；如果不存在此元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa1c69306c01d9d2337e3925ac50275e90ff6cc0" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引与查询元素相等（按memchr）；如果不存在此元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf2b5b89dd50ba3629b0c31509efee4b7508e72e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; which is equal (by memchr) to the query element, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中第一个元素的索引，该索引与查询元素相等（按memchr）；如果不存在此元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ec8e9f3c268a55e1a8cc1231f1eae1abb77d29a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 函数通过按升序返回等于查询元素的所有元素的索引来扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90b21d94f3c4b1320ba1626339daeec7770ba1e2" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5279735e72e89d06c3a1fde73bc9f386b870f61e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b537bc732a5e0ead515d3f5653a49613f24068c5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a ByteString, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个ByteString，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="783d0496db965e51d6cb762b18cde0603137b5c1" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">为O（n）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; S和散布列表中的每个元件之间的第一个参数之后串接列表。</target>
        </trans-unit>
        <trans-unit id="3dd83c62c3c268df717539e323562675cc5430f8" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a Char and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that Char between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">为O（n）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个字符和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 和`点缀该字符的的元件之间 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它类似于列表中的散布函数。</target>
        </trans-unit>
        <trans-unit id="372a2b3dc42980d37508731eb80bf6db7d2199d5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91332377f7f70899a0ae41286769ec2db1c8413a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8cb409b41ddae1071f8145a59011916cf6931dd" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c394b71edebe9c2ef371ba928c756427e7aad665" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="e580d884d8ad04ca31c3dd1da0be9cd9d9371459" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="ea727e4f5b04829eee15f4fed62b98263fc99223" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个ByteStrings并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="da2d448e19017177a615154734c18743b68888cd" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51d95e44f921fca12780d855c9f3e162160c7c7f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bca72ec09d0f261682b2a802befebf999d9481fe" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its prefix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 函数采用两个ByteStrings并 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回第二个数组的其余部分（第一个是它的前缀），否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f201f1907b48b3a7cc6cc99b33ecee717dde57d" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e59cfc58400ce23ac75fa42c3f44b6c1e97e7f86" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51bbc3bd49287e69f49acc30614c63278e5fa743" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; function takes two ByteStrings and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the remainder of the second iff the first is its suffix, and otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（N）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:stripSuffix&quot;&gt;stripSuffix&lt;/a&gt;&lt;/code&gt; 函数有两个字节串，并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 第二的剩余当且仅当第一个是它的后缀，否则 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b0c4cfcabfa18f0f9d991cbd407b72c68d8fb33" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="21c6075e8b47b7fa1e041e7edecb7535466dea75" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="887513beb5458fc8421f7608693cb13a86fcd17b" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepending to the ByteString and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表&amp;ldquo;展开&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是ByteString的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="9a79fe1dc6f18eb8f680df25925a90f02b4b12c6" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回与该谓词匹配的第一个元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="69054e5f8b47316b792e23e75909b624a9dd7d65" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回与该谓词匹配的第一个元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b18e8cd79784aab1d766d2fb808c10a2356f1bf9" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回与该谓词匹配的第一个元素；如果没有这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="1e0b837386ac594b44e5cf6d096e613510179aab" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; satisfying the predicate. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中满足该谓词的第一个元素的索引。受到融合。</target>
        </trans-unit>
        <trans-unit id="63d3f4379f27a35ffcc42ed8fdb56412243f58b2" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">为O（n）的 &lt;code&gt;&lt;a href=&quot;data-text#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 和列表 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; S和散布列表中的每个元件之间的第一个参数之后串接列表。</target>
        </trans-unit>
        <trans-unit id="e836e26f77556c0c8b0cc26ff73d34938e7b0047" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a character and places it between the characters of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个字符并将其放置在 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的字符之间。</target>
        </trans-unit>
        <trans-unit id="984aa17d031ef64073f3da8a43c7bf9548dd919f" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的前缀。受到融合。</target>
        </trans-unit>
        <trans-unit id="c4701c23717bbb22295ad14f2b10eb58dc7df987" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="4dfb48b3caeabb7a1df3e331f89f4140c49c314a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="b21fdc0a25cfb046efd48b241930d19eb078c970" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的后缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69e4f31c4313f1d4c3b67bed4cc48640a8ddfa1" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="db110ae37c426517ea25e4cf70a039f84806d771" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="3ab19dcdc36cc1c990891fc53ddbd925d7e04441" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the pair of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s with elements which do and do not satisfy the predicate, respectively; i.e.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并分别返回一对 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 和具有不满足该谓词的元素；即</target>
        </trans-unit>
        <trans-unit id="0268ba154bc2df65369ee7c9f2860a69e5f12720" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument. Note that this function uses &lt;code&gt;&lt;a href=&quot;data-text#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, and the list version of transpose, and is thus not very efficient.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 函数转置其 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 参数的行和列。请注意，此函数使用 &lt;code&gt;&lt;a href=&quot;data-text#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 和transpose的列表版本，因此效率不高。</target>
        </trans-unit>
        <trans-unit id="6f251ba2e248e15eaccaea66658fe246c0b91a6a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:countCharI&quot;&gt;countCharI&lt;/a&gt;&lt;/code&gt; function returns the number of times the query element appears in the given stream.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:countCharI&quot;&gt;countCharI&lt;/a&gt;&lt;/code&gt; 函数返回查询元素出现在给定流中的次数。</target>
        </trans-unit>
        <trans-unit id="6eaaa8e81e7668e011fec45f05f761f3572874b5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; 函数获取一个谓词和一个流，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="295b6756a4814711709f93f1dec5c2c15fd68471" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个流，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1117bda5e528eaead4fc5ec80e720cc207b7b423" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findBy&quot;&gt;findBy&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个流，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b284a7b295ef70c67ab5d6c8855dc29d511a07b7" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="931ddb07490e7cec9210576ddaec219147360847" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的前缀。</target>
        </trans-unit>
        <trans-unit id="73bc4c07f9134cdb353c613167c4bdfc7de771f7" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的前缀。</target>
        </trans-unit>
        <trans-unit id="25a5607aba7f8c2bbb7401fa4d562110e6df9f7e" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="01e94843b9d1ffb74fbb5ec0f71b85258ae98acb" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bef145f57703a175a846b70ff0c4145e380fbd3" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the first element in matching the predicate, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回匹配该谓词的第一个元素；如果不存在这样的元素，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="95828d7cd49664c5ab7bed1d6891046b6c1333a5" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and concatenates the list after interspersing the first argument between each element of the list.</source>
          <target state="translated">为O（n）的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intercalate&quot;&gt;intercalate&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 和列表 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; S和散布列表中的每个元件之间的第一个参数之后串接列表。</target>
        </trans-unit>
        <trans-unit id="3cae76bc8927661b489edb3e78bf012fb490d938" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a character and places it between the characters of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个字符并将其放置在 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的字符之间。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="97bb42a55cb8c57d4f1fbc3342c90cdb42316d3c" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的前缀。受到融合。</target>
        </trans-unit>
        <trans-unit id="a4fcd527985de3e72cee7a20888625e4230e30bd" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="8d65f47ad6bf5b34cb72753823ae743307c5137a" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a prefix of the second. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的前缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="074610c8ab674e115547afb68793bda621fadeef" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第一个是第二个的后缀，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="644de61930aa7c438ab49813b5fd60f714b9a479" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="7cb3cbb4a320b1f174cd320996e698c547c69dcc" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is a suffix of the second.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，前提是第一个是第二个的后缀。</target>
        </trans-unit>
        <trans-unit id="57a78956fd1a59e10ea99a16e76360b37ac4ecaa" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and returns the pair of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s with elements which do and do not satisfy the predicate, respectively; i.e.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数接受一个谓词和一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并分别返回一对 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 和具有不满足该谓词的元素；即</target>
        </trans-unit>
        <trans-unit id="6eeaa345a563e0fa2e5c1f6c8f36ad488f35a4ed" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument. Note that this function uses &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, and the list version of transpose, and is thus not very efficient.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 函数转置其 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 参数的行和列。请注意，此函数使用 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 和transpose的列表版本，因此效率不高。</target>
        </trans-unit>
        <trans-unit id="51ae577567561237689dc6b0d14f758718ddd181" translate="yes" xml:space="preserve">
          <source>O(n) The &lt;code&gt;count&lt;/code&gt; function returns the number of times the query element appears in the given stream.</source>
          <target state="translated">O（n） &lt;code&gt;count&lt;/code&gt; 函数返回查询元素出现在给定流中的次数。</target>
        </trans-unit>
        <trans-unit id="dc7ee14d7eade919f222af426593eaafcbfc0185" translate="yes" xml:space="preserve">
          <source>O(n) all &lt;code&gt;p &lt;/code&gt;xs determines if all characters in the &lt;code&gt;Text&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O（n）所有 &lt;code&gt;p &lt;/code&gt; xs确定 &lt;code&gt;Text&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 中的所有字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79cec94da8772ae50c6e028ddd630af1260aec70" translate="yes" xml:space="preserve">
          <source>O(n) any &lt;code&gt;p &lt;/code&gt;xs determines if any character in the stream &lt;code&gt;xs&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O（n）任何 &lt;code&gt;p &lt;/code&gt; xs确定流 &lt;code&gt;xs&lt;/code&gt; 中的任何字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bc987e83d1621e87ef81a9eb7f6a9f52d5bf7ab" translate="yes" xml:space="preserve">
          <source>O(n) construction Use a &lt;code&gt;ByteString&lt;/code&gt; with a function requiring a &lt;code&gt;CStringLen&lt;/code&gt;. As for &lt;code&gt;useAsCString&lt;/code&gt; this function makes a copy of the original &lt;code&gt;ByteString&lt;/code&gt;. It must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O（n）构造将 &lt;code&gt;ByteString&lt;/code&gt; 与需要 &lt;code&gt;CStringLen&lt;/code&gt; 的函数一起使用。至于 &lt;code&gt;useAsCString&lt;/code&gt; ,此函数将复制原始 &lt;code&gt;ByteString&lt;/code&gt; 。子计算完成后，不得存储或使用它。</target>
        </trans-unit>
        <trans-unit id="3f42f538b318943c153831ed08e2685c23285c0d" translate="yes" xml:space="preserve">
          <source>O(n) construction Use a &lt;code&gt;ByteString&lt;/code&gt; with a function requiring a null-terminated &lt;code&gt;CString&lt;/code&gt;. The &lt;code&gt;CString&lt;/code&gt; is a copy and will be freed automatically; it must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O（n）构造将 &lt;code&gt;ByteString&lt;/code&gt; 与需要空终止 &lt;code&gt;CString&lt;/code&gt; 的函数一起使用。该 &lt;code&gt;CString&lt;/code&gt; 的是副本，将自动释放; 子计算完成后，不得存储或使用它。</target>
        </trans-unit>
        <trans-unit id="c846ca8d154a7b0a9fb00359353de049647ae99b" translate="yes" xml:space="preserve">
          <source>O(n) construction. Use a &lt;code&gt;ShortByteString&lt;/code&gt; with a function requiring a &lt;code&gt;CStringLen&lt;/code&gt;. As for &lt;code&gt;useAsCString&lt;/code&gt; this function makes a copy of the original &lt;code&gt;ShortByteString&lt;/code&gt;. It must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O（n）构造。将 &lt;code&gt;ShortByteString&lt;/code&gt; 与需要 &lt;code&gt;CStringLen&lt;/code&gt; 的函数一起使用。至于 &lt;code&gt;useAsCString&lt;/code&gt; ,此函数将复制原始的 &lt;code&gt;ShortByteString&lt;/code&gt; 。子计算完成后，不得存储或使用它。</target>
        </trans-unit>
        <trans-unit id="2e24f4a921886ebc8dee74e604e63c1bc88cd4f7" translate="yes" xml:space="preserve">
          <source>O(n) construction. Use a &lt;code&gt;ShortByteString&lt;/code&gt; with a function requiring a null-terminated &lt;code&gt;CString&lt;/code&gt;. The &lt;code&gt;CString&lt;/code&gt; is a copy and will be freed automatically; it must not be stored or used after the subcomputation finishes.</source>
          <target state="translated">O（n）构造。将 &lt;code&gt;ShortByteString&lt;/code&gt; 与需要空终止 &lt;code&gt;CString&lt;/code&gt; 的函数一起使用。该 &lt;code&gt;CString&lt;/code&gt; 的是副本，将自动释放; 子计算完成后，不得存储或使用它。</target>
        </trans-unit>
        <trans-unit id="7cf753ad2eeb7c815eac4d51d25857fb8075e367" translate="yes" xml:space="preserve">
          <source>O(n) maximum returns the maximum value from a stream, which must be non-empty.</source>
          <target state="translated">O(n)maximum 返回流的最大值,该值必须是非空的。</target>
        </trans-unit>
        <trans-unit id="7c447d6fd523c0d0c62fdb16120768a0538cec15" translate="yes" xml:space="preserve">
          <source>O(n) minimum returns the minimum value from a &lt;code&gt;Text&lt;/code&gt;, which must be non-empty.</source>
          <target state="translated">O（n）minimum返回 &lt;code&gt;Text&lt;/code&gt; 的最小值，该值必须为非空。</target>
        </trans-unit>
        <trans-unit id="8b47776ea350b828e4782c8b7d2e87c90ff26b41" translate="yes" xml:space="preserve">
          <source>O(n) stream index (subscript) operator, starting from 0.</source>
          <target state="translated">O(n)流索引(下标)运算符,从0开始。</target>
        </trans-unit>
        <trans-unit id="2a179679d6c92f2ff0a3ed59f1ae3c6c726098c1" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="3205e99c86e333e04777ffbdfeca6914a6cf5483" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="3accdfd17749f70874b4680f21a7d44eca628fa4" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="ff818ad54f1470dfc5f3acaa8418748ae7b95cf4" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="0eb07bedb5ec374aecdbd4bb8d80730362790f63" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="ff0ec7e684013a58ab97e1279af054717042a38d" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;. In this case, &lt;code&gt;a&lt;/code&gt; is the next &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能类似于列表 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 根据种子值构建 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。该函数接受元素，如果完成生成 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 。在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="0b6a73856d1308ea4b064a3d9fc6d62b223a3429" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;code&gt;n&lt;/code&gt; is the length of the result. The unfoldr function is analogous to the List &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. unfoldr builds a stream from a seed value. The function takes the element and returns Nothing if it is done producing the stream or returns Just (a,b), in which case, a is the next Char in the string, and b is the seed value for further production.</source>
          <target state="translated">O（n），其中 &lt;code&gt;n&lt;/code&gt; 是结果的长度。展开功能类似于列表 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。展开器根据种子值构建流。该函数接受元素并在完成生成流后返回Nothing或返回Just（a，b），在这种情况下，a是字符串中的下一个Char，b是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="c03ab14925a542ebc519ea48d4a849680bd10f4a" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字节， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="816ab5613d5257e41cd12eab24bceef2e1566aa0" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字节， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="582ae87eb833988f0c89cc09219c226699b41a6e" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next byte in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字节， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="d0fde6970ba722285dbfb2bb86ba9ddab5e58ec9" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字符， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="cdfbbdc5dc33e6b9add119167d0df5fbd5a5e58d" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字符， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="e991edceddf5e8bd2a8ec31ea7e70c451ae8cac8" translate="yes" xml:space="preserve">
          <source>O(n), where &lt;em&gt;n&lt;/em&gt; is the length of the result. The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to the List 'unfoldr'. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the ByteString or returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is the next character in the string, and &lt;code&gt;b&lt;/code&gt; is the seed value for further production.</source>
          <target state="translated">O（n），其中&lt;em&gt;n&lt;/em&gt;是结果的长度。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 功能是类似于列表&amp;ldquo;unfoldr&amp;rdquo;。 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 从种子值构建ByteString。该函数接受元素，如果完成生成ByteString或返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; 则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是字符串中的下一个字符， &lt;code&gt;b&lt;/code&gt; 是用于进一步生产的种子值。</target>
        </trans-unit>
        <trans-unit id="ceaee61cf4c86a4cfedd55743379f704a86375c4" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="a9a6e5489e15971815fbadc25cbc83a64b5a4e4e" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="5fb15abd7958532e8ea126eb3916394c786030ff" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="9ec18bf9617ddbc5f926dd7e90848c7b25f4cba2" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="3854551c76b0975df5c831a06eac450d79a73884" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="26efc74ce3281d637bcff38f8aa55750ecc2dfb2" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="06a6b96e556967d134bb56ea9708d4004f451168" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="bbe068fbb503e4b0b81cf66c9d125156d8ea7b1a" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="9e1b029649a82490c31408643b7ec9e9746982d4" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-intmap-strict-internal#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="2a28ae698d478e9723ab92a699f5a1fab2e893a9" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 删除第一次出现的 &lt;code&gt;x&lt;/code&gt; 从其列表的说法。例如，</target>
        </trans-unit>
        <trans-unit id="ccf20cdd3504967299316be3c4b583dca63bcaf2" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足谓词的那些元素的列表；即</target>
        </trans-unit>
        <trans-unit id="d6fe1b11423245d1cb4e0bdb9854f834eff82c62" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="11f965321b8cf48b28368645a30a485a8fbe2bf3" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="8c55e4147006d30488e980655db22c957c6d3858" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续减小值的列表：</target>
        </trans-unit>
        <trans-unit id="8cc7978dbf7398841fab5ef77987edff23cc46d3" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="3276e1977108db17ca404044fc0e4cf770d7f949" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="d4146ad1a8026cc64491869dab9073233e206c19" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="1acbc5396610d091e2bd3f021730a65076944055" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; ，但仅当 &lt;code&gt;f&lt;/code&gt; 严格单调时才有效。也就是说，对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何值，如果 &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 则 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; 。&lt;em&gt;不检查前提条件。&lt;/em&gt;半正式地，我们有：</target>
        </trans-unit>
        <trans-unit id="d5757263023c5cec22db23f29c037746af6d0da6" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数还可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="e63a890a138b208c55c6769d80c83815c8ff5640" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="e7dfbb66630630f47c85414d3080c23acee97837" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, behaves exactly like a regular &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-lazy#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (,) k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-lazy#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 也就是说，其行为与常规 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 完全相同，只是遍历函数也可以访问与值关联的键。</target>
        </trans-unit>
        <trans-unit id="1cc472489dbc2ff3cc43835b13e34e467315dd41" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; ，但仅当 &lt;code&gt;f&lt;/code&gt; 严格单调时才有效。也就是说，对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何值，如果 &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 则 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; 。&lt;em&gt;不检查前提条件。&lt;/em&gt;半正式地，我们有：</target>
        </trans-unit>
        <trans-unit id="cea185f035e06b795818b7d4fabdc1b0fef0bf2b" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, it behaves much like a regular &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value and the values are forced before they are installed in the result map.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 即，它的行为就像一个常规的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 除遍历功能还可以访问与值关联的键，并且在将值安装到结果映射中之前将其强制。</target>
        </trans-unit>
        <trans-unit id="7192133739e1c92cbd532c66d42709ac4c9a5de1" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, it behaves much like a regular &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value and the values are forced before they are installed in the result map.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 即，它的行为就像一个常规的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 除遍历功能还可以访问与值关联的键，并且在将值安装到结果映射中之前将其强制。</target>
        </trans-unit>
        <trans-unit id="84f53fde76e9997ab963b20568f2c6c1d382fe4e" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; That is, it behaves much like a regular &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; except that the traversing function also has access to the key associated with a value and the values are forced before they are installed in the result map.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:traverseWithKey&quot;&gt;traverseWithKey&lt;/a&gt; f m == &lt;a href=&quot;data-map-strict#v:fromList&quot;&gt;fromList&lt;/a&gt; &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt; ((k, v) -&amp;gt; (v' -&amp;gt; v' `seq` (k,v')) &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; f k v) (&lt;a href=&quot;data-map-strict#v:toList&quot;&gt;toList&lt;/a&gt; m)&lt;/code&gt; 即，它的行为就像一个常规的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 除遍历功能还可以访问与值关联的键，并且在将值安装到结果映射中之前将其强制。</target>
        </trans-unit>
        <trans-unit id="8007dbe721f56ebc5e776bd43354f56a1b8e404f" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="46d3eacf6c15ed88627cd6de7787fa50dacce5f6" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；即</target>
        </trans-unit>
        <trans-unit id="0bf19886a76e7131793141b2d9864a2a0dbbfff4" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 形式返回有限列表的长度。它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 的实例，其结果类型可以是任何数字。</target>
        </trans-unit>
        <trans-unit id="db7f64169595886472ec744cb1bbafae98b3cf54" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="f3ff23116ae72545d77549c1ec0fa0f5fd3e1c89" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="824f695c7c4f739b93537e96dcb9ff4e4c0a90bf" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续减小值的列表：</target>
        </trans-unit>
        <trans-unit id="045e5a9f70a34641cb06644e1fa86228ab102908" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="310795a4329755dec2ed79c11b8311da1103913c" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="c6e1e31fd1fc11a0f2735b2a8cf7393a75f33e8f" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="b936791b29247c7f9b4e15048744b9cc7608afab" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 删除第一次出现的 &lt;code&gt;x&lt;/code&gt; 从其列表的说法。例如，</target>
        </trans-unit>
        <trans-unit id="9a6fcf6789e028094a541cbfbbfdfec2309d5a96" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；即</target>
        </trans-unit>
        <trans-unit id="05fbe4552475b693aab8bdf13ac7026cdbfe7ced" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 形式返回有限列表的长度。它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 的实例，其结果类型可以是任何数字。</target>
        </trans-unit>
        <trans-unit id="254fff5a4de46ce9d178b5eff8cd85ac75de3880" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="48f176e190a0c5f600c3d2874157da1284586155" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="dde493ad53fbdb0bfd6f761be075cdd2f1f0c36a" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续减小值的列表：</target>
        </trans-unit>
        <trans-unit id="8b28d83ba41d81f7b42565c540fb3b9c08212581" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="bc83e83adec5b4e7cc90c163f46c901f6b1fa2f7" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="573dea7ef43efaa5eecb101453bf66ef2aaa811e" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="d301cbe6e2600371f03d481dbffc35b50bec2f92" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；即</target>
        </trans-unit>
        <trans-unit id="dc73d88e92572b41dfdee704ea155b51c75e61b7" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="b743e350bfc904dbe5448ea57249e9ab73540707" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="d6a4c69de0dbafe4c5a63b928de7fd345bf43179" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续减小值的列表：</target>
        </trans-unit>
        <trans-unit id="2bfac262165c91307a48da21d04f83e5bdb837ac" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="f46f289161b09cf495b972e219ff941b09fc1cc1" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="b5107a476769f8d488425004099579d97919ff1c" translate="yes" xml:space="preserve">
          <source>O(n). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="80685670a565df2994ff82358d8d9ff346ae50d8" translate="yes" xml:space="preserve">
          <source>O(n). A builder taking &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and copy it to a Builder, satisfying</source>
          <target state="translated">上）。一个构建者使用 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 并将其复制到构建器，</target>
        </trans-unit>
        <trans-unit id="c2f78c4f172bc4680efd940d6c47ab223d367d51" translate="yes" xml:space="preserve">
          <source>O(n). A builder taking &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and copy it to a Builder, satisfying</source>
          <target state="translated">在）。一个构建者使用 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 并将其复制到一个构建器，满足</target>
        </trans-unit>
        <trans-unit id="70530ff33b2f16d9be90d2560f114d8dac8bfc71" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="c7380470e12e67adf60da39d725c225d497cd662" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="0bf0c60b5a6d8a2a055aaebd92dc0d1c6b5c103a" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="82457c61bd0e963eec702359fcd34f0ff32501f0" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="5a29f8d2a31048d9445b8886cc17d35b68969681" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="cc75e48d3a49b33e6f4a5c064a7700327c483fb6" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="a454f37660a51ebf61d9a9170dbc42b08c97ea8b" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="f37cf8f77f78f92b1d2b189d97d8a766dfb4b013" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="07b3e469f7af7089b4d7e6be8526028e5208ba72" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="6652cb2e4158f4edcbb03a44c914d8bbdcea8def" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="2f2d3eee8befdc90da40cb506768f425108997cf" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="fbfc0b3d401de0da22c833fd914cdf87cf3ad2ad" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="9c9b47ca6ec14a56ef0784dd784ebaba55d0ff1f" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="ea14a4b5caf215591432bbecd9c62674000ce961" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="ad005000b108f9f31078985fef50b64dda243665" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="e2e08f85d242295bd6a7359e0f4e3a1dd883998e" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="3ede2b5f5836896aa861499f8e3bf682ba69f6ec" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="83a96d043e8c0058beb4beed6a6fc723903d87e6" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="9dac0f730b434a42ae9957e2d7025be0a3627a87" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="ae0949840a8f862d0e211f4d923fc48b92807906" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="f28ab3bbfb1340b66378ee808be9d2a2987e7a8f" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="8b0acf8d5f562e1eaa30615815852e4b38d994a5" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="72f18a0b545c4ad6247523768dde2a7ce47f0810" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="b3f861bd5e903de24fdec1c75612861903c49750" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="cc72c076578869cc3de5b3d0c434dfa36f224709" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="835c9e3e5e07db560062a8c80415943a883c2334" translate="yes" xml:space="preserve">
          <source>O(n). A strict version of &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</source>
          <target state="translated">上）。文件 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的严格版本。在下一个应用程序中使用结果之前，将对操作员的每个应用程序进行评估。此功能的起始值严格。</target>
        </trans-unit>
        <trans-unit id="063cc731f27cbebf293ec9eacfc6553e106ac3a1" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">上）。严格累积的 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="dc1cd9ce113d0d3907dd9da1930ec270f5945076" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">上）。严格累积的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="85639e1d597282db08f70e9b2cb500f671d35a66" translate="yes" xml:space="preserve">
          <source>O(n). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">上）。严格累积的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="33971ce6acba8402c3758c76737e1c0b89d6c430" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。以升序顺序返回映射中的所有键/值对。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="dfcf33bd47f25122dc59dfe1518c78eec0627929" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。以升序顺序返回映射中的所有键/值对。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="938ef8b59e329c83f3be432fd7651512e7c3d413" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Returns all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。以升序顺序返回映射中的所有键/值对。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="1dfa0cbbb13da3d38e8ee7d534675b7cc31c619a" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。以升序顺序返回地图中的所有键/值对。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="c1f6c65197a208e02e5f6e1c3db3c69651d3f940" translate="yes" xml:space="preserve">
          <source>O(n). An alias for &lt;code&gt;&lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。以升序顺序返回地图中的所有键/值对。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="1916b10ea722263e2dfc142ca33d3e33943e58f3" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。集合中的元素按升序排列。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="c62ebbbdd6d3cb62f75691f5c5c1fd1fdc7d21f1" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。集合中的元素按升序排列。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="1986568dddd744d5fe0785ebc3f7919cddca61f4" translate="yes" xml:space="preserve">
          <source>O(n). An alias of &lt;code&gt;&lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;. The elements of a set in ascending order. Subject to list fusion.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 的别名。集合中的元素按升序排列。有待清单融合。</target>
        </trans-unit>
        <trans-unit id="3daacd528be89274a916e931b2d01da14ee9cdf7" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list in linear time with a combining function for equal keys. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。利用线性键的组合功能从线性时间的降序列表构建地图。&lt;em&gt;不检查前提条件（输入列表降序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6daf271b34fd0ee22a7b221ce97aae9f534f7a50" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list in linear time. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。从线性时间的降序列表构建地图。&lt;em&gt;不检查前提条件（输入列表降序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="729cb7b9c6526cbf116498bbd1a02e7f2fd9de41" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a descending list of distinct elements in linear time. &lt;em&gt;The precondition is not checked.&lt;/em&gt;</source>
          <target state="translated">O(n). Build a map from a descending list of distinct elements in linear time. &lt;em&gt;The precondition is not checked.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04829e28a59536fa17ba4dd57fe84f7b01bbc53b" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order and all distinct. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">O(n). Build a map from a list of key/value pairs where the keys are in ascending order and all distinct. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc398f65e3d84504143cfc77896ba699dbca8682" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order, with a combining function on equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">O(n). Build a map from a list of key/value pairs where the keys are in ascending order, with a combining function on equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a000fae0b6e524a14b40c7d6b60b7b128b6dc6ca" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a list of key/value pairs where the keys are in ascending order.</source>
          <target state="translated">O(n)。从键/值对的列表中建立一个地图,其中键是按升序排列的。</target>
        </trans-unit>
        <trans-unit id="9400af3afb5f52d7933a8fd94fe48f15d665625c" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from a set of keys and a function which for each key computes its value.</source>
          <target state="translated">O(n)。从一组键和一个函数建立一个地图,对每个键计算其值。</target>
        </trans-unit>
        <trans-unit id="0d846e7d484766b6455d3d20fbac1d15237cbd78" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list in linear time with a combining function for equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">O(n). Build a map from an ascending list in linear time with a combining function for equal keys. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="382dbb9f6886862ebe682148e2a1304e6e911ce0" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list in linear time. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">O(n). Build a map from an ascending list in linear time. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9a9573ff4e725a34e321f32ef83a67f8acf6206" translate="yes" xml:space="preserve">
          <source>O(n). Build a map from an ascending list of distinct elements in linear time. &lt;em&gt;The precondition is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。根据线性时间中不同元素的升序列表构建地图。&lt;em&gt;不检查前提条件。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dadd9ac678a4613069a434f429dc49502d3082e3" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from a descending list in linear time. &lt;em&gt;The precondition (input list is descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。从线性时间的降序列表构建集合。&lt;em&gt;不检查前提条件（输入列表降序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66e1fa93cd42026eaa1da1a002e30a7bf60afcc2" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from a descending list of distinct elements in linear time. &lt;em&gt;The precondition (input list is strictly descending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。根据线性时间中不同元素的降序列表构建集合。&lt;em&gt;不检查前提条件（输入列表严格降序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eee38f55e80530b1e9b1c715fe02e0a1e408a76" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list in linear time. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。从线性时间的升序列表构建集合。&lt;em&gt;不检查前提条件（输入列表升序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6809d6e2d235a847eb2c098caad8a6faa4a558da" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of distinct elements in linear time. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。在线性时间内从不同元素的升序列表构建集合。&lt;em&gt;不检查前提条件（输入列表严格升序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9662193240858bcb94da0313cc5b5f335754ab0" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of distinct elements. &lt;em&gt;The precondition (input list is strictly ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。从不同元素的升序列表构建集合。&lt;em&gt;不检查前提条件（输入列表严格升序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af6905fb7dd9332dae81595f53ed13e17f3a7b3e" translate="yes" xml:space="preserve">
          <source>O(n). Build a set from an ascending list of elements. &lt;em&gt;The precondition (input list is ascending) is not checked.&lt;/em&gt;</source>
          <target state="translated">上）。从元素的升序列表构建集合。&lt;em&gt;不检查前提条件（输入列表升序）。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0b8aa48e50c217480a7bac3595337f5cd713365" translate="yes" xml:space="preserve">
          <source>O(n). Cardinality of the set.</source>
          <target state="translated">O(n)。集的基数。</target>
        </trans-unit>
        <trans-unit id="87fc609c058362b77fb22012d92969714c9de300" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ByteString&lt;/code&gt; from a &lt;code&gt;CString&lt;/code&gt;. The resulting &lt;code&gt;ByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CString&lt;/code&gt;, and is managed on the Haskell heap. The original &lt;code&gt;CString&lt;/code&gt; must be null terminated.</source>
          <target state="translated">上）。从 &lt;code&gt;CString&lt;/code&gt; 构造一个新的 &lt;code&gt;ByteString&lt;/code&gt; 。结果 &lt;code&gt;ByteString&lt;/code&gt; 是原始 &lt;code&gt;CString&lt;/code&gt; 的不变副本，并在Haskell堆上进行管理。原始 &lt;code&gt;CString&lt;/code&gt; 必须以null终止。</target>
        </trans-unit>
        <trans-unit id="3f96c04218005ba3f372a9e0681a6f7482a0605c" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ByteString&lt;/code&gt; from a &lt;code&gt;CStringLen&lt;/code&gt;. The resulting &lt;code&gt;ByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CStringLen&lt;/code&gt;. The &lt;code&gt;ByteString&lt;/code&gt; is a normal Haskell value and will be managed on the Haskell heap.</source>
          <target state="translated">上）。从 &lt;code&gt;CStringLen&lt;/code&gt; 构造一个新的 &lt;code&gt;ByteString&lt;/code&gt; 。结果 &lt;code&gt;ByteString&lt;/code&gt; 是原始 &lt;code&gt;CStringLen&lt;/code&gt; 的不变副本。该 &lt;code&gt;ByteString&lt;/code&gt; 是一个正常的Haskell值，并将于Haskell的堆管理。</target>
        </trans-unit>
        <trans-unit id="3af0d34eddae2fa890c99e6e7750e36f7d028e14" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ShortByteString&lt;/code&gt; from a &lt;code&gt;CString&lt;/code&gt;. The resulting &lt;code&gt;ShortByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CString&lt;/code&gt;, and is managed on the Haskell heap. The original &lt;code&gt;CString&lt;/code&gt; must be null terminated.</source>
          <target state="translated">上）。从 &lt;code&gt;CString&lt;/code&gt; 构造一个新的 &lt;code&gt;ShortByteString&lt;/code&gt; 。生成的 &lt;code&gt;ShortByteString&lt;/code&gt; 是原始 &lt;code&gt;CString&lt;/code&gt; 的不变副本，并在Haskell堆上进行管理。原始 &lt;code&gt;CString&lt;/code&gt; 必须以null终止。</target>
        </trans-unit>
        <trans-unit id="b455d50c1fe35d365821ac00e8e7e524a5007e9b" translate="yes" xml:space="preserve">
          <source>O(n). Construct a new &lt;code&gt;ShortByteString&lt;/code&gt; from a &lt;code&gt;CStringLen&lt;/code&gt;. The resulting &lt;code&gt;ShortByteString&lt;/code&gt; is an immutable copy of the original &lt;code&gt;CStringLen&lt;/code&gt;. The &lt;code&gt;ShortByteString&lt;/code&gt; is a normal Haskell value and will be managed on the Haskell heap.</source>
          <target state="translated">上）。从 &lt;code&gt;CStringLen&lt;/code&gt; 构造一个新的 &lt;code&gt;ShortByteString&lt;/code&gt; 。结果得到的 &lt;code&gt;ShortByteString&lt;/code&gt; 是原始 &lt;code&gt;CStringLen&lt;/code&gt; 的不变副本。该 &lt;code&gt;ShortByteString&lt;/code&gt; 是正常的Haskell值，并将于Haskell的堆管理。</target>
        </trans-unit>
        <trans-unit id="d605df03958840eb26896869cbad19609feb0e48" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c77d0c3f6baffb8d25d9ff396d4687d8b4bc2f9" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad5dad9654275617c6c664c1a00e8b2eaaf27898" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="104b0cdf481fb213c0fbe1b1362ab69b9f4405ea" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a list.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 转换为列表。</target>
        </trans-unit>
        <trans-unit id="40d1304b8827895cdf1bb4f59d8bc130273aaf23" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297088dbf1e8c09077781d38164fb76d68843a39" translate="yes" xml:space="preserve">
          <source>O(n). Convert a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; into a list.</source>
          <target state="translated">上）。将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 转换为列表。</target>
        </trans-unit>
        <trans-unit id="eab1e87a8573b28450f0853eebb702a97f8d52af" translate="yes" xml:space="preserve">
          <source>O(n). Convert a list into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">上）。将列表转换成 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd464cb518575f88abc9f28748496003ac2f39b9" translate="yes" xml:space="preserve">
          <source>O(n). Convert a list into a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">上）。将列表转换成 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54bf324121cf04e8bf75f5d03af99d55eba2edb1" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs where the keys are in ascending order. Subject to list fusion.</source>
          <target state="translated">O(n)。将地图转换为键/值对的列表,其中键按升序排列。受制于列表融合。</target>
        </trans-unit>
        <trans-unit id="b37e9319ddf52e30abb6270d730dd637ccb1a1c1" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs where the keys are in descending order. Subject to list fusion.</source>
          <target state="translated">O(n)。将地图转换为键/值对的列表,其中键是降序的。受制于列表融合。</target>
        </trans-unit>
        <trans-unit id="1b9592ab7e554056e70625d0f6a1d9a4dbb98aad" translate="yes" xml:space="preserve">
          <source>O(n). Convert the map to a list of key/value pairs. Subject to list fusion.</source>
          <target state="translated">O(n)。将地图转换为键/值对的列表。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="1f55e622796c2112ef81903eed79711372b62b24" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to a descending list of elements. Subject to list fusion.</source>
          <target state="translated">O(n)。将集合转换为元素的降序列表。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="d8408ba5d185cec2589d3b3222cb3b94b09b3b72" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to a list of elements. Subject to list fusion.</source>
          <target state="translated">O(n)。将集合转换为元素列表。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="55634c24f206f4681ac932e849c1bd513d33a8be" translate="yes" xml:space="preserve">
          <source>O(n). Convert the set to an ascending list of elements. Subject to list fusion.</source>
          <target state="translated">O(n)。将集合转换为元素的升序列表。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="2a0fbedac005cda8da057c4c7632c26766051d62" translate="yes" xml:space="preserve">
          <source>O(n). Extract a lazy &lt;code&gt;Text&lt;/code&gt; from a &lt;code&gt;Builder&lt;/code&gt; with a default buffer size. The construction work takes place if and when the relevant part of the lazy &lt;code&gt;Text&lt;/code&gt; is demanded.</source>
          <target state="translated">上）。从 &lt;code&gt;Builder&lt;/code&gt; 提取具有默认缓冲区大小的惰性 &lt;code&gt;Text&lt;/code&gt; 。如果需要惰性 &lt;code&gt;Text&lt;/code&gt; 的相关部分，则将进行构造工作。</target>
        </trans-unit>
        <trans-unit id="f8f08df5754e3c864e5e5d2f3623efd7721b6fc9" translate="yes" xml:space="preserve">
          <source>O(n). Extract a lazy &lt;code&gt;Text&lt;/code&gt; from a &lt;code&gt;Builder&lt;/code&gt;, using the given size for the initial buffer. The construction work takes place if and when the relevant part of the lazy &lt;code&gt;Text&lt;/code&gt; is demanded.</source>
          <target state="translated">上）。使用给定的初始缓冲区大小，从 &lt;code&gt;Builder&lt;/code&gt; 中提取惰性 &lt;code&gt;Text&lt;/code&gt; 。如果需要惰性 &lt;code&gt;Text&lt;/code&gt; 的相关部分，则将进行构造工作。</target>
        </trans-unit>
        <trans-unit id="6fe7d65969a116c9d2fcb0181118e2c835f1e1f3" translate="yes" xml:space="preserve">
          <source>O(n). Extract the last element of a list, which must be finite and non-empty.</source>
          <target state="translated">O(n)。提取列表中的最后一个元素,该元素必须是有限的、非空的。</target>
        </trans-unit>
        <trans-unit id="7241dc2b686aac0cb246206f5761f1dfbe048ba8" translate="yes" xml:space="preserve">
          <source>O(n). Filter all elements that satisfy some predicate.</source>
          <target state="translated">O(n)。过滤所有满足某个谓词的元素。</target>
        </trans-unit>
        <trans-unit id="3bc73542b8cc3c264a30bd7ffccf5378a38c6038" translate="yes" xml:space="preserve">
          <source>O(n). Filter all elements that satisfy the predicate.</source>
          <target state="translated">O(n)。过滤所有满足谓词的元素。</target>
        </trans-unit>
        <trans-unit id="0712ff9b4298830ef4a9f7a2fab8b0341da27545" translate="yes" xml:space="preserve">
          <source>O(n). Filter all keys/values that satisfy some predicate.</source>
          <target state="translated">O(n)。过滤所有满足某个谓词的键/值。</target>
        </trans-unit>
        <trans-unit id="9c5dcab4c81d1a0bda0edfeecc5f7bc0e4646864" translate="yes" xml:space="preserve">
          <source>O(n). Filter all keys/values that satisfy the predicate.</source>
          <target state="translated">O(n)。过滤所有满足谓词的键/值。</target>
        </trans-unit>
        <trans-unit id="faf50780dfd316b2b37e87515f049261caf3492b" translate="yes" xml:space="preserve">
          <source>O(n). Filter all values that satisfy some predicate.</source>
          <target state="translated">O(n)。过滤所有满足某个谓词的值。</target>
        </trans-unit>
        <trans-unit id="5be317c4605cb1f4dd8d41a02e5f76bff0ac97fb" translate="yes" xml:space="preserve">
          <source>O(n). Filter all values that satisfy the predicate.</source>
          <target state="translated">O(n)。过滤所有满足谓词的值。</target>
        </trans-unit>
        <trans-unit id="fd187d380259e772f7777ff3d8188b6dfe8de3a3" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ea0999e67715a8fc28d2f325684bc33d0713301" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="425088ba0efb51ad2aff52deeea71f304dfdd869" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f489c4b27b1c2cc165ef315dd05b68a6fa36505a" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="331c0868ec4611fd9bf6273b75dd9ad7c2587e75" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1fa02f4c6a8402feb500f73b7b63873e04abff4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f324b2b0f59da83f5871f1dd588fd32acd68deb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="545a2de033705986e238c1b8f2f2fdb9df74e9be" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48f5d961ae7e18fe8cd2412bf10abb3377bb373d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d2891b27e5ad3bd47a68596fcfc66af3677d178" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7382bb16e7085515a4ccc38c499fd2dfde669cbe" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad0b390fdf0da6d104cce8af6e8f1a78c3d06fbe" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed1f0fabd3931ac452c0505605247322919ef5b7" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="007129228d848f4965f48fcab5d362b5d9ae0645" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f83cfb6170c1e53a882e73d525c572c4d6ec11eb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intset-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d96b1ff503ab715f860cc010d3aa443ff17d126" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f8e285802ef69b72ebbe3b22cfefc40807fb85" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5510fd8558b0aac4520d727c9b616f6d9653324" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠集合中的元素，使得 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-set#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f0c54a302b43d4378064cbb4ee3fcc46426ad6c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素。此功能等效于文件 &lt;code&gt;&lt;a href=&quot;data-intset#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 并且仅出于兼容性目的而存在。</target>
        </trans-unit>
        <trans-unit id="c4a6aaccbde70c13ad3121d99c6be59257d8d3dc" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素。此功能等效于文件 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 并且仅出于兼容性目的而存在。</target>
        </trans-unit>
        <trans-unit id="bbd7db46181441c03e9162a32dc212c95e00689f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the elements in the set using the given right-associative binary operator. This function is an equivalent of &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; and is present for compatibility only.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠集合中的元素。此功能等效于文件 &lt;code&gt;&lt;a href=&quot;data-set#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 并且仅出于兼容性目的而存在。</target>
        </trans-unit>
        <trans-unit id="420a91bccd693fd91224409726cfa81357c23e11" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30b65823f6675873cb1a9414c34776e278fa9db9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93eac3b47b790e3b1c974b8fc473dfa6192e234b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d15df2c03af36975fa4c874e66623b5cc569eac" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61659404d8560ff350ca75a44ee3055a27e1d4a5" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27bb75a5df92e8cecba6ab3978e2a1495cd54312" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4c50d45667ec51cf9d881549e19a7d8d93db6f7" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46762683efed2b9d7e96625249c405fc1749f923" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d4d0d4c7c7ecaa0557481f03931167da367cb36" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5314494d648fc03643b467e48fb407b70680a15d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="680fbb405bb284e329d72efbe02d691b3d9aee3c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44bfda29cb446707f13b16e5c003069d0f85cb25" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cf75e0b5187e855d9687eb54d63a19fdac671b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d747bcbd597f36c0149d3f3fff48554dd77a7fe" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f952f92e4a9cdb033bca39c48c8533bfabc44dde" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (\z' (kx, x) -&amp;gt; f z' kx x) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41dc7087452432576b4253c2fe034bed92265b22" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given monoid, such that</source>
          <target state="translated">O(n)。使用给定的单体对图中的键和值进行折叠,使得</target>
        </trans-unit>
        <trans-unit id="7b147a5bbd0ab6db0d8b192fdc2c0aaade469db9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符在映射中折叠键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7cc847945454b47d631496ec9de07c306cdd7eb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac75aa68c796d8304b5b398c98be087a8756145" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf97c889d33c15be915f227337df5ead3b5e01c2" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符在映射中折叠键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef9be34f7e154a1d2785480f651ae379c09128a9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d2e3bb39c3604e6a553d08e4ace804de97345ec" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="737ae284156ddd7ec85750aa648563e2353c863f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符在映射中折叠键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f61be01603ef02011f2b93061578257c8871d1b0" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9199807d966804d064ac9ea311cdc1ac73bef6b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-intmap-strict-internal#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5900ffccace2bb41fa387fcfb2d2e2beffee0fd6" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符在映射中折叠键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb6036e9ef5590d91f60e25057e704252fcebc48" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0960cbe971ce75ea35f54a7c972fc433cc06a17b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-lazy#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f355e15b89571d5f94a93ce1229fe94de15d615c" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符在映射中折叠键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f06fcc3364cc6e5ca334d3a8329885dc3c163775" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76afe260ff98145d3c95b303dd7ec96d80691b2a" translate="yes" xml:space="preserve">
          <source>O(n). Fold the keys and values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的键和值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:uncurry&quot;&gt;uncurry&lt;/a&gt; f) z . &lt;a href=&quot;data-map-strict#v:toAscList&quot;&gt;toAscList&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f679715363009cd3a06c72b3f2be25343eba4533" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d25bf5c08a40ae957ae20fad0de75081021f7d66" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="393857c07810f1a832a6f75ecac8cb71a0b8b96a" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28c0cce1607c943199c39c6a1ebb1573288d1f6f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad22df3262ceed93bc2c690b1dfd2b716e772de9" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5b40991616cccc1360f63bb419a708ac2afdc40" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be2cf80125dcb52b214a5d99f4084cf0cac98388" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="262fc31483be0a3045510d0bae0dcf1aa222026d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4466f605064244a2caf7b35ffcfc817ff0cac84f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="718c7224ec44e223b2be3a549c64fe306e201873" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc549d3da74315038bea670011313ed312e6fffb" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b7e0e36a0bab65808a5cd3e53e651f3befe935b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769390eedd60c8ae1d97c4c438bac6456a727375" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b956d7520714df903ad4f075cb74eb3c00b670b4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc6fa664b3e09f11b1f94d3290504c06d3e0c11" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given left-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的左关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldl&quot;&gt;foldl&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e960d57eefa58793286f14fd5f64ddf1c8bafd6" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb177a593c811f121f23f142a62cc5ef7add881d" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90de488375b1e909220f98fdabd2b7c5e1c34e69" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5d64d43d6cafe1a938edcbc4877507c4416255b" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73e28ceeb602cdcbd778c0763c4f6401c08e60c4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5e38c580d323d05522800247073aab5dc2cffd4" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46935e9716aef69b9bad01480c973e1ac756472" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e898f6a23ed70ecf501e051dade8af6b3269d3" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ef47138db34a3549030c5f00d427c4ad9857f78" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-intmap-strict-internal#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a071bb93e5cb9cb0cc0479bfa2dbc2f564d7b16" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d55962360d0ec40caf1f3606fc87b1f742ecdc83" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90e4383ef1bb96574df4b1b480c9cb84e1a28483" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-lazy#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17e16d6b81f14248006211f97996620166151842" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d655488a73bc6f23c3c2abcdc2ffdd97fd3e836f" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0afcaf95cb57b8ce1fbd552a052a85bde7d28e52" translate="yes" xml:space="preserve">
          <source>O(n). Fold the values in the map using the given right-associative binary operator, such that &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在）。使用给定的右关联二进制运算符折叠映射中的值，使得 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt; f z == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldr&quot;&gt;foldr&lt;/a&gt; f z . &lt;a href=&quot;data-map-strict#v:elems&quot;&gt;elems&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf01b4698c066b0b378341073e2125bf52db1134" translate="yes" xml:space="preserve">
          <source>O(n). Map a function over all values in the map.</source>
          <target state="translated">O(n)。将一个函数映射到映射中的所有值上。</target>
        </trans-unit>
        <trans-unit id="bbccdf89731955a9400998a6114d2837d096a981" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">上）。映射键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="c8230522617ab0a4acb490d8be3451e1b772afcf" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="27328584b01e2ecae03a937b840e2c00e7e2d856" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="a76552525b158c8f82471de156e40e2bcc3b1ce2" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">上）。映射键/值并分离 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="ce87fa336090794b430dffb93a1aa680a08ec249" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射键/值并分离 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="b7dbfa446983b404f8c550f16e08daf5acce1f1c" translate="yes" xml:space="preserve">
          <source>O(n). Map keys/values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射键/值并分离 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="21ef8296af9f2afa8f9a15c44e3ba51476cd14c0" translate="yes" xml:space="preserve">
          <source>O(n). Map values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">上）。映射值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="55c1e98a2221ffac22c5939a66b681d19acfa130" translate="yes" xml:space="preserve">
          <source>O(n). Map values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="7ec1d039082f25b999fafd83f7dbad13731b97e8" translate="yes" xml:space="preserve">
          <source>O(n). Map values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="14a7913e311b4b3e728eced4de41876519fbb7e7" translate="yes" xml:space="preserve">
          <source>O(n). Map values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">上）。映射值并将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 结果和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果分开。</target>
        </trans-unit>
        <trans-unit id="b9b96cb297dd47e10a91d6aeb4a32a68cf77577d" translate="yes" xml:space="preserve">
          <source>O(n). Map values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射值，并分开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="9ef27f9feb52d276a53b6dd7ee286d9fe1962fb3" translate="yes" xml:space="preserve">
          <source>O(n). Map values and separate the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。映射值，并分开&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="7da1bbef23d470faa79587e532c71aeb2dfb06f2" translate="yes" xml:space="preserve">
          <source>O(n). Number of elements in the map.</source>
          <target state="translated">O(n)。地图中元素的数量。</target>
        </trans-unit>
        <trans-unit id="ca7813a01116d9f994a862c3f8f3c0e0a4161a02" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。根据谓词对地图进行分区。第一个映射包含满足谓词的所有元素，第二个映射包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28a12b7c2ddf73425db47b25ff0e21286cfd08de" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。根据谓词对地图进行分区。第一个映射包含满足谓词的所有元素，第二个映射包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5c46ac5acbc5460bd950b307564d31030391a54" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。根据某些谓词对地图进行分区。第一个映射包含满足谓词的所有元素，第二个映射包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb64cc06d0fc5872d58a6d9d2df165ac0912e391" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。根据某些谓词对地图进行分区。第一个映射包含满足谓词的所有元素，第二个映射包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5902e7b9cb1e33328a5723641e3facd75d1f04e" translate="yes" xml:space="preserve">
          <source>O(n). Partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。根据某些谓词对地图进行分区。第一个映射包含满足谓词的所有元素，第二个映射包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e4689f50053d60e8b12bc8079d817dada74746c" translate="yes" xml:space="preserve">
          <source>O(n). Partition the set into two sets, one with all elements that satisfy the predicate and one with all elements that don't satisfy the predicate. See also &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。将集合分为两组，一组包含所有满足谓词的元素，而另一组包含不满足谓词的所有元素。另请参见 &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a20953ab24f48d2ba8110890acc9412f0f62d973" translate="yes" xml:space="preserve">
          <source>O(n). Return all elements of the map in the ascending order of their keys. Subject to list fusion.</source>
          <target state="translated">O(n)。按键的升序返回地图的所有元素。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="8630a78da8f5c0cfe78e345d3f2e551e0b67329d" translate="yes" xml:space="preserve">
          <source>O(n). Return all keys of the map in ascending order. Subject to list fusion.</source>
          <target state="translated">O(n).按升序返回地图的所有键。按升序返回地图的所有键。受列表融合的影响。</target>
        </trans-unit>
        <trans-unit id="43824a6f5c7483ca2f085a077e4596429bfc3cd1" translate="yes" xml:space="preserve">
          <source>O(n). Return all the elements of a list except the last one. The list must be non-empty.</source>
          <target state="translated">O(n)。返回列表中除最后一个元素外的所有元素。列表必须是非空的。</target>
        </trans-unit>
        <trans-unit id="36a68651939ea7bf78af13ecbe22bf7688a51736" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the map. The tree is shown in a compressed, hanging format.</source>
          <target state="translated">O(n)。显示实现该地图的树。该树以压缩、悬挂的形式显示。</target>
        </trans-unit>
        <trans-unit id="4e4db00c39363393d519fb5c4366332a6fb0de88" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the map. The tree is shown in a compressed, hanging format. See &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。显示实现地图的树。该树以压缩的悬挂格式显示。参见 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ce9adb9e14ba216ad42950a875bc9c14a8209f" translate="yes" xml:space="preserve">
          <source>O(n). Show the tree that implements the set. The tree is shown in a compressed, hanging format.</source>
          <target state="translated">O(n)。显示实现该集合的树。该树以压缩、悬挂的形式显示。</target>
        </trans-unit>
        <trans-unit id="9c10017bd592438d3e62d5bc2e00b9865930af4a" translate="yes" xml:space="preserve">
          <source>O(n). Test if the internal map structure is valid.</source>
          <target state="translated">O(n)。测试内部地图结构是否有效。</target>
        </trans-unit>
        <trans-unit id="c0d7d3d821d1ee1593fb61d9e36825865c839d05" translate="yes" xml:space="preserve">
          <source>O(n). Test if the internal set structure is valid.</source>
          <target state="translated">O(n)。测试内部集合结构是否有效。</target>
        </trans-unit>
        <trans-unit id="2bd8d3ca7f264c1dfc39c248ff7bff4929785346" translate="yes" xml:space="preserve">
          <source>O(n). The</source>
          <target state="translated">O(n)。该</target>
        </trans-unit>
        <trans-unit id="5493b27f1c4b773117d6ff6c8ac89adcfcc21bb4" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但需要用户提供平等谓语。</target>
        </trans-unit>
        <trans-unit id="98032ca70b502ed7c8b616f957d53d84d7de967b" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。特别是，它不返回 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 而是返回任何作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例的类型。但是，它的效率比 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 差。</target>
        </trans-unit>
        <trans-unit id="4587623b8218c7dd5734795fb0233350ad1937cf" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">上）。所述 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表，并插入该元件到列表中在所述第一位置，在其小于或等于所述下一个元素。特别是，如果列表在调用之前排序，则结果也将排序。这是 &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="9ebaa6a5d93309f39c904f20878a239aa03b7857" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表和`点缀的列表的元素之间的元件。例如，</target>
        </trans-unit>
        <trans-unit id="fa50d5aae03c95132217bf805fdc774a3e03caa7" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">上）。在 &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有最终段，最长的第一。例如，</target>
        </trans-unit>
        <trans-unit id="ef3cd44c571d67791124813dab1fa2f48dd03156" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但需要用户提供平等谓语。</target>
        </trans-unit>
        <trans-unit id="210217c8f0159a82488ae5aab8cb5e35cf178bf9" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。特别是，它不返回 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 而是返回任何作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例的类型。但是，它的效率比 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 差。</target>
        </trans-unit>
        <trans-unit id="5f0dc6a5ad6bfd25e9bea807673a76890fa48497" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">上）。所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表，并插入该元件到列表中在所述第一位置，在其小于或等于所述下一个元素。特别是，如果列表在调用之前排序，则结果也将排序。这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="c3afabf0106af3fe4e53fef7849c2befc5d24bc8" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">上）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表和`点缀的列表的元素之间的元件。例如，</target>
        </trans-unit>
        <trans-unit id="c8f7a2b4ac8edf7f65996f45e45238e7654a6a8b" translate="yes" xml:space="preserve">
          <source>O(n). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">上）。在 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有最终段，最长的第一。例如，</target>
        </trans-unit>
        <trans-unit id="d2429730dc6a42eb0c6a71c287aab27365db1896" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the map. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">上）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现地图的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="bfa2e61261498c9b3a9c1d95d6d6c8c7f045984d" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the map. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现地图的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="aa293bddcca691e10c583ab7eb22557c613ef199" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the map. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现地图的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="3307bd4f4ef6829ef4be8f3a64ed42b0e6348c5a" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">上）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="1e19c399e5ec72b22fa5e9e212b3f04b3d856870" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="fd357f6215bda7776dac7c4bf7ae6593238c1e1a" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="831d42878394a9a0d4ea363502b8a5dd7e6cba2e" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">上）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="648df4fcaa104208481e88bc7693b141962f74e9" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="0e0cc84cc8f0ad83a0585c4f6a897d5635143e38" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="1bf0dd685c64224551ec47eef3c51bd8a8276bcd" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt;) shows the tree that implements the map. Elements are shown using the &lt;code&gt;showElem&lt;/code&gt; function. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">上）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt; ）显示实现地图的树。使用 &lt;code&gt;showElem&lt;/code&gt; 函数显示元素。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="56f0cde755d4f17130983af6ad45b003dff4a553" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt;) shows the tree that implements the map. Elements are shown using the &lt;code&gt;showElem&lt;/code&gt; function. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt; ）显示实现地图的树。使用 &lt;code&gt;showElem&lt;/code&gt; 函数显示元素。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="3c07a3dec49a9f056671960080fb9c23cbd237e8" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt;) shows the tree that implements the map. Elements are shown using the &lt;code&gt;showElem&lt;/code&gt; function. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt; showelem hang wide map&lt;/code&gt; ）显示实现地图的树。使用 &lt;code&gt;showElem&lt;/code&gt; 函数显示元素。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="7888e014ff70e7da6951568cde6d193cdf7e76d0" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;showTreeWith hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">上）。表达式（ &lt;code&gt;showTreeWith hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="1a39d4aadf2415d3ca8e7782698cd0da4aaeef91" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;showTreeWith hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;showTreeWith hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="f51f1440ab42f2e4b7fa008b14673abae027bcce" translate="yes" xml:space="preserve">
          <source>O(n). The expression (&lt;code&gt;showTreeWith hang wide map&lt;/code&gt;) shows the tree that implements the set. If &lt;code&gt;hang&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a &lt;em&gt;hanging&lt;/em&gt; tree is shown otherwise a rotated tree is shown. If &lt;code&gt;wide&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, an extra wide version is shown.</source>
          <target state="translated">在）。表达式（ &lt;code&gt;showTreeWith hang wide map&lt;/code&gt; ）显示实现该集合的树。如果 &lt;code&gt;hang&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则显示&lt;em&gt;悬挂的&lt;/em&gt;树，否则显示旋转的树。如果 &lt;code&gt;wide&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，那么将显示一个额外的版本。</target>
        </trans-unit>
        <trans-unit id="4a3b936d7a2a3abf4106e26a74b1016792d526db" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 函数以键的升序在映射中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="24303720e3b3efb5d3fa3de3a33c863550062b1b" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的降序在地图中穿插一个累加参数。</target>
        </trans-unit>
        <trans-unit id="e30c90b941aefaaec19001464154f4f386904d0c" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的升序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="be5d31fd21e879811ff4b354fe058f2becedf771" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 函数以键的升序在映射中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="b7bda8ed7f65711bca9f979c83cf84ee6549e77e" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的降序在地图中穿插一个累加参数。</target>
        </trans-unit>
        <trans-unit id="45c5776f771ab7b4fe7f9402624ccc49e8f16dbf" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的升序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="7445f426a041c9fcafb5b12bd274a6d8e517ce70" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 函数以键的升序在映射中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="a3e3710dc20fc1999d79e16542cad6128f08a9b1" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的降序在地图中穿插一个累加参数。</target>
        </trans-unit>
        <trans-unit id="644ee7ec96c4f77595cefdcc9ad11d6644044af7" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的升序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="29c4c7f8af356ae75f35ab782687363d88d91f89" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 函数以键的升序在映射中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="eb1cd045ea0cc875abdde47b175f7c3da234a7bf" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的降序在地图中穿插一个累加参数。</target>
        </trans-unit>
        <trans-unit id="efb4101740d24939f936f917a29d61d30dfd76ca" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的升序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="e568b210fbc6e98ba452c9fff80dd6215c292bad" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccum&quot;&gt;mapAccum&lt;/a&gt;&lt;/code&gt; 函数以键的升序在映射中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="8a3f14d0bab404d5fe2260ba0b9855ab3bd68fcc" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">在）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumRWithKey&quot;&gt;mapAccumRWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的降序在地图中穿插一个累加参数。</target>
        </trans-unit>
        <trans-unit id="b522ba3d40a23738c085941f155930d8976c8fba" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; threads an accumulating argument through the map in ascending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapAccumWithKey&quot;&gt;mapAccumWithKey&lt;/a&gt;&lt;/code&gt; 函数以键的升序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="f477880ebda2d0dec0ff396ee9f082a19a4dc9a9" translate="yes" xml:space="preserve">
          <source>O(n). The function &lt;code&gt;mapAccumR&lt;/code&gt; threads an accumulating argument through the map in descending order of keys.</source>
          <target state="translated">上）。 &lt;code&gt;mapAccumR&lt;/code&gt; 函数以键的降序在地图中穿插一个累积参数。</target>
        </trans-unit>
        <trans-unit id="a53abd52488386fcd346720aa042ddcb12d8ba07" translate="yes" xml:space="preserve">
          <source>O(n). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 的非重载版本。</target>
        </trans-unit>
        <trans-unit id="defad20c6cc6143a71da5efc53c4695a5d70721a" translate="yes" xml:space="preserve">
          <source>O(n). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">上）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 的非重载版本。</target>
        </trans-unit>
        <trans-unit id="c9619cc589ba678ece69e17342f4e0ee894c4288" translate="yes" xml:space="preserve">
          <source>O(n). The set of all keys of the map.</source>
          <target state="translated">O(n)。该图的所有键的集合。</target>
        </trans-unit>
        <trans-unit id="bd0e59538306ce4d2d23d102dc288ea1dea4874c" translate="yes" xml:space="preserve">
          <source>O(n). Traverse keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">上）。遍历键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="940f7036d1cd131308f7f749b45a120398ccb158" translate="yes" xml:space="preserve">
          <source>O(n). Traverse keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。遍历键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="4dbfc5977abe13db42c0d838f60020d8d7e64394" translate="yes" xml:space="preserve">
          <source>O(n). Traverse keys/values and collect the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; results.</source>
          <target state="translated">在）。遍历键/值并收集 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="dd87eb599d9b5e6d71506fd91c6fd4256d0a7111" translate="yes" xml:space="preserve">
          <source>O(n). partition the set according to some predicate.</source>
          <target state="translated">O(n).根据某个谓词对集合进行分割。</target>
        </trans-unit>
        <trans-unit id="a6d18da55bd04db6f9b044076b9fc0b37e85d962" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to (:) for lists, but of different complexity, as it requires making a copy.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 与列表的（:)类似，但复杂度不同，因为它需要进行复制。</target>
        </trans-unit>
        <trans-unit id="e87133507bf78c9e7a16270bfef3263e3368d0ef" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 成员资格谓词。</target>
        </trans-unit>
        <trans-unit id="fd3b0b58e2a7e1a52b5bc4c356abfb5643405318" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和ByteString的O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个ByteString，其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="6780da47a89a67bb9f3cf2a8d2655bfad738a16e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的ByteString 。</target>
        </trans-unit>
        <trans-unit id="607c54f2d193454c7f49eac5713df114d2e0a454" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; This function will fuse. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回最大值。该函数将融合。空ByteString的情况下将引发异常。</target>
        </trans-unit>
        <trans-unit id="420f486298b5ea93389bc61a46e136d81c208a50" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; This function will fuse. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回最小值。此函数将融合。空ByteString的情况下将引发异常。</target>
        </trans-unit>
        <trans-unit id="904125c9bd5092c22065ec505bcda6e71336cebf" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的逆</target>
        </trans-unit>
        <trans-unit id="aadb1f7c5dc7e9de99f1a8013f57ab676303dfcc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element. The following holds:</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n x&lt;/code&gt; 是长度为 &lt;code&gt;n&lt;/code&gt; 的ByteString，其中 &lt;code&gt;x&lt;/code&gt; 是每个元素的值。以下内容成立：</target>
        </trans-unit>
        <trans-unit id="994f3cbfc5291a1e3c33531cf7ff5c9675e44117" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; efficiently returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 有效地返回的元素 &lt;code&gt;xs&lt;/code&gt; 以相反的顺序。</target>
        </trans-unit>
        <trans-unit id="6b03bb07227481e418e2cb9f9128b364e6ce78ac" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 将一对字节对的列表转换为一对ByteString。请注意，这将执行两次 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="e084291cb5bb6d7c40375664b0d9ba69b4daa281" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个ByteString，并返回相应的字节对列表。如果一个输入ByteString较短，则丢弃较长ByteString的多余元素。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="897f57bc1efb2a7b246b139b7d17f9f8b7289669" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to (:) for lists, but of different complexity, as it requires a memcpy.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 与列表的（:)类似，但复杂度不同，因为它需要一个memcpy。</target>
        </trans-unit>
        <trans-unit id="8e061223a14e5f7b418f9492129f20987fd40f17" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate. This implementation uses &lt;code&gt;memchr(3)&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 成员资格谓词。此实现使用 &lt;code&gt;memchr(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9c3cdee5acc43da1a053ba8975941b35050215" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和ByteString的O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个ByteString，其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="3366778fe3aa7fdde841f790f970185cb85baec8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的ByteString</target>
        </trans-unit>
        <trans-unit id="a87438b3c1567d01fa16af6be1c70eb11f879c41" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的逆</target>
        </trans-unit>
        <trans-unit id="e50638915a675c05dec99d62a49a89f284909123" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element. The following holds:</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n x&lt;/code&gt; 是长度为 &lt;code&gt;n&lt;/code&gt; 的ByteString，其中 &lt;code&gt;x&lt;/code&gt; 是每个元素的值。以下内容成立：</target>
        </trans-unit>
        <trans-unit id="7dc7b4001e51ca96d33790d4fa04c8097941e947" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; efficiently returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 有效地返回的元素 &lt;code&gt;xs&lt;/code&gt; 以相反的顺序。</target>
        </trans-unit>
        <trans-unit id="c49843235184b635597fc6bc634328f58d39343f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of Chars. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations, and so space usage may be large for multi-megabyte ByteStrings</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接受两个ByteString，并返回相应的Chars对列表。如果一个输入ByteString较短，则丢弃较长ByteString的多余元素。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作，因此，对于数兆字节的ByteString，空间使用可能会很大</target>
        </trans-unit>
        <trans-unit id="be1ae7748e6f0f64f8d41767e7d09afa52892d1d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 成员资格谓词。</target>
        </trans-unit>
        <trans-unit id="e83bf67f47bcd12cb10b1c88852ce603cef046e6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和ByteString的O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个ByteString，其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="594f41e365f4c84a617876e5d010b0f3bf6c029f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的ByteString 。</target>
        </trans-unit>
        <trans-unit id="637cb1e10be19103636ce06997ee5ab857d94fe8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回最大值</target>
        </trans-unit>
        <trans-unit id="8c7604309eb5230fdf9522bd24f18245bf75a51f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回最小值</target>
        </trans-unit>
        <trans-unit id="8f6ee8aeb4568fc4aa387603741be339ec3cac76" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的逆</target>
        </trans-unit>
        <trans-unit id="813ee49a0e4d52fdb3ae8304d21d3ac2df4dcbc8" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; 是一个长度为 &lt;code&gt;n&lt;/code&gt; 的ByteString，其中 &lt;code&gt;x&lt;/code&gt; 是每个元素的值。</target>
        </trans-unit>
        <trans-unit id="0e0dc3ba246d837d3a9b010550f249679050f953" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 以相反顺序返回 &lt;code&gt;xs&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="9202ad8e3b4632caa08f6f34bfd27121728ab275" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 将一对字节对的列表转换为一对ByteString。请注意，这将执行两次 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="5a9da1672e7f1b5b674d8afdd2354b04ab7243f5" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个ByteString，并返回相应的字节对列表。如果一个输入ByteString较短，则丢弃较长ByteString的多余元素。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="c42bf137e10bf436f58e738df9dc0464ac9bd42a" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; membership predicate. This implementation uses &lt;code&gt;memchr(3)&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 成员资格谓词。此实现使用 &lt;code&gt;memchr(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91c53f865408d000f101db6acde868e970f9c430" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和ByteString的O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个ByteString，其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="b8ba031b9efd1026d26f073281d08fc3e760438e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the ByteString obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的ByteString</target>
        </trans-unit>
        <trans-unit id="b7aa51e2a6c207eddcadb3119c3b5db7b3f75278" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; is the inverse of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的逆</target>
        </trans-unit>
        <trans-unit id="e8ebd28624996cb8f5222d45ff82209729d29cac" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; is a ByteString of length &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; the value of every element.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:replicate&quot;&gt;replicate&lt;/a&gt; n x&lt;/code&gt; 是一个长度为 &lt;code&gt;n&lt;/code&gt; 的ByteString，其中 &lt;code&gt;x&lt;/code&gt; 是每个元素的值。</target>
        </trans-unit>
        <trans-unit id="0c9ad4f094aa254f69c6092bea03e198e42c0f2e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;xs&lt;/code&gt; returns the elements of &lt;code&gt;xs&lt;/code&gt; in reverse order.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;xs&lt;/code&gt; 以相反顺序返回 &lt;code&gt;xs&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="1025a51d54a7b411e304766783043b2c8c9ebe8c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two ByteStrings and returns a list of corresponding pairs of Chars. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations, and so space usage may be large for multi-megabyte ByteStrings</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接受两个ByteString，并返回相应的Chars对列表。如果一个输入ByteString较短，则丢弃较长ByteString的多余元素。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作，因此，对于数兆字节的ByteString，空间使用可能会很大</target>
        </trans-unit>
        <trans-unit id="47f1f808b1116798948bf6e17810a76c4c27a281" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="507dcd4c5ffbdf85b7afecdfbd6ffb348b3f2a12" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。接受融合。</target>
        </trans-unit>
        <trans-unit id="79c7f6fabdbf2741f226cec77b19c2ed76fa0d43" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether all characters in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 确定 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 中的所有字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="7eba5fc089d3982c308520a95c1f77dd2130c7b0" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether any character in the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 确定 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 中的任何字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="f81c7ff9cb185390d27d39f40c6e350881c76f10" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, but the prefix returned is over elements that fail the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; 就像 &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 一样，但是返回的前缀超过了谓词 &lt;code&gt;p&lt;/code&gt; 失败的元素。</target>
        </trans-unit>
        <trans-unit id="2a401e4a49118c11b4758cd5236552b720cf3223" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the suffix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is greater than the length of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，返回的后缀 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 第一后 &lt;code&gt;n&lt;/code&gt; 字符，或者空 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;n&lt;/code&gt; 比的长度大 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="62638e9e2515ce80c16e9bbd4d722902b80a7bde" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the substring remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from both the beginning and end of &lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的开头和结尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后剩余的子字符串。受到融合。</target>
        </trans-unit>
        <trans-unit id="50b676b0a4a9eff6b367ed39fc8ad50da4c80c8d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾删除 &lt;code&gt;n&lt;/code&gt; 个字符后剩余的前缀。</target>
        </trans-unit>
        <trans-unit id="80990f9067babc8c1a96660ef6ad72b05b11abd6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回在 &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 之后剩余的后缀。受到融合。</target>
        </trans-unit>
        <trans-unit id="1e6c16939d4c355b6e4010f481ae78113c01265d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后剩余的前缀。</target>
        </trans-unit>
        <trans-unit id="ae97f194eb0bb99602ab124ca73db33a4929d2a1" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from the end of &lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 从 &lt;code&gt;t&lt;/code&gt; 的末尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后，返回剩余的前缀。受到融合。</target>
        </trans-unit>
        <trans-unit id="fba89c9273cb01a6feeeb52ba105e8c263324589" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="36718733e2bd35c6068adc8721e8015ecae35c23" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the left-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from left to right. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，起始值（通常是运算符的左标识）和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，使用二进制运算符从左到右 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="9e93d3274aad02da381d77d8727f4a8d9bec1df6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the right-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from right to left. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，起始值（通常是运算符的右标识）和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，使用二进制运算符从右到左 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="53340410ef80985b02395b3f73c6037ec5158b5a" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;t&lt;/code&gt; 的每个元素而获得的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3392997e6a37b5ea492369dbab6c9d285c75f9bb" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 返回最大值，该Text必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="e0d5d05610018479cf03a721cc8f0d3b278d43cc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 返回最小值，该最小值必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="ce440d86acb7656e3a075deae33e810590daf9ef" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="1602e01d9551438052ee00621c4ff0186d8aa39b" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 不具有初始值的参数。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="a802a82d4cb6533dfbd873bc1518cfdd2fa96a42" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 不具有初始值的参数。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="0b02a62da4052d8e51d2387f68f561b76b8e2e71" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）的 &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;data-text#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="dd59edc8b679e21a5fc719bf31908c07caed4a38" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是没有初始值参数的 &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 的变体。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="c206687b879c81144a6cc7e054706c4fe453fb0f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是没有初始值参数的 &lt;code&gt;&lt;a href=&quot;data-text#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 的变体。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="793a30afbe1bb62bb4bbc71da7c935274e7fdd02" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and text &lt;code&gt;t&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;t&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;, and whose second is the remainder of the list.</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和文本 &lt;code&gt;t&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 返回一个对，第一个元素是满足 &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;t&lt;/code&gt; 中最长的前缀（可能为空），第二个元素是列表的其余部分。</target>
        </trans-unit>
        <trans-unit id="e876383d6fe4d4cf57cb2e995578fddd8df3eb2e" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n t&lt;/code&gt; returns a pair whose first element is a prefix of &lt;code&gt;t&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, and whose second is the remainder of the string. It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n t&lt;/code&gt; 返回一对，其第一个元素是长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;t&lt;/code&gt; 的前缀，第二个元素为字符串的其余部分。等效于 &lt;code&gt;(&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt; &lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt; nt，&lt;a href=&quot;data-text#v:drop&quot;&gt;drop&lt;/a&gt; nt）。</target>
        </trans-unit>
        <trans-unit id="724c5a910dc02d1935ca3c0e9f3d61da582138ff" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the prefix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the Text. Subject to fusion.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，返回的前缀 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 本身如果 &lt;code&gt;n&lt;/code&gt; 大于文本的长度大。受到融合。</target>
        </trans-unit>
        <trans-unit id="e63ef89c44ffb426bb835c53ad49105c6cc4f6c3" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after taking &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾取 &lt;code&gt;n&lt;/code&gt; 个字符后剩余的后缀。</target>
        </trans-unit>
        <trans-unit id="e92dcc54a916468d23b42ca137f26aeb26550c73" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest prefix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的最长前缀（可能为空）。受到融合。</target>
        </trans-unit>
        <trans-unit id="aaa1f8a3e08b881dfc79f5d52ff65332b0fa61cd" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest suffix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Examples:</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt; 返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的最长后缀（可能为空）。例子：</target>
        </trans-unit>
        <trans-unit id="a2e3606f4f01d7e5a10ca68ed180b1abf7fa753a" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest suffix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Subject to fusion. Examples:</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt; 返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的最长后缀（可能为空）。受到融合。例子：</target>
        </trans-unit>
        <trans-unit id="ad3be8f0faa9bd5d4aa2e5d20f35304c380828e9" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns a list of corresponding pairs of bytes. If one input &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is short, excess elements of the longer &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回相应的字节对列表。如果一个输入 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 短，则较长 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 多余元素将被丢弃。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-text#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="af939213fd5b0f6bd31b51acd6695dbeb5ffdb19" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数而不是tupling函数对zip进行 &lt;code&gt;&lt;a href=&quot;data-text#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括zip。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="da4aeeaabfc5ed693c1e151384a746ca87c72217" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:drop&quot;&gt;drop&lt;/a&gt; n&lt;/code&gt;, applied to a stream, returns the suffix of the stream after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty stream if &lt;code&gt;n&lt;/code&gt; is greater than the length of the stream.</source>
          <target state="translated">应用于流的O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:drop&quot;&gt;drop&lt;/a&gt; n&lt;/code&gt; 返回前 &lt;code&gt;n&lt;/code&gt; 个字符后的流后缀；如果 &lt;code&gt;n&lt;/code&gt; 大于流的长度，则返回空流。</target>
        </trans-unit>
        <trans-unit id="9fa687005bdc593df76bb72517e1b521d29d2d20" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; is the stream membership predicate.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 是流成员谓词。</target>
        </trans-unit>
        <trans-unit id="2b77afc64a7bb85e8690139a4da22ea45eedc543" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a stream, returns a stream containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和流的O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回包含满足谓词的那些字符的流。</target>
        </trans-unit>
        <trans-unit id="0f5ad5c44e1631f865afdc5530f0bd7da572556c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f &lt;/code&gt;xs is the Stream Char obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f &lt;/code&gt; xs是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的流Char 。</target>
        </trans-unit>
        <trans-unit id="21beeb85fff56f2a29dc2595d7cacf25e1f49ff2" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:take&quot;&gt;take&lt;/a&gt; n&lt;/code&gt;, applied to a stream, returns the prefix of the stream of length &lt;code&gt;n&lt;/code&gt;, or the stream itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the stream.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:take&quot;&gt;take&lt;/a&gt; n&lt;/code&gt; 应用于流，返回长度为 &lt;code&gt;n&lt;/code&gt; 的流的前缀，如果 &lt;code&gt;n&lt;/code&gt; 大于流的长度，则返回流本身。</target>
        </trans-unit>
        <trans-unit id="ec5345d4b738007ae4d0718330b8753d2fd5d334" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="8963168f0bc112575b88fa986522b23655ce5f29" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。接受融合。</target>
        </trans-unit>
        <trans-unit id="52001832e9a111e63388c13d8c78741fd22c16dc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether all characters in the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfy the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 确定 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 中的所有字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="a80deb53f3ff5102554537a88ab56ecdbe9919f6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; determines whether any character in the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; satisfies the predicate &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 确定 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 中的任何字符是否满足谓词 &lt;code&gt;p&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="843af696b2b94016c6c577af94d3025d3394bc28" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, but the prefix returned is over elements that fail the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:break&quot;&gt;break&lt;/a&gt;&lt;/code&gt; 就像 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 一样，但是返回的前缀超过了谓词 &lt;code&gt;p&lt;/code&gt; 失败的元素。</target>
        </trans-unit>
        <trans-unit id="8015cbe0acbd22d830807b751205bb9541efeb95" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the suffix of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; characters, or the empty &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is greater than the length of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，返回的后缀 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 第一后 &lt;code&gt;n&lt;/code&gt; 字符，或者空 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;n&lt;/code&gt; 比的长度大 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="803c2a3577d64fc8b7b535621c173f7322d98ae4" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the substring remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from both the beginning and end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的开头和结尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后剩余的子字符串。</target>
        </trans-unit>
        <trans-unit id="4da52596bae25a03fe4d5fcfd6d854401bfc5821" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the substring remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from both the beginning and end of &lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropAround&quot;&gt;dropAround&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的开头和结尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后剩余的子字符串。受到融合。</target>
        </trans-unit>
        <trans-unit id="8b8335a4c8467eeeadac078c96149b316651e93c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropEnd&quot;&gt;dropEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾删除 &lt;code&gt;n&lt;/code&gt; 个字符后剩余的前缀。</target>
        </trans-unit>
        <trans-unit id="d9a32767a767b136763342cc8fed3626bdf438b4" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhile&quot;&gt;dropWhile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回在 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 之后剩余的后缀。受到融合。</target>
        </trans-unit>
        <trans-unit id="89b4db52cdaace3419e13833e1e5f48543f35232" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the prefix remaining after dropping characters that satisfy the predicate &lt;code&gt;p&lt;/code&gt; from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾删除满足谓词 &lt;code&gt;p&lt;/code&gt; 的字符后剩余的前缀。</target>
        </trans-unit>
        <trans-unit id="71d3f9fc45ab8bc303bb4565aef5df7a8ab861d7" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; containing those characters that satisfy the predicate.</source>
          <target state="translated">应用于谓词和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 返回一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,其中包含满足谓词的那些字符。</target>
        </trans-unit>
        <trans-unit id="84c8b4d29979d85554d7904ebbaab64e20a7bd42" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the left-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from left to right. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，起始值（通常是运算符的左标识）和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，使用二进制运算符从左到右 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="32828db51b3f1d98312c38de9aa152cd0b245c37" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, applied to a binary operator, a starting value (typically the right-identity of the operator), and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, reduces the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; using the binary operator, from right to left. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，起始值（通常是运算符的右标识）和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，使用二进制运算符从右到左 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="b9547085ec7aae34af4b82fa0951d92170eb8a3d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;t&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;t&lt;/code&gt; 的每个元素而获得的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="275d34f83778a74e1a4c86f88fdbe41d09ac601c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; returns the maximum value from a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:maximum&quot;&gt;maximum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 返回最大值，该Text必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="aab0542c71645f606c2c21ed062d6c45d54fd679" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; returns the minimum value from a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:minimum&quot;&gt;minimum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 返回最小值，该最小值必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="8c2f9f716605703cc16d79787eb6433b44544b74" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the elements of &lt;code&gt;t&lt;/code&gt; in reverse order.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 以相反顺序返回 &lt;code&gt;t&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="290e19543b06aa470e6e00fa1777da74ca666bcb" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="bfbae6d3a43ef1d2a9cfee5b582edbbb5f448c1d" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 不具有初始值的参数。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="96ad6aeb8b2e98cf441e1d6939ad433053c60b72" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 不具有初始值的参数。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="752730ad120352a67964470bec9296c38933d9a6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="defff53dbc7d598b9a15f139c156778912a78cf7" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是没有初始值参数的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 的变体。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="ec22df8af2b3913cd31c2ff7b32450ee597a62ce" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and text &lt;code&gt;t&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;t&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;, and whose second is the remainder of the list.</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和文本 &lt;code&gt;t&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:span&quot;&gt;span&lt;/a&gt;&lt;/code&gt; 返回一个对，第一个元素是满足 &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;t&lt;/code&gt; 中最长的前缀（可能为空），第二个元素是列表的其余部分。</target>
        </trans-unit>
        <trans-unit id="ed213541644726c53144685282a501ecf21fc2ba" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n t&lt;/code&gt; returns a pair whose first element is a prefix of &lt;code&gt;t&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, and whose second is the remainder of the string. It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n t&lt;/code&gt; 返回一对，其第一个元素是长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;t&lt;/code&gt; 的前缀，第二个元素为字符串的其余部分。等效于 &lt;code&gt;(&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt; n t, &lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n t)&lt;/code&gt; &lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt; nt，&lt;a href=&quot;data-text-lazy#v:drop&quot;&gt;drop&lt;/a&gt; nt）。</target>
        </trans-unit>
        <trans-unit id="2a4e6688874ddaf9782c32f74b5af00856d6162c" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the prefix of the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; itself if &lt;code&gt;n&lt;/code&gt; is greater than the length of the Text. Subject to fusion.</source>
          <target state="translated">为O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，返回的前缀 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 本身如果 &lt;code&gt;n&lt;/code&gt; 大于文本的长度大。受到融合。</target>
        </trans-unit>
        <trans-unit id="fafb109ed736e9539678dc223045f998ecc60586" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; returns the suffix remaining after taking &lt;code&gt;n&lt;/code&gt; characters from the end of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeEnd&quot;&gt;takeEnd&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 返回从 &lt;code&gt;t&lt;/code&gt; 的末尾取 &lt;code&gt;n&lt;/code&gt; 个字符后剩余的后缀。</target>
        </trans-unit>
        <trans-unit id="48231e4265962339b40bf2779c38705e16bb89c6" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest prefix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhile&quot;&gt;takeWhile&lt;/a&gt;&lt;/code&gt; 返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的最长前缀（可能为空）。受到融合。</target>
        </trans-unit>
        <trans-unit id="0fbcec5531082dc0f76c85517fe246d924a8b4d5" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, returns the longest suffix (possibly empty) of elements that satisfy &lt;code&gt;p&lt;/code&gt;. Examples:</source>
          <target state="translated">应用于谓词 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:takeWhileEnd&quot;&gt;takeWhileEnd&lt;/a&gt;&lt;/code&gt; 返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的最长后缀（可能为空）。例子：</target>
        </trans-unit>
        <trans-unit id="b425ee4e8c05b3cda0ff6d30f9b09d52f8c568cc" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns a list of corresponding pairs of bytes. If one input &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is short, excess elements of the longer &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; are discarded. This is equivalent to a pair of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ,并返回相应的字节对列表。如果一个输入 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 短，则较长 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 多余元素将被丢弃。这等效于一对 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="1581c28e8613b72990177d99cabcdaa4473b802f" translate="yes" xml:space="preserve">
          <source>O(n)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数而不是tupling函数对zip进行 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括zip。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="064939379eae2c6be3abdbb7b12833cf140eacf3" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="e8edcb9f3b9ce9874d0f50df16eaf453e97b5522" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="1d21400b6e833afb6bf8143413e415596fc7e8c2" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="10c506dbf93fa334d9a419951daf58b88553c5ad" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="f834fc8764b608e3a2c7e67729ea839011b86b0d" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="55b64ce77eb583b2a8d7e0008229894a3efce603" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="ef55ea6e8a459abefacb74a290038f5ce0831ec8" translate="yes" xml:space="preserve">
          <source>O(n*log n). &lt;code&gt;&lt;a href=&quot;data-set#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。 &lt;code&gt;&lt;a href=&quot;data-set#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个元素而获得的集合。</target>
        </trans-unit>
        <trans-unit id="e21338981ac62324a8ffb888033d85823da92462" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。使用组合功能从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b4ee600b68a1b413680c347347b72d52a62b248" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。使用组合功能从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2b6445f60417018f5403793c1dd9664c415e81b" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。使用组合功能从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54ee44c25d5df18f80f0b752d11418a6db2d26b9" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * log n）。使用组合功能从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscListWithKey&quot;&gt;fromAscListWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1342a9ab083de169557710a30b3fad7ae6c99e26" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt;. If the list contains more than one value for the same key, the last value for the key is retained.</source>
          <target state="translated">O（n * log n）。从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt; 。如果列表包含同一键的多个值，则保留键的最后一个值。</target>
        </trans-unit>
        <trans-unit id="02e2cd705835954197360bd74e3af96c7c963564" translate="yes" xml:space="preserve">
          <source>O(n*log n). Build a map from a list of key/value pairs. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt;. If the list contains more than one value for the same key, the last value for the key is retained.</source>
          <target state="translated">O（n * log n）。从键/值对列表中构建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromAscList&quot;&gt;fromAscList&lt;/a&gt;&lt;/code&gt; 。如果列表包含同一键的多个值，则保留键的最后一个值。</target>
        </trans-unit>
        <trans-unit id="b1bd3b225b2e28c124d8bb6bccbf13d7c9843e1d" translate="yes" xml:space="preserve">
          <source>O(n*log n). Create a set from a list of elements.</source>
          <target state="translated">O(n*log n)。从元素列表中创建一个集合。</target>
        </trans-unit>
        <trans-unit id="cf816e1e72765d7793512d1bd9c75675ccb813e8" translate="yes" xml:space="preserve">
          <source>O(n*m)&lt;code&gt;&lt;a href=&quot;data-text#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; consisting of the input &lt;code&gt;t&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">O（n * m） &lt;code&gt;&lt;a href=&quot;data-text#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 由重复 &lt;code&gt;n&lt;/code&gt; 次的输入 &lt;code&gt;t&lt;/code&gt; 组成。</target>
        </trans-unit>
        <trans-unit id="496aa72cda3836a07a9a2fe26ce5be56819c8747" translate="yes" xml:space="preserve">
          <source>O(n*m)&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; consisting of the input &lt;code&gt;t&lt;/code&gt; repeated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">O（n * m） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 由重复 &lt;code&gt;n&lt;/code&gt; 次的输入 &lt;code&gt;t&lt;/code&gt; 组成。</target>
        </trans-unit>
        <trans-unit id="5b88b501d9cd1a51f539e06a9f8b52a7518aed37" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="c825c89428e8aaee3dd58c3c0ed678ebb02559f4" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; ，但仅当 &lt;code&gt;f&lt;/code&gt; 严格单调时才有效。也就是说，对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何值，如果 &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 则 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; 。&lt;em&gt;不检查前提条件。&lt;/em&gt;半正式地，我们有：</target>
        </trans-unit>
        <trans-unit id="99b60a72b8c0e9adf3019aa8dfa7569bd4a92c32" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeysWith&quot;&gt;mapKeysWith&lt;/a&gt; c f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="c969970b95ecd5a60d39d789b9e1e9987b1bb4dd" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="41ebfbb8f2b447294a3e1e314695a58f6931431c" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; ，但仅当 &lt;code&gt;f&lt;/code&gt; 严格单调时才有效。也就是说，对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何值，如果 &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 则 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; 。&lt;em&gt;不检查前提条件。&lt;/em&gt;半正式地，我们有：</target>
        </trans-unit>
        <trans-unit id="1f74203ecf6c5e6aa71439f7d49b6b4738761859" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; is the map obtained by applying &lt;code&gt;f&lt;/code&gt; to each key of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个键而获得的映射。</target>
        </trans-unit>
        <trans-unit id="e8c92eb26aefeaf7f5adf2cafbf52ebcc77c3862" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt;, but works only when &lt;code&gt;f&lt;/code&gt; is strictly monotonic. That is, for any values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, if &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt;. &lt;em&gt;The precondition is not checked.&lt;/em&gt; Semi-formally, we have:</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeysMonotonic&quot;&gt;mapKeysMonotonic&lt;/a&gt; f s == &lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt; f s&lt;/code&gt; ，但仅当 &lt;code&gt;f&lt;/code&gt; 严格单调时才有效。也就是说，对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何值，如果 &lt;code&gt;x&lt;/code&gt; &amp;lt; &lt;code&gt;y&lt;/code&gt; 则 &lt;code&gt;f x&lt;/code&gt; &amp;lt; &lt;code&gt;f y&lt;/code&gt; 。&lt;em&gt;不检查前提条件。&lt;/em&gt;半正式地，我们有：</target>
        </trans-unit>
        <trans-unit id="9100fd3a27e166f348e6cd61f6a291f6e0417995" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intset#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intset#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个元素而获得的集合。</target>
        </trans-unit>
        <trans-unit id="d205ac9d99bcd11ba10bdf3d053d0d44937ca6ca" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; is the set obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:map&quot;&gt;map&lt;/a&gt; f s&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;s&lt;/code&gt; 的每个元素而获得的集合。</target>
        </trans-unit>
        <trans-unit id="d619d90fc5b48cf5af644e6dcbb4f68f4674b874" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'.</source>
          <target state="translated">O(n*min(n,W))。用组合函数从键/值对的列表中建立一个映射。参见 fromAscListWithKey'。</target>
        </trans-unit>
        <trans-unit id="6a2422ae977d3f41d77926cd0791db18ae04e3ec" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。使用组合功能从键/值对列表中创建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5049b4311dd1d4031e503c8eb3922c754e897945" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。使用组合功能从键/值对列表中创建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bea1f51f900a25425eba0fd0046a89d1236cf0a" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n * min（n，W））。使用组合功能从键/值对列表中创建地图。另请参见 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:fromAscListWith&quot;&gt;fromAscListWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e34b3e78c63542e8bb8d0adde3243e4615d23d" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a map from a list of key/value pairs.</source>
          <target state="translated">O(n*min(n,W))。从键/值对的列表中创建一个映射。</target>
        </trans-unit>
        <trans-unit id="b7a6efb65f9b82dfbe8c913159082518b7d595ff" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). Create a set from a list of integers.</source>
          <target state="translated">O(n*min(n,W))。从整数列表中创建一个集合。</target>
        </trans-unit>
        <trans-unit id="b9feaf7c13d0928ac7999068f93fb53410e85f11" translate="yes" xml:space="preserve">
          <source>O(n*min(n,W)). The set of all keys of the map.</source>
          <target state="translated">O(n*min(n,W))。该图的所有键的集合。</target>
        </trans-unit>
        <trans-unit id="36e608696cdf9e28e6a2b62b32b357e3d0dad570" translate="yes" xml:space="preserve">
          <source>O(n+m) Find all non-overlapping instances of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt;. Each element of the returned list consists of a pair:</source>
          <target state="translated">O（n + m）在 &lt;code&gt;haystack&lt;/code&gt; 查找所有不重叠的 &lt;code&gt;needle&lt;/code&gt; 实例。返回列表的每个元素都由一对组成：</target>
        </trans-unit>
        <trans-unit id="b44547ebca41c66fe9bd023df1af24399976630d" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the first instance of &lt;code&gt;needle&lt;/code&gt; (which must be non-&lt;code&gt;&lt;a href=&quot;data-text#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;) in &lt;code&gt;haystack&lt;/code&gt;. The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt; is matched. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, starting with the match.</source>
          <target state="translated">O（n + m ）在 &lt;code&gt;haystack&lt;/code&gt; 查找 &lt;code&gt;needle&lt;/code&gt; 的第一个实例（必须为非 &lt;code&gt;&lt;a href=&quot;data-text#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; ）。返回的元组的第一个元素是在 &lt;code&gt;needle&lt;/code&gt; 被匹配之前的 &lt;code&gt;haystack&lt;/code&gt; 的前缀。第二个是从比赛开始的 &lt;code&gt;haystack&lt;/code&gt; 的其余部分。</target>
        </trans-unit>
        <trans-unit id="65c9466c31e6549336e0668edfa4ccca44c0acb5" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the first instance of &lt;code&gt;needle&lt;/code&gt; (which must be non-&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;) in &lt;code&gt;haystack&lt;/code&gt;. The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt; is matched. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, starting with the match.</source>
          <target state="translated">O（n + m ）在 &lt;code&gt;haystack&lt;/code&gt; 查找 &lt;code&gt;needle&lt;/code&gt; 的第一个实例（必须为非 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; ）。返回的元组的第一个元素是在 &lt;code&gt;needle&lt;/code&gt; 被匹配之前的 &lt;code&gt;haystack&lt;/code&gt; 的前缀。第二个是从比赛开始的 &lt;code&gt;haystack&lt;/code&gt; 的其余部分。</target>
        </trans-unit>
        <trans-unit id="5a5717f7a8e94cdda15365780f80755eeaf720de" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the offsets of all non-overlapping indices of &lt;code&gt;needle&lt;/code&gt; within &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">O（N + M）查找所有非重叠索引的偏移 &lt;code&gt;needle&lt;/code&gt; 内 &lt;code&gt;haystack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf145a14b4d45ba3bdedb33baa39b464e5635f5b" translate="yes" xml:space="preserve">
          <source>O(n+m) Find the offsets of all non-overlapping indices of &lt;code&gt;needle&lt;/code&gt; within &lt;code&gt;haystack&lt;/code&gt;. The offsets returned represent uncorrected indices in the low-level &quot;needle&quot; array, to which its offset must be added.</source>
          <target state="translated">O（N + M）查找所有非重叠索引的偏移 &lt;code&gt;needle&lt;/code&gt; 内 &lt;code&gt;haystack&lt;/code&gt; 。返回的偏移量表示必须在其上添加偏移量的低级&amp;ldquo; needle&amp;rdquo;数组中的未校正索引。</target>
        </trans-unit>
        <trans-unit id="e3c9d725275f03324a3b2fdda6f1f233ef3169f0" translate="yes" xml:space="preserve">
          <source>O(n+m) Similar to &lt;code&gt;&lt;a href=&quot;data-text#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt;, but searches from the end of the string.</source>
          <target state="translated">O（n + m）类似于 &lt;code&gt;&lt;a href=&quot;data-text#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt; ，但是从字符串的末尾开始搜索。</target>
        </trans-unit>
        <trans-unit id="1175fd5285a043c9a711ebebaffc18e9667d9a54" translate="yes" xml:space="preserve">
          <source>O(n+m) Similar to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt;, but searches from the end of the string.</source>
          <target state="translated">O（n + m）类似于 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOn&quot;&gt;breakOn&lt;/a&gt;&lt;/code&gt; ，但是从字符串的末尾开始搜索。</target>
        </trans-unit>
        <trans-unit id="c9a3b9a9ca60934ef751e0d1700fb0db56e70fe4" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; function returns the number of times the query string appears in the given &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. An empty query string is invalid, and will cause an error to be raised.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; 函数返回查询字符串出现在给定 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中的次数。空的查询字符串无效，并且将引发错误。</target>
        </trans-unit>
        <trans-unit id="dc07bd53a44d4b9fca8e25e271227f0696b1c205" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa949ee707031b36e3c5dbbfd870bf320c1d752d" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c6b4c1c1254a45cf510260aab2c0f458fa5283c" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e6cd194953d70c5fa065b8183d9f30516b0948" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; function returns the number of times the query string appears in the given &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. An empty query string is invalid, and will cause an error to be raised.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:count&quot;&gt;count&lt;/a&gt;&lt;/code&gt; 函数返回查询字符串出现在给定 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中的次数。空的查询字符串无效，并且将引发错误。</target>
        </trans-unit>
        <trans-unit id="13382ca7340a8eaf3a939b2a1ed948b0dcfdc7f0" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64f48cfabbe836a27454fffc8eb460276d03cfe7" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ceed7174ab33890874e61808d4d2b181a990f9b" translate="yes" xml:space="preserve">
          <source>O(n+m) The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">O（n + m） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数接受两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，如果第二个中的任何一个完整且完整地包含第一个，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2167067fadd513712bc42846c5d961980cc14b15" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。高性能的通用组合功能。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ，可以定义所有合并函数而不会降低效率（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 除外，其中某些节点的共享会被 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 丢失）。</target>
        </trans-unit>
        <trans-unit id="0a7b74bed8767dfd4c8cbfc6c23cdee7572f0523" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。高性能的通用组合功能。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ，可以定义所有合并函数而不会降低效率（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 除外，其中某些节点的共享会被 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 丢失）。</target>
        </trans-unit>
        <trans-unit id="b5a51f66550cd6721cfbc2055ced63ae8b5b721b" translate="yes" xml:space="preserve">
          <source>O(n+m). A high-performance universal combining function. Using &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, all combining functions can be defined without any loss of efficiency (with exception of &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, where sharing of some nodes is lost with &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。高性能的通用组合功能。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; ，可以定义所有合并函数而不会降低效率（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 除外，其中某些节点的共享会被 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 丢失）。</target>
        </trans-unit>
        <trans-unit id="c2c9d53c1a61505c507a77f11e744f10ac5321fd" translate="yes" xml:space="preserve">
          <source>O(n+m). An unsafe general combining function.</source>
          <target state="translated">O(n+m)。一个不安全的一般组合函数。</target>
        </trans-unit>
        <trans-unit id="04c17b4d406e8e7f791bcdc5e7bbabd3bda36558" translate="yes" xml:space="preserve">
          <source>O(n+m). An unsafe universal combining function.</source>
          <target state="translated">O(n+m)。一个不安全的通用组合函数。</target>
        </trans-unit>
        <trans-unit id="6904fa4f9eeb478245da7ef5b29f442d3a069927" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O（n + m）。检查两个地图的键集是否不相交（即它们的 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="fe24974c1f1cf88414158604450576321622c099" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O（n + m）。检查两个地图的键集是否不相交（即它们的 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="a401abee7ced03111b359144c8a12d3572504805" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether the key sets of two maps are disjoint (i.e. their &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O（n + m）。检查两个地图的键集是否不相交（即它们的 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="6d12ca25c9eb6961c2321d4afa8587c92934e2fb" translate="yes" xml:space="preserve">
          <source>O(n+m). Check whether two sets are disjoint (i.e. their intersection is empty).</source>
          <target state="translated">O(n+m)。检查两个集合是否不相交(即它们的交点为空)。</target>
        </trans-unit>
        <trans-unit id="c04ab65196d99d47289a58d92620f68e15fbe411" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference between two maps (based on keys).</source>
          <target state="translated">O(n+m)。两张地图之间的差值(基于键)。</target>
        </trans-unit>
        <trans-unit id="2b175850b2b4c7b73920a2bd09ee395823dfe991" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference between two sets.</source>
          <target state="translated">O(n+m)。两组之间的差值。</target>
        </trans-unit>
        <trans-unit id="642024d6eebec205fb5e23871df26affc526f51e" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function.</source>
          <target state="translated">O(n+m)。与组合函数的区别。</target>
        </trans-unit>
        <trans-unit id="e82cae1cbcc151c7d43da06a29f3d4c4dd638d8d" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于键和两个值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该元素将被丢弃（适当的设置差）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="d78a59691af3a1f463fcc648f48e7aa9af5140a2" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于该键和两个值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则元素将被丢弃（正确的设置差异）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="5a78d0fe71b5f02df83cff1c2b39913e13fc7fb6" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于该键和两个值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则元素将被丢弃（正确的设置差异）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="6a8defb5abb9dc37227acdef0ddf8e9086576b96" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于这些键的值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该元素将被丢弃（适当的设置差）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="9b9232eb6da84be956de3d86b2f9a3596b670d07" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于这些键的值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则元素将被丢弃（正确的设置差异）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="aa3327dd60e2b18f29125d77c0ebf07c9abcbf91" translate="yes" xml:space="preserve">
          <source>O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is discarded (proper set difference). If it returns (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the element is updated with a new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。与组合功能的区别。当遇到两个相等的键时，组合功能将应用于这些键的值。如果返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则元素将被丢弃（正确的设置差异）。如果返回（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则使用新值 &lt;code&gt;y&lt;/code&gt; 更新元素。</target>
        </trans-unit>
        <trans-unit id="1893b5539e545690e9ffd683494151968ad95c91" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0bcad9d148cb43a988e5d81559c7f98bfd4f571" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="259d7f16c8ef5c42b712b6bd1b6d835707d3fc6f" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fa500881115a261c32e171d67351b5d2ec39a167" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="086a4885e056a23c714c075d705073db4b763166" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2138264ca5a69c674ef74f75c67f797ba1ec15ee" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;keys m1&lt;/code&gt; and &lt;code&gt;keys m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;keys m1&lt;/code&gt; 和 &lt;code&gt;keys m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3f52f4b27c74c68545875153116cd3df8e8618e" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="15f91d0ab0f998067f2adeb93623344211d85bda" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4ee296e35ba846bfb8e6d01544af5ef1423af02e" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;keys m1&lt;/code&gt; and &lt;code&gt;keys m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;keys m1&lt;/code&gt; 和 &lt;code&gt;keys m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d36e66134f49baa74c16748aa4fb1bc2f1b590a7" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？（即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e04f7f18a1ae2e5b701ed54d8ae7d55bbc518436" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3deb2ccad188b62a945cb7b7b2e56307b67704d7" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;keys m1&lt;/code&gt; and &lt;code&gt;keys m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。这是合适的子图吗？ （即子图，但不相等）。当 &lt;code&gt;keys m1&lt;/code&gt; 和 &lt;code&gt;keys m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4a631953f81d0e447c8fdc69cf069142667e281d" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a proper subset? (ie. a subset but not equal).</source>
          <target state="translated">O(n+m)。这是一个合适的子集吗?(即子集但不相等)。</target>
        </trans-unit>
        <trans-unit id="eebc330ada31dc89576a052f1291e0814e19b344" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是子图吗？定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="77cf7a69469399af955924e2279784b9e2604e7f" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是子图吗？定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4431560a42f73900705f2d8f975011e0f9131735" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a submap? Defined as (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。这是子图吗？定义为（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="95f1327cbb34c7f0d462f61ec2eb2bdb693eb58b" translate="yes" xml:space="preserve">
          <source>O(n+m). Is this a subset? &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; tells whether &lt;code&gt;s1&lt;/code&gt; is a subset of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。这是子集吗？ &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; 判断 &lt;code&gt;s1&lt;/code&gt; 是否为 &lt;code&gt;s2&lt;/code&gt; 的子集。</target>
        </trans-unit>
        <trans-unit id="853dab43bcbe16991732c6d4b28495ea5732e019" translate="yes" xml:space="preserve">
          <source>O(n+m). Remove all the keys in a given set from a map.</source>
          <target state="translated">O(n+m)。从一个映射中删除给定集合中的所有键。</target>
        </trans-unit>
        <trans-unit id="c1b95d70a81d94d1b2f2943a9a8a879ae12ca499" translate="yes" xml:space="preserve">
          <source>O(n+m). See &lt;code&gt;&lt;a href=&quot;data-intset#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。看 &lt;code&gt;&lt;a href=&quot;data-intset#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c0c033e78b5f044fb2891d9b4979b5fb0a3e771" translate="yes" xml:space="preserve">
          <source>O(n+m). See &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n + m）。看 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabc7bfe4185073a15a5de307d4e92518cd380a6" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) intersection of two maps (based on keys).</source>
          <target state="translated">O(n+m)。两个地图的(左偏)交点(基于键)。</target>
        </trans-unit>
        <trans-unit id="06961d5d1ab5fa2c8570a9d85046d4a05dc7eb63" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）联合。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c8af9eb1020703ed741e76dfbd54678ef12ddfe5" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="011b9913066fed07d6a46f229e61c42fdd570916" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bafc90ea33c8a530d3beef31c5367384af63f7c0" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）联合。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="06cca18a9ea62d448cb2ae8ce6046a32a6eeb7e5" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c3dff78696e4e5a334f9a2fdf3cea483345bb61" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f4ad0a244b4a8b2f49ef3d414deb4d187f9a6cc2" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）联合。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31e89469c4001a829fde3233e342d7e9eec1929b" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="981fd1e6e690d7c34e45bb128e4d01ed870f2810" translate="yes" xml:space="preserve">
          <source>O(n+m). The (left-biased) union of two maps. It prefers the first map when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（n + m）。两张地图的（左偏）并集。当遇到重复的键时，它倾向于第一个映射，即（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-intmap-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cc2918486dc9d1b3d88c95caecdcf91f0062806a" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a51544441efda5b774bf5ba7135522fa07aeb34" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e4e0c5bef0200ad49437fa8d7349e4f74061f11d" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c682f84ef41f26c41a860753eec9a7c1df03b072" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d46f07e5f2d5ba28c84ab4450e5f9330078bcc3c" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7336e2b862019149934a2a6c7b39efd4be16e2a" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28c133c2820ef14ec3aca95b5da1617ff047b0eb" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3c133848b5c3643fa590368299465506d198f3bc" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52d28d9c1a3a62fb5743ed3d390d5a867c54549c" translate="yes" xml:space="preserve">
          <source>O(n+m). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（n + m）。如果 &lt;code&gt;m1&lt;/code&gt; 中的所有键都位于 &lt;code&gt;m2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ；当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，返回f &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0f82649fd48787dfa3f6fb48e8009b24ac636f79" translate="yes" xml:space="preserve">
          <source>O(n+m). The intersection of two sets.</source>
          <target state="translated">O(n+m)。两个集合的交点。</target>
        </trans-unit>
        <trans-unit id="9cc718bb4770b7a90006261329b003135139c8ad" translate="yes" xml:space="preserve">
          <source>O(n+m). The intersection with a combining function.</source>
          <target state="translated">O(n+m)。与组合函数的交点。</target>
        </trans-unit>
        <trans-unit id="890f8c2b1acfa581b0c7f7e114b78e7d23366ee0" translate="yes" xml:space="preserve">
          <source>O(n+m). The restriction of a map to the keys in a set.</source>
          <target state="translated">O(n+m)。映射对集合中键的限制。</target>
        </trans-unit>
        <trans-unit id="5016a3d0debf2b50c789dd9e1a7b6671faab6a15" translate="yes" xml:space="preserve">
          <source>O(n+m). The union of two sets.</source>
          <target state="translated">O(n+m)。两个集合的结合。</target>
        </trans-unit>
        <trans-unit id="fd2cc7317cafb69298079beaf97e19917cd839b3" translate="yes" xml:space="preserve">
          <source>O(n+m). The union with a combining function.</source>
          <target state="translated">O(n+m)。与结合函数的结合。</target>
        </trans-unit>
        <trans-unit id="7d7e0023469558d3f70102c921ee4c3a9e3395fd" translate="yes" xml:space="preserve">
          <source>O(n/c) Append a byte to the end of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n / c）将一个字节附加到 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的末尾</target>
        </trans-unit>
        <trans-unit id="6cc37b0e22800234ef3f07b1490484598d0573ab" translate="yes" xml:space="preserve">
          <source>O(n/c) Append two ByteStrings</source>
          <target state="translated">O(n/c)添加两个ByteStrings。</target>
        </trans-unit>
        <trans-unit id="2d16b77d7608c5b05bf8bdfa8224cce8737fe128" translate="yes" xml:space="preserve">
          <source>O(n/c) Appends one &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to another. Subject to fusion.</source>
          <target state="translated">O（n / c）将一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 附加到另一个文本。受到融合。</target>
        </trans-unit>
        <trans-unit id="83e9729beee8e50770bb2d1f1ad5ed715db824b2" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O（n / c）提取ByteString 的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，如果为空则返回Nothing。</target>
        </trans-unit>
        <trans-unit id="8d9647ec0d877c0b2b247e8f277a0813bb9fa700" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O（n / c）提取ByteString 的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，如果为空则返回Nothing。</target>
        </trans-unit>
        <trans-unit id="9b60c39448cd17dc08f0f768a3a97ebd3de0381d" translate="yes" xml:space="preserve">
          <source>O(n/c) Extract the last element of a ByteString, which must be finite and non-empty.</source>
          <target state="translated">O(n/c)提取ByteString的最后一个元素,该元素必须是有限的和非空的。</target>
        </trans-unit>
        <trans-unit id="37b6278fe47a64e98a0bf8147cadf1bb592f7472" translate="yes" xml:space="preserve">
          <source>O(n/c) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one.</source>
          <target state="translated">O（n / c）返回 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有元素，但最后一个除外。</target>
        </trans-unit>
        <trans-unit id="6a2b4a041ecc6ab0616448e8c20b0c5a37880038" translate="yes" xml:space="preserve">
          <source>O(n/c) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one.</source>
          <target state="translated">O（n / c）返回 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有元素，但最后一个除外。</target>
        </trans-unit>
        <trans-unit id="0e3ad70873ec194a1a39a69714dd21042af5e5ad" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns all but the last character of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n / c）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的所有字符，但最后一个字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="27f439a72af29ea013e45190eb466312a751e58a" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty.</source>
          <target state="translated">O（N / C）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一个的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。</target>
        </trans-unit>
        <trans-unit id="1a9291bf9c091b55b1328473e44f843705375f3a" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty.</source>
          <target state="translated">O（N / C）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一个的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。</target>
        </trans-unit>
        <trans-unit id="7b77ed15d8ae05f0fc90526801bb2abe716255fb" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty.</source>
          <target state="translated">O（N / C）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一个的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。</target>
        </trans-unit>
        <trans-unit id="7e459c0133a7fa1d77589eafc5ac9befb3f26dfe" translate="yes" xml:space="preserve">
          <source>O(n/c) Returns the last character of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（n / c）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的最后一个字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="4b739d6be59fd1e3bd8ffa28a8cf4f0e86b46fcc" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（n / c） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 返回前 &lt;code&gt;n&lt;/code&gt; 个元素后的 &lt;code&gt;xs&lt;/code&gt; 后缀，如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3230bf165ab4f88bcfb24f3948a318fab7ae358c" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n / c）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f33a588e4903fd21668a1f7077c81aabda2ed64" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n / c）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="279a301156ba949c3ca05606b442b0fe4820bb23" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O（N / C） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 相当于 &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="098f5344db1894ea2ce7cb94140d79449edea1d5" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（N / C） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个字节串 &lt;code&gt;xs&lt;/code&gt; ，返回的前缀 &lt;code&gt;xs&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;xs&lt;/code&gt; 本身如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f36361a6522b2ae73d9a8f3d84f7bfb6f86caa03" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（n / c） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 返回前 &lt;code&gt;n&lt;/code&gt; 个元素后的 &lt;code&gt;xs&lt;/code&gt; 后缀，如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dca9d892c44a82be4d56f29a65e495be62351350" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n / c）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="033d5573aff7a09739e31b4140066fa4a57ad5ae" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n / c）的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5306bdfe59376f62c270fc886b633e2f6e1dcd87" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O（N / C） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 相当于 &lt;code&gt;(&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-lazy-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c57cb3fd24a15391e066d7bb4903681e1cc442e" translate="yes" xml:space="preserve">
          <source>O(n/c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（N / C） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个字节串 &lt;code&gt;xs&lt;/code&gt; ，返回的前缀 &lt;code&gt;xs&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;xs&lt;/code&gt; 本身如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-lazy-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fef8912f31d84073770a6dedf25eb44f12874e5" translate="yes" xml:space="preserve">
          <source>O(n^2). The &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">O（n ^ 2）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="92f2f94e099bb7227cfcc768bf47b8c9015c9ce7" translate="yes" xml:space="preserve">
          <source>O(n^2). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">O（n ^ 2）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="a61ad319127b680ea53570fe744c01d959f80faf" translate="yes" xml:space="preserve">
          <source>OSVERSIONINFOEX</source>
          <target state="translated">OSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="89c135f2ce1971887f752edc6617873ab49e2efb" translate="yes" xml:space="preserve">
          <source>OVERLAPPED</source>
          <target state="translated">OVERLAPPED</target>
        </trans-unit>
        <trans-unit id="9beeba965ae8dfbfff40f9bb14dd3916873ca225" translate="yes" xml:space="preserve">
          <source>O_APPEND</source>
          <target state="translated">O_APPEND</target>
        </trans-unit>
        <trans-unit id="1d359ddeab5bd0bfc7e36286fbd4b017c0306eca" translate="yes" xml:space="preserve">
          <source>O_EXCL</source>
          <target state="translated">O_EXCL</target>
        </trans-unit>
        <trans-unit id="5cb2bdb342c206ea5f6f844817a04b4faff12dc1" translate="yes" xml:space="preserve">
          <source>O_NOCTTY</source>
          <target state="translated">O_NOCTTY</target>
        </trans-unit>
        <trans-unit id="4c2fbe88ccc156499e1adb5569ddb4a71e2a0944" translate="yes" xml:space="preserve">
          <source>O_NONBLOCK</source>
          <target state="translated">O_NONBLOCK</target>
        </trans-unit>
        <trans-unit id="2ee322829f78f74d8bacf972b329ca8066c9a6c7" translate="yes" xml:space="preserve">
          <source>O_SYNC</source>
          <target state="translated">O_SYNC</target>
        </trans-unit>
        <trans-unit id="ce320f21777d59129eeca3fbf91595d9a215b3b0" translate="yes" xml:space="preserve">
          <source>O_TRUNC</source>
          <target state="translated">O_TRUNC</target>
        </trans-unit>
        <trans-unit id="fa81ee290b985173ab2f672fb935281b2d2e6c39" translate="yes" xml:space="preserve">
          <source>Object (.o)</source>
          <target state="translated">对象(.o)</target>
        </trans-unit>
        <trans-unit id="6b2f496323a4895019ec0a9b369fe04ec7ca98eb" translate="yes" xml:space="preserve">
          <source>Object files linked into shared objects must be compiled with &lt;a href=&quot;#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt;</source>
          <target state="translated">链接到共享库中的目标文件必须使用&lt;a href=&quot;#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;进行编译，请参见&lt;a href=&quot;#options-codegen&quot;&gt;影响代码生成的选项&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47de13ee5612750157967f1515fc00db4a7c92bd" translate="yes" xml:space="preserve">
          <source>Objective C</source>
          <target state="translated">目标C</target>
        </trans-unit>
        <trans-unit id="706f81efadad70c24efce57ea6d4e51ec7d7b3af" translate="yes" xml:space="preserve">
          <source>Objective C++</source>
          <target state="translated">Objective C++</target>
        </trans-unit>
        <trans-unit id="007aa0511eafaf62149d25010b14a8bb508fb130" translate="yes" xml:space="preserve">
          <source>Observe a type representation for the type of a value.</source>
          <target state="translated">观察一个值的类型表示。</target>
        </trans-unit>
        <trans-unit id="cd150df10728118f52cdf23f860179c0fad85301" translate="yes" xml:space="preserve">
          <source>Observe the &lt;code&gt;&lt;a href=&quot;ghc-fingerprint-type#t:Fingerprint&quot;&gt;Fingerprint&lt;/a&gt;&lt;/code&gt; of a type representation</source>
          <target state="translated">观察类型表示的 &lt;code&gt;&lt;a href=&quot;ghc-fingerprint-type#t:Fingerprint&quot;&gt;Fingerprint&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="409bd195ee5312c03c5d82bb0a53f65357224327" translate="yes" xml:space="preserve">
          <source>Observe the argument types of a type representation</source>
          <target state="translated">观察类型表示的参数类型</target>
        </trans-unit>
        <trans-unit id="b4b8289ec30f6e1a557ff9064f1f6b20543a7105" translate="yes" xml:space="preserve">
          <source>Observe the kind of a type.</source>
          <target state="translated">观察一个类型的种类。</target>
        </trans-unit>
        <trans-unit id="053b657569ecb7e098a31a03ae84e78b99ac515b" translate="yes" xml:space="preserve">
          <source>Observe the type constructor of a quantified type representation.</source>
          <target state="translated">观察量化类型表示的类型构造函数。</target>
        </trans-unit>
        <trans-unit id="a2ccc102a2dfd9eb15f652450214c5947ce98f64" translate="yes" xml:space="preserve">
          <source>Observe the type constructor of a type representation</source>
          <target state="translated">观察类型表示的类型构造函数。</target>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="translated">Observers</target>
        </trans-unit>
        <trans-unit id="39a3a78d27464eeb6b4e25918dbf5c9b44c8072a" translate="yes" xml:space="preserve">
          <source>Observing type representations</source>
          <target state="translated">观察类型表示</target>
        </trans-unit>
        <trans-unit id="bde229174b59bd1c95b5316149d2ce6a8e8efb33" translate="yes" xml:space="preserve">
          <source>Obsolete helpers</source>
          <target state="translated">过时的助手</target>
        </trans-unit>
        <trans-unit id="0fb9100499fe89a0975e82b1a3a8f4e9d2fd735d" translate="yes" xml:space="preserve">
          <source>Obtain a temporary file path with the given suffix. The compiler will delete this file after compilation.</source>
          <target state="translated">获取一个后缀为给定的临时文件路径。编译器将在编译后删除这个文件。</target>
        </trans-unit>
        <trans-unit id="08504fa744e6ae985fd5e1d3159ba4d86ca141de" translate="yes" xml:space="preserve">
          <source>Obtain the Haskell value referenced by a stable pointer, i.e., the same value that was passed to the corresponding call to &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt;. If the argument to &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; has already been freed using &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;, the behaviour of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">获取稳定指针引用的Haskell值，即与传递给 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt; 的相应调用的值相同的值。如果参数 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 已经使用释放 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; ，行为 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 不确定。</target>
        </trans-unit>
        <trans-unit id="700d14839cf29e3aa8bb6f2235b72aaad3a7ed94" translate="yes" xml:space="preserve">
          <source>Obtain the Haskell value referenced by a stable pointer, i.e., the same value that was passed to the corresponding call to &lt;code&gt;&lt;a href=&quot;ghc-stable#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt;. If the argument to &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; has already been freed using &lt;code&gt;&lt;a href=&quot;ghc-stable#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;, the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">获取稳定指针引用的Haskell值，即与传递给 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:newStablePtr&quot;&gt;newStablePtr&lt;/a&gt;&lt;/code&gt; 的相应调用的值相同的值。如果参数 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 已经使用释放 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; ，行为 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 不确定。</target>
        </trans-unit>
        <trans-unit id="a2440e4e145be4eb215fcb093e788fb9960299cd" translate="yes" xml:space="preserve">
          <source>Obtain the current working directory as an absolute path.</source>
          <target state="translated">获取当前工作目录的绝对路径。</target>
        </trans-unit>
        <trans-unit id="c1dd9feacb8ad914196a33496bfe7966a0a186c8" translate="yes" xml:space="preserve">
          <source>Obtain the path to a special directory for storing user-specific application data (traditional Unix location). Newer applications may prefer the the XDG-conformant location provided by &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;https://github.com/haskell/directory/issues/6#issuecomment-96521020&quot;&gt;migration guide&lt;/a&gt;).</source>
          <target state="translated">获取用于存储用户特定的应用程序数据的特殊目录的路径（传统Unix位置）。较新的应用程序可能更喜欢 &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; （&lt;a href=&quot;https://github.com/haskell/directory/issues/6#issuecomment-96521020&quot;&gt;迁移指南&lt;/a&gt;）提供的符合XDG的位置。</target>
        </trans-unit>
        <trans-unit id="5c48b83679543b94189e3b3857193ee60a82c74c" translate="yes" xml:space="preserve">
          <source>Obtain the paths to special directories for storing user-specific application data, configuration, and cache files, conforming to the &lt;a href=&quot;http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Base Directory Specification&lt;/a&gt;. Compared with &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt;, this function provides a more fine-grained hierarchy as well as greater flexibility for the user.</source>
          <target state="translated">获得符合&lt;a href=&quot;http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG基本目录规范的&lt;/a&gt;用于存储用户特定的应用程序数据，配置和缓存文件的特殊目录的路径。与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; 相比，此函数为用户提供了更细粒度的层次结构和更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="a87ae459f6cca39ea02c6527675b2cb4d0f768d7" translate="yes" xml:space="preserve">
          <source>Obtain the paths to special directories for storing user-specific application data, configuration, and cache files, conforming to the &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Base Directory Specification&lt;/a&gt;. Compared with &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt;, this function provides a more fine-grained hierarchy as well as greater flexibility for the user.</source>
          <target state="translated">获取符合&lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG基本目录规范的&lt;/a&gt;用于存储用户特定的应用程序数据，配置和缓存文件的特殊目录的路径。与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; 相比，此函数为用户提供了更细粒度的层次结构和更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="9ca83079153a8ef840b63ce27bb2fb8a367d26e7" translate="yes" xml:space="preserve">
          <source>Obtain the size of a file in bytes.</source>
          <target state="translated">获取文件的字节数。</target>
        </trans-unit>
        <trans-unit id="9fe9c6afc02350dde6bce9905666a177cb7718a2" translate="yes" xml:space="preserve">
          <source>Obtain the time at which the file or directory was last accessed.</source>
          <target state="translated">获取文件或目录最后被访问的时间。</target>
        </trans-unit>
        <trans-unit id="fe02e9af07ca18b2e182f9029db868dc37a5029e" translate="yes" xml:space="preserve">
          <source>Obtain the time at which the file or directory was last modified.</source>
          <target state="translated">获取文件或目录最后修改的时间。</target>
        </trans-unit>
        <trans-unit id="ff7dba47666639f94394aa3dd0febd37e4ecc275" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">从得到 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="8d89b30a22ab542b2220d609d797437caf3a9581" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">从获得 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="442dc1559deffb0ef963faf7fa54adec4e60807c" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">从得到 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="182d8ba16b92f752f26f4563dc36a9660282111d" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/template-haskell-2.16.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/template-haskell-2.16.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="808af45a8c161f66c05c30204ffc7b09a12d4c71" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/template-haskell-2.15.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/template-haskell-2.15.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="685f89ed8b9c2652bc827857c50ff8b162fd13ef" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/template-haskell-2.17.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/template-haskell-2.17.0.0/Language-Haskell-TH-Lib.html#v:thisModule&quot;&gt;thisModule&lt;/a&gt;&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="d46cc88ad2b7ebeb92e27c492df182c9102b8ed0" translate="yes" xml:space="preserve">
          <source>Obtained from &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">从获得 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="f7e2e85147570bbfd1afb948ab5b789d3478fe86" translate="yes" xml:space="preserve">
          <source>Obtaining file status</source>
          <target state="translated">获得档案状态</target>
        </trans-unit>
        <trans-unit id="e3870373daca7d25421aaf721af5436c7f6ea920" translate="yes" xml:space="preserve">
          <source>Obtaining the constructor from a given datum. For proper terms, this is meant to be the top-level constructor. Primitive datatypes are here viewed as potentially infinite sets of values (i.e., constructors).</source>
          <target state="translated">从一个给定的基准点获取构造函数。对于适当的术语,这意味着是顶层构造函数。基元数据类型在这里被看作是潜在的无限值集(即构造函数)。</target>
        </trans-unit>
        <trans-unit id="1f8c61df2bac9fbfd23bad2f0e9746f16edb8aa7" translate="yes" xml:space="preserve">
          <source>OccName</source>
          <target state="translated">OccName</target>
        </trans-unit>
        <trans-unit id="a8ecac7d31bbf740edf1b0b3ea851c89f44a5d30" translate="yes" xml:space="preserve">
          <source>Occasionally &lt;strong&gt;gv&lt;/strong&gt; will choke as it tries to read an incomplete copy of &lt;code&gt;FOO.ps&lt;/code&gt; (because &lt;strong&gt;hp2ps&lt;/strong&gt; is still running as an update occurs). A slightly more complicated script works around this problem, by using the fact that sending a SIGHUP to gv will cause it to re-read its input file:</source>
          <target state="translated">有时，&lt;strong&gt;gv&lt;/strong&gt;在尝试读取 &lt;code&gt;FOO.ps&lt;/code&gt; 的不完整副本时会感到窒息（因为更新时&lt;strong&gt;hp2ps&lt;/strong&gt;仍在运行）。通过使用将SIGHUP发送到gv将导致它重新读取其输入文件这一事实，一个稍微复杂一些的脚本可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="7d892360b7aa6e79ccbbb2db9552ec0912fed1fe" translate="yes" xml:space="preserve">
          <source>Octal and hexadecimal numerics are not recognized as a single token</source>
          <target state="translated">八进制和十六进制数字不被识别为一个单一的标记。</target>
        </trans-unit>
        <trans-unit id="31ef00312f2e1ee7506655b11623866b09a38490" translate="yes" xml:space="preserve">
          <source>OddParity</source>
          <target state="translated">OddParity</target>
        </trans-unit>
        <trans-unit id="14ad9c3a886a6706b68193db972d3c2fd0f4dd48" translate="yes" xml:space="preserve">
          <source>Oddly enough, people really do use this option! Our pal in Durham (England), Paul Callaghan, writes: &amp;ldquo;Some people here use it for a variety of purposes&amp;mdash;honestly!&amp;mdash;e.g., confirmation that the code/machine is doing something, infinite loop detection, gauging cost of recently added code. Certain people can even tell what stage [the program] is in by the beep pattern. But the major use is for annoying others in the same office&amp;hellip;&amp;rdquo;</source>
          <target state="translated">奇怪的是，人们确实确实使用了该选项！我们在英国达勒姆（Durham）的朋友Paul Callaghan写道：&amp;ldquo;老实说，这里的某些人将其用于各种目的，例如，确认代码/机器正在做某事，无限循环检测，衡量最近添加代码的成本。某些人甚至可以通过蜂鸣声模式判断[程序]处于哪个阶段。但是主要用途是使同一办公室的其他人烦恼&amp;hellip;&amp;hellip;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0c0b0b1a2080b74e19b756494638ec92162f2758" translate="yes" xml:space="preserve">
          <source>Odds and ends, mostly functions for reading and showing &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;-like kind of values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; ，主要是读取和显示类似RealFloat的值的功能。</target>
        </trans-unit>
        <trans-unit id="fb4aa7843d0c5581b08750305cac08a18952a151" translate="yes" xml:space="preserve">
          <source>Of course when running another interactive program in the console then we want to let that program handle Ctl-C. Under Unix however, Ctl-C sends &lt;code&gt;SIGINT&lt;/code&gt; to every process using the console. The standard solution is that while running an interactive program, ignore &lt;code&gt;SIGINT&lt;/code&gt; in the parent, and let it be handled in the child process. If that process then terminates due to the &lt;code&gt;SIGINT&lt;/code&gt; signal, then at that point treat it as if we had recieved the &lt;code&gt;SIGINT&lt;/code&gt; ourselves and begin an orderly shutdown.</source>
          <target state="translated">当然，当在控制台中运行另一个交互式程序时，我们希望让该程序处理Ctl-C。但是，在Unix下，Ctl-C 使用控制台将 &lt;code&gt;SIGINT&lt;/code&gt; 发送到每个进程。标准解决方案是在运行交互式程序时，忽略父级中的 &lt;code&gt;SIGINT&lt;/code&gt; ，并在子进程中对其进行处理。如果该过程随后由于 &lt;code&gt;SIGINT&lt;/code&gt; 信号而终止，则在此时将其视为我们自己已收到 &lt;code&gt;SIGINT&lt;/code&gt; 并开始有序关闭。</target>
        </trans-unit>
        <trans-unit id="13cbc7281dc8f2ba063030a73854a759868eae8d" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;UndecidableInstances&lt;/code&gt; lifts the Paterson Conditions, as now.</source>
          <target state="translated">当然，像现在一样， &lt;code&gt;UndecidableInstances&lt;/code&gt; 会解除 Paterson条件。</target>
        </trans-unit>
        <trans-unit id="bd80101b7867bda9e4de541e2013550d0cd09fca" translate="yes" xml:space="preserve">
          <source>Of course, if you have foreign calls in your program then all bets are off, because you can trash the heap, the stack, or whatever.</source>
          <target state="translated">当然,如果你的程序里有国外的跟注,那么所有的赌注都是不对的,因为你可以糟蹋堆,堆,或者其他的东西。</target>
        </trans-unit>
        <trans-unit id="a37fd12339c76f03254c6a2485812a618d645f86" translate="yes" xml:space="preserve">
          <source>Of course, in this particular situation you can do even better:</source>
          <target state="translated">当然,在这种特殊情况下,你可以做得更好。</target>
        </trans-unit>
        <trans-unit id="959274964b08ed6b64f4a784f4ffb9f800fb0e15" translate="yes" xml:space="preserve">
          <source>Of course, you can also bind normal non-IO expressions using the &lt;code&gt;let&lt;/code&gt;-statement:</source>
          <target state="translated">当然，您也可以使用 &lt;code&gt;let&lt;/code&gt; -statement 绑定普通的非IO表达式：</target>
        </trans-unit>
        <trans-unit id="6b1e2c81f99bb1db90306be62673e1a90e706694" translate="yes" xml:space="preserve">
          <source>Of the form &lt;code&gt;TYPE r&lt;/code&gt; for some &lt;code&gt;r&lt;/code&gt; (see &lt;a href=&quot;#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt;). For example:</source>
          <target state="translated">形式的 &lt;code&gt;TYPE r&lt;/code&gt; 一段 &lt;code&gt;r&lt;/code&gt; （见&lt;a href=&quot;#runtime-rep&quot;&gt;轻浮多态性&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="afcdbe9a12bcfe61d1dd2d4d138cd73a5c5e20a1" translate="yes" xml:space="preserve">
          <source>Of the form &lt;code&gt;TYPE r&lt;/code&gt; for some &lt;code&gt;r&lt;/code&gt; (see &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt;). For example:</source>
          <target state="translated">形式的 &lt;code&gt;TYPE r&lt;/code&gt; 一段 &lt;code&gt;r&lt;/code&gt; （见&lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;轻浮多态性&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="1fa3c2ee363eec71d94c2c2d92dc5c6cd1bf213f" translate="yes" xml:space="preserve">
          <source>Offset from the pointer</source>
          <target state="translated">指针的偏移量</target>
        </trans-unit>
        <trans-unit id="ea2c1b968cb14580f767587f854d5b3baa84a1fa" translate="yes" xml:space="preserve">
          <source>Offset into first</source>
          <target state="translated">偏移到第一个</target>
        </trans-unit>
        <trans-unit id="5c4232ca426c972654e6acef0e24307e9bf01cdb" translate="yes" xml:space="preserve">
          <source>Offset into second</source>
          <target state="translated">偏移到第二个</target>
        </trans-unit>
        <trans-unit id="f8e5c2c7cae1141a37276f0a36a8a63d24f1a869" translate="yes" xml:space="preserve">
          <source>Often a particular data structure is being retained by a chain of unevaluated closures, only the nearest of which will be reported by retainer profiling - for example &lt;code&gt;A&lt;/code&gt; retains &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; retains &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; retains a large structure. There might be a large number of &lt;code&gt;B&lt;/code&gt;s but only a single &lt;code&gt;A&lt;/code&gt;, so &lt;code&gt;A&lt;/code&gt; is really the one we&amp;rsquo;re interested in eliminating. However, retainer profiling will in this case report &lt;code&gt;B&lt;/code&gt; as the retainer of the large structure. To move further up the chain of retainers, we can ask for another retainer profile but this time restrict the profile to &lt;code&gt;B&lt;/code&gt; objects, so we get a profile of the retainers of &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">通常，特定的数据结构由未评估的闭包链保留，只有最接近的闭包将通过保留程序配置文件报告-例如 &lt;code&gt;A&lt;/code&gt; 保留 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 保留 &lt;code&gt;C&lt;/code&gt; ，并且 &lt;code&gt;C&lt;/code&gt; 保留大结构。可能会有大量的 &lt;code&gt;B&lt;/code&gt; ,但只有一个 &lt;code&gt;A&lt;/code&gt; ，因此 &lt;code&gt;A&lt;/code&gt; 确实是我们有兴趣消除的一个。但是，在这种情况下，保持器性能分析将报告 &lt;code&gt;B&lt;/code&gt; 为大型结构的保持器。为了使固定器链进一步向上移动，我们可以请求另一个固定器配置文件，但是这次将配置文件限制为 &lt;code&gt;B&lt;/code&gt; 对象，因此我们获得了 &lt;code&gt;B&lt;/code&gt; 的保留者的资料：</target>
        </trans-unit>
        <trans-unit id="69167169d72ddc29203b8842fec5ca3158c37c4a" translate="yes" xml:space="preserve">
          <source>Old API kept to avoid breaking clients</source>
          <target state="translated">保留旧的API以避免破坏客户端</target>
        </trans-unit>
        <trans-unit id="9ce5a70368f8243b3801e08794befe07bb9b0130" translate="yes" xml:space="preserve">
          <source>Old deprecated functions</source>
          <target state="translated">旧的废弃功能</target>
        </trans-unit>
        <trans-unit id="199b0ae233b01261174a40c433e452bd8e11764e" translate="yes" xml:space="preserve">
          <source>Old path</source>
          <target state="translated">古道</target>
        </trans-unit>
        <trans-unit id="9b285d963737095a360d0a661d0df2fea803a4ac" translate="yes" xml:space="preserve">
          <source>Omit code generation</source>
          <target state="translated">省略代码生成</target>
        </trans-unit>
        <trans-unit id="06b348347f0fc6282795f8b8662b8c726c982724" translate="yes" xml:space="preserve">
          <source>Omit code generation (and all later phases) altogether. This is useful if you&amp;rsquo;re only interested in type checking code.</source>
          <target state="translated">完全省略代码生成（以及所有后续阶段）。如果您仅对类型检查代码感兴趣，这将很有用。</target>
        </trans-unit>
        <trans-unit id="143759d6a82a6e782ba8b006ab52848e42762c71" translate="yes" xml:space="preserve">
          <source>Omit heap checks when no allocation is being performed.</source>
          <target state="translated">当没有进行分配时,省略堆检查。</target>
        </trans-unit>
        <trans-unit id="7e25f9708b019df5d840bb95bec43db511395b29" translate="yes" xml:space="preserve">
          <source>Omits the link step. This option can be used with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; to avoid the automatic linking that takes place if the program contains a &lt;code&gt;Main&lt;/code&gt; module.</source>
          <target state="translated">省略链接步骤。此选项可与&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;一起使用，以避免在程序包含 &lt;code&gt;Main&lt;/code&gt; 模块时发生自动链接。</target>
        </trans-unit>
        <trans-unit id="60e957e3d9a735dd58ec78b95add59bf7dee68af" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;-N⟨x⟩&lt;/code&gt; entirely means &lt;code&gt;-N1&lt;/code&gt;.</source>
          <target state="translated">省略 &lt;code&gt;-N⟨x⟩&lt;/code&gt; 完全意味着 &lt;code&gt;-N1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="852085b8a1ca62c46bfcfacdf985dc281e39d842" translate="yes" xml:space="preserve">
          <source>Omitting generic instances</source>
          <target state="translated">省略通用实例</target>
        </trans-unit>
        <trans-unit id="02a33c2d0537913c5f5350486a8c3f93ad4f4e57" translate="yes" xml:space="preserve">
          <source>Omitting ⟨x⟩, i.e. &lt;code&gt;+RTS -N -RTS&lt;/code&gt;, lets the runtime choose the value of ⟨x⟩ itself based on how many processors are in your machine.</source>
          <target state="translated">省略⟨x⟩，即 &lt;code&gt;+RTS -N -RTS&lt;/code&gt; ，可以使运行时根据计算机中有多少个处理器来选择⟨x⟨本身的值。</target>
        </trans-unit>
        <trans-unit id="15d76fc4eb3563c85ec6bb33fc1966e50eaee83c" translate="yes" xml:space="preserve">
          <source>On 32-bit x86 platforms when using the native code generator, the &lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt;&lt;code&gt;-fexcess-precision&lt;/code&gt;&lt;/a&gt; option is always on. This means that floating-point calculations are non-deterministic, because depending on how the program is compiled (optimisation settings, for example), certain calculations might be done at 80-bit precision instead of the intended 32-bit or 64-bit precision. Floating-point results may differ when optimisation is turned on. In the worst case, referential transparency is violated, because for example &lt;code&gt;let x = E1 in E2&lt;/code&gt; can evaluate to a different value than &lt;code&gt;E2[E1/x]&lt;/code&gt;.</source>
          <target state="translated">在使用本机代码生成器的32位x86平台上，&lt;a href=&quot;using-optimisation#ghc-flag--fexcess-precision&quot;&gt; &lt;code&gt;-fexcess-precision&lt;/code&gt; &lt;/a&gt;选项始终处于启用状态。这意味着浮点计算是不确定的，因为取决于程序的编译方式（例如，优化设置），某些计算可能以80位精度而不是预期的32位或64位精度进行。启用优化后，浮点结果可能会有所不同。在最坏的情况下，会违反参照透明性，因为例如， &lt;code&gt;let x = E1 in E2&lt;/code&gt; 可以得出与 &lt;code&gt;E2[E1/x]&lt;/code&gt; 不同的值。</target>
        </trans-unit>
        <trans-unit id="1391cbd23623d8953378e909f91a6612b37b28fe" translate="yes" xml:space="preserve">
          <source>On 64-bit machines, the RTS needs to allocate memory in the low 2Gb of the address space. Support for this across different operating systems is patchy, and sometimes fails. This option is there to give the RTS a hint about where it should be able to allocate memory in the low 2Gb of the address space. For example, &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; would hint that the RTS should allocate starting at the 0.5Gb mark. The default is to use the OS&amp;rsquo;s built-in support for allocating memory in the low 2Gb if available (e.g. &lt;code&gt;mmap&lt;/code&gt; with &lt;code&gt;MAP_32BIT&lt;/code&gt; on Linux), or otherwise &lt;code&gt;-xm40000000&lt;/code&gt;.</source>
          <target state="translated">在64位计算机上，RTS需要在地址空间的低2Gb中分配内存。在不同的操作系统上对此的支持是不完整的，有时会失败。可以使用该选项向RTS提示有关它应该能够在地址空间的低2Gb中分配内存的位置。例如， &lt;code&gt;+RTS -xm20000000 -RTS&lt;/code&gt; 会暗示RTS应该从0.5Gb标记开始分配。默认设置是使用操作系统的内置支持（如果可用）在低2Gb内存中分配内存（例如，在Linux上具有 &lt;code&gt;MAP_32BIT&lt;/code&gt; 的 &lt;code&gt;mmap&lt;/code&gt; ），否则使用 &lt;code&gt;-xm40000000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097883c1f4907fb1b521ee5631f70e7ddf86398d" translate="yes" xml:space="preserve">
          <source>On 64-bit machines, the runtime linker usually needs to map object code into the low 2Gb of the address space, due to the x86_64 small memory model where most symbol references are 32 bits. The problem is that this 2Gb of address space can fill up, especially if you&amp;rsquo;re loading a very large number of object files into GHCi.</source>
          <target state="translated">在64位计算机上，由于x86_64小型内存模型（其中大多数符号引用为32位），运行时链接程序通常需要将目标代码映射到地址空间的低2Gb中。问题在于，这2Gb的地址空间会填满，特别是如果您要将大量的目标文件加载到GHCi中时。</target>
        </trans-unit>
        <trans-unit id="56b14479147dc851f7df3c7d9e83023d77f4f785" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X, dynamic libraries are stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the ultimate install path of the library file. Any libraries or executables that subsequently link against it will pick up that path as their runtime search location for it. By default, ghc sets the install name to the location where the library is built. This option allows you to override it with the specified file path. (It passes &lt;code&gt;-install_name&lt;/code&gt; to Apple&amp;rsquo;s linker.) Ignored on other platforms.</source>
          <target state="translated">在Darwin / OS X上，动态库在构建时会用&amp;ldquo;安装名称&amp;rdquo;标记，这是库文件的最终安装路径。随后链接到该库的任何库或可执行文件都将使用该路径作为其运行时搜索位置。默认情况下，ghc将安装名称设置为构建库的位置。该选项允许您使用指定的文件路径覆盖它。（它将 &lt;code&gt;-install_name&lt;/code&gt; 传递给Apple的链接器。）在其他平台上被忽略。</target>
        </trans-unit>
        <trans-unit id="c502a4721745da19ad3306edaec1023d6b7312d6" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, add ⟨dir⟩ to the list of directories searched for frameworks. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">仅在Darwin / OS X / iOS上，将⟨dir⟩添加到搜索框架的目录列表中。此选项与Apple的Linker 的 &lt;code&gt;-F&lt;/code&gt; 选项相对应。</target>
        </trans-unit>
        <trans-unit id="f8f858556433cf6929170371cf16d1d28b70f4f0" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, add ⟨dir⟩ to the list of directories searched for frameworks. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple's Linker.</source>
          <target state="translated">仅在Darwin / OS X / iOS上，将&amp;ldquo; dir&amp;rdquo;添加到搜索框架的目录列表中。此选项与Apple的Linker的 &lt;code&gt;-F&lt;/code&gt; 选项相对应。</target>
        </trans-unit>
        <trans-unit id="836aeb62038416ab5d18c1c4cccc6b7891cf00da" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker.</source>
          <target state="translated">仅在Darwin / OS X / iOS上，链接框架⟨name⟩。此选项与Apple的Linker 的 &lt;code&gt;-framework&lt;/code&gt; 选项相对应。</target>
        </trans-unit>
        <trans-unit id="0d2f8a49d8d4c58193d7bce9934ad90451e92201" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple&amp;rsquo;s Linker. Please note that frameworks and packages are two different things - frameworks don&amp;rsquo;t contain any Haskell code. Rather, they are Apple&amp;rsquo;s way of packaging shared libraries. To link to Apple&amp;rsquo;s &amp;ldquo;Carbon&amp;rdquo; API, for example, you&amp;rsquo;d use &lt;code&gt;-framework Carbon&lt;/code&gt;.</source>
          <target state="translated">仅在Darwin / OS X / iOS上，链接框架⟨name⟩。此选项与Apple的Linker 的 &lt;code&gt;-framework&lt;/code&gt; 选项相对应。请注意，框架和包是两回事-框架不包含任何Haskell代码。相反，它们是Apple打包共享库的方式。例如，要链接到Apple的&amp;ldquo; Carbon&amp;rdquo; API，您可以使用 &lt;code&gt;-framework Carbon&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cccac3a36668d1fdad31c6e062fb07a44e28644" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the &lt;code&gt;-framework&lt;/code&gt; option for Apple's Linker.</source>
          <target state="translated">仅在Darwin / OS X / iOS上，链接框架⟨name⟩。此选项与Apple的Linker的 &lt;code&gt;-framework&lt;/code&gt; 选项相对应。</target>
        </trans-unit>
        <trans-unit id="c57aabecc887720cc819888b560ff938ff24a471" translate="yes" xml:space="preserve">
          <source>On Darwin/OS X/iOS only, prepend the directory ⟨dir⟩ to the framework directories path. This option corresponds to the &lt;code&gt;-F&lt;/code&gt; option for Apple&amp;rsquo;s Linker (&lt;code&gt;-F&lt;/code&gt; already means something else for GHC).</source>
          <target state="translated">仅在Darwin / OS X / iOS上，将目录dir放在框架目录路径之前。此选项与Apple的Linker 的 &lt;code&gt;-F&lt;/code&gt; 选项相对应（ &lt;code&gt;-F&lt;/code&gt; 对GHC而言已经意味着其他名称）。</target>
        </trans-unit>
        <trans-unit id="f6e8ba5a3fab15f9e41a75f470422c219a534bb8" translate="yes" xml:space="preserve">
          <source>On GHC, the runtime will ensure that any Haskell thread will only see &quot;its own&quot; &lt;code&gt;errno&lt;/code&gt;, by saving and restoring the value when Haskell threads are scheduled across OS threads.</source>
          <target state="translated">在GHC上，运行时将通过在跨OS线程调度Haskell线程时保存并还原该值，从而确保任何Haskell线程仅看到&amp;ldquo;自己的&amp;rdquo; &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c71882ba581cd6bc6d41d871050d79d61de4659e" translate="yes" xml:space="preserve">
          <source>On Linux, MADV_FREE is newer and faster because it can avoid zeroing pages if they are re-used by the process later (see &lt;code&gt;man 2 madvise&lt;/code&gt;), but for the trade-off that memory inspection tools like &lt;code&gt;top&lt;/code&gt; will not immediately reflect the freeing in their display of resident memory (RSS column): Only under memory pressure will Linux actually remove the freed pages from the process and update its RSS statistics. Until then, the pages show up as &lt;code&gt;LazyFree&lt;/code&gt; in &lt;code&gt;/proc/PID/smaps&lt;/code&gt; (see &lt;code&gt;man 5 proc&lt;/code&gt;).</source>
          <target state="translated">在Linux上，MADV_FREE是更新和更快的，因为它可以避免将页面归零（如果稍后将其重新使用）（请参阅 &lt;code&gt;man 2 madvise&lt;/code&gt; ），但是要进行权衡，像 &lt;code&gt;top&lt;/code&gt; 这样的内存检查工具不会立即反映出释放空间。它们显示的常驻内存（RSS列）：只有在内存压力下，Linux才会真正从进程中删除释放的页面并更新其RSS统计信息。在此之前，该网页显示为 &lt;code&gt;LazyFree&lt;/code&gt; 中 &lt;code&gt;/proc/PID/smaps&lt;/code&gt; （见 &lt;code&gt;man 5 proc&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="40cc400d7871c058aaff05bc589d341778622e21" translate="yes" xml:space="preserve">
          <source>On POSIX platforms these two new handles will always be Nothing</source>
          <target state="translated">在POSIX平台上,这两个新的句柄将始终是Nothing</target>
        </trans-unit>
        <trans-unit id="078d3ef4757340184bdc802a0b2704173202e340" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this is equivalent to &lt;code&gt;stat&lt;/code&gt; followed by &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">在POSIX系统上，这等效于 &lt;code&gt;stat&lt;/code&gt; 和 &lt;code&gt;chmod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5150091903944c9e80b85e4f5491e74472f81c1" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this returns the result of &lt;code&gt;access&lt;/code&gt;.</source>
          <target state="translated">在POSIX系统上，这将返回 &lt;code&gt;access&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="0e1256ac8aafae1c7e4adb4ddae8c68c82e5af71" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this sets the &lt;em&gt;owner&lt;/em&gt; permissions.</source>
          <target state="translated">在POSIX系统上，这将设置&lt;em&gt;所有者&lt;/em&gt;权限。</target>
        </trans-unit>
        <trans-unit id="15a6eb7d1aee9c1397492586a65a460c544dbaea" translate="yes" xml:space="preserve">
          <source>On POSIX, equivalent to &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在POSIX上，等效于 &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:simplifyPosix&quot;&gt;simplifyPosix&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a057a4f6c4818787b76f3467f2b22b0d6a9e3b6d" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible platforms GHC&amp;rsquo;s runtime system (when built with &lt;code&gt;libdw&lt;/code&gt; support) will produce a stack trace on &lt;code&gt;stderr&lt;/code&gt; when a &lt;code&gt;SIGQUIT&lt;/code&gt; signal is received (on many systems this signal can be sent using</source>
          <target state="translated">在兼容POSIX的平台上，GHC的运行时系统（当支持 &lt;code&gt;libdw&lt;/code&gt; 构建时）将在收到 &lt;code&gt;SIGQUIT&lt;/code&gt; 信号时在 &lt;code&gt;stderr&lt;/code&gt; 上生成堆栈跟踪（在许多系统上，可以使用以下命令发送该信号）</target>
        </trans-unit>
        <trans-unit id="6c168ab7b60c55fc5b0097e465ca6c5d25010787" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible platforms GHC&amp;rsquo;s runtime system (when built with &lt;code&gt;libdw&lt;/code&gt; support) will produce a stack trace on &lt;code&gt;stderr&lt;/code&gt; when a &lt;code&gt;SIGQUIT&lt;/code&gt; signal is received (on many systems this signal can be sent using &lt;code&gt;Ctrl-\&lt;/code&gt;). For instance (using the same &lt;code&gt;fib.hs&lt;/code&gt; as above),</source>
          <target state="translated">在兼容POSIX的平台上，GHC的运行时系统（当使用 &lt;code&gt;libdw&lt;/code&gt; 支持构建时）将在收到 &lt;code&gt;SIGQUIT&lt;/code&gt; 信号时在 &lt;code&gt;stderr&lt;/code&gt; 上生成堆栈跟踪（在许多系统上，可以使用 &lt;code&gt;Ctrl-\&lt;/code&gt; 发送该信号）。例如（使用与上述相同的 &lt;code&gt;fib.hs&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="fd039a8f7dffd39b1f1b6eeb928b5966cd384926" translate="yes" xml:space="preserve">
          <source>On Posix systems the I/O manager has an implicit reliance on doing a file read moving the file pointer. However on Windows async operations the kernel object representing a file does not use the file pointer offset. Logically this makes sense since operations can be performed in any arbitrary order. OVERLAPPED operations don't respect the file pointer offset as their intention is to support arbitrary async reads to anywhere at a much lower level. As such we should explicitly keep track of the file offsets of the target in the buffer. Any operation to seek should also update this entry.</source>
          <target state="translated">在Posix系统中,I/O管理器有一个隐含的依赖,就是在做文件读取时移动文件指针,但是在Windows异步操作中,代表文件的内核对象不使用文件指针偏移。然而在Windows的异步操作中,代表文件的内核对象并不使用文件指针偏移。从逻辑上讲,这是有道理的,因为操作可以以任意的顺序执行。OVERLAPPED操作不尊重文件指针偏移量,因为它们的目的是支持任意的异步读到更低层次的任何地方。因此,我们应该明确地跟踪缓冲区中目标的文件偏移量。任何寻找的操作也应该更新这个条目。</target>
        </trans-unit>
        <trans-unit id="0422707a616b81e28b0b133b6079462f1cb7aac1" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; sends the process the SIGTERM signal. On Windows systems, if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; function is called to kill all processes associated with the job and passing the exit code of 1 to each of them. Otherwise if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; function is called, passing an exit code of 1.</source>
          <target state="translated">在Unix系统上， &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 向进程发送SIGTERM信号。在Windows系统上，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则将调用 Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; 函数来杀死与该作业关联的所有进程，并将退出代码1传递给每个进程。否则，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ,则调用Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; 函数，并传递退出代码1。</target>
        </trans-unit>
        <trans-unit id="2ee8ff777481e4647016777c942f48cad360e353" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; sends the process the SIGTERM signal. On Windows systems, if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; function is called to kill all processes associated with the job and passing the exit code of 1 to each of them. Otherwise if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; function is called, passing an exit code of 1.</source>
          <target state="translated">在Unix系统上， &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 向进程发送SIGTERM信号。在Windows系统上，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则将调用Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; 函数来杀死与该作业关联的所有进程，并将退出代码1传递给每个进程。否则，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ,则调用Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; 函数，并传递退出代码1。</target>
        </trans-unit>
        <trans-unit id="d3899316474abe7a59038dc3fbc0b48116b708d4" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; sends the process the SIGTERM signal. On Windows systems, if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; function is called to kill all processes associated with the job and passing the exit code of 1 to each of them. Otherwise if &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; then the Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; function is called, passing an exit code of 1.</source>
          <target state="translated">在Unix系统上， &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 向进程发送SIGTERM信号。在Windows系统上，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则将调用Win32 &lt;code&gt;TerminateJobObject&lt;/code&gt; 函数来杀死与该作业关联的所有进程，并将退出代码1传递给每个进程。否则，如果 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ,则调用Win32 &lt;code&gt;TerminateProcess&lt;/code&gt; 函数，并传递退出代码1。</target>
        </trans-unit>
        <trans-unit id="26000ccdb50e03ab1029e35d0df1776d18e9ab0e" translate="yes" xml:space="preserve">
          <source>On Unix systems, it sends the group the SIGINT signal.</source>
          <target state="translated">在Unix系统中,它向该组发送SIGINT信号。</target>
        </trans-unit>
        <trans-unit id="c6d0966027827b87508cf93ba9e2a42091942bf2" translate="yes" xml:space="preserve">
          <source>On Unix systems, see &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for the meaning of exit codes when the process died as the result of a signal.</source>
          <target state="translated">在Unix系统上，请参见 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 以获取当进程由于信号而死亡时退出代码的含义。</target>
        </trans-unit>
        <trans-unit id="09629c83332620e6e6759db7b31141b99ca9c762" translate="yes" xml:space="preserve">
          <source>On Unix there are two mechanisms. Shared libraries can be installed into standard locations that the dynamic linker knows about. For example &lt;code&gt;/usr/lib&lt;/code&gt; or &lt;code&gt;/usr/local/lib&lt;/code&gt; on most systems. The other mechanism is to use a &amp;ldquo;runtime path&amp;rdquo; or &amp;ldquo;rpath&amp;rdquo; embedded into programs and libraries themselves. These paths can either be absolute paths or on at least Linux and Solaris they can be paths relative to the program or library itself. In principle this makes it possible to construct fully relocatable sets of programs and libraries.</source>
          <target state="translated">在Unix上，有两种机制。可以将共享库安装到动态链接器知道的标准位置。例如，在大多数系统上， &lt;code&gt;/usr/lib&lt;/code&gt; 或 &lt;code&gt;/usr/local/lib&lt;/code&gt; 。另一种机制是使用嵌入到程序和库本身中的&amp;ldquo;运行时路径&amp;rdquo;或&amp;ldquo; rpath&amp;rdquo;。这些路径可以是绝对路径，或者至少在Linux和Solaris上，它们可以是相对于程序或库本身的路径。原则上，这使得构建完全可重定位的程序和库集成为可能。</target>
        </trans-unit>
        <trans-unit id="1aa9bf14869ffa0729b113a2919b90d3a99f83ea" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; behaves as follows:</source>
          <target state="translated">在Unix上， &lt;code&gt;&lt;a href=&quot;system-directory#v:getHomeDirectory&quot;&gt;getHomeDirectory&lt;/a&gt;&lt;/code&gt; 的行为如下：</target>
        </trans-unit>
        <trans-unit id="dbda9eb325b9c89423ab40811c09f445058a091b" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable or &quot;/tmp&quot; if the variable isn't defined. On Windows, the function checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">在Unix上， &lt;code&gt;&lt;a href=&quot;system-directory#v:getTemporaryDirectory&quot;&gt;getTemporaryDirectory&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量的值，如果未定义，则返回&amp;ldquo; / tmp&amp;rdquo;。在Windows上，该函数按以下顺序检查环境变量是否存在，并使用找到的第一个路径：</target>
        </trans-unit>
        <trans-unit id="db73ed697e88171697c761e2de6ba9e3b2fdb8f6" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; returns the value of the &lt;code&gt;HOME&lt;/code&gt; environment variable. On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt;.</source>
          <target state="translated">在Unix上， &lt;code&gt;&lt;a href=&quot;system-directory#v:getUserDocumentsDirectory&quot;&gt;getUserDocumentsDirectory&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;HOME&lt;/code&gt; 环境变量的值。在Windows上，系统会查询一条合适的路径。典型的路径可能是 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/Documents&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6aec3d6d90c1ca53af23e974fd0a1470d206561" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, permissions, access time, and modification time are preserved. If possible, the owner and group are also preserved. Note that the very act of copying can change the access time of the source file, hence the access times of the two files may differ after the operation completes.</source>
          <target state="translated">在类似Unix的系统中,权限、访问时间和修改时间都会被保留。如果可能的话,所有者和组也会被保留。需要注意的是,复制行为本身就会改变源文件的访问时间,因此在操作完成后,两个文件的访问时间可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="1f67f27323ff913fec8fc3bce6fba0553de49353" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, the path is &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">在类似Unix的系统上，路径为 &lt;code&gt;~/.&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2acf1d643c18794b5ab0d3288014560943c06f0b" translate="yes" xml:space="preserve">
          <source>On Unix: &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</source>
          <target state="translated">在Unix上： &lt;code&gt;$HOME/.ghc/ghci.conf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="686bba75bbf12a7e94f3f601b8b2b6f1c767e5b6" translate="yes" xml:space="preserve">
          <source>On Win32 platforms, &lt;code&gt;renameDirectory&lt;/code&gt; fails if the &lt;em&gt;new&lt;/em&gt; directory already exists.</source>
          <target state="translated">在Win32平台上，如果&lt;em&gt;新&lt;/em&gt;目录已存在，则 &lt;code&gt;renameDirectory&lt;/code&gt; 失败。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4cf66c11f13f8d5cfb30fa66ff975ad9d16e7224" translate="yes" xml:space="preserve">
          <source>On Windows XP or earlier systems, junction expansion is not performed due to their lack of &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt;.</source>
          <target state="translated">在Windows XP或更早的系统上，由于缺少 &lt;code&gt;GetFinalPathNameByHandle&lt;/code&gt; 而不执行结点扩展。</target>
        </trans-unit>
        <trans-unit id="e2645284c47be98a8acf2a83e433b0e66594a2f2" translate="yes" xml:space="preserve">
          <source>On Windows a second wait method can be used to block for event completion. This requires two handles. A process job handle and a events handle to monitor.</source>
          <target state="translated">在Windows上,可以使用第二个等待方法来阻止事件的完成。这需要两个句柄。一个进程作业句柄和一个事件句柄来监控。</target>
        </trans-unit>
        <trans-unit id="9658f389cd47e6221668fd22bc06e990b9d9dd68" translate="yes" xml:space="preserve">
          <source>On Windows hs_init treats argv as UTF8-encoded. Passing other encodings might lead to unexpected results. Passing NULL as argv is valid but can lead to &amp;lt;unknown&amp;gt; showing up in error messages instead of the name of the executable.</source>
          <target state="translated">在Windows上，hs_init将argv视为UTF8编码。传递其他编码可能会导致意外结果。将argv作为NULL传递是有效的，但可能导致错误消息中显示&amp;lt;unknown&amp;gt;而不是可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="b4698d639ab062d2aed61863bbaa5096920591d6" translate="yes" xml:space="preserve">
          <source>On Windows systems this flag indicates that we should wait for the entire process tree to finish before unblocking. On POSIX systems this flag is ignored. See $exec-on-windows for details.</source>
          <target state="translated">在Windows系统中,这个标志表示我们应该等待整个进程树完成后再解锁。在POSIX系统中,这个标志被忽略。详情请参阅$exec-on-windows。</target>
        </trans-unit>
        <trans-unit id="45e04fe208e77db2f230b90c671409e216534e94" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">在Windows系统上，它将生成CTRL_BREAK_EVENT，并且仅适用于使用 &lt;code&gt;createProcess&lt;/code&gt; 并设置 &lt;code&gt;&lt;a href=&quot;system-process#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 标志创建的进程</target>
        </trans-unit>
        <trans-unit id="d883d2ded3f33c4ac5277dea1b34c15e47204a0e" translate="yes" xml:space="preserve">
          <source>On Windows systems, it generates a CTRL_BREAK_EVENT and will only work for processes created using &lt;code&gt;createProcess&lt;/code&gt; and setting the &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; flag</source>
          <target state="translated">在Windows系统上，它将生成CTRL_BREAK_EVENT，并且仅适用于使用 &lt;code&gt;createProcess&lt;/code&gt; 并设置 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:create_group&quot;&gt;create_group&lt;/a&gt;&lt;/code&gt; 标志创建的进程</target>
        </trans-unit>
        <trans-unit id="1311c5b9754526fe0793423a543b261c1854ae36" translate="yes" xml:space="preserve">
          <source>On Windows systems, this calls &lt;code&gt;DeviceIoControl&lt;/code&gt; with &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also works on junction points. On POSIX systems, this calls &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">在Windows系统上，这会使用 &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt; 调用 &lt;code&gt;DeviceIoControl&lt;/code&gt; 。除了符号链接，该功能还适用于接合点。在POSIX系统上，这称为 &lt;code&gt;readlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1567544926c7445013dc0be717298582cb416b6" translate="yes" xml:space="preserve">
          <source>On Windows this has no effect.</source>
          <target state="translated">在Windows上,这没有任何效果。</target>
        </trans-unit>
        <trans-unit id="8f02d4da8e0b35ffd3d2c36f1392b357f6c5f8d8" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">在Windows上， &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 将命令传递给Windows命令解释器（ &lt;code&gt;CMD.EXE&lt;/code&gt; 或 &lt;code&gt;COMMAND.COM&lt;/code&gt; ），因此Unixy shell技巧将不起作用。</target>
        </trans-unit>
        <trans-unit id="48c350060f4cd8913452b9533ace5233eb42f47d" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; usually map to the same directory unless overridden.</source>
          <target state="translated">在Windows上，除非覆盖 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; ，否则它们通常映射到同一目录。</target>
        </trans-unit>
        <trans-unit id="b2c2a5d7334002daf6e872673bc987f5bdaaf260" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; usually map to the same list of directories unless overridden.</source>
          <target state="translated">在Windows上，除非被覆盖，否则 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; 通常映射到相同的目录列表。</target>
        </trans-unit>
        <trans-unit id="8b25994ba9790bb8044b9cc7287876fc972fce5c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; calls the Win32 function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt;, which may search other places before checking the directories in the &lt;code&gt;PATH&lt;/code&gt; environment variable. Where it actually searches depends on registry settings, but notably includes the directory containing the current executable.</source>
          <target state="translated">在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 调用Win32函数 &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365527.aspx&quot;&gt;SearchPath&lt;/a&gt;&lt;/code&gt; ，该函数可能会在检查 &lt;code&gt;PATH&lt;/code&gt; 环境变量中的目录之前搜索其他位置。它实际搜索的位置取决于注册表设置，但特别要包括包含当前可执行文件的目录。</target>
        </trans-unit>
        <trans-unit id="dca5f3e83bb026318939bea1cd25a1940f11ff0f" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; passes the command to the Windows command interpreter (&lt;code&gt;CMD.EXE&lt;/code&gt; or &lt;code&gt;COMMAND.COM&lt;/code&gt;), hence Unixy shell tricks will not work.</source>
          <target state="translated">在Windows上， &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 将命令传递给Windows命令解释器（ &lt;code&gt;CMD.EXE&lt;/code&gt; 或 &lt;code&gt;COMMAND.COM&lt;/code&gt; ），因此Unixy shell技巧将不起作用。</target>
        </trans-unit>
        <trans-unit id="c8886822cdea6ae2e0b2d173208997d3a1f79f72" translate="yes" xml:space="preserve">
          <source>On Windows, GHC normally generates a manifest file when linking a binary. The manifest is placed in the file &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the &amp;ldquo;installer detection&amp;rdquo; in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing &amp;ldquo;install&amp;rdquo;, &amp;ldquo;setup&amp;rdquo; or &amp;ldquo;patch&amp;rdquo;). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</source>
          <target state="translated">在Windows上，GHC通常在链接二进制文件时生成清单文件。该清单放置在文件 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; 其中⟨prog.exe⟩是可执行文件的名称。清单文件当前仅用于一个目的：它禁用Windows Vista中的&amp;ldquo;安装程序检测&amp;rdquo;，该程序试图提升具有某些名称（例如，包含&amp;ldquo;安装&amp;rdquo;，&amp;ldquo;安装&amp;rdquo;或&amp;ldquo;补丁&amp;rdquo;的名称）可执行文件的特权。如果没有清单文件来关闭安装程序检测，尝试运行Windows认为是安装程序的可执行文件将向调用者返回一个权限错误代码。根据调用者的不同，结果可能是一个对话框，询问用户提升的权限，也可能只是一个权限被拒绝的错误。</target>
        </trans-unit>
        <trans-unit id="df3c28898ffda6729df899cf284892444c82605a" translate="yes" xml:space="preserve">
          <source>On Windows, GHC normally generates a manifestmanifest file when linking a binary. The manifest is placed in the file &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the &amp;ldquo;installer detection&amp;rdquo; in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing &amp;ldquo;install&amp;rdquo;, &amp;ldquo;setup&amp;rdquo; or &amp;ldquo;patch&amp;rdquo;). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</source>
          <target state="translated">在Windows上，GHC通常在链接二进制文件时生成清单文件。该清单放置在文件 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.exe.manifest`&lt;/code&gt; 其中⟨prog.exe⟩是可执行文件的名称。清单文件当前仅用于一个目的：它禁用Windows Vista中的&amp;ldquo;安装程序检测&amp;rdquo;，该程序试图为具有某些名称（例如，包含&amp;ldquo;安装&amp;rdquo;，&amp;ldquo;安装&amp;rdquo;或&amp;ldquo;补丁&amp;rdquo;的名称）的可执行文件提升特权。如果没有清单文件来关闭安装程序检测，尝试运行Windows认为是安装程序的可执行文件将向调用者返回一个权限错误代码。根据调用者的不同，结果可能是一个对话框，要求用户提供提升的权限，也可能只是一个权限被拒绝的错误。</target>
        </trans-unit>
        <trans-unit id="3857f1cd71ad0bc38aa45f3e4c0b66be30d8d39f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">在Windows上，从[1]开始：&amp;ldquo;如果文件名仅以磁盘标识符开头，而不以冒号后的反斜杠开头，则它将被解释为驱动器上具有指定字母的当前目录的相对路径。&amp;rdquo; &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 当前的行为是永远不要合并这些形式。</target>
        </trans-unit>
        <trans-unit id="00fab97cf532bb811e9f99b70b73e208825c5f0f" translate="yes" xml:space="preserve">
          <source>On Windows, from [1]: &quot;If a file name begins with only a disk designator but not the backslash after the colon, it is interpreted as a relative path to the current directory on the drive with the specified letter.&quot; The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">在Windows上，从[1]开始：&amp;ldquo;如果文件名仅以磁盘标识符开头，而不以冒号后的反斜杠开头，则它将被解释为驱动器上具有指定字母的当前目录的相对路径。&amp;rdquo; &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 当前的行为是永远不要合并这些形式。</target>
        </trans-unit>
        <trans-unit id="1a1fc027f89a30d75d09af18559914b65d210c7f" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">在Windows上，如果文件路径以单个斜杠开头，则它相对于当前驱动器的根目录。在[1]中，这（被混淆地）称为绝对路径。 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 当前的行为是永远不要合并这些形式。</target>
        </trans-unit>
        <trans-unit id="c91c78ad4fae4d53474ef709fdcd0ed43c7ee0a9" translate="yes" xml:space="preserve">
          <source>On Windows, if a filepath starts with a single slash, it is relative to the root of the current drive. In [1], this is (confusingly) referred to as an absolute path. The current behavior of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; is to never combine these forms.</source>
          <target state="translated">在Windows上，如果文件路径以单个斜杠开头，则它相对于当前驱动器的根目录。在[1]中，这（被混淆地）称为绝对路径。 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt;&lt;/code&gt; 当前的行为是永远不要合并这些形式。</target>
        </trans-unit>
        <trans-unit id="4d3e5aee2864678aaa60dea89f1461abcedaa812" translate="yes" xml:space="preserve">
          <source>On Windows, it behaves like the Win32 function &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt;, which copies various kinds of metadata including file attributes and security resource properties.</source>
          <target state="translated">在Windows上，其行为类似于Win32函数&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851.aspx&quot;&gt;CopyFile&lt;/a&gt;，该函数复制各种元数据，包括文件属性和安全资源属性。</target>
        </trans-unit>
        <trans-unit id="abd019f889227ae682d9d79f35737ff6a44be1e1" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission corresponds to the &quot;read-only&quot; attribute. The &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; permission is set if the file extension is of an executable file type. The &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; permission is always set.</source>
          <target state="translated">在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 权限对应于&amp;ldquo;只读&amp;rdquo;属性。该 &lt;code&gt;&lt;a href=&quot;system-directory#v:executable&quot;&gt;executable&lt;/a&gt;&lt;/code&gt; ，如果文件扩展名是一个可执行文件类型的权限设置。该 &lt;code&gt;&lt;a href=&quot;system-directory#v:readable&quot;&gt;readable&lt;/a&gt;&lt;/code&gt; 权限始终设置。</target>
        </trans-unit>
        <trans-unit id="a82573349a58df428e5cf8f04f5449302de59c8f" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;^Z&lt;/code&gt; character is interpreted as an end-of-file character, so if you read a file containing this character the file will appear to end just before it. To avoid this, use &lt;code&gt;IOExts.openFileEx&lt;/code&gt; to open a file in binary (untranslated) mode or change an already opened file handle into binary mode using &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt;. The &lt;code&gt;IOExts&lt;/code&gt; module is part of the &lt;code&gt;lang&lt;/code&gt; package.</source>
          <target state="translated">在Windows上， &lt;code&gt;^Z&lt;/code&gt; 字符被解释为文件结尾字符，因此，如果您读取包含该字符的文件，则该文件似乎会在文件之前结束。为避免这种情况，请使用 &lt;code&gt;IOExts.openFileEx&lt;/code&gt; 以二进制（未翻译）模式打开文件，或使用 &lt;code&gt;IOExts.hSetBinaryMode&lt;/code&gt; 将已打开的文件句柄更改为二进制模式。所述 &lt;code&gt;IOExts&lt;/code&gt; 模块是的一部分 &lt;code&gt;lang&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="f4e0faedb7eb77e9f9303b4aee6bff531c17eba6" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt; with &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is also included if supported by the operating system. On POSIX, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">在Windows上，功能是通过实施 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 与 &lt;code&gt;SYMBOLIC_LINK_FLAG_DIRECTORY&lt;/code&gt; 。由于1.3.3.0，该 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 如果操作系统支持的标志也被包括在内。在POSIX上，这是 &lt;code&gt;&lt;a href=&quot;system-directory#v:createFileLink&quot;&gt;createFileLink&lt;/a&gt;&lt;/code&gt; 的别名，因此是原子的。</target>
        </trans-unit>
        <trans-unit id="a5bae1c687cf11ec3ed5ad2f9f8ff005ae0b6dfc" translate="yes" xml:space="preserve">
          <source>On Windows, the function is implemented using &lt;code&gt;CreateSymbolicLink&lt;/code&gt;. Since 1.3.3.0, the &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; flag is included if supported by the operating system. On POSIX, the function uses &lt;code&gt;symlink&lt;/code&gt; and is therefore atomic.</source>
          <target state="translated">在Windows上，该功能是使用 &lt;code&gt;CreateSymbolicLink&lt;/code&gt; 实现的。由于1.3.3.0，该 &lt;code&gt;SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE&lt;/code&gt; 如果操作系统支持的标志是包括在内。在POSIX上，该函数使用 &lt;code&gt;symlink&lt;/code&gt; ，因此是原子的。</target>
        </trans-unit>
        <trans-unit id="e855d866abccd89156106ea9ff5c5937f3c49ead" translate="yes" xml:space="preserve">
          <source>On Windows, the operation fails if &lt;em&gt;dir&lt;/em&gt; is a directory symbolic link.</source>
          <target state="translated">在Windows上，如果&lt;em&gt;dir&lt;/em&gt;是目录符号链接，则操作将失败。</target>
        </trans-unit>
        <trans-unit id="e44cd211b73577bb580283a31fe9e11ec9d0f8fb" translate="yes" xml:space="preserve">
          <source>On Windows, the path is &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt;)</source>
          <target state="translated">在Windows上，路径为 &lt;code&gt;%APPDATA%/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming/&lt;em&gt;&amp;lt;app&amp;gt;&lt;/em&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f11f1f05f568d29a8830243c65984fa477970a3c" translate="yes" xml:space="preserve">
          <source>On Windows, the system is queried for a suitable path; a typical path might be &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">在Windows上，系统会查询一条合适的路径。典型的路径可能是 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3e77adec84060bc903e2e912e15d0de80cff520" translate="yes" xml:space="preserve">
          <source>On Windows, there&amp;rsquo;s a GNU ld/BFD bug whereby it emits bogus PE object files that have more than 0xffff relocations. When GHCi tries to load a package affected by this bug, you get an error message of the form</source>
          <target state="translated">在Windows上，存在一个GNU ld / BFD错误，它会发出伪造的PE对象文件，这些文件的重定位次数超过0xffff。当GHCi尝试加载受此错误影响的软件包时，您将收到以下形式的错误消息：</target>
        </trans-unit>
        <trans-unit id="85e22f23309dbf90a94129f8db64b297cbb2f916" translate="yes" xml:space="preserve">
          <source>On Windows, this &lt;em&gt;only returns the first ocurrence&lt;/em&gt;, if any. Its behavior is therefore equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Windows上，这&lt;em&gt;仅会返回第一次出现&lt;/em&gt;（如果有）。因此，其行为等同于 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da36f078a8e10da6023ea1ab8024e74f1183e975" translate="yes" xml:space="preserve">
          <source>On Windows, this checks for &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt;. In addition to symbolic links, the function also returns true on junction points. On POSIX systems, this checks for &lt;code&gt;S_IFLNK&lt;/code&gt;.</source>
          <target state="translated">在Windows上，这将检查 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 。除符号链接外，该函数还在结点上返回true。在POSIX系统上，这将检查 &lt;code&gt;S_IFLNK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52cfb4329fc32c0d833a61183ba7721cc4129515" translate="yes" xml:space="preserve">
          <source>On Windows, this copies only the read-only attribute.</source>
          <target state="translated">在Windows上,这将只复制只读属性。</target>
        </trans-unit>
        <trans-unit id="ed105f70828ccfdebad6090636cb8dc84666d5c9" translate="yes" xml:space="preserve">
          <source>On Windows, this encoding *should not* be used if possible because the use of code pages is deprecated: Strings should be retrieved via the &quot;wide&quot; W-family of UTF-16 APIs instead</source>
          <target state="translated">在Windows上,如果可能的话,不应该使用这种编码,因为代码页的使用已经被废弃。字符串应该通过UTF-16 API的 &quot;宽 &quot;W系列来检索。</target>
        </trans-unit>
        <trans-unit id="ac2cd505b24931f86258fdc4d09b1d6d6f31c478" translate="yes" xml:space="preserve">
          <source>On Windows, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt;. On POSIX systems, this is an alias for &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在Windows上，这是 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectory&quot;&gt;removeDirectory&lt;/a&gt;&lt;/code&gt; 的别名。在POSIX系统上，这是 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="721f4605ef1d86ca2dde42c37a045d3e3a154879" translate="yes" xml:space="preserve">
          <source>On Windows, this is only capable of changing the &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; permission, which corresponds to the &quot;read-only&quot; attribute. Changing the other permissions has no effect.</source>
          <target state="translated">在Windows上，这只能更改 &lt;code&gt;&lt;a href=&quot;system-directory#v:writable&quot;&gt;writable&lt;/a&gt;&lt;/code&gt; 权限，该权限对应于&amp;ldquo;只读&amp;rdquo;属性。更改其他权限无效。</target>
        </trans-unit>
        <trans-unit id="5b5fedbf70c277d93381f0f283d73b921d80d6e3" translate="yes" xml:space="preserve">
          <source>On Windows, you can access supported code pages with the prefix &lt;code&gt;CP&lt;/code&gt;; for example, &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt;.</source>
          <target state="translated">在Windows上，您可以使用前缀 &lt;code&gt;CP&lt;/code&gt; 来访问支持的代码页；例如 &lt;code&gt;&quot;CP1250&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcbabe85dcb1f0f6be8be76732501ee39274fba1" translate="yes" xml:space="preserve">
          <source>On a 64-bit platform it is not always possible to acquire the top 64 bits of the result. Therefore, a recommended implementation is to take the absolute value of both operands, and return 0 iff bits[63:31] of them are zero, since that means that their magnitudes fit within 31 bits, so the magnitude of the product must fit into 62 bits.</source>
          <target state="translated">在64位平台上,并不总是能够获得结果的前64位。因此,推荐的实现方式是取两个操作数的绝对值,如果其中的bit[63:31]为0,则返回0,因为这意味着它们的大小适合在31位之内,所以乘积的大小必须适合在62位之内。</target>
        </trans-unit>
        <trans-unit id="ca55a4a165c97ee87021e748a5999af653eb1351" translate="yes" xml:space="preserve">
          <source>On a Core2 Duo 2.20GHz on a 32-bit Linux, the above code takes 1ms to generate the 22'500 bytes long lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Looking again at the definitions above, we see that we took care to avoid intermediate data structures, as otherwise we would sacrifice performance. For example, the following (arguably simpler) definition of &lt;code&gt;renderRow&lt;/code&gt; is about 20% slower.</source>
          <target state="translated">在32位Linux上的Core2 Duo 2.20GHz上，上面的代码花费1ms来生成22'500字节长的惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。再次看一下上面的定义，我们发现我们要小心避免中间数据结构，否则会牺牲性能。例如，以下（可能更简单）的 &lt;code&gt;renderRow&lt;/code&gt; 定义要慢大约20％。</target>
        </trans-unit>
        <trans-unit id="c8a5a9af1eb8c360fd6ffff320585505f281c939" translate="yes" xml:space="preserve">
          <source>On both reading and writing, the platform's native newline conversion is performed.</source>
          <target state="translated">在阅读和写作上,平台的原生新行转换都会进行。</target>
        </trans-unit>
        <trans-unit id="96b98fc0e34c4b769b9edb0262fc17069a81fc2b" translate="yes" xml:space="preserve">
          <source>On empty structures, this function throws an exception:</source>
          <target state="translated">在空结构上,这个函数会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="75b5bdd28cb9e313800f349b125cecb04cdb2cab" translate="yes" xml:space="preserve">
          <source>On infinite structures, this function hangs:</source>
          <target state="translated">在无限结构上,这个函数挂起。</target>
        </trans-unit>
        <trans-unit id="584fe990b6c406c5750b476c119e0a10d54a8c7d" translate="yes" xml:space="preserve">
          <source>On most UNIX platforms it is also possible to build executables that can be &lt;code&gt;dlopen&lt;/code&gt;&amp;lsquo;d like shared libraries using the &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt; flag during linking.</source>
          <target state="translated">在大多数UNIX平台上，也可以在链接过程中使用&lt;a href=&quot;phases#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt;标志来构建类似于共享库的 &lt;code&gt;dlopen&lt;/code&gt; 可执行文件。</target>
        </trans-unit>
        <trans-unit id="43e3fc1e854dceae3b55c658433a092145204e78" translate="yes" xml:space="preserve">
          <source>On most UNIX platforms it is also possible to build executables that can be &lt;code&gt;dlopen&lt;/code&gt;&amp;rsquo;d like shared libraries using the &lt;a href=&quot;phases#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt; flag during linking.</source>
          <target state="translated">在大多数UNIX平台上，也可以在链接期间使用&lt;a href=&quot;phases#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt;标志来构建可以像共享库一样 &lt;code&gt;dlopen&lt;/code&gt; 的可执行文件。</target>
        </trans-unit>
        <trans-unit id="6e3ecb7f7003c5f8586cd3273747fd5240fdd03f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在非Windows平台上，此行为等效于使用 &lt;code&gt;PATH&lt;/code&gt; 环境变量中的搜索目录的 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="7fb6c020bc093fa27959e91b43bb2cec678d112f" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, the behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the search directories from the &lt;code&gt;PATH&lt;/code&gt; environment variable and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在非Windows平台上，此行为等效于使用 &lt;code&gt;PATH&lt;/code&gt; 环境变量中的搜索目录并测试每个文件的可执行权限，从而实现 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="8188af56fd6edcf23beb2e9dcf2382a4e4902ffd" translate="yes" xml:space="preserve">
          <source>On program termination, the standard &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; are flushed automatically; any other buffered &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s need to be flushed manually, otherwise the buffered data will be discarded.</source>
          <target state="translated">程序终止时，将自动刷新标准 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; ；任何其他缓冲的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 需要手动刷新，否则缓冲的数据将被丢弃。</target>
        </trans-unit>
        <trans-unit id="b9a3d4952093702fc02750fecbc28a2a44b781b5" translate="yes" xml:space="preserve">
          <source>On program termination, the standard &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; are flushed automatically; any other buffered &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s need to be flushed manually, otherwise the buffered data will be discarded.</source>
          <target state="translated">程序终止时，将自动刷新标准 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; ；任何其他缓冲的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 需要手动刷新，否则缓冲的数据将被丢弃。</target>
        </trans-unit>
        <trans-unit id="b458bc64e60c4d81db682d145a7fc32242bb3944" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">在某些主机（例如SuSe和Ubuntu Linux）上， &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 未设置宏 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; ,则 &lt;code&gt;RTLD_NEXT&lt;/code&gt; （和RTLD_DEFAULT）不可见。由于我们不想定义此宏，因此可以使用功能 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 来检查标志 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 是否可用。理想情况下，将由编译器对其进行优化，以使其与 &lt;code&gt;#ifdef&lt;/code&gt; 一样高效。</target>
        </trans-unit>
        <trans-unit id="fe7652641a4b092db3389c67281410748d6204c1" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">在某些主机（例如SuSe和Ubuntu Linux）上， &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 未设置宏 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; ,则 &lt;code&gt;RTLD_NEXT&lt;/code&gt; （和RTLD_DEFAULT）不可见。由于我们不想定义此宏，因此可以使用功能 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 来检查标志 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 是否可用。理想情况下，将由编译器对其进行优化，以使其与 &lt;code&gt;#ifdef&lt;/code&gt; 一样高效。</target>
        </trans-unit>
        <trans-unit id="c440936ef0fa8d5c9fb4a5252385fb1aecb976b4" translate="yes" xml:space="preserve">
          <source>On some hosts (e.g. SuSe and Ubuntu Linux) &lt;code&gt;RTLD_NEXT&lt;/code&gt; (and &lt;code&gt;RTLD_DEFAULT&lt;/code&gt;) are not visible without setting the macro &lt;code&gt;_GNU_SOURCE&lt;/code&gt;. Since we don't want to define this macro, you can use the function &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; to check wether the flag &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; is available. Ideally, this will be optimized by the compiler so that it should be as efficient as an &lt;code&gt;#ifdef&lt;/code&gt;.</source>
          <target state="translated">在某些主机（例如SuSe和Ubuntu Linux）上， &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 未设置宏 &lt;code&gt;_GNU_SOURCE&lt;/code&gt; ,则 &lt;code&gt;RTLD_NEXT&lt;/code&gt; （和RTLD_DEFAULT）不可见。由于我们不想定义此宏，因此可以使用功能 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 来检查标志 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 是否可用。理想情况下，将由编译器对其进行优化，以使其与 &lt;code&gt;#ifdef&lt;/code&gt; 一样高效。</target>
        </trans-unit>
        <trans-unit id="15cb1a56421815ce54b1980f31648be5dff8f144" translate="yes" xml:space="preserve">
          <source>On some platforms GHC supports building Haskell code into shared libraries. Shared libraries are also sometimes known as dynamic libraries, in particular on Windows they are referred to as dynamic link libraries (DLLs).</source>
          <target state="translated">在某些平台上,GHC支持将Haskell代码构建到共享库中。共享库有时也被称为动态库,特别是在Windows上,它们被称为动态链接库(DLLs)。</target>
        </trans-unit>
        <trans-unit id="b3fce05ecd29b5587b3c4d8a69a917c6df74798b" translate="yes" xml:space="preserve">
          <source>On some platforms where PIC is always the case, e.g. macOS and OpenBSD on x86_64, and macOS and Linux on aarch64 this flag is enabled by default. One repercussion of this is that referenced system libraries also need to be compiled with &lt;code&gt;-fPIC&lt;/code&gt; if we need to load them in the runtime linker.</source>
          <target state="translated">在某些总是使用PIC的平台上，例如x86_64上的macOS和OpenBSD，以及aarch64上的macOS和Linux，默认情况下启用此标志。对此的一种反应是，如果需要将引用的系统库加载到运行时链接程序中，则还需要使用 &lt;code&gt;-fPIC&lt;/code&gt; 对其进行编译。</target>
        </trans-unit>
        <trans-unit id="0d36502b7263f0b4485c96cc36bc155187135ea3" translate="yes" xml:space="preserve">
          <source>On some platforms where PIC is always the case, e.g. x86_64 MacOS X, this flag is enabled by default.</source>
          <target state="translated">在某些平台上,PIC总是这样,例如x86_64 MacOS X,这个标志是默认启用的。</target>
        </trans-unit>
        <trans-unit id="8eb8ce4db21a6bb265eeec2e7b65240ba8199bdd" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.dll&lt;/code&gt;-style shared libraries, the actual library loaded will be &lt;code&gt;lib.dll&lt;/code&gt;, &lt;code&gt;liblib.dll&lt;/code&gt;. GHCi also has full support for import libraries, either Microsoft style &lt;code&gt;.lib&lt;/code&gt;, or GNU GCC style &lt;code&gt;.a&lt;/code&gt; and &lt;code&gt;.dll.a&lt;/code&gt; libraries. If you have an import library it is advisable to always specify the import libary instead of the &lt;code&gt;.dll&lt;/code&gt;. e.g. use &lt;code&gt;-lgcc` instead of
``-llibgcc_s_seh-1&lt;/code&gt;. Again, GHCi will signal an error if it can&amp;rsquo;t find the library.</source>
          <target state="translated">在具有 &lt;code&gt;.dll&lt;/code&gt; 样式的共享库的系统上，实际加载的库将是 &lt;code&gt;lib.dll&lt;/code&gt; ， &lt;code&gt;liblib.dll&lt;/code&gt; 。GHCi还完全支持导入库，例如Microsoft样式 &lt;code&gt;.lib&lt;/code&gt; 或GNU GCC样式 &lt;code&gt;.a&lt;/code&gt; 和 &lt;code&gt;.dll.a&lt;/code&gt; 库。如果您有导入库，建议始终指定导入库而不是 &lt;code&gt;.dll&lt;/code&gt; 。例如使用 &lt;code&gt;-lgcc` instead of ``-llibgcc_s_seh-1&lt;/code&gt; 。同样，如果GHCi找不到该库，则会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="21513f4e4396cb1f88f659deed17144c64c22629" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.dll&lt;/code&gt;-style shared libraries, the actual library loaded will be &lt;code&gt;lib.dll&lt;/code&gt;, &lt;code&gt;liblib.dll&lt;/code&gt;. GHCi also has full support for import libraries, either Microsoft style &lt;code&gt;.lib&lt;/code&gt;, or GNU GCC style &lt;code&gt;.a&lt;/code&gt; and &lt;code&gt;.dll.a&lt;/code&gt; libraries. If you have an import library it is advisable to always specify the import library instead of the &lt;code&gt;.dll&lt;/code&gt;. e.g. use &lt;code&gt;-lgcc` instead of
``-llibgcc_s_seh-1&lt;/code&gt;. Again, GHCi will signal an error if it can&amp;rsquo;t find the library.</source>
          <target state="translated">在具有 &lt;code&gt;.dll&lt;/code&gt; 样式的共享库的系统上，实际加载的库将是 &lt;code&gt;lib.dll&lt;/code&gt; ， &lt;code&gt;liblib.dll&lt;/code&gt; 。GHCi还完全支持导入库，无论是Microsoft样式 &lt;code&gt;.lib&lt;/code&gt; 还是GNU GCC样式 &lt;code&gt;.a&lt;/code&gt; 和 &lt;code&gt;.dll.a&lt;/code&gt; 库。如果您有导入库，建议始终指定导入库而不是 &lt;code&gt;.dll&lt;/code&gt; 。例如使用 &lt;code&gt;-lgcc` instead of ``-llibgcc_s_seh-1&lt;/code&gt; 。同样，如果GHCi找不到该库，则会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="79878901a3ff26ad9bef6e39ce6be8f5fbd886f1" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;.so&lt;/code&gt;-style shared libraries, the actual library loaded will the &lt;code&gt;liblib.so&lt;/code&gt;. GHCi searches the following places for libraries, in this order:</source>
          <target state="translated">在具有 &lt;code&gt;.so&lt;/code&gt; - style共享库的系统上，实际加载的库将为 &lt;code&gt;liblib.so&lt;/code&gt; 。GHCi按以下顺序搜索以下位置的图书馆：</target>
        </trans-unit>
        <trans-unit id="0fdf7f76740d047b5e3edd87cc87a6a11d2158f4" translate="yes" xml:space="preserve">
          <source>On the World-Wide Web, there are several URLs of likely interest:</source>
          <target state="translated">在万维网上,有几个可能感兴趣的网址。</target>
        </trans-unit>
        <trans-unit id="d05a6ef32800b6777916856b927d4f8bd9b77ba3" translate="yes" xml:space="preserve">
          <source>On the left or right (see &lt;code&gt;f4&lt;/code&gt;, for example) of a function arrow</source>
          <target state="translated">在功能箭头的左侧或右侧（例如，参见 &lt;code&gt;f4&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="265e2957a5d7f44af1209a39b3d1475fb8acdd24" translate="yes" xml:space="preserve">
          <source>On the left-hand sides of type declarations, such as classes, data types, etc.</source>
          <target state="translated">在类型声明的左侧,如类、数据类型等。</target>
        </trans-unit>
        <trans-unit id="4f305cc5e3cb7028da9ff3cbac52003a8cb62b20" translate="yes" xml:space="preserve">
          <source>On the other hand, a derived &lt;code&gt;Functor&lt;/code&gt; instances for the &lt;code&gt;CovFun&lt;/code&gt;s are within the realm of possibility:</source>
          <target state="translated">在另一方面，派生 &lt;code&gt;Functor&lt;/code&gt; 的实例 &lt;code&gt;CovFun&lt;/code&gt; s为的可能做到的：</target>
        </trans-unit>
        <trans-unit id="a0c7bdbeeec14950364d5eba585fee5f46490af7" translate="yes" xml:space="preserve">
          <source>On the other hand, function &lt;code&gt;g&lt;/code&gt; works fine, because matching against &lt;code&gt;P2&lt;/code&gt; (which wraps the GADT &lt;code&gt;S&lt;/code&gt;) provides the local equality &lt;code&gt;(a~Bool)&lt;/code&gt;. If you were to give an explicit pattern signature &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt;, then &lt;code&gt;P2&lt;/code&gt; would become less polymorphic, and would behave exactly like &lt;code&gt;P1&lt;/code&gt; so that &lt;code&gt;g&lt;/code&gt; would then be rejected.</source>
          <target state="translated">另一方面，函数 &lt;code&gt;g&lt;/code&gt; 可以正常工作，因为与 &lt;code&gt;P2&lt;/code&gt; 匹配（包装了GADT &lt;code&gt;S&lt;/code&gt; ）提供了局部等式 &lt;code&gt;(a~Bool)&lt;/code&gt; a〜Bool ）。如果要给显式模式签名 &lt;code&gt;P2 :: Bool -&amp;gt; S Bool&lt;/code&gt; ，则 &lt;code&gt;P2&lt;/code&gt; 的多态性会降低，并且表现得与 &lt;code&gt;P1&lt;/code&gt; 完全一样，因此 &lt;code&gt;g&lt;/code&gt; 将被拒绝。</target>
        </trans-unit>
        <trans-unit id="1c549059d60fda45dc8528cd8c34dd2387420acc" translate="yes" xml:space="preserve">
          <source>On the other hand, type families are exempt from this rule:</source>
          <target state="translated">另一方面,类型家族可免于这一规则。</target>
        </trans-unit>
        <trans-unit id="4c209963c4c6b38b35bf01ab372514c3bd7acc07" translate="yes" xml:space="preserve">
          <source>On the right-hand side of a type synonym, e.g.:</source>
          <target state="translated">在类型同义词的右侧,如:。</target>
        </trans-unit>
        <trans-unit id="42d363a29721400db631067ea9cb7bd7ce4d4eea" translate="yes" xml:space="preserve">
          <source>On this score, GHC usually does pretty well, especially if you &amp;ldquo;allow&amp;rdquo; it to be off by one or two. In the case of an instance or class declaration, the line number may only point you to the declaration, not to a specific method.</source>
          <target state="translated">在这个分数上，GHC通常表现不错，尤其是如果您&amp;ldquo;允许&amp;rdquo;它减少一到两个。在实例或类声明的情况下，行号可能仅指向您声明，而不指向特定方法。</target>
        </trans-unit>
        <trans-unit id="5ea755dd39d492e55b9e34b0a111d2cfb8276cb3" translate="yes" xml:space="preserve">
          <source>On transcoding errors, an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; exception is thrown. You can use the API in &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; if you need more control over error handling or transcoding.</source>
          <target state="translated">发生转码错误时，将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 异常。如果您需要对错误处理或代码转换的更多控制，则可以在&lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding中&lt;/a&gt;使用API 。</target>
        </trans-unit>
        <trans-unit id="4b575b6399010d5b474f9a9e19ba9246edb70b03" translate="yes" xml:space="preserve">
          <source>On transcoding errors, an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; exception is thrown. You can use the API in &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; if you need more control over error handling or transcoding.</source>
          <target state="translated">发生转码错误时，将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 异常。如果您需要对错误处理或代码转换的更多控制，则可以在&lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding中&lt;/a&gt;使用API 。</target>
        </trans-unit>
        <trans-unit id="674cd5b76b61a86b0bcfe28dad5e5e29ab38ac63" translate="yes" xml:space="preserve">
          <source>On transcoding errors, an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; exception is thrown. You can use the API in &lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding&lt;/a&gt; if you need more control over error handling or transcoding.</source>
          <target state="translated">发生转码错误时，将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 异常。如果您需要对错误处理或代码转换的更多控制，则可以在&lt;a href=&quot;data-text-encoding&quot;&gt;Data.Text.Encoding中&lt;/a&gt;使用API 。</target>
        </trans-unit>
        <trans-unit id="56b1aac7c401101a39c4f55a428919092262060c" translate="yes" xml:space="preserve">
          <source>OnDecodeError</source>
          <target state="translated">OnDecodeError</target>
        </trans-unit>
        <trans-unit id="6f666943e43935b64269246162dcf5a1465ea5ff" translate="yes" xml:space="preserve">
          <source>OnEncodeError</source>
          <target state="translated">OnEncodeError</target>
        </trans-unit>
        <trans-unit id="1ec9c77019b9c571c284d11d62850d0be7f7d725" translate="yes" xml:space="preserve">
          <source>OnError</source>
          <target state="translated">OnError</target>
        </trans-unit>
        <trans-unit id="ed0ab25823975d83734fae1b6bd16e05190469eb" translate="yes" xml:space="preserve">
          <source>Once EOF is encountered, the Handle is closed.</source>
          <target state="translated">一旦遇到EOF,则关闭Handle。</target>
        </trans-unit>
        <trans-unit id="60e264a17495d5948da3fde8b611b62bef7e4a18" translate="yes" xml:space="preserve">
          <source>Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed. The contents of this final list is only partially specified: it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed.</source>
          <target state="translated">一旦一个半封闭的句柄被关闭,相关列表的内容就会固定下来。这个最终列表的内容只是部分指定:它将至少包含在句柄关闭之前被评估的流的所有项目。</target>
        </trans-unit>
        <trans-unit id="6cef81242bdb3dd15794848f47ffe89e35f13fea" translate="yes" xml:space="preserve">
          <source>Once again, the profiling facilities (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;) are the basic tool for demystifying the space behaviour of your program.</source>
          <target state="translated">再一次，分析工具（&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;）是使程序的空间行为神秘化的基本工具。</target>
        </trans-unit>
        <trans-unit id="5a380911a32818bc0a573ee902e7c81ff47d4df3" translate="yes" xml:space="preserve">
          <source>Once the system call is successfully interrupted, the surrounding code must return control out of the &lt;code&gt;foreign import&lt;/code&gt;, back into Haskell code, so that the &lt;code&gt;throwTo&lt;/code&gt; Haskell exception can be raised there.</source>
          <target state="translated">成功中断系统调用后，周围的代码必须将控制权从 &lt;code&gt;foreign import&lt;/code&gt; 中返回，返回到Haskell代码中，以便在 &lt;code&gt;throwTo&lt;/code&gt; 可以引发throwTo Haskell异常。</target>
        </trans-unit>
        <trans-unit id="315e28f14a5749001346c76c600fc06cf79ac069" translate="yes" xml:space="preserve">
          <source>Once the user declares type family to be injective GHC must verify that this declaration is correct, i.e., that type family equations don&amp;rsquo;t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way the user claims and an error is reported. In the bullets below &lt;em&gt;RHS&lt;/em&gt; refers to the right-hand side of the type family equation being checked for injectivity. &lt;em&gt;LHS&lt;/em&gt; refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</source>
          <target state="translated">一旦用户宣布类型族为内射型，GHC必须验证该声明是否正确，即类型族方程式不违反内射性注解。一般的想法是，如果至少一个方程式（下面的子弹（1），（2）和（3））或一对方程式（下面的子弹（4）和（5））违反了注记注释，则类型族是并非以用户要求的方式进行内射，并报告了错误。在下面的项目符号中，&lt;em&gt;RHS&lt;/em&gt;指的是要检查内射性的类型族方程的右侧。&lt;em&gt;LHS&lt;/em&gt;引用该类型族方程的参数。以下是检查类型族的插入性时遵循的规则：</target>
        </trans-unit>
        <trans-unit id="ffc00d55d5cade6b9732f3047fd68f9150e53462" translate="yes" xml:space="preserve">
          <source>Once the user declares type family to be injective GHC must verify that this declaration is correct, ie. type family equations don&amp;rsquo;t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way user claims and an error is reported. In the bullets below &lt;em&gt;RHS&lt;/em&gt; refers to the right-hand side of the type family equation being checked for injectivity. &lt;em&gt;LHS&lt;/em&gt; refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</source>
          <target state="translated">一旦用户宣布类型族为可注射型，GHC必须确认该声明正确无误。类型族方程不违反注入性注释。一般的想法是，如果至少一个方程式（下面的项目符号（1），（2）和（3））或一对方程式（下面的项目符号（4）和（5））违反了内注性注释，则类型族是不能以用户要求的方式进行内射，并报告错误。在下面的项目符号中，&lt;em&gt;RHS&lt;/em&gt;指的是要检查内射性的类型族方程的右侧。&lt;em&gt;LHS&lt;/em&gt;引用该类型族方程的参数。以下是检查类型族的插入性时遵循的规则：</target>
        </trans-unit>
        <trans-unit id="c50b67bca5fb4c6603a23fdfb82c3d73e171c099" translate="yes" xml:space="preserve">
          <source>Once you have a library of GHCi macros, you may want to source them from separate files, or you may want to source your &lt;code&gt;.ghci&lt;/code&gt; file into your running GHCi session while debugging it</source>
          <target state="translated">拥有GHCi宏库后，您可能希望从单独的文件中获取它们，或者在调试时将 &lt;code&gt;.ghci&lt;/code&gt; 文件源到正在运行的GHCi会话中</target>
        </trans-unit>
        <trans-unit id="6e7e950f611ffeefb5dc8da946a455d9ce68ff45" translate="yes" xml:space="preserve">
          <source>Once you know the producer or the type of the heap in the drag or void states, the next step is usually to find the retainer(s):</source>
          <target state="translated">一旦你知道了生产者或堆在拖动或空闲状态下的类型,下一步通常是找到保持器。</target>
        </trans-unit>
        <trans-unit id="68e926d9c748359a8152a413a626288e329b3079" translate="yes" xml:space="preserve">
          <source>One can then use functions from &lt;code&gt;GHC.Stack&lt;/code&gt; to inspect or pretty print (as is done in &lt;code&gt;f&lt;/code&gt; below) the call stack.</source>
          <target state="translated">然后可以使用 &lt;code&gt;GHC.Stack&lt;/code&gt; 中的函数来检查或漂亮地打印（如下面 &lt;code&gt;f&lt;/code&gt; 所示）调用堆栈。</target>
        </trans-unit>
        <trans-unit id="4023758f19beece83257d349668ba73b4a5f55d3" translate="yes" xml:space="preserve">
          <source>One can think of this instance being implemented with the same code as the &lt;code&gt;Num Int&lt;/code&gt; instance, but with &lt;code&gt;Dollars&lt;/code&gt; and &lt;code&gt;getDollars&lt;/code&gt; added wherever necessary in order to make it typecheck. (In practice, GHC uses a somewhat different approach to code generation. See the &lt;a href=&quot;#precise-gnd-specification&quot;&gt;A more precise specification&lt;/a&gt; section below for more details.)</source>
          <target state="translated">可以想到该实例是用与 &lt;code&gt;Num Int&lt;/code&gt; 实例相同的代码实现的，但是在必要时添加了 &lt;code&gt;Dollars&lt;/code&gt; 和 &lt;code&gt;getDollars&lt;/code&gt; 以便进行类型检查。（实际上，GHC使用了一些不同的方法来生成代码。有关更多详细信息，请参见下面的&lt;a href=&quot;#precise-gnd-specification&quot;&gt;&amp;ldquo;更精确的规范&amp;rdquo;&lt;/a&gt;部分。）</target>
        </trans-unit>
        <trans-unit id="9743b7636df84ead47845f240cbbd477f19f70e0" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">当与（可以安全地）对列表使用的函数结合使用时，可以使用 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="4ec55bf61d8ab5d04d04ebcb2ee2159a392ea14e" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; to avoid pattern matching when combined with a function that (safely) works on lists:</source>
          <target state="translated">当与（可以安全地）对列表使用的函数结合使用时，可以使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="c3d9ffa5463e1c26285c5e33a8e8a9504fd92ef8" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;-XEmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">一个可以使用的没有构造函数写数据类型&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;-XEmptyDataDecls&lt;/code&gt; &lt;/a&gt;标志（请参见&lt;a href=&quot;#nullary-types&quot;&gt;数据类型与没有构造函数&lt;/a&gt;），这是由2010年的Haskell默认的不是在默认情况下是能够对这些类型的派生类型的类的实例。通过使用&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt;标志可以启用此功能。例如，这让一个人写道：</target>
        </trans-unit>
        <trans-unit id="7322eb1a388043bfc4b465ffeaf47b177b19e690" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">一个可以使用的没有构造函数写数据类型&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt;标志（请参见&lt;a href=&quot;#nullary-types&quot;&gt;数据类型与没有构造函数&lt;/a&gt;），这是由2010年的Haskell默认的不是在默认情况下是能够对这些类型的派生类型的类的实例。通过使用&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt;标志启用此功能。例如，这让一个人写道：</target>
        </trans-unit>
        <trans-unit id="c6ae12379e0fe869830a2a8d82eea0f9f8a587bc" translate="yes" xml:space="preserve">
          <source>One can write data types with no constructors using the &lt;a href=&quot;nullary_types#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;nullary_types#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag. For instance, this lets one write:</source>
          <target state="translated">一个可以使用的没有构造函数写数据类型&lt;a href=&quot;nullary_types#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt;标志（请参见&lt;a href=&quot;nullary_types#nullary-types&quot;&gt;数据类型与没有构造函数&lt;/a&gt;），这是由2010年的Haskell默认的不是在默认情况下是能够对这些类型的派生类型的类的实例。通过使用&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt;标志启用此功能。例如，这让一个人写道：</target>
        </trans-unit>
        <trans-unit id="3d496c6b9647ae6150efda24096b39fcf9eb1a86" translate="yes" xml:space="preserve">
          <source>One consequence of the way that GHCi follows dependencies to find modules to load is that every module must have a source file. The only exception to the rule is modules that come from a package, including the &lt;code&gt;Prelude&lt;/code&gt; and standard libraries such as &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt;. If you attempt to load a module for which GHCi can&amp;rsquo;t find a source file, even if there are object and interface files for the module, you&amp;rsquo;ll get an error message.</source>
          <target state="translated">GHCi遵循依赖关系以查找要加载的模块的方式的一个后果是，每个模块都必须具有一个源文件。该规则的唯一例外是来自软件包的模块，包括 &lt;code&gt;Prelude&lt;/code&gt; 和 &lt;code&gt;IO&lt;/code&gt; 和 &lt;code&gt;Complex&lt;/code&gt; 等标准库。如果尝试加载GHCi找不到源文件的模块，即使该模块有目标文件和接口文件，也会收到错误消息。</target>
        </trans-unit>
        <trans-unit id="5483c77e4f829cc17d6601c4ac4404068ce5302b" translate="yes" xml:space="preserve">
          <source>One could either pick the &lt;code&gt;DeriveAnyClass&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt; or the &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; approach to deriving &lt;code&gt;C&lt;/code&gt;, both of which would be equally as valid. GHC defaults to favoring &lt;code&gt;DeriveAnyClass&lt;/code&gt; in such a dispute, but this is not a satisfying solution, since that leaves users unable to use both language extensions in a single module.</source>
          <target state="translated">可以选择 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 方法派生 &lt;code&gt;C&lt;/code&gt; 或 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 方法派生 &lt;code&gt;C&lt;/code&gt; ，这两种方法都同样有效。GHC 在这种争议中默认不支持 &lt;code&gt;DeriveAnyClass&lt;/code&gt; ，但这不是令人满意的解决方案，因为这使用户无法在单个模块中使用两种语言扩展。</target>
        </trans-unit>
        <trans-unit id="07da619a058ee72f68e35cbedda9fed2d2008eeb" translate="yes" xml:space="preserve">
          <source>One day in &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 中的一天。</target>
        </trans-unit>
        <trans-unit id="3d64ec6630f50a5fa3cc17dae6e273e1017ecb35" translate="yes" xml:space="preserve">
          <source>One equation of a type family instance or closed type family. The arguments are the left-hand-side type and the right-hand-side result.</source>
          <target state="translated">一个类型族实例或封闭类型族的一个方程。参数是左手边的类型和右手边的结果。</target>
        </trans-unit>
        <trans-unit id="8ad7e9507f922f5c3971e0839b353cb5b01d4c7f" translate="yes" xml:space="preserve">
          <source>One final note: the &lt;code&gt;aaaa&lt;/code&gt;&lt;code&gt;bbbb&lt;/code&gt; example may not work too well on GHC (see Scheduling, above), due to the locking on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. Only one thread may hold the lock on a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; at any one time, so if a reschedule happens while a thread is holding the lock, the other thread won't be able to run. The upshot is that the switch from &lt;code&gt;aaaa&lt;/code&gt; to &lt;code&gt;bbbbb&lt;/code&gt; happens infrequently. It can be improved by lowering the reschedule tick period. We also have a patch that causes a reschedule whenever a thread waiting on a lock is woken up, but haven't found it to be useful for anything other than this example :-)</source>
          <target state="translated">最后一点： &lt;code&gt;aaaa&lt;/code&gt; &lt;code&gt;bbbb&lt;/code&gt; 示例在GHC上可能效果不佳（请参见上面的调度），这是由于 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上的锁定。任何时候只有一个线程可以在一个 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上持有该锁，因此，如果在一个线程持有该锁的同时进行了重新计划，则另一个线程将无法运行。结果是从 &lt;code&gt;aaaa&lt;/code&gt; 到 &lt;code&gt;bbbbb&lt;/code&gt; 的切换很少发生。可以通过减少重新计划的滴答周期来改进它。我们还提供了一个补丁程序，该补丁程序会在等待锁的线程被唤醒时导致重新计划，但除了本示例以外，它还没有发现其他有用的方法:-)</target>
        </trans-unit>
        <trans-unit id="cca5d9a52684589d02fe67865e293c54351f48de" translate="yes" xml:space="preserve">
          <source>One of the motivating examples was the ability to register compiler hooks from a plugin. For example, one might want to modify the way Template Haskell code is executed. This is achievable by updating the &lt;code&gt;hooks&lt;/code&gt; field of the &lt;code&gt;DynFlags&lt;/code&gt; type, recording our custom &amp;ldquo;meta hook&amp;rdquo; in the right place. A simple application of this idea can be seen below:</source>
          <target state="translated">激励示例之一是能够从插件注册编译器挂钩。例如，可能要修改执行模板Haskell代码的方式。这可以通过更新 &lt;code&gt;DynFlags&lt;/code&gt; 类型的 &lt;code&gt;hooks&lt;/code&gt; 字段，并在正确的位置记录我们的自定义&amp;ldquo; meta hook&amp;rdquo;来实现。这个想法的简单应用如下所示：</target>
        </trans-unit>
        <trans-unit id="95ea55d691054154f178c4188946d4c03f7e9c26" translate="yes" xml:space="preserve">
          <source>One of these new quantified constraints can appear anywhere that any other constraint can, not just in instance declarations. Notably, it can appear in a type signature for a value binding, data constructor, or expression. For example</source>
          <target state="translated">这些新的量化约束之一可以出现在任何其他约束可以出现的地方,而不仅仅是在实例声明中。值得注意的是,它可以出现在值绑定、数据构造函数或表达式的类型签名中。例如</target>
        </trans-unit>
        <trans-unit id="61fc274a467ee7617c4b73c08349e4d3c37da810" translate="yes" xml:space="preserve">
          <source>One or more.</source>
          <target state="translated">一个或多个。</target>
        </trans-unit>
        <trans-unit id="4b9e1cd86b2ee828fde7016484a1c36fb1da2c89" translate="yes" xml:space="preserve">
          <source>One or none.</source>
          <target state="translated">一个或没有。</target>
        </trans-unit>
        <trans-unit id="2e17f5233f1634abadabdb2fd410bbc1afa1bc70" translate="yes" xml:space="preserve">
          <source>One simplification allowed by combining types and kinds is that the type of &lt;code&gt;Type&lt;/code&gt; is just &lt;code&gt;Type&lt;/code&gt;. It is true that the &lt;code&gt;Type :: Type&lt;/code&gt; axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) &lt;em&gt;does&lt;/em&gt; mean that despite the expressiveness of GHC&amp;rsquo;s type system, a &amp;ldquo;proof&amp;rdquo; you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.</source>
          <target state="translated">组合类型和种类所允许的一种简化是 &lt;code&gt;Type&lt;/code&gt; 的 &lt;code&gt;Type&lt;/code&gt; 就是Type。 &lt;code&gt;Type :: Type&lt;/code&gt; 公理确实可以导致非终止，但这在GHC中不是问题，因为我们已经有了其他非终止类型和表达式程序的方法。这个决定（在许多其他决定中）&lt;em&gt;确实&lt;/em&gt;意味着，尽管GHC的类型系统具有表现力，但是您在Haskell中编写的&amp;ldquo;证明&amp;rdquo;并不是无可辩驳的数学证明。 GHC仅保证部分正确，即如果您的程序编译并运行完成，则其结果确实具有指定的类型。对于没有在有限时间内完成的程序，它没有任何要求。</target>
        </trans-unit>
        <trans-unit id="04e45da5d15f7b84f75303b148b0c58446719a7a" translate="yes" xml:space="preserve">
          <source>One solution would be to represent an occurrence of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; with 'Rec0 Int' instead. With this approach, however, the programmer has no way of knowing whether the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is actually an &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; in disguise.</source>
          <target state="translated">一种解决方案是改为用'Rec0 Int' 表示 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 的出现。但是，使用这种方法，程序员无法知道 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 实际上是否是变相的 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71086252ab12cdaa049eefe6701cf95f5fcaa5cf" translate="yes" xml:space="preserve">
          <source>One stylistic reason for wanting to write a type signature is simple documentation. Another is that you may want to bring scoped type variables into scope. For example:</source>
          <target state="translated">想写类型签名的一个风格上的原因是简单的文档。另一个原因是,你可能想把范围内的类型变量纳入范围。例如</target>
        </trans-unit>
        <trans-unit id="45133c20fc7ccdca10220b7b14632f7d9475ba07" translate="yes" xml:space="preserve">
          <source>One time when &lt;code&gt;Float&lt;/code&gt; might be a good idea is if you have a &lt;em&gt;lot&lt;/em&gt; of them, say a giant array of &lt;code&gt;Float&lt;/code&gt;s. They take up half the space in the heap compared to &lt;code&gt;Doubles&lt;/code&gt;. However, this isn&amp;rsquo;t true on a 64-bit machine.</source>
          <target state="translated">有一次，当 &lt;code&gt;Float&lt;/code&gt; 可能是一个不错的想法是，如果你有&lt;em&gt;很多的&lt;/em&gt;人，说的巨型阵列 &lt;code&gt;Float&lt;/code&gt; 秒。与 &lt;code&gt;Doubles&lt;/code&gt; 相比，它们占据了堆空​​间的一半。但是，在64位计算机上并非如此。</target>
        </trans-unit>
        <trans-unit id="a12bfceb7507e74d1f52bf5268e41928d787ee56" translate="yes" xml:space="preserve">
          <source>One way out is to define an extended &lt;code&gt;assert&lt;/code&gt; function which also takes a descriptive string to include in the error message and perhaps combine this with the use of a pre-processor which inserts the source location where &lt;code&gt;assert&lt;/code&gt; was used.</source>
          <target state="translated">一种解决方法是定义一个扩展的 &lt;code&gt;assert&lt;/code&gt; 函数，该函数还需要在错误消息中包含一个描述性字符串，并可能与预处理器结合使用，该预处理器会插入使用 &lt;code&gt;assert&lt;/code&gt; 的源位置。</target>
        </trans-unit>
        <trans-unit id="fc58693ff257f4600136a2111c4960ba6926b129" translate="yes" xml:space="preserve">
          <source>One way to do this is to create a &lt;code&gt;foreign export&lt;/code&gt; that will do whatever needs to be done to wake up the Haskell thread - perhaps &lt;code&gt;putMVar&lt;/code&gt; - and then call this from our C callback. There are a couple of problems with this:</source>
          <target state="translated">一种方法是创建一个 &lt;code&gt;foreign export&lt;/code&gt; ，该文件将执行唤醒Haskell线程（可能是 &lt;code&gt;putMVar&lt;/code&gt; )所需的所有操作，然后从我们的C回调中调用它。这有两个问题：</target>
        </trans-unit>
        <trans-unit id="896496c9fe69e79ba2c5e72301d3696844b503d6" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">使用 &lt;code&gt;INLINABLE&lt;/code&gt; 的一种方法是与 &lt;code&gt;inline&lt;/code&gt; 特殊功能（&lt;a href=&quot;#special-ids&quot;&gt;内建&lt;/a&gt;特殊功能）结合使用。调用 &lt;code&gt;inline f&lt;/code&gt; 非常尝试内联 &lt;code&gt;f&lt;/code&gt; 。为了确保 &lt;code&gt;f&lt;/code&gt; 可以内联，最好将 &lt;code&gt;f&lt;/code&gt; 的定义标记为 &lt;code&gt;INLINABLE&lt;/code&gt; ，以便GHC保证暴露出展开的大小，而不管其大小如何。此外，通过将 &lt;code&gt;f&lt;/code&gt; 注释为 &lt;code&gt;INLINABLE&lt;/code&gt; ，可以确保内联 &lt;code&gt;f&lt;/code&gt; 的原始RHS，而不是生成 &lt;code&gt;f&lt;/code&gt; GHC优化器的任何随机优化版本。</target>
        </trans-unit>
        <trans-unit id="e1ca150617a20c94c6d991df08ea7fec8c13f698" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">使用 &lt;code&gt;INLINABLE&lt;/code&gt; 的一种方法是与特殊功能 &lt;code&gt;inline&lt;/code&gt; （&lt;a href=&quot;#special-ids&quot;&gt;特殊内置函数&lt;/a&gt;）结合使用。调用 &lt;code&gt;inline f&lt;/code&gt; 很难内联 &lt;code&gt;f&lt;/code&gt; 。为了确保 &lt;code&gt;f&lt;/code&gt; 可以内联，将 &lt;code&gt;f&lt;/code&gt; 的定义标记为 &lt;code&gt;INLINABLE&lt;/code&gt; 是一个好主意，这样GHC保证不管它有多大都公开一个展开的对象。此外，通过将 &lt;code&gt;f&lt;/code&gt; 注释为 &lt;code&gt;INLINABLE&lt;/code&gt; ，可以确保内联 &lt;code&gt;f&lt;/code&gt; 的原始RHS，而不是生成 &lt;code&gt;f&lt;/code&gt; GHC优化器的任何随机优化版本。</target>
        </trans-unit>
        <trans-unit id="6d3c0eb3dec0638d303cc14348ea33fc7756e47a" translate="yes" xml:space="preserve">
          <source>One way to use &lt;code&gt;INLINABLE&lt;/code&gt; is in conjunction with the special function &lt;code&gt;inline&lt;/code&gt; (&lt;a href=&quot;special_builtin#special-ids&quot;&gt;Special built-in functions&lt;/a&gt;). The call &lt;code&gt;inline f&lt;/code&gt; tries very hard to inline &lt;code&gt;f&lt;/code&gt;. To make sure that &lt;code&gt;f&lt;/code&gt; can be inlined, it is a good idea to mark the definition of &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, you ensure that &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s original RHS is inlined, rather than whatever random optimised version of &lt;code&gt;f&lt;/code&gt; GHC&amp;rsquo;s optimiser has produced.</source>
          <target state="translated">使用 &lt;code&gt;INLINABLE&lt;/code&gt; 的一种方法是与特殊功能 &lt;code&gt;inline&lt;/code&gt; （&lt;a href=&quot;special_builtin#special-ids&quot;&gt;特殊内置函数&lt;/a&gt;）结合使用。调用 &lt;code&gt;inline f&lt;/code&gt; 很难内联 &lt;code&gt;f&lt;/code&gt; 。为了确保 &lt;code&gt;f&lt;/code&gt; 可以内联，将 &lt;code&gt;f&lt;/code&gt; 的定义标记为 &lt;code&gt;INLINABLE&lt;/code&gt; 是一个好主意，这样GHC保证不管它有多大都公开一个展开的对象。此外，通过将 &lt;code&gt;f&lt;/code&gt; 注释为 &lt;code&gt;INLINABLE&lt;/code&gt; ，可以确保内联 &lt;code&gt;f&lt;/code&gt; 的原始RHS，而不是生成 &lt;code&gt;f&lt;/code&gt; GHC优化器的任何随机优化版本。</target>
        </trans-unit>
        <trans-unit id="4dba5747f4551a506f4292cb3c2030f7b24af891" translate="yes" xml:space="preserve">
          <source>One way to use this flag is to set a breakpoint on &lt;code&gt;LongGCSync()&lt;/code&gt; in the debugger, and find the thread that is delaying the sync. You probably want to use &lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt;&lt;code&gt;-g&lt;/code&gt;&lt;/a&gt; to provide more info to the debugger.</source>
          <target state="translated">使用此标志的一种方法是在调试器中的 &lt;code&gt;LongGCSync()&lt;/code&gt; 上设置一个断点，然后查找延迟同步的线程。您可能想使用&lt;a href=&quot;debug-info#ghc-flag--g&quot;&gt; &lt;code&gt;-g&lt;/code&gt; &lt;/a&gt;向调试器提供更多信息。</target>
        </trans-unit>
        <trans-unit id="d2c680b63b6bef62589b5937a565537e66960d46" translate="yes" xml:space="preserve">
          <source>One workaround is to use the &lt;a href=&quot;using#ghc-flag--msse2&quot;&gt;&lt;code&gt;-msse2&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;using#options-platform&quot;&gt;Platform-specific Flags&lt;/a&gt;), which generates code to use the SSE2 instruction set instead of the x87 instruction set. SSE2 code uses the correct precision for all floating-point operations, and so gives deterministic results. However, note that this only works with processors that support SSE2 (Intel Pentium 4 or AMD Athlon 64 and later), which is why the option is not enabled by default. The libraries that come with GHC are probably built without this option, unless you built GHC yourself.</source>
          <target state="translated">一种解决方法是使用&lt;a href=&quot;using#ghc-flag--msse2&quot;&gt; &lt;code&gt;-msse2&lt;/code&gt; &lt;/a&gt;选项（请参阅&lt;a href=&quot;using#options-platform&quot;&gt;平台特定的标志&lt;/a&gt;），该选项生成代码以使用SSE2指令集而不是x87指令集。SSE2代码对所有浮点运算都使用正确的精度，因此可以提供确定的结果。但是，请注意，这仅适用于支持SSE2的处理器（Intel Pentium 4或AMD Athlon 64及更高版本），这就是默认情况下未启用该选项的原因。除非您自己构建GHC，否则GHC随附的库可能没有此选项即可构建。</target>
        </trans-unit>
        <trans-unit id="1dfc86abc6a3fb1a97eebda069c8175f292ebd73" translate="yes" xml:space="preserve">
          <source>OneLineGCStats</source>
          <target state="translated">OneLineGCStats</target>
        </trans-unit>
        <trans-unit id="927d5cf27de83f9a93bc0c43d5e9992d0e575568" translate="yes" xml:space="preserve">
          <source>OneLineMode</source>
          <target state="translated">OneLineMode</target>
        </trans-unit>
        <trans-unit id="293e0ad51fda89c714a301db9fbb3d1d9e6c34d7" translate="yes" xml:space="preserve">
          <source>OneShot</source>
          <target state="translated">OneShot</target>
        </trans-unit>
        <trans-unit id="92340949cbfd5f6b38df2be19df951ad335baa8c" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;dynamic&lt;/em&gt; flags can be used in an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;).</source>
          <target state="translated">只有&lt;em&gt;动态的&lt;/em&gt;标志可以在使用 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 附注（见&lt;a href=&quot;#mode-dynamic-flags&quot;&gt;动态和模式选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5805ff05f15235a01101ac5b0cf4fe9284ddd19e" translate="yes" xml:space="preserve">
          <source>Only a subset of &lt;code&gt;.hsc&lt;/code&gt; syntax is supported by &lt;code&gt;--cross-compile&lt;/code&gt;. The following are unsupported:</source>
          <target state="translated">&lt;code&gt;--cross-compile&lt;/code&gt; 仅支持 &lt;code&gt;.hsc&lt;/code&gt; 语法的子集。不支持以下内容：</target>
        </trans-unit>
        <trans-unit id="c0c7ea9b4b424e7701e19b198d45f22f5ddc88ca" translate="yes" xml:space="preserve">
          <source>Only defined for &lt;code&gt;base-4.7.0.0&lt;/code&gt; and later</source>
          <target state="translated">仅针对 &lt;code&gt;base-4.7.0.0&lt;/code&gt; 及更高版本定义</target>
        </trans-unit>
        <trans-unit id="4a596037bffe0627dd076aba851bf6d728006681" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-fllvm&lt;/code&gt; is specified. When GHC is using version &lt;code&gt;x.y.z&lt;/code&gt; of LLVM, the value of &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example when using version 3.7 of LLVM, &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt;).</source>
          <target state="translated">仅在指定 &lt;code&gt;-fllvm&lt;/code&gt; 时定义。当GHC使用LLVM的 &lt;code&gt;x.y.z&lt;/code&gt; 版本时， &lt;code&gt;__GLASGOW_HASKELL_LLVM__&lt;/code&gt; 的值是整数⟨xyy⟩（如果yy是一个数字，则添加前导零，因此例如，当使用LLVM 3.7版时， &lt;code&gt;__GLASGOW_HASKELL_LLVM__==307&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="77501c9a6b02892b95f0d3d080f47d0f67625a4e" translate="yes" xml:space="preserve">
          <source>Only defined when &lt;code&gt;-parallel&lt;/code&gt; is in use! This symbol is defined when pre-processing Haskell (input) and pre-processing C (GHC output).</source>
          <target state="translated">仅在使用 &lt;code&gt;-parallel&lt;/code&gt; 时定义！在预处理Haskell（输入）和预处理C（GHC输出）时定义此符号。</target>
        </trans-unit>
        <trans-unit id="e0c06d06e0a5175e07456f6f291ad2c1525ce9e4" translate="yes" xml:space="preserve">
          <source>Only instances which could potentially be used will be displayed in the results. Instances which require unsatisfiable constraints such as &lt;code&gt;TypeError&lt;/code&gt; will not be included. In the following example, the instance for &lt;code&gt;A&lt;/code&gt; is not shown because it cannot be used.</source>
          <target state="translated">结果中仅显示可能使用的实例。需要不满足要求的约束（例如 &lt;code&gt;TypeError&lt;/code&gt; )的实例将不包括在内。在以下示例中，未显示 &lt;code&gt;A&lt;/code&gt; 的实例，因为它无法使用。</target>
        </trans-unit>
        <trans-unit id="7ff1cf96778de3d5827e74815c075270e8782040" translate="yes" xml:space="preserve">
          <source>Only one of the two class parameters is a parameter to the data family. Hence, the following instance declaration is invalid:</source>
          <target state="translated">两个类参数中只有一个是数据族的参数。因此,下面的实例声明是无效的。</target>
        </trans-unit>
        <trans-unit id="2721baf97a0c4efdd138d61549b8c89209e4143c" translate="yes" xml:space="preserve">
          <source>Only the instance head counts. In the example above, it is not good enough for &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s declaration to be in module &lt;code&gt;A&lt;/code&gt;; it must be the declaration of &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">仅实例头计数。在上面的示例中，将 &lt;code&gt;C&lt;/code&gt; 的声明放在模块 &lt;code&gt;A&lt;/code&gt; 中是不够的；它必须是 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 的声明。</target>
        </trans-unit>
        <trans-unit id="9c3f07cc6d0c90bb9379747728c0148950cf6bc3" translate="yes" xml:space="preserve">
          <source>Only the instance head counts. In the example above, it is not good enough for &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s declaration to be in module &lt;code&gt;A&lt;/code&gt;; it must be the declaration of &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">仅实例头计数。在上面的示例中，将 &lt;code&gt;C&lt;/code&gt; 的声明放在模块 &lt;code&gt;A&lt;/code&gt; 中是不够的；它必须是 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 的声明。</target>
        </trans-unit>
        <trans-unit id="e7998f0bdcbff51167fe5e1c42e1067cc0272867" translate="yes" xml:space="preserve">
          <source>Only the outer constructor is taken into consideration:</source>
          <target state="translated">只考虑到外部构造者。</target>
        </trans-unit>
        <trans-unit id="868f341dfb14a799178bbe260757188c4e090543" translate="yes" xml:space="preserve">
          <source>Only used internally</source>
          <target state="translated">仅在内部使用</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="c637aebe3a2825fb1f2be997a9434f3ce48a4b93" translate="yes" xml:space="preserve">
          <source>Opaque</source>
          <target state="translated">Opaque</target>
        </trans-unit>
        <trans-unit id="ab610cf3766e2ab5ebbdef1c372c6423bceb9405" translate="yes" xml:space="preserve">
          <source>Open a file and make an &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; for it. Truncates the file to zero size when the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">打开文件并为其创建 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 。截断文件时零大小 &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb658d04e484f6ef351935e7a9b766b60debe2d4" translate="yes" xml:space="preserve">
          <source>Open a named semaphore with the given name, flags, mode, and initial value.</source>
          <target state="translated">用给定的名称、标志、模式和初始值打开一个命名的信号体。</target>
        </trans-unit>
        <trans-unit id="f57c4790f7f34a8ca95eceb331923fb2088fdde1" translate="yes" xml:space="preserve">
          <source>Open a shared memory object with the given name, flags, and mode.</source>
          <target state="translated">用给定的名称、标志和模式打开一个共享内存对象。</target>
        </trans-unit>
        <trans-unit id="a4120aa06412e5adc4c600815d8ebb61aa98d422" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">打开并选择创建此文件。有关如何使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 类型的信息，请参见 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea860b430753ad4955968e34ae243867a6c5fb04" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">打开并选择创建此文件。有关如何使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 类型的信息，请参见 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38d704fa0fd9546874e23fac804b3c4c73ca5c95" translate="yes" xml:space="preserve">
          <source>Open and optionally create this file. See &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; for information on how to use the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">打开并选择创建此文件。有关如何使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:FileMode&quot;&gt;FileMode&lt;/a&gt;&lt;/code&gt; 类型的信息，请参见 &lt;code&gt;&lt;a href=&quot;system-posix#v:Files&quot;&gt;Files&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="316640348a429645fef91dfb05b3196eb965850e" translate="yes" xml:space="preserve">
          <source>Open indexed type families are introduced by a signature, such as</source>
          <target state="translated">开放式索引类型族是由一个签名引入的,例如</target>
        </trans-unit>
        <trans-unit id="62d19b763ce96acde6de1a0a0a137c190e97e371" translate="yes" xml:space="preserve">
          <source>Open type and data family declarations are exactly as in Haskell.</source>
          <target state="translated">开放类型和数据族的声明与Haskell中完全一样。</target>
        </trans-unit>
        <trans-unit id="345592cb9cc814b84d928db32f524bd68b8e8665" translate="yes" xml:space="preserve">
          <source>OpenExtHandle</source>
          <target state="translated">OpenExtHandle</target>
        </trans-unit>
        <trans-unit id="be4ef35b845f3f8742151ba042e927f175f32d3d" translate="yes" xml:space="preserve">
          <source>OpenFileFlags</source>
          <target state="translated">OpenFileFlags</target>
        </trans-unit>
        <trans-unit id="d4c5cbf148e8ab067ee8fcd91a86a68f327e2c93" translate="yes" xml:space="preserve">
          <source>OpenFileLimit</source>
          <target state="translated">OpenFileLimit</target>
        </trans-unit>
        <trans-unit id="b2a5470d265ed406614e0d033c4ebe86bf811418" translate="yes" xml:space="preserve">
          <source>OpenHandle</source>
          <target state="translated">OpenHandle</target>
        </trans-unit>
        <trans-unit id="f3dd14171959950898b3fb604b356ae109b6e608" translate="yes" xml:space="preserve">
          <source>OpenMode</source>
          <target state="translated">OpenMode</target>
        </trans-unit>
        <trans-unit id="528d57c38374a655a269ff7a2796f6152cc2b011" translate="yes" xml:space="preserve">
          <source>OpenPunctuation</source>
          <target state="translated">OpenPunctuation</target>
        </trans-unit>
        <trans-unit id="389682fb06c2c4c783f2fcf52cb3f6b658b5e3d8" translate="yes" xml:space="preserve">
          <source>OpenSemFlags</source>
          <target state="translated">OpenSemFlags</target>
        </trans-unit>
        <trans-unit id="1d32d2857ce9ece257ef7358389a75c0c4dd1605" translate="yes" xml:space="preserve">
          <source>OpenTypeFamilyD</source>
          <target state="translated">OpenTypeFamilyD</target>
        </trans-unit>
        <trans-unit id="8b0c300483c96f9ee4308ab45551ff569e61bab4" translate="yes" xml:space="preserve">
          <source>Opening and closing files</source>
          <target state="translated">打开和关闭文件</target>
        </trans-unit>
        <trans-unit id="a535bff5bb480bbb6c0b709154409086b9fa6c12" translate="yes" xml:space="preserve">
          <source>Opening files</source>
          <target state="translated">打开文件</target>
        </trans-unit>
        <trans-unit id="3ffea85c4926df7fcf793cfa4d81139f2c8578a1" translate="yes" xml:space="preserve">
          <source>Opens an editor to edit the file ⟨file⟩, or the most recently loaded module if ⟨file⟩ is omitted. If there were errors during the last loading, the cursor will be positioned at the line of the first error. The editor to invoke is taken from the &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; environment variable, or a default editor on your system if &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; is not set. You can change the editor using &lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt;&lt;code&gt;:set editor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开编辑器来编辑文件&amp;ldquo;文件&amp;rdquo;，如果省略了&amp;ldquo;文件&amp;rdquo;，则打开最近加载的模块。如果在上一次加载期间发生错误，则光标将位于第一个错误的行。调用的编辑器取自 &lt;code id=&quot;index-24&quot;&gt;EDITOR&lt;/code&gt; 环境变量，如果未设置 &lt;code id=&quot;index-25&quot;&gt;EDITOR&lt;/code&gt; ，则取自系统上的默认编辑器。您可以使用&lt;a href=&quot;#ghci-cmd-:set%20editor&quot;&gt; &lt;code&gt;:set editor&lt;/code&gt; &lt;/a&gt;更改编辑器。</target>
        </trans-unit>
        <trans-unit id="ab766ba42381e7e73d60b327225011551bd62285" translate="yes" xml:space="preserve">
          <source>Opens an existing file and creates mapping object to it.</source>
          <target state="translated">打开现有的文件,并为其创建映射对象。</target>
        </trans-unit>
        <trans-unit id="b2e30baf3d135ff701a189f664d0aa02d8bc535e" translate="yes" xml:space="preserve">
          <source>Operate on the current user&amp;rsquo;s local package database. This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">在当前用户的本地软件包数据库上进行操作。此标志影响 &lt;code&gt;register&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; ， &lt;code&gt;unregister&lt;/code&gt; ， &lt;code&gt;expose&lt;/code&gt; 和 &lt;code&gt;hide&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="083cd84d11675eeddb18e443e875f6b6a3d95c50" translate="yes" xml:space="preserve">
          <source>Operate on the global package database (this is the default). This flag affects the &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt;, and &lt;code&gt;hide&lt;/code&gt; commands.</source>
          <target state="translated">在全局软件包数据库上操作（这是默认设置）。此标志影响 &lt;code&gt;register&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; ， &lt;code&gt;unregister&lt;/code&gt; ， &lt;code&gt;expose&lt;/code&gt; 和 &lt;code&gt;hide&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="bf70e187ccc63f90f3e1fb5ec071ddb81220b4ff" translate="yes" xml:space="preserve">
          <source>Operating on the raw buffer as a Ptr</source>
          <target state="translated">将原始缓冲区作为一个Ptr进行操作。</target>
        </trans-unit>
        <trans-unit id="212e24ce1fc682d740e1dca655f0849d8ec6b1da" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation (&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;).</source>
          <target state="translated">操作注释以Big-O表示法（&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;）包含操作时间复杂度。</target>
        </trans-unit>
        <trans-unit id="d406e280888f6ee17e0a89e460fa2b59971be7ca" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation (&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;).</source>
          <target state="translated">操作注释以Big-O表示法（&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;）包含操作时间复杂度。</target>
        </trans-unit>
        <trans-unit id="30b4c034f9dfce3148616876e4eb785c3c71ce25" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">操作注释以Big-O表示法&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;包含操作时间的复杂性。许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算的元素数可以线性化，最大为&lt;em&gt;W&lt;/em&gt; - &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数（32或64）。</target>
        </trans-unit>
        <trans-unit id="cc94aba5ba9874c8ccd3a8b0bd8fc45a51ca4e90" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">操作注释以Big-O表示法&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;包含操作时间的复杂性。许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算可以在最大为&lt;em&gt;W&lt;/em&gt;的元素数量（即 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数）（32或64）中变为线性。</target>
        </trans-unit>
        <trans-unit id="712a3b6a43e62927dad08ad34e3618de34bf7041" translate="yes" xml:space="preserve">
          <source>Operation comments contain the operation time complexity in the Big-O notation &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;. Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">操作注释以Big-O表示法&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;http://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;包含操作时间的复杂性。许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算可以在最大为&lt;em&gt;W&lt;/em&gt;的元素数量（即 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数）（32或64）中变为线性。</target>
        </trans-unit>
        <trans-unit id="1956fb1b777c2f5cb51b9aa2d865337af0a8590e" translate="yes" xml:space="preserve">
          <source>Operationally, in a dictionary-passing implementation, the constructors &lt;code&gt;Baz1&lt;/code&gt; and &lt;code&gt;Baz2&lt;/code&gt; must store the dictionaries for &lt;code&gt;Eq&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt; respectively, and extract it on pattern matching.</source>
          <target state="translated">在操作上，在传递字典的实现中，构造函数 &lt;code&gt;Baz1&lt;/code&gt; 和 &lt;code&gt;Baz2&lt;/code&gt; 必须分别存储 &lt;code&gt;Eq&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; 的字典，并在模式匹配时将其提取。</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="010424427c51ae459956824d4f41c5856a7d7600" translate="yes" xml:space="preserve">
          <source>Operations for composing transactions: &lt;code&gt;retry&lt;/code&gt;, and &lt;code&gt;orElse&lt;/code&gt;.</source>
          <target state="translated">组成交易的操作： &lt;code&gt;retry&lt;/code&gt; 和 &lt;code&gt;orElse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64c6bfa202489b3690a8497e85422b7af3c47ee6" translate="yes" xml:space="preserve">
          <source>Operations for creating and interacting with sub-processes.</source>
          <target state="translated">创建子流程并与子流程互动的操作。</target>
        </trans-unit>
        <trans-unit id="63e9af41f1576e5aa52ffaa696122d209a87d569" translate="yes" xml:space="preserve">
          <source>Operations for injecting values of arbitrary type into a dynamically typed value, Dynamic, are provided, together with operations for converting dynamic values into a concrete (monomorphic) type.</source>
          <target state="translated">提供了将任意类型的值注入到动态类型的值--Dynamic中的操作,以及将动态值转换为具体(单态)类型的操作。</target>
        </trans-unit>
        <trans-unit id="dfa672f70c432a2f16141a0afca1b4ff49e644e5" translate="yes" xml:space="preserve">
          <source>Operations on &lt;code&gt;Float&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; numbers are &lt;em&gt;unchecked&lt;/em&gt; for overflow, underflow, and other sad occurrences. (note, however, that some architectures trap floating-point overflow and loss-of-precision and report a floating-point exception, probably terminating the program)</source>
          <target state="translated">在操作 &lt;code&gt;Float&lt;/code&gt; 和 &lt;code&gt;Double&lt;/code&gt; 数字是&lt;em&gt;选中&lt;/em&gt;了溢，下溢，和其他伤心的事件。（但是请注意，某些体系结构会捕获浮点溢出和精度损失，并报告浮点异常，可能会终止程序）</target>
        </trans-unit>
        <trans-unit id="70b889a0601ca0e0323fbe3001c86239d52c2976" translate="yes" xml:space="preserve">
          <source>Operations on handles</source>
          <target state="translated">对手柄的操作</target>
        </trans-unit>
        <trans-unit id="251fdb8c40a857d5de5aef3683ba18da16bd56ad" translate="yes" xml:space="preserve">
          <source>Operations on lists.</source>
          <target state="translated">对名单的操作:</target>
        </trans-unit>
        <trans-unit id="a187376dc1defee65e37c92ba05a3b6fa77db72f" translate="yes" xml:space="preserve">
          <source>Operations whose result would be negative &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;
 (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt;,</source>
          <target state="translated">操作，其结果将是负的 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt; (&lt;a href=&quot;control-exception#v:Underflow&quot;&gt;Underflow&lt;/a&gt; :: &lt;a href=&quot;control-exception#v:ArithException&quot;&gt;ArithException&lt;/a&gt;)&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="d4f31eb6a5e978c610c6b257f8e92dc5ac9b8f36" translate="yes" xml:space="preserve">
          <source>Operator symbols become type &lt;em&gt;constructors&lt;/em&gt; rather than type &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">运算符成为类型&lt;em&gt;构造函数，&lt;/em&gt;而不是类型&lt;em&gt;变量&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="df4aab8de9b7c877a7baeb4198669b3c5323bb26" translate="yes" xml:space="preserve">
          <source>Operator symbols in types can be written infix, both in definitions and uses. For example:</source>
          <target state="translated">类型中的操作符符号可以写成infix,在定义和使用中都可以。比如说</target>
        </trans-unit>
        <trans-unit id="deefc1ebb8a6a9e9d71ba863ed305fcb6f2e73df" translate="yes" xml:space="preserve">
          <source>OperatorTable</source>
          <target state="translated">OperatorTable</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e8b0a981c3293cd72332580a9bfaa03f3df518cf" translate="yes" xml:space="preserve">
          <source>OptDescr</source>
          <target state="translated">OptDescr</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b293465e066906a2876636d4afb03e8ac6cf2ddc" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit from the current process)</source>
          <target state="translated">可选环境(否则从当前进程继承)</target>
        </trans-unit>
        <trans-unit id="dd55d6c6a66ab5ddbc36d53946c786320ec3587d" translate="yes" xml:space="preserve">
          <source>Optional environment (otherwise inherit)</source>
          <target state="translated">可选环境(否则继承)</target>
        </trans-unit>
        <trans-unit id="0f14588d7b9710ada9394bfeaff05157c6f2476d" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory</source>
          <target state="translated">工作目录的可选路径</target>
        </trans-unit>
        <trans-unit id="d91392285a0151b95f54b71ab44e6f6e738b5437" translate="yes" xml:space="preserve">
          <source>Optional path to the working directory for the new process</source>
          <target state="translated">新进程工作目录的可选路径。</target>
        </trans-unit>
        <trans-unit id="f439f2ba967862c2d5e67c16eed9a8d3ce132e3a" translate="yes" xml:space="preserve">
          <source>Optionally, the program may be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;. This provides two benefits:</source>
          <target state="translated">（可选）程序可以与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项&lt;a href=&quot;phases#options-linker&quot;&gt;链接&lt;/a&gt;（请参阅影响链接的选项。这提供了两个好处：</target>
        </trans-unit>
        <trans-unit id="150df3ba8f1d25b3d2442fb251bd0b8739a08f6c" translate="yes" xml:space="preserve">
          <source>Options can be forced through to a particular compilation phase, using the following flags:</source>
          <target state="translated">使用以下标志,可以将选项强制到特定的编译阶段。</target>
        </trans-unit>
        <trans-unit id="07de4eb670ca9b55e22ab8e74a884db849e506ae" translate="yes" xml:space="preserve">
          <source>Options may also be modified from within GHCi, using the &lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">也可以使用&lt;a href=&quot;ghci#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;命令从GHCi内部修改选项。</target>
        </trans-unit>
        <trans-unit id="bbc525524ba745988196c2cf239dca851f2646d3" translate="yes" xml:space="preserve">
          <source>Or I could define a simple way to invoke &amp;ldquo;&lt;code&gt;ghc --make Main&lt;/code&gt;&amp;rdquo; in the current directory:</source>
          <target state="translated">或者，我可以定义一种简单的方法来在当前目录中调用&amp;ldquo; &lt;code&gt;ghc --make Main&lt;/code&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="ed5f6d189422866d42c01faf2773a8db4acd9c2a" translate="yes" xml:space="preserve">
          <source>Or even simpler using applicative style:</source>
          <target state="translated">或者更简单的使用应用性风格。</target>
        </trans-unit>
        <trans-unit id="c3af411739703165e3837288b0679427c0978621" translate="yes" xml:space="preserve">
          <source>Or in a standalone deriving declaration</source>
          <target state="translated">或者在一个独立的派生声明中</target>
        </trans-unit>
        <trans-unit id="9e0ef2f0808aa7783d6cf8e9c6f90e88d912e8e1" translate="yes" xml:space="preserve">
          <source>Or using guards:</source>
          <target state="translated">或者使用防护罩。</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="2813ca76372ef7834dbf7b83dd19ec3f7be3b60a" translate="yes" xml:space="preserve">
          <source>Ord</source>
          <target state="translated">Ord</target>
        </trans-unit>
        <trans-unit id="f5167f3705089803c8512ac674241dfd7724cb93" translate="yes" xml:space="preserve">
          <source>Ord1</source>
          <target state="translated">Ord1</target>
        </trans-unit>
        <trans-unit id="a846bf09723a1322f808ad711f192bb56fbfbec4" translate="yes" xml:space="preserve">
          <source>Ord2</source>
          <target state="translated">Ord2</target>
        </trans-unit>
        <trans-unit id="f67c47b80d23bf9aafb12517fa70e43e75dc9ce1" translate="yes" xml:space="preserve">
          <source>Ordered ByteStrings</source>
          <target state="translated">有序ByteStrings</target>
        </trans-unit>
        <trans-unit id="6b5d4e1e91de3c24915fa410d3ac4a21868bffb0" translate="yes" xml:space="preserve">
          <source>Ordered list</source>
          <target state="translated">订购清单</target>
        </trans-unit>
        <trans-unit id="9bed071603b37f170248ba8799e9c1e267fbd2f5" translate="yes" xml:space="preserve">
          <source>Ordered lists</source>
          <target state="translated">订购清单</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="5ee1f118f806c2954ead1243461f8f5c2a0d2524" translate="yes" xml:space="preserve">
          <source>Ordering of &lt;code&gt;-l&lt;/code&gt; options matters: a library should be mentioned &lt;em&gt;before&lt;/em&gt; the libraries it depends on (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 选项的顺序很重要：应该在依赖它的库&lt;em&gt;之前&lt;/em&gt;提及一个库（请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="026197d403291a7a7c724e41228f7b3923b83a89" translate="yes" xml:space="preserve">
          <source>Orderings</source>
          <target state="translated">Orderings</target>
        </trans-unit>
        <trans-unit id="4cd6b596de672da2114ba27b5d0928eebf93910e" translate="yes" xml:space="preserve">
          <source>Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected results. Consider this (artificial) example</source>
          <target state="translated">普通内联与规则重写同时发生,这可能会导致意想不到的结果。考虑一下这个(人为的)例子</target>
        </trans-unit>
        <trans-unit id="04b00cb26f97f959a02aa6ce19955a72b8bd0a5f" translate="yes" xml:space="preserve">
          <source>Ordinary single-threaded Haskell programs will not benefit from enabling SMP parallelism alone: you must expose parallelism to the compiler. One way to do so is forking threads using Concurrent Haskell (&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;), but the simplest mechanism for extracting parallelism from pure code is to use the &lt;code&gt;par&lt;/code&gt; combinator, which is closely related to (and often used with) &lt;code&gt;seq&lt;/code&gt;. Both of these are available from the &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;parallel library&lt;/a&gt;:</source>
          <target state="translated">普通的单线程Haskell程序将不能从仅启用SMP并行性中受益：您必须向编译器公开并行性。一种方法是使用Concurrent Haskell（&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;）分叉线程，但是从纯代码中提取并行性的最简单机制是使用 &lt;code&gt;par&lt;/code&gt; 组合器，该组合器与 &lt;code&gt;seq&lt;/code&gt; 密切相关（并且经常与seq一起使用）。这两个都可以从&lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;并行库中获得&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6bd9604a31679a1b6cab41ca7a57157d1b8ed083" translate="yes" xml:space="preserve">
          <source>Ordinary single-threaded Haskell programs will not benefit from enabling SMP parallelism alone: you must expose parallelism to the compiler. One way to do so is forking threads using Concurrent Haskell (&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;), but the simplest mechanism for extracting parallelism from pure code is to use the &lt;code&gt;par&lt;/code&gt; combinator, which is closely related to (and often used with) &lt;code&gt;seq&lt;/code&gt;. Both of these are available from the &lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;parallel library&lt;/a&gt;:</source>
          <target state="translated">普通的单线程Haskell程序将不能从仅启用SMP并行性中受益：您必须向编译器公开并行性。一种方法是使用Concurrent Haskell（&lt;a href=&quot;#concurrent-haskell&quot;&gt;Concurrent Haskell&lt;/a&gt;）分叉线程，但是从纯代码中提取并行性的最简单机制是使用 &lt;code&gt;par&lt;/code&gt; 组合器，该组合器与 &lt;code&gt;seq&lt;/code&gt; 密切相关（并且经常与seq一起使用）。这两个都可以从&lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;并行库中获得&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a9e54f5fa5a278d112dceef67452d2651ffb1f7b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow 重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了扩展。Duncan Coutts和Don Stewart的懒惰变体。</target>
        </trans-unit>
        <trans-unit id="93598ac808fb05625f35e4f620de0f0e53817bdf" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow 重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了扩展。</target>
        </trans-unit>
        <trans-unit id="cb8e5613ec2d48a74c172ac7aa02cac4bef17d2b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow将其重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了重写。邓肯&amp;middot;库茨（Duncan Coutts）和唐&amp;middot;斯图尔特（Don Stewart）的懒惰变体。</target>
        </trans-unit>
        <trans-unit id="74c96e5b47a54e6acfda288d441c2ec8fe32131b" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow将其重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了重写。</target>
        </trans-unit>
        <trans-unit id="5ac9bf5abb7e2927464a8a8c0144eea1f76b2254" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow将其重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了重写。邓肯&amp;middot;库茨（Duncan Coutts）和唐&amp;middot;斯图尔特（Don Stewart）的懒惰变体。</target>
        </trans-unit>
        <trans-unit id="5a6184f79266c0c8ca2fefd80e809b07e3b7285f" translate="yes" xml:space="preserve">
          <source>Original GHC implementation by Bryan O'Sullivan. Rewritten to use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; by Simon Marlow. Rewritten to support slices and use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts.</source>
          <target state="translated">Bryan O'Sullivan最初执行的GHC。Simon Marlow将其重写为使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。重写以支持切片，用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由戴维&amp;middot;罗迪。唐&amp;middot;斯图尔特（Don Stewart）和邓肯&amp;middot;库茨（Duncan Coutts）再次对其进行了重写。</target>
        </trans-unit>
        <trans-unit id="1b9ce637b76a3e86159754092a5bff05de23030c" translate="yes" xml:space="preserve">
          <source>Originally designed by John Hughes's and Simon Peyton Jones's.</source>
          <target state="translated">最初是由约翰-休斯的和西蒙-佩顿-琼斯的设计。</target>
        </trans-unit>
        <trans-unit id="e0d11db984918c900a2e7615ec383a5f3eade238" translate="yes" xml:space="preserve">
          <source>Orphan instances</source>
          <target state="translated">孤儿实例</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="5ad09dd090c8718838113f73d1171adb4a590c71" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">其他 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 操作与冲突&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;或&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;前奏&lt;/a&gt;功能然而，那他们应该引进 &lt;code&gt;qualified&lt;/code&gt; 有不同的别名如</target>
        </trans-unit>
        <trans-unit id="97d83121e95b29befe338184898beb90ca66afb8" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">其他 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 操作与冲突&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;或&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;前奏&lt;/a&gt;功能然而，那他们应该引进 &lt;code&gt;qualified&lt;/code&gt; 有不同的别名如</target>
        </trans-unit>
        <trans-unit id="e39b33ae7ad3b3c8dfa98b425e86edd01f297a5b" translate="yes" xml:space="preserve">
          <source>Other &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; operations clash with &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; or &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions however, so they should be imported &lt;code&gt;qualified&lt;/code&gt; with a different alias e.g.</source>
          <target state="translated">其他 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 操作与冲突&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;或&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;前奏&lt;/a&gt;功能然而，那他们应该引进 &lt;code&gt;qualified&lt;/code&gt; 有不同的别名如</target>
        </trans-unit>
        <trans-unit id="d7d5fbcca333f989fd2b0f0cf8199618b39f1bd3" translate="yes" xml:space="preserve">
          <source>Other Haskell systems do not currently support multiple operating system threads.</source>
          <target state="translated">其他Haskell系统目前不支持多个操作系统线程。</target>
        </trans-unit>
        <trans-unit id="778e98a9766b655c4f188fb5d617327629ecdb0a" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">图形应用程序并发Haskell调试器（&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;）等其他应用程序也可能出于其目的选择重载 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9086a30a19ab20bd7cd31262ef8e704a3c0e4890" translate="yes" xml:space="preserve">
          <source>Other applications like the graphical Concurrent Haskell Debugger (&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;) may choose to overload &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; for their purposes as well.</source>
          <target state="translated">图形应用程序并发Haskell调试器（&lt;a href=&quot;http://www.informatik.uni-kiel.de/~fhu/chd/&quot;&gt;http://www.informatik.uni-kiel.de/~fhu/chd/&lt;/a&gt;）等其他应用程序也可能出于其目的选择重载 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:labelThread&quot;&gt;labelThread&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31deb74a58fba669a7c2cb31b6bed8515ab85d00" translate="yes" xml:space="preserve">
          <source>Other combinators</source>
          <target state="translated">其他组合体</target>
        </trans-unit>
        <trans-unit id="f717c91b4ff7b4e9135a9458b2f8146b78bb74a3" translate="yes" xml:space="preserve">
          <source>Other operations</source>
          <target state="translated">其他业务</target>
        </trans-unit>
        <trans-unit id="82169c7fc5215cf20135048050c38ee826497c85" translate="yes" xml:space="preserve">
          <source>Other operations such as &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; may return &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; as well as a dummy/place-holder value instead of &lt;code&gt;undefined&lt;/code&gt; since we can't throw exceptions. But that behaviour should not be relied upon.</source>
          <target state="translated">其他操作，例如 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:quotBigNat&quot;&gt;quotBigNat&lt;/a&gt;&lt;/code&gt; ,可能会返回 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;&lt;/code&gt; 以及一个虚拟值/占位符值，而不是 &lt;code&gt;undefined&lt;/code&gt; 值，因为我们不能抛出异常。但是，这种行为不应该被依靠。</target>
        </trans-unit>
        <trans-unit id="9047c6f96c316a252e973efb632599db44d02ce4" translate="yes" xml:space="preserve">
          <source>Other special syntax: sequences of characters that have a different meaning when this particular option is turned on.</source>
          <target state="translated">其他特殊语法:当这个特殊选项被打开时,具有不同意义的字符序列。</target>
        </trans-unit>
        <trans-unit id="91b29ffa8ce218d650e0c973969ab7a599e5a143" translate="yes" xml:space="preserve">
          <source>Other stuff</source>
          <target state="translated">其他东西</target>
        </trans-unit>
        <trans-unit id="4b372c318a0ac15f1e50d7fd1a01e206248a8e63" translate="yes" xml:space="preserve">
          <source>Other than these two caveats, users can always expect that a finalizer will be run after its weak pointer's object becomes unreachable. However, the second caveat means that users need to trust that all of their transitive dependencies do not throw exceptions in finalizers, since any finalizers can end up queued together.</source>
          <target state="translated">除了这两个注意事项之外,用户总是可以期望在其弱指针的对象变得无法到达之后,最终确定器会被运行。然而,第二个注意事项意味着用户需要相信他们所有的转义依赖不会在最终确定器中抛出异常,因为任何最终确定器都可能最终一起排队。</target>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="translated">其他类型</target>
        </trans-unit>
        <trans-unit id="c871109d68307ac18e84ee307aacea963e4970b3" translate="yes" xml:space="preserve">
          <source>Other uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are undefined. In particular, you should not use &lt;code&gt;unsafeCoerce#&lt;/code&gt; to cast a T to an algebraic data type D, unless T is also an algebraic data type. For example, do not cast &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt;, even if you later cast that &lt;code&gt;Bool&lt;/code&gt; back to &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; before applying it. The reasons have to do with GHC's internal representation details (for the cognoscenti, data values can be entered but function closures cannot). If you want a safe type to cast things to, use &lt;code&gt;Any&lt;/code&gt;, which is not an algebraic data type.</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 的其他用途是不确定的。特别是，除非T也是代数数据类型，否则不应使用 &lt;code&gt;unsafeCoerce#&lt;/code&gt; 将T转换为代数数据类型D。例如，请勿将 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 强制转换为 &lt;code&gt;Bool&lt;/code&gt; ，即使稍后在应用该 &lt;code&gt;Bool&lt;/code&gt; 之前将其转换为 &lt;code&gt;Int-&amp;gt;Int&lt;/code&gt; 。原因与GHC的内部表示详细信息有关（对于cognoscenti，可以输入数据值，但不能关闭函数）。如果要使用安全类型来强制转换，请使用 &lt;code&gt;Any&lt;/code&gt; ，这不是代数数据类型。</target>
        </trans-unit>
        <trans-unit id="3cca89d1c6f9e6b7edb2c91666360061ed277fff" translate="yes" xml:space="preserve">
          <source>OtherError</source>
          <target state="translated">OtherError</target>
        </trans-unit>
        <trans-unit id="b004f25ba2f862ca69a0ad498024ce48dcec48b4" translate="yes" xml:space="preserve">
          <source>OtherLetter</source>
          <target state="translated">OtherLetter</target>
        </trans-unit>
        <trans-unit id="79976ff76f967e06eb59c60ae5e3d4d8d8f1dea8" translate="yes" xml:space="preserve">
          <source>OtherNumber</source>
          <target state="translated">OtherNumber</target>
        </trans-unit>
        <trans-unit id="2fe5dcff8470fff0318c0b5bff7bb23017100fe8" translate="yes" xml:space="preserve">
          <source>OtherPunctuation</source>
          <target state="translated">OtherPunctuation</target>
        </trans-unit>
        <trans-unit id="7d352f6a13bd8fb7c6cafa22cba1529a45d2c13e" translate="yes" xml:space="preserve">
          <source>OtherSymbol</source>
          <target state="translated">OtherSymbol</target>
        </trans-unit>
        <trans-unit id="a8f27da35e68a9f7a5a97f1703ac92769848a8d4" translate="yes" xml:space="preserve">
          <source>Others have execute permission.</source>
          <target state="translated">其他人有执行权限。</target>
        </trans-unit>
        <trans-unit id="a4b5a656b29825a9211b83ccae7336ee695ce161" translate="yes" xml:space="preserve">
          <source>Others have read permission.</source>
          <target state="translated">其他人已经阅读了许可。</target>
        </trans-unit>
        <trans-unit id="25f01ea5949b3e11544a08901cd4fc6b386f3f43" translate="yes" xml:space="preserve">
          <source>Others have read, write and execute permission.</source>
          <target state="translated">其他人有读、写和执行权限。</target>
        </trans-unit>
        <trans-unit id="fc0d4f6a481380e178acd3897e6a60f3ade59b6a" translate="yes" xml:space="preserve">
          <source>Others have write permission.</source>
          <target state="translated">其他人有写权限。</target>
        </trans-unit>
        <trans-unit id="49385a99644f84243228dd0e51c68c048e901bf5" translate="yes" xml:space="preserve">
          <source>Otherwise GHC will solve the &lt;code&gt;HasCallStack&lt;/code&gt; constraint for the singleton &lt;code&gt;CallStack&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">否则，GHC将解决 &lt;code&gt;CallStack&lt;/code&gt; 包含当前呼叫站点的单例CallStack的 &lt;code&gt;HasCallStack&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="73b9866b09caa352e14869afa4a22348cbf03067" translate="yes" xml:space="preserve">
          <source>Otherwise there is exactly one non-incoherent candidate; call it the &amp;ldquo;prime candidate&amp;rdquo;.</source>
          <target state="translated">否则，只有一个非相干候选者；称其为&amp;ldquo;主要候选人&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fb76a4f7af9550821f6b9b31e5732f8573d196f6" translate="yes" xml:space="preserve">
          <source>Otherwise uses home directory returned by &lt;code&gt;getpwuid_r&lt;/code&gt; using the UID of the current proccesses user. This basically reads the &lt;em&gt;etc&lt;/em&gt;passwd file. An empty home directory field is considered valid.</source>
          <target state="translated">否则，使用当前进程用户的UID使用 &lt;code&gt;getpwuid_r&lt;/code&gt; 返回的主目录。这基本上是读取&lt;em&gt;etc&lt;/em&gt; passwd文件。空的主目录字段被视为有效。</target>
        </trans-unit>
        <trans-unit id="165546d2f6cedba70f1aef6539fe75331eec72db" translate="yes" xml:space="preserve">
          <source>Otherwise, in the common case of a simple type error such as typing &lt;code&gt;reverse True&lt;/code&gt; at the prompt, you would get a warning and then an immediately-following type error when the expression is evaluated.</source>
          <target state="translated">否则，在简单类型错误的常见情况下（例如在提示符下键入 &lt;code&gt;reverse True&lt;/code&gt; )，在计算表达式时，您将得到警告，然后是紧随其后的类型错误。</target>
        </trans-unit>
        <trans-unit id="9328699bfa5be08b83f54b0c37225de2cd8e0bd2" translate="yes" xml:space="preserve">
          <source>Otherwise, it behaves like &lt;code&gt;ghc-pkg list&lt;/code&gt;, including options.</source>
          <target state="translated">否则，其行为类似于 &lt;code&gt;ghc-pkg list&lt;/code&gt; ，包括选项。</target>
        </trans-unit>
        <trans-unit id="122c01da0c009875e86f7f7f7990dd90b8f65d05" translate="yes" xml:space="preserve">
          <source>Out of scope term variables</source>
          <target state="translated">范围外的术语变量</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dcd804196c4ab4c07a7fb9d32d6dd85f499cdd67" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 输出到 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 被直接执行对的缓冲器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。如果缓冲区太小（或不存在），则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="ce49a024c5b74db9ad28503714f87c2bd1cb09a1" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 输出到 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 被直接执行对的缓冲器 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。如果缓冲区太小（或不存在），则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="b818c7ed10da88db6cfc0ecfcf848d9e7f16f19d" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is executed directly on the buffer of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. If the buffer is too small (or not present), then it is replaced with a large enough buffer.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 输出到 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 被直接执行对的缓冲器 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。如果缓冲区太小（或不存在），则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="faccf69b130383a7a701fa6e58ffeb062f573f54" translate="yes" xml:space="preserve">
          <source>Output errors in reverse order</source>
          <target state="translated">按相反顺序输出错误</target>
        </trans-unit>
        <trans-unit id="5218d9a3d99e1852dea200794dafd520fce146d7" translate="yes" xml:space="preserve">
          <source>Output full span in error messages</source>
          <target state="translated">在错误信息中输出完整的跨度</target>
        </trans-unit>
        <trans-unit id="364167f7b761668d223893cadae4f828c7c2fa44" translate="yes" xml:space="preserve">
          <source>Output functions</source>
          <target state="translated">输出功能</target>
        </trans-unit>
        <trans-unit id="fbd84c24ac8d22f5181f1bc88f9671c4344d5b53" translate="yes" xml:space="preserve">
          <source>Output is returned strictly, so this is not suitable for launching processes that require interaction over the standard file streams.</source>
          <target state="translated">输出是严格返回的,所以不适合启动需要通过标准文件流进行交互的进程。</target>
        </trans-unit>
        <trans-unit id="d56117c403f664c3e1ed706f67f62dcab08add06" translate="yes" xml:space="preserve">
          <source>Output preprocessor dependencies. This only has an effect when the CPP language extension is enabled. These dependencies are files included with the &lt;code&gt;#include&lt;/code&gt; preprocessor directive (as well as transitive includes) and implicitly included files such as standard c preprocessor headers and a GHC version header. One exception to this is that GHC generates a temporary header file (during compilation) containing package version macros. As this is only a temporary file that GHC will always generate, it is not output as a dependency.</source>
          <target state="translated">输出预处理器依赖性。这仅在启用CPP语言扩展时才有效。这些依赖项是 &lt;code&gt;#include&lt;/code&gt; 预处理程序指令（以及可传递包含）中包含的文件，以及隐式包含的文件，例如标准c预处理程序标头和GHC版本标头。一个例外是GHC会生成一个临时头文件（在编译过程中），其中包含程序包版本宏。由于这只是GHC始终生成的临时文件，因此不会作为依赖项输出。</target>
        </trans-unit>
        <trans-unit id="e103798c3274cee279fa6992b0f5932f325fa5ac" translate="yes" xml:space="preserve">
          <source>Output the &lt;code&gt;ghc-pkg&lt;/code&gt; version number.</source>
          <target state="translated">输出 &lt;code&gt;ghc-pkg&lt;/code&gt; 版本号。</target>
        </trans-unit>
        <trans-unit id="ec3a20e9b85c9c73b5f9e136d68ee50ad77983fe" translate="yes" xml:space="preserve">
          <source>Output the HTML without adding newlines or spaces within the markup. This should be the most time and space efficient way to render HTML, though the ouput is quite unreadable.</source>
          <target state="translated">输出HTML时,不在标记中添加换行或空格。这应该是最节省时间和空间的渲染HTML的方式,尽管输出的结果很难读。</target>
        </trans-unit>
        <trans-unit id="ed8e0c3be25bb282bdb7ed21575be0568a2ea8ce" translate="yes" xml:space="preserve">
          <source>Output version information and exit successfully.</source>
          <target state="translated">输出版本信息,成功退出。</target>
        </trans-unit>
        <trans-unit id="d76b710eda6d9732ae60ae3688eb9124d03137ca" translate="yes" xml:space="preserve">
          <source>OutputCap</source>
          <target state="translated">OutputCap</target>
        </trans-unit>
        <trans-unit id="3210573c1fb5e651cb8a6253bec6053d0ba32e16" translate="yes" xml:space="preserve">
          <source>OutputQueue</source>
          <target state="translated">OutputQueue</target>
        </trans-unit>
        <trans-unit id="1478d601c03c445a904d445d7c3e8cec48d16838" translate="yes" xml:space="preserve">
          <source>OutputUnderflow</source>
          <target state="translated">OutputUnderflow</target>
        </trans-unit>
        <trans-unit id="2bbfd1ba36d0c76586f52911ecb048b6eac561d8" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3921704966c02cc64ce4b5f314c1cf70c103f53f" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a4926ef198c57eac920152c5f1336c7dea25039" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdabf64a0b25e97a2bcdfbcbab9832f9fb21a8e2" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce4268dda332085e9857fd93d80106998f5a9cf6" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94f000644f43d076248d928456d3f7341a4c922a" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2be19b4f59c90e2b571c4c57a78af1c21f19989" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入，因此仅hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="2b18f35ca8a8c8c01b6e67812f93b06a07030750" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入数据，因此单独使用hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="ec8b59c3ea192e5e077e239ed9da4cdcd1a63b27" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入数据，因此单独使用hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="b4f34b67d163777be1cfe43137e0b8aa27949758" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入，因此仅hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="92437970ef11779b851993774cf3f2a23f482a62" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入数据，因此单独使用hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="79d76c439f46d252acc194dd556956ea28ae0e26" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The chunks will be written one at a time. Other threads might write to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; between the writes, and hence &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; alone might not be suitable for concurrent writes.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 输出到指定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。这些块将一次写入一个。其他线程可能在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 写入之间向 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 写入数据，因此单独使用hPut可能不适用于并发写入。</target>
        </trans-unit>
        <trans-unit id="437c6c5b9e71301759333f52e620b482f7d4e6a3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输出缩进的HTML，并在元素内部缩进。这可以更改HTML文档的含义，并且对于调试HTML输出最有用。实现效率低下，通常最好使用 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9342f2cf13303d6a47b5d18b92f9cf13b2e5169" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输出缩进的HTML，并在元素内部缩进。这可以更改HTML文档的含义，并且对于调试HTML输出最有用。实现效率低下，通常最好使用 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19430befa515c2d9064f3110f0aa35abc26dd1f3" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML, with indentation inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">输出缩进的HTML，并在元素内部缩进。这可以更改HTML文档的含义，并且对于调试HTML输出最有用。实现效率低下，通常最好使用 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtml&quot;&gt;showHtml&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtml&quot;&gt;renderHtml&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="582cb8658b32442aec042d63a5cfab472fe58413" translate="yes" xml:space="preserve">
          <source>Outputs indented HTML. Because space matters in HTML, the output is quite messy.</source>
          <target state="translated">输出缩进的HTML。因为HTML中的空间很重要,所以输出的内容很乱。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
